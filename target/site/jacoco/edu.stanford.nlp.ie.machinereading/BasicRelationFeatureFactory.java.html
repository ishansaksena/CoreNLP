<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BasicRelationFeatureFactory.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.ie.machinereading</a> &gt; <span class="el_source">BasicRelationFeatureFactory.java</span></div><h1>BasicRelationFeatureFactory.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.ie.machinereading;
import edu.stanford.nlp.util.logging.Redwood;

import java.io.Serializable;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

import edu.stanford.nlp.ie.machinereading.structure.*;
import edu.stanford.nlp.ie.machinereading.structure.MachineReadingAnnotations.GenderAnnotation;
import edu.stanford.nlp.ie.machinereading.structure.MachineReadingAnnotations.TriggerAnnotation;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.ling.Datum;
import edu.stanford.nlp.ling.IndexedWord;
import edu.stanford.nlp.ling.RVFDatum;
import edu.stanford.nlp.ling.CoreAnnotations.TextAnnotation;
import edu.stanford.nlp.ling.CoreAnnotations.TokensAnnotation;
import edu.stanford.nlp.process.Morphology;
import edu.stanford.nlp.stats.ClassicCounter;
import edu.stanford.nlp.stats.Counter;
import edu.stanford.nlp.trees.EnglishGrammaticalRelations;
import edu.stanford.nlp.trees.GrammaticalRelation;
import edu.stanford.nlp.trees.GrammaticalStructure;
import edu.stanford.nlp.trees.Tree;
import edu.stanford.nlp.trees.TreeCoreAnnotations.TreeAnnotation;
import edu.stanford.nlp.semgraph.SemanticGraph;
import edu.stanford.nlp.semgraph.SemanticGraphCoreAnnotations;
import edu.stanford.nlp.semgraph.SemanticGraphEdge;
import edu.stanford.nlp.semgraph.SemanticGraphFactory;
import edu.stanford.nlp.semgraph.SemanticGraphFactory.Mode;
import edu.stanford.nlp.util.CoreMap;
import edu.stanford.nlp.util.StringUtils;

// XXX convert to BasicRelationFeatureFactory, make RelationFeatureFactory an interface


/**
 *  @author Mason Smith
 *  @author Mihai Surdeanu
 */
public class BasicRelationFeatureFactory extends RelationFeatureFactory implements Serializable  {

  /** A logger for this class */
<span class="nc" id="L50">  private static Redwood.RedwoodChannels log = Redwood.channels(BasicRelationFeatureFactory.class);</span>
  private static final long serialVersionUID = -7376668998622546620L;

<span class="nc" id="L53">  private static final Logger logger = Logger.getLogger(BasicRelationFeatureFactory.class.getName());</span>


<span class="nc" id="L56">  protected static final List&lt;String&gt; dependencyFeatures = Collections.unmodifiableList(Arrays.asList(</span>
          &quot;dependency_path_lowlevel&quot;,&quot;dependency_path_length&quot;,&quot;dependency_path_length_binary&quot;,
          &quot;verb_in_dependency_path&quot;,&quot;dependency_path&quot;,&quot;dependency_path_words&quot;,&quot;dependency_paths_to_verb&quot;,
          &quot;dependency_path_stubs_to_verb&quot;,
          &quot;dependency_path_POS_unigrams&quot;,
          &quot;dependency_path_word_n_grams&quot;,
          &quot;dependency_path_POS_n_grams&quot;,
          &quot;dependency_path_edge_n_grams&quot;,&quot;dependency_path_edge_lowlevel_n_grams&quot;,
          &quot;dependency_path_edge-node-edge-grams&quot;,&quot;dependency_path_edge-node-edge-grams_lowlevel&quot;,
          &quot;dependency_path_node-edge-node-grams&quot;,&quot;dependency_path_node-edge-node-grams_lowlevel&quot;,
          &quot;dependency_path_directed_bigrams&quot;,
          &quot;dependency_path_edge_unigrams&quot;,
          &quot;dependency_path_trigger&quot;
  ));

  protected List&lt;String&gt; featureList;



<span class="nc" id="L75">  public BasicRelationFeatureFactory(String... featureList) {</span>
<span class="nc" id="L76">    this.doNotLexicalizeFirstArg = false;</span>
<span class="nc" id="L77">    this.dependencyType = DEPENDENCY_TYPE.COLLAPSED_CCPROCESSED;</span>
<span class="nc" id="L78">    this.featureList = Collections.unmodifiableList(Arrays.asList(featureList));</span>
<span class="nc" id="L79">  }</span>

  static {
<span class="nc" id="L82">    logger.setLevel(Level.INFO);</span>
<span class="nc" id="L83">  }</span>


  public Datum&lt;String,String&gt; createDatum(RelationMention rel) {
<span class="nc" id="L87">    return createDatum(rel, (Logger) null);</span>
  }

  public Datum&lt;String,String&gt; createDatum(RelationMention rel, Logger logger) {
<span class="nc" id="L91">    Counter&lt;String&gt; features = new ClassicCounter&lt;&gt;();</span>
<span class="nc bnc" id="L92" title="All 2 branches missed.">    if (rel.getArgs().size() != 2) {</span>
<span class="nc" id="L93">      return null;</span>
    }

<span class="nc" id="L96">    addFeatures(features, rel, featureList, logger);</span>

<span class="nc" id="L98">    String labelString = rel.getType();</span>
<span class="nc" id="L99">    return new RVFDatum&lt;&gt;(features, labelString);</span>
  }

  @Override
  public Datum&lt;String, String&gt; createTestDatum(RelationMention rel, Logger logger) {
<span class="nc" id="L104">    return createDatum(rel, logger);</span>
  }

  public Datum&lt;String,String&gt; createDatum(RelationMention rel, String positiveLabel) {
<span class="nc" id="L108">    Counter&lt;String&gt; features = new ClassicCounter&lt;&gt;();</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">    if (rel.getArgs().size() != 2) {</span>
<span class="nc" id="L110">      return null;</span>
    }

<span class="nc" id="L113">    addFeatures(features, rel, featureList);</span>

<span class="nc" id="L115">    String labelString = rel.getType();</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">    if(! labelString.equals(positiveLabel)) labelString = RelationMention.UNRELATED;</span>
<span class="nc" id="L117">    return new RVFDatum&lt;&gt;(features, labelString);</span>
  }

  public boolean addFeatures(Counter&lt;String&gt; features, RelationMention rel, List&lt;String&gt; types) {
<span class="nc" id="L121">    return addFeatures(features, rel, types, null);</span>
  }

  /**
   * Creates all features for the datum corresponding to this relation mention
   * Note: this assumes binary relations where both arguments are EntityMention
   * @param features Stores all features
   * @param rel The mention
   * @param types Comma separated list of feature classes to use
   */
  public boolean addFeatures(Counter&lt;String&gt; features, RelationMention rel, List&lt;String&gt; types, Logger logger) {
    // sanity checks: must have two arguments, and each must be an entity mention
<span class="nc bnc" id="L133" title="All 2 branches missed.">    if(rel.getArgs().size() != 2) return false;</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">    if(! (rel.getArg(0) instanceof EntityMention)) return false;</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">    if(! (rel.getArg(1) instanceof EntityMention)) return false;</span>

<span class="nc" id="L137">    EntityMention arg0 = (EntityMention) rel.getArg(0);</span>
<span class="nc" id="L138">    EntityMention arg1 = (EntityMention) rel.getArg(1);</span>

<span class="nc" id="L140">    Tree tree = rel.getSentence().get(TreeAnnotation.class);</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">    if(tree == null){</span>
<span class="nc" id="L142">      throw new RuntimeException(&quot;ERROR: Relation extraction requires full syntactic analysis!&quot;);</span>
    }
<span class="nc" id="L144">    List&lt;Tree&gt; leaves = tree.getLeaves();</span>
<span class="nc" id="L145">    List&lt;CoreLabel&gt; tokens = rel.getSentence().get(TokensAnnotation.class);</span>

    // this assumes that both args are in the same sentence as the relation object
    // let's check for this to be safe
<span class="nc" id="L149">    CoreMap relSentence = rel.getSentence();</span>
<span class="nc" id="L150">    CoreMap arg0Sentence = arg0.getSentence();</span>
<span class="nc" id="L151">    CoreMap arg1Sentence = arg1.getSentence();</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">    if(arg0Sentence != relSentence){</span>
<span class="nc" id="L153">      log.info(&quot;WARNING: Found relation with arg0 in a different sentence: &quot; + rel);</span>
<span class="nc" id="L154">      log.info(&quot;Relation sentence: &quot; + relSentence.get(TextAnnotation.class));</span>
<span class="nc" id="L155">      log.info(&quot;Arg0 sentence: &quot; + arg0Sentence.get(TextAnnotation.class));</span>
<span class="nc" id="L156">      return false;</span>
    }
<span class="nc bnc" id="L158" title="All 2 branches missed.">    if(arg1Sentence != relSentence){</span>
<span class="nc" id="L159">      log.info(&quot;WARNING: Found relation with arg1 in a different sentence: &quot; + rel);</span>
<span class="nc" id="L160">      log.info(&quot;Relation sentence: &quot; + relSentence.get(TextAnnotation.class));</span>
<span class="nc" id="L161">      log.info(&quot;Arg1 sentence: &quot; + arg1Sentence.get(TextAnnotation.class));</span>
<span class="nc" id="L162">      return false;</span>
    }

    // Checklist keeps track of which features have been handled by an if clause
    // Should be empty after all the clauses have been gone through.
<span class="nc" id="L167">    List&lt;String&gt; checklist = new ArrayList&lt;&gt;(types);</span>

    // arg_type: concatenation of the entity types of the args, e.g.
    // &quot;arg1type=Loc_and_arg2type=Org&quot;
    // arg_subtype: similar, for entity subtypes
<span class="nc bnc" id="L172" title="All 2 branches missed.">    if (usingFeature(types, checklist, &quot;arg_type&quot;)) {</span>
<span class="nc" id="L173">      features.setCount(&quot;arg1type=&quot; + arg0.getType() + &quot;_and_arg2type=&quot; + arg1.getType(), 1.0);</span>
    }
<span class="nc bnc" id="L175" title="All 2 branches missed.">    if (usingFeature(types,checklist,&quot;arg_subtype&quot;)) {</span>
<span class="nc" id="L176">      features.setCount(&quot;arg1subtype=&quot;+arg0.getSubType()+&quot;_and_arg2subtype=&quot;+arg1.getSubType(),1.0);</span>
    }

    // arg_order: which arg comes first in the sentence
<span class="nc bnc" id="L180" title="All 2 branches missed.">    if (usingFeature(types, checklist, &quot;arg_order&quot;)) {</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">      if (arg0.getSyntacticHeadTokenPosition() &lt; arg1.getSyntacticHeadTokenPosition())</span>
<span class="nc" id="L182">        features.setCount(&quot;arg1BeforeArg2&quot;, 1.0);</span>
    }
    // same_head: whether the two args share the same syntactic head token
<span class="nc bnc" id="L185" title="All 2 branches missed.">    if (usingFeature(types, checklist, &quot;same_head&quot;)) {</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">      if (arg0.getSyntacticHeadTokenPosition() == arg1.getSyntacticHeadTokenPosition())</span>
<span class="nc" id="L187">        features.setCount(&quot;arguments_have_same_head&quot;,1.0);</span>
    }

    // full_tree_path: Path from one arg to the other in the phrase structure tree,
    // e.g., NNP -&gt; PP -&gt; NN &lt;- NNP
<span class="nc bnc" id="L192" title="All 2 branches missed.">    if (usingFeature(types, checklist, &quot;full_tree_path&quot;)) {</span>
      //log.info(&quot;ARG0: &quot; + arg0);
      //log.info(&quot;ARG0 HEAD: &quot; + arg0.getSyntacticHeadTokenPosition());
      //log.info(&quot;TREE: &quot; + tree);
      //log.info(&quot;SENTENCE: &quot; + sentToString(arg0.getSentence()));
<span class="nc bnc" id="L197" title="All 4 branches missed.">      if(arg0.getSyntacticHeadTokenPosition() &lt; leaves.size() &amp;&amp; arg1.getSyntacticHeadTokenPosition() &lt; leaves.size()){</span>
<span class="nc" id="L198">        Tree arg0preterm = leaves.get(arg0.getSyntacticHeadTokenPosition()).parent(tree);</span>
<span class="nc" id="L199">        Tree arg1preterm = leaves.get(arg1.getSyntacticHeadTokenPosition()).parent(tree);</span>
<span class="nc" id="L200">        Tree join = tree.joinNode(arg0preterm, arg1preterm);</span>
<span class="nc" id="L201">        StringBuilder pathStringBuilder = new StringBuilder();</span>
<span class="nc" id="L202">        List&lt;Tree&gt; pathUp = join.dominationPath(arg0preterm);</span>
<span class="nc" id="L203">        Collections.reverse(pathUp);</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">        for (Tree node : pathUp) {</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">          if (node != join) {</span>
<span class="nc" id="L206">            pathStringBuilder.append(node.label().value() + &quot; &lt;- &quot;);</span>
          }
<span class="nc" id="L208">        }</span>

<span class="nc bnc" id="L210" title="All 2 branches missed.">        for (Tree node : join.dominationPath(arg1preterm)) {</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">          pathStringBuilder.append(((node == join) ? &quot;&quot; : &quot; -&gt; &quot;) + node.label().value());</span>
<span class="nc" id="L212">        }</span>
<span class="nc" id="L213">        String pathString = pathStringBuilder.toString();</span>
<span class="nc bnc" id="L214" title="All 4 branches missed.">        if(logger != null &amp;&amp; ! rel.getType().equals(RelationMention.UNRELATED)) logger.info(&quot;full_tree_path: &quot; + pathString);</span>
<span class="nc" id="L215">        features.setCount(&quot;treepath:&quot;+pathString, 1.0);</span>
<span class="nc" id="L216">      } else {</span>
<span class="nc" id="L217">        log.info(&quot;WARNING: found weird argument offsets. Most likely because arguments appear in different sentences than the relation:&quot;);</span>
<span class="nc" id="L218">        log.info(&quot;ARG0: &quot; + arg0);</span>
<span class="nc" id="L219">        log.info(&quot;ARG0 HEAD: &quot; + arg0.getSyntacticHeadTokenPosition());</span>
<span class="nc" id="L220">        log.info(&quot;ARG0 SENTENCE: &quot; + sentToString(arg0.getSentence()));</span>
<span class="nc" id="L221">        log.info(&quot;ARG1: &quot; + arg1);</span>
<span class="nc" id="L222">        log.info(&quot;ARG1 HEAD: &quot; + arg1.getSyntacticHeadTokenPosition());</span>
<span class="nc" id="L223">        log.info(&quot;ARG1 SENTENCE: &quot; + sentToString(arg1.getSentence()));</span>
<span class="nc" id="L224">        log.info(&quot;RELATION TREE: &quot; + tree);</span>
      }
    }

<span class="nc" id="L228">    int pathLength = tree.pathNodeToNode(tree.getLeaves().get(arg0.getSyntacticHeadTokenPosition()),</span>
<span class="nc" id="L229">            tree.getLeaves().get(arg1.getSyntacticHeadTokenPosition())).size();</span>
    // path_length: Length of the path in the phrase structure parse tree, integer-valued feature
<span class="nc bnc" id="L231" title="All 2 branches missed.">    if (usingFeature(types, checklist, &quot;path_length&quot;)) {</span>
<span class="nc" id="L232">      features.setCount(&quot;path_length&quot;, pathLength);</span>
    }
    // path_length_binary: Length of the path in the phrase structure parse tree, binary features
<span class="nc bnc" id="L235" title="All 2 branches missed.">    if (usingFeature(types, checklist, &quot;path_length_binary&quot;)) {</span>
<span class="nc" id="L236">      features.setCount(&quot;path_length_&quot; + pathLength, 1.0);</span>
    }

    /* entity_order
           * This tells you for each of the two args
           * whether there are other entities before or after that arg.
           * In particular, it can tell whether an arg is the first entity of its type in the sentence
           * (which can be useful for example for telling the gameWinner and gameLoser in NFL).
           * TODO: restrict this feature so that it only looks for
           * entities of the same type?
           * */
<span class="nc bnc" id="L247" title="All 2 branches missed.">    if (usingFeature(types, checklist, &quot;entity_order&quot;)) {</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">      for (int i = 0; i &lt; rel.getArgs().size(); i++) {</span>
        // We already checked the class of the args at the beginning of the method
<span class="nc" id="L250">        EntityMention arg = (EntityMention) rel.getArgs().get(i);</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">        if(rel.getSentence().get(MachineReadingAnnotations.EntityMentionsAnnotation.class) != null) { // may be null due to annotation error</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">          for (EntityMention otherArg : rel.getSentence().get(MachineReadingAnnotations.EntityMentionsAnnotation.class)) {</span>
            String feature;
<span class="nc bnc" id="L254" title="All 2 branches missed.">            if (otherArg.getSyntacticHeadTokenPosition() &gt; arg.getSyntacticHeadTokenPosition()) {</span>
<span class="nc" id="L255">              feature = &quot;arg&quot; + i + &quot;_before_&quot; + otherArg.getType();</span>
<span class="nc" id="L256">              features.setCount(feature, 1.0);</span>
            }
<span class="nc bnc" id="L258" title="All 2 branches missed.">            if (otherArg.getSyntacticHeadTokenPosition() &lt; arg.getSyntacticHeadTokenPosition()) {</span>
<span class="nc" id="L259">              feature = &quot;arg&quot; + i + &quot;_after_&quot; + otherArg.getType();</span>
<span class="nc" id="L260">              features.setCount(feature, 1.0);</span>
            }
<span class="nc" id="L262">          }</span>
        }
      }
    }

    // surface_distance: Number of tokens in the sentence between the two words, integer-valued feature
<span class="nc" id="L268">    int surfaceDistance = Math.abs(arg0.getSyntacticHeadTokenPosition() - arg1.getSyntacticHeadTokenPosition());</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">    if (usingFeature(types, checklist, &quot;surface_distance&quot;)) {</span>
<span class="nc" id="L270">      features.setCount(&quot;surface_distance&quot;, surfaceDistance);</span>
    }
    // surface_distance_binary: Number of tokens in the sentence between the two words, binary features
<span class="nc bnc" id="L273" title="All 2 branches missed.">    if (usingFeature(types, checklist, &quot;surface_distance_binary&quot;)) {</span>
<span class="nc" id="L274">      features.setCount(&quot;surface_distance_&quot; + surfaceDistance, 1.0);</span>
    }
    // surface_distance_bins: number of tokens between the two args, binned to several intervals
<span class="nc bnc" id="L277" title="All 2 branches missed.">    if(usingFeature(types, checklist, &quot;surface_distance_bins&quot;)) {</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">      if(surfaceDistance &lt; 4){</span>
<span class="nc" id="L279">        features.setCount(&quot;surface_distance_bin&quot; + surfaceDistance, 1.0);</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">      } else if(surfaceDistance &lt; 6){</span>
<span class="nc" id="L281">        features.setCount(&quot;surface_distance_bin_lt6&quot;, 1.0);</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">      } else if(surfaceDistance &lt; 10) {</span>
<span class="nc" id="L283">        features.setCount(&quot;surface_distance_bin_lt10&quot;, 1.0);</span>
      } else {
<span class="nc" id="L285">        features.setCount(&quot;surface_distance_bin_ge10&quot;, 1.0);</span>
      }
    }

    // separate_surface_windows: windows of 1,2,3 tokens before and after args, for each arg separately
    // Separate features are generated for windows to the left and to the right of the args.
    // Features are concatenations of words in the window (or NULL for sentence boundary).
    //
    // conjunction_surface_windows: concatenation of the windows of the two args
    //
    // separate_surface_windows_POS: windows of POS tags of size 1,2,3 for each arg
    //
    // conjunction_surface_windows_POS: concatenation of windows of the args

<span class="nc" id="L299">    List&lt;EntityMention&gt; args = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L300">    args.add(arg0); args.add(arg1);</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">    for (int windowSize = 1; windowSize &lt;= 3; windowSize++) {</span>

      String[] leftWindow, rightWindow, leftWindowPOS, rightWindowPOS;
<span class="nc" id="L304">      leftWindow = new String[2];</span>
<span class="nc" id="L305">      rightWindow = new String[2];</span>
<span class="nc" id="L306">      leftWindowPOS = new String[2];</span>
<span class="nc" id="L307">      rightWindowPOS = new String[2];</span>

<span class="nc bnc" id="L309" title="All 2 branches missed.">      for (int argn = 0; argn &lt;= 1; argn++) {</span>
<span class="nc" id="L310">        int ind = args.get(argn).getSyntacticHeadTokenPosition();</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">        for (int winnum = 1; winnum &lt;= windowSize; winnum++) {</span>
<span class="nc" id="L312">          int windex = ind - winnum;</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">          if (windex &gt; 0) {</span>
<span class="nc" id="L314">            leftWindow[argn] = leaves.get(windex).label().value() + &quot;_&quot; + leftWindow[argn];</span>
<span class="nc" id="L315">            leftWindowPOS[argn] = leaves.get(windex).parent(tree).label().value() + &quot;_&quot; + leftWindowPOS[argn];</span>
          } else {
<span class="nc" id="L317">            leftWindow[argn] = &quot;NULL_&quot; + leftWindow[argn];</span>
<span class="nc" id="L318">            leftWindowPOS[argn] = &quot;NULL_&quot; + leftWindowPOS[argn];</span>
          }
<span class="nc" id="L320">          windex = ind + winnum;</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">          if (windex &lt; leaves.size()) {</span>
<span class="nc" id="L322">            rightWindow[argn] = rightWindow[argn] + &quot;_&quot; + leaves.get(windex).label().value();</span>
<span class="nc" id="L323">            rightWindowPOS[argn] = rightWindowPOS[argn] + &quot;_&quot; + leaves.get(windex).parent(tree).label().value();</span>
          } else {
<span class="nc" id="L325">            rightWindow[argn] = rightWindow[argn] + &quot;_NULL&quot;;</span>
<span class="nc" id="L326">            rightWindowPOS[argn] = rightWindowPOS[argn] + &quot;_NULL&quot;;</span>
          }
        }
<span class="nc bnc" id="L329" title="All 2 branches missed.">        if (usingFeature(types, checklist, &quot;separate_surface_windows&quot;)) {</span>
<span class="nc" id="L330">          features.setCount(&quot;left_window_&quot;+windowSize+&quot;_arg_&quot; + argn + &quot;: &quot; + leftWindow[argn], 1.0);</span>
<span class="nc" id="L331">          features.setCount(&quot;left_window_&quot;+windowSize+&quot;_POS_arg_&quot; + argn + &quot;: &quot; + leftWindowPOS[argn], 1.0);</span>
        }
<span class="nc bnc" id="L333" title="All 2 branches missed.">        if (usingFeature(types, checklist, &quot;separate_surface_windows_POS&quot;)) {</span>
<span class="nc" id="L334">          features.setCount(&quot;right_window_&quot;+windowSize+&quot;_arg_&quot; + argn + &quot;: &quot; + rightWindow[argn], 1.0);</span>
<span class="nc" id="L335">          features.setCount(&quot;right_window_&quot;+windowSize+&quot;_POS_arg_&quot; + argn + &quot;: &quot; + rightWindowPOS[argn], 1.0);</span>
        }

      }
<span class="nc bnc" id="L339" title="All 2 branches missed.">      if (usingFeature(types, checklist, &quot;conjunction_surface_windows&quot;)) {</span>
<span class="nc" id="L340">        features.setCount(&quot;left_windows_&quot;+windowSize+&quot;: &quot; + leftWindow[0] + &quot;__&quot; + leftWindow[1], 1.0);</span>
<span class="nc" id="L341">        features.setCount(&quot;right_windows_&quot;+windowSize+&quot;: &quot; + rightWindow[0] + &quot;__&quot; + rightWindow[1], 1.0);</span>
      }
<span class="nc bnc" id="L343" title="All 2 branches missed.">      if (usingFeature(types, checklist, &quot;conjunction_surface_windows_POS&quot;)) {</span>
<span class="nc" id="L344">        features.setCount(&quot;left_windows_&quot;+windowSize+&quot;_POS: &quot; + leftWindowPOS[0] + &quot;__&quot; + leftWindowPOS[1], 1.0);</span>
<span class="nc" id="L345">        features.setCount(&quot;right_windows_&quot;+windowSize+&quot;_POS: &quot; + rightWindowPOS[0] + &quot;__&quot; + rightWindowPOS[1], 1.0);</span>
      }
    }

    // arg_words:  The actual arg tokens as separate features, and concatenated
<span class="nc" id="L350">    String word0 = leaves.get(arg0.getSyntacticHeadTokenPosition()).label().value();</span>
<span class="nc" id="L351">    String word1 = leaves.get(arg1.getSyntacticHeadTokenPosition()).label().value();</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">    if (usingFeature(types, checklist, &quot;arg_words&quot;)) {</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">      if(doNotLexicalizeFirstArg == false)</span>
<span class="nc" id="L354">        features.setCount(&quot;word_arg0: &quot; + word0, 1.0);</span>
<span class="nc" id="L355">      features.setCount(&quot;word_arg1: &quot; + word1, 1.0);</span>
<span class="nc bnc" id="L356" title="All 2 branches missed.">      if(doNotLexicalizeFirstArg == false)</span>
<span class="nc" id="L357">        features.setCount(&quot;words: &quot; + word0 + &quot;__&quot; + word1, 1.0);</span>
    }

    // arg_POS:  POS tags of the args, as separate features and concatenated
<span class="nc" id="L361">    String pos0 = leaves.get(arg0.getSyntacticHeadTokenPosition()).parent(tree).label().value();</span>
<span class="nc" id="L362">    String pos1 = leaves.get(arg1.getSyntacticHeadTokenPosition()).parent(tree).label().value();</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">    if (usingFeature(types, checklist, &quot;arg_POS&quot;)) {</span>
<span class="nc" id="L364">      features.setCount(&quot;POS_arg0: &quot; + pos0, 1.0);</span>
<span class="nc" id="L365">      features.setCount(&quot;POS_arg1: &quot; + pos1, 1.0);</span>
<span class="nc" id="L366">      features.setCount(&quot;POSs: &quot; + pos0 + &quot;__&quot; + pos1, 1.0);</span>
    }

    // adjacent_words: words immediately to the left and right of the args
<span class="nc bnc" id="L370" title="All 2 branches missed.">    if(usingFeature(types, checklist, &quot;adjacent_words&quot;)){</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">      for(int i = 0; i &lt; rel.getArgs().size(); i ++){</span>
<span class="nc" id="L372">        Span s = ((EntityMention) rel.getArg(i)).getHead();</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">        if(s.start() &gt; 0){</span>
<span class="nc" id="L374">          String v = tokens.get(s.start() - 1).word();</span>
<span class="nc" id="L375">          features.setCount(&quot;leftarg&quot; + i + &quot;-&quot; + v, 1.0);</span>
        }
<span class="nc bnc" id="L377" title="All 2 branches missed.">        if(s.end() &lt; tokens.size()){</span>
<span class="nc" id="L378">          String v = tokens.get(s.end()).word();</span>
<span class="nc" id="L379">          features.setCount(&quot;rightarg&quot; + i + &quot;-&quot; + v, 1.0);</span>
        }
      }
    }

    // entities_between_args:  binary feature for each type specifying whether there is an entity of that type in the sentence
    // between the two args.
    // e.g. &quot;entity_between_args: Loc&quot; means there is at least one entity of type Loc between the two args
<span class="nc bnc" id="L387" title="All 2 branches missed.">    if (usingFeature(types, checklist, &quot;entities_between_args&quot;)) {</span>
<span class="nc" id="L388">      CoreMap sent = rel.getSentence();</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">      if(sent == null) throw new RuntimeException(&quot;NULL sentence for relation &quot; + rel);</span>
<span class="nc" id="L390">      List&lt;EntityMention&gt; relArgs = sent.get(MachineReadingAnnotations.EntityMentionsAnnotation.class);</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">      if(relArgs != null) { // may be null due to annotation errors!</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">        for (EntityMention arg : relArgs) {</span>
<span class="nc bnc" id="L393" title="All 4 branches missed.">          if ((arg.getSyntacticHeadTokenPosition() &gt; arg0.getSyntacticHeadTokenPosition() &amp;&amp; arg.getSyntacticHeadTokenPosition() &lt; arg1.getSyntacticHeadTokenPosition())</span>
<span class="nc bnc" id="L394" title="All 4 branches missed.">                  || (arg.getSyntacticHeadTokenPosition() &gt; arg1.getSyntacticHeadTokenPosition() &amp;&amp; arg.getSyntacticHeadTokenPosition() &lt; arg0.getSyntacticHeadTokenPosition())) {</span>
<span class="nc" id="L395">            features.setCount(&quot;entity_between_args: &quot; + arg.getType(), 1.0);</span>
          }
<span class="nc" id="L397">        }</span>
      }
    }

    // entity_counts: For each type, the total number of entities of that type in the sentence (integer-valued feature)
    // entity_counts_binary: Counts of entity types as binary features.
<span class="nc" id="L403">    Counter&lt;String&gt; typeCounts = new ClassicCounter&lt;&gt;();</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">    if(rel.getSentence().get(MachineReadingAnnotations.EntityMentionsAnnotation.class) != null){ // may be null due to annotation errors!</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">      for (EntityMention arg : rel.getSentence().get(MachineReadingAnnotations.EntityMentionsAnnotation.class))</span>
<span class="nc" id="L406">        typeCounts.incrementCount(arg.getType());</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">      for (String type : typeCounts.keySet()) {</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">        if (usingFeature(types,checklist,&quot;entity_counts&quot;))</span>
<span class="nc" id="L409">          features.setCount(&quot;entity_counts_&quot;+type,typeCounts.getCount(type));</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">        if (usingFeature(types,checklist,&quot;entity_counts_binary&quot;))</span>
<span class="nc" id="L411">          features.setCount(&quot;entity_counts_&quot;+type+&quot;: &quot;+typeCounts.getCount(type),1.0);</span>
<span class="nc" id="L412">      }</span>
    }

    // surface_path: concatenation of tokens between the two args
    // surface_path_POS: concatenation of POS tags between the args
    // surface_path_selective: concatenation of tokens between the args which are nouns or verbs
<span class="nc" id="L418">    StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L419">    StringBuilder sbPOS = new StringBuilder();</span>
<span class="nc" id="L420">    StringBuilder sbSelective = new StringBuilder();</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">    for (int i = Math.min(arg0.getSyntacticHeadTokenPosition(), arg1.getSyntacticHeadTokenPosition()) + 1; i &lt; Math.max(arg0.getSyntacticHeadTokenPosition(), arg1.getSyntacticHeadTokenPosition()); i++) {</span>
<span class="nc" id="L422">      String word = leaves.get(i).label().value();</span>
<span class="nc" id="L423">      sb.append(word + &quot;_&quot;);</span>
<span class="nc" id="L424">      String pos = leaves.get(i).parent(tree).label().value();</span>
<span class="nc" id="L425">      sbPOS.append(pos + &quot;_&quot;);</span>
<span class="nc bnc" id="L426" title="All 10 branches missed.">      if (pos.equals(&quot;NN&quot;) || pos.equals(&quot;NNS&quot;) || pos.equals(&quot;NNP&quot;) || pos.equals(&quot;NNPS&quot;) || pos.equals(&quot;VB&quot;)</span>
<span class="nc bnc" id="L427" title="All 10 branches missed.">              || pos.equals(&quot;VBN&quot;) || pos.equals(&quot;VBD&quot;) || pos.equals(&quot;VBG&quot;) || pos.equals(&quot;VBP&quot;) || pos.equals(&quot;VBZ&quot;)) {</span>
<span class="nc" id="L428">        sbSelective.append(word + &quot;_&quot;);</span>
      }
    }
<span class="nc bnc" id="L431" title="All 2 branches missed.">    if (usingFeature(types, checklist, &quot;surface_path&quot;)) {</span>
<span class="nc" id="L432">      features.setCount(&quot;surface_path: &quot; + sb, 1.0);</span>
    }
<span class="nc bnc" id="L434" title="All 2 branches missed.">    if (usingFeature(types, checklist, &quot;surface_path_POS&quot;)) {</span>
<span class="nc" id="L435">      features.setCount(&quot;surface_path_POS: &quot; + sbPOS, 1.0);</span>
    }
<span class="nc bnc" id="L437" title="All 2 branches missed.">    if (usingFeature(types, checklist, &quot;surface_path_selective&quot;)) {</span>
<span class="nc" id="L438">      features.setCount(&quot;surface_path_selective: &quot; + sbSelective, 1.0);</span>
    }

    int swStart, swEnd; // must be initialized below
<span class="nc bnc" id="L442" title="All 2 branches missed.">    if (arg0.getSyntacticHeadTokenPosition() &lt; arg1.getSyntacticHeadTokenPosition()){</span>
<span class="nc" id="L443">      swStart = arg0.getExtentTokenEnd();</span>
<span class="nc" id="L444">      swEnd = arg1.getExtentTokenStart();</span>
    } else {
<span class="nc" id="L446">      swStart = arg1.getExtentTokenEnd();</span>
<span class="nc" id="L447">      swEnd = arg0.getExtentTokenStart();</span>
    }

    // span_words_unigrams: words that appear in between the two arguments
<span class="nc bnc" id="L451" title="All 2 branches missed.">    if (usingFeature(types, checklist, &quot;span_words_unigrams&quot;)) {</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">      for(int i = swStart; i &lt; swEnd; i ++){</span>
<span class="nc" id="L453">        features.setCount(&quot;span_word:&quot; + tokens.get(i).word(), 1.0);</span>
      }
    }

    // span_words_bigrams: bigrams of words that appear in between the two arguments
<span class="nc bnc" id="L458" title="All 2 branches missed.">    if (usingFeature(types, checklist, &quot;span_words_bigrams&quot;)) {</span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">      for(int i = swStart; i &lt; swEnd - 1; i ++){</span>
<span class="nc" id="L460">        features.setCount(&quot;span_bigram:&quot; + tokens.get(i).word() + &quot;-&quot; + tokens.get(i + 1).word(), 1.0);</span>
      }
    }

<span class="nc bnc" id="L464" title="All 2 branches missed.">    if (usingFeature(types, checklist, &quot;span_words_trigger&quot;)) {</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">      for (int i = swStart; i &lt; swEnd; i++) {</span>
<span class="nc" id="L466">        String trigger = tokens.get(i).get(TriggerAnnotation.class);</span>
<span class="nc bnc" id="L467" title="All 4 branches missed.">        if (trigger != null &amp;&amp; trigger.startsWith(&quot;B-&quot;))</span>
<span class="nc" id="L468">          features.incrementCount(&quot;span_words_trigger=&quot; + trigger.substring(2));</span>
      }
    }

<span class="nc bnc" id="L472" title="All 2 branches missed.">    if (usingFeature(types, checklist, &quot;arg2_number&quot;)) {</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">      if (arg1.getType().equals(&quot;NUMBER&quot;)){</span>
        try {
<span class="nc" id="L475">          int value = Integer.parseInt(arg1.getValue());</span>

<span class="nc bnc" id="L477" title="All 4 branches missed.">          if (2 &lt;= value &amp;&amp; value &lt;= 100)</span>
<span class="nc" id="L478">            features.setCount(&quot;arg2_number&quot;, 1.0);</span>
<span class="nc bnc" id="L479" title="All 4 branches missed.">          if (2 &lt;= value &amp;&amp; value &lt;= 19)</span>
<span class="nc" id="L480">            features.setCount(&quot;arg2_number_2&quot;, 1.0);</span>
<span class="nc bnc" id="L481" title="All 4 branches missed.">          if (20 &lt;= value &amp;&amp; value &lt;= 59)</span>
<span class="nc" id="L482">            features.setCount(&quot;arg2_number_20&quot;, 1.0);</span>
<span class="nc bnc" id="L483" title="All 4 branches missed.">          if (60 &lt;= value &amp;&amp; value &lt;= 100)</span>
<span class="nc" id="L484">            features.setCount(&quot;arg2_number_60&quot;, 1.0);</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">          if (value &gt;= 100)</span>
<span class="nc" id="L486">            features.setCount(&quot;arg2_number_100&quot;, 1.0);</span>
<span class="nc" id="L487">        } catch (NumberFormatException e) {}</span>
      }
    }

<span class="nc bnc" id="L491" title="All 2 branches missed.">    if (usingFeature(types, checklist, &quot;arg2_date&quot;)) {</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">      if (arg1.getType().equals(&quot;DATE&quot;)){</span>
        try {
<span class="nc" id="L494">          int value = Integer.parseInt(arg1.getValue());</span>

<span class="nc bnc" id="L496" title="All 4 branches missed.">          if (0 &lt;= value &amp;&amp; value &lt;= 2010)</span>
<span class="nc" id="L497">            features.setCount(&quot;arg2_date&quot;, 1.0);</span>
<span class="nc bnc" id="L498" title="All 4 branches missed.">          if (0 &lt;= value &amp;&amp; value &lt;= 999)</span>
<span class="nc" id="L499">            features.setCount(&quot;arg2_date_0&quot;, 1.0);</span>
<span class="nc bnc" id="L500" title="All 4 branches missed.">          if (1000 &lt;= value &amp;&amp; value &lt;= 1599)</span>
<span class="nc" id="L501">            features.setCount(&quot;arg2_date_1000&quot;, 1.0);</span>
<span class="nc bnc" id="L502" title="All 4 branches missed.">          if (1600 &lt;= value &amp;&amp; value &lt;= 1799)</span>
<span class="nc" id="L503">            features.setCount(&quot;arg2_date_1600&quot;, 1.0);</span>
<span class="nc bnc" id="L504" title="All 4 branches missed.">          if (1800 &lt;= value &amp;&amp; value &lt;= 1899)</span>
<span class="nc" id="L505">            features.setCount(&quot;arg2_date_1800&quot;, 1.0);</span>
<span class="nc bnc" id="L506" title="All 4 branches missed.">          if (1900 &lt;= value &amp;&amp; value &lt;= 1999)</span>
<span class="nc" id="L507">            features.setCount(&quot;arg2_date_1900&quot;, 1.0);</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">          if (value &gt;= 2000)</span>
<span class="nc" id="L509">            features.setCount(&quot;arg2_date_2000&quot;, 1.0);</span>
<span class="nc" id="L510">        } catch (NumberFormatException e) {}</span>
      }
    }

<span class="nc bnc" id="L514" title="All 2 branches missed.">    if (usingFeature(types, checklist, &quot;arg_gender&quot;)) {</span>
<span class="nc" id="L515">      boolean arg0Male = false, arg0Female = false;</span>
<span class="nc" id="L516">      boolean arg1Male = false, arg1Female = false;</span>
<span class="nc" id="L517">      System.out.println(&quot;Adding gender annotations!&quot;);</span>

<span class="nc" id="L519">      int index = arg0.getExtentTokenStart();</span>
<span class="nc" id="L520">      String gender = tokens.get(index).get(GenderAnnotation.class);</span>
<span class="nc" id="L521">      System.out.println(tokens.get(index).word() + &quot; -- &quot; + gender);</span>
<span class="nc bnc" id="L522" title="All 2 branches missed.">      if (gender.equals(&quot;MALE&quot;))</span>
<span class="nc" id="L523">        arg0Male = true;</span>
<span class="nc bnc" id="L524" title="All 2 branches missed.">      else if (gender.equals(&quot;FEMALE&quot;))</span>
<span class="nc" id="L525">        arg0Female = true;</span>

<span class="nc" id="L527">      index = arg1.getExtentTokenStart();</span>
<span class="nc" id="L528">      gender = tokens.get(index).get(GenderAnnotation.class);</span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">      if (gender.equals(&quot;MALE&quot;))</span>
<span class="nc" id="L530">        arg1Male = true;</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">      else if (gender.equals(&quot;FEMALE&quot;))</span>
<span class="nc" id="L532">        arg1Female = true;</span>

<span class="nc bnc" id="L534" title="All 2 branches missed.">      if (arg0Male) features.setCount(&quot;arg1_male&quot;, 1.0);</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">      if (arg0Female) features.setCount(&quot;arg1_female&quot;, 1.0);</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">      if (arg1Male) features.setCount(&quot;arg2_male&quot;, 1.0);</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">      if (arg1Female) features.setCount(&quot;arg2_female&quot;, 1.0);</span>

<span class="nc bnc" id="L539" title="All 8 branches missed.">      if ((arg0Male &amp;&amp; arg1Male) || (arg0Female &amp;&amp; arg1Female))</span>
<span class="nc" id="L540">        features.setCount(&quot;arg_same_gender&quot;, 1.0);</span>
<span class="nc bnc" id="L541" title="All 8 branches missed.">      if ((arg0Male &amp;&amp; arg1Female) || (arg0Female &amp;&amp; arg1Male))</span>
<span class="nc" id="L542">        features.setCount(&quot;arg_different_gender&quot;, 1.0);</span>
    }

<span class="nc" id="L545">    List&lt;String&gt; tempDepFeatures = new ArrayList&lt;&gt;(dependencyFeatures);</span>
<span class="nc bnc" id="L546" title="All 4 branches missed.">    if (tempDepFeatures.removeAll(types) || types.contains(&quot;all&quot;)) { // dependencyFeatures contains at least one of the features listed in types</span>
<span class="nc" id="L547">      addDependencyPathFeatures(features, rel, arg0, arg1, types, checklist, logger);</span>
    }

<span class="nc bnc" id="L550" title="All 4 branches missed.">    if (!checklist.isEmpty() &amp;&amp; !checklist.contains(&quot;all&quot;))</span>
<span class="nc" id="L551">      throw new AssertionError(&quot;RelationFeatureFactory: features not handled: &quot;+checklist);</span>


<span class="nc" id="L554">    List&lt;String&gt; featureList = new ArrayList&lt;&gt;(features.keySet());</span>
<span class="nc" id="L555">    Collections.sort(featureList);</span>

//    for (String feature : featureList) {
//      logger.info(feature+&quot;\n&quot;+&quot;count=&quot;+features.getCount(feature));
//    }

<span class="nc" id="L561">    return true;</span>

  }

  String sentToString(CoreMap sentence) {
<span class="nc" id="L566">    StringBuffer os = new StringBuffer();</span>
<span class="nc" id="L567">    List&lt;CoreLabel&gt; tokens = sentence.get(TokensAnnotation.class);</span>
<span class="nc bnc" id="L568" title="All 2 branches missed.">    if(tokens != null){</span>
<span class="nc" id="L569">      boolean first = true;</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">      for(CoreLabel token: tokens) {</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">        if(! first) os.append(&quot; &quot;);</span>
<span class="nc" id="L572">        os.append(token.word());</span>
<span class="nc" id="L573">        first = false;</span>
<span class="nc" id="L574">      }</span>
    }

<span class="nc" id="L577">    return os.toString();</span>
  }

  protected void addDependencyPathFeatures(
          Counter&lt;String&gt; features,
          RelationMention rel,
          EntityMention arg0,
          EntityMention arg1,
          List&lt;String&gt; types,
          List&lt;String&gt; checklist,
          Logger logger) {
<span class="nc" id="L588">    SemanticGraph graph = null;</span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">    if(dependencyType == null) dependencyType = DEPENDENCY_TYPE.COLLAPSED_CCPROCESSED; // needed for backwards compatibility. old serialized models don't have it</span>
<span class="nc bnc" id="L590" title="All 2 branches missed.">    if(dependencyType == DEPENDENCY_TYPE.COLLAPSED_CCPROCESSED)</span>
<span class="nc" id="L591">      graph = rel.getSentence().get(SemanticGraphCoreAnnotations.CollapsedCCProcessedDependenciesAnnotation.class);</span>
<span class="nc bnc" id="L592" title="All 2 branches missed.">    else if(dependencyType == DEPENDENCY_TYPE.COLLAPSED)</span>
<span class="nc" id="L593">      graph = rel.getSentence().get(SemanticGraphCoreAnnotations.CollapsedDependenciesAnnotation.class);</span>
<span class="nc bnc" id="L594" title="All 2 branches missed.">    else if(dependencyType == DEPENDENCY_TYPE.BASIC)</span>
<span class="nc" id="L595">      graph = rel.getSentence().get(SemanticGraphCoreAnnotations.BasicDependenciesAnnotation.class);</span>
    else
<span class="nc" id="L597">      throw new RuntimeException(&quot;ERROR: unknown dependency type: &quot; + dependencyType);</span>

<span class="nc bnc" id="L599" title="All 2 branches missed.">    if (graph == null) {</span>
<span class="nc" id="L600">      Tree tree = rel.getSentence().get(TreeAnnotation.class);</span>
<span class="nc bnc" id="L601" title="All 2 branches missed.">      if(tree == null){</span>
<span class="nc" id="L602">        log.info(&quot;WARNING: found sentence without TreeAnnotation. Skipped dependency-path features.&quot;);</span>
<span class="nc" id="L603">        return;</span>
      }
      try {
<span class="nc" id="L606">        graph = SemanticGraphFactory.makeFromTree(tree, Mode.COLLAPSED, GrammaticalStructure.Extras.NONE, null, true);</span>

<span class="nc" id="L608">      } catch(Exception e){</span>
<span class="nc" id="L609">        log.info(&quot;WARNING: failed to generate dependencies from tree &quot; + tree.toString());</span>
<span class="nc" id="L610">        e.printStackTrace();</span>
<span class="nc" id="L611">        log.info(&quot;Skipped dependency-path features.&quot;);</span>
<span class="nc" id="L612">        return;</span>
<span class="nc" id="L613">      }</span>
    }

<span class="nc" id="L616">    IndexedWord node0 = graph.getNodeByIndexSafe(arg0.getSyntacticHeadTokenPosition() + 1);</span>
<span class="nc" id="L617">    IndexedWord node1 = graph.getNodeByIndexSafe(arg1.getSyntacticHeadTokenPosition() + 1);</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">    if (node0 == null) {</span>
<span class="nc" id="L619">      checklist.removeAll(dependencyFeatures);</span>
<span class="nc" id="L620">      return;</span>
    }
<span class="nc bnc" id="L622" title="All 2 branches missed.">    if (node1 == null) {</span>
<span class="nc" id="L623">      checklist.removeAll(dependencyFeatures);</span>
<span class="nc" id="L624">      return;</span>
    }

<span class="nc" id="L627">    List&lt;SemanticGraphEdge&gt; edgePath = graph.getShortestUndirectedPathEdges(node0, node1);</span>
<span class="nc" id="L628">    List&lt;IndexedWord&gt; pathNodes = graph.getShortestUndirectedPathNodes(node0, node1);</span>

<span class="nc bnc" id="L630" title="All 2 branches missed.">    if (edgePath == null) {</span>
<span class="nc" id="L631">      checklist.removeAll(dependencyFeatures);</span>
<span class="nc" id="L632">      return;</span>
    }

<span class="nc bnc" id="L635" title="All 4 branches missed.">    if (pathNodes == null || pathNodes.size() &lt;= 1) { // arguments have the same head.</span>
<span class="nc" id="L636">      checklist.removeAll(dependencyFeatures);</span>
<span class="nc" id="L637">      return;</span>
    }

    // dependency_path: Concatenation of relations in the path between the args in the dependency graph, including directions
    // e.g. &quot;subj-&gt;  &lt;-prep_in  &lt;-mod&quot;
    // dependency_path_lowlevel: Same but with finer-grained syntactic relations
    // e.g. &quot;nsubj-&gt;  &lt;-prep_in  &lt;-nn&quot;
<span class="nc bnc" id="L644" title="All 2 branches missed.">    if (usingFeature(types, checklist, &quot;dependency_path&quot;)) {</span>
<span class="nc" id="L645">      features.setCount(&quot;dependency_path:&quot;+generalizedDependencyPath(edgePath, node0), 1.0);</span>
    }
<span class="nc bnc" id="L647" title="All 2 branches missed.">    if (usingFeature(types, checklist, &quot;dependency_path_lowlevel&quot;)) {</span>
<span class="nc" id="L648">      String depLowLevel = dependencyPath(edgePath, node0);</span>
<span class="nc bnc" id="L649" title="All 4 branches missed.">      if(logger != null &amp;&amp; ! rel.getType().equals(RelationMention.UNRELATED)) logger.info(&quot;dependency_path_lowlevel: &quot; + depLowLevel);</span>
<span class="nc" id="L650">      features.setCount(&quot;dependency_path_lowlevel:&quot; + depLowLevel, 1.0);</span>
    }

<span class="nc" id="L653">    List&lt;String&gt; pathLemmas = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L654">    List&lt;String&gt; noArgPathLemmas = new ArrayList&lt;&gt;();</span>
    // do not add to pathLemmas words that belong to one of the two args
<span class="nc" id="L656">    Set&lt;Integer&gt; indecesToSkip = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L657" title="All 2 branches missed.">    for(int i = arg0.getExtentTokenStart(); i &lt; arg0.getExtentTokenEnd(); i ++) indecesToSkip.add(i + 1);</span>
<span class="nc bnc" id="L658" title="All 2 branches missed.">    for(int i = arg1.getExtentTokenStart(); i &lt; arg1.getExtentTokenEnd(); i ++) indecesToSkip.add(i + 1);</span>
<span class="nc bnc" id="L659" title="All 2 branches missed.">    for (IndexedWord node : pathNodes){</span>
<span class="nc" id="L660">      pathLemmas.add(Morphology.lemmaStatic(node.value(), node.tag(), true));</span>
<span class="nc bnc" id="L661" title="All 2 branches missed.">      if(! indecesToSkip.contains(node.index()))</span>
<span class="nc" id="L662">        noArgPathLemmas.add(Morphology.lemmaStatic(node.value(), node.tag(), true));</span>
<span class="nc" id="L663">    }</span>


    // Verb-based features
    // These features were designed on the assumption that verbs are often trigger words
    // (specifically with the &quot;Kill&quot; relation from Roth CONLL04 in mind)
    // but they didn't end up boosting performance on Roth CONLL04, so they may not be necessary.
    //
    // dependency_paths_to_verb: for each verb in the dependency path,
    // the path to the left of the (lemmatized) verb, to the right, and both, e.g.
    // &quot;subj-&gt; be&quot;
    // &quot;be  &lt;-prep_in  &lt;-mod&quot;
    // &quot;subj-&gt;  be  &lt;-prep_in  &lt;-mod&quot;
    // (Higher level relations used as opposed to &quot;lowlevel&quot; finer grained relations)
<span class="nc bnc" id="L677" title="All 2 branches missed.">    if (usingFeature(types, checklist, &quot;dependency_paths_to_verb&quot;)) {</span>
<span class="nc bnc" id="L678" title="All 2 branches missed.">      for (IndexedWord node : pathNodes) {</span>
<span class="nc bnc" id="L679" title="All 2 branches missed.">        if (node.tag().contains(&quot;VB&quot;)) {</span>
<span class="nc bnc" id="L680" title="All 4 branches missed.">          if (node.equals(node0) || node.equals(node1)) {</span>
<span class="nc" id="L681">            continue;</span>
          }
<span class="nc" id="L683">          String lemma = Morphology.lemmaStatic(node.value(), node.tag(), true);</span>
<span class="nc" id="L684">          String node1Path = generalizedDependencyPath(graph.getShortestUndirectedPathEdges(node, node1), node);</span>
<span class="nc" id="L685">          String node0Path = generalizedDependencyPath(graph.getShortestUndirectedPathEdges(node0, node), node0);</span>
<span class="nc" id="L686">          features.setCount(&quot;dependency_paths_to_verb:&quot; + node0Path + &quot; &quot; + lemma, 1.0);</span>
<span class="nc" id="L687">          features.setCount(&quot;dependency_paths_to_verb:&quot; + lemma + &quot; &quot; + node1Path, 1.0);</span>
<span class="nc" id="L688">          features.setCount(&quot;dependency_paths_to_verb:&quot; + node0Path + &quot; &quot; + lemma + &quot; &quot; + node1Path, 1.0);</span>
        }
<span class="nc" id="L690">      }</span>
    }
    // dependency_path_stubs_to_verb:
    // For each verb in the dependency path,
    // the verb concatenated with the first (high-level) relation in the path from arg0;
    // the verb concatenated with the first relation in the path from arg1,
    // and the verb concatenated with both relations.  E.g. (same arguments and sentence as example above)
    // &quot;stub: subj-&gt;  be&quot;
    // &quot;stub: be  &lt;-mod&quot;
    // &quot;stub: subj-&gt;  be  &lt;-mod&quot;
<span class="nc bnc" id="L700" title="All 2 branches missed.">    if (usingFeature(types, checklist, &quot;dependency_path_stubs_to_verb&quot;)) {</span>
<span class="nc bnc" id="L701" title="All 2 branches missed.">      for (IndexedWord node : pathNodes) {</span>
<span class="nc" id="L702">        SemanticGraphEdge edge0 = edgePath.get(0);</span>
<span class="nc" id="L703">        SemanticGraphEdge edge1 = edgePath.get(edgePath.size() - 1);</span>
<span class="nc bnc" id="L704" title="All 2 branches missed.">        if (node.tag().contains(&quot;VB&quot;)) {</span>
<span class="nc bnc" id="L705" title="All 4 branches missed.">          if (node.equals(node0) || node.equals(node1)) {</span>
<span class="nc" id="L706">            continue;</span>
          }
<span class="nc" id="L708">          String lemma = Morphology.lemmaStatic(node.value(), node.tag(), true);</span>
          String edge0str, edge1str;
<span class="nc bnc" id="L710" title="All 2 branches missed.">          if (node0.equals(edge0.getGovernor())) {</span>
<span class="nc" id="L711">            edge0str = &quot;&lt;-&quot; + generalizeRelation(edge0.getRelation());</span>
          } else {
<span class="nc" id="L713">            edge0str = generalizeRelation(edge0.getRelation()) + &quot;-&gt;&quot;;</span>
          }
<span class="nc bnc" id="L715" title="All 2 branches missed.">          if (node1.equals(edge1.getGovernor())) {</span>
<span class="nc" id="L716">            edge1str = generalizeRelation(edge1.getRelation()) + &quot;-&gt;&quot;;</span>
          } else {
<span class="nc" id="L718">            edge1str = &quot;&lt;-&quot; + generalizeRelation(edge1.getRelation());</span>
          }
<span class="nc" id="L720">          features.setCount(&quot;stub: &quot; + edge0str + &quot; &quot; + lemma, 1.0);</span>
<span class="nc" id="L721">          features.setCount(&quot;stub: &quot; + lemma + edge1str, 1.0);</span>
<span class="nc" id="L722">          features.setCount(&quot;stub: &quot; + edge0str + &quot; &quot; + lemma + &quot; &quot; + edge1str, 1.0);</span>
        }
<span class="nc" id="L724">      }</span>
    }

<span class="nc bnc" id="L727" title="All 2 branches missed.">    if (usingFeature(types, checklist, &quot;verb_in_dependency_path&quot;)) {</span>
<span class="nc bnc" id="L728" title="All 2 branches missed.">      for (IndexedWord node : pathNodes) {</span>
<span class="nc bnc" id="L729" title="All 2 branches missed.">        if (node.tag().contains(&quot;VB&quot;)) {</span>
<span class="nc bnc" id="L730" title="All 4 branches missed.">          if (node.equals(node0) || node.equals(node1)) {</span>
<span class="nc" id="L731">            continue;</span>
          }
<span class="nc" id="L733">          SemanticGraphEdge rightEdge = graph.getShortestUndirectedPathEdges(node, node1).get(0);</span>
<span class="nc" id="L734">          SemanticGraphEdge leftEdge = graph.getShortestUndirectedPathEdges(node, node0).get(0);</span>
          String rightRelation, leftRelation;
<span class="nc" id="L736">          boolean governsLeft = false, governsRight = false;</span>
<span class="nc bnc" id="L737" title="All 2 branches missed.">          if (node.equals(rightEdge.getGovernor())) {</span>
<span class="nc" id="L738">            rightRelation = &quot; &lt;-&quot; + generalizeRelation(rightEdge.getRelation());</span>
<span class="nc" id="L739">            governsRight = true;</span>
          } else {
<span class="nc" id="L741">            rightRelation = generalizeRelation(rightEdge.getRelation()) + &quot;-&gt; &quot;;</span>
          }
<span class="nc bnc" id="L743" title="All 2 branches missed.">          if (node.equals(leftEdge.getGovernor())) {</span>
<span class="nc" id="L744">            leftRelation = generalizeRelation(leftEdge.getRelation()) + &quot;-&gt; &quot;;</span>
<span class="nc" id="L745">            governsLeft = true;</span>
          } else {
<span class="nc" id="L747">            leftRelation = &quot; &lt;-&quot; + generalizeRelation(leftEdge.getRelation());</span>
          }
<span class="nc" id="L749">          String lemma = Morphology.lemmaStatic(node.value(), node.tag(), true);</span>

<span class="nc bnc" id="L751" title="All 4 branches missed.">          if (governsLeft || governsRight) {</span>
          }
<span class="nc bnc" id="L753" title="All 2 branches missed.">          if (governsLeft) {</span>
<span class="nc" id="L754">            features.setCount(&quot;verb: &quot; + leftRelation + lemma, 1.0);</span>
          }
<span class="nc bnc" id="L756" title="All 2 branches missed.">          if (governsRight) {</span>
<span class="nc" id="L757">            features.setCount(&quot;verb: &quot; + lemma + rightRelation, 1.0);</span>
          }
<span class="nc bnc" id="L759" title="All 4 branches missed.">          if (governsLeft &amp;&amp; governsRight) {</span>
<span class="nc" id="L760">            features.setCount(&quot;verb: &quot; + leftRelation + lemma + rightRelation, 1.0);</span>
          }
        }
<span class="nc" id="L763">      }</span>
    }


    // FEATURES FROM BJORNE ET AL., BIONLP'09
    // dependency_path_words: generates a feature for each word in the dependency path (lemmatized)
    // dependency_path_POS_unigrams: generates a feature for the POS tag of each word in the dependency path
<span class="nc bnc" id="L770" title="All 2 branches missed.">    if (usingFeature(types, checklist, &quot;dependency_path_words&quot;)) {</span>
<span class="nc bnc" id="L771" title="All 2 branches missed.">      for (String lemma : noArgPathLemmas)</span>
<span class="nc" id="L772">        features.setCount(&quot;word_in_dependency_path:&quot; + lemma, 1.0);</span>
    }
<span class="nc bnc" id="L774" title="All 2 branches missed.">    if (usingFeature(types, checklist, &quot;dependency_path_POS_unigrams&quot;)) {</span>
<span class="nc bnc" id="L775" title="All 2 branches missed.">      for (IndexedWord node : pathNodes)</span>
<span class="nc bnc" id="L776" title="All 4 branches missed.">        if (!node.equals(node0) &amp;&amp; !node.equals(node1))</span>
<span class="nc" id="L777">          features.setCount(&quot;POS_in_dependency_path: &quot;+node.tag(),1.0);</span>
    }

    // dependency_path_word_n_grams: n-grams of words (lemmatized) in the dependency path, n=2,3,4
    // dependency_path_POS_n_grams: n-grams of POS tags of words in the dependency path, n=2,3,4
<span class="nc bnc" id="L782" title="All 2 branches missed.">    for (int node = 0; node &lt; pathNodes.size(); node++) {</span>
<span class="nc bnc" id="L783" title="All 2 branches missed.">      for (int n = 2; n &lt;= 4; n++) {</span>
<span class="nc bnc" id="L784" title="All 2 branches missed.">        if (node+n &gt; pathNodes.size())</span>
<span class="nc" id="L785">          break;</span>
<span class="nc" id="L786">        StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L787">        StringBuilder sbPOS = new StringBuilder();</span>

<span class="nc bnc" id="L789" title="All 2 branches missed.">        for (int elt = node; elt &lt; node+n; elt++) {</span>
<span class="nc" id="L790">          sb.append(pathLemmas.get(elt));</span>
<span class="nc" id="L791">          sb.append(&quot;_&quot;);</span>
<span class="nc" id="L792">          sbPOS.append(pathNodes.get(elt).tag());</span>
<span class="nc" id="L793">          sbPOS.append(&quot;_&quot;);</span>
        }
<span class="nc bnc" id="L795" title="All 2 branches missed.">        if (usingFeature(types, checklist, &quot;dependency_path_word_n_grams&quot;))</span>
<span class="nc" id="L796">          features.setCount(&quot;dependency_path_&quot;+n+&quot;-gram: &quot;+sb,1.0);</span>
<span class="nc bnc" id="L797" title="All 2 branches missed.">        if (usingFeature(types,checklist, &quot;dependency_path_POS_n_grams&quot;))</span>
<span class="nc" id="L798">          features.setCount(&quot;dependency_path_POS_&quot;+n+&quot;-gram: &quot;+sbPOS,1.0);</span>
      }
    }
    // dependency_path_edge_n_grams: n_grams of relations (high-level) in the dependency path, undirected, n=2,3,4
    // e.g. &quot;subj -- prep_in -- mod&quot;
    // dependency_path_edge_lowlevel_n_grams: similar, for fine-grained relations
    //
    // dependency_path_node-edge-node-grams: trigrams consisting of adjacent words (lemmatized) in the dependency path
    // and the relation between them (undirected)
    // dependency_path_node-edge-node-grams_lowlevel: same, using fine-grained relations
    //
    // dependency_path_edge-node-edge-grams: trigrams consisting of words (lemmatized) in the dependency path
    // and the incoming and outgoing relations (undirected)
    // e.g. &quot;subj -- television -- mod&quot;
    // dependency_path_edge-node-edge-grams_lowlevel: same, using fine-grained relations
    //
    // dependency_path_directed_bigrams: consecutive words in the dependency path (lemmatized) and the direction
    // of the dependency between them
    // e.g. &quot;Theatre -&gt; exhibit&quot;
    //
    // dependency_path_edge_unigrams: feature for each (fine-grained) relation in the dependency path,
    // with its direction in the path and whether it's at the left end, right end, or interior of the path.
    // e.g. &quot;prep_at -&gt;  - leftmost&quot;
<span class="nc bnc" id="L821" title="All 2 branches missed.">    for (int edge = 0; edge &lt; edgePath.size(); edge++) {</span>
<span class="nc bnc" id="L822" title="All 2 branches missed.">      if (usingFeature(types, checklist, &quot;dependency_path_edge_n_grams&quot;) ||</span>
<span class="nc bnc" id="L823" title="All 2 branches missed.">              usingFeature(types, checklist, &quot;dependency_path_edge_lowlevel_n_grams&quot;)) {</span>
<span class="nc bnc" id="L824" title="All 2 branches missed.">        for (int n = 2; n &lt;= 4; n++) {</span>
<span class="nc bnc" id="L825" title="All 2 branches missed.">          if (edge+n &gt; edgePath.size())</span>
<span class="nc" id="L826">            break;</span>
<span class="nc" id="L827">          StringBuilder sbRelsHi = new StringBuilder();</span>
<span class="nc" id="L828">          StringBuilder sbRelsLo = new StringBuilder();</span>
<span class="nc bnc" id="L829" title="All 2 branches missed.">          for (int elt = edge; elt &lt; edge+n; elt++) {</span>
<span class="nc" id="L830">            GrammaticalRelation gr = edgePath.get(elt).getRelation();</span>
<span class="nc" id="L831">            sbRelsHi.append(generalizeRelation(gr));</span>
<span class="nc" id="L832">            sbRelsHi.append(&quot;_&quot;);</span>
<span class="nc" id="L833">            sbRelsLo.append(gr);</span>
<span class="nc" id="L834">            sbRelsLo.append(&quot;_&quot;);</span>
          }
<span class="nc bnc" id="L836" title="All 2 branches missed.">          if (usingFeature(types, checklist, &quot;dependency_path_edge_n_grams&quot;))</span>
<span class="nc" id="L837">            features.setCount(&quot;dependency_path_edge_&quot;+n+&quot;-gram: &quot;+sbRelsHi,1.0);</span>
<span class="nc bnc" id="L838" title="All 2 branches missed.">          if (usingFeature(types, checklist, &quot;dependency_path_edge_lowlevel_n_grams&quot;))</span>
<span class="nc" id="L839">            features.setCount(&quot;dependency_path_edge_lowlevel_&quot;+n+&quot;-gram: &quot;+sbRelsLo,1.0);</span>
        }
      }
<span class="nc bnc" id="L842" title="All 2 branches missed.">      if (usingFeature(types, checklist, &quot;dependency_path_node-edge-node-grams&quot;))</span>
<span class="nc" id="L843">        features.setCount(</span>
                &quot;dependency_path_node-edge-node-gram: &quot;+
<span class="nc" id="L845">                        pathLemmas.get(edge)+&quot; -- &quot;+</span>
<span class="nc" id="L846">                        generalizeRelation(edgePath.get(edge).getRelation())+&quot; -- &quot;+</span>
<span class="nc" id="L847">                        pathLemmas.get(edge+1),</span>
                1.0);
<span class="nc bnc" id="L849" title="All 2 branches missed.">      if (usingFeature(types, checklist, &quot;dependency_path_node-edge-node-grams_lowlevel&quot;))</span>
<span class="nc" id="L850">        features.setCount(</span>
                &quot;dependency_path_node-edge-node-gram_lowlevel: &quot;+
<span class="nc" id="L852">                        pathLemmas.get(edge)+&quot; -- &quot;+</span>
<span class="nc" id="L853">                        edgePath.get(edge).getRelation()+&quot; -- &quot;+</span>
<span class="nc" id="L854">                        pathLemmas.get(edge+1),</span>
                1.0);
<span class="nc bnc" id="L856" title="All 4 branches missed.">      if (usingFeature(types,checklist, &quot;dependency_path_edge-node-edge-grams&quot;) &amp;&amp; edge &gt; 0)</span>
<span class="nc" id="L857">        features.setCount(</span>
                &quot;dependency_path_edge-node-edge-gram: &quot;+
<span class="nc" id="L859">                        generalizeRelation(edgePath.get(edge-1).getRelation())+&quot; -- &quot;+</span>
<span class="nc" id="L860">                        pathLemmas.get(edge)+&quot; -- &quot;+</span>
<span class="nc" id="L861">                        generalizeRelation(edgePath.get(edge).getRelation()),</span>
                1.0);
<span class="nc bnc" id="L863" title="All 4 branches missed.">      if (usingFeature(types,checklist,&quot;dependency_path_edge-node-edge-grams_lowlevel&quot;) &amp;&amp; edge &gt; 0)</span>
<span class="nc" id="L864">        features.setCount(</span>
                &quot;dependency_path_edge-node-edge-gram_lowlevel: &quot;+
<span class="nc" id="L866">                        edgePath.get(edge-1).getRelation()+&quot; -- &quot;+</span>
<span class="nc" id="L867">                        pathLemmas.get(edge)+&quot; -- &quot;+</span>
<span class="nc" id="L868">                        edgePath.get(edge).getRelation(),</span>
                1.0);
<span class="nc bnc" id="L870" title="All 2 branches missed.">      String dir = pathNodes.get(edge).equals(edgePath.get(edge).getDependent()) ? &quot; -&gt; &quot; : &quot; &lt;- &quot;;</span>
<span class="nc bnc" id="L871" title="All 2 branches missed.">      if (usingFeature(types, checklist, &quot;dependency_path_directed_bigrams&quot;))</span>
<span class="nc" id="L872">        features.setCount(</span>
                &quot;dependency_path_directed_bigram: &quot;+
<span class="nc" id="L874">                        pathLemmas.get(edge)+</span>
                        dir+
<span class="nc" id="L876">                        pathLemmas.get(edge+1),</span>
                1.0);
<span class="nc bnc" id="L878" title="All 2 branches missed.">      if (usingFeature(types, checklist, &quot;dependency_path_edge_unigrams&quot;))</span>
<span class="nc" id="L879">        features.setCount(</span>
                &quot;dependency_path_edge_unigram: &quot;+
<span class="nc bnc" id="L881" title="All 2 branches missed.">                        edgePath.get(edge).getRelation() +</span>
                        dir+
<span class="nc bnc" id="L883" title="All 2 branches missed.">                        (edge==0 ? &quot; - leftmost&quot; : edge==edgePath.size()-1 ? &quot; - rightmost&quot; : &quot; - interior&quot;),1.0);</span>
    }

    // dependency_path_length: number of edges in the path between args in the dependency graph, integer-valued
    // dependency_path_length_binary: same, as binary features
<span class="nc bnc" id="L888" title="All 2 branches missed.">    if (usingFeature(types, checklist, &quot;dependency_path_length&quot;)) {</span>
<span class="nc" id="L889">      features.setCount(&quot;dependency_path_length&quot;, edgePath.size());</span>
    }
<span class="nc bnc" id="L891" title="All 2 branches missed.">    if (usingFeature(types, checklist, &quot;dependency_path_length_binary&quot;)) {</span>
<span class="nc" id="L892">      features.setCount(&quot;dependency_path_length_&quot; + new DecimalFormat(&quot;00&quot;).format(edgePath.size()), 1.0);</span>
    }

<span class="nc bnc" id="L895" title="All 2 branches missed.">    if (usingFeature(types, checklist, &quot;dependency_path_trigger&quot;)) {</span>
<span class="nc" id="L896">      List&lt;CoreLabel&gt; tokens = rel.getSentence().get(TokensAnnotation.class);</span>

<span class="nc bnc" id="L898" title="All 2 branches missed.">      for (IndexedWord node : pathNodes) {</span>
<span class="nc" id="L899">        int index = node.index();</span>
<span class="nc bnc" id="L900" title="All 2 branches missed.">        if (indecesToSkip.contains(index)) continue;</span>

<span class="nc" id="L902">        String trigger = tokens.get(index - 1).get(TriggerAnnotation.class);</span>
<span class="nc bnc" id="L903" title="All 4 branches missed.">        if (trigger != null &amp;&amp; trigger.startsWith(&quot;B-&quot;))</span>
<span class="nc" id="L904">          features.incrementCount(&quot;dependency_path_trigger=&quot; + trigger.substring(2));</span>
<span class="nc" id="L905">      }</span>
    }
<span class="nc" id="L907">  }</span>

  /**
   * Helper method that checks if a feature type &quot;type&quot; is present in the list of features &quot;types&quot;
   * and removes it from &quot;checklist&quot;
   * @param types
   * @param checklist
   * @param type
   * @return true if types contains type
   */
  protected static boolean usingFeature(final List&lt;String&gt; types, List&lt;String&gt; checklist, String type) {
<span class="nc" id="L918">    checklist.remove(type);</span>
<span class="nc bnc" id="L919" title="All 4 branches missed.">    return types.contains(type) || types.contains(&quot;all&quot;);</span>
  }

  protected static GrammaticalRelation generalizeRelation(GrammaticalRelation gr) {
<span class="nc" id="L923">    final GrammaticalRelation[] GENERAL_RELATIONS = { EnglishGrammaticalRelations.SUBJECT,</span>
            EnglishGrammaticalRelations.COMPLEMENT, EnglishGrammaticalRelations.CONJUNCT,
            EnglishGrammaticalRelations.MODIFIER, };
<span class="nc bnc" id="L926" title="All 2 branches missed.">    for (GrammaticalRelation generalGR : GENERAL_RELATIONS) {</span>
<span class="nc bnc" id="L927" title="All 2 branches missed.">      if (generalGR.isAncestor(gr)) {</span>
<span class="nc" id="L928">        return generalGR;</span>
      }
    }
<span class="nc" id="L931">    return gr;</span>
  }

  /*
   * Under construction
   */

  public static List&lt;String&gt; dependencyPathAsList(List&lt;SemanticGraphEdge&gt; edgePath, IndexedWord node, boolean generalize) {
<span class="nc bnc" id="L939" title="All 2 branches missed.">    if(edgePath == null) return null;</span>
<span class="nc" id="L940">    List&lt;String&gt; path = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L941" title="All 2 branches missed.">    for (SemanticGraphEdge edge : edgePath) {</span>
      IndexedWord nextNode;
      GrammaticalRelation relation;
<span class="nc bnc" id="L944" title="All 2 branches missed.">      if (generalize) {</span>
<span class="nc" id="L945">        relation = generalizeRelation(edge.getRelation());</span>
      } else {
<span class="nc" id="L947">        relation = edge.getRelation();</span>
      }

<span class="nc bnc" id="L950" title="All 2 branches missed.">      if (node.equals(edge.getDependent())) {</span>
<span class="nc" id="L951">        String v = (relation + &quot;-&gt;&quot;).intern();</span>
<span class="nc" id="L952">        path.add(v);</span>
<span class="nc" id="L953">        nextNode = edge.getGovernor();</span>
<span class="nc" id="L954">      } else {</span>
<span class="nc" id="L955">        String v = (&quot;&lt;-&quot; + relation).intern();</span>
<span class="nc" id="L956">        path.add(v);</span>
<span class="nc" id="L957">        nextNode = edge.getDependent();</span>
      }
<span class="nc" id="L959">      node = nextNode;</span>
<span class="nc" id="L960">    }</span>

<span class="nc" id="L962">    return path;</span>
  }

  public static String dependencyPath(List&lt;SemanticGraphEdge&gt; edgePath, IndexedWord node) {
    // the extra spaces are to maintain compatibility with existing relation extraction models
<span class="nc" id="L967">    return &quot; &quot; + StringUtils.join(dependencyPathAsList(edgePath, node, false), &quot;  &quot;) + &quot; &quot;;</span>
  }

  public static String generalizedDependencyPath(List&lt;SemanticGraphEdge&gt; edgePath, IndexedWord node) {
    // the extra spaces are to maintain compatibility with existing relation extraction models
<span class="nc" id="L972">    return &quot; &quot; + StringUtils.join(dependencyPathAsList(edgePath, node, true), &quot;  &quot;) + &quot; &quot;;</span>
  }

  public Set&lt;String&gt; getFeatures(RelationMention rel, String featureType) {
<span class="nc" id="L976">    Counter&lt;String&gt; features = new ClassicCounter&lt;&gt;();</span>
<span class="nc" id="L977">    List&lt;String&gt; singleton = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L978">    singleton.add(featureType);</span>
<span class="nc" id="L979">    addFeatures(features, rel, singleton);</span>
<span class="nc" id="L980">    return features.keySet();</span>
  }

  public String getFeature(RelationMention rel, String featureType) {
<span class="nc" id="L984">    Set&lt;String&gt; features = getFeatures(rel, featureType);</span>
<span class="nc bnc" id="L985" title="All 2 branches missed.">    if (features.size() == 0) {</span>
<span class="nc" id="L986">      return &quot;&quot;;</span>
    } else {
<span class="nc" id="L988">      return features.iterator().next();</span>
    }
  }


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>