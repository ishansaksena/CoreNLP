<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>KBPRelationExtractor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.ie</a> &gt; <span class="el_source">KBPRelationExtractor.java</span></div><h1>KBPRelationExtractor.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.ie;

import edu.stanford.nlp.ie.machinereading.structure.Span;
import edu.stanford.nlp.io.IOUtils;
import edu.stanford.nlp.simple.Sentence;
import edu.stanford.nlp.stats.ClassicCounter;
import edu.stanford.nlp.stats.Counter;
import edu.stanford.nlp.util.ConfusionMatrix;
import edu.stanford.nlp.util.Pair;
import edu.stanford.nlp.util.StringUtils;

import java.io.*;
import java.text.DecimalFormat;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static edu.stanford.nlp.ie.KBPRelationExtractor.NERTag.*;
import static edu.stanford.nlp.util.logging.Redwood.Util.endTrack;
import static edu.stanford.nlp.util.logging.Redwood.Util.forceTrack;
import static edu.stanford.nlp.util.logging.Redwood.log;

/**
 * An interface for a KBP-style relation extractor
 *
 * @author Gabor Angeli
 */
<span class="nc bnc" id="L29" title="All 2 branches missed.">public interface KBPRelationExtractor {</span>

  /**
   * Classify the given sentence into the relation it expresses, with the associated
   * confidence.
   */
  Pair&lt;String,Double&gt; classify(KBPInput input);


  /**
   * The special tag for no relation.
   */
  String NO_RELATION = &quot;no_relation&quot;;

  /**
   * A list of valid KBP NER tags.
   */
<span class="nc" id="L46">  enum NERTag {</span>
    // ENUM_NAME        NAME           SHORT_NAME  IS_REGEXNER_TYPE
<span class="nc" id="L48">    CAUSE_OF_DEATH(&quot;CAUSE_OF_DEATH&quot;, &quot;COD&quot;, true), // note: these names must be upper case</span>
<span class="nc" id="L49">    CITY(&quot;CITY&quot;, &quot;CIT&quot;, true), //       furthermore, DO NOT change the short names, or else serialization may break</span>
<span class="nc" id="L50">    COUNTRY(&quot;COUNTRY&quot;, &quot;CRY&quot;, true),</span>
<span class="nc" id="L51">    CRIMINAL_CHARGE(&quot;CRIMINAL_CHARGE&quot;, &quot;CC&quot;, true),</span>
<span class="nc" id="L52">    DATE(&quot;DATE&quot;, &quot;DT&quot;, false),</span>
<span class="nc" id="L53">    IDEOLOGY(&quot;IDEOLOGY&quot;, &quot;IDY&quot;, true),</span>
<span class="nc" id="L54">    LOCATION(&quot;LOCATION&quot;, &quot;LOC&quot;, false),</span>
<span class="nc" id="L55">    MISC(&quot;MISC&quot;, &quot;MSC&quot;, false),</span>
<span class="nc" id="L56">    MODIFIER(&quot;MODIFIER&quot;, &quot;MOD&quot;, false),</span>
<span class="nc" id="L57">    NATIONALITY(&quot;NATIONALITY&quot;, &quot;NAT&quot;, true),</span>
<span class="nc" id="L58">    NUMBER(&quot;NUMBER&quot;, &quot;NUM&quot;, false),</span>
<span class="nc" id="L59">    ORGANIZATION(&quot;ORGANIZATION&quot;, &quot;ORG&quot;, false),</span>
<span class="nc" id="L60">    PERSON(&quot;PERSON&quot;, &quot;PER&quot;, false),</span>
<span class="nc" id="L61">    RELIGION(&quot;RELIGION&quot;, &quot;REL&quot;, true),</span>
<span class="nc" id="L62">    STATE_OR_PROVINCE(&quot;STATE_OR_PROVINCE&quot;, &quot;ST&quot;, true),</span>
<span class="nc" id="L63">    TITLE(&quot;TITLE&quot;, &quot;TIT&quot;, true),</span>
<span class="nc" id="L64">    URL(&quot;URL&quot;, &quot;URL&quot;, true),</span>
<span class="nc" id="L65">    DURATION(&quot;DURATION&quot;, &quot;DUR&quot;, false),</span>
<span class="nc" id="L66">    GPE(&quot;GPE&quot;, &quot;GPE&quot;, false), // note(chaganty): This NER tag is solely used in the cold-start system for entities.</span>
//  SCHOOL            (&quot;SCHOOL&quot;,            &quot;SCH&quot;, true),
    ;

    /**
     * The full name of this NER tag, as would come out of our NER or RegexNER system
     */
    public final String name;
    /**
     * A short name for this NER tag, intended for compact serialization
     */
    public final String shortName;
    /**
     * If true, this NER tag is not in the standard NER set, but is annotated via RegexNER
     */
    public final boolean isRegexNERType;

<span class="nc" id="L83">    NERTag(String name, String shortName, boolean isRegexNERType) {</span>
<span class="nc" id="L84">      this.name = name;</span>
<span class="nc" id="L85">      this.shortName = shortName;</span>
<span class="nc" id="L86">      this.isRegexNERType = isRegexNERType;</span>
<span class="nc" id="L87">    }</span>

    /** Find the slot for a given name */
    public static Optional&lt;NERTag&gt; fromString(String name) {
      // Early termination
<span class="nc bnc" id="L92" title="All 2 branches missed.">      if (StringUtils.isNullOrEmpty(name)) { return Optional.empty(); }</span>
      // Cycle known NER tags
<span class="nc" id="L94">      name = name.toUpperCase();</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">      for (NERTag slot : NERTag.values()) {</span>
<span class="nc bnc" id="L96" title="All 2 branches missed.">        if (slot.name.equals(name)) return Optional.of(slot);</span>
      }
<span class="nc bnc" id="L98" title="All 2 branches missed.">      for (NERTag slot : NERTag.values()) {</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">        if (slot.shortName.equals(name)) return Optional.of(slot);</span>
      }
      // Some quick fixes
<span class="nc" id="L102">      return Optional.empty();</span>
    }
  }

  /**
   * Known relation types (last updated for the 2013 shared task).
   *
   * Note that changing the constants here can have far-reaching consequences in loading serialized
   * models, and various bits of code that have been hard-coded to these relation types (e.g., the various
   * consistency filters).
   *
   * &lt;p&gt;
   * &lt;i&gt;Note:&lt;/i&gt; Neither per:spouse, org:founded_by, or X:organizations_founded are SINGLE relations
   *       in the spec - these are made single here because our system otherwise over-predicts them.
   * &lt;/p&gt;
   *
   * @author Gabor Angeli
   */
<span class="nc" id="L120">  enum RelationType {</span>
<span class="nc" id="L121">    PER_ALTERNATE_NAMES(&quot;per:alternate_names&quot;, true, 10, PERSON, Cardinality.LIST, new NERTag[]{PERSON, MISC}, new String[]{&quot;NNP&quot;}, 0.0353027270308107100),</span>
<span class="nc" id="L122">    PER_CHILDREN(&quot;per:children&quot;, true, 5, PERSON, Cardinality.LIST, new NERTag[]{PERSON}, new String[]{&quot;NNP&quot;}, 0.0058428110284504410),</span>
<span class="nc" id="L123">    PER_CITIES_OF_RESIDENCE(&quot;per:cities_of_residence&quot;, true, 5, PERSON, Cardinality.LIST, new NERTag[]{CITY,}, new String[]{&quot;NNP&quot;}, 0.0136105679675116560),</span>
<span class="nc" id="L124">    PER_CITY_OF_BIRTH(&quot;per:city_of_birth&quot;, true, 3, PERSON, Cardinality.SINGLE, new NERTag[]{CITY,}, new String[]{&quot;NNP&quot;}, 0.0358146961159769100),</span>
<span class="nc" id="L125">    PER_CITY_OF_DEATH(&quot;per:city_of_death&quot;, true, 3, PERSON, Cardinality.SINGLE, new NERTag[]{CITY,}, new String[]{&quot;NNP&quot;}, 0.0102003332137774650),</span>
<span class="nc" id="L126">    PER_COUNTRIES_OF_RESIDENCE(&quot;per:countries_of_residence&quot;, true, 5, PERSON, Cardinality.LIST, new NERTag[]{COUNTRY,}, new String[]{&quot;NNP&quot;}, 0.0107788293552082020),</span>
<span class="nc" id="L127">    PER_COUNTRY_OF_BIRTH(&quot;per:country_of_birth&quot;, true, 3, PERSON, Cardinality.SINGLE, new NERTag[]{COUNTRY,}, new String[]{&quot;NNP&quot;}, 0.0223444134627622040),</span>
<span class="nc" id="L128">    PER_COUNTRY_OF_DEATH(&quot;per:country_of_death&quot;, true, 3, PERSON, Cardinality.SINGLE, new NERTag[]{COUNTRY,}, new String[]{&quot;NNP&quot;}, 0.0060626395621941200),</span>
<span class="nc" id="L129">    PER_EMPLOYEE_OF(&quot;per:employee_of&quot;, true, 10, PERSON, Cardinality.LIST, new NERTag[]{ORGANIZATION, COUNTRY, STATE_OR_PROVINCE, CITY}, new String[]{&quot;NNP&quot;}, 2.0335281901169719200),</span>
<span class="nc" id="L130">    PER_LOC_OF_BIRTH(&quot;per:LOCATION_of_birth&quot;, true, 3, PERSON, Cardinality.LIST, new NERTag[]{CITY, STATE_OR_PROVINCE, COUNTRY}, new String[]{&quot;NNP&quot;}, 0.0165825918941120660),</span>
<span class="nc" id="L131">    PER_LOC_OF_DEATH(&quot;per:LOCATION_of_death&quot;, true, 3, PERSON, Cardinality.LIST, new NERTag[]{CITY, STATE_OR_PROVINCE, COUNTRY}, new String[]{&quot;NNP&quot;}, 0.0165825918941120660),</span>
<span class="nc" id="L132">    PER_LOC_OF_RESIDENCE(&quot;per:LOCATION_of_residence&quot;, true, 3, PERSON, Cardinality.LIST, new NERTag[]{STATE_OR_PROVINCE,}, new String[]{&quot;NNP&quot;}, 0.0165825918941120660),</span>
<span class="nc" id="L133">    PER_MEMBER_OF(&quot;per:member_of&quot;, true, 10, PERSON, Cardinality.LIST, new NERTag[]{ORGANIZATION}, new String[]{&quot;NNP&quot;}, 0.0521716745149309900),</span>
<span class="nc" id="L134">    PER_ORIGIN(&quot;per:origin&quot;, true, 10, PERSON, Cardinality.LIST, new NERTag[]{NATIONALITY, COUNTRY}, new String[]{&quot;NNP&quot;}, 0.0069795559463618380),</span>
<span class="nc" id="L135">    PER_OTHER_FAMILY(&quot;per:other_family&quot;, true, 5, PERSON, Cardinality.LIST, new NERTag[]{PERSON}, new String[]{&quot;NNP&quot;}, 2.7478566717959990E-5),</span>
<span class="nc" id="L136">    PER_PARENTS(&quot;per:parents&quot;, true, 5, PERSON, Cardinality.LIST, new NERTag[]{PERSON}, new String[]{&quot;NNP&quot;}, 0.0032222235077692030),</span>
<span class="nc" id="L137">    PER_SCHOOLS_ATTENDED(&quot;per:schools_attended&quot;, true, 5, PERSON, Cardinality.LIST, new NERTag[]{ORGANIZATION}, new String[]{&quot;NNP&quot;}, 0.0054696810172276150),</span>
<span class="nc" id="L138">    PER_SIBLINGS(&quot;per:siblings&quot;, true, 5, PERSON, Cardinality.LIST, new NERTag[]{PERSON}, new String[]{&quot;NNP&quot;}, 1.000000000000000e-99),</span>
<span class="nc" id="L139">    PER_SPOUSE(&quot;per:spouse&quot;, true, 3, PERSON, Cardinality.LIST, new NERTag[]{PERSON}, new String[]{&quot;NNP&quot;}, 0.0164075968113292680),</span>
<span class="nc" id="L140">    PER_STATE_OR_PROVINCES_OF_BIRTH(&quot;per:stateorprovince_of_birth&quot;, true, 3, PERSON, Cardinality.SINGLE, new NERTag[]{STATE_OR_PROVINCE,}, new String[]{&quot;NNP&quot;}, 0.0165825918941120660),</span>
<span class="nc" id="L141">    PER_STATE_OR_PROVINCES_OF_DEATH(&quot;per:stateorprovince_of_death&quot;, true, 3, PERSON, Cardinality.SINGLE, new NERTag[]{STATE_OR_PROVINCE,}, new String[]{&quot;NNP&quot;}, 0.0050083303444366030),</span>
<span class="nc" id="L142">    PER_STATE_OR_PROVINCES_OF_RESIDENCE(&quot;per:stateorprovinces_of_residence&quot;, true, 5, PERSON, Cardinality.LIST, new NERTag[]{STATE_OR_PROVINCE,}, new String[]{&quot;NNP&quot;}, 0.0066787379528178550),</span>
<span class="nc" id="L143">    PER_AGE(&quot;per:age&quot;, true, 3, PERSON, Cardinality.SINGLE, new NERTag[]{NUMBER, DURATION}, new String[]{&quot;CD&quot;, &quot;NN&quot;}, 0.0483159977322951300),</span>
<span class="nc" id="L144">    PER_DATE_OF_BIRTH(&quot;per:date_of_birth&quot;, true, 3, PERSON, Cardinality.SINGLE, new NERTag[]{DATE}, new String[]{&quot;CD&quot;, &quot;NN&quot;}, 0.0743584477791533200),</span>
<span class="nc" id="L145">    PER_DATE_OF_DEATH(&quot;per:date_of_death&quot;, true, 3, PERSON, Cardinality.SINGLE, new NERTag[]{DATE}, new String[]{&quot;CD&quot;, &quot;NN&quot;}, 0.0189819046406960460),</span>
<span class="nc" id="L146">    PER_CAUSE_OF_DEATH(&quot;per:cause_of_death&quot;, true, 3, PERSON, Cardinality.SINGLE, new NERTag[]{CAUSE_OF_DEATH}, new String[]{&quot;NN&quot;}, 1.0123682475037891E-5),</span>
<span class="nc" id="L147">    PER_CHARGES(&quot;per:charges&quot;, true, 5, PERSON, Cardinality.LIST, new NERTag[]{CRIMINAL_CHARGE}, new String[]{&quot;NN&quot;}, 3.8614617440501670E-4),</span>
<span class="nc" id="L148">    PER_RELIGION(&quot;per:religion&quot;, true, 3, PERSON, Cardinality.SINGLE, new NERTag[]{RELIGION}, new String[]{&quot;NN&quot;}, 7.6650738739572610E-4),</span>
<span class="nc" id="L149">    PER_TITLE(&quot;per:title&quot;, true, 15, PERSON, Cardinality.LIST, new NERTag[]{TITLE, MODIFIER}, new String[]{&quot;NN&quot;}, 0.0334283995325751200),</span>
<span class="nc" id="L150">    ORG_ALTERNATE_NAMES(&quot;org:alternate_names&quot;, true, 10, ORGANIZATION, Cardinality.LIST, new NERTag[]{ORGANIZATION, MISC}, new String[]{&quot;NNP&quot;}, 0.0552058867767352000),</span>
<span class="nc" id="L151">    ORG_CITY_OF_HEADQUARTERS(&quot;org:city_of_headquarters&quot;, true, 3, ORGANIZATION, Cardinality.SINGLE, new NERTag[]{CITY, LOCATION}, new String[]{&quot;NNP&quot;}, 0.0555949254318473740),</span>
<span class="nc" id="L152">    ORG_COUNTRY_OF_HEADQUARTERS(&quot;org:country_of_headquarters&quot;, true, 3, ORGANIZATION, Cardinality.SINGLE, new NERTag[]{COUNTRY, NATIONALITY}, new String[]{&quot;NNP&quot;}, 0.0580217167451493100),</span>
<span class="nc" id="L153">    ORG_FOUNDED_BY(&quot;org:founded_by&quot;, true, 3, ORGANIZATION, Cardinality.LIST, new NERTag[]{PERSON, ORGANIZATION}, new String[]{&quot;NNP&quot;}, 0.0050806423621154450),</span>
<span class="nc" id="L154">    ORG_LOC_OF_HEADQUARTERS(&quot;org:LOCATION_of_headquarters&quot;, true, 10, ORGANIZATION, Cardinality.LIST, new NERTag[]{CITY, STATE_OR_PROVINCE, COUNTRY,}, new String[]{&quot;NNP&quot;}, 0.0555949254318473740),</span>
<span class="nc" id="L155">    ORG_MEMBER_OF(&quot;org:member_of&quot;, true, 20, ORGANIZATION, Cardinality.LIST, new NERTag[]{ORGANIZATION, STATE_OR_PROVINCE, COUNTRY,}, new String[]{&quot;NNP&quot;}, 0.0396298781687126140),</span>
<span class="nc" id="L156">    ORG_MEMBERS(&quot;org:members&quot;, true, 20, ORGANIZATION, Cardinality.LIST, new NERTag[]{ORGANIZATION, COUNTRY}, new String[]{&quot;NNP&quot;}, 0.0012220730987724312),</span>
<span class="nc" id="L157">    ORG_PARENTS(&quot;org:parents&quot;, true, 10, ORGANIZATION, Cardinality.LIST, new NERTag[]{ORGANIZATION,}, new String[]{&quot;NNP&quot;}, 0.0550048593675880200),</span>
<span class="nc" id="L158">    ORG_POLITICAL_RELIGIOUS_AFFILIATION(&quot;org:political/religious_affiliation&quot;, true, 5, ORGANIZATION, Cardinality.LIST, new NERTag[]{IDEOLOGY, RELIGION}, new String[]{&quot;NN&quot;, &quot;JJ&quot;}, 0.0059266929689578970),</span>
<span class="nc" id="L159">    ORG_SHAREHOLDERS(&quot;org:shareholders&quot;, true, 10, ORGANIZATION, Cardinality.LIST, new NERTag[]{PERSON, ORGANIZATION}, new String[]{&quot;NNP&quot;}, 1.1569922828614734E-5),</span>
<span class="nc" id="L160">    ORG_STATE_OR_PROVINCES_OF_HEADQUARTERS(&quot;org:stateorprovince_of_headquarters&quot;, true, 3, ORGANIZATION, Cardinality.SINGLE, new NERTag[]{STATE_OR_PROVINCE}, new String[]{&quot;NNP&quot;}, 0.0312619314829170100),</span>
<span class="nc" id="L161">    ORG_SUBSIDIARIES(&quot;org:subsidiaries&quot;, true, 20, ORGANIZATION, Cardinality.LIST, new NERTag[]{ORGANIZATION}, new String[]{&quot;NNP&quot;}, 0.0162412791706679320),</span>
<span class="nc" id="L162">    ORG_TOP_MEMBERS_SLASH_EMPLOYEES(&quot;org:top_members/employees&quot;, true, 10, ORGANIZATION, Cardinality.LIST, new NERTag[]{PERSON}, new String[]{&quot;NNP&quot;}, 0.0907168724184609800),</span>
<span class="nc" id="L163">    ORG_DISSOLVED(&quot;org:dissolved&quot;, true, 3, ORGANIZATION, Cardinality.SINGLE, new NERTag[]{DATE}, new String[]{&quot;CD&quot;, &quot;NN&quot;}, 0.0023877428237553656),</span>
<span class="nc" id="L164">    ORG_FOUNDED(&quot;org:founded&quot;, true, 3, ORGANIZATION, Cardinality.SINGLE, new NERTag[]{DATE}, new String[]{&quot;CD&quot;, &quot;NN&quot;}, 0.0796314401082944800),</span>
<span class="nc" id="L165">    ORG_NUMBER_OF_EMPLOYEES_SLASH_MEMBERS(&quot;org:number_of_employees/members&quot;, true, 3, ORGANIZATION, Cardinality.SINGLE, new NERTag[]{NUMBER}, new String[]{&quot;CD&quot;, &quot;NN&quot;}, 0.0366274831946870950),</span>
<span class="nc" id="L166">    ORG_WEBSITE(&quot;org:website&quot;, true, 3, ORGANIZATION, Cardinality.SINGLE, new NERTag[]{URL}, new String[]{&quot;NNP&quot;, &quot;NN&quot;}, 0.0051544006201478640),</span>
    // Inverse types
<span class="nc" id="L168">    ORG_EMPLOYEES(&quot;org:employees_or_members&quot;, false, 68, ORGANIZATION, Cardinality.LIST, new NERTag[]{PERSON}, new String[]{&quot;NNP&quot;, &quot;NN&quot;}, 0.0051544006201478640),</span>
<span class="nc" id="L169">    GPE_EMPLOYEES(&quot;gpe:employees_or_members&quot;, false, 10, GPE, Cardinality.LIST, new NERTag[]{PERSON}, new String[]{&quot;NNP&quot;, &quot;NN&quot;}, 0.0051544006201478640),</span>
<span class="nc" id="L170">    ORG_STUDENTS(&quot;org:students&quot;, false, 50, ORGANIZATION, Cardinality.LIST, new NERTag[]{PERSON}, new String[]{&quot;NNP&quot;, &quot;NN&quot;}, 0.0051544006201478640),</span>
<span class="nc" id="L171">    GPE_BIRTHS_IN_CITY(&quot;gpe:births_in_city&quot;, false, 50, GPE, Cardinality.LIST, new NERTag[]{PERSON}, new String[]{&quot;NNP&quot;, &quot;NN&quot;}, 0.0051544006201478640),</span>
<span class="nc" id="L172">    GPE_BIRTHS_IN_STATE_OR_PROVINCE(&quot;gpe:births_in_stateorprovince&quot;, false, 50, GPE, Cardinality.LIST, new NERTag[]{PERSON}, new String[]{&quot;NNP&quot;, &quot;NN&quot;}, 0.0051544006201478640),</span>
<span class="nc" id="L173">    GPE_BIRTHS_IN_COUNTRY(&quot;gpe:births_in_country&quot;, false, 50, GPE, Cardinality.LIST, new NERTag[]{PERSON}, new String[]{&quot;NNP&quot;, &quot;NN&quot;}, 0.0051544006201478640),</span>
<span class="nc" id="L174">    GPE_RESIDENTS_IN_CITY(&quot;gpe:residents_of_city&quot;, false, 50, GPE, Cardinality.LIST, new NERTag[]{PERSON}, new String[]{&quot;NNP&quot;, &quot;NN&quot;}, 0.0051544006201478640),</span>
<span class="nc" id="L175">    GPE_RESIDENTS_IN_STATE_OR_PROVINCE(&quot;gpe:residents_of_stateorprovince&quot;, false, 50, GPE, Cardinality.LIST, new NERTag[]{PERSON}, new String[]{&quot;NNP&quot;, &quot;NN&quot;}, 0.0051544006201478640),</span>
<span class="nc" id="L176">    GPE_RESIDENTS_IN_COUNTRY(&quot;gpe:residents_of_country&quot;, false, 50, GPE, Cardinality.LIST, new NERTag[]{PERSON}, new String[]{&quot;NNP&quot;, &quot;NN&quot;}, 0.0051544006201478640),</span>
<span class="nc" id="L177">    GPE_DEATHS_IN_CITY(&quot;gpe:deaths_in_city&quot;, false, 50, GPE, Cardinality.LIST, new NERTag[]{PERSON}, new String[]{&quot;NNP&quot;, &quot;NN&quot;}, 0.0051544006201478640),</span>
<span class="nc" id="L178">    GPE_DEATHS_IN_STATE_OR_PROVINCE(&quot;gpe:deaths_in_stateorprovince&quot;, false, 50, GPE, Cardinality.LIST, new NERTag[]{PERSON}, new String[]{&quot;NNP&quot;, &quot;NN&quot;}, 0.0051544006201478640),</span>
<span class="nc" id="L179">    GPE_DEATHS_IN_COUNTRY(&quot;gpe:deaths_in_country&quot;, false, 50, GPE, Cardinality.LIST, new NERTag[]{PERSON}, new String[]{&quot;NNP&quot;, &quot;NN&quot;}, 0.0051544006201478640),</span>
<span class="nc" id="L180">    PER_HOLDS_SHARES_IN(&quot;per:holds_shares_in&quot;, false, 10, PERSON, Cardinality.LIST, new NERTag[]{ORGANIZATION}, new String[]{&quot;NNP&quot;, &quot;NN&quot;}, 0.0051544006201478640),</span>
<span class="nc" id="L181">    GPE_HOLDS_SHARES_IN(&quot;gpe:holds_shares_in&quot;, false, 10, GPE, Cardinality.LIST, new NERTag[]{ORGANIZATION}, new String[]{&quot;NNP&quot;, &quot;NN&quot;}, 0.0051544006201478640),</span>
<span class="nc" id="L182">    ORG_HOLDS_SHARES_IN(&quot;org:holds_shares_in&quot;, false, 10, ORGANIZATION, Cardinality.LIST, new NERTag[]{ORGANIZATION}, new String[]{&quot;NNP&quot;, &quot;NN&quot;}, 0.0051544006201478640),</span>
<span class="nc" id="L183">    PER_ORGANIZATIONS_FOUNDED(&quot;per:organizations_founded&quot;, false, 3, PERSON, Cardinality.LIST, new NERTag[]{ORGANIZATION}, new String[]{&quot;NNP&quot;, &quot;NN&quot;}, 0.0051544006201478640),</span>
<span class="nc" id="L184">    GPE_ORGANIZATIONS_FOUNDED(&quot;gpe:organizations_founded&quot;, false, 3, GPE, Cardinality.LIST, new NERTag[]{ORGANIZATION}, new String[]{&quot;NNP&quot;, &quot;NN&quot;}, 0.0051544006201478640),</span>
<span class="nc" id="L185">    ORG_ORGANIZATIONS_FOUNDED(&quot;org:organizations_founded&quot;, false, 3, ORGANIZATION, Cardinality.LIST, new NERTag[]{ORGANIZATION}, new String[]{&quot;NNP&quot;, &quot;NN&quot;}, 0.0051544006201478640),</span>
<span class="nc" id="L186">    PER_TOP_EMPLOYEE_OF(&quot;per:top_member_employee_of&quot;, false, 5, PERSON, Cardinality.LIST, new NERTag[]{ORGANIZATION}, new String[]{&quot;NNP&quot;, &quot;NN&quot;}, 0.0051544006201478640),</span>
<span class="nc" id="L187">    GPE_MEMBER_OF(&quot;gpe:member_of&quot;, false, 10, GPE, Cardinality.LIST, new NERTag[]{ORGANIZATION}, new String[]{&quot;NNP&quot;}, 0.0396298781687126140),</span>
<span class="nc" id="L188">    GPE_SUBSIDIARIES(&quot;gpe:subsidiaries&quot;, false, 10, GPE, Cardinality.LIST, new NERTag[]{ORGANIZATION}, new String[]{&quot;NNP&quot;}, 0.0396298781687126140),</span>
<span class="nc" id="L189">    GPE_HEADQUARTERS_IN_CITY(&quot;gpe:headquarters_in_city&quot;, false, 50, GPE, Cardinality.LIST, new NERTag[]{ORGANIZATION}, new String[]{&quot;NNP&quot;, &quot;NN&quot;}, 0.0051544006201478640),</span>
<span class="nc" id="L190">    GPE_HEADQUARTERS_IN_STATE_OR_PROVINCE(&quot;gpe:headquarters_in_stateorprovince&quot;, false, 50, GPE, Cardinality.LIST, new NERTag[]{ORGANIZATION}, new String[]{&quot;NNP&quot;, &quot;NN&quot;}, 0.0051544006201478640),</span>
<span class="nc" id="L191">    GPE_HEADQUARTERS_IN_COUNTRY(&quot;gpe:headquarters_in_country&quot;, false, 50, GPE, Cardinality.LIST, new NERTag[]{ORGANIZATION}, new String[]{&quot;NNP&quot;, &quot;NN&quot;}, 0.0051544006201478640),</span>
    ;

<span class="nc" id="L194">    public enum Cardinality {</span>
<span class="nc" id="L195">      SINGLE,</span>
<span class="nc" id="L196">      LIST</span>
    }

    /**
     * A canonical name for this relation type. This is the official 2010 relation name,
     * that has since changed.
     */
    public final String canonicalName;
    /**
     * If true, realtation was one of the original (non-inverse) KBP relation.
     */
    public final boolean isOriginalRelation;
    /**
     * A guess of the maximum number of results to query for this relation.
     * Only really relevant for cold start.
     */
    public final int queryLimit;
    /**
     * The entity type (left arg type) associated with this relation. That is, either a PERSON or an ORGANIZATION &quot;slot&quot;.
     */
    public final NERTag entityType;
    /**
     * The cardinality of this entity. That is, can multiple right arguments participate in this relation (born_in vs. lived_in)
     */
    public final Cardinality cardinality;
    /**
     * Valid named entity labels for the right argument to this relation
     */
    public final Set&lt;NERTag&gt; validNamedEntityLabels;
    /**
     * Valid POS [prefixes] for the right argument to this relation (e.g., can only take nouns, or can only take numbers, etc.)
     */
    public final Set&lt;String&gt; validPOSPrefixes;
    /**
     * The prior for how often this relation occurs in the training data.
     * Note that this prior is not necessarily accurate for the test data.
     */
    public final double priorProbability;


    RelationType(String canonicalName, boolean isOriginalRelation, int queryLimit, NERTag type, Cardinality cardinality, NERTag[] validNamedEntityLabels, String[] validPOSPrefixes,
<span class="nc" id="L237">                 double priorProbability) {</span>
<span class="nc" id="L238">      this.canonicalName          = canonicalName;</span>
<span class="nc" id="L239">      this.isOriginalRelation     = isOriginalRelation;</span>
<span class="nc" id="L240">      this.queryLimit             = queryLimit;</span>
<span class="nc" id="L241">      this.entityType             = type;</span>
<span class="nc" id="L242">      this.cardinality            = cardinality;</span>
<span class="nc" id="L243">      this.validNamedEntityLabels = new HashSet&lt;&gt;(Arrays.asList(validNamedEntityLabels));</span>
<span class="nc" id="L244">      this.validPOSPrefixes       = new HashSet&lt;&gt;(Arrays.asList(validPOSPrefixes));</span>
<span class="nc" id="L245">      this.priorProbability       = priorProbability;</span>
<span class="nc" id="L246">    }</span>

    /** A small cache of names to relation types; we call fromString() a lot in the code, usually expecting it to be very fast */
<span class="nc" id="L249">    private static final Map&lt;String, RelationType&gt; cachedFromString = new HashMap&lt;&gt;();</span>

    /** Find the slot for a given name */
    public static Optional&lt;RelationType&gt; fromString(String name) {
<span class="nc bnc" id="L253" title="All 2 branches missed.">      if (name == null) { return Optional.empty(); }</span>
<span class="nc" id="L254">      String originalName = name;</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">      if (cachedFromString.get(name) != null) { return Optional.of(cachedFromString.get(name)); }</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">      if (cachedFromString.containsKey(name)) { return Optional.empty(); }</span>
      // Try naive
<span class="nc bnc" id="L258" title="All 2 branches missed.">      for (RelationType slot : RelationType.values()) {</span>
<span class="nc bnc" id="L259" title="All 4 branches missed.">        if (slot.canonicalName.equals(name) || slot.name().equals(name)) {</span>
<span class="nc" id="L260">          cachedFromString.put(originalName, slot);</span>
<span class="nc" id="L261">          return Optional.of(slot);</span>
        }
      }
      // Replace slashes
<span class="nc" id="L265">      name = name.toLowerCase().replaceAll(&quot;[Ss][Ll][Aa][Ss][Hh]&quot;, &quot;/&quot;);</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">      for (RelationType slot : RelationType.values()) {</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">        if (slot.canonicalName.equalsIgnoreCase(name)) {</span>
<span class="nc" id="L268">          cachedFromString.put(originalName, slot);</span>
<span class="nc" id="L269">          return Optional.of(slot);</span>
        }
      }
<span class="nc" id="L272">      cachedFromString.put(originalName, null);</span>
<span class="nc" id="L273">      return Optional.empty();</span>
    }


    /**
     * Returns whether two entity types could plausibly have a relation hold between them.
     * That is, is there a known relation type that would hold between these two entity types.
     * @param entityType The NER tag of the entity.
     * @param slotValueType The NER tag of the slot value.
     * @return True if there is a plausible relation which could occur between these two types.
     */
    public static boolean plausiblyHasRelation(NERTag entityType, NERTag slotValueType) {
<span class="nc bnc" id="L285" title="All 2 branches missed.">      for (RelationType rel : RelationType.values()) {</span>
<span class="nc bnc" id="L286" title="All 4 branches missed.">        if (rel.entityType == entityType &amp;&amp; rel.validNamedEntityLabels.contains(slotValueType)) {</span>
<span class="nc" id="L287">          return true;</span>
        }
      }
<span class="nc" id="L290">      return false;</span>
    }
  }

  @SuppressWarnings(&quot;unused&quot;)
  class KBPInput {

    public final Span subjectSpan;
    public final Span objectSpan;
    public final NERTag subjectType;
    public final NERTag objectType;
    public final Sentence sentence;

    public KBPInput(Span subjectSpan, Span objectSpan,
                    NERTag subjectType, NERTag objectType,
<span class="nc" id="L305">                    Sentence sentence) {</span>
<span class="nc" id="L306">      this.subjectSpan = subjectSpan;</span>
<span class="nc" id="L307">      this.objectSpan = objectSpan;</span>
<span class="nc" id="L308">      this.subjectType = subjectType;</span>
<span class="nc" id="L309">      this.objectType = objectType;</span>
<span class="nc" id="L310">      this.sentence = sentence;</span>
<span class="nc" id="L311">    }</span>

    public Sentence getSentence() {
<span class="nc" id="L314">      return sentence;</span>
    }

    public Span getSubjectSpan() {
<span class="nc" id="L318">      return subjectSpan;</span>
    }

    public String getSubjectText() {
<span class="nc" id="L322">      return StringUtils.join(sentence.originalTexts().subList(subjectSpan.start(), subjectSpan.end()).stream(), &quot; &quot;);</span>
    }

    public Span getObjectSpan() {
<span class="nc" id="L326">      return objectSpan;</span>
    }

    public String getObjectText() {
<span class="nc" id="L330">      return StringUtils.join(sentence.originalTexts().subList(objectSpan.start(), objectSpan.end()).stream(), &quot; &quot;);</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L335">      return &quot;KBPInput{&quot; +</span>
          &quot;, subjectSpan=&quot; + subjectSpan +
          &quot;, objectSpan=&quot; + objectSpan +
          &quot;, sentence=&quot; + sentence +
          '}';
    }
  }

  /**
   * Read a dataset from a CoNLL formatted input file
   * @param conllInputFile The input file, formatted as a TSV
   * @return A list of examples.
   */
  @SuppressWarnings(&quot;StatementWithEmptyBody&quot;)
  static List&lt;Pair&lt;KBPInput, String&gt;&gt; readDataset(File conllInputFile) throws IOException {
<span class="nc" id="L350">    BufferedReader reader = IOUtils.readerFromFile(conllInputFile);</span>
<span class="nc" id="L351">    List&lt;Pair&lt;KBPInput, String&gt;&gt; examples = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L353">    int i = 0;</span>
<span class="nc" id="L354">    String relation = null;</span>
<span class="nc" id="L355">    List&lt;String&gt; tokens = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L356">    Span subject = new Span(Integer.MAX_VALUE, Integer.MIN_VALUE);</span>
<span class="nc" id="L357">    NERTag subjectNER = null;</span>
<span class="nc" id="L358">    Span object = new Span(Integer.MAX_VALUE, Integer.MIN_VALUE);</span>
<span class="nc" id="L359">    NERTag objectNER = null;</span>

<span class="nc" id="L361">    String line = reader.readLine();</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">    if (!line.startsWith(&quot;#&quot;)) {</span>
<span class="nc" id="L363">      throw new IllegalArgumentException(&quot;First line of input file should be header definition&quot;);</span>
    }
<span class="nc bnc" id="L365" title="All 2 branches missed.">    while ( (line = reader.readLine()) != null ) {</span>
<span class="nc" id="L366">      String[] fields = line.split(&quot;\t&quot;);</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">      if (relation == null) {</span>
        // Case: read the relation
<span class="nc bnc" id="L369" title="All 6 branches missed.">        assert fields.length == 1;</span>
<span class="nc" id="L370">        relation = fields[0];</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">      } else if (fields.length == 9) {</span>
        // Case: read a token
<span class="nc" id="L373">        tokens.add(fields[0]);</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">        if (&quot;SUBJECT&quot;.equals(fields[1])) {</span>
<span class="nc" id="L375">          subject = new Span(Math.min(subject.start(), i), Math.max(subject.end(), i + 1));</span>
<span class="nc" id="L376">          subjectNER = valueOf(fields[2].toUpperCase());</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">        } else if (&quot;OBJECT&quot;.equals(fields[3])) {</span>
<span class="nc" id="L378">          object = new Span(Math.min(object.start(), i), Math.max(object.end(), i + 1));</span>
<span class="nc" id="L379">          objectNER = valueOf(fields[4].toUpperCase());</span>
<span class="nc bnc" id="L380" title="All 4 branches missed.">        } else if (&quot;-&quot;.equals(fields[1]) &amp;&amp; &quot;-&quot;.equals(fields[3])) {</span>
          // do nothing
        } else {
<span class="nc" id="L383">          throw new IllegalStateException(&quot;Could not parse CoNLL file&quot;);</span>
        }
<span class="nc" id="L385">        i += 1;</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">      } else if (StringUtils.isNullOrEmpty(line.trim())) {</span>
        // Case: commit a sentence
<span class="nc" id="L388">        examples.add(Pair.makePair(new KBPInput(</span>
            subject,
            object,
            subjectNER,
            objectNER,
            new Sentence(tokens)
        ), relation));

        // (clear the variables)
<span class="nc" id="L397">        i = 0;</span>
<span class="nc" id="L398">        relation = null;</span>
<span class="nc" id="L399">        tokens = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L400">        subject = new Span(Integer.MAX_VALUE, Integer.MIN_VALUE);</span>
<span class="nc" id="L401">        object = new Span(Integer.MAX_VALUE, Integer.MIN_VALUE);</span>
      } else {
<span class="nc" id="L403">        throw new IllegalStateException(&quot;Could not parse CoNLL file&quot;);</span>
      }
<span class="nc" id="L405">    }</span>

<span class="nc" id="L407">    return examples;</span>
  }

  /** A class to compute the accuracy of a relation extractor. */
  @SuppressWarnings(&quot;unused&quot;)
<span class="fc" id="L412">  class Accuracy {</span>

    private static class PerRelationStat implements  Comparable&lt;PerRelationStat&gt; {
      public final String name;
      public final double precision;
      public final double recall;
      public final int predictedCount;
      public final int goldCount;
<span class="nc" id="L420">      public PerRelationStat(String name, double precision, double recall, int predictedCount, int goldCount) {</span>
<span class="nc" id="L421">        this.name = name;</span>
<span class="nc" id="L422">        this.precision = precision;</span>
<span class="nc" id="L423">        this.recall = recall;</span>
<span class="nc" id="L424">        this.predictedCount = predictedCount;</span>
<span class="nc" id="L425">        this.goldCount = goldCount;</span>
<span class="nc" id="L426">      }</span>
      public double f1() {
<span class="nc bnc" id="L428" title="All 4 branches missed.">        if (precision == 0.0 &amp;&amp; recall == 0.0) {</span>
<span class="nc" id="L429">          return 0.0;</span>
        } else {
<span class="nc" id="L431">          return 2.0 * precision * recall / (precision + recall);</span>
        }
      }
      @SuppressWarnings(&quot;NullableProblems&quot;)
      @Override
      public int compareTo(PerRelationStat o) {
<span class="nc bnc" id="L437" title="All 2 branches missed.">        if (this.precision &lt; o.precision) {</span>
<span class="nc" id="L438">          return -1;</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">        } else if (this.precision &gt; o.precision) {</span>
<span class="nc" id="L440">          return 1;</span>
        } else {
<span class="nc" id="L442">          return 0;</span>
        }
      }
      @Override
      public String toString() {
<span class="nc" id="L447">        DecimalFormat df = new DecimalFormat(&quot;0.00%&quot;);</span>
<span class="nc" id="L448">        return &quot;[&quot; + name + &quot;]  pred/gold: &quot; + predictedCount + &quot;/&quot; + goldCount + &quot;  P: &quot; + df.format(precision) + &quot;  R: &quot; + df.format(recall) + &quot;  F1: &quot; + df.format(f1());</span>
      }
    }

<span class="fc" id="L452">    private Counter&lt;String&gt; correctCount   = new ClassicCounter&lt;&gt;();</span>
<span class="fc" id="L453">    private Counter&lt;String&gt; predictedCount = new ClassicCounter&lt;&gt;();</span>
<span class="fc" id="L454">    private Counter&lt;String&gt; goldCount      = new ClassicCounter&lt;&gt;();</span>
<span class="fc" id="L455">    private Counter&lt;String&gt; totalCount     = new ClassicCounter&lt;&gt;();</span>
<span class="fc" id="L456">    public final ConfusionMatrix&lt;String&gt; confusion = new ConfusionMatrix&lt;&gt;();</span>


    public void predict(Set&lt;String&gt; predictedRelationsRaw, Set&lt;String&gt; goldRelationsRaw) {
<span class="fc" id="L460">      Set&lt;String&gt; predictedRelations = new HashSet&lt;&gt;(predictedRelationsRaw);</span>
<span class="fc" id="L461">      predictedRelations.remove(NO_RELATION);</span>
<span class="fc" id="L462">      Set&lt;String&gt; goldRelations = new HashSet&lt;&gt;(goldRelationsRaw);</span>
<span class="fc" id="L463">      goldRelations.remove(NO_RELATION);</span>
      // Register the prediction
<span class="fc bfc" id="L465" title="All 2 branches covered.">      for (String pred : predictedRelations) {</span>
<span class="fc bfc" id="L466" title="All 2 branches covered.">        if (goldRelations.contains(pred)) {</span>
<span class="fc" id="L467">          correctCount.incrementCount(pred);</span>
        }
<span class="fc" id="L469">        predictedCount.incrementCount(pred);</span>
<span class="fc" id="L470">      }</span>
<span class="fc" id="L471">      goldRelations.forEach(goldCount::incrementCount);</span>
<span class="fc" id="L472">      HashSet&lt;String&gt; allRelations = new HashSet&lt;String&gt;(){{ addAll(predictedRelations); addAll(goldRelations); }};</span>
<span class="fc" id="L473">      allRelations.forEach(totalCount::incrementCount);</span>

      // Register the confusion matrix
<span class="fc bfc" id="L476" title="All 4 branches covered.">      if (predictedRelations.size() == 1 &amp;&amp; goldRelations.size() == 1) {</span>
<span class="fc" id="L477">        confusion.add(predictedRelations.iterator().next(), goldRelations.iterator().next());</span>
      }
<span class="fc bfc" id="L479" title="All 4 branches covered.">      if (predictedRelations.size() == 1 &amp;&amp; goldRelations.isEmpty()) {</span>
<span class="fc" id="L480">        confusion.add(predictedRelations.iterator().next(), &quot;NR&quot;);</span>
      }
<span class="fc bfc" id="L482" title="All 4 branches covered.">      if (predictedRelations.isEmpty() &amp;&amp; goldRelations.size() == 1) {</span>
<span class="fc" id="L483">        confusion.add(&quot;NR&quot;, goldRelations.iterator().next());</span>
      }
<span class="fc" id="L485">    }</span>

    public double precision(String relation) {
<span class="pc bpc" id="L488" title="1 of 2 branches missed.">      if (predictedCount.getCount(relation) == 0) {</span>
<span class="nc" id="L489">        return 1.0;</span>
      }
<span class="fc" id="L491">      return correctCount.getCount(relation) / predictedCount.getCount(relation);</span>
    }

    public double precisionMicro() {
<span class="pc bpc" id="L495" title="1 of 2 branches missed.">      if (predictedCount.totalCount() == 0) {</span>
<span class="nc" id="L496">        return 1.0;</span>
      }
<span class="fc" id="L498">      return correctCount.totalCount() / predictedCount.totalCount();</span>
    }

    public double precisionMacro() {
<span class="fc" id="L502">      double sumPrecision = 0.0;</span>
<span class="fc bfc" id="L503" title="All 2 branches covered.">      for (String rel : totalCount.keySet()) {</span>
<span class="fc" id="L504">        sumPrecision += precision(rel);</span>
<span class="fc" id="L505">      }</span>
<span class="fc" id="L506">      return sumPrecision / ((double) totalCount.size());</span>
    }


    public double recall(String relation) {
<span class="pc bpc" id="L511" title="1 of 2 branches missed.">      if (goldCount.getCount(relation) == 0) {</span>
<span class="nc" id="L512">        return 0.0;</span>
      }
<span class="fc" id="L514">      return correctCount.getCount(relation) / goldCount.getCount(relation);</span>
    }

    public double recallMicro() {
<span class="pc bpc" id="L518" title="1 of 2 branches missed.">      if (goldCount.totalCount() == 0) {</span>
<span class="nc" id="L519">        return 0.0;</span>
      }
<span class="fc" id="L521">      return correctCount.totalCount() / goldCount.totalCount();</span>
    }

    public double recallMacro() {
<span class="fc" id="L525">      double sumRecall = 0.0;</span>
<span class="fc bfc" id="L526" title="All 2 branches covered.">      for (String rel : totalCount.keySet()) {</span>
<span class="fc" id="L527">        sumRecall += recall(rel);</span>
<span class="fc" id="L528">      }</span>
<span class="fc" id="L529">      return sumRecall / ((double) totalCount.size());</span>
    }

    public double f1(String relation) {
<span class="fc" id="L533">      return 2.0 * precision(relation) * recall(relation) / (precision(relation) + recall(relation));</span>
    }

    public double f1Micro() {
<span class="nc" id="L537">      return 2.0 * precisionMicro() * recallMicro() / (precisionMicro() + recallMicro());</span>
    }

    public double f1Macro() {
<span class="nc" id="L541">      return 2.0 * precisionMacro() * recallMacro() / (precisionMacro() + recallMacro());</span>
    }

    public void dumpPerRelationStats(PrintStream out) {
<span class="nc" id="L545">      List&lt;PerRelationStat&gt; stats = goldCount.keySet().stream().map(relation -&gt; new PerRelationStat(relation, precision(relation), recall(relation), (int) predictedCount.getCount(relation), (int) goldCount.getCount(relation))).collect(Collectors.toList());</span>
<span class="nc" id="L546">      Collections.sort(stats);</span>
<span class="nc" id="L547">      out.println(&quot;Per-relation Accuracy&quot;);</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">      for (PerRelationStat stat : stats) {</span>
<span class="nc" id="L549">        out.println(stat);</span>
<span class="nc" id="L550">      }</span>
<span class="nc" id="L551">    }</span>

    public void dumpPerRelationStats() {
<span class="nc" id="L554">      dumpPerRelationStats(System.out);</span>

<span class="nc" id="L556">    }</span>

    public void toString(PrintStream out) {
<span class="nc" id="L559">      out.println();</span>
<span class="nc" id="L560">      out.println(&quot;PRECISION (micro average): &quot; + new DecimalFormat(&quot;0.000%&quot;).format(precisionMicro()));</span>
<span class="nc" id="L561">      out.println(&quot;RECALL    (micro average): &quot; + new DecimalFormat(&quot;0.000%&quot;).format(recallMicro()));</span>
<span class="nc" id="L562">      out.println(&quot;F1        (micro average): &quot; + new DecimalFormat(&quot;0.000%&quot;).format(f1Micro()));</span>
<span class="nc" id="L563">      out.println();</span>
<span class="nc" id="L564">      out.println(&quot;PRECISION (macro average): &quot; + new DecimalFormat(&quot;0.000%&quot;).format(precisionMacro()));</span>
<span class="nc" id="L565">      out.println(&quot;RECALL    (macro average): &quot; + new DecimalFormat(&quot;0.000%&quot;).format(recallMacro()));</span>
<span class="nc" id="L566">      out.println(&quot;F1        (macro average): &quot; + new DecimalFormat(&quot;0.000%&quot;).format(f1Macro()));</span>
<span class="nc" id="L567">      out.println();</span>
<span class="nc" id="L568">    }</span>

    public String toString() {
<span class="nc" id="L571">      ByteArrayOutputStream bs = new ByteArrayOutputStream();</span>
<span class="nc" id="L572">      PrintStream out = new PrintStream(bs);</span>
<span class="nc" id="L573">      toString(out);</span>
<span class="nc" id="L574">      return bs.toString();</span>
    }

    /**
     * A short, single line summary of the micro-precision/recall/f1.
     */
    public String toOneLineString() {
<span class="nc" id="L581">      return</span>
<span class="nc" id="L582">          &quot;P: &quot; + new DecimalFormat(&quot;0.000%&quot;).format(precisionMicro()) + &quot;  &quot; +</span>
<span class="nc" id="L583">          &quot;R: &quot; + new DecimalFormat(&quot;0.000%&quot;).format(recallMicro()) + &quot;  &quot; +</span>
<span class="nc" id="L584">          &quot;F1: &quot; + new DecimalFormat(&quot;0.000%&quot;).format(f1Micro());</span>
    }
  }

  default Accuracy computeAccuracy(Stream&lt;Pair&lt;KBPInput, String&gt;&gt; examples,
                                   Optional&lt;PrintStream&gt; predictOut) {
<span class="nc" id="L590">    forceTrack(&quot;Accuracy&quot;);</span>
<span class="nc" id="L591">    Accuracy accuracy = new Accuracy();</span>
<span class="nc" id="L592">    AtomicInteger testI = new AtomicInteger(0);</span>
<span class="nc" id="L593">    DecimalFormat confidenceFormat = new DecimalFormat(&quot;0.0000&quot;);</span>
<span class="nc" id="L594">    forceTrack(&quot;Featurizing&quot;);</span>
<span class="nc" id="L595">    examples.parallel().map(example -&gt; {</span>
<span class="nc" id="L596">      Pair&lt;String, Double&gt; predicted = this.classify(example.first);</span>
<span class="nc" id="L597">      synchronized (accuracy) {</span>
<span class="nc" id="L598">        accuracy.predict(Collections.singleton(predicted.first), Collections.singleton(example.second));</span>
<span class="nc" id="L599">      }</span>
<span class="nc bnc" id="L600" title="All 2 branches missed.">      if (testI.incrementAndGet() % 1000 == 0) {</span>
<span class="nc" id="L601">        log(KBPRelationExtractor.class, &quot;[&quot; + testI.get() + &quot;]  &quot; + accuracy.toOneLineString());</span>
      }
<span class="nc" id="L603">      return predicted.first + &quot;\t&quot; + confidenceFormat.format(predicted.second);</span>
    })
<span class="nc" id="L605">      .forEachOrdered(line -&gt; {</span>
<span class="nc bnc" id="L606" title="All 2 branches missed.">        if (predictOut.isPresent()) {</span>
<span class="nc" id="L607">          predictOut.get().println(line);</span>
        }
<span class="nc" id="L609">      });</span>
<span class="nc" id="L610">    endTrack(&quot;Featurizing&quot;);</span>
<span class="nc" id="L611">    log(accuracy.toString());</span>
<span class="nc" id="L612">    endTrack(&quot;Accuracy&quot;);</span>
<span class="nc" id="L613">    return accuracy;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>