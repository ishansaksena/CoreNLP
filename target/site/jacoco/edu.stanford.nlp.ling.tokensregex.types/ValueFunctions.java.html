<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ValueFunctions.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.ling.tokensregex.types</a> &gt; <span class="el_source">ValueFunctions.java</span></div><h1>ValueFunctions.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.ling.tokensregex.types;

import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.ling.tokensregex.*;
import edu.stanford.nlp.pipeline.ChunkAnnotationUtils;
import edu.stanford.nlp.process.CoreLabelTokenFactory;
import edu.stanford.nlp.util.*;

import java.lang.reflect.Field;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.*;
import java.util.function.Function;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * ValueFunctions supported by tokensregex.
 *
 * @author Angel Chang
 */
public class ValueFunctions {

<span class="nc" id="L24">  private ValueFunctions() {} // static methods</span>

  protected static Object lookupFunctionObject(Env env, String name) {
<span class="nc bnc" id="L27" title="All 2 branches missed.">    if (env != null) {</span>
<span class="nc" id="L28">      Object obj = env.get(name);</span>
<span class="nc bnc" id="L29" title="All 2 branches missed.">      if (obj != null) {</span>
<span class="nc" id="L30">        return obj;</span>
      }
    }
<span class="nc" id="L33">    return registeredFunctions.get(name);</span>
  }

  public abstract static class NamedValueFunction implements ValueFunction {
    protected String name;
    protected String signature;

<span class="nc" id="L40">    public NamedValueFunction(String name) {</span>
<span class="nc" id="L41">      this.name = name;</span>
<span class="nc" id="L42">    }</span>

    @Override
<span class="nc" id="L45">    public String getDescription() { return &quot;&quot;; }</span>

<span class="nc" id="L47">    public String getParamDesc() { return &quot;...&quot;; }</span>

    protected static String getParamDesc(String type, int nargs) {
<span class="nc bnc" id="L50" title="All 2 branches missed.">      if (nargs &lt; 0) {</span>
<span class="nc" id="L51">        return type + &quot;...&quot;;</span>
<span class="nc bnc" id="L52" title="All 2 branches missed.">      } else if (nargs &lt;= 3) {</span>
<span class="nc" id="L53">        String[] tmp = new String[nargs];</span>
<span class="nc" id="L54">        Arrays.fill(tmp, type);</span>
<span class="nc" id="L55">        return StringUtils.join(tmp, &quot;,&quot;);</span>
<span class="nc" id="L56">      } else return type + &quot;[&quot; + nargs + &quot;]&quot;;</span>
    }

    protected static String getTypeName(Class c) {
<span class="nc" id="L60">      return c.getCanonicalName();</span>
    }

    public String toString() {
<span class="nc bnc" id="L64" title="All 2 branches missed.">      if (signature == null) {</span>
<span class="nc" id="L65">        signature = name + '(' + getParamDesc() + ')';</span>
      }
<span class="nc" id="L67">      return signature;</span>
    }

  } // end static class NamedValueFunction


  public static class ParamInfo {
    public final String name;
    public final String typeName;
    public final Class className;
    public final boolean nullable;

<span class="nc" id="L79">    public ParamInfo(String name, String typeName, Class className, boolean nullable) {</span>
<span class="nc" id="L80">      this.name = name;</span>
<span class="nc" id="L81">      this.typeName = typeName;</span>
<span class="nc" id="L82">      this.className = className;</span>
<span class="nc" id="L83">      this.nullable = nullable;</span>
<span class="nc" id="L84">    }</span>
  }

  public abstract static class TypeCheckedFunction extends NamedValueFunction {
    List&lt;ParamInfo&gt; paramInfos;
    int nargs;

    public TypeCheckedFunction(String name, List&lt;ParamInfo&gt; paramInfos) {
<span class="nc" id="L92">      super(name);</span>
<span class="nc" id="L93">      this.paramInfos = paramInfos;</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">      nargs = (paramInfos != null)? paramInfos.size():0;</span>
<span class="nc" id="L95">    }</span>

    public TypeCheckedFunction(String name, ParamInfo... paramInfos) {
<span class="nc" id="L98">      super(name);</span>
<span class="nc" id="L99">      this.paramInfos = Arrays.asList(paramInfos);</span>
<span class="nc" id="L100">      nargs = paramInfos.length;</span>
<span class="nc" id="L101">    }</span>

    @Override
    public String getParamDesc() {
<span class="nc" id="L105">      StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L106" title="All 2 branches missed.">      for (ParamInfo p:paramInfos) {</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">        if (sb.length() &gt; 0) {</span>
<span class="nc" id="L108">          sb.append(&quot;, &quot;);</span>
        }
<span class="nc bnc" id="L110" title="All 2 branches missed.">        if (p.typeName != null) {</span>
<span class="nc" id="L111">          sb.append(p.typeName);</span>
        } else {
<span class="nc" id="L113">          sb.append(getTypeName(p.className));</span>
        }
<span class="nc" id="L115">      }</span>
<span class="nc" id="L116">      return sb.toString();</span>
    }

    @Override
    public boolean checkArgs(List&lt;Value&gt; in) {
<span class="nc bnc" id="L121" title="All 2 branches missed.">      if (in.size() != nargs) {</span>
<span class="nc" id="L122">        return false;</span>
      }
<span class="nc bnc" id="L124" title="All 2 branches missed.">      for (int i = 0; i &lt; in.size(); i++) {</span>
<span class="nc" id="L125">        Value v = in.get(i);</span>
<span class="nc" id="L126">        ParamInfo p = paramInfos.get(i);</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">        if (v == null) {</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">          if (!p.nullable) {</span>
<span class="nc" id="L129">            return false;</span>
          }
        } else {
<span class="nc bnc" id="L132" title="All 4 branches missed.">          if (p.typeName != null &amp;&amp; !p.typeName.equals(v.getType())) {</span>
<span class="nc" id="L133">            return false;</span>
          }
<span class="nc bnc" id="L135" title="All 2 branches missed.">          if (v.get() != null) {</span>
<span class="nc bnc" id="L136" title="All 4 branches missed.">            if (p.className != null &amp;&amp; !(p.className.isAssignableFrom(v.get().getClass()))) {</span>
<span class="nc" id="L137">              return false;</span>
            }
          }
        }
      }
<span class="nc" id="L142">      return true;</span>
    }
  }

  public abstract static class NumericFunction extends NamedValueFunction {
<span class="nc" id="L147">    protected String resultTypeName = Expressions.TYPE_NUMBER;</span>
<span class="nc" id="L148">    protected int nargs = 2;</span>

    protected NumericFunction(String name, int nargs) {
<span class="nc" id="L151">      super(name);</span>
<span class="nc" id="L152">      this.nargs = nargs;</span>
<span class="nc" id="L153">    }</span>

    protected NumericFunction(String name, int nargs, String resultTypeName) {
<span class="nc" id="L156">      super(name);</span>
<span class="nc" id="L157">      this.resultTypeName = resultTypeName;</span>
<span class="nc" id="L158">      this.nargs = nargs;</span>
<span class="nc" id="L159">    }</span>

    @Override
    public String getParamDesc() {
<span class="nc" id="L163">      return getParamDesc(Expressions.TYPE_NUMBER, nargs);</span>
    }

    public abstract Number compute(Number...ns);

    @Override
    public boolean checkArgs(List&lt;Value&gt; in) {
<span class="nc bnc" id="L170" title="All 4 branches missed.">      if (nargs &gt; 0 &amp;&amp; in.size() != nargs) {</span>
<span class="nc" id="L171">        return false;</span>
      }
<span class="nc bnc" id="L173" title="All 2 branches missed.">      for (Value v : in) {</span>
<span class="nc bnc" id="L174" title="All 4 branches missed.">        if (v == null || !(v.get() instanceof Number)) {</span>
<span class="nc" id="L175">          return false;</span>
        }
<span class="nc" id="L177">      }</span>
<span class="nc" id="L178">      return true;</span>
    }

    @Override
    public Value apply(Env env, List&lt;Value&gt; in) {
<span class="nc bnc" id="L183" title="All 4 branches missed.">      if (nargs &gt; 0 &amp;&amp; in.size() != nargs) {</span>
<span class="nc" id="L184">        throw new IllegalArgumentException(nargs + &quot; arguments expected, got &quot; + in.size());</span>
      }
<span class="nc" id="L186">      Number[] numbers = new Number[in.size()];</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">      for (int i = 0; i &lt; in.size(); i++) {</span>
<span class="nc" id="L188">        numbers[i] = (Number) in.get(i).get();</span>
      }
<span class="nc" id="L190">      Number res = compute(numbers);</span>
<span class="nc" id="L191">      return new Expressions.PrimitiveValue(resultTypeName, res);</span>
    }
  }

<span class="nc" id="L195">  public static final ValueFunction ADD_FUNCTION = new NumericFunction(&quot;ADD&quot;, 2) {</span>
    @Override
    public Number compute(Number... in) {
<span class="nc bnc" id="L198" title="All 4 branches missed.">      if (isInteger(in[0]) &amp;&amp; isInteger(in[1])) {</span>
<span class="nc" id="L199">        return in[0].longValue() + in[1].longValue();</span>
      } else {
<span class="nc" id="L201">        return in[0].doubleValue() + in[1].doubleValue();</span>
      }
    }
  };

<span class="nc" id="L206">  public static final ValueFunction SUBTRACT_FUNCTION = new NumericFunction(&quot;SUBTRACT&quot;, 2) {</span>
    @Override
    public Number compute(Number... in) {
<span class="nc bnc" id="L209" title="All 4 branches missed.">      if (isInteger(in[0]) &amp;&amp; isInteger(in[1])) {</span>
<span class="nc" id="L210">        return in[0].longValue() - in[1].longValue();</span>
      } else {
<span class="nc" id="L212">        return in[0].doubleValue() - in[1].doubleValue();</span>
      }
    }
  };

<span class="nc" id="L217">  public static final ValueFunction MULTIPLY_FUNCTION = new NumericFunction(&quot;MULTIPLY&quot;, 2) {</span>
    @Override
    public Number compute(Number... in) {
<span class="nc bnc" id="L220" title="All 4 branches missed.">      if (isInteger(in[0]) &amp;&amp; isInteger(in[1])) {</span>
<span class="nc" id="L221">        return in[0].longValue() * in[1].longValue();</span>
      } else {
<span class="nc" id="L223">        return in[0].doubleValue() * in[1].doubleValue();</span>
      }
    }
  };

<span class="nc" id="L228">  public static final ValueFunction DIVIDE_FUNCTION = new NumericFunction(&quot;DIVIDE&quot;, 2) {</span>
    @Override
    public Number compute(Number... in) {
<span class="nc bnc" id="L231" title="All 4 branches missed.">      if (isInteger(in[0]) &amp;&amp; isInteger(in[1])) {</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">        if ( in[0].longValue() % in[1].longValue() == 0)</span>
<span class="nc" id="L233">          return in[0].longValue() / in[1].longValue();</span>
<span class="nc" id="L234">        else return in[0].doubleValue() / in[1].doubleValue();</span>
      } else {
<span class="nc" id="L236">        return in[0].doubleValue() / in[1].doubleValue();</span>
      }
    }
  };

<span class="nc" id="L241">  public static final ValueFunction MOD_FUNCTION = new NumericFunction(&quot;MOD&quot;, 2) {</span>
    @Override
    public Number compute(Number... in) {
<span class="nc bnc" id="L244" title="All 4 branches missed.">      if (isInteger(in[0]) &amp;&amp; isInteger(in[1])) {</span>
<span class="nc" id="L245">        return in[0].longValue() % in[1].longValue();</span>
      } else {
<span class="nc" id="L247">        return in[0].doubleValue() % in[1].doubleValue();</span>
      }
    }
  };

<span class="nc" id="L252">  public static final ValueFunction MAX_FUNCTION = new NumericFunction(&quot;MAX&quot;, 2) {</span>
    @Override
    public Number compute(Number... in) {
<span class="nc bnc" id="L255" title="All 4 branches missed.">      if (isInteger(in[0]) &amp;&amp; isInteger(in[1])) {</span>
<span class="nc" id="L256">        return Math.max(in[0].longValue(), in[1].longValue());</span>
      } else {
<span class="nc" id="L258">        return Math.max(in[0].doubleValue(), in[1].doubleValue());</span>
      }
    }
  };

<span class="nc" id="L263">  public static final ValueFunction MIN_FUNCTION = new NumericFunction(&quot;MIN&quot;, 2) {</span>
    @Override
    public Number compute(Number... in) {
<span class="nc bnc" id="L266" title="All 4 branches missed.">      if (isInteger(in[0]) &amp;&amp; isInteger(in[1])) {</span>
<span class="nc" id="L267">        return Math.min(in[0].longValue(), in[1].longValue());</span>
      } else {
<span class="nc" id="L269">        return Math.min(in[0].doubleValue(), in[1].doubleValue());</span>
      }
    }
  };

<span class="nc" id="L274">  public static final ValueFunction POW_FUNCTION = new NumericFunction(&quot;POW&quot;, 2) {</span>
    @Override
    public Number compute(Number... in) {
<span class="nc" id="L277">      return Math.pow(in[0].doubleValue(), in[1].doubleValue());</span>
    }
  };

<span class="nc" id="L281">  public static final ValueFunction NEGATE_FUNCTION = new NumericFunction(&quot;NEGATE&quot;, 1) {</span>
    @Override
    public Number compute(Number... in) {
<span class="nc bnc" id="L284" title="All 2 branches missed.">      if (isInteger(in[0])) {</span>
<span class="nc" id="L285">        return - in[0].longValue();</span>
      } else {
<span class="nc" id="L287">        return - in[0].doubleValue();</span>
      }
    }
  };

  public abstract static class BooleanFunction extends NamedValueFunction {
<span class="nc" id="L293">    protected String resultTypeName = Expressions.TYPE_BOOLEAN;</span>
<span class="nc" id="L294">    protected int nargs = 2;</span>

    protected BooleanFunction(String name, int nargs) {
<span class="nc" id="L297">      super(name);</span>
<span class="nc" id="L298">      this.nargs = nargs;</span>
<span class="nc" id="L299">    }</span>

    protected BooleanFunction(String name, int nargs, String resultTypeName) {
<span class="nc" id="L302">      super(name);</span>
<span class="nc" id="L303">      this.resultTypeName = resultTypeName;</span>
<span class="nc" id="L304">      this.nargs = nargs;</span>
<span class="nc" id="L305">    }</span>

    public abstract Boolean compute(Boolean...ns);

    @Override
    public String getParamDesc() {
<span class="nc" id="L311">      return getParamDesc(Expressions.TYPE_BOOLEAN, nargs);</span>
    }

    @Override
    public boolean checkArgs(List&lt;Value&gt; in) {
<span class="nc bnc" id="L316" title="All 4 branches missed.">      if (nargs &gt; 0 &amp;&amp; in.size() != nargs) {</span>
<span class="nc" id="L317">        return false;</span>
      }
<span class="nc bnc" id="L319" title="All 2 branches missed.">      for (Value v : in) {</span>
<span class="nc bnc" id="L320" title="All 4 branches missed.">        if (v == null || !(v.get() instanceof Boolean)) {</span>
<span class="nc" id="L321">          return false;</span>
        }
<span class="nc" id="L323">      }</span>
<span class="nc" id="L324">      return true;</span>
    }

    @Override
    public Value apply(Env env, List&lt;Value&gt; in) {
<span class="nc bnc" id="L329" title="All 4 branches missed.">      if (nargs &gt; 0 &amp;&amp; in.size() != nargs) {</span>
<span class="nc" id="L330">        throw new IllegalArgumentException(nargs + &quot; arguments expected, got &quot; + in.size());</span>
      }
<span class="nc" id="L332">      Boolean[] bools = new Boolean[in.size()];</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">      for (int i = 0; i &lt; in.size(); i++) {</span>
<span class="nc" id="L334">        bools[i] = (Boolean) in.get(i).get();</span>
      }
<span class="nc" id="L336">      Boolean res = compute(bools);</span>
<span class="nc" id="L337">      return new Expressions.PrimitiveValue(resultTypeName, res);</span>
    }
  }

<span class="nc" id="L341">  public static final ValueFunction AND_FUNCTION = new BooleanFunction(&quot;AND&quot;, -1) {</span>
    @Override
    public Boolean compute(Boolean... in) {
<span class="nc bnc" id="L344" title="All 2 branches missed.">      for (Boolean b:in) {</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">        if (!b) return false;</span>
      }
<span class="nc" id="L347">      return true;</span>
    }
  };

<span class="nc" id="L351">  public static final ValueFunction OR_FUNCTION = new BooleanFunction(&quot;OR&quot;, -1) {</span>
    @Override
    public Boolean compute(Boolean... in) {
<span class="nc bnc" id="L354" title="All 2 branches missed.">      for (Boolean b:in) {</span>
<span class="nc bnc" id="L355" title="All 2 branches missed.">        if (b) return true;</span>
      }
<span class="nc" id="L357">      return false;</span>
    }
  };

<span class="nc" id="L361">  public static final ValueFunction NOT_FUNCTION = new BooleanFunction(&quot;NOT&quot;, 1) {</span>
    @Override
    public Boolean compute(Boolean... in) {
<span class="nc bnc" id="L364" title="All 2 branches missed.">      Boolean res = !in[0];</span>
<span class="nc" id="L365">      return res;</span>
    }
  };

  private static String join(Object[] args, String glue) {
<span class="nc" id="L370">    String res = null;</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">    if (args.length == 1) {</span>
      // Only one element - check if it is a list or array and do join on that
<span class="nc bnc" id="L373" title="All 2 branches missed.">      if (args[0] instanceof Iterable) {</span>
<span class="nc" id="L374">        res = StringUtils.join((Iterable) args[0], glue);</span>
      } else {
<span class="nc" id="L376">        res = StringUtils.join(args, glue);</span>
      }
    } else {
<span class="nc" id="L379">      res = StringUtils.join(args, glue);</span>
    }
<span class="nc" id="L381">    return res;</span>
  }

  public abstract static class StringFunction extends NamedValueFunction {
<span class="nc" id="L385">    protected String resultTypeName = Expressions.TYPE_STRING;</span>
<span class="nc" id="L386">    protected int nargs = 2;</span>

    protected StringFunction(String name, int nargs) {
<span class="nc" id="L389">      super(name);</span>
<span class="nc" id="L390">      this.nargs = nargs;</span>
<span class="nc" id="L391">    }</span>

    protected StringFunction(String name, int nargs, String resultTypeName) {
<span class="nc" id="L394">      super(name);</span>
<span class="nc" id="L395">      this.resultTypeName = resultTypeName;</span>
<span class="nc" id="L396">      this.nargs = nargs;</span>
<span class="nc" id="L397">    }</span>

    public abstract String compute(String... strs);

    @Override
    public String getParamDesc() {
<span class="nc" id="L403">      return getParamDesc(Expressions.TYPE_STRING, nargs);</span>
    }

    @Override
    public boolean checkArgs(List&lt;Value&gt; in) {
<span class="nc bnc" id="L408" title="All 4 branches missed.">      if (nargs &gt; 0 &amp;&amp; in.size() != nargs) {</span>
<span class="nc" id="L409">        return false;</span>
      }
<span class="nc bnc" id="L411" title="All 2 branches missed.">      for (Value v : in) {</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">        if (v == null /*|| !(v.get() instanceof String) */) {</span>
<span class="nc" id="L413">          return false;</span>
        }
<span class="nc" id="L415">      }</span>
<span class="nc" id="L416">      return true;</span>
    }

    @Override
    public Value apply(Env env, List&lt;Value&gt; in) {
<span class="nc bnc" id="L421" title="All 4 branches missed.">      if (nargs &gt; 0 &amp;&amp; in.size() != nargs) {</span>
<span class="nc" id="L422">        throw new IllegalArgumentException(nargs + &quot; arguments expected, got &quot; + in.size());</span>
      }
<span class="nc" id="L424">      String[] strs = new String[in.size()];</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">      for (int i = 0; i &lt; in.size(); i++) {</span>
<span class="nc bnc" id="L426" title="All 2 branches missed.">        if (in.get(i).get() instanceof String) {</span>
<span class="nc" id="L427">          strs[i] = (String) in.get(i).get();</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">        } else if (in.get(i).get() != null) {</span>
<span class="nc" id="L429">          strs[i] = in.get(i).get().toString();</span>
        } else {
<span class="nc" id="L431">          strs[i] = null;</span>
        }
      }
<span class="nc" id="L434">      String res = compute(strs);</span>
<span class="nc" id="L435">      return new Expressions.PrimitiveValue(resultTypeName, res);</span>
    }
  }

<span class="nc" id="L439">  public static final ValueFunction CONCAT_FUNCTION = new StringFunction(&quot;CONCAT&quot;, -1) {</span>
    @Override
    public String compute(String... in) {
<span class="nc" id="L442">      return join(in, &quot;&quot;);</span>
    }
  };

<span class="nc" id="L446">  public static final ValueFunction UPPERCASE_FUNCTION = new StringFunction(&quot;UPPERCASE&quot;, 1) {</span>
    @Override
    public String compute(String... in) {
<span class="nc" id="L449">      return in[0].toUpperCase();</span>
    }
  };

<span class="nc" id="L453">  public static final ValueFunction LOWERCASE_FUNCTION = new StringFunction(&quot;LOWERCASE&quot;, 1) {</span>
    @Override
    public String compute(String... in) {
<span class="nc" id="L456">      return in[0].toLowerCase();</span>
    }
  };

<span class="nc" id="L460">  public static final ValueFunction PRINT_FUNCTION = new NamedValueFunction(&quot;PRINT&quot;) {</span>
    @Override
    public String getParamDesc() {
<span class="nc" id="L463">      return &quot;...&quot;;</span>
    }

    @Override
    public boolean checkArgs(List&lt;Value&gt; in) {
<span class="nc bnc" id="L468" title="All 2 branches missed.">      if (in.size() &lt; 1) {</span>
<span class="nc" id="L469">        return false;</span>
      }
<span class="nc bnc" id="L471" title="All 6 branches missed.">      if (in.size() &gt; 1 &amp;&amp; (in.get(0) == null || !(in.get(0).get() instanceof String))) {</span>
<span class="nc" id="L472">        return false;</span>
      }
<span class="nc" id="L474">      return true;</span>
    }

    @Override
    public Value apply(Env env, List&lt;Value&gt; in) {
<span class="nc bnc" id="L479" title="All 2 branches missed.">      if (in.size() &gt; 1) {</span>
<span class="nc" id="L480">        String format = (String) in.get(0).get();</span>
<span class="nc" id="L481">        Object[] args = new Object[in.size()-1];</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">        for (int i = 1; i &lt; in.size(); i++) {</span>
<span class="nc" id="L483">          args[i-1] = in.get(i).get();</span>
        }
<span class="nc" id="L485">        String res = String.format(format,  args);</span>
<span class="nc" id="L486">        System.out.print(res);</span>
<span class="nc" id="L487">      } else {</span>
<span class="nc" id="L488">        System.out.print(in.get(0));</span>
      }
<span class="nc" id="L490">      return null;</span>
    }
  };

<span class="nc" id="L494">  public static final ValueFunction FORMAT_FUNCTION = new NamedValueFunction(&quot;FORMAT&quot;) {</span>
    @Override
    public String getParamDesc() {
<span class="nc" id="L497">      return Expressions.TYPE_STRING + &quot;,...&quot;;</span>
    }

    @Override
    public boolean checkArgs(List&lt;Value&gt; in) {
<span class="nc bnc" id="L502" title="All 2 branches missed.">      if (in.size() &lt; 1) {</span>
<span class="nc" id="L503">        return false;</span>
      }
<span class="nc bnc" id="L505" title="All 4 branches missed.">      if (in.get(0) == null || !(in.get(0).get() instanceof String)) {</span>
<span class="nc" id="L506">        return false;</span>
      }
<span class="nc" id="L508">      return true;</span>
    }

    @Override
    public Value apply(Env env, List&lt;Value&gt; in) {
<span class="nc" id="L513">      String format = (String) in.get(0).get();</span>
<span class="nc" id="L514">      Object[] args = new Object[in.size()-1];</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">      for (int i = 1; i &lt; in.size(); i++) {</span>
<span class="nc" id="L516">        args[i-1] = in.get(i).get();</span>
      }
<span class="nc" id="L518">      String res = String.format(format,  args);</span>
<span class="nc" id="L519">      return new Expressions.PrimitiveValue(Expressions.TYPE_STRING, res);</span>
    }
  };

<span class="nc" id="L523">  public static final ValueFunction JOIN_FUNCTION = new NamedValueFunction(&quot;JOIN&quot;) {</span>
    @Override
    public String getParamDesc() {
<span class="nc" id="L526">      return &quot;String glue,...&quot;;</span>
    }

    @Override
    public boolean checkArgs(List&lt;Value&gt; in) {
<span class="nc bnc" id="L531" title="All 2 branches missed.">      if (in.size() &lt; 1) {</span>
<span class="nc" id="L532">        return false;</span>
      }
<span class="nc bnc" id="L534" title="All 4 branches missed.">      if (in.get(0) == null || !(in.get(0).get() instanceof String)) {</span>
<span class="nc" id="L535">        return false;</span>
      }
<span class="nc" id="L537">      return true;</span>
    }

    @Override
    public Value apply(Env env, List&lt;Value&gt; in) {
<span class="nc" id="L542">      String glue = (String) in.get(0).get();</span>
<span class="nc" id="L543">      Object[] args = new Object[in.size()-1];</span>
<span class="nc bnc" id="L544" title="All 2 branches missed.">      for (int i = 1; i &lt; in.size(); i++) {</span>
<span class="nc" id="L545">        args[i-1] = in.get(i).get();</span>
      }
<span class="nc" id="L547">      String res = join(args, glue);</span>
<span class="nc" id="L548">      return new Expressions.PrimitiveValue(Expressions.TYPE_STRING, res);</span>
    }
  };

<span class="nc" id="L552">  public static final ValueFunction CREATE_REGEX_FUNCTION = new NamedValueFunction(&quot;CREATE_REGEX&quot;) {</span>
    @Override
    public boolean checkArgs(List&lt;Value&gt; in) {
<span class="nc bnc" id="L555" title="All 2 branches missed.">      if (in.size() &lt; 1) {</span>
<span class="nc" id="L556">        return false;</span>
      }
<span class="nc bnc" id="L558" title="All 4 branches missed.">      if (in.get(0) == null || !(in.get(0).get() instanceof List)) {</span>
<span class="nc" id="L559">        return false;</span>
      }
<span class="nc" id="L561">      return true;</span>
    }

    @Override
    public Value apply(Env env, List&lt;Value&gt; in) {
<span class="nc" id="L566">      List list = (List) in.get(0).get();</span>
<span class="nc" id="L567">      String[] args = new String[list.size()];</span>
<span class="nc bnc" id="L568" title="All 2 branches missed.">      for (int i = 0; i &lt; list.size(); i++) {</span>
<span class="nc" id="L569">        args[i] = list.get(i).toString();</span>
      }
<span class="nc" id="L571">      MultiWordStringMatcher matcher = new MultiWordStringMatcher(&quot;EXCTWS&quot;);</span>
<span class="nc" id="L572">      String regex = matcher.getRegex(args);</span>
<span class="nc" id="L573">      return new Expressions.PrimitiveValue(Expressions.TYPE_REGEX, regex);</span>
    }
  };

<span class="nc" id="L577">  private static final ParamInfo PARAM_INFO_VALUE_FUNCTION = new ParamInfo(&quot;FUNCTION&quot;, Expressions.TYPE_FUNCTION, ValueFunction.class, false);</span>
<span class="nc" id="L578">  private static final ParamInfo PARAM_INFO_LIST = new ParamInfo(&quot;LIST&quot;, null, List.class, true);</span>
<span class="nc" id="L579">  public static final ValueFunction MAP_VALUES_FUNCTION =</span>
<span class="nc" id="L580">          new TypeCheckedFunction(&quot;MAP_VALUES&quot;, PARAM_INFO_LIST, PARAM_INFO_VALUE_FUNCTION) {</span>
            // First argument is list of elements to apply function to
            // Second argument is function to apply
            @Override
            public Value apply(Env env, List&lt;Value&gt; in) {
<span class="nc bnc" id="L585" title="All 2 branches missed.">              if (in.get(0) == null) return null;</span>
<span class="nc" id="L586">              List list = (List) in.get(0).get();</span>
<span class="nc" id="L587">              ValueFunction func = (ValueFunction) in.get(1).get();</span>
<span class="nc" id="L588">              List&lt;Value&gt; res = new ArrayList&lt;&gt;(list.size());</span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">              for (Object elem:list) {</span>
<span class="nc" id="L590">                List&lt;Value&gt; args = new ArrayList&lt;&gt;(1);</span>
<span class="nc" id="L591">                args.add(Expressions.createValue(Expressions.TYPE_LIST, elem));</span>
<span class="nc" id="L592">                res.add(func.apply(env, args));</span>
<span class="nc" id="L593">              }</span>
<span class="nc" id="L594">              return new Expressions.PrimitiveValue&lt;&gt;(Expressions.TYPE_LIST, res);</span>
            }
          };
<span class="nc" id="L597">  private static final ParamInfo PARAM_INFO_FUNCTION = new ParamInfo(&quot;FUNCTION&quot;, Expressions.TYPE_FUNCTION, Function.class, false);</span>
<span class="nc" id="L598">  public static final ValueFunction MAP_FUNCTION =</span>
<span class="nc" id="L599">          new TypeCheckedFunction(&quot;MAP&quot;, PARAM_INFO_LIST, PARAM_INFO_FUNCTION) {</span>
            // First argument is list of elements to apply function to
            // Second argument is function to apply
            @Override
            public Value apply(Env env, List&lt;Value&gt; in) {
<span class="nc bnc" id="L604" title="All 2 branches missed.">              if (in.get(0) == null) return null;</span>
<span class="nc" id="L605">              List list = (List) in.get(0).get();</span>
<span class="nc" id="L606">              Function func = (Function) in.get(1).get();</span>
<span class="nc" id="L607">              List&lt;Object&gt; res = new ArrayList&lt;&gt;(list.size());</span>
<span class="nc bnc" id="L608" title="All 2 branches missed.">              for (Object elem:list) {</span>
<span class="nc" id="L609">                res.add(func.apply(elem));</span>
<span class="nc" id="L610">              }</span>
<span class="nc" id="L611">              return new Expressions.PrimitiveValue&lt;&gt;(null, res);</span>
            }
          };


<span class="nc" id="L616">  private static final ParamInfo PARAM_INFO_TOKEN_REGEX = new ParamInfo(&quot;TOKEN_REGEX&quot;, Expressions.TYPE_TOKEN_REGEX, TokenSequencePattern.class, false);</span>
<span class="nc" id="L617">  private static final ParamInfo PARAM_INFO_TOKEN_LIST = new ParamInfo(&quot;TOKEN_LIST&quot;, null, List.class, true);</span>
<span class="nc" id="L618">  private static final ParamInfo PARAM_INFO_TOKEN_LIST_REPLACE = new ParamInfo(&quot;TOKEN_LIST_REPLACEMENT&quot;, null, List.class, true);</span>

<span class="nc" id="L620">  public static final ValueFunction TOKENS_MATCH_FUNCTION =</span>
<span class="nc" id="L621">          new TypeCheckedFunction(&quot;TOKENS_MATCH&quot;, PARAM_INFO_TOKEN_LIST, PARAM_INFO_TOKEN_REGEX) {</span>
            // First argument is list of tokens to match
            // Second argument is pattern to match
            @Override
            public Value apply(Env env, List&lt;Value&gt; in) {
<span class="nc bnc" id="L626" title="All 4 branches missed.">              if (in.get(0) == null || in.get(0).get() == null) return Expressions.FALSE;</span>
<span class="nc" id="L627">              List&lt;CoreMap&gt; cms = (List&lt;CoreMap&gt;) in.get(0).get();</span>
<span class="nc" id="L628">              TokenSequencePattern pattern = (TokenSequencePattern) in.get(1).get();</span>
<span class="nc" id="L629">              TokenSequenceMatcher matcher = pattern.getMatcher(cms);</span>
<span class="nc" id="L630">              boolean matches = matcher.matches();</span>
<span class="nc bnc" id="L631" title="All 2 branches missed.">              return (matches)? Expressions.TRUE: Expressions.FALSE;</span>
            }
          };

<span class="nc" id="L635">  public static final ValueFunction TOKENS_REPLACE_FUNCTION =</span>
          new TypeCheckedFunction(&quot;TOKENS_REPLACE&quot;,
<span class="nc" id="L637">              PARAM_INFO_TOKEN_LIST, PARAM_INFO_TOKEN_REGEX, PARAM_INFO_TOKEN_LIST_REPLACE) {</span>
            // First argument is list of tokens to match
            // Second argument is pattern to match
            // Third argument is replacement tokens
            @Override
            public Value apply(Env env, List&lt;Value&gt; in) {
<span class="nc bnc" id="L643" title="All 4 branches missed.">              if (in.get(0) == null || in.get(0).get() == null) return Expressions.FALSE;</span>
<span class="nc" id="L644">              List&lt;CoreMap&gt; cms = (List&lt;CoreMap&gt;) in.get(0).get();</span>
<span class="nc" id="L645">              List&lt;CoreMap&gt; replacement = (List&lt;CoreMap&gt;) in.get(2).get();</span>
<span class="nc" id="L646">              TokenSequencePattern pattern = (TokenSequencePattern) in.get(1).get();</span>
<span class="nc" id="L647">              TokenSequenceMatcher matcher = pattern.getMatcher(cms);</span>
<span class="nc" id="L648">              List&lt;CoreMap&gt; replaced = matcher.replaceAll(replacement);</span>
<span class="nc" id="L649">              return new Expressions.PrimitiveValue(Expressions.TYPE_TOKENS, replaced);</span>
            }
          };

<span class="nc" id="L653">  private static final ParamInfo PARAM_INFO_STRING_REGEX = new ParamInfo(&quot;REGEX&quot;, Expressions.TYPE_REGEX, null, false);</span>
<span class="nc" id="L654">  private static final ParamInfo PARAM_INFO_STRING = new ParamInfo(&quot;STRING&quot;, null, String.class, true);</span>
<span class="nc" id="L655">  private static final ParamInfo PARAM_INFO_STRING_REPLACE = new ParamInfo(&quot;STRING_REPLACEMENT&quot;, null, String.class, true);</span>

<span class="nc" id="L657">  public static final ValueFunction STRING_MATCH_FUNCTION =</span>
<span class="nc" id="L658">          new TypeCheckedFunction(&quot;STRING_MATCH&quot;, PARAM_INFO_STRING, PARAM_INFO_STRING_REGEX) {</span>
            // First argument is string to match
            // Second argument is pattern to match
            @Override
            public Value apply(Env env, List&lt;Value&gt; in) {
<span class="nc bnc" id="L663" title="All 4 branches missed.">              if (in.get(0) == null || in.get(0).get() == null) return Expressions.FALSE;</span>
<span class="nc" id="L664">              String str = (String) in.get(0).get();</span>
<span class="nc" id="L665">              String regex = (String) in.get(1).get();</span>
<span class="nc" id="L666">              Pattern pattern = env.getStringPattern(regex);</span>
<span class="nc" id="L667">              Matcher matcher = pattern.matcher(str);</span>
<span class="nc" id="L668">              boolean matches = matcher.matches();</span>
<span class="nc bnc" id="L669" title="All 2 branches missed.">              return (matches)? Expressions.TRUE: Expressions.FALSE;</span>
            }
          };

<span class="nc" id="L673">  public static final ValueFunction STRING_REPLACE_FUNCTION =</span>
          new TypeCheckedFunction(&quot;STRING_REPLACE&quot;,
<span class="nc" id="L675">              PARAM_INFO_STRING, PARAM_INFO_STRING_REGEX, PARAM_INFO_STRING_REPLACE) {</span>
            // First argument is string to match
            // Second argument is pattern to match
            // Third argument is replacement string
            @Override
            public Value apply(Env env, List&lt;Value&gt; in) {
<span class="nc bnc" id="L681" title="All 4 branches missed.">              if (in.get(0) == null || in.get(0).get() == null) return Expressions.FALSE;</span>
<span class="nc" id="L682">              String str = (String) in.get(0).get();</span>
<span class="nc" id="L683">              String replacement = (String) in.get(2).get();</span>
<span class="nc" id="L684">              String regex = (String) in.get(1).get();</span>
<span class="nc" id="L685">              Pattern pattern = env.getStringPattern(regex);</span>
<span class="nc" id="L686">              Matcher matcher = pattern.matcher(str);</span>
<span class="nc" id="L687">              String replaced = matcher.replaceAll(replacement);</span>
<span class="nc" id="L688">              return new Expressions.PrimitiveValue(Expressions.TYPE_STRING, replaced);</span>
            }
          };

<span class="nc" id="L692">  private static final CoreLabelTokenFactory CORELABEL_FACTORY = new CoreLabelTokenFactory();</span>
<span class="nc" id="L693">  private static final ParamInfo PARAM_INFO_TOKEN = new ParamInfo(&quot;TOKEN&quot;, null, CoreMap.class, false);</span>
<span class="nc" id="L694">  public static final ValueFunction TOKEN_STRING_SPLIT_FUNCTION =</span>
          new TypeCheckedFunction(&quot;TOKEN_STRING_SPLIT&quot;,
              PARAM_INFO_TOKEN, PARAM_INFO_STRING_REGEX,
<span class="nc" id="L697">              new ParamInfo(&quot;INCLUDE_MATCHED&quot;, null, Boolean.class, false)) {</span>
            // First argument is token to split
            // Second argument is pattern to split on
            @Override
            public Value apply(Env env, List&lt;Value&gt; in) {
<span class="nc" id="L702">              CoreMap cm = (CoreMap) in.get(0).get();</span>
<span class="nc" id="L703">              String regex = (String) in.get(1).get();</span>
<span class="nc" id="L704">              Boolean includeMatchedAsTokens = (Boolean) in.get(2).get();</span>
<span class="nc" id="L705">              Pattern pattern = env.getStringPattern(regex);</span>
<span class="nc" id="L706">              List&lt;CoreLabel&gt; res =</span>
<span class="nc" id="L707">                      ChunkAnnotationUtils.splitCoreMap(pattern, includeMatchedAsTokens, cm, CORELABEL_FACTORY);</span>
<span class="nc" id="L708">              return new Expressions.PrimitiveValue(Expressions.TYPE_TOKENS, res);</span>
            }
          };

  public static boolean isInteger(Number n) {
<span class="nc bnc" id="L713" title="All 6 branches missed.">    return (n instanceof Long || n instanceof Integer || n instanceof Short);</span>
  }
<span class="nc" id="L715">  public static final NumericComparator NUMBER_COMPARATOR = new NumericComparator();</span>

<span class="nc" id="L717">  public static class NumericComparator implements Comparator&lt;Number&gt; {</span>
    @Override
    public int compare(Number o1, Number o2) {
<span class="nc bnc" id="L720" title="All 4 branches missed.">      if (isInteger(o1) &amp;&amp; isInteger(o2)) {</span>
<span class="nc" id="L721">        return Long.compare(o1.longValue(), o2.longValue());</span>
      } else {
<span class="nc" id="L723">        return Double.compare(o1.doubleValue(),o2.doubleValue());</span>
      }
    }
  }

<span class="nc" id="L728">  public static class ComparableComparator&lt;T extends Comparable&lt;T&gt;&gt; implements Comparator&lt;T&gt; {</span>
    @Override
    public int compare(T o1, T o2) {
<span class="nc" id="L731">      return o1.compareTo(o2);</span>
    }
  }

<span class="nc" id="L735">  public enum CompareType { GT, LT, GE, LE, EQ, NE }</span>

  public static class CompareFunction&lt;T&gt; extends NamedValueFunction {
    Comparator&lt;T&gt; comparator;
    CompareType compType;
    Class clazz;

    public CompareFunction(String name, Comparator&lt;T&gt; comparator, CompareType compType, Class clazz) {
<span class="nc" id="L743">      super(name);</span>
<span class="nc" id="L744">      this.comparator = comparator;</span>
<span class="nc" id="L745">      this.compType = compType;</span>
<span class="nc" id="L746">      this.clazz = clazz;</span>
<span class="nc" id="L747">    }</span>

    @Override
    public String getParamDesc() {
<span class="nc" id="L751">      return &quot;(&quot; + getTypeName(clazz) + &quot;,&quot; + getTypeName(clazz) + &quot;)&quot;;</span>
    }

    public Boolean compare(T o1, T o2) {
<span class="nc" id="L755">      int res = comparator.compare(o1,o2);</span>
<span class="nc bnc" id="L756" title="All 7 branches missed.">      switch (compType) {</span>
<span class="nc bnc" id="L757" title="All 2 branches missed.">        case GT: return res &gt; 0;</span>
<span class="nc bnc" id="L758" title="All 2 branches missed.">        case LT: return res &lt; 0;</span>
<span class="nc bnc" id="L759" title="All 2 branches missed.">        case GE: return res &gt;= 0;</span>
<span class="nc bnc" id="L760" title="All 2 branches missed.">        case LE: return res &lt;= 0;</span>
<span class="nc bnc" id="L761" title="All 2 branches missed.">        case EQ: return res == 0;</span>
<span class="nc bnc" id="L762" title="All 2 branches missed.">        case NE: return res != 0;</span>
<span class="nc" id="L763">        default: throw new UnsupportedOperationException(&quot;Unknown compType: &quot; + compType);</span>
      }
    }

    @Override
    public boolean checkArgs(List&lt;Value&gt; in) {
<span class="nc bnc" id="L769" title="All 2 branches missed.">      if (in.size() != 2) {</span>
<span class="nc" id="L770">        return false;</span>
      }
<span class="nc bnc" id="L772" title="All 2 branches missed.">      if (clazz != null) {</span>
<span class="nc bnc" id="L773" title="All 6 branches missed.">        if (in.get(0) == null || in.get(0).get() == null || !(clazz.isAssignableFrom(in.get(0).get().getClass()))) {</span>
<span class="nc" id="L774">          return false;</span>
        }
<span class="nc bnc" id="L776" title="All 6 branches missed.">        if (in.get(1) == null || in.get(1).get() == null || !(clazz.isAssignableFrom(in.get(1).get().getClass()))) {</span>
<span class="nc" id="L777">          return false;</span>
        }
      }
<span class="nc" id="L780">      return true;</span>
    }

    @Override
    public Value apply(Env env, List&lt;Value&gt; in) {
<span class="nc bnc" id="L785" title="All 2 branches missed.">      if (in.size() != 2) {</span>
<span class="nc" id="L786">        throw new IllegalArgumentException(&quot;2 arguments expected, got &quot; + in.size());</span>
      }
<span class="nc bnc" id="L788" title="All 8 branches missed.">      if (in.get(0) == null || in.get(1) == null || in.get(0).get() == null || in.get(1).get() == null) {</span>
<span class="nc" id="L789">        return null; // Can't compare...</span>
      }
<span class="nc" id="L791">      Boolean res = compare((T) in.get(0).get(), (T) in.get(1).get());</span>
<span class="nc bnc" id="L792" title="All 2 branches missed.">      return (res)? Expressions.TRUE: Expressions.FALSE;</span>
    }
  }

<span class="nc" id="L796">  public static final ValueFunction NOT_EQUALS_FUNCTION = new NamedValueFunction(&quot;EQUALS&quot;) {</span>
    @Override
    public String getParamDesc() {
<span class="nc" id="L799">      return &quot;Object,Object&quot;;</span>
    }

    @Override
    public boolean checkArgs(List&lt;Value&gt; in) {
<span class="nc bnc" id="L804" title="All 2 branches missed.">      return in.size() == 2;</span>
    }

    @Override
    public Value apply(Env env, List&lt;Value&gt; in) {
<span class="nc bnc" id="L809" title="All 2 branches missed.">      if (in.size() != 2) {</span>
<span class="nc" id="L810">        throw new IllegalArgumentException(&quot;2 arguments expected, got &quot; + in.size());</span>
      }
<span class="nc" id="L812">      boolean res = false;</span>
<span class="nc bnc" id="L813" title="All 4 branches missed.">      if (in.get(0) == null || in.get(1) == null) {</span>
<span class="nc bnc" id="L814" title="All 2 branches missed.">        res = (in.get(0) == in.get(1));</span>
<span class="nc bnc" id="L815" title="All 4 branches missed.">      } else if (in.get(0).get() == null || in.get(1).get() == null) {</span>
<span class="nc bnc" id="L816" title="All 2 branches missed.">        res = (in.get(0).get() == in.get(1).get());</span>
      } else {
<span class="nc" id="L818">        res = in.get(0).get().equals(in.get(1).get());</span>
      }
<span class="nc bnc" id="L820" title="All 2 branches missed.">      return (res)? Expressions.FALSE: Expressions.TRUE;</span>
    }
  };


<span class="nc" id="L825">  public static final ValueFunction EQUALS_FUNCTION = new NamedValueFunction(&quot;EQUALS&quot;) {</span>
    @Override
    public String getParamDesc() {
<span class="nc" id="L828">      return &quot;Object,Object&quot;;</span>
    }

    @Override
    public boolean checkArgs(List&lt;Value&gt; in) {
<span class="nc bnc" id="L833" title="All 2 branches missed.">      return in.size() == 2;</span>
    }

    @Override
    public Value apply(Env env, List&lt;Value&gt; in) {
<span class="nc bnc" id="L838" title="All 2 branches missed.">      if (in.size() != 2) {</span>
<span class="nc" id="L839">        throw new IllegalArgumentException(&quot;2 arguments expected, got &quot; + in.size());</span>
      }
<span class="nc" id="L841">      boolean res = false;</span>
<span class="nc bnc" id="L842" title="All 4 branches missed.">      if (in.get(0) == null || in.get(1) == null) {</span>
<span class="nc bnc" id="L843" title="All 2 branches missed.">        res = (in.get(0) == in.get(1));</span>
<span class="nc bnc" id="L844" title="All 4 branches missed.">      } else if (in.get(0).get() == null || in.get(1).get() == null) {</span>
<span class="nc bnc" id="L845" title="All 2 branches missed.">        res = (in.get(0).get() == in.get(1).get());</span>
      } else {
<span class="nc" id="L847">        res = in.get(0).get().equals(in.get(1).get());</span>
      }
<span class="nc bnc" id="L849" title="All 2 branches missed.">      return (res)? Expressions.TRUE: Expressions.FALSE;</span>
    }
  };

<span class="nc" id="L853">  public static final ValueFunction ANNOTATION_FUNCTION = new NamedValueFunction(&quot;ANNOTATION_VALUE&quot;) {</span>
    @Override
    public String getParamDesc() {
<span class="nc" id="L856">      return &quot;CoreMap coremap,String fieldName|Class field,[Object value]&quot;;</span>
    }

    // First argument is what (CoreMap) to get annotation for
    // Second argument is field (Class or String) to get annotation for
    // Third argument (optional) is annotation value to set
    @Override
    public boolean checkArgs(List&lt;Value&gt; in) {
<span class="nc bnc" id="L864" title="All 4 branches missed.">      if (in.size() != 2 &amp;&amp; in.size() != 3) {</span>
<span class="nc" id="L865">        return false;</span>
      }
<span class="nc bnc" id="L867" title="All 2 branches missed.">      if (in.get(0) == null ||</span>
<span class="nc bnc" id="L868" title="All 4 branches missed.">              (!(in.get(0).get() instanceof CoreMap) &amp;&amp; !(in.get(0).get() instanceof List))) {</span>
<span class="nc" id="L869">        return false;</span>
      }
<span class="nc bnc" id="L871" title="All 2 branches missed.">      if (in.get(1) == null ||</span>
<span class="nc bnc" id="L872" title="All 4 branches missed.">              (!(in.get(1).get() instanceof Class) &amp;&amp; !(in.get(1).get() instanceof String))) {</span>
<span class="nc" id="L873">        return false;</span>
      }
<span class="nc" id="L875">      return true;</span>
    }
    @Override
    public Value apply(Env env, List&lt;Value&gt; in) {
<span class="nc" id="L879">      Value cmv = in.get(0);</span>
<span class="nc" id="L880">      Object field = in.get(1).get();</span>
<span class="nc" id="L881">      Class annotationFieldClass = null;</span>
<span class="nc bnc" id="L882" title="All 2 branches missed.">      if (field instanceof String)  {</span>
<span class="nc" id="L883">        annotationFieldClass = EnvLookup.lookupAnnotationKey(env, (String) field);</span>
<span class="nc bnc" id="L884" title="All 2 branches missed.">        if (annotationFieldClass == null) {</span>
<span class="nc" id="L885">          throw new IllegalArgumentException(&quot;Cannot get annotation field &quot; + field);</span>
        }
<span class="nc bnc" id="L887" title="All 2 branches missed.">      } else if (field instanceof Class) {</span>
<span class="nc" id="L888">        annotationFieldClass = (Class)  field;</span>
      } else {
<span class="nc" id="L890">        throw new IllegalArgumentException(&quot;Type mismatch on arg1: Cannot apply &quot; + this + &quot; to &quot; + in);</span>
      }
<span class="nc bnc" id="L892" title="All 2 branches missed.">      if (cmv.get() instanceof CoreMap) {</span>
<span class="nc" id="L893">        CoreMap cm = (CoreMap) cmv.get();</span>
<span class="nc bnc" id="L894" title="All 2 branches missed.">        if (in.size() &gt;= 3) {</span>
<span class="nc" id="L895">          Value v = in.get(2);</span>
<span class="nc bnc" id="L896" title="All 2 branches missed.">          Object annotationObject = (v != null)? v.get():null;</span>
<span class="nc" id="L897">          cm.set(annotationFieldClass, annotationObject);</span>
        }
<span class="nc" id="L899">        Object obj = cm.get(annotationFieldClass);</span>
<span class="nc" id="L900">        return Expressions.createValue(annotationFieldClass.getName(), obj);</span>
<span class="nc bnc" id="L901" title="All 2 branches missed.">      } else if (cmv.get() instanceof List) {</span>
<span class="nc" id="L902">        List&lt;CoreMap&gt; cmList = (List&lt;CoreMap&gt;) cmv.get();</span>
<span class="nc bnc" id="L903" title="All 2 branches missed.">        if (in.size() &gt;= 3) {</span>
<span class="nc" id="L904">          Value v = in.get(2);</span>
<span class="nc bnc" id="L905" title="All 2 branches missed.">          Object annotationObject = (v != null)? v.get():null;</span>
<span class="nc bnc" id="L906" title="All 2 branches missed.">          for (CoreMap cm:cmList) {</span>
<span class="nc" id="L907">            cm.set(annotationFieldClass, annotationObject);</span>
<span class="nc" id="L908">          }</span>
        }
<span class="nc" id="L910">        List&lt;Object&gt; list = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L911">        Value res = new Expressions.PrimitiveValue(Expressions.TYPE_LIST, list);</span>
<span class="nc bnc" id="L912" title="All 2 branches missed.">        for (CoreMap cm:cmList) {</span>
<span class="nc" id="L913">          list.add(cm.get(annotationFieldClass));</span>
<span class="nc" id="L914">        }</span>
<span class="nc" id="L915">        return res;</span>
      } else {
<span class="nc" id="L917">        throw new IllegalArgumentException(&quot;Type mismatch on arg0: Cannot apply &quot; + this + &quot; to &quot; + in);</span>
      }
    }
  };

<span class="nc" id="L922">  public static final ValueFunction GET_ANNOTATION_TAG_FUNCTION = new NamedValueFunction(&quot;GET_ANNOTATION_TAG&quot;) {</span>
    @Override
    public String getParamDesc() {
<span class="nc" id="L925">      return &quot;CoreMap or List&lt;CoreMap&gt;,String tag&quot;;</span>
    }

    // First argument is what (CoreMap or List&lt;CoreMap&gt;) to tag
    // Second argument is tag
    @Override
    public boolean checkArgs(List&lt;Value&gt; in) {
<span class="nc bnc" id="L932" title="All 2 branches missed.">      if (in.size() != 2) {</span>
<span class="nc" id="L933">        return false;</span>
      }
<span class="nc bnc" id="L935" title="All 4 branches missed.">      if (in.get(0) == null || in.get(0).get() == null) return true; // Allow for NULL</span>
<span class="nc bnc" id="L936" title="All 2 branches missed.">      if (in.get(0) == null ||</span>
<span class="nc bnc" id="L937" title="All 4 branches missed.">              (!(in.get(0).get() instanceof CoreMap) &amp;&amp; !(in.get(0).get() instanceof List))) {</span>
<span class="nc" id="L938">        return false;</span>
      }
<span class="nc bnc" id="L940" title="All 4 branches missed.">      if (in.get(1) == null || !(in.get(1).get() instanceof String)) {</span>
<span class="nc" id="L941">        return false;</span>
      }
<span class="nc" id="L943">      return true;</span>
    }

    public Value getTag(CoreMap cm, String tag)
    {
<span class="nc" id="L948">      Tags tags = cm.get(Tags.TagsAnnotation.class);</span>
<span class="nc bnc" id="L949" title="All 2 branches missed.">      return (tags != null)? tags.getTag(tag): null;</span>
    }

    @Override
    public Value apply(Env env, List&lt;Value&gt; in) {
<span class="nc bnc" id="L954" title="All 4 branches missed.">      if (in.get(0) == null || in.get(0).get() == null) return null;</span>
<span class="nc" id="L955">      Value v = in.get(0);</span>
<span class="nc" id="L956">      Value res = null;</span>
<span class="nc" id="L957">      String tag = (String) in.get(1).get();</span>
<span class="nc bnc" id="L958" title="All 2 branches missed.">      if (v.get() instanceof CoreMap) {</span>
<span class="nc" id="L959">        res = getTag((CoreMap) v.get(), tag);</span>
<span class="nc bnc" id="L960" title="All 2 branches missed.">      } else if (v.get() instanceof List) {</span>
<span class="nc" id="L961">        List&lt;CoreMap&gt; cmList = (List&lt;CoreMap&gt;) v.get();</span>
<span class="nc" id="L962">        List&lt;Value&gt; list = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L963">        res = new Expressions.PrimitiveValue(Expressions.TYPE_LIST, list);</span>
<span class="nc bnc" id="L964" title="All 2 branches missed.">        for (CoreMap cm:cmList) {</span>
<span class="nc" id="L965">          list.add(getTag(cm, tag));</span>
<span class="nc" id="L966">        }</span>
<span class="nc" id="L967">      } else {</span>
<span class="nc" id="L968">        throw new IllegalArgumentException(&quot;Type mismatch on arg0: Cannot apply &quot; + this + &quot; to &quot; + in);</span>
      }
<span class="nc" id="L970">      return res;</span>
    }
  };

<span class="nc" id="L974">  public static final ValueFunction SET_ANNOTATION_TAG_FUNCTION = new NamedValueFunction(&quot;SET_ANNOTATION_TAG&quot;) {</span>
    @Override
    public String getParamDesc() {
<span class="nc" id="L977">      return &quot;CoreMap or List&lt;CoreMap&gt;,String tag,[Object value]&quot;;</span>
    }

    // First argument is what (CoreMap or List&lt;CoreMap&gt;) to tag
    // Second argument is tag
    // Third argument is tag value
    @Override
    public boolean checkArgs(List&lt;Value&gt; in) {
<span class="nc bnc" id="L985" title="All 4 branches missed.">      if (in.size() != 2 &amp;&amp; in.size() != 3) {</span>
<span class="nc" id="L986">        return false;</span>
      }
<span class="nc bnc" id="L988" title="All 2 branches missed.">      if (in.get(0) == null ||</span>
<span class="nc bnc" id="L989" title="All 4 branches missed.">              (!(in.get(0).get() instanceof CoreMap) &amp;&amp; !(in.get(0).get() instanceof List))) {</span>
<span class="nc" id="L990">        return false;</span>
      }
<span class="nc bnc" id="L992" title="All 4 branches missed.">      if (in.get(1) == null || !(in.get(1).get() instanceof String)) {</span>
<span class="nc" id="L993">        return false;</span>
      }
<span class="nc" id="L995">      return true;</span>
    }

    public void setTag(CoreMap cm, String tag, Value tagValue)
    {
<span class="nc" id="L1000">      Tags tags = cm.get(Tags.TagsAnnotation.class);</span>
<span class="nc bnc" id="L1001" title="All 2 branches missed.">      if (tags == null) {</span>
<span class="nc" id="L1002">        cm.set(Tags.TagsAnnotation.class, tags = new Tags());</span>
      }
<span class="nc" id="L1004">      tags.setTag(tag, tagValue);</span>
<span class="nc" id="L1005">    }</span>

    @Override
    public Value apply(Env env, List&lt;Value&gt; in) {
<span class="nc" id="L1009">      Value v = in.get(0);</span>
<span class="nc" id="L1010">      String tag = (String) in.get(1).get();</span>
<span class="nc bnc" id="L1011" title="All 2 branches missed.">      Value tagValue = (in.size() &gt;= 3)? in.get(2):null;</span>
<span class="nc bnc" id="L1012" title="All 2 branches missed.">      if (v.get() instanceof CoreMap) {</span>
<span class="nc" id="L1013">        setTag((CoreMap) v.get(), tag, tagValue);</span>
<span class="nc bnc" id="L1014" title="All 2 branches missed.">      } else if (v.get() instanceof List) {</span>
<span class="nc" id="L1015">        List&lt;CoreMap&gt; cmList = (List&lt;CoreMap&gt;) v.get();</span>
<span class="nc bnc" id="L1016" title="All 2 branches missed.">        for (CoreMap cm:cmList) {</span>
<span class="nc" id="L1017">          setTag(cm, tag, tagValue);</span>
<span class="nc" id="L1018">        }</span>
<span class="nc" id="L1019">      } else {</span>
<span class="nc" id="L1020">        throw new IllegalArgumentException(&quot;Type mismatch on arg0: Cannot apply &quot; + this + &quot; to &quot; + in);</span>
      }
<span class="nc" id="L1022">      return v;</span>
    }
  };

<span class="nc" id="L1026">  public static final ValueFunction REMOVE_ANNOTATION_TAG_FUNCTION = new NamedValueFunction(&quot;REMOVE_ANNOTATION_TAG&quot;) {</span>
    @Override
    public String getParamDesc() {
<span class="nc" id="L1029">      return &quot;CoreMap or List&lt;CoreMap&gt;,String tag&quot;;</span>
    }

    // First argument is what (CoreMap) to tag
    // Second argument is tag
    @Override
    public boolean checkArgs(List&lt;Value&gt; in) {
<span class="nc bnc" id="L1036" title="All 2 branches missed.">      if (in.size() != 2) {</span>
<span class="nc" id="L1037">        return false;</span>
      }
<span class="nc bnc" id="L1039" title="All 2 branches missed.">      if (in.get(0) == null ||</span>
<span class="nc bnc" id="L1040" title="All 4 branches missed.">              (!(in.get(0).get() instanceof CoreMap) &amp;&amp; !(in.get(0).get() instanceof List))) {</span>
<span class="nc" id="L1041">        return false;</span>
      }
<span class="nc bnc" id="L1043" title="All 4 branches missed.">      if (in.get(1) == null || !(in.get(1).get() instanceof String)) {</span>
<span class="nc" id="L1044">        return false;</span>
      }
<span class="nc" id="L1046">      return true;</span>
    }
    public void removeTag(CoreMap cm, String tag)
    {
<span class="nc" id="L1050">      Tags tags = cm.get(Tags.TagsAnnotation.class);</span>
<span class="nc bnc" id="L1051" title="All 2 branches missed.">      if (tags != null) {</span>
<span class="nc" id="L1052">        tags.removeTag(tag);</span>
      }
<span class="nc" id="L1054">    }</span>

    @Override
    public Value apply(Env env, List&lt;Value&gt; in) {
<span class="nc" id="L1058">      Value v = in.get(0);</span>
<span class="nc" id="L1059">      String tag = (String) in.get(1).get();</span>
<span class="nc bnc" id="L1060" title="All 2 branches missed.">      if (v.get() instanceof CoreMap) {</span>
<span class="nc" id="L1061">        removeTag((CoreMap) v.get(), tag);</span>
<span class="nc bnc" id="L1062" title="All 2 branches missed.">      } else if (v.get() instanceof List) {</span>
<span class="nc" id="L1063">        List&lt;CoreMap&gt; cmList = (List&lt;CoreMap&gt;) v.get();</span>
<span class="nc bnc" id="L1064" title="All 2 branches missed.">        for (CoreMap cm:cmList) {</span>
<span class="nc" id="L1065">          removeTag(cm, tag);</span>
<span class="nc" id="L1066">        }</span>
<span class="nc" id="L1067">      } else {</span>
<span class="nc" id="L1068">        throw new IllegalArgumentException(&quot;Type mismatch on arg0: Cannot apply &quot; + this + &quot; to &quot; + in);</span>
      }
<span class="nc" id="L1070">      return v;</span>
    }
  };

<span class="nc" id="L1074">  public static final ValueFunction TAGS_VALUE_FUNCTION = new NamedValueFunction(&quot;TAGS_VALUE&quot;) {</span>
    @Override
    public String getParamDesc() {
<span class="nc" id="L1077">      return getTypeName(Tags.class) + &quot; tags,String field,[Object value]&quot;;</span>
    }

    // First argument is tags object
    // Second argument is tag
    // Third argument (optional) is tag value
    @Override
    public boolean checkArgs(List&lt;Value&gt; in) {
<span class="nc bnc" id="L1085" title="All 4 branches missed.">      if (in.size() != 2 &amp;&amp; in.size() != 3) {</span>
<span class="nc" id="L1086">        return false;</span>
      }
<span class="nc bnc" id="L1088" title="All 4 branches missed.">      if (in.get(0) == null || !(in.get(0).get() instanceof Tags)) {</span>
<span class="nc" id="L1089">        return false;</span>
      }
<span class="nc bnc" id="L1091" title="All 4 branches missed.">      if (in.get(1) == null || !(in.get(1).get() instanceof String)) {</span>
<span class="nc" id="L1092">        return false;</span>
      }
<span class="nc" id="L1094">      return true;</span>
    }
    @Override
    public Value apply(Env env, List&lt;Value&gt; in) {
<span class="nc" id="L1098">      Value v = in.get(0);</span>
<span class="nc" id="L1099">      Tags tags = (Tags) v.get();</span>
<span class="nc" id="L1100">      String tag = (String) in.get(1).get();</span>
<span class="nc bnc" id="L1101" title="All 2 branches missed.">      if (in.size() &gt;= 3) {</span>
<span class="nc" id="L1102">        Value tagValue = in.get(2);</span>
<span class="nc" id="L1103">        tags.setTag(tag, tagValue);</span>
      }
<span class="nc" id="L1105">      return tags.getTag(tag);</span>
    }
  };

<span class="nc" id="L1109">  public static final ValueFunction SET_VALUE_TAG_FUNCTION = new NamedValueFunction(&quot;VALUE_TAG&quot;) {</span>
    @Override
    public String getParamDesc() {
<span class="nc" id="L1112">      return &quot;Value,String tag,[Object value]&quot;;</span>
    }

    // First argument is what to tag
    // Second argument is tag
    // Third argument is tag value
    @Override
    public boolean checkArgs(List&lt;Value&gt; in) {
<span class="nc bnc" id="L1120" title="All 4 branches missed.">      if (in.size() != 2 &amp;&amp; in.size() != 3) {</span>
<span class="nc" id="L1121">        return false;</span>
      }
<span class="nc bnc" id="L1123" title="All 2 branches missed.">      if (in.get(0) == null) {</span>
<span class="nc" id="L1124">        return false;</span>
      }
<span class="nc bnc" id="L1126" title="All 4 branches missed.">      if (in.get(1) == null || !(in.get(1).get() instanceof String)) {</span>
<span class="nc" id="L1127">        return false;</span>
      }
<span class="nc" id="L1129">      return true;</span>
    }
    @Override
    public Value apply(Env env, List&lt;Value&gt; in) {
<span class="nc" id="L1133">      Value v = in.get(0);</span>
<span class="nc" id="L1134">      Tags tags = v.getTags();</span>
<span class="nc bnc" id="L1135" title="All 2 branches missed.">      if (tags == null) {</span>
<span class="nc" id="L1136">        v.setTags(tags = new Tags());</span>
      }
<span class="nc" id="L1138">      String tag = (String) in.get(1).get();</span>
<span class="nc bnc" id="L1139" title="All 2 branches missed.">      Value tagValue = (in.size() &gt;= 3)? in.get(2):null;</span>
<span class="nc" id="L1140">      tags.setTag(tag, tagValue);</span>
<span class="nc" id="L1141">      return v;</span>
    }
  };

<span class="nc" id="L1145">  public static final ValueFunction GET_VALUE_TAG_FUNCTION = new NamedValueFunction(&quot;GET_VALUE_TAG&quot;) {</span>
    @Override
    public String getParamDesc() {
<span class="nc" id="L1148">      return &quot;Value,String tag&quot;;</span>
    }

    // First argument is what to tag
    // Second argument is tag
    @Override
    public boolean checkArgs(List&lt;Value&gt; in) {
<span class="nc bnc" id="L1155" title="All 2 branches missed.">      if (in.size() != 2) {</span>
<span class="nc" id="L1156">        return false;</span>
      }
<span class="nc bnc" id="L1158" title="All 2 branches missed.">      if (in.get(0) == null) {</span>
<span class="nc" id="L1159">        return false;</span>
      }
<span class="nc bnc" id="L1161" title="All 4 branches missed.">      if (in.get(1) == null || !(in.get(1).get() instanceof String)) {</span>
<span class="nc" id="L1162">        return false;</span>
      }
<span class="nc" id="L1164">      return true;</span>
    }

    @Override
    public Value apply(Env env, List&lt;Value&gt; in) {
<span class="nc" id="L1169">      Value v = in.get(0);</span>
<span class="nc" id="L1170">      Tags tags = v.getTags();</span>
<span class="nc" id="L1171">      String tag = (String) in.get(1).get();</span>
<span class="nc bnc" id="L1172" title="All 2 branches missed.">      return (tags != null)? tags.getTag(tag):null;</span>
    }
  };

<span class="nc" id="L1176">  public static final ValueFunction REMOVE_VALUE_TAG_FUNCTION = new NamedValueFunction(&quot;REMOVE_VALUE_TAG&quot;) {</span>
    @Override
    public String getParamDesc() {
<span class="nc" id="L1179">      return &quot;Value,String tag&quot;;</span>
    }

    // First argument is what to tag
    // Second argument is tag
    @Override
    public boolean checkArgs(List&lt;Value&gt; in) {
<span class="nc bnc" id="L1186" title="All 2 branches missed.">      if (in.size() != 2) {</span>
<span class="nc" id="L1187">        return false;</span>
      }
<span class="nc bnc" id="L1189" title="All 2 branches missed.">      if (in.get(0) == null) {</span>
<span class="nc" id="L1190">        return false;</span>
      }
<span class="nc bnc" id="L1192" title="All 4 branches missed.">      if (in.get(1) == null || !(in.get(1).get() instanceof String)) {</span>
<span class="nc" id="L1193">        return false;</span>
      }
<span class="nc" id="L1195">      return true;</span>
    }
    @Override
    public Value apply(Env env, List&lt;Value&gt; in) {
<span class="nc" id="L1199">      Value v = in.get(0);</span>
<span class="nc" id="L1200">      Tags tags = v.getTags();</span>
<span class="nc bnc" id="L1201" title="All 2 branches missed.">      if (tags == null) {</span>
<span class="nc" id="L1202">        v.setTags(tags = new Tags());</span>
      }
<span class="nc" id="L1204">      String tag = (String) in.get(1).get();</span>
<span class="nc" id="L1205">      tags.removeTag(tag);</span>
<span class="nc" id="L1206">      return v;</span>
    }
  };

<span class="nc" id="L1210">  public static final ValueFunction COMPOSITE_VALUE_FUNCTION = new NamedValueFunction(&quot;COMPOSITE_VALUE&quot;) {</span>
    @Override
    public String getParamDesc() {
<span class="nc" id="L1213">      return Expressions.TYPE_COMPOSITE + &quot; obj,String field,[Object value]&quot;;</span>
    }

    // First argument is composite value
    // Second argument is field to select
    // Third argument (optional) is value to set composite value field to
    @Override
    public boolean checkArgs(List&lt;Value&gt; in) {
<span class="nc bnc" id="L1221" title="All 4 branches missed.">      if (in.size() != 2 &amp;&amp; in.size() != 3) {</span>
<span class="nc" id="L1222">        return false;</span>
      }
<span class="nc bnc" id="L1224" title="All 4 branches missed.">      if (in.get(0) == null || in.get(0).get() == null) return true;   // Allow for null</span>
<span class="nc bnc" id="L1225" title="All 4 branches missed.">      if (in.get(0) == null || !(in.get(0) instanceof Expressions.CompositeValue)) {</span>
<span class="nc" id="L1226">        return false;</span>
      }
<span class="nc bnc" id="L1228" title="All 4 branches missed.">      if (in.get(1) == null || !(in.get(1).get() instanceof String)) {</span>
<span class="nc" id="L1229">        return false;</span>
      }
<span class="nc" id="L1231">      return true;</span>
    }
    @Override
    public Value apply(Env env, List&lt;Value&gt; in) {
<span class="nc bnc" id="L1235" title="All 4 branches missed.">      if (in.get(0) == null || in.get(0).get() == null ) return null;   // Allow for null</span>
<span class="nc" id="L1236">      Expressions.CompositeValue v = (Expressions.CompositeValue) in.get(0);</span>
<span class="nc" id="L1237">      String fieldName = (String) in.get(1).get();</span>
<span class="nc bnc" id="L1238" title="All 2 branches missed.">      if (in.size() &gt;= 3) {</span>
<span class="nc" id="L1239">        v.set(fieldName, in.get(2));</span>
      }
<span class="nc" id="L1241">      return v.getValue(fieldName);</span>
    }
  };

<span class="nc" id="L1245">  public static final ValueFunction COMPOSITE_KEYS_FUNCTION = new NamedValueFunction(&quot;COMPOSITE_KEYS&quot;) {</span>
    @Override
    public String getParamDesc() {
<span class="nc" id="L1248">      return Expressions.TYPE_COMPOSITE;</span>
    }

    // First argument is composite value
    @Override
    public boolean checkArgs(List&lt;Value&gt; in) {
<span class="nc bnc" id="L1254" title="All 2 branches missed.">      if (in.size() != 1) {</span>
<span class="nc" id="L1255">        return false;</span>
      }
<span class="nc bnc" id="L1257" title="All 4 branches missed.">      if (in.get(0) == null || in.get(0).get() == null) return true;   // Allow for null</span>
<span class="nc bnc" id="L1258" title="All 4 branches missed.">      if (in.get(0) == null || !(in.get(0) instanceof Expressions.CompositeValue)) {</span>
<span class="nc" id="L1259">        return false;</span>
      }
<span class="nc" id="L1261">      return true;</span>
    }
    @Override
    public Value apply(Env env, List&lt;Value&gt; in) {
<span class="nc bnc" id="L1265" title="All 4 branches missed.">      if (in.get(0) == null || in.get(0).get() == null ) return null;   // Allow for null</span>
<span class="nc" id="L1266">      Expressions.CompositeValue v = (Expressions.CompositeValue) in.get(0);</span>
<span class="nc" id="L1267">      List&lt;String&gt; res = new ArrayList&lt;&gt;(v.getAttributes());</span>
<span class="nc" id="L1268">      return Expressions.createValue(Expressions.TYPE_LIST, res);</span>
    }
  };

<span class="nc" id="L1272">  public static final ValueFunction OBJECT_FIELD_FUNCTION = new NamedValueFunction(&quot;OBJECT_FIELD&quot;) {</span>
    @Override
    public String getParamDesc() {
<span class="nc" id="L1275">      return &quot;Object obj,String fieldName,[Object value]&quot;;</span>
    }

    // First argument is object
    // Second argument is field to select
    // Third argument (optional) is value to assign to object field
    @Override
    public boolean checkArgs(List&lt;Value&gt; in) {
<span class="nc bnc" id="L1283" title="All 4 branches missed.">      if (in.size() != 2 &amp;&amp; in.size() != 3) {</span>
<span class="nc" id="L1284">        return false;</span>
      }
<span class="nc bnc" id="L1286" title="All 4 branches missed.">      if (in.get(0) == null || in.get(0).get() == null) return true;   // Allow for null</span>
<span class="nc bnc" id="L1287" title="All 4 branches missed.">      if (in.get(0) == null || !(in.get(0) instanceof Object)) {</span>
<span class="nc" id="L1288">        return false;</span>
      }
<span class="nc bnc" id="L1290" title="All 4 branches missed.">      if (in.get(1) == null || !(in.get(1).get() instanceof String)) {</span>
<span class="nc" id="L1291">        return false;</span>
      }
<span class="nc" id="L1293">      return true;</span>
    }

    @Override
    public Value apply(Env env, List&lt;Value&gt; in) {
<span class="nc bnc" id="L1298" title="All 4 branches missed.">      if (in.get(0) == null || in.get(0).get() == null ) return null;   // Allow for null</span>
<span class="nc" id="L1299">      Value v = in.get(0);</span>
<span class="nc" id="L1300">      String fieldName = (String) in.get(1).get();</span>
      try {
<span class="nc" id="L1302">        Object obj = v.get();</span>
<span class="nc" id="L1303">        Field f = obj.getClass().getField(fieldName);</span>
<span class="nc bnc" id="L1304" title="All 2 branches missed.">        if (in.size() &gt;= 3) {</span>
<span class="nc" id="L1305">          Value fieldValue = in.get(2);</span>
<span class="nc bnc" id="L1306" title="All 2 branches missed.">          if (fieldValue == null) {</span>
<span class="nc" id="L1307">            f.set(obj, null);</span>
<span class="nc bnc" id="L1308" title="All 2 branches missed.">          } else if (f.getType().isAssignableFrom(Value.class)) {</span>
<span class="nc" id="L1309">            f.set(obj, fieldValue);</span>
          } else {
<span class="nc bnc" id="L1311" title="All 2 branches missed.">            if (fieldValue.get() == null) {</span>
<span class="nc" id="L1312">              f.set(obj, null);</span>
<span class="nc bnc" id="L1313" title="All 2 branches missed.">            } else if (f.getType().isAssignableFrom(List.class)) {</span>
<span class="nc bnc" id="L1314" title="All 2 branches missed.">              if (fieldValue.get() instanceof List) {</span>
<span class="nc" id="L1315">                List list = (List) fieldValue.get();</span>
<span class="nc" id="L1316">                Type[] fieldParamTypes = ((ParameterizedType) f.getGenericType()).getActualTypeArguments();</span>
<span class="nc bnc" id="L1317" title="All 2 branches missed.">                if (fieldParamTypes[0] instanceof Value) {</span>
<span class="nc" id="L1318">                  List&lt;Value&gt; list2 = new ArrayList&lt;&gt;(list.size());</span>
<span class="nc bnc" id="L1319" title="All 2 branches missed.">                  for (Object elem:list) {</span>
<span class="nc" id="L1320">                    list2.add(Expressions.asValue(env, elem));</span>
<span class="nc" id="L1321">                  }</span>
<span class="nc" id="L1322">                  f.set(obj, list2);</span>
<span class="nc" id="L1323">                } else {</span>
<span class="nc" id="L1324">                  List list2 = new ArrayList(list.size());</span>
<span class="nc bnc" id="L1325" title="All 2 branches missed.">                  for (Object elem:list) {</span>
<span class="nc bnc" id="L1326" title="All 2 branches missed.">                    if (elem instanceof Value) {</span>
<span class="nc" id="L1327">                      list2.add(((Value) elem).get());</span>
                    } else {
<span class="nc" id="L1329">                      list2.add(elem);</span>
                    }
<span class="nc" id="L1331">                  }</span>
<span class="nc" id="L1332">                  f.set(obj, list2);</span>
                }
<span class="nc" id="L1334">              } else {</span>
<span class="nc" id="L1335">                f.set(obj, Arrays.asList(fieldValue.get()));</span>
              }
            } else {
<span class="nc" id="L1338">              f.set(obj, fieldValue.get());</span>
            }
          }
        }
<span class="nc" id="L1342">        return Expressions.createValue(null, f.get(obj));</span>
<span class="nc" id="L1343">      } catch (NoSuchFieldException ex) {</span>
<span class="nc" id="L1344">        throw new RuntimeException(&quot;Cannot get field &quot; + fieldName + &quot; from &quot; + v, ex);</span>
<span class="nc" id="L1345">      } catch (IllegalAccessException ex) {</span>
<span class="nc" id="L1346">        throw new RuntimeException(&quot;Cannot get field &quot; + fieldName + &quot; from &quot; + v, ex);</span>
      }
    }
  };

<span class="nc" id="L1351">  public static final ValueFunction LIST_VALUE_FUNCTION = new NamedValueFunction(&quot;LIST_VALUE&quot;) {</span>
    @Override
    public String getParamDesc() {
<span class="nc" id="L1354">      return &quot;List list,int index,[Object value]&quot;;</span>
    }

    // First argument is List
    // Second argument is index of element to select
    // Third argument (optional) is value to assign list element
    @Override
    public boolean checkArgs(List&lt;Value&gt; in) {
<span class="nc bnc" id="L1362" title="All 4 branches missed.">      if (in.size() != 2 &amp;&amp; in.size() != 3) {</span>
<span class="nc" id="L1363">        return false;</span>
      }
<span class="nc bnc" id="L1365" title="All 4 branches missed.">      if (in.get(0) == null || in.get(0).get() == null) return true;   // Allow for null</span>
<span class="nc bnc" id="L1366" title="All 4 branches missed.">      if (in.get(0) == null || !(in.get(0).get() instanceof List)) {</span>
<span class="nc" id="L1367">        return false;</span>
      }
<span class="nc bnc" id="L1369" title="All 4 branches missed.">      if (in.get(1) == null || !(in.get(1).get() instanceof Integer)) {</span>
<span class="nc" id="L1370">        return false;</span>
      }
<span class="nc" id="L1372">      return true;</span>
    }
    @Override
    public Value apply(Env env, List&lt;Value&gt; in) {
<span class="nc bnc" id="L1376" title="All 4 branches missed.">      if (in.get(0) == null || in.get(0).get() == null ) return null;   // Allow for null</span>
<span class="nc" id="L1377">      List list = (List) in.get(0).get();</span>
<span class="nc" id="L1378">      Integer index = (Integer) in.get(1).get();</span>
<span class="nc bnc" id="L1379" title="All 2 branches missed.">      if (index &lt; 0) {</span>
<span class="nc" id="L1380">        index = list.size() + index;</span>
      }
<span class="nc bnc" id="L1382" title="All 4 branches missed.">      if (index &gt;= list.size() || index &lt; 0) {</span>
        // index out of bounds
<span class="nc" id="L1384">        return null;</span>
      }
<span class="nc bnc" id="L1386" title="All 2 branches missed.">      if (in.size() &gt;= 3) {</span>
<span class="nc" id="L1387">        Value fieldValue = in.get(2);</span>
<span class="nc bnc" id="L1388" title="All 2 branches missed.">        if (fieldValue != null) {</span>
<span class="nc" id="L1389">          list.set(index, fieldValue.get());</span>
        } else {
<span class="nc" id="L1391">          list.set(index, null);</span>
        }
      }
<span class="nc" id="L1394">      Object obj = list.get(index);</span>
<span class="nc" id="L1395">      return Expressions.asValue(env, obj);</span>
//      return Expressions.PrimitiveValue.create(null, obj);
    }
  };

<span class="nc" id="L1400">  public static final ValueFunction MAP_VALUE_FUNCTION = new NamedValueFunction(&quot;MAP_VALUE&quot;) {</span>
    @Override
    public String getParamDesc() {
<span class="nc" id="L1403">      return &quot;Map map,Object key,[Object value]&quot;;</span>
    }

    // First argument is Map
    // Second argument is key of element to select
    // Third argument (optional) is value to assign to element
    @Override
    public boolean checkArgs(List&lt;Value&gt; in) {
<span class="nc bnc" id="L1411" title="All 4 branches missed.">      if (in.size() != 2 &amp;&amp; in.size() != 3) {</span>
<span class="nc" id="L1412">        return false;</span>
      }
<span class="nc bnc" id="L1414" title="All 4 branches missed.">      if (in.get(0) == null || in.get(0).get() == null) return true;   // Allow for null</span>
<span class="nc bnc" id="L1415" title="All 4 branches missed.">      if (in.get(0) == null || !(in.get(0).get() instanceof Map)) {</span>
<span class="nc" id="L1416">        return false;</span>
      }
<span class="nc bnc" id="L1418" title="All 4 branches missed.">      if (in.get(1) == null || !(in.get(1).get() instanceof Object)) {</span>
<span class="nc" id="L1419">        return false;</span>
      }
<span class="nc" id="L1421">      return true;</span>
    }
    @Override
    public Value apply(Env env, List&lt;Value&gt; in) {
<span class="nc bnc" id="L1425" title="All 4 branches missed.">      if (in.get(0) == null || in.get(0).get() == null ) return null;   // Allow for null</span>
<span class="nc" id="L1426">      Map map = (Map) in.get(0).get();</span>
<span class="nc" id="L1427">      Object key = in.get(1).get();</span>
<span class="nc bnc" id="L1428" title="All 2 branches missed.">      if (in.size() &gt;= 3) {</span>
<span class="nc" id="L1429">        Value fieldValue = in.get(2);</span>
<span class="nc bnc" id="L1430" title="All 2 branches missed.">        if (fieldValue != null) {</span>
<span class="nc" id="L1431">          map.put(key, fieldValue.get());</span>
        } else {
<span class="nc" id="L1433">          map.remove(key);</span>
        }
      }
<span class="nc" id="L1436">      Object obj = map.get(key);</span>
<span class="nc bnc" id="L1437" title="All 6 branches missed.">      if (in.size() == 2 &amp;&amp; obj == null &amp;&amp; key instanceof String) {</span>
<span class="nc" id="L1438">        Class annotationFieldClass = null;</span>
<span class="nc" id="L1439">        annotationFieldClass = EnvLookup.lookupAnnotationKey(env, (String) key);</span>
<span class="nc bnc" id="L1440" title="All 2 branches missed.">        if (annotationFieldClass != null) {</span>
<span class="nc" id="L1441">          obj = map.get(annotationFieldClass);</span>
        }
      }
<span class="nc" id="L1444">      return Expressions.asValue(env, obj);</span>
//      return Expressions.PrimitiveValue.create(null, obj);
    }
  };

<span class="nc" id="L1449">  public static final ValueFunction MAP_KEYS_FUNCTION = new NamedValueFunction(&quot;MAP_KEYS&quot;) {</span>
    @Override
    public String getParamDesc() {
<span class="nc" id="L1452">      return &quot;Map&quot;;</span>
    }

    // First argument is Map
    @Override
    public boolean checkArgs(List&lt;Value&gt; in) {
<span class="nc bnc" id="L1458" title="All 2 branches missed.">      if (in.size() != 1) {</span>
<span class="nc" id="L1459">        return false;</span>
      }
<span class="nc bnc" id="L1461" title="All 4 branches missed.">      if (in.get(0) == null || in.get(0).get() == null) return true;   // Allow for null</span>
<span class="nc bnc" id="L1462" title="All 4 branches missed.">      if (in.get(0) == null || !(in.get(0).get() instanceof Map)) {</span>
<span class="nc" id="L1463">        return false;</span>
      }
<span class="nc" id="L1465">      return true;</span>
    }
    @Override
    public Value apply(Env env, List&lt;Value&gt; in) {
<span class="nc bnc" id="L1469" title="All 4 branches missed.">      if (in.get(0) == null || in.get(0).get() == null ) return null;   // Allow for null</span>
<span class="nc" id="L1470">      Map map = (Map) in.get(0).get();</span>
<span class="nc" id="L1471">      List&lt;Object&gt; res = new ArrayList&lt;&gt;(map.keySet());</span>
<span class="nc" id="L1472">      return Expressions.createValue(Expressions.TYPE_LIST, res);</span>
    }
  };

<span class="nc" id="L1476">  public static final ValueFunction AGGREGATE_FUNCTION = new NamedValueFunction(&quot;AGGREGATE&quot;) {</span>
    @Override
    public String getParamDesc() {
<span class="nc" id="L1479">      return &quot;ValueFunction func,Object initialValue,...&quot;;</span>
    }

    // First argument is function to apply
    // Second argument is initial value
    @Override
    public boolean checkArgs(List&lt;Value&gt; in) {
<span class="nc bnc" id="L1486" title="All 2 branches missed.">      if (in.size() &lt; 2) {</span>
<span class="nc" id="L1487">        return false;</span>
      }
<span class="nc bnc" id="L1489" title="All 4 branches missed.">      if (in.get(0) == null || !(in.get(0).get() instanceof ValueFunction)) {</span>
<span class="nc" id="L1490">        return false;</span>
      }
<span class="nc bnc" id="L1492" title="All 2 branches missed.">      if (in.get(1) == null) {</span>
<span class="nc" id="L1493">        return false;</span>
      }
<span class="nc" id="L1495">      return true;</span>
    }
    @Override
    public Value apply(Env env, List&lt;Value&gt; in) {
<span class="nc" id="L1499">      ValueFunction func = (ValueFunction) in.get(0).get();</span>
<span class="nc" id="L1500">      Value res = in.get(1);</span>
<span class="nc" id="L1501">      List&lt;Value&gt; args = new ArrayList&lt;&gt;(2);</span>
<span class="nc bnc" id="L1502" title="All 2 branches missed.">      for (int i = 2; i &lt; in.size(); i++) {</span>
<span class="nc" id="L1503">        args.set(0, res);</span>
<span class="nc" id="L1504">        args.set(1, in.get(i));</span>
<span class="nc" id="L1505">        res = func.apply(env, args);</span>
      }
<span class="nc" id="L1507">      return res;</span>
    }
  };

<span class="nc" id="L1511">  public static final ValueFunction CALL_FUNCTION = new NamedValueFunction(&quot;CALL&quot;) {</span>
    @Override
    public String getParamDesc() {
<span class="nc" id="L1514">      return &quot;ValueFunction func or String funcname,...&quot;;</span>
    }

    // First argument is function to apply
    @Override
    public boolean checkArgs(List&lt;Value&gt; in) {
<span class="nc bnc" id="L1520" title="All 2 branches missed.">      if (in.size() &lt; 1) {</span>
<span class="nc" id="L1521">        return false;</span>
      }
<span class="nc bnc" id="L1523" title="All 2 branches missed.">      if (in.get(0) == null ||</span>
<span class="nc bnc" id="L1524" title="All 4 branches missed.">        !(in.get(0).get() instanceof ValueFunction || in.get(0).get() instanceof String)) {</span>
<span class="nc" id="L1525">        return false;</span>
      }
<span class="nc" id="L1527">      return true;</span>
    }
    @Override
    public Value apply(Env env, List&lt;Value&gt; in) {
      Value res;
<span class="nc" id="L1532">      List&lt;Value&gt; args = new ArrayList&lt;&gt;(in.size() - 1);</span>
<span class="nc bnc" id="L1533" title="All 2 branches missed.">      for (int i = 1; i &lt; in.size(); i++) {</span>
<span class="nc" id="L1534">        args.add(in.get(i));</span>
      }
<span class="nc bnc" id="L1536" title="All 2 branches missed.">      if (in.get(0).get() instanceof ValueFunction) {</span>
<span class="nc" id="L1537">        ValueFunction func = (ValueFunction) in.get(0).get();</span>
<span class="nc" id="L1538">        res = func.apply(env, args);</span>
<span class="nc bnc" id="L1539" title="All 2 branches missed.">      } else if (in.get(0).get() instanceof String) {</span>
<span class="nc" id="L1540">        Expressions.FunctionCallExpression func =</span>
<span class="nc" id="L1541">          new Expressions.FunctionCallExpression((String) in.get(0).get(), args);</span>
<span class="nc" id="L1542">        res = func.evaluate(env);</span>
<span class="nc" id="L1543">      } else {</span>
<span class="nc" id="L1544">        throw new IllegalArgumentException(&quot;Type mismatch on arg0: Cannot apply &quot; + this + &quot; to &quot; + in);</span>
      }
<span class="nc" id="L1546">      return res;</span>
    }
  };

<span class="nc" id="L1550">  static final CollectionValuedMap&lt;String, ValueFunction&gt; registeredFunctions =</span>
          new CollectionValuedMap&lt;&gt;(
<span class="nc" id="L1552">                  MapFactory.&lt;String, Collection&lt;ValueFunction&gt;&gt;linkedHashMapFactory(),</span>
<span class="nc" id="L1553">                  CollectionFactory.&lt;ValueFunction&gt;arrayListFactory(), false);</span>
  static {
<span class="nc" id="L1555">    registeredFunctions.add(&quot;Add&quot;, ADD_FUNCTION);</span>
<span class="nc" id="L1556">    registeredFunctions.add(&quot;Subtract&quot;, SUBTRACT_FUNCTION);</span>
<span class="nc" id="L1557">    registeredFunctions.add(&quot;Multiply&quot;, MULTIPLY_FUNCTION);</span>
<span class="nc" id="L1558">    registeredFunctions.add(&quot;Divide&quot;, DIVIDE_FUNCTION);</span>
<span class="nc" id="L1559">    registeredFunctions.add(&quot;Mod&quot;, MOD_FUNCTION);</span>
<span class="nc" id="L1560">    registeredFunctions.add(&quot;Min&quot;, MIN_FUNCTION);</span>
<span class="nc" id="L1561">    registeredFunctions.add(&quot;Max&quot;, MAX_FUNCTION);</span>
<span class="nc" id="L1562">    registeredFunctions.add(&quot;Pow&quot;, POW_FUNCTION);</span>
<span class="nc" id="L1563">    registeredFunctions.add(&quot;Negate&quot;, NEGATE_FUNCTION);</span>

<span class="nc" id="L1565">    registeredFunctions.add(&quot;And&quot;, AND_FUNCTION);</span>
<span class="nc" id="L1566">    registeredFunctions.add(&quot;Or&quot;, OR_FUNCTION);</span>
<span class="nc" id="L1567">    registeredFunctions.add(&quot;Not&quot;, NOT_FUNCTION);</span>

<span class="nc" id="L1569">    registeredFunctions.add(&quot;Format&quot;, FORMAT_FUNCTION);</span>
<span class="nc" id="L1570">    registeredFunctions.add(&quot;Concat&quot;, CONCAT_FUNCTION);</span>
<span class="nc" id="L1571">    registeredFunctions.add(&quot;Join&quot;, JOIN_FUNCTION);</span>
<span class="nc" id="L1572">    registeredFunctions.add(&quot;Lowercase&quot;, LOWERCASE_FUNCTION);</span>
<span class="nc" id="L1573">    registeredFunctions.add(&quot;Uppercase&quot;, UPPERCASE_FUNCTION);</span>

<span class="nc" id="L1575">    registeredFunctions.add(&quot;Map&quot;, MAP_VALUES_FUNCTION);</span>
<span class="nc" id="L1576">    registeredFunctions.add(&quot;Map&quot;, MAP_FUNCTION);</span>

<span class="nc" id="L1578">    registeredFunctions.add(&quot;Match&quot;, TOKENS_MATCH_FUNCTION);</span>
<span class="nc" id="L1579">    registeredFunctions.add(&quot;Match&quot;, STRING_MATCH_FUNCTION);</span>
<span class="nc" id="L1580">    registeredFunctions.add(&quot;Replace&quot;, TOKENS_REPLACE_FUNCTION);</span>
<span class="nc" id="L1581">    registeredFunctions.add(&quot;Replace&quot;, STRING_REPLACE_FUNCTION);</span>

<span class="nc" id="L1583">    registeredFunctions.add(&quot;GE&quot;, new CompareFunction&lt;&gt;(&quot;GE&quot;, NUMBER_COMPARATOR, CompareType.GE, Number.class) );</span>
<span class="nc" id="L1584">    registeredFunctions.add(&quot;GT&quot;, new CompareFunction&lt;&gt;(&quot;GT&quot;, NUMBER_COMPARATOR, CompareType.GT, Number.class) );</span>
<span class="nc" id="L1585">    registeredFunctions.add(&quot;LE&quot;, new CompareFunction&lt;&gt;(&quot;LE&quot;, NUMBER_COMPARATOR, CompareType.LE, Number.class) );</span>
<span class="nc" id="L1586">    registeredFunctions.add(&quot;LT&quot;, new CompareFunction&lt;&gt;(&quot;LT&quot;, NUMBER_COMPARATOR, CompareType.LT, Number.class) );</span>
<span class="nc" id="L1587">    registeredFunctions.add(&quot;EQ&quot;, new CompareFunction&lt;&gt;(&quot;EQ&quot;, NUMBER_COMPARATOR, CompareType.EQ, Number.class) );</span>
<span class="nc" id="L1588">    registeredFunctions.add(&quot;NE&quot;, new CompareFunction&lt;&gt;(&quot;NE&quot;, NUMBER_COMPARATOR, CompareType.NE, Number.class) );</span>
<span class="nc" id="L1589">    registeredFunctions.add(&quot;EQ&quot;, EQUALS_FUNCTION );</span>
<span class="nc" id="L1590">    registeredFunctions.add(&quot;NE&quot;, NOT_EQUALS_FUNCTION );</span>

<span class="nc" id="L1592">    registeredFunctions.add(&quot;VTag&quot;, SET_VALUE_TAG_FUNCTION);</span>
<span class="nc" id="L1593">    registeredFunctions.add(&quot;GetVTag&quot;, GET_VALUE_TAG_FUNCTION);</span>
<span class="nc" id="L1594">    registeredFunctions.add(&quot;RemoveVTag&quot;, REMOVE_VALUE_TAG_FUNCTION);</span>

<span class="nc" id="L1596">    registeredFunctions.add(&quot;Tag&quot;, SET_ANNOTATION_TAG_FUNCTION);</span>
<span class="nc" id="L1597">    registeredFunctions.add(&quot;GetTag&quot;, GET_ANNOTATION_TAG_FUNCTION);</span>
<span class="nc" id="L1598">    registeredFunctions.add(&quot;RemoveTag&quot;, REMOVE_ANNOTATION_TAG_FUNCTION);</span>

<span class="nc" id="L1600">    registeredFunctions.add(&quot;Split&quot;, TOKEN_STRING_SPLIT_FUNCTION);</span>
<span class="nc" id="L1601">    registeredFunctions.add(&quot;Annotate&quot;, ANNOTATION_FUNCTION);</span>
<span class="nc" id="L1602">    registeredFunctions.add(&quot;Aggregate&quot;, AGGREGATE_FUNCTION);</span>

<span class="nc" id="L1604">    registeredFunctions.add(&quot;Call&quot;, CALL_FUNCTION);</span>

<span class="nc" id="L1606">    registeredFunctions.add(&quot;CreateRegex&quot;, CREATE_REGEX_FUNCTION);</span>

<span class="nc" id="L1608">    registeredFunctions.add(&quot;Select&quot;, COMPOSITE_VALUE_FUNCTION);</span>
<span class="nc" id="L1609">    registeredFunctions.add(&quot;Select&quot;, MAP_VALUE_FUNCTION);</span>
<span class="nc" id="L1610">    registeredFunctions.add(&quot;Select&quot;, TAGS_VALUE_FUNCTION);</span>
<span class="nc" id="L1611">    registeredFunctions.add(&quot;Select&quot;, ANNOTATION_FUNCTION);</span>
<span class="nc" id="L1612">    registeredFunctions.add(&quot;Select&quot;, OBJECT_FIELD_FUNCTION);</span>
<span class="nc" id="L1613">    registeredFunctions.add(&quot;ListSelect&quot;, LIST_VALUE_FUNCTION);</span>

<span class="nc" id="L1615">    registeredFunctions.add(&quot;Keys&quot;, MAP_KEYS_FUNCTION);</span>
<span class="nc" id="L1616">    registeredFunctions.add(&quot;Keys&quot;, COMPOSITE_KEYS_FUNCTION);</span>

<span class="nc" id="L1618">    registeredFunctions.add(&quot;Set&quot;, TAGS_VALUE_FUNCTION);</span>
<span class="nc" id="L1619">    registeredFunctions.add(&quot;Set&quot;, COMPOSITE_VALUE_FUNCTION);</span>
<span class="nc" id="L1620">    registeredFunctions.add(&quot;Set&quot;, MAP_VALUE_FUNCTION);</span>
<span class="nc" id="L1621">    registeredFunctions.add(&quot;Set&quot;, ANNOTATION_FUNCTION);</span>
<span class="nc" id="L1622">    registeredFunctions.add(&quot;Set&quot;, OBJECT_FIELD_FUNCTION);</span>
<span class="nc" id="L1623">    registeredFunctions.add(&quot;Set&quot;, LIST_VALUE_FUNCTION);</span>
<span class="nc" id="L1624">    registeredFunctions.add(&quot;Get&quot;, TAGS_VALUE_FUNCTION);</span>
<span class="nc" id="L1625">    registeredFunctions.add(&quot;Get&quot;, COMPOSITE_VALUE_FUNCTION);</span>
<span class="nc" id="L1626">    registeredFunctions.add(&quot;Get&quot;, MAP_VALUE_FUNCTION);</span>
<span class="nc" id="L1627">    registeredFunctions.add(&quot;Get&quot;, ANNOTATION_FUNCTION);</span>
<span class="nc" id="L1628">    registeredFunctions.add(&quot;Get&quot;, OBJECT_FIELD_FUNCTION);</span>
<span class="nc" id="L1629">    registeredFunctions.add(&quot;Get&quot;, LIST_VALUE_FUNCTION);</span>

    // For debugging
<span class="nc" id="L1632">    registeredFunctions.add(&quot;Print&quot;, PRINT_FUNCTION);</span>
<span class="nc" id="L1633">  }</span>

  public static void main(String[] args) {
    // Dumps the registered functions
<span class="nc bnc" id="L1637" title="All 2 branches missed.">    for (Map.Entry&lt;String, Collection&lt;ValueFunction&gt;&gt; entry : registeredFunctions.entrySet()) {</span>
<span class="nc bnc" id="L1638" title="All 2 branches missed.">      for (ValueFunction vf: entry.getValue()) {</span>
<span class="nc" id="L1639">        System.out.println(entry.getKey() + &quot;: &quot; + vf);</span>
<span class="nc" id="L1640">      }</span>
<span class="nc" id="L1641">    }</span>
<span class="nc" id="L1642">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>