<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Expressions.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.ling.tokensregex.types</a> &gt; <span class="el_source">Expressions.java</span></div><h1>Expressions.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.ling.tokensregex.types;
import edu.stanford.nlp.util.logging.Redwood;

import edu.stanford.nlp.ling.tokensregex.Env;
import edu.stanford.nlp.ling.tokensregex.EnvLookup;
import edu.stanford.nlp.ling.tokensregex.SequenceMatchResult;
import edu.stanford.nlp.util.CoreMap;
import edu.stanford.nlp.util.MetaClass;
import edu.stanford.nlp.util.Pair;
import edu.stanford.nlp.util.StringUtils;

import java.io.Serializable;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.*;
import java.util.regex.MatchResult;
import java.util.regex.Pattern;

/**
 * Various implementations of the Expression interface, which is
 *   used for specifying an &quot;action&quot; or &quot;result&quot; in TokensRegex extraction rules.
 *   Expressions are made up of identifiers, literals (numbers, strings &quot;I'm a string&quot;, TRUE, FALSE),
 *     function calls ( FUNC(args) ).
 * &lt;/p&gt;
 *
 * After a pattern has been matched, we can access the capture groups using one of the following methods:
 * &lt;p&gt;
 * &lt;table&gt;
 *   &lt;tr&gt;&lt;th&gt;Field&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;th colspan=&quot;2&quot;&gt;Accessing captured groups as list of tokens&lt;/th&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;$n&lt;/td&gt;&lt;td&gt;Capture group (as list of tokens) corresponding to the variable &lt;code&gt;$n&lt;/code&gt;.
 *     If &lt;code&gt;n&lt;/code&gt; is a integer, then the n-th captured group.  Capture group 0 is the entire matched expression.
 *     Otherwise, if &lt;code&gt;n&lt;/code&gt; is a string, then the captured group with name &lt;code&gt;n&lt;/code&gt;.&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;$n[i]&lt;/td&gt;&lt;td&gt;The i-th token of the captured group &lt;code&gt;$n&lt;/code&gt;.
 *     Use negative indices to count from the end of the list (e.g. -1 is the last token).&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;$n[i].key&lt;/td&gt;&lt;td&gt;The value of annotation &lt;code&gt;key&lt;/code&gt; of the i-th token of the captured group &lt;code&gt;$n&lt;/code&gt;.&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;th colspan=&quot;2&quot;&gt;Accessing captured groups as MatchedGroupInfo&lt;/th&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;$$n&lt;/td&gt;&lt;td&gt;Capture group (as MatchedGroupInfo) corresponding to the variable &lt;code&gt;$n&lt;/code&gt;.
 *     Use to get the associated value of the group and any embedded capture groups.
 *     If &lt;code&gt;n&lt;/code&gt; is a integer, then the n-th captured group.  Capture group 0 is the entire matched expression.
 *     Otherwise, if &lt;code&gt;n&lt;/code&gt; is a string, then the captured group with name &lt;code&gt;n&lt;/code&gt;.&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;$$n.text&lt;/td&gt;&lt;td&gt;Text of the capture group &lt;code&gt;n&lt;/code&gt;.&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;$$n.nodes&lt;/td&gt;&lt;td&gt;Tokens of the capture group &lt;code&gt;n&lt;/code&gt; (this is equivalent to &lt;code&gt;$n&lt;/code&gt;).&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;$$n.value&lt;/td&gt;&lt;td&gt;Value associated with capture group &lt;code&gt;n&lt;/code&gt;.&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;$$n.matchResults&lt;/td&gt;&lt;td&gt;Additional match results associated with capture group &lt;code&gt;n&lt;/code&gt;.
 *      Use to get embedded capture groups.  For instance, when the TokensRegex &lt;code&gt;/(\d\d)-(\d\d)/&lt;/code&gt; is matched
 *      against the sentence &quot;the score was 10-12&quot;, &lt;code&gt;$$0.text&lt;/code&gt; will be &quot;10-12&quot; and
 *      &lt;code&gt;$$0.matchResults[0].word.group(1)&lt;/code&gt; will be &quot;10&quot;.&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 *   The following functions are supported:
 * &lt;table&gt;
 *   &lt;tr&gt;&lt;th&gt;Function&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;&lt;code&gt;Annotate(CoreMap, field, value)&lt;/td&gt;&lt;td&gt;Annotates the CoreMap with specified field=value&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;&lt;code&gt;Aggregate(function, initialValue,...)&lt;/td&gt;&lt;td&gt;Aggregates values using function (like fold)&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;&lt;code&gt;Split(CoreMap, delimRegex, includeMatched)&lt;/td&gt;&lt;td&gt;Split one CoreMap into smaller coremaps using the specified delimRegex on the text of the CoreMap.
 *     If includeMatched is true, pieces that matches the delimRegex are included in the final list of CoreMaps&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;th colspan=&quot;2&quot;&gt;Tagging functions&lt;/th&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;&lt;code&gt;Tag(CoreMap or List&amp;lt;CoreMap&amp;gt;, tag, value)&lt;br/&gt;VTag(Value,tag,value)&lt;/code&gt;&lt;/td&gt;&lt;td&gt;Sets a temporary tag on the CoreMap(s) or Value&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;&lt;code&gt;GetTag(CoreMap or List&amp;lt;CoreMap&amp;gt;, tag)&lt;br/&gt;GetVTag(Value,tag)&lt;/code&gt;&lt;/td&gt;&lt;td&gt;Returns the temporary tag on the CoreMap(s) or Value&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;&lt;code&gt;RemoveTag(CoreMap or List&amp;lt;CoreMap&amp;gt;, tag)&lt;br/&gt;RemoveVTag(Value,tag)&lt;/code&gt;&lt;/td&gt;&lt;td&gt;Removes the temporary tag on the CoreMap(s) or Value&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;th colspan=&quot;2&quot;&gt;Regex functions&lt;/th&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;&lt;code&gt;Match(List&amp;lt;CoreMap&amp;gt;, tokensregex)&lt;br/&gt;Match(String,regex)&lt;/code&gt;&lt;/td&gt;&lt;td&gt;Returns whether the tokens or text matched&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;&lt;code&gt;Replace(List&amp;lt;CoreMap&amp;gt;, tokensregex, replacement)&lt;br/&gt;Match(String,regex,replacement)&lt;/code&gt;&lt;/td&gt;&lt;td&gt;Replaces the matched tokens or text&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;&lt;code&gt;CreateRegex(List&amp;lt;String&amp;gt;)&lt;/code&gt;&lt;/td&gt;&lt;td&gt;Creates one big string regular expression that matches any of the strings in the list&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;th colspan=&quot;2&quot;&gt;Accessor functions&lt;/th&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;&lt;code&gt;Map(list,function)&lt;/code&gt;&lt;/td&gt;&lt;td&gt;Returns a new list that is the result of applying the function on every element of the List&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;&lt;code&gt;Keys(map)&lt;/code&gt;&lt;/td&gt;&lt;td&gt;Returns list of keys for the given map&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;&lt;code&gt;Set(object or map, fieldname, value)&lt;br/&gt;Set(list,index,value)&lt;/code&gt;&lt;/td&gt;&lt;td&gt;Set the field to the specified value&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;&lt;code&gt;Get(object or map, fieldname) or object.fieldname &lt;br/&gt;Get(list,index) or list[index]&lt;/code&gt;&lt;/td&gt;&lt;td&gt;Returns the value of the specified field&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;th colspan=&quot;2&quot;&gt;String functions&lt;/th&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;&lt;code&gt;Format(format,arg1,arg2,...)&lt;/code&gt;&lt;/td&gt;&lt;td&gt;Returns formatted string&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;&lt;code&gt;Concat(str1,str2,...)&lt;/code&gt;&lt;/td&gt;&lt;td&gt;Returns strings concatenated together&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;&lt;code&gt;Join(glue,str1,str2,...)&lt;/code&gt;&lt;/td&gt;&lt;td&gt;Returns strings concatenated together with glue in the middle&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;&lt;code&gt;Lowercase(str)&lt;/code&gt;&lt;/td&gt;&lt;td&gt;Returns the lowercase form of the string&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;&lt;code&gt;Uppercase(str)&lt;/code&gt;&lt;/td&gt;&lt;td&gt;Returns the uppercase form of the string&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;th colspan=&quot;2&quot;&gt;Numeric functions&lt;/th&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;&lt;code&gt;Subtract(X,Y)&lt;/code&gt;&lt;/td&gt;&lt;td&gt;Returns &lt;code&gt;X-Y&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;&lt;code&gt;Add(X,Y)&lt;/code&gt;&lt;/td&gt;&lt;td&gt;Returns &lt;code&gt;X+Y&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;&lt;code&gt;Subtract(X,Y)&lt;/code&gt;&lt;/td&gt;&lt;td&gt;Returns &lt;code&gt;X-Y&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;&lt;code&gt;Multiply(X,Y)&lt;/code&gt;&lt;/td&gt;&lt;td&gt;Returns &lt;code&gt;X*Y&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;&lt;code&gt;Divide(X,Y)&lt;/code&gt;&lt;/td&gt;&lt;td&gt;Returns &lt;code&gt;X/Y&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;&lt;code&gt;Mod(X,Y)&lt;/code&gt;&lt;/td&gt;&lt;td&gt;Returns &lt;code&gt;X%Y&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;&lt;code&gt;Negate(X)&lt;/code&gt;&lt;/td&gt;&lt;td&gt;Returns &lt;code&gt;-X&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;th colspan=&quot;2&quot;&gt;Boolean functions&lt;/th&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;&lt;code&gt;And(X,Y)&lt;/code&gt;&lt;/td&gt;&lt;td&gt;Returns &lt;code&gt;X&amp;&amp;Y&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;&lt;code&gt;Or(X,Y)&lt;/code&gt;&lt;/td&gt;&lt;td&gt;Returns &lt;code&gt;X||Y&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;&lt;code&gt;Not(X)&lt;/code&gt;&lt;/td&gt;&lt;td&gt;Returns &lt;code&gt;!X&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;&lt;code&gt;GE(X,Y) or X &gt;= Y&lt;/code&gt;&lt;/td&gt;&lt;td&gt;Returns &lt;code&gt;X &gt;= Y&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;&lt;code&gt;GT(X,Y) or X &gt; Y&lt;/code&gt;&lt;/td&gt;&lt;td&gt;Returns &lt;code&gt;X &gt; Y&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;&lt;code&gt;LE(X,Y) or X &lt;= Y&lt;/code&gt;&lt;/td&gt;&lt;td&gt;Returns &lt;code&gt;X &lt;= Y&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;&lt;code&gt;LT(X,Y) or X &lt; Y&lt;/code&gt;&lt;/td&gt;&lt;td&gt;Returns &lt;code&gt;X &lt; Y&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;&lt;code&gt;EQ(X,Y) or X == Y&lt;/code&gt;&lt;/td&gt;&lt;td&gt;Returns &lt;code&gt;X == Y&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;&lt;code&gt;NE(X,Y) or X != Y&lt;/code&gt;&lt;/td&gt;&lt;td&gt;Returns &lt;code&gt;X != Y&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;
 * &lt;/p&gt;
 *
 * @author Angel Chang
 */
public class Expressions  {

  /** A logger for this class */
<span class="fc" id="L107">  private static Redwood.RedwoodChannels log = Redwood.channels(Expressions.class);</span>

  /** VAR - Variable */
  public static final String TYPE_VAR = &quot;VAR&quot;;
  /** FUNCTION - (input) =&gt; (output) where input is a list of Values, and output is a single Value */
  public static final String TYPE_FUNCTION = &quot;FUNCTION&quot;;
  /** REGEX - Regular expression pattern (for tokens or string) */
  public static final String TYPE_REGEX = &quot;REGEX&quot;;
  public static final String TYPE_STRING_REGEX = &quot;STRING_REGEX&quot;;
  public static final String TYPE_TOKEN_REGEX = &quot;TOKEN_REGEX&quot;;
  /** REGEXMATCHVAR - Variable that refers to variable resulting from a regex match or used in a regex match (starts with $) */
  public static final String TYPE_REGEXMATCHVAR = &quot;REGEXMATCHVAR&quot;;
  /** STRING - String */
  public static final String TYPE_STRING = &quot;STRING&quot;;
  /** NUMBER - Numeric value (can be integer or real) */
  public static final String TYPE_NUMBER = &quot;NUMBER&quot;;
  /** COMPOSITE - Composite value with field names and field values */
  public static final String TYPE_COMPOSITE = &quot;COMPOSITE&quot;;
  /** LIST - List */
  public static final String TYPE_LIST = &quot;LIST&quot;;
  public static final String TYPE_SET = &quot;SET&quot;;
  public static final String TYPE_ANNOTATION_KEY = &quot;ANNOKEY&quot;;
  /** CLASS - Maps to a Java class */
  public static final String TYPE_CLASS = &quot;CLASS&quot;;
  public static final String TYPE_TOKENS = &quot;TOKENS&quot;;
  public static final String TYPE_BOOLEAN = &quot;BOOLEAN&quot;;

  public static final String VAR_SELF = &quot;_&quot;;

<span class="fc" id="L136">  public static final Value&lt;Boolean&gt; TRUE = new PrimitiveValue&lt;&gt;(Expressions.TYPE_BOOLEAN, true);</span>
<span class="fc" id="L137">  public static final Value&lt;Boolean&gt; FALSE = new PrimitiveValue&lt;&gt;(Expressions.TYPE_BOOLEAN, false);</span>
<span class="fc" id="L138">  public static final Value NIL = new PrimitiveValue(&quot;NIL&quot;, null);</span>

<span class="nc" id="L140">  private Expressions() { } // static methods and classes</span>

  public static Boolean convertValueToBoolean(Value v, boolean keepNull) {
<span class="nc" id="L143">    Boolean res = null;</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">    if (v != null) {</span>
<span class="nc" id="L145">      Object obj = v.get();</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">      if (obj != null) {</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">        if (obj instanceof Boolean) {</span>
<span class="nc" id="L148">          res = ((Boolean) obj).booleanValue();</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">        } else if (obj instanceof Integer) {</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">          res = (((Integer) obj).intValue() != 0);</span>
        } else {
<span class="nc" id="L152">          res = true;</span>
        }
<span class="nc" id="L154">        return res;</span>
      }
    }
<span class="nc bnc" id="L157" title="All 2 branches missed.">    return (keepNull)? res:false;</span>
  }

  public static Value&lt;Boolean&gt; convertValueToBooleanValue(Value v, boolean keepNull) {
<span class="nc bnc" id="L161" title="All 2 branches missed.">    if (v != null) {</span>
<span class="nc" id="L162">      Object obj = v.get();</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">      if (obj instanceof Boolean) {</span>
<span class="nc" id="L164">        return (Value&lt;Boolean&gt;) v;</span>
      } else {
<span class="nc" id="L166">        return new PrimitiveValue&lt;&gt;(Expressions.TYPE_BOOLEAN, convertValueToBoolean(v, keepNull));</span>
      }
    } else {
<span class="nc bnc" id="L169" title="All 2 branches missed.">      return keepNull? null:FALSE;</span>
    }
  }

  public static &lt;C&gt; C asObject(Env env, Object v) {
<span class="nc bnc" id="L174" title="All 2 branches missed.">    if (v instanceof Expression) {</span>
<span class="nc" id="L175">      return (C) ((Expression) v).evaluate(env).get();</span>
    } else {
<span class="nc" id="L177">      return (C) v;</span>
    }
  }

  public static Expression asExpression(Env env, Object v) {
<span class="nc bnc" id="L182" title="All 2 branches missed.">    if (v instanceof Expression) {</span>
<span class="nc" id="L183">      return (Expression) v;</span>
    } else {
<span class="nc" id="L185">      return createValue(null, v);</span>
    }
  }

  public static Value asValue(Env env, Object v) {
<span class="nc bnc" id="L190" title="All 2 branches missed.">    if (v instanceof Value) {</span>
<span class="nc" id="L191">      return (Value) v;</span>
    } else {
<span class="nc" id="L193">      return createValue(null, v);</span>
    }
  }

  public static &lt;T&gt; Value createValue(String typename, T value, String... tags) {
<span class="nc bnc" id="L198" title="All 2 branches missed.">    if (value instanceof Value) {</span>
<span class="nc" id="L199">      return (Value) value;</span>
    } else {
<span class="nc bnc" id="L201" title="All 4 branches missed.">      if (typename == null &amp;&amp; value != null) {</span>
        // TODO: Check for simpler typename provided by value
<span class="nc" id="L203">        typename = value.getClass().getName();</span>
      }
<span class="nc" id="L205">      return new PrimitiveValue&lt;&gt;(typename, value, tags);</span>
    }
  }

  /**
   * An expression that is a wrapper around another expression.
   */
<span class="nc" id="L212">  public abstract static class WrappedExpression implements Expression {</span>

    protected Expression expr;

    @Override
    public Tags getTags() {
<span class="nc" id="L218">      return expr.getTags();</span>
    }

    @Override
    public void setTags(Tags tags) {
<span class="nc" id="L223">      expr.setTags(tags);</span>
<span class="nc" id="L224">    }</span>

    @Override
    public String getType() {
<span class="nc" id="L228">      return expr.getType();</span>
    }

    @Override
    public Expression simplify(Env env) {
<span class="nc" id="L233">      return expr.simplify(env);</span>
    }

    @Override
    public boolean hasValue() {
<span class="nc" id="L238">      return expr.hasValue();</span>
    }

    @Override
    public Value evaluate(Env env, Object... args) {
<span class="nc" id="L243">      return expr.evaluate(env, args);</span>
    }

    @Override
    public boolean equals(Object o) {
<span class="nc bnc" id="L248" title="All 2 branches missed.">      if (this == o) return true;</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">      if (!(o instanceof WrappedExpression)) return false;</span>

<span class="nc" id="L251">      WrappedExpression that = (WrappedExpression) o;</span>

<span class="nc bnc" id="L253" title="All 6 branches missed.">      if (expr != null ? !expr.equals(that.expr) : that.expr != null) return false;</span>

<span class="nc" id="L255">      return true;</span>
    }

    @Override
    public int hashCode() {
<span class="nc bnc" id="L260" title="All 2 branches missed.">      return expr != null ? expr.hashCode() : 0;</span>
    }

  }

  /**
  * An expression with a typename and tags.
  */
  public abstract static class TypedExpression implements Expression, Serializable {
    String typename;
    Tags tags;

<span class="fc" id="L272">    public TypedExpression(String typename, String... tags) {</span>
<span class="fc" id="L273">      this.typename = typename;</span>
<span class="pc bpc" id="L274" title="1 of 2 branches missed.">      if (tags != null) {</span>
<span class="fc" id="L275">        this.tags = new Tags(tags);</span>
      }
<span class="fc" id="L277">    }</span>

    public Tags getTags() {
<span class="nc" id="L280">      return tags;</span>
    }

    public void setTags(Tags tags) {
<span class="nc" id="L284">      this.tags = tags;</span>
<span class="nc" id="L285">    }</span>

    public String getType() {
<span class="nc" id="L288">      return typename;</span>
    }

    public Expression simplify(Env env) {
<span class="nc" id="L292">      return this;</span>
    }

    public boolean hasValue() {
<span class="nc" id="L296">      return false;</span>
    }

    private static final long serialVersionUID = 2;

    @Override
    public boolean equals(Object o) {
<span class="nc bnc" id="L303" title="All 2 branches missed.">      if (this == o) return true;</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">      if (!(o instanceof TypedExpression)) return false;</span>

<span class="nc" id="L306">      TypedExpression that = (TypedExpression) o;</span>

<span class="nc bnc" id="L308" title="All 6 branches missed.">      if (tags != null ? !tags.equals(that.tags) : that.tags != null) return false;</span>
<span class="nc bnc" id="L309" title="All 6 branches missed.">      if (typename != null ? !typename.equals(that.typename) : that.typename != null) return false;</span>

<span class="nc" id="L311">      return true;</span>
    }

    @Override
    public int hashCode() {
<span class="nc bnc" id="L316" title="All 2 branches missed.">      int result = typename != null ? typename.hashCode() : 0;</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">      result = 31 * result + (tags != null ? tags.hashCode() : 0);</span>
<span class="nc" id="L318">      return result;</span>
    }
  }

  /**
   * A simple implementation of an expression that is represented by a java object of type T
   * @param &lt;T&gt; type of the expression object
   */
  public abstract static class SimpleExpression&lt;T&gt; extends Expressions.TypedExpression {
    T value;

    protected SimpleExpression(String typename, T value, String... tags) {
<span class="nc" id="L330">      super(typename, tags);</span>
<span class="nc" id="L331">      this.value = value;</span>
<span class="nc" id="L332">    }</span>

    public T get() {
<span class="nc" id="L335">      return value;</span>
    }

    public String toString() {
<span class="nc" id="L339">      return getType() + &quot;(&quot; + value + &quot;)&quot;;</span>
    }

    @Override
    public boolean equals(Object o) {
<span class="nc bnc" id="L344" title="All 2 branches missed.">      if (this == o) return true;</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">      if (!(o instanceof SimpleExpression)) return false;</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">      if (!super.equals(o)) return false;</span>

<span class="nc" id="L348">      SimpleExpression that = (SimpleExpression) o;</span>

<span class="nc bnc" id="L350" title="All 6 branches missed.">      if (value != null ? !value.equals(that.value) : that.value != null) return false;</span>

<span class="nc" id="L352">      return true;</span>
    }

    @Override
    public int hashCode() {
<span class="nc" id="L357">      int result = super.hashCode();</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">      result = 31 * result + (value != null ? value.hashCode() : 0);</span>
<span class="nc" id="L359">      return result;</span>
    }
  }

  /**
   * A simple implementation of an expression that is represented by a java object of type T
   *    and which also has a cached Value stored with it
   * @param &lt;T&gt; type of the expression object
   */
  public static class SimpleCachedExpression&lt;T&gt; extends SimpleExpression&lt;T&gt; {
    Value evaluated;
<span class="nc" id="L370">    boolean disableCaching = false;</span>

    protected SimpleCachedExpression(String typename, T value, String... tags) {
<span class="nc" id="L373">      super(typename, value, tags);</span>
<span class="nc" id="L374">    }</span>

    protected Value doEvaluation(Env env, Object... args) {
<span class="nc" id="L377">      throw new UnsupportedOperationException(&quot;Cannot evaluate type: &quot; + typename);</span>
    }

    public Value evaluate(Env env, Object... args) {
<span class="nc bnc" id="L381" title="All 2 branches missed.">      if (args != null) {</span>
<span class="nc" id="L382">        return doEvaluation(env, args);</span>
      }
<span class="nc bnc" id="L384" title="All 4 branches missed.">      if (evaluated == null || disableCaching) {</span>
<span class="nc" id="L385">        evaluated = doEvaluation(env, args);</span>
      }
<span class="nc" id="L387">      return evaluated;</span>
    }

    public boolean hasValue() {
<span class="nc bnc" id="L391" title="All 2 branches missed.">      return (evaluated != null);</span>
    }

    @Override
    public boolean equals(Object o) {
<span class="nc bnc" id="L396" title="All 2 branches missed.">      if (this == o) return true;</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">      if (!(o instanceof SimpleCachedExpression)) return false;</span>

<span class="nc" id="L399">      SimpleCachedExpression that = (SimpleCachedExpression) o;</span>

<span class="nc bnc" id="L401" title="All 2 branches missed.">      if (disableCaching != that.disableCaching) return false;</span>
<span class="nc bnc" id="L402" title="All 6 branches missed.">      if (evaluated != null ? !evaluated.equals(that.evaluated) : that.evaluated != null) return false;</span>

<span class="nc" id="L404">      return true;</span>
    }

    @Override
    public int hashCode() {
<span class="nc bnc" id="L409" title="All 2 branches missed.">      int result = evaluated != null ? evaluated.hashCode() : 0;</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">      result = 31 * result + (disableCaching ? 1 : 0);</span>
<span class="nc" id="L411">      return result;</span>
    }
  }

  /**
   * Simple implementation of Value backed by a java object of type T
   * @param &lt;T&gt;
   */
  public static class SimpleValue&lt;T&gt; extends Expressions.TypedExpression implements Value&lt;T&gt; {
    T value;

    protected SimpleValue(String typename, T value, String... tags) {
<span class="fc" id="L423">      super(typename, tags);</span>
<span class="fc" id="L424">      this.value = value;</span>
<span class="fc" id="L425">    }</span>

    public T get() {
<span class="nc" id="L428">      return value;</span>
    }

    public Value evaluate(Env env, Object... args) {
<span class="nc" id="L432">      return this;</span>
    }

    public String toString() {
<span class="nc" id="L436">      return getType() + &quot;(&quot; + value + &quot;)&quot;;</span>
    }

    public boolean hasValue() {
<span class="nc" id="L440">      return true;</span>
    }

    @Override
    public boolean equals(Object o) {
<span class="pc bpc" id="L445" title="1 of 2 branches missed.">      if (this == o) return true;</span>
<span class="pc bpc" id="L446" title="1 of 2 branches missed.">      if (!(o instanceof SimpleValue)) return false;</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">      if (!super.equals(o)) return false;</span>

<span class="nc" id="L449">      SimpleValue that = (SimpleValue) o;</span>

<span class="nc bnc" id="L451" title="All 6 branches missed.">      if (value != null ? !value.equals(that.value) : that.value != null) return false;</span>

<span class="nc" id="L453">      return true;</span>
    }

    @Override
    public int hashCode() {
<span class="nc" id="L458">      int result = super.hashCode();</span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">      result = 31 * result + (value != null ? value.hashCode() : 0);</span>
<span class="nc" id="L460">      return result;</span>
    }
  }

  /**
   * A string that represents a regular expression
   */
  public static class RegexValue extends SimpleValue&lt;String&gt; {
    public RegexValue(String regex, String... tags) {
<span class="nc" id="L469">      super(TYPE_REGEX, regex, tags);</span>
<span class="nc" id="L470">    }</span>
  }


  /**
   * A variable assignment with the name of the variable, and the expression to assign to that variable
   */
  public static class VarAssignmentExpression extends Expressions.TypedExpression {

    final String varName;
    final Expression valueExpr;
    final boolean bindAsValue;

    public VarAssignmentExpression(String varName, Expression valueExpr, boolean bindAsValue) {
<span class="nc" id="L484">      super(&quot;VAR_ASSIGNMENT&quot;);</span>
<span class="nc" id="L485">      this.varName = varName;</span>
<span class="nc" id="L486">      this.valueExpr = valueExpr;</span>
<span class="nc" id="L487">      this.bindAsValue = bindAsValue;</span>
<span class="nc" id="L488">    }</span>
    public Value evaluate(Env env, Object... args) {
<span class="nc" id="L490">      Value value = valueExpr.evaluate(env, args);</span>
<span class="nc bnc" id="L491" title="All 2 branches missed.">      if (args != null) {</span>
<span class="nc bnc" id="L492" title="All 4 branches missed.">        if (args.length == 1 &amp;&amp; args[0] instanceof CoreMap) {</span>
<span class="nc" id="L493">          CoreMap cm = (CoreMap) args[0];</span>
<span class="nc" id="L494">          Class annotationKey = EnvLookup.lookupAnnotationKey(env, varName);</span>
<span class="nc bnc" id="L495" title="All 2 branches missed.">          if (annotationKey != null) {</span>
<span class="nc bnc" id="L496" title="All 2 branches missed.">            cm.set(annotationKey, (value != null)? value.get():null);</span>
<span class="nc" id="L497">            return value;</span>
          }
        }
      }
<span class="nc bnc" id="L501" title="All 2 branches missed.">      if (bindAsValue) {</span>
<span class="nc" id="L502">        env.bind(varName, value);</span>
      } else {
<span class="nc bnc" id="L504" title="All 2 branches missed.">        env.bind(varName, (value != null)? value.get():null);</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">        if (TYPE_REGEX == value.getType()) {</span>
          try {
<span class="nc" id="L507">            Object vobj = value.get();</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">            if (vobj instanceof String) {</span>
<span class="nc" id="L509">              env.bindStringRegex(varName, (String) vobj);</span>
<span class="nc bnc" id="L510" title="All 2 branches missed.">            } else if (vobj instanceof Pattern) {</span>
<span class="nc" id="L511">              env.bindStringRegex(varName, ((Pattern) vobj).pattern());</span>
            }
<span class="nc" id="L513">          } catch (Exception ex) {}</span>
        }
      }
<span class="nc" id="L516">      return value;</span>
    }

    @Override
    public boolean equals(Object o) {
<span class="nc bnc" id="L521" title="All 2 branches missed.">      if (this == o) return true;</span>
<span class="nc bnc" id="L522" title="All 2 branches missed.">      if (!(o instanceof VarAssignmentExpression)) return false;</span>
<span class="nc bnc" id="L523" title="All 2 branches missed.">      if (!super.equals(o)) return false;</span>

<span class="nc" id="L525">      VarAssignmentExpression that = (VarAssignmentExpression) o;</span>

<span class="nc bnc" id="L527" title="All 2 branches missed.">      if (bindAsValue != that.bindAsValue) return false;</span>
<span class="nc bnc" id="L528" title="All 6 branches missed.">      if (valueExpr != null ? !valueExpr.equals(that.valueExpr) : that.valueExpr != null) return false;</span>
<span class="nc bnc" id="L529" title="All 6 branches missed.">      if (varName != null ? !varName.equals(that.varName) : that.varName != null) return false;</span>

<span class="nc" id="L531">      return true;</span>
    }

    @Override
    public int hashCode() {
<span class="nc" id="L536">      int result = super.hashCode();</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">      result = 31 * result + (varName != null ? varName.hashCode() : 0);</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">      result = 31 * result + (valueExpr != null ? valueExpr.hashCode() : 0);</span>
<span class="nc bnc" id="L539" title="All 2 branches missed.">      result = 31 * result + (bindAsValue ? 1 : 0);</span>
<span class="nc" id="L540">      return result;</span>
    }
  } // end class VarAssignmentExpression


  /**
   * A variable, which can be assigned any expression.
   * When evaluated, the value of the variable is retrieved from the
   *   environment, evaluated, and returned.
   */
  public static class VarExpression extends SimpleExpression&lt;String&gt; implements AssignableExpression  {

    public VarExpression(String varname, String... tags) {
<span class="nc" id="L553">      super(TYPE_VAR, varname, tags);</span>
<span class="nc" id="L554">    }</span>

    @Override
    public Value evaluate(Env env, Object... args) {
<span class="nc" id="L558">      Expression exp = null;</span>
<span class="nc" id="L559">      String varName = value;</span>
<span class="nc bnc" id="L560" title="All 2 branches missed.">      if (args != null) {</span>
<span class="nc bnc" id="L561" title="All 4 branches missed.">        if (args.length == 1 &amp;&amp; args[0] instanceof CoreMap) {</span>
<span class="nc" id="L562">          CoreMap cm = (CoreMap) args[0];</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">          if (VAR_SELF.equals(varName))  {</span>
<span class="nc" id="L564">            return createValue(varName, cm);</span>
          }
<span class="nc" id="L566">          Class annotationKey = EnvLookup.lookupAnnotationKey(env, varName);</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">          if (annotationKey != null) {</span>
<span class="nc" id="L568">            return createValue(varName, cm.get(annotationKey));</span>
          }
        }
      }
<span class="nc bnc" id="L572" title="All 2 branches missed.">      if (VAR_SELF.equals(varName))  {</span>
<span class="nc" id="L573">        return createValue(varName, env.peek(varName));</span>
      }
<span class="nc" id="L575">      Object obj = env.get(varName);</span>
<span class="nc bnc" id="L576" title="All 2 branches missed.">      if (obj != null) {</span>
<span class="nc" id="L577">        exp = asExpression(env, obj);</span>
      }
<span class="nc bnc" id="L579" title="All 2 branches missed.">      Value v = exp != null? exp.evaluate(env, args): null;</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">      if (v == null) {</span>
<span class="nc" id="L581">        log.info(&quot;Unknown variable: &quot; + varName);</span>
      }
<span class="nc" id="L583">      return v;</span>
    }
    public Expression assign(Expression expr) {
<span class="nc" id="L586">      return new VarAssignmentExpression(value, expr, true);</span>
    }
  }

  /**
   * A variable that represents a regular expression match result.
   * The match result is identified either by the group id (Integer) or
   *   the group name (String).
   * When evaluated, one argument (the MatchResult or SequenceMatchResult) must be supplied.
   * Depending on the match result supplied, the returned value
   *   is either a String (for MatchResult) or a list of tokens (for SequenceMatchResult).
   */
<span class="fc" id="L598">  private static final Pattern DIGITS_PATTERN = Pattern.compile(&quot;\\d+&quot;);</span>
  public static class RegexMatchVarExpression extends SimpleExpression implements AssignableExpression {
    public RegexMatchVarExpression(String groupname, String... tags) {
<span class="nc" id="L601">      super(TYPE_REGEXMATCHVAR, groupname, tags);</span>
<span class="nc" id="L602">    }</span>
    public RegexMatchVarExpression(Integer groupid, String... tags) {
<span class="nc" id="L604">      super(TYPE_REGEXMATCHVAR, groupid, tags);</span>
<span class="nc" id="L605">    }</span>
    public static RegexMatchVarExpression valueOf(String group) {
<span class="nc bnc" id="L607" title="All 2 branches missed.">      if (DIGITS_PATTERN.matcher(group).matches()) {</span>
<span class="nc" id="L608">        Integer n = Integer.valueOf(group);</span>
<span class="nc" id="L609">        return new RegexMatchVarExpression(n);</span>
      } else {
<span class="nc" id="L611">        return new RegexMatchVarExpression(group);</span>
      }
    }
    public Value evaluate(Env env, Object... args) {
<span class="nc bnc" id="L615" title="All 4 branches missed.">      if (args != null &amp;&amp; args.length &gt; 0) {</span>
<span class="nc bnc" id="L616" title="All 2 branches missed.">        if (args[0] instanceof SequenceMatchResult) {</span>
<span class="nc" id="L617">          SequenceMatchResult mr = (SequenceMatchResult) args[0];</span>
<span class="nc" id="L618">          Object v = get();</span>
<span class="nc bnc" id="L619" title="All 2 branches missed.">          if (v instanceof String) {</span>
            // TODO: depending if TYPE_STRING, use string version...
<span class="nc" id="L621">            return new PrimitiveValue&lt;&gt;(TYPE_TOKENS, mr.groupNodes((String) v));</span>
<span class="nc bnc" id="L622" title="All 2 branches missed.">          } else if (v instanceof Integer) {</span>
<span class="nc" id="L623">            return new PrimitiveValue&lt;&gt;(TYPE_TOKENS, mr.groupNodes((Integer) v));</span>
          } else {
<span class="nc" id="L625">            throw new UnsupportedOperationException(&quot;String match result must be referred to by group id&quot;);</span>
          }
<span class="nc bnc" id="L627" title="All 2 branches missed.">        } else if (args[0] instanceof MatchResult) {</span>
<span class="nc" id="L628">          MatchResult mr = (MatchResult) args[0];</span>
<span class="nc" id="L629">          Object v = get();</span>
<span class="nc bnc" id="L630" title="All 2 branches missed.">          if (v instanceof Integer) {</span>
<span class="nc" id="L631">            String str = mr.group((Integer) get());</span>
<span class="nc" id="L632">            return new PrimitiveValue&lt;&gt;(TYPE_STRING, str);</span>
          } else {
<span class="nc" id="L634">            throw new UnsupportedOperationException(&quot;String match result must be referred to by group id&quot;);</span>
          }
        }
      }
<span class="nc" id="L638">      return null;</span>
    }
    public Expression assign(Expression expr) {
<span class="nc" id="L641">      return new VarAssignmentExpression(value.toString(), expr, false);</span>
    }
  }

  public static class RegexMatchResultVarExpression extends SimpleExpression {
    public RegexMatchResultVarExpression(String groupname, String... tags) {
<span class="nc" id="L647">      super(TYPE_REGEXMATCHVAR, groupname, tags);</span>
<span class="nc" id="L648">    }</span>
    public RegexMatchResultVarExpression(Integer groupid, String... tags) {
<span class="nc" id="L650">      super(TYPE_REGEXMATCHVAR, groupid, tags);</span>
<span class="nc" id="L651">    }</span>
    public static RegexMatchResultVarExpression valueOf(String group) {
<span class="nc bnc" id="L653" title="All 2 branches missed.">      if (DIGITS_PATTERN.matcher(group).matches()) {</span>
<span class="nc" id="L654">        Integer n = Integer.valueOf(group);</span>
<span class="nc" id="L655">        return new RegexMatchResultVarExpression(n);</span>
      } else {
<span class="nc" id="L657">        return new RegexMatchResultVarExpression(group);</span>
      }
    }
    public Value evaluate(Env env, Object... args) {
<span class="nc bnc" id="L661" title="All 4 branches missed.">      if (args != null &amp;&amp; args.length &gt; 0) {</span>
<span class="nc bnc" id="L662" title="All 2 branches missed.">        if (args[0] instanceof SequenceMatchResult) {</span>
<span class="nc" id="L663">          SequenceMatchResult mr = (SequenceMatchResult) args[0];</span>
<span class="nc" id="L664">          Object v = get();</span>
<span class="nc bnc" id="L665" title="All 2 branches missed.">          if (v instanceof String) {</span>
<span class="nc" id="L666">            return new PrimitiveValue(&quot;MATCHED_GROUP_INFO&quot;, mr.groupInfo((String) v));</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">          } else if (v instanceof Integer) {</span>
<span class="nc" id="L668">            return new PrimitiveValue(&quot;MATCHED_GROUP_INFO&quot;, mr.groupInfo((Integer) v));</span>
          } else {
<span class="nc" id="L670">            throw new UnsupportedOperationException(&quot;String match result must be referred to by group id&quot;);</span>
          }
        }
      }
<span class="nc" id="L674">      return null;</span>
    }
  }

  /**
   * A function call that can be assigned a value.
   */
  public static class AssignableFunctionCallExpression extends FunctionCallExpression implements AssignableExpression {
    public AssignableFunctionCallExpression(String function, List&lt;Expression&gt; params, String... tags) {
<span class="nc" id="L683">      super(function, params, tags);</span>
<span class="nc" id="L684">    }</span>

    public Expression assign(Expression expr) {
<span class="nc" id="L687">      List&lt;Expression&gt; newParams = new ArrayList&lt;&gt;(params);</span>
<span class="nc" id="L688">      newParams.add(expr);</span>
<span class="nc" id="L689">      Expression res = new FunctionCallExpression(function, newParams);</span>
<span class="nc" id="L690">      res.setTags(tags);</span>
<span class="nc" id="L691">      return res;</span>
    }
  }

  public static class IndexedExpression extends AssignableFunctionCallExpression {
    public IndexedExpression(Expression expr, int index) {
<span class="nc" id="L697">      super(&quot;ListSelect&quot;, Arrays.asList(expr, new PrimitiveValue(&quot;Integer&quot;, index)));</span>
<span class="nc" id="L698">    }</span>
  }

  public static class FieldExpression extends AssignableFunctionCallExpression {
    public FieldExpression(Expression expr, String field) {
<span class="nc" id="L703">      super(&quot;Select&quot;, Arrays.asList(expr, new PrimitiveValue(TYPE_STRING, field)));</span>
<span class="nc" id="L704">    }</span>
    public FieldExpression(Expression expr, Expression field) {
<span class="nc" id="L706">      super(&quot;Select&quot;, Arrays.asList(expr, field));</span>
<span class="nc" id="L707">    }</span>
  }

  public static class OrExpression extends FunctionCallExpression {
    public OrExpression(List&lt;Expression&gt; children) {
<span class="nc" id="L712">      super(&quot;Or&quot;, children);</span>
<span class="nc" id="L713">    }</span>
  }

  public static class AndExpression extends FunctionCallExpression {
    public AndExpression(List&lt;Expression&gt; children) {
<span class="nc" id="L718">      super(&quot;And&quot;, children);</span>
<span class="nc" id="L719">    }</span>
  }

  public static class NotExpression extends FunctionCallExpression {
    public NotExpression(Expression expr) {
<span class="nc" id="L724">      super(&quot;Not&quot;, Arrays.asList(expr));</span>
<span class="nc" id="L725">    }</span>
  }

  public static class IfExpression extends Expressions.TypedExpression {
    Expression condExpr;
    Expression trueExpr;
    Expression falseExpr;

    public IfExpression(Expression cond, Expression vt, Expression vf) {
<span class="nc" id="L734">      super(&quot;If&quot;);</span>
<span class="nc" id="L735">      this.condExpr = cond;</span>
<span class="nc" id="L736">      this.trueExpr = vt;</span>
<span class="nc" id="L737">      this.falseExpr = vf;</span>
<span class="nc" id="L738">    }</span>

    public Value evaluate(Env env, Object... args) {
<span class="nc" id="L741">      Value condValue = condExpr.evaluate(env, args);</span>
<span class="nc" id="L742">      Boolean cond = (Boolean) condValue.get();</span>
<span class="nc bnc" id="L743" title="All 2 branches missed.">      if (cond) {</span>
<span class="nc" id="L744">        return trueExpr.evaluate(env, args);</span>
      } else {
<span class="nc" id="L746">        return falseExpr.evaluate(env, args);</span>
      }
    }
  }

  public static class CaseExpression extends Expressions.WrappedExpression {
<span class="nc" id="L752">    public CaseExpression(List&lt;Pair&lt;Expression,Expression&gt;&gt; conds, Expression elseExpr) {</span>
<span class="nc bnc" id="L753" title="All 2 branches missed.">      if (conds.size() == 0) {</span>
<span class="nc" id="L754">        throw new IllegalArgumentException(&quot;No conditions!&quot;);</span>
      } else {
<span class="nc" id="L756">        expr = elseExpr;</span>
<span class="nc bnc" id="L757" title="All 2 branches missed.">        for (int i = conds.size()-1; i&gt;=0; i--) {</span>
<span class="nc" id="L758">          Pair&lt;Expression,Expression&gt; p = conds.get(i);</span>
<span class="nc" id="L759">          expr = new IfExpression(p.first(), p.second(), expr);</span>
        }
      }
<span class="nc" id="L762">    }</span>
  }


  public static class ConditionalExpression extends Expressions.WrappedExpression {

<span class="nc" id="L768">    public ConditionalExpression(Expression expr) {</span>
<span class="nc" id="L769">      this.expr = expr;</span>
<span class="nc" id="L770">    }</span>

<span class="nc" id="L772">    public ConditionalExpression(String op, Expression expr1, Expression expr2) {</span>
<span class="nc bnc" id="L773" title="All 34 branches missed.">      switch (op) {</span>
        case &quot;&gt;=&quot;:
<span class="nc" id="L775">          expr = new FunctionCallExpression(&quot;GE&quot;, Arrays.asList(expr1, expr2));</span>
<span class="nc" id="L776">          break;</span>
        case &quot;&lt;=&quot;:
<span class="nc" id="L778">          expr = new FunctionCallExpression(&quot;LE&quot;, Arrays.asList(expr1, expr2));</span>
<span class="nc" id="L779">          break;</span>
        case &quot;&gt;&quot;:
<span class="nc" id="L781">          expr = new FunctionCallExpression(&quot;GT&quot;, Arrays.asList(expr1, expr2));</span>
<span class="nc" id="L782">          break;</span>
        case &quot;&lt;&quot;:
<span class="nc" id="L784">          expr = new FunctionCallExpression(&quot;LT&quot;, Arrays.asList(expr1, expr2));</span>
<span class="nc" id="L785">          break;</span>
        case &quot;==&quot;:
<span class="nc" id="L787">          expr = new FunctionCallExpression(&quot;EQ&quot;, Arrays.asList(expr1, expr2));</span>
<span class="nc" id="L788">          break;</span>
        case &quot;!=&quot;:
<span class="nc" id="L790">          expr = new FunctionCallExpression(&quot;NE&quot;, Arrays.asList(expr1, expr2));</span>
<span class="nc" id="L791">          break;</span>
        case &quot;=~&quot;:
<span class="nc" id="L793">          expr = new FunctionCallExpression(&quot;Match&quot;, Arrays.asList(expr1, expr2));</span>
<span class="nc" id="L794">          break;</span>
        case &quot;!~&quot;:
<span class="nc" id="L796">          expr = new NotExpression(new FunctionCallExpression(&quot;Match&quot;, Arrays.asList(expr1, expr2)));</span>
          break;
      }
<span class="nc" id="L799">    }</span>

    @Override
    public String getType() {
<span class="nc" id="L803">      return Expressions.TYPE_BOOLEAN;</span>
    }

    @Override
    public Expression simplify(Env env) {
<span class="nc" id="L808">      return this;</span>
    }

    @Override
    public Value evaluate(Env env, Object... args) {
<span class="nc" id="L813">      Value v = expr.evaluate(env, args);</span>
<span class="nc" id="L814">      return convertValueToBooleanValue(v, false);</span>
    }

  }

  public static class ListExpression extends TypedExpression {

    List&lt;Expression&gt; exprs;

    public ListExpression(String typename, String... tags) {
<span class="nc" id="L824">      super(typename, tags);</span>
<span class="nc" id="L825">      this.exprs = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L826">    }</span>

    public ListExpression(String typename, List&lt;Expression&gt; exprs, String... tags) {
<span class="nc" id="L829">      super(typename, tags);</span>
<span class="nc" id="L830">      this.exprs = new ArrayList&lt;&gt;(exprs);</span>
<span class="nc" id="L831">    }</span>

    public void addAll(List&lt;Expression&gt; exprs) {
<span class="nc bnc" id="L834" title="All 2 branches missed.">      if (exprs != null) {</span>
<span class="nc" id="L835">        this.exprs.addAll(exprs);</span>
      }
<span class="nc" id="L837">    }</span>

    public void add(Expression expr) {
<span class="nc" id="L840">      this.exprs.add(expr);</span>
<span class="nc" id="L841">    }</span>

    public Value evaluate(Env env, Object... args) {
<span class="nc" id="L844">      List&lt;Value&gt; values = new ArrayList&lt;&gt;(exprs.size());</span>
<span class="nc bnc" id="L845" title="All 2 branches missed.">      for (Expression s:exprs) {</span>
<span class="nc" id="L846">        values.add(s.evaluate(env, args));</span>
<span class="nc" id="L847">      };</span>
<span class="nc" id="L848">      return new PrimitiveValue&lt;&gt;(typename, values);</span>
    }
  }

  private static final boolean isArgTypesCompatible(Class[] paramTypes, Class[] targetParamTypes)
  {
<span class="nc" id="L854">    boolean compatible = true;</span>
<span class="nc bnc" id="L855" title="All 2 branches missed.">    if (targetParamTypes.length == paramTypes.length) {</span>
<span class="nc bnc" id="L856" title="All 2 branches missed.">      for (int i = 0; i &lt; targetParamTypes.length; i++) {</span>
<span class="nc bnc" id="L857" title="All 2 branches missed.">        if (targetParamTypes[i].isPrimitive()) {</span>
<span class="nc" id="L858">          compatible = false;</span>
<span class="nc bnc" id="L859" title="All 2 branches missed.">          if (paramTypes[i] != null) {</span>
            try {
<span class="nc" id="L861">              Class&lt;?&gt; type = (Class&lt;?&gt;) paramTypes[i].getField(&quot;TYPE&quot;).get(null);</span>
<span class="nc bnc" id="L862" title="All 2 branches missed.">              if (type.equals(targetParamTypes[i])) { compatible = true; }</span>
<span class="nc" id="L863">            } catch (NoSuchFieldException ex2) {</span>
<span class="nc" id="L864">            } catch (IllegalAccessException ex2) {</span>
<span class="nc" id="L865">            }</span>
          }
<span class="nc bnc" id="L867" title="All 2 branches missed.">          if (!compatible) break;</span>
        } else {
<span class="nc bnc" id="L869" title="All 4 branches missed.">          if (paramTypes[i] != null &amp;&amp; !targetParamTypes[i].isAssignableFrom(paramTypes[i])) {</span>
<span class="nc" id="L870">            compatible = false;</span>
<span class="nc" id="L871">            break;</span>
          }
        }
      }
    } else {
<span class="nc" id="L876">      compatible = false;</span>
    }
<span class="nc" id="L878">    return compatible;</span>
  }


<span class="fc" id="L882">  protected static final String NEWLINE = System.getProperty(&quot;line.separator&quot;);</span>

  public static class FunctionCallExpression extends Expressions.TypedExpression {

    final String function;
    final List&lt;? extends Expression&gt; params;

    public FunctionCallExpression(String function, List&lt;? extends Expression&gt; params, String... tags) {
<span class="nc" id="L890">      super(TYPE_FUNCTION, tags);</span>
<span class="nc" id="L891">      this.function = function;</span>
<span class="nc" id="L892">      this.params = params;</span>
<span class="nc" id="L893">    }</span>

    public String toString() {
<span class="nc" id="L896">      return function + '(' + StringUtils.join(params, &quot;, &quot;) + ')';</span>
    }

    public Expression simplify(Env env)
    {
<span class="nc" id="L901">      boolean paramsAllHasValue = true;</span>
<span class="nc" id="L902">      List&lt;Expression&gt; simplifiedParams = new ArrayList&lt;&gt;(params.size());</span>
<span class="nc bnc" id="L903" title="All 2 branches missed.">      for (Expression param:params) {</span>
<span class="nc" id="L904">        Expression simplified = param.simplify(env);</span>
<span class="nc" id="L905">        simplifiedParams.add(simplified);</span>
<span class="nc bnc" id="L906" title="All 2 branches missed.">        if (!(simplified.hasValue())) {</span>
<span class="nc" id="L907">          paramsAllHasValue = false;</span>
        }
<span class="nc" id="L909">      }</span>
<span class="nc" id="L910">      Expression res = new FunctionCallExpression(function, simplifiedParams);</span>
<span class="nc bnc" id="L911" title="All 2 branches missed.">      if (paramsAllHasValue) {</span>
<span class="nc" id="L912">        return res.evaluate(env);</span>
      } else {
<span class="nc" id="L914">        return res;</span>
      }
    }

    public Value evaluate(Env env, Object... args) {
<span class="nc" id="L919">      Object funcValue = ValueFunctions.lookupFunctionObject(env, function);</span>
<span class="nc bnc" id="L920" title="All 2 branches missed.">      if (funcValue == null) {</span>
<span class="nc" id="L921">        throw new RuntimeException(&quot;Unknown function &quot; + function);</span>
      }
<span class="nc bnc" id="L923" title="All 2 branches missed.">      if (funcValue instanceof Value) {</span>
<span class="nc" id="L924">        funcValue = ((Value) funcValue).evaluate(env, args).get();</span>
      }
<span class="nc bnc" id="L926" title="All 2 branches missed.">      if (funcValue instanceof ValueFunction) {</span>
<span class="nc" id="L927">        ValueFunction f = (ValueFunction) funcValue;</span>
<span class="nc" id="L928">        List&lt;Value&gt; evaled = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L929" title="All 2 branches missed.">        for (Expression param:params) {</span>
<span class="nc" id="L930">          evaled.add(param.evaluate(env, args));</span>
<span class="nc" id="L931">        }</span>
<span class="nc" id="L932">        return f.apply(env, evaled);</span>
<span class="nc bnc" id="L933" title="All 2 branches missed.">      } else if (funcValue instanceof Collection) {</span>
<span class="nc" id="L934">        List&lt;Value&gt; evaled = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L935" title="All 2 branches missed.">        for (Expression param:params) {</span>
<span class="nc" id="L936">          evaled.add(param.evaluate(env, args));</span>
<span class="nc" id="L937">        }</span>
<span class="nc" id="L938">        Collection&lt;ValueFunction&gt; fs = (Collection&lt;ValueFunction&gt;) funcValue;</span>
<span class="nc bnc" id="L939" title="All 2 branches missed.">        for (ValueFunction f:fs) {</span>
<span class="nc bnc" id="L940" title="All 2 branches missed.">          if (f.checkArgs(evaled)) {</span>
<span class="nc" id="L941">            return f.apply(env, evaled);</span>
          }
<span class="nc" id="L943">        }</span>
<span class="nc" id="L944">        StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L945">        sb.append(&quot;Cannot find function matching args: &quot; + function + NEWLINE);</span>
<span class="nc" id="L946">        sb.append(&quot;Args are: &quot; + StringUtils.join(evaled, &quot;,&quot;) + NEWLINE);</span>
<span class="nc bnc" id="L947" title="All 2 branches missed.">        if (fs.size() &gt; 0) {</span>
<span class="nc" id="L948">          sb.append(&quot;Options are:\n&quot; + StringUtils.join(fs, NEWLINE));</span>
        } else {
<span class="nc" id="L950">          sb.append(&quot;No options&quot;);</span>
        }
<span class="nc" id="L952">        throw new RuntimeException(sb.toString());</span>
<span class="nc bnc" id="L953" title="All 2 branches missed.">      } else if (funcValue instanceof Class) {</span>
<span class="nc" id="L954">        Class c = (Class) funcValue;</span>
<span class="nc" id="L955">        List&lt;Value&gt; evaled = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L956" title="All 2 branches missed.">        for (Expression param:params) {</span>
<span class="nc" id="L957">          evaled.add(param.evaluate(env, args));</span>
<span class="nc" id="L958">        }</span>
<span class="nc" id="L959">        Class[] paramTypes = new Class[params.size()];</span>
<span class="nc" id="L960">        Object[] objs = new Object[params.size()];</span>
<span class="nc" id="L961">        boolean paramsNotNull = true;</span>
<span class="nc bnc" id="L962" title="All 2 branches missed.">        for (int i = 0; i &lt; params.size(); i++) {</span>
<span class="nc" id="L963">          Value v = evaled.get(i);</span>
<span class="nc bnc" id="L964" title="All 2 branches missed.">          if (v != null) {</span>
<span class="nc" id="L965">            objs[i] = v.get();</span>
<span class="nc bnc" id="L966" title="All 2 branches missed.">            if (objs[i] != null) {</span>
<span class="nc" id="L967">              paramTypes[i] = objs[i].getClass();</span>
            } else {
<span class="nc" id="L969">              paramTypes[i] = null;</span>
<span class="nc" id="L970">              paramsNotNull = false;</span>
            }
          } else {
<span class="nc" id="L973">            objs[i] = null;</span>
<span class="nc" id="L974">            paramTypes[i] = null;</span>
<span class="nc" id="L975">            paramsNotNull = false;</span>
            //throw new RuntimeException(&quot;Missing evaluated value for &quot; + params.get(i));
          }
        }
<span class="nc bnc" id="L979" title="All 2 branches missed.">        if (paramsNotNull) {</span>
<span class="nc" id="L980">          Object obj = MetaClass.create(c).createInstance(objs);</span>
<span class="nc bnc" id="L981" title="All 2 branches missed.">          if (obj != null) {</span>
<span class="nc" id="L982">            return new PrimitiveValue&lt;&gt;(function, obj);</span>
          }
        }
        try {
<span class="nc" id="L986">          Constructor constructor = null;</span>
          try {
<span class="nc" id="L988">            constructor = c.getConstructor(paramTypes);</span>
<span class="nc" id="L989">          } catch (NoSuchMethodException ex) {</span>
<span class="nc" id="L990">            Constructor[] constructors = c.getConstructors();</span>
<span class="nc bnc" id="L991" title="All 2 branches missed.">            for (Constructor cons:constructors) {</span>
<span class="nc" id="L992">              Class[] consParamTypes = cons.getParameterTypes();</span>
<span class="nc" id="L993">              boolean compatible = isArgTypesCompatible(paramTypes, consParamTypes);</span>
<span class="nc bnc" id="L994" title="All 2 branches missed.">              if (compatible) {</span>
<span class="nc" id="L995">                constructor = cons;</span>
<span class="nc" id="L996">                break;</span>
              }
            }
<span class="nc bnc" id="L999" title="All 2 branches missed.">            if (constructor == null) {</span>
<span class="nc" id="L1000">              throw new RuntimeException(&quot;Cannot instantiate &quot; + c, ex);</span>
            }
<span class="nc" id="L1002">          }</span>
<span class="nc" id="L1003">          Object obj = constructor.newInstance(objs);</span>
<span class="nc" id="L1004">          return new PrimitiveValue&lt;&gt;(function, obj);</span>
<span class="nc" id="L1005">        } catch (InvocationTargetException ex) {</span>
<span class="nc" id="L1006">          throw new RuntimeException(&quot;Cannot instantiate &quot; + c, ex);</span>
<span class="nc" id="L1007">        } catch (InstantiationException ex) {</span>
<span class="nc" id="L1008">          throw new RuntimeException(&quot;Cannot instantiate &quot; + c, ex);</span>
<span class="nc" id="L1009">        } catch (IllegalAccessException ex) {</span>
<span class="nc" id="L1010">          throw new RuntimeException(&quot;Cannot instantiate &quot; + c, ex);</span>
        }
      } else {
<span class="nc" id="L1013">        throw new UnsupportedOperationException(&quot;Unsupported function value &quot; + funcValue);</span>
      }
    }

    @Override
    public boolean equals(Object o) {
<span class="nc bnc" id="L1019" title="All 2 branches missed.">      if (this == o) return true;</span>
<span class="nc bnc" id="L1020" title="All 2 branches missed.">      if (!(o instanceof FunctionCallExpression)) return false;</span>

<span class="nc" id="L1022">      FunctionCallExpression that = (FunctionCallExpression) o;</span>

<span class="nc bnc" id="L1024" title="All 6 branches missed.">      if (function != null ? !function.equals(that.function) : that.function != null) return false;</span>
<span class="nc bnc" id="L1025" title="All 6 branches missed.">      if (params != null ? !params.equals(that.params) : that.params != null) return false;</span>

<span class="nc" id="L1027">      return true;</span>
    }

    @Override
    public int hashCode() {
<span class="nc bnc" id="L1032" title="All 2 branches missed.">      int result = function != null ? function.hashCode() : 0;</span>
<span class="nc bnc" id="L1033" title="All 2 branches missed.">      result = 31 * result + (params != null ? params.hashCode() : 0);</span>
<span class="nc" id="L1034">      return result;</span>
    }
  }

  public static class MethodCallExpression extends Expressions.TypedExpression {

    String function;
    private final Expression object;
    List&lt;Expression&gt; params;

    public MethodCallExpression(String function, Expression object, List&lt;Expression&gt; params, String... tags) {
<span class="nc" id="L1045">      super(TYPE_FUNCTION, tags);</span>
<span class="nc" id="L1046">      this.function = function;</span>
<span class="nc" id="L1047">      this.object = object;</span>
<span class="nc" id="L1048">      this.params = params;</span>
<span class="nc" id="L1049">    }</span>

    public String toString() {
<span class="nc" id="L1052">      return object + &quot;.&quot; + function + '(' + StringUtils.join(params, &quot;, &quot;) + ')';</span>
    }

    public Expression simplify(Env env)
    {
<span class="nc" id="L1057">      boolean paramsAllHasValue = true;</span>
<span class="nc" id="L1058">      List&lt;Expression&gt; simplifiedParams = new ArrayList&lt;&gt;(params.size());</span>
<span class="nc bnc" id="L1059" title="All 2 branches missed.">      for (Expression param:params) {</span>
<span class="nc" id="L1060">        Expression simplified = param.simplify(env);</span>
<span class="nc" id="L1061">        simplifiedParams.add(simplified);</span>
<span class="nc bnc" id="L1062" title="All 2 branches missed.">        if (!(simplified.hasValue())) {</span>
<span class="nc" id="L1063">          paramsAllHasValue = false;</span>
        }
<span class="nc" id="L1065">      }</span>
<span class="nc" id="L1066">      Expression simplifiedObject = object.simplify(env);</span>
<span class="nc" id="L1067">      Expression res = new MethodCallExpression(function, simplifiedObject, simplifiedParams);</span>
<span class="nc bnc" id="L1068" title="All 4 branches missed.">      if (paramsAllHasValue &amp;&amp; object.hasValue()) {</span>
<span class="nc" id="L1069">        return res.evaluate(env);</span>
      } else {
<span class="nc" id="L1071">        return res;</span>
      }
    }

    public Value evaluate(Env env, Object... args) {
<span class="nc" id="L1076">      Value evaledObj = object.evaluate(env, args);</span>
<span class="nc bnc" id="L1077" title="All 4 branches missed.">      if (evaledObj == null || evaledObj.get() == null) return null;</span>
<span class="nc" id="L1078">      Object mainObj = evaledObj.get();</span>
<span class="nc" id="L1079">      Class c = mainObj.getClass();</span>
<span class="nc" id="L1080">      List&lt;Value&gt; evaled = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1081" title="All 2 branches missed.">      for (Expression param:params) {</span>
<span class="nc" id="L1082">        evaled.add(param.evaluate(env, args));</span>
<span class="nc" id="L1083">      }</span>
<span class="nc" id="L1084">      Class[] paramTypes = new Class[params.size()];</span>
<span class="nc" id="L1085">      Object[] objs = new Object[params.size()];</span>
<span class="nc bnc" id="L1086" title="All 2 branches missed.">      for (int i = 0; i &lt; params.size(); i++) {</span>
<span class="nc" id="L1087">        Value v = evaled.get(i);</span>
<span class="nc bnc" id="L1088" title="All 2 branches missed.">        if (v != null) {</span>
<span class="nc" id="L1089">          objs[i] = v.get();</span>
<span class="nc bnc" id="L1090" title="All 2 branches missed.">          if (objs[i] != null) {</span>
<span class="nc" id="L1091">            paramTypes[i] = objs[i].getClass();</span>
          } else {
<span class="nc" id="L1093">            paramTypes[i] = null;</span>
          }
        } else {
<span class="nc" id="L1096">          objs[i] = null;</span>
<span class="nc" id="L1097">          paramTypes[i] = null;</span>
          //throw new RuntimeException(&quot;Missing evaluated value for &quot; + params.get(i));
        }
      }
<span class="nc" id="L1101">      Method method = null;</span>
      try {
<span class="nc" id="L1103">        method = c.getMethod(function, paramTypes);</span>
<span class="nc" id="L1104">      } catch (NoSuchMethodException ex) {</span>
<span class="nc" id="L1105">        Method[] methods = c.getMethods();</span>
<span class="nc bnc" id="L1106" title="All 2 branches missed.">        for (Method m:methods) {</span>
<span class="nc bnc" id="L1107" title="All 2 branches missed.">          if (m.getName().equals(function)) {</span>
<span class="nc" id="L1108">            Class[] mParamTypes = m.getParameterTypes();</span>
<span class="nc bnc" id="L1109" title="All 2 branches missed.">            if (mParamTypes.length == paramTypes.length) {</span>
<span class="nc" id="L1110">              boolean compatible = isArgTypesCompatible(paramTypes, mParamTypes);</span>
<span class="nc bnc" id="L1111" title="All 2 branches missed.">              if (compatible) {</span>
<span class="nc" id="L1112">                method = m;</span>
<span class="nc" id="L1113">                break;</span>
              }
            }
          }
        }
<span class="nc bnc" id="L1118" title="All 2 branches missed.">        if (method == null) {</span>
<span class="nc" id="L1119">          throw new RuntimeException(&quot;Cannot find method &quot; + function + &quot; on object of class &quot; + c, ex);</span>
        }
<span class="nc" id="L1121">      }</span>
      try {
<span class="nc" id="L1123">        Object res = method.invoke(mainObj, objs);</span>
<span class="nc" id="L1124">        return new PrimitiveValue&lt;&gt;(function, res);</span>
<span class="nc" id="L1125">      } catch (InvocationTargetException ex) {</span>
<span class="nc" id="L1126">        throw new RuntimeException(&quot;Cannot evaluate method &quot; + function + &quot; on object &quot; + mainObj, ex);</span>
<span class="nc" id="L1127">      } catch (IllegalAccessException ex) {</span>
<span class="nc" id="L1128">        throw new RuntimeException(&quot;Cannot evaluate method &quot; + function + &quot; on object &quot; + mainObj, ex);</span>
      }
    }

    @Override
    public boolean equals(Object o) {
<span class="nc bnc" id="L1134" title="All 2 branches missed.">      if (this == o) return true;</span>
<span class="nc bnc" id="L1135" title="All 2 branches missed.">      if (!(o instanceof MethodCallExpression)) return false;</span>
<span class="nc bnc" id="L1136" title="All 2 branches missed.">      if (!super.equals(o)) return false;</span>

<span class="nc" id="L1138">      MethodCallExpression that = (MethodCallExpression) o;</span>

<span class="nc bnc" id="L1140" title="All 6 branches missed.">      if (function != null ? !function.equals(that.function) : that.function != null) return false;</span>
<span class="nc bnc" id="L1141" title="All 6 branches missed.">      if (object != null ? !object.equals(that.object) : that.object != null) return false;</span>
<span class="nc bnc" id="L1142" title="All 6 branches missed.">      if (params != null ? !params.equals(that.params) : that.params != null) return false;</span>

<span class="nc" id="L1144">      return true;</span>
    }

    @Override
    public int hashCode() {
<span class="nc" id="L1149">      int result = super.hashCode();</span>
<span class="nc bnc" id="L1150" title="All 2 branches missed.">      result = 31 * result + (function != null ? function.hashCode() : 0);</span>
<span class="nc bnc" id="L1151" title="All 2 branches missed.">      result = 31 * result + (object != null ? object.hashCode() : 0);</span>
<span class="nc bnc" id="L1152" title="All 2 branches missed.">      result = 31 * result + (params != null ? params.hashCode() : 0);</span>
<span class="nc" id="L1153">      return result;</span>
    }
  }

  /**
  * Primitive value that is directly represented by a Java object of type T
  */
  public static class PrimitiveValue&lt;T&gt; extends SimpleValue&lt;T&gt; {
    public PrimitiveValue(String typename, T value, String... tags) {
<span class="fc" id="L1162">      super(typename, value, tags);</span>
<span class="fc" id="L1163">    }</span>
  }

  /**
  * A composite value with field names and values for each field
  */
  public static class CompositeValue extends SimpleCachedExpression&lt;Map&lt;String,Expression&gt;&gt; implements Value&lt;Map&lt;String,Expression&gt;&gt;{
    public CompositeValue(String... tags) {
<span class="nc" id="L1171">      super(TYPE_COMPOSITE, new HashMap&lt;&gt;(), tags);//Generics.&lt;String,Expression&gt;newHashMap()</span>
<span class="nc" id="L1172">    }</span>

    public CompositeValue(Map&lt;String, Expression&gt; m, boolean isEvaluated, String... tags) {
<span class="nc" id="L1175">      super(TYPE_COMPOSITE, m, tags);</span>
<span class="nc bnc" id="L1176" title="All 2 branches missed.">      if (isEvaluated) {</span>
<span class="nc" id="L1177">        evaluated = this;</span>
<span class="nc bnc" id="L1178" title="All 2 branches missed.">        disableCaching = !checkValue();</span>
      }
<span class="nc" id="L1180">    }</span>

    private boolean checkValue() {
<span class="nc" id="L1183">      boolean ok = true;</span>
<span class="nc bnc" id="L1184" title="All 2 branches missed.">      for (String key:value.keySet()) {</span>
<span class="nc" id="L1185">        Expression expr = value.get(key);</span>
<span class="nc bnc" id="L1186" title="All 4 branches missed.">        if (expr != null &amp;&amp; !expr.hasValue()) {</span>
<span class="nc" id="L1187">          ok = false;</span>
        }
<span class="nc" id="L1189">      }</span>
<span class="nc" id="L1190">      return ok;</span>
    }

    public Set&lt;String&gt; getAttributes() {
<span class="nc" id="L1194">      return value.keySet();</span>
    }

    public Expression getExpression(String attr) {
<span class="nc" id="L1198">      return value.get(attr);</span>
    }

    public Value getValue(String attr) {
<span class="nc" id="L1202">      Expression expr = value.get(attr);</span>
<span class="nc bnc" id="L1203" title="All 2 branches missed.">      if (expr == null) return null;</span>
<span class="nc bnc" id="L1204" title="All 2 branches missed.">      if (expr instanceof Value) {</span>
<span class="nc" id="L1205">        return (Value) expr;</span>
      }
<span class="nc" id="L1207">      throw new UnsupportedOperationException(&quot;Expression was not evaluated....&quot;);</span>
    }

    public &lt;T&gt; T get(String attr) {
<span class="nc" id="L1211">      Expression expr = value.get(attr);</span>
<span class="nc bnc" id="L1212" title="All 2 branches missed.">      if (expr == null) return null;</span>
<span class="nc bnc" id="L1213" title="All 2 branches missed.">      if (expr instanceof Value) {</span>
<span class="nc" id="L1214">        return ((Value&lt;T&gt;) expr).get();</span>
      }
<span class="nc" id="L1216">      throw new UnsupportedOperationException(&quot;Expression was not evaluated....&quot;);</span>
    }

    public void set(String attr, Object obj) {
<span class="nc bnc" id="L1220" title="All 2 branches missed.">      if (obj instanceof Expression) {</span>
<span class="nc" id="L1221">        value.put(attr, (Expression) obj);</span>
      } else {
<span class="nc" id="L1223">        value.put(attr, createValue(null, obj));</span>
      }
<span class="nc" id="L1225">      evaluated = null;</span>
<span class="nc" id="L1226">    }</span>

    private static Object toCompatibleObject(Field f, Object value) {
<span class="nc bnc" id="L1229" title="All 2 branches missed.">      if (value == null) return value;</span>
<span class="nc bnc" id="L1230" title="All 2 branches missed.">      if (!f.getDeclaringClass().isAssignableFrom(value.getClass())) {</span>
<span class="nc bnc" id="L1231" title="All 2 branches missed.">        if (Number.class.isAssignableFrom(value.getClass())) {</span>
<span class="nc" id="L1232">          Number number = (Number) value;</span>
<span class="nc bnc" id="L1233" title="All 2 branches missed.">          if (f.getType().isAssignableFrom(Double.class)) {</span>
<span class="nc" id="L1234">            return number.doubleValue();</span>
<span class="nc bnc" id="L1235" title="All 2 branches missed.">          } else if (f.getType().isAssignableFrom(Float.class)) {</span>
<span class="nc" id="L1236">              return number.floatValue();</span>
<span class="nc bnc" id="L1237" title="All 2 branches missed.">          } else if (f.getType().isAssignableFrom(Long.class)) {</span>
<span class="nc" id="L1238">            return number.longValue();</span>
<span class="nc bnc" id="L1239" title="All 2 branches missed.">          } else if (f.getType().isAssignableFrom(Integer.class)) {</span>
<span class="nc" id="L1240">            return number.intValue();</span>
          }
        }
      }
<span class="nc" id="L1244">      return value;</span>
    }

    private static Value attemptTypeConversion(CompositeValue cv, Env env, Object... args) {
<span class="nc" id="L1248">      Expression typeFieldExpr = cv.value.get(&quot;type&quot;);</span>
<span class="nc bnc" id="L1249" title="All 2 branches missed.">      if (typeFieldExpr != null) {</span>
        // Automatically convert types ....
<span class="nc" id="L1251">        Value typeValue = typeFieldExpr.evaluate(env, args);</span>
<span class="nc bnc" id="L1252" title="All 2 branches missed.">        if (typeFieldExpr instanceof VarExpression) {</span>
<span class="nc" id="L1253">          VarExpression varExpr = (VarExpression) typeFieldExpr;</span>
          // The name of the variable is used to indicate the &quot;type&quot; of object
<span class="nc" id="L1255">          String typeName = varExpr.get();</span>
<span class="nc bnc" id="L1256" title="All 2 branches missed.">          if (typeValue != null) {</span>
            // Check if variable points to a class
            // If so, then try to instantiate a new instance of the class
<span class="nc bnc" id="L1259" title="All 2 branches missed.">            if (TYPE_CLASS.equals(typeValue.getType())) {</span>
              // Variable maps to a java class
<span class="nc" id="L1261">              Class c = (Class) typeValue.get();</span>
              try {
<span class="nc" id="L1263">                Object obj = c.newInstance();</span>
                // for any field other than the &quot;type&quot;, set the value of the field
                //   of the created object to the specified value
<span class="nc bnc" id="L1266" title="All 2 branches missed.">                for (String s:cv.value.keySet()) {</span>
<span class="nc bnc" id="L1267" title="All 2 branches missed.">                  if (!&quot;type&quot;.equals(s)) {</span>
<span class="nc" id="L1268">                    Value v = cv.value.get(s).evaluate(env, args);</span>
                    try {
<span class="nc" id="L1270">                      Field f = c.getField(s);</span>
<span class="nc" id="L1271">                      Object objVal =  toCompatibleObject(f, v.get());</span>
<span class="nc" id="L1272">                      f.set(obj, objVal);</span>
<span class="nc" id="L1273">                    } catch (NoSuchFieldException ex){</span>
<span class="nc" id="L1274">                      throw new RuntimeException(&quot;Unknown field &quot; + s + &quot; for type &quot; + typeName + &quot;, trying to set to &quot; + v, ex);</span>
<span class="nc" id="L1275">                    } catch (IllegalArgumentException ex){</span>
<span class="nc" id="L1276">                      throw new RuntimeException(&quot;Incompatible type &quot; + s + &quot; for type &quot; + typeName + &quot;, trying to set to &quot; + v, ex);</span>
<span class="nc" id="L1277">                    }</span>
                  }
<span class="nc" id="L1279">                }</span>
<span class="nc" id="L1280">                return new PrimitiveValue&lt;&gt;(typeName, obj);</span>
<span class="nc" id="L1281">              } catch (InstantiationException ex) {</span>
<span class="nc" id="L1282">                throw new RuntimeException(&quot;Cannot instantiate &quot; + c, ex);</span>
<span class="nc" id="L1283">              } catch (IllegalAccessException ex) {</span>
<span class="nc" id="L1284">                throw new RuntimeException(&quot;Cannot instantiate &quot; + c, ex);</span>
              }
<span class="nc bnc" id="L1286" title="All 2 branches missed.">            } else if (typeValue.get() != null){</span>
              // When evaluated, variable does not explicitly map to &quot;CLASS&quot;
              // See if we can convert this CompositeValue into appropriate object
              // by calling &quot;create(CompositeValue cv)&quot;
<span class="nc" id="L1290">              Class c = typeValue.get().getClass();</span>
              try {
<span class="nc" id="L1292">                Method m = c.getMethod(&quot;create&quot;, CompositeValue.class);</span>
<span class="nc" id="L1293">                CompositeValue evaluatedCv = cv.evaluateNoTypeConversion(env, args);</span>
                try {
<span class="nc" id="L1295">                  return new PrimitiveValue&lt;&gt;(typeName, m.invoke(typeValue.get(), evaluatedCv));</span>
<span class="nc" id="L1296">                } catch (InvocationTargetException ex) {</span>
<span class="nc" id="L1297">                  throw new RuntimeException(&quot;Cannot instantiate &quot; + c, ex);</span>
<span class="nc" id="L1298">                } catch (IllegalAccessException ex) {</span>
<span class="nc" id="L1299">                  throw new RuntimeException(&quot;Cannot instantiate &quot; + c, ex);</span>
                }
<span class="nc" id="L1301">              } catch (NoSuchMethodException ex) {}</span>
            }
          }
<span class="nc bnc" id="L1304" title="All 4 branches missed.">        } else if (typeValue != null &amp;&amp; typeValue.get() instanceof String) {</span>
<span class="nc" id="L1305">          String typeName = (String) typeValue.get();</span>
          // Predefined types:
<span class="nc" id="L1307">          Expression valueField = cv.value.get(&quot;value&quot;);</span>
<span class="nc" id="L1308">          Value value = valueField.evaluate(env, args);</span>
<span class="nc bnc" id="L1309" title="All 22 branches missed.">          switch (typeName) {</span>
            case TYPE_ANNOTATION_KEY: {
<span class="nc" id="L1311">              String className = (String) value.get();</span>
              try {
<span class="nc" id="L1313">                return new PrimitiveValue&lt;Class&gt;(TYPE_ANNOTATION_KEY, Class.forName(className));</span>
<span class="nc" id="L1314">              } catch (ClassNotFoundException ex) {</span>
<span class="nc" id="L1315">                throw new RuntimeException(&quot;Unknown class &quot; + className, ex);</span>
              }
            }
            case TYPE_CLASS: {
<span class="nc" id="L1319">              String className = (String) value.get();</span>
              try {
<span class="nc" id="L1321">                return new PrimitiveValue&lt;Class&gt;(TYPE_CLASS, Class.forName(className));</span>
<span class="nc" id="L1322">              } catch (ClassNotFoundException ex) {</span>
<span class="nc" id="L1323">                throw new RuntimeException(&quot;Unknown class &quot; + className, ex);</span>
              }
            }
            case TYPE_STRING:
<span class="nc" id="L1327">              return new PrimitiveValue&lt;&gt;(TYPE_STRING, (String) value.get());</span>
            case TYPE_REGEX:
<span class="nc" id="L1329">              return new RegexValue((String) value.get());</span>
            /* } else if (TYPE_TOKEN_REGEX.equals(type)) {
       return new PrimitiveValue&lt;TokenSequencePattern&gt;(TYPE_TOKEN_REGEX, (TokenSequencePattern) value.get()); */
            case TYPE_NUMBER:
<span class="nc bnc" id="L1333" title="All 2 branches missed.">              if (value.get() instanceof Number) {</span>
<span class="nc" id="L1334">                return new PrimitiveValue&lt;&gt;(TYPE_NUMBER, (Number) value.get());</span>
<span class="nc bnc" id="L1335" title="All 2 branches missed.">              } else if (value.get() instanceof String) {</span>
<span class="nc" id="L1336">                String str = (String) value.get();</span>
<span class="nc bnc" id="L1337" title="All 2 branches missed.">                if (str.contains(&quot;.&quot;)) {</span>
<span class="nc" id="L1338">                  return new PrimitiveValue&lt;Number&gt;(TYPE_NUMBER, Double.valueOf(str));</span>
                } else {
<span class="nc" id="L1340">                  return new PrimitiveValue&lt;Number&gt;(TYPE_NUMBER, Long.valueOf(str));</span>
                }
              } else {
<span class="nc" id="L1343">                throw new IllegalArgumentException(&quot;Invalid value &quot; + value + &quot; for type &quot; + typeName);</span>
              }
            default:
              // TODO: support other types
<span class="nc" id="L1347">              return new PrimitiveValue(typeName, value.get());</span>
              //throw new UnsupportedOperationException(&quot;Cannot convert type &quot; + typeName);
          }
        }
      }
<span class="nc" id="L1352">      return null;</span>
    }

    public CompositeValue simplifyNoTypeConversion(Env env, Object... args) {
<span class="nc" id="L1356">      Map&lt;String, Expression&gt; m = value;</span>
<span class="nc" id="L1357">      Map&lt;String, Expression&gt; res = new HashMap&lt;&gt;(m.size());//Generics.newHashMap (m.size());</span>
<span class="nc bnc" id="L1358" title="All 2 branches missed.">      for (Map.Entry&lt;String, Expression&gt; stringExpressionEntry : m.entrySet()) {</span>
<span class="nc" id="L1359">        res.put(stringExpressionEntry.getKey(), stringExpressionEntry.getValue().simplify(env));</span>
<span class="nc" id="L1360">      }</span>
<span class="nc" id="L1361">      return new CompositeValue(res, true);</span>
    }

    private CompositeValue evaluateNoTypeConversion(Env env, Object... args) {
<span class="nc" id="L1365">      Map&lt;String, Expression&gt; m = value;</span>
<span class="nc" id="L1366">      Map&lt;String, Expression&gt; res = new HashMap&lt;&gt;(m.size());//Generics.newHashMap (m.size());</span>
<span class="nc bnc" id="L1367" title="All 2 branches missed.">      for (Map.Entry&lt;String, Expression&gt; stringExpressionEntry : m.entrySet()) {</span>
<span class="nc" id="L1368">        res.put(stringExpressionEntry.getKey(), stringExpressionEntry.getValue().evaluate(env, args));</span>
<span class="nc" id="L1369">      }</span>
<span class="nc" id="L1370">      return new CompositeValue(res, true);</span>
    }

    public Value doEvaluation(Env env, Object... args) {
<span class="nc" id="L1374">      Value v = attemptTypeConversion(this, env, args);</span>
<span class="nc bnc" id="L1375" title="All 2 branches missed.">      if (v != null) return v;</span>
<span class="nc" id="L1376">      Map&lt;String, Expression&gt; m = value;</span>
<span class="nc" id="L1377">      Map&lt;String, Expression&gt; res = new HashMap&lt;&gt;(m.size());//Generics.newHashMap (m.size());</span>
<span class="nc bnc" id="L1378" title="All 2 branches missed.">      for (Map.Entry&lt;String, Expression&gt; stringExpressionEntry : m.entrySet()) {</span>
<span class="nc" id="L1379">        res.put(stringExpressionEntry.getKey(), stringExpressionEntry.getValue().evaluate(env, args));</span>
<span class="nc" id="L1380">      }</span>
<span class="nc bnc" id="L1381" title="All 2 branches missed.">      disableCaching = !checkValue();</span>
<span class="nc" id="L1382">      return new CompositeValue(res, true);</span>
    }

  } // end static class CompositeValue

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>