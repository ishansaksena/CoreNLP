<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CRFClassifier.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.ie.crf</a> &gt; <span class="el_source">CRFClassifier.java</span></div><h1>CRFClassifier.java</h1><pre class="source lang-java linenums">// CRFClassifier -- a probabilistic (CRF) sequence model, mainly used for NER.
// Copyright (c) 2002-2016 The Board of Trustees of
// The Leland Stanford Junior University. All Rights Reserved.
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software Foundation,
// Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
//
// For more information, bug reports, fixes, contact:
//    Christopher Manning
//    Dept of Computer Science, Gates 1A
//    Stanford CA 94305-9010
//    USA
//    Support/Questions: java-nlp-user@lists.stanford.edu
//    Licensing: java-nlp-support@lists.stanford.edu

package edu.stanford.nlp.ie.crf;

import edu.stanford.nlp.ie.*;
import edu.stanford.nlp.io.IOUtils;
import edu.stanford.nlp.io.RuntimeIOException;
import edu.stanford.nlp.ling.CoreAnnotations;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.math.ArrayMath;
import edu.stanford.nlp.objectbank.ObjectBank;
import edu.stanford.nlp.optimization.*;
import edu.stanford.nlp.optimization.Function;
import edu.stanford.nlp.sequences.*;
import edu.stanford.nlp.stats.ClassicCounter;
import edu.stanford.nlp.stats.Counter;
import edu.stanford.nlp.stats.TwoDimensionalCounter;
import edu.stanford.nlp.util.*;
import edu.stanford.nlp.util.logging.Redwood;

import java.io.*;
import java.lang.reflect.InvocationTargetException;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.util.*;
import java.util.regex.*;
import java.util.stream.Collectors;
import java.util.zip.GZIPOutputStream;

/**
 * Class for sequence classification using a Conditional Random Field model.
 * The code has functionality for different document formats, but when
 * using the standard {@link edu.stanford.nlp.sequences.ColumnDocumentReaderAndWriter} for training
 * or testing models, input files are expected to
 * be one token per line with the columns indicating things like the word,
 * POS, chunk, and answer class.  The default for
 * {@code ColumnDocumentReaderAndWriter} training data is 3 column input,
 * with the columns containing a word, its POS, and its gold class, but
 * this can be specified via the {@code map} property.
 * &lt;/p&gt;&lt;p&gt;
 * When run on a file with {@code -textFile} or {@code -textFiles},
 * the file is assumed to be plain English text (or perhaps simple HTML/XML),
 * and a reasonable attempt is made at English tokenization by
 * {@link PlainTextDocumentReaderAndWriter}.  The class used to read
 * the text can be changed with -plainTextDocumentReaderAndWriter.
 * Extra options can be supplied to the tokenizer using the
 * -tokenizerOptions flag.
 * &lt;/p&gt;&lt;p&gt;
 * To read from stdin, use the flag -readStdin.  The same
 * reader/writer will be used as for -textFile.
 * &lt;/p&gt;
 * &lt;p&gt;&lt;b&gt;Typical command-line usage&lt;/b&gt;&lt;/p&gt;
 * &lt;p&gt;For running a trained model with a provided serialized classifier on a
 * text file: &lt;/p&gt;
 * &lt;p&gt;
 * {@code java -mx500m edu.stanford.nlp.ie.crf.CRFClassifier -loadClassifier
 * conll.ner.gz -textFile sampleSentences.txt }
 * &lt;/p&gt;
 * &lt;p&gt;
 * When specifying all parameters in a properties file (train, test, or
 * runtime):
 * &lt;/p&gt;
 * &lt;p&gt;
 * {@code java -mx1g edu.stanford.nlp.ie.crf.CRFClassifier -prop propFile }
 * &lt;/p&gt;
 * &lt;p&gt;
 * To train and test a simple NER model from the command line:&lt;/p&gt;
 * &lt;p&gt;
 * {@code java -mx1000m edu.stanford.nlp.ie.crf.CRFClassifier
 * -trainFile trainFile -testFile testFile -macro &amp;gt; output }
 * &lt;/p&gt;
 * &lt;p&gt;
 * To train with multiple files: &lt;/p&gt;
 * &lt;p&gt;
 * {@code java -mx1000m edu.stanford.nlp.ie.crf.CRFClassifier
 * -trainFileList file1,file2,... -testFile testFile -macro &amp;gt; output }
 * &lt;/p&gt;
 * &lt;p&gt;
 * To test on multiple files, use the -testFiles option and a comma
 * separated list.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Features are defined by a {@link edu.stanford.nlp.sequences.FeatureFactory}.
 * {@link NERFeatureFactory} is used by default, and you should look
 * there for feature templates and properties or flags that will cause
 * certain features to be used when training an NER classifier. There
 * are also various feature factories for Chinese word segmentation
 * such as {@link edu.stanford.nlp.wordseg.ChineseSegmenterFeatureFactory}.
 * Features are specified either
 * by a Properties file (which is the recommended method) or by flags on the
 * command line. The flags are read into a {@link SeqClassifierFlags} object,
 * which the user need not be concerned with, unless wishing to add new
 * features. &lt;/p&gt; CRFClassifier may also be used programmatically. When creating
 * a new instance, you &lt;i&gt;must&lt;/i&gt; specify a Properties object. You may then
 * call train methods to train a classifier, or load a classifier. The other way
 * to get a CRFClassifier is to deserialize one via the static
 * {@link CRFClassifier#getClassifier(String)} methods, which return a
 * deserialized classifier. You may then tag (classify the items of) documents
 * using either the assorted {@code classify()} methods here or the additional
 * ones in {@link AbstractSequenceClassifier}.
 * Probabilities assigned by the CRF can be interrogated using either the
 * {@code printProbsDocument()} or {@code getCliqueTrees()} methods.
 *
 * @author Jenny Finkel
 * @author Sonal Gupta (made the class generic)
 * @author Mengqiu Wang (LOP implementation and non-linear CRF implementation)
 */
<span class="nc bnc" id="L132" title="All 2 branches missed.">public class CRFClassifier&lt;IN extends CoreMap&gt; extends AbstractSequenceClassifier&lt;IN&gt;  {</span>

  /** A logger for this class */
<span class="nc" id="L135">  private static final Redwood.RedwoodChannels log = Redwood.channels(CRFClassifier.class);</span>

  // TODO(mengqiu) need to move the embedding lookup and capitalization features into a FeatureFactory

  List&lt;Index&lt;CRFLabel&gt;&gt; labelIndices;
  Index&lt;String&gt; tagIndex;
  private Pair&lt;double[][], double[][]&gt; entityMatrices;

  CliquePotentialFunction cliquePotentialFunction;
  HasCliquePotentialFunction cliquePotentialFunctionHelper;

  /** Parameter weights of the classifier.  weights[featureIndex][labelIndex] */
  double[][] weights;

  /** index the features of CRF */
  Index&lt;String&gt; featureIndex;
  /** caches the featureIndex */
  int[] map;
<span class="nc" id="L153">  Random random = new Random(2147483647L);</span>
  Index&lt;Integer&gt; nodeFeatureIndicesMap;
  Index&lt;Integer&gt; edgeFeatureIndicesMap;

  private Map&lt;String, double[]&gt; embeddings; // = null;

  /**
   * Name of default serialized classifier resource to look for in a jar file.
   */
  public static final String DEFAULT_CLASSIFIER = &quot;/edu/stanford/nlp/models/ner/english.all.3class.distsim.crf.ser.gz&quot;;
  private static final boolean VERBOSE = false;

  /**
   * Fields for grouping features
   */
<span class="nc" id="L168">  private Pattern suffixPatt = Pattern.compile(&quot;.+?((?:-[A-Z]+)+)\\|.*C&quot;);</span>
  private Index&lt;String&gt; templateGroupIndex;
  private Map&lt;Integer, Integer&gt; featureIndexToTemplateIndex;

  // Label dictionary for fast decoding
  private LabelDictionary labelDictionary;

  // List selftraindatums = new ArrayList();

  protected CRFClassifier() {
<span class="nc" id="L178">    super(new SeqClassifierFlags());</span>
<span class="nc" id="L179">  }</span>

  public CRFClassifier(Properties props) {
<span class="nc" id="L182">    super(props);</span>
<span class="nc" id="L183">  }</span>

  public CRFClassifier(SeqClassifierFlags flags) {
<span class="nc" id="L186">    super(flags);</span>
<span class="nc" id="L187">  }</span>

  /**
   * Makes a copy of the crf classifier
   */
  public CRFClassifier(CRFClassifier&lt;IN&gt; crf) {
<span class="nc" id="L193">    super(crf.flags);</span>
<span class="nc" id="L194">    this.windowSize = crf.windowSize;</span>
<span class="nc" id="L195">    this.featureFactories = crf.featureFactories;</span>
<span class="nc" id="L196">    this.pad = crf.pad;</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">    if (crf.knownLCWords == null) {</span>
<span class="nc" id="L198">      this.knownLCWords = new MaxSizeConcurrentHashSet&lt;&gt;(crf.flags.maxAdditionalKnownLCWords);</span>
    } else {
<span class="nc" id="L200">      this.knownLCWords = new MaxSizeConcurrentHashSet&lt;&gt;(crf.knownLCWords);</span>
<span class="nc" id="L201">      this.knownLCWords.setMaxSize(this.knownLCWords.size() + crf.flags.maxAdditionalKnownLCWords);</span>
    }
<span class="nc bnc" id="L203" title="All 2 branches missed.">    this.featureIndex = (crf.featureIndex != null) ? new HashIndex&lt;&gt;(crf.featureIndex.objectsList()) : null;</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">    this.classIndex = (crf.classIndex != null) ? new HashIndex&lt;&gt;(crf.classIndex.objectsList()) : null;</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">    if (crf.labelIndices != null) {</span>
<span class="nc" id="L206">      this.labelIndices = new ArrayList&lt;&gt;(crf.labelIndices.size());</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">      for (int i = 0; i &lt; crf.labelIndices.size(); i++) {</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">        this.labelIndices.add((crf.labelIndices.get(i) != null) ? new HashIndex&lt;&gt;(crf.labelIndices.get(i).objectsList()) : null);</span>
      }
    } else {
<span class="nc" id="L211">      this.labelIndices = null;</span>
    }
<span class="nc" id="L213">    this.cliquePotentialFunction = crf.cliquePotentialFunction;</span>
<span class="nc" id="L214">  }</span>

  /**
   * Returns the total number of weights associated with this classifier.
   *
   * @return number of weights
   */
  public int getNumWeights() {
<span class="nc bnc" id="L222" title="All 2 branches missed.">    if (weights == null) return 0;</span>
<span class="nc" id="L223">    int numWeights = 0;</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">    for (double[] wts : weights) {</span>
<span class="nc" id="L225">      numWeights += wts.length;</span>
    }
<span class="nc" id="L227">    return numWeights;</span>
  }

  /**
   * Get index of featureType for feature indexed by i. (featureType index is
   * used to index labelIndices to get labels.)
   *
   * @param i Feature index
   * @return index of featureType
   */
  private int getFeatureTypeIndex(int i) {
<span class="nc" id="L238">    return getFeatureTypeIndex(featureIndex.get(i));</span>
  }

  /**
   * Get index of featureType for feature based on the feature string
   * (featureType index used to index labelIndices to get labels)
   *
   * @param feature Feature string
   * @return index of featureType
   */
  private static int getFeatureTypeIndex(String feature) {
<span class="nc bnc" id="L249" title="All 2 branches missed.">    if (feature.endsWith(&quot;|C&quot;)) {</span>
<span class="nc" id="L250">      return 0;</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">    } else if (feature.endsWith(&quot;|CpC&quot;)) {</span>
<span class="nc" id="L252">      return 1;</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">    } else if (feature.endsWith(&quot;|Cp2C&quot;)) {</span>
<span class="nc" id="L254">      return 2;</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">    } else if (feature.endsWith(&quot;|Cp3C&quot;)) {</span>
<span class="nc" id="L256">      return 3;</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">    } else if (feature.endsWith(&quot;|Cp4C&quot;)) {</span>
<span class="nc" id="L258">      return 4;</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">    } else if (feature.endsWith(&quot;|Cp5C&quot;)) {</span>
<span class="nc" id="L260">      return 5;</span>
    } else {
<span class="nc" id="L262">      throw new RuntimeException(&quot;Unknown feature type &quot; + feature);</span>
    }
  }

  /**
   * Scales the weights of this CRFClassifier by the specified weight.
   *
   * @param scale The scale to multiply by
   */
  public void scaleWeights(double scale) {
<span class="nc bnc" id="L272" title="All 2 branches missed.">    for (int i = 0; i &lt; weights.length; i++) {</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">      for (int j = 0; j &lt; weights[i].length; j++) {</span>
<span class="nc" id="L274">        weights[i][j] *= scale;</span>
      }
    }
<span class="nc" id="L277">  }</span>

  /**
   * Combines weights from another crf (scaled by weight) into this CRF's
   * weights (assumes that this CRF's indices have already been updated to
   * include features/labels from the other crf)
   *
   * @param crf Other CRF whose weights to combine into this CRF
   * @param weight Amount to scale the other CRF's weights by
   */
  private void combineWeights(CRFClassifier&lt;IN&gt; crf, double weight) {
<span class="nc" id="L288">    int numFeatures = featureIndex.size();</span>
<span class="nc" id="L289">    int oldNumFeatures = weights.length;</span>

    // Create a map of other crf labels to this crf labels
<span class="nc" id="L292">    Map&lt;CRFLabel, CRFLabel&gt; crfLabelMap = Generics.newHashMap();</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">    for (int i = 0; i &lt; crf.labelIndices.size(); i++) {</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">      for (int j = 0; j &lt; crf.labelIndices.get(i).size(); j++) {</span>
<span class="nc" id="L295">        CRFLabel labels = crf.labelIndices.get(i).get(j);</span>
<span class="nc" id="L296">        int[] newLabelIndices = new int[i + 1];</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">        for (int ci = 0; ci &lt;= i; ci++) {</span>
<span class="nc" id="L298">          String classLabel = crf.classIndex.get(labels.getLabel()[ci]);</span>
<span class="nc" id="L299">          newLabelIndices[ci] = this.classIndex.indexOf(classLabel);</span>
        }
<span class="nc" id="L301">        CRFLabel newLabels = new CRFLabel(newLabelIndices);</span>
<span class="nc" id="L302">        crfLabelMap.put(labels, newLabels);</span>
<span class="nc" id="L303">        int k = this.labelIndices.get(i).indexOf(newLabels); // IMPORTANT: the indexing is needed, even when not printed out!</span>
        // log.info(&quot;LabelIndices &quot; + i + &quot; &quot; + labels + &quot;: &quot; + j +
        // &quot; mapped to &quot; + k);
      }
    }

    // Create map of featureIndex to featureTypeIndex
<span class="nc" id="L310">    map = new int[numFeatures];</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">    for (int i = 0; i &lt; numFeatures; i++) {</span>
<span class="nc" id="L312">      map[i] = getFeatureTypeIndex(i);</span>
    }

    // Create new weights
<span class="nc" id="L316">    double[][] newWeights = new double[numFeatures][];</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">    for (int i = 0; i &lt; numFeatures; i++) {</span>
<span class="nc" id="L318">      int length = labelIndices.get(map[i]).size();</span>
<span class="nc" id="L319">      newWeights[i] = new double[length];</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">      if (i &lt; oldNumFeatures) {</span>
<span class="nc bnc" id="L321" title="All 4 branches missed.">        assert (length &gt;= weights[i].length);</span>
<span class="nc" id="L322">        System.arraycopy(weights[i], 0, newWeights[i], 0, weights[i].length);</span>
      }
    }
<span class="nc" id="L325">    weights = newWeights;</span>

    // Get original weight indices from other crf and weight them in
    // depending on the type of the feature, different number of weights is
    // associated with it
<span class="nc bnc" id="L330" title="All 2 branches missed.">    for (int i = 0; i &lt; crf.weights.length; i++) {</span>
<span class="nc" id="L331">      String feature = crf.featureIndex.get(i);</span>
<span class="nc" id="L332">      int newIndex = featureIndex.indexOf(feature);</span>
      // Check weights are okay dimension
<span class="nc bnc" id="L334" title="All 2 branches missed.">      if (weights[newIndex].length &lt; crf.weights[i].length) {</span>
<span class="nc" id="L335">        throw new RuntimeException(&quot;Incompatible CRFClassifier: weight length mismatch for feature &quot; + newIndex + &quot;: &quot;</span>
<span class="nc" id="L336">            + featureIndex.get(newIndex) + &quot; (also feature &quot; + i + &quot;: &quot; + crf.featureIndex.get(i) + &quot;) &quot; + &quot;, len1=&quot;</span>
            + weights[newIndex].length + &quot;, len2=&quot; + crf.weights[i].length);
      }
<span class="nc" id="L339">      int featureTypeIndex = map[newIndex];</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">      for (int j = 0; j &lt; crf.weights[i].length; j++) {</span>
<span class="nc" id="L341">        CRFLabel labels = crf.labelIndices.get(featureTypeIndex).get(j);</span>
<span class="nc" id="L342">        CRFLabel newLabels = crfLabelMap.get(labels);</span>
<span class="nc" id="L343">        int k = this.labelIndices.get(featureTypeIndex).indexOf(newLabels);</span>
<span class="nc" id="L344">        weights[newIndex][k] += crf.weights[i][j] * weight;</span>
      }
    }
<span class="nc" id="L347">  }</span>

  /**
   * Combines weighted crf with this crf.
   *
   * @param crf Other CRF whose weights to combine into this CRF
   * @param weight Amount to scale the other CRF's weights by
   */
  public void combine(CRFClassifier&lt;IN&gt; crf, double weight) {
<span class="nc" id="L356">    Timing timer = new Timing();</span>

    // Check the CRFClassifiers are compatible
<span class="nc bnc" id="L359" title="All 2 branches missed.">    if (!this.pad.equals(crf.pad)) {</span>
<span class="nc" id="L360">      throw new RuntimeException(&quot;Incompatible CRFClassifier: pad does not match&quot;);</span>
    }
<span class="nc bnc" id="L362" title="All 2 branches missed.">    if (this.windowSize != crf.windowSize) {</span>
<span class="nc" id="L363">      throw new RuntimeException(&quot;Incompatible CRFClassifier: windowSize does not match&quot;);</span>
    }
<span class="nc bnc" id="L365" title="All 2 branches missed.">    if (this.labelIndices.size() != crf.labelIndices.size()) {</span>
      // Should match since this should be same as the windowSize
<span class="nc" id="L367">      throw new RuntimeException(&quot;Incompatible CRFClassifier: labelIndices length does not match&quot;);</span>
    }
<span class="nc" id="L369">    this.classIndex.addAll(crf.classIndex.objectsList());</span>

    // Combine weights of the other classifier with this classifier,
    // weighing the other classifier's weights by weight
    // First merge the feature indices
<span class="nc" id="L374">    int oldNumFeatures1 = this.featureIndex.size();</span>
<span class="nc" id="L375">    int oldNumFeatures2 = crf.featureIndex.size();</span>
<span class="nc" id="L376">    int oldNumWeights1 = this.getNumWeights();</span>
<span class="nc" id="L377">    int oldNumWeights2 = crf.getNumWeights();</span>
<span class="nc" id="L378">    this.featureIndex.addAll(crf.featureIndex.objectsList());</span>
<span class="nc" id="L379">    this.knownLCWords.addAll(crf.knownLCWords);</span>
<span class="nc bnc" id="L380" title="All 4 branches missed.">    assert (weights.length == oldNumFeatures1);</span>

    // Combine weights of this classifier with other classifier
<span class="nc bnc" id="L383" title="All 2 branches missed.">    for (int i = 0; i &lt; labelIndices.size(); i++) {</span>
<span class="nc" id="L384">      this.labelIndices.get(i).addAll(crf.labelIndices.get(i).objectsList());</span>
    }
<span class="nc" id="L386">    log.info(&quot;Combining weights: will automatically match labelIndices&quot;);</span>
<span class="nc" id="L387">    combineWeights(crf, weight);</span>

<span class="nc" id="L389">    int numFeatures = featureIndex.size();</span>
<span class="nc" id="L390">    int numWeights = getNumWeights();</span>
<span class="nc" id="L391">    long elapsedMs = timer.stop();</span>
<span class="nc" id="L392">    log.info(&quot;numFeatures: orig1=&quot; + oldNumFeatures1 + &quot;, orig2=&quot; + oldNumFeatures2 + &quot;, combined=&quot;</span>
        + numFeatures);
<span class="nc" id="L394">    log.info(&quot;numWeights: orig1=&quot; + oldNumWeights1 + &quot;, orig2=&quot; + oldNumWeights2 + &quot;, combined=&quot; + numWeights);</span>
<span class="nc" id="L395">    log.info(&quot;Time to combine CRFClassifier: &quot; + Timing.toSecondsString(elapsedMs) + &quot; seconds&quot;);</span>
<span class="nc" id="L396">  }</span>

  public void dropFeaturesBelowThreshold(double threshold) {
<span class="nc" id="L399">    Index&lt;String&gt; newFeatureIndex = new HashIndex&lt;&gt;();</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">    for (int i = 0; i &lt; weights.length; i++) {</span>
<span class="nc" id="L401">      double smallest = weights[i][0];</span>
<span class="nc" id="L402">      double biggest = weights[i][0];</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">      for (int j = 1; j &lt; weights[i].length; j++) {</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">        if (weights[i][j] &gt; biggest) {</span>
<span class="nc" id="L405">          biggest = weights[i][j];</span>
        }
<span class="nc bnc" id="L407" title="All 2 branches missed.">        if (weights[i][j] &lt; smallest) {</span>
<span class="nc" id="L408">          smallest = weights[i][j];</span>
        }
<span class="nc bnc" id="L410" title="All 2 branches missed.">        if (biggest - smallest &gt; threshold) {</span>
<span class="nc" id="L411">          newFeatureIndex.add(featureIndex.get(i));</span>
<span class="nc" id="L412">          break;</span>
        }
      }
    }

<span class="nc" id="L417">    int[] newMap = new int[newFeatureIndex.size()];</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">    for (int i = 0; i &lt; newMap.length; i++) {</span>
<span class="nc" id="L419">      int index = featureIndex.indexOf(newFeatureIndex.get(i));</span>
<span class="nc" id="L420">      newMap[i] = map[index];</span>
    }
<span class="nc" id="L422">    map = newMap;</span>
<span class="nc" id="L423">    featureIndex = newFeatureIndex;</span>
<span class="nc" id="L424">  }</span>

  /**
   * Convert a document List into arrays storing the data features and labels.
   * This is used at test time.
   *
   * @param document Testing documents
   * @return A Triple, where the first element is an int[][][] representing the
   *         data, the second element is an int[] representing the labels, and
   *         the third element is a double[][][] representing the feature values (optionally null)
   */
  public Triple&lt;int[][][], int[], double[][][]&gt; documentToDataAndLabels(List&lt;IN&gt; document) {
<span class="nc" id="L436">    int docSize = document.size();</span>
    // first index is position in the document also the index of the
    // clique/factor table
    // second index is the number of elements in the clique/window these
    // features are for (starting with last element)
    // third index is position of the feature in the array that holds them.
    // An element in data[j][k][m] is the feature index of the mth feature occurring in
    // position k of the jth clique
<span class="nc" id="L444">    int[][][] data = new int[docSize][windowSize][];</span>
<span class="nc" id="L445">    double[][][] featureVals = new double[docSize][windowSize][];</span>
    // index is the position in the document.
    // element in labels[j] is the index of the correct label (if it exists) at
    // position j of document
<span class="nc" id="L449">    int[] labels = new int[docSize];</span>

<span class="nc bnc" id="L451" title="All 2 branches missed.">    if (flags.useReverse) {</span>
<span class="nc" id="L452">      Collections.reverse(document);</span>
    }

    // log.info(&quot;docSize:&quot;+docSize);
<span class="nc bnc" id="L456" title="All 2 branches missed.">    for (int j = 0; j &lt; docSize; j++) {</span>
<span class="nc" id="L457">      CRFDatum&lt;List&lt;String&gt;, CRFLabel&gt; d = makeDatum(document, j, featureFactories);</span>

<span class="nc" id="L459">      List&lt;List&lt;String&gt;&gt; features = d.asFeatures();</span>
<span class="nc" id="L460">      List&lt;double[]&gt; featureValList = d.asFeatureVals();</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">      for (int k = 0, fSize = features.size(); k &lt; fSize; k++) {</span>
<span class="nc" id="L462">        Collection&lt;String&gt; cliqueFeatures = features.get(k);</span>
<span class="nc" id="L463">        data[j][k] = new int[cliqueFeatures.size()];</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">        if(featureValList != null) { // CRFBiasedClassifier.makeDatum causes null</span>
<span class="nc" id="L465">          featureVals[j][k] = featureValList.get(k);</span>
        }
<span class="nc" id="L467">        int m = 0;</span>
<span class="nc bnc" id="L468" title="All 2 branches missed.">        for (String feature : cliqueFeatures) {</span>
<span class="nc" id="L469">          int index = featureIndex.indexOf(feature);</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">          if (index &gt;= 0) {</span>
<span class="nc" id="L471">            data[j][k][m] = index;</span>
<span class="nc" id="L472">            m++;</span>
          } else {
            // this is where we end up when we do feature threshold cutoffs
          }
<span class="nc" id="L476">        }</span>

<span class="nc bnc" id="L478" title="All 2 branches missed.">        if (m &lt; data[j][k].length) {</span>
<span class="nc" id="L479">          int[] f = new int[m];</span>
<span class="nc" id="L480">          System.arraycopy(data[j][k], 0, f, 0, m);</span>
<span class="nc" id="L481">          data[j][k] = f;</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">          if (featureVals[j][k] != null) {</span>
<span class="nc" id="L483">            double[] fVal = new double[m];</span>
<span class="nc" id="L484">            System.arraycopy(featureVals[j][k], 0, fVal, 0, m);</span>
<span class="nc" id="L485">            featureVals[j][k] = fVal;</span>
          }
        }
      }

<span class="nc" id="L490">      IN wi = document.get(j);</span>
<span class="nc" id="L491">      labels[j] = classIndex.indexOf(wi.get(CoreAnnotations.AnswerAnnotation.class));</span>
    }

<span class="nc bnc" id="L494" title="All 2 branches missed.">    if (flags.useReverse) {</span>
<span class="nc" id="L495">      Collections.reverse(document);</span>
    }

<span class="nc" id="L498">    return new Triple&lt;&gt;(data, labels, featureVals);</span>
  }

  private int[][][] transformDocData(int[][][] docData) {
<span class="nc" id="L502">    int[][][] transData = new int[docData.length][][];</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">    for (int i = 0; i &lt; docData.length; i++) {</span>
<span class="nc" id="L504">      transData[i] = new int[docData[i].length][];</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">      for (int j = 0; j &lt; docData[i].length; j++) {</span>
<span class="nc" id="L506">        int[] cliqueFeatures = docData[i][j];</span>
<span class="nc" id="L507">        transData[i][j] = new int[cliqueFeatures.length];</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">        for (int n = 0; n &lt; cliqueFeatures.length; n++) {</span>
          int transFeatureIndex; // initialized below;
<span class="nc bnc" id="L510" title="All 2 branches missed.">          if (j == 0) {</span>
<span class="nc" id="L511">            transFeatureIndex = nodeFeatureIndicesMap.indexOf(cliqueFeatures[n]);</span>
<span class="nc bnc" id="L512" title="All 2 branches missed.">            if (transFeatureIndex == -1)</span>
<span class="nc" id="L513">              throw new RuntimeException(&quot;node cliqueFeatures[n]=&quot;+cliqueFeatures[n]+&quot; not found, nodeFeatureIndicesMap.size=&quot;+nodeFeatureIndicesMap.size());</span>
          } else {
<span class="nc" id="L515">            transFeatureIndex = edgeFeatureIndicesMap.indexOf(cliqueFeatures[n]);</span>
<span class="nc bnc" id="L516" title="All 2 branches missed.">            if (transFeatureIndex == -1)</span>
<span class="nc" id="L517">              throw new RuntimeException(&quot;edge cliqueFeatures[n]=&quot;+cliqueFeatures[n]+&quot; not found, edgeFeatureIndicesMap.size=&quot;+edgeFeatureIndicesMap.size());</span>
          }
<span class="nc" id="L519">          transData[i][j][n] = transFeatureIndex;</span>
        }
      }
    }
<span class="nc" id="L523">    return transData;</span>
  }

  public void printLabelInformation(String testFile, DocumentReaderAndWriter&lt;IN&gt; readerAndWriter) throws Exception {
<span class="nc" id="L527">    ObjectBank&lt;List&lt;IN&gt;&gt; documents = makeObjectBankFromFile(testFile, readerAndWriter);</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">    for (List&lt;IN&gt; document : documents) {</span>
<span class="nc" id="L529">      printLabelValue(document);</span>
<span class="nc" id="L530">    }</span>
<span class="nc" id="L531">  }</span>

  public void printLabelValue(List&lt;IN&gt; document) {
<span class="nc bnc" id="L534" title="All 2 branches missed.">    if (flags.useReverse) {</span>
<span class="nc" id="L535">      Collections.reverse(document);</span>
    }

<span class="nc" id="L538">    NumberFormat nf = new DecimalFormat();</span>

<span class="nc" id="L540">    List&lt;String&gt; classes = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">    for (int i = 0; i &lt; classIndex.size(); i++) {</span>
<span class="nc" id="L542">      classes.add(classIndex.get(i));</span>
    }
<span class="nc" id="L544">    String[] columnHeaders = classes.toArray(new String[classes.size()]);</span>

    // log.info(&quot;docSize:&quot;+docSize);
<span class="nc bnc" id="L547" title="All 2 branches missed.">    for (int j = 0; j &lt; document.size(); j++) {</span>

<span class="nc" id="L549">      System.out.println(&quot;--== &quot; + document.get(j).get(CoreAnnotations.TextAnnotation.class) + &quot; ==--&quot;);</span>

<span class="nc" id="L551">      List&lt;String[]&gt; lines = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L552">      List&lt;String&gt; rowHeaders = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L553">      List&lt;String&gt; line = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L555" title="All 2 branches missed.">      for (int p = 0; p &lt; labelIndices.size(); p++) {</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">        if (j + p &gt;= document.size()) {</span>
<span class="nc" id="L557">          continue;</span>
        }
<span class="nc" id="L559">        CRFDatum&lt;List&lt;String&gt;, CRFLabel&gt; d = makeDatum(document, j + p, featureFactories);</span>

<span class="nc" id="L561">        List&lt;List&lt;String&gt;&gt; features = d.asFeatures();</span>
<span class="nc bnc" id="L562" title="All 2 branches missed.">        for (int k = p, fSize = features.size(); k &lt; fSize; k++) {</span>
<span class="nc" id="L563">          Collection&lt;String&gt; cliqueFeatures = features.get(k);</span>
<span class="nc bnc" id="L564" title="All 2 branches missed.">          for (String feature : cliqueFeatures) {</span>
<span class="nc" id="L565">            int index = featureIndex.indexOf(feature);</span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">            if (index &gt;= 0) {</span>
              // line.add(feature+&quot;[&quot;+(-p)+&quot;]&quot;);
<span class="nc" id="L568">              rowHeaders.add(feature + '[' + (-p) + ']');</span>
<span class="nc" id="L569">              double[] values = new double[labelIndices.get(0).size()];</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">              for (CRFLabel label : labelIndices.get(k)) {</span>
<span class="nc" id="L571">                int[] l = label.getLabel();</span>
<span class="nc" id="L572">                double v = weights[index][labelIndices.get(k).indexOf(label)];</span>
<span class="nc" id="L573">                values[l[l.length - 1 - p]] += v;</span>
<span class="nc" id="L574">              }</span>
<span class="nc bnc" id="L575" title="All 2 branches missed.">              for (double value : values) {</span>
<span class="nc" id="L576">                line.add(nf.format(value));</span>
              }
<span class="nc" id="L578">              lines.add(line.toArray(new String[line.size()]));</span>
<span class="nc" id="L579">              line = new ArrayList&lt;&gt;();</span>
            }
<span class="nc" id="L581">          }</span>
        }
        // lines.add(Collections.&lt;String&gt;emptyList());
<span class="nc" id="L584">        System.out.println(StringUtils.makeTextTable(lines.toArray(new String[lines.size()][0]), rowHeaders</span>
<span class="nc" id="L585">                .toArray(new String[rowHeaders.size()]), columnHeaders, 0, 1, true));</span>
<span class="nc" id="L586">        System.out.println();</span>
      }
      // log.info(edu.stanford.nlp.util.StringUtils.join(lines,&quot;\n&quot;));
    }

<span class="nc bnc" id="L591" title="All 2 branches missed.">    if (flags.useReverse) {</span>
<span class="nc" id="L592">      Collections.reverse(document);</span>
    }
<span class="nc" id="L594">  }</span>

  /**
   * Convert an ObjectBank to arrays of data features and labels.
   * This version is used at training time.
   *
   * @return A Triple, where the first element is an int[][][][] representing the
   *         data, the second element is an int[][] representing the labels, and
   *         the third element is a double[][][][] representing the feature values
   *         which could be optionally left as null.
   */
  public Triple&lt;int[][][][], int[][], double[][][][]&gt; documentsToDataAndLabels(Collection&lt;List&lt;IN&gt;&gt; documents) {

    // first index is the number of the document
    // second index is position in the document also the index of the
    // clique/factor table
    // third index is the number of elements in the clique/window these features
    // are for (starting with last element)
    // fourth index is position of the feature in the array that holds them
    // element in data[i][j][k][m] is the index of the mth feature occurring in
    // position k of the jth clique of the ith document
    // int[][][][] data = new int[documentsSize][][][];
<span class="nc" id="L616">    List&lt;int[][][]&gt; data = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L617">    List&lt;double[][][]&gt; featureVal = new ArrayList&lt;&gt;();</span>

    // first index is the number of the document
    // second index is the position in the document
    // element in labels[i][j] is the index of the correct label (if it exists)
    // at position j in document i
    // int[][] labels = new int[documentsSize][];
<span class="nc" id="L624">    List&lt;int[]&gt; labels = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L626">    int numDatums = 0;</span>

<span class="nc bnc" id="L628" title="All 2 branches missed.">    for (List&lt;IN&gt; doc : documents) {</span>
<span class="nc" id="L629">      Triple&lt;int[][][], int[], double[][][]&gt; docTriple = documentToDataAndLabels(doc);</span>
<span class="nc" id="L630">      data.add(docTriple.first());</span>
<span class="nc" id="L631">      labels.add(docTriple.second());</span>
<span class="nc bnc" id="L632" title="All 2 branches missed.">      if (flags.useEmbedding)</span>
<span class="nc" id="L633">        featureVal.add(docTriple.third());</span>
<span class="nc" id="L634">      numDatums += doc.size();</span>
<span class="nc" id="L635">    }</span>

<span class="nc" id="L637">    log.info(&quot;numClasses: &quot; + classIndex.size() + ' ' + classIndex);</span>
<span class="nc" id="L638">    log.info(&quot;numDocuments: &quot; + data.size());</span>
<span class="nc" id="L639">    log.info(&quot;numDatums: &quot; + numDatums);</span>
<span class="nc" id="L640">    log.info(&quot;numFeatures: &quot; + featureIndex.size());</span>
<span class="nc" id="L641">    printFeatures();</span>

<span class="nc" id="L643">    double[][][][] featureValArr = null;</span>
<span class="nc bnc" id="L644" title="All 2 branches missed.">    if (flags.useEmbedding)</span>
<span class="nc" id="L645">      featureValArr = featureVal.toArray(new double[data.size()][][][]);</span>


<span class="nc" id="L648">    return new Triple&lt;&gt;(</span>
<span class="nc" id="L649">            data.toArray(new int[data.size()][][][]),</span>
<span class="nc" id="L650">            labels.toArray(new int[labels.size()][]),</span>
            featureValArr);
  }

  /**
   * Convert an ObjectBank to corresponding collection of data features and
   * labels. This version is used at test time.
   *
   * @return A List of pairs, one for each document, where the first element is
   *         an int[][][] representing the data and the second element is an
   *         int[] representing the labels.
   */
  public List&lt;Triple&lt;int[][][], int[], double[][][]&gt;&gt; documentsToDataAndLabelsList(Collection&lt;List&lt;IN&gt;&gt; documents) {
<span class="nc" id="L663">    int numDatums = 0;</span>

<span class="nc" id="L665">    List&lt;Triple&lt;int[][][], int[], double[][][]&gt;&gt; docList = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L666" title="All 2 branches missed.">    for (List&lt;IN&gt; doc : documents) {</span>
<span class="nc" id="L667">      Triple&lt;int[][][], int[], double[][][]&gt; docTriple = documentToDataAndLabels(doc);</span>
<span class="nc" id="L668">      docList.add(docTriple);</span>
<span class="nc" id="L669">      numDatums += doc.size();</span>
<span class="nc" id="L670">    }</span>

<span class="nc" id="L672">    log.info(&quot;numClasses: &quot; + classIndex.size() + ' ' + classIndex);</span>
<span class="nc" id="L673">    log.info(&quot;numDocuments: &quot; + docList.size());</span>
<span class="nc" id="L674">    log.info(&quot;numDatums: &quot; + numDatums);</span>
<span class="nc" id="L675">    log.info(&quot;numFeatures: &quot; + featureIndex.size());</span>
<span class="nc" id="L676">    return docList;</span>
  }

  protected void printFeatures() {
<span class="nc bnc" id="L680" title="All 2 branches missed.">    if (flags.printFeatures == null) {</span>
<span class="nc" id="L681">      return;</span>
    }
    try {
<span class="nc" id="L684">      String enc = flags.inputEncoding;</span>
<span class="nc bnc" id="L685" title="All 2 branches missed.">      if (flags.inputEncoding == null) {</span>
<span class="nc" id="L686">        log.info(&quot;flags.inputEncoding doesn't exist, using UTF-8 as default&quot;);</span>
<span class="nc" id="L687">        enc = &quot;UTF-8&quot;;</span>
      }

<span class="nc" id="L690">      PrintWriter pw = new PrintWriter(new OutputStreamWriter(new FileOutputStream(&quot;features-&quot; + flags.printFeatures</span>
          + &quot;.txt&quot;), enc), true);
<span class="nc bnc" id="L692" title="All 2 branches missed.">      for (String feat : featureIndex) {</span>
<span class="nc" id="L693">        pw.println(feat);</span>
<span class="nc" id="L694">      }</span>
<span class="nc" id="L695">      pw.close();</span>
<span class="nc" id="L696">    } catch (IOException ioe) {</span>
<span class="nc" id="L697">      ioe.printStackTrace();</span>
<span class="nc" id="L698">    }</span>
<span class="nc" id="L699">  }</span>

  /**
   * This routine builds the {@code labelIndices} which give the
   * empirically legal label sequences (of length (order) at most
   * {@code windowSize}) and the {@code classIndex}, which indexes
   * known answer classes.
   *
   * @param ob The training data: Read from an ObjectBank, each item in it is a
   *          {@code List&lt;CoreLabel&gt;}.
   */
  protected void makeAnswerArraysAndTagIndex(Collection&lt;List&lt;IN&gt;&gt; ob) {
<span class="nc bnc" id="L711" title="All 2 branches missed.">    boolean useFeatureCountThresh = flags.featureCountThresh &gt; 1;</span>

<span class="nc" id="L713">    Set&lt;String&gt;[] featureIndices = new HashSet[windowSize];</span>
<span class="nc" id="L714">    Map&lt;String, Integer&gt;[] featureCountIndices = null;</span>
<span class="nc bnc" id="L715" title="All 2 branches missed.">    for (int i = 0; i &lt; windowSize; i++) {</span>
<span class="nc" id="L716">      featureIndices[i] = Generics.newHashSet();</span>
    }
<span class="nc bnc" id="L718" title="All 2 branches missed.">    if (useFeatureCountThresh) {</span>
<span class="nc" id="L719">      featureCountIndices = new HashMap[windowSize];</span>
<span class="nc bnc" id="L720" title="All 2 branches missed.">      for (int i = 0; i &lt; windowSize; i++) {</span>
<span class="nc" id="L721">        featureCountIndices[i] = Generics.newHashMap();</span>
      }
    }

<span class="nc" id="L725">    labelIndices = new ArrayList&lt;&gt;(windowSize);</span>
<span class="nc bnc" id="L726" title="All 2 branches missed.">    for (int i = 0; i &lt; windowSize; i++) {</span>
<span class="nc" id="L727">      labelIndices.add(new HashIndex&lt;&gt;());</span>
    }

<span class="nc" id="L730">    Index&lt;CRFLabel&gt; labelIndex = labelIndices.get(windowSize - 1);</span>

<span class="nc bnc" id="L732" title="All 2 branches missed.">    if (classIndex == null)</span>
<span class="nc" id="L733">      classIndex = new HashIndex&lt;&gt;();</span>
    // classIndex.add(&quot;O&quot;);
<span class="nc" id="L735">    classIndex.add(flags.backgroundSymbol);</span>

<span class="nc" id="L737">    Set&lt;String&gt;[] seenBackgroundFeatures = new HashSet[2];</span>
<span class="nc" id="L738">    seenBackgroundFeatures[0] = Generics.newHashSet();</span>
<span class="nc" id="L739">    seenBackgroundFeatures[1] = Generics.newHashSet();</span>

<span class="nc" id="L741">    int wordCount = 0;</span>

<span class="nc bnc" id="L743" title="All 2 branches missed.">    if (flags.labelDictionaryCutoff &gt; 0) {</span>
<span class="nc" id="L744">      this.labelDictionary = new LabelDictionary();</span>
    }

<span class="nc bnc" id="L747" title="All 2 branches missed.">    for (List&lt;IN&gt; doc : ob) {</span>
<span class="nc bnc" id="L748" title="All 2 branches missed.">      if (flags.useReverse) {</span>
<span class="nc" id="L749">        Collections.reverse(doc);</span>
      }

      // create the full set of labels in classIndex
      // note: update to use addAll later
<span class="nc bnc" id="L754" title="All 2 branches missed.">      for (IN token : doc) {</span>
<span class="nc" id="L755">        wordCount++;</span>
<span class="nc" id="L756">        String ans = token.get(CoreAnnotations.AnswerAnnotation.class);</span>
<span class="nc bnc" id="L757" title="All 4 branches missed.">        if (ans == null || ans.isEmpty()) {</span>
<span class="nc" id="L758">          throw new IllegalArgumentException(&quot;Word &quot; + wordCount + &quot; (\&quot;&quot; + token.get(CoreAnnotations.TextAnnotation.class) + &quot;\&quot;) has a blank answer&quot;);</span>
        }
<span class="nc" id="L760">        classIndex.add(ans);</span>
<span class="nc bnc" id="L761" title="All 2 branches missed.">        if (labelDictionary != null) {</span>
<span class="nc" id="L762">          String observation = token.get(CoreAnnotations.TextAnnotation.class);</span>
<span class="nc" id="L763">          labelDictionary.increment(observation, ans);</span>
        }
<span class="nc" id="L765">      }</span>

<span class="nc bnc" id="L767" title="All 2 branches missed.">      for (int j = 0, docSize = doc.size(); j &lt; docSize; j++) {</span>
<span class="nc" id="L768">        CRFDatum&lt;List&lt;String&gt;, CRFLabel&gt; d = makeDatum(doc, j, featureFactories);</span>
<span class="nc" id="L769">        labelIndex.add(d.label());</span>

<span class="nc" id="L771">        List&lt;List&lt;String&gt;&gt; features = d.asFeatures();</span>
<span class="nc bnc" id="L772" title="All 2 branches missed.">        for (int k = 0, fSize = features.size(); k &lt; fSize; k++) {</span>
<span class="nc" id="L773">          Collection&lt;String&gt; cliqueFeatures = features.get(k);</span>
<span class="nc bnc" id="L774" title="All 4 branches missed.">          if (k &lt; 2 &amp;&amp; flags.removeBackgroundSingletonFeatures) {</span>
<span class="nc" id="L775">            String ans = doc.get(j).get(CoreAnnotations.AnswerAnnotation.class);</span>
<span class="nc" id="L776">            boolean background = ans.equals(flags.backgroundSymbol);</span>
<span class="nc bnc" id="L777" title="All 6 branches missed.">            if (k == 1 &amp;&amp; j &gt; 0 &amp;&amp; background) {</span>
<span class="nc" id="L778">              ans = doc.get(j - 1).get(CoreAnnotations.AnswerAnnotation.class);</span>
<span class="nc" id="L779">              background = ans.equals(flags.backgroundSymbol);</span>
            }
<span class="nc bnc" id="L781" title="All 2 branches missed.">            if (background) {</span>
<span class="nc bnc" id="L782" title="All 2 branches missed.">              for (String f : cliqueFeatures) {</span>
<span class="nc bnc" id="L783" title="All 2 branches missed.">                if (useFeatureCountThresh) {</span>
<span class="nc bnc" id="L784" title="All 2 branches missed.">                  if (!featureCountIndices[k].containsKey(f)) {</span>
<span class="nc bnc" id="L785" title="All 2 branches missed.">                    if (seenBackgroundFeatures[k].contains(f)) {</span>
<span class="nc" id="L786">                      seenBackgroundFeatures[k].remove(f);</span>
<span class="nc" id="L787">                      featureCountIndices[k].put(f, 1);</span>
                    } else {
<span class="nc" id="L789">                      seenBackgroundFeatures[k].add(f);</span>
                    }
                  }
                } else {
<span class="nc bnc" id="L793" title="All 2 branches missed.">                  if (!featureIndices[k].contains(f)) {</span>
<span class="nc bnc" id="L794" title="All 2 branches missed.">                    if (seenBackgroundFeatures[k].contains(f)) {</span>
<span class="nc" id="L795">                      seenBackgroundFeatures[k].remove(f);</span>
<span class="nc" id="L796">                      featureIndices[k].add(f);</span>
                    } else {
<span class="nc" id="L798">                      seenBackgroundFeatures[k].add(f);</span>
                    }
                  }
                }
<span class="nc" id="L802">              }</span>
            } else {
<span class="nc" id="L804">              seenBackgroundFeatures[k].removeAll(cliqueFeatures);</span>
<span class="nc bnc" id="L805" title="All 2 branches missed.">              if (useFeatureCountThresh) {</span>
<span class="nc" id="L806">                Map&lt;String, Integer&gt; fCountIndex = featureCountIndices[k];</span>
<span class="nc bnc" id="L807" title="All 2 branches missed.">                for (String f: cliqueFeatures) {</span>
<span class="nc bnc" id="L808" title="All 2 branches missed.">                  if (fCountIndex.containsKey(f))</span>
<span class="nc" id="L809">                    fCountIndex.put(f, fCountIndex.get(f)+1);</span>
                  else
<span class="nc" id="L811">                    fCountIndex.put(f, 1);</span>
<span class="nc" id="L812">                }</span>
<span class="nc" id="L813">              } else {</span>
<span class="nc" id="L814">                featureIndices[k].addAll(cliqueFeatures);</span>
              }
            }
<span class="nc" id="L817">          } else {</span>
<span class="nc bnc" id="L818" title="All 2 branches missed.">            if (useFeatureCountThresh) {</span>
<span class="nc" id="L819">              Map&lt;String, Integer&gt; fCountIndex = featureCountIndices[k];</span>
<span class="nc bnc" id="L820" title="All 2 branches missed.">              for (String f: cliqueFeatures) {</span>
<span class="nc bnc" id="L821" title="All 2 branches missed.">                if (fCountIndex.containsKey(f))</span>
<span class="nc" id="L822">                  fCountIndex.put(f, fCountIndex.get(f)+1);</span>
                else
<span class="nc" id="L824">                  fCountIndex.put(f, 1);</span>
<span class="nc" id="L825">              }</span>
<span class="nc" id="L826">            } else {</span>
<span class="nc" id="L827">              featureIndices[k].addAll(cliqueFeatures);</span>
            }
          }
        }
      }

<span class="nc bnc" id="L833" title="All 2 branches missed.">      if (flags.useReverse) {</span>
<span class="nc" id="L834">        Collections.reverse(doc);</span>
      }
<span class="nc" id="L836">    }</span>

<span class="nc bnc" id="L838" title="All 2 branches missed.">    if (useFeatureCountThresh) {</span>
<span class="nc" id="L839">      int numFeatures = 0;</span>
<span class="nc bnc" id="L840" title="All 2 branches missed.">      for (int i = 0; i &lt; windowSize; i++) {</span>
<span class="nc" id="L841">        numFeatures += featureCountIndices[i].size();</span>
      }
<span class="nc" id="L843">      log.info(&quot;Before feature count thresholding, numFeatures = &quot; + numFeatures);</span>
<span class="nc bnc" id="L844" title="All 2 branches missed.">      for (int i = 0; i &lt; windowSize; i++) {</span>
<span class="nc bnc" id="L845" title="All 2 branches missed.">        for(Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; it = featureCountIndices[i].entrySet().iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L846">          Map.Entry&lt;String, Integer&gt; entry = it.next();</span>
<span class="nc bnc" id="L847" title="All 2 branches missed.">          if(entry.getValue() &lt; flags.featureCountThresh) {</span>
<span class="nc" id="L848">            it.remove();</span>
          }
<span class="nc" id="L850">        }</span>
<span class="nc" id="L851">        featureIndices[i].addAll(featureCountIndices[i].keySet());</span>
<span class="nc" id="L852">        featureCountIndices[i] = null;</span>
      }
    }

<span class="nc" id="L856">    int numFeatures = 0;</span>
<span class="nc bnc" id="L857" title="All 2 branches missed.">    for (int i = 0; i &lt; windowSize; i++) {</span>
<span class="nc" id="L858">      numFeatures += featureIndices[i].size();</span>
    }
<span class="nc" id="L860">    log.info(&quot;numFeatures = &quot; + numFeatures);</span>

<span class="nc" id="L862">    featureIndex = new HashIndex&lt;&gt;();</span>
<span class="nc" id="L863">    map = new int[numFeatures];</span>

<span class="nc bnc" id="L865" title="All 2 branches missed.">    if (flags.groupByFeatureTemplate) {</span>
<span class="nc" id="L866">      templateGroupIndex = new HashIndex&lt;&gt;();</span>
<span class="nc" id="L867">      featureIndexToTemplateIndex = new HashMap&lt;&gt;();</span>
    }

<span class="nc bnc" id="L870" title="All 2 branches missed.">    for (int i = 0; i &lt; windowSize; i++) {</span>
<span class="nc" id="L871">      Index&lt;Integer&gt; featureIndexMap = new HashIndex&lt;&gt;();</span>

<span class="nc" id="L873">      featureIndex.addAll(featureIndices[i]);</span>
<span class="nc bnc" id="L874" title="All 2 branches missed.">      for (String str : featureIndices[i]) {</span>
<span class="nc" id="L875">        int index = featureIndex.indexOf(str);</span>
<span class="nc" id="L876">        map[index] = i;</span>
<span class="nc" id="L877">        featureIndexMap.add(index);</span>

        // grouping features by template
<span class="nc bnc" id="L880" title="All 2 branches missed.">        if (flags.groupByFeatureTemplate) {</span>
<span class="nc" id="L881">          Matcher m = suffixPatt.matcher(str);</span>
<span class="nc" id="L882">          String groupSuffix = &quot;NoTemplate&quot;;</span>
<span class="nc bnc" id="L883" title="All 2 branches missed.">          if (m.matches()) {</span>
<span class="nc" id="L884">            groupSuffix = m.group(1);</span>
          }
<span class="nc" id="L886">          groupSuffix += &quot;-c:&quot;+i;</span>

<span class="nc" id="L888">          int groupIndex = templateGroupIndex.addToIndex(groupSuffix);</span>
<span class="nc" id="L889">          featureIndexToTemplateIndex.put(index, groupIndex);</span>
        }
<span class="nc" id="L891">      }</span>
      // todo [cdm 2014]: Talk to Mengqiu about this; it seems like it only supports first order CRF
<span class="nc bnc" id="L893" title="All 2 branches missed.">      if (i == 0) {</span>
<span class="nc" id="L894">        nodeFeatureIndicesMap = featureIndexMap;</span>
        // log.info(&quot;setting nodeFeatureIndicesMap, size=&quot;+nodeFeatureIndicesMap.size());
      } else {
<span class="nc" id="L897">        edgeFeatureIndicesMap = featureIndexMap;</span>
        // log.info(&quot;setting edgeFeatureIndicesMap, size=&quot;+edgeFeatureIndicesMap.size());
      }
    }

<span class="nc bnc" id="L902" title="All 2 branches missed.">    if (flags.numOfFeatureSlices &gt; 0) {</span>
<span class="nc" id="L903">      log.info(&quot;Taking &quot; + flags.numOfFeatureSlices + &quot; out of &quot; + flags.totalFeatureSlice + &quot; slices of node features for training&quot;);</span>
<span class="nc" id="L904">      pruneNodeFeatureIndices(flags.totalFeatureSlice, flags.numOfFeatureSlices);</span>
    }

<span class="nc bnc" id="L907" title="All 2 branches missed.">    if (flags.useObservedSequencesOnly) {</span>
<span class="nc bnc" id="L908" title="All 2 branches missed.">      for (int i = 0, liSize = labelIndex.size(); i &lt; liSize; i++) {</span>
<span class="nc" id="L909">        CRFLabel label = labelIndex.get(i);</span>
<span class="nc bnc" id="L910" title="All 2 branches missed.">        for (int j = windowSize - 2; j &gt;= 0; j--) {</span>
<span class="nc" id="L911">          label = label.getOneSmallerLabel();</span>
<span class="nc" id="L912">          labelIndices.get(j).add(label);</span>
        }
      }
    } else {
<span class="nc bnc" id="L916" title="All 2 branches missed.">      for (int i = 0; i &lt; labelIndices.size(); i++) {</span>
<span class="nc" id="L917">        labelIndices.set(i, allLabels(i + 1, classIndex));</span>
      }
    }

    if (VERBOSE) {
      for (int i = 0, fiSize = featureIndex.size(); i &lt; fiSize; i++) {
        System.out.println(i + &quot;: &quot; + featureIndex.get(i));
      }
    }
<span class="nc bnc" id="L926" title="All 2 branches missed.">    if (labelDictionary != null) {</span>
<span class="nc" id="L927">      labelDictionary.lock(flags.labelDictionaryCutoff, classIndex);</span>
    }
<span class="nc" id="L929">  }</span>

  protected static Index&lt;CRFLabel&gt; allLabels(int window, Index&lt;String&gt; classIndex) {
<span class="nc" id="L932">    int[] label = new int[window];</span>
    // cdm 2005: array initialization isn't necessary: JLS (3rd ed.) 4.12.5
    // Arrays.fill(label, 0);
<span class="nc" id="L935">    int numClasses = classIndex.size();</span>
<span class="nc" id="L936">    Index&lt;CRFLabel&gt; labelIndex = new HashIndex&lt;&gt;();</span>
    OUTER: while (true) {
<span class="nc" id="L938">      CRFLabel l = new CRFLabel(label);</span>
<span class="nc" id="L939">      labelIndex.add(l);</span>
<span class="nc" id="L940">      int[] label1 = new int[window];</span>
<span class="nc" id="L941">      System.arraycopy(label, 0, label1, 0, label.length);</span>
<span class="nc" id="L942">      label = label1;</span>
<span class="nc bnc" id="L943" title="All 2 branches missed.">      for (int j = 0; j &lt; label.length; j++) {</span>
<span class="nc" id="L944">        label[j]++;</span>
<span class="nc bnc" id="L945" title="All 2 branches missed.">        if (label[j] &gt;= numClasses) {</span>
<span class="nc" id="L946">          label[j] = 0;</span>
<span class="nc bnc" id="L947" title="All 2 branches missed.">          if (j == label.length - 1) {</span>
<span class="nc" id="L948">            break OUTER;</span>
          }
        } else {
          break;
        }
      }
<span class="nc" id="L954">    }</span>
<span class="nc" id="L955">    return labelIndex;</span>
  }

  /**
   * Makes a CRFDatum by producing features and a label from input data at a
   * specific position, using the provided factory.
   *
   * @param info The input data. Particular feature factories might look for arbitrary keys in the IN items.
   * @param loc The position to build a datum at
   * @param featureFactories The FeatureFactories to use to extract features
   * @return The constructed CRFDatum
   */
  public CRFDatum&lt;List&lt;String&gt;, CRFLabel&gt; makeDatum(List&lt;IN&gt; info, int loc,
                                                    List&lt;FeatureFactory&lt;IN&gt;&gt; featureFactories) {
    // pad.set(CoreAnnotations.AnswerAnnotation.class, flags.backgroundSymbol); // cdm: isn't this unnecessary, as this is how it's initialized in AbstractSequenceClassifier.reinit?
<span class="nc" id="L970">    PaddedList&lt;IN&gt; pInfo = new PaddedList&lt;&gt;(info, pad);</span>

<span class="nc" id="L972">    ArrayList&lt;List&lt;String&gt;&gt; features = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L973">    List&lt;double[]&gt; featureVals = new ArrayList&lt;&gt;();</span>

    // for (int i = 0; i &lt; windowSize; i++) {
    // List featuresC = new ArrayList();
    // for (int j = 0; j &lt; FeatureFactory.win[i].length; j++) {
    // featuresC.addAll(featureFactory.features(info, loc,
    // FeatureFactory.win[i][j]));
    // }
    // features.add(featuresC);
    // }

    // todo [cdm Aug 2012]: Since getCliques returns all cliques within its bounds, can't the for loop here be eliminated? But my first attempt to removed failed to produce identical results....
<span class="nc" id="L985">    Collection&lt;Clique&gt; done = Generics.newHashSet();</span>
<span class="nc bnc" id="L986" title="All 2 branches missed.">    for (int i = 0; i &lt; windowSize; i++) {</span>
<span class="nc" id="L987">      List&lt;String&gt; featuresC = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L988">      List&lt;Clique&gt; windowCliques = FeatureFactory.getCliques(i, 0);</span>
<span class="nc" id="L989">      windowCliques.removeAll(done);</span>
<span class="nc" id="L990">      done.addAll(windowCliques);</span>
<span class="nc" id="L991">      double[] featureValArr = null;</span>
<span class="nc bnc" id="L992" title="All 4 branches missed.">      if (flags.useEmbedding &amp;&amp; i == 0) { // only activated for node features</span>
<span class="nc" id="L993">        featureValArr = makeDatumUsingEmbedding(info, loc, featureFactories, pInfo, featuresC, windowCliques);</span>
      } else {
<span class="nc bnc" id="L995" title="All 2 branches missed.">        for (Clique c : windowCliques) {</span>
<span class="nc bnc" id="L996" title="All 2 branches missed.">          for (FeatureFactory featureFactory : featureFactories) {</span>
<span class="nc" id="L997">            featuresC.addAll(featureFactory.getCliqueFeatures(pInfo, loc, c)); //todo useless copy because of typing reasons</span>
<span class="nc" id="L998">          }</span>
<span class="nc" id="L999">        }</span>
      }
<span class="nc" id="L1001">      features.add(featuresC);</span>
<span class="nc" id="L1002">      featureVals.add(featureValArr);</span>
    }

<span class="nc" id="L1005">    int[] labels = new int[windowSize];</span>

<span class="nc bnc" id="L1007" title="All 2 branches missed.">    for (int i = 0; i &lt; windowSize; i++) {</span>
<span class="nc" id="L1008">      String answer = pInfo.get(loc + i - windowSize + 1).get(CoreAnnotations.AnswerAnnotation.class);</span>
<span class="nc" id="L1009">      labels[i] = classIndex.indexOf(answer);</span>
    }

<span class="nc" id="L1012">    printFeatureLists(pInfo.get(loc), features);</span>

<span class="nc" id="L1014">    CRFDatum&lt;List&lt;String&gt;, CRFLabel&gt; d = new CRFDatum&lt;&gt;(features, new CRFLabel(labels), featureVals);</span>
    // log.info(d);
<span class="nc" id="L1016">    return d;</span>
  }

  private double[] makeDatumUsingEmbedding(List&lt;IN&gt; info, int loc, List&lt;FeatureFactory&lt;IN&gt;&gt; featureFactories, PaddedList&lt;IN&gt; pInfo, List&lt;String&gt; featuresC, List&lt;Clique&gt; windowCliques) {
    double[] featureValArr;
<span class="nc" id="L1021">    List&lt;double[]&gt; embeddingList = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1022">    int concatEmbeddingLen = 0;</span>
<span class="nc" id="L1023">    String currentWord = null;</span>
<span class="nc bnc" id="L1024" title="All 2 branches missed.">    for (int currLoc = loc-2; currLoc &lt;= loc+2; currLoc++) {</span>
      double[] embedding; // Initialized in cases below // = null;
<span class="nc bnc" id="L1026" title="All 4 branches missed.">      if (currLoc &gt;=0 &amp;&amp; currLoc &lt; info.size()) {</span>
<span class="nc" id="L1027">        currentWord = info.get(loc).get(CoreAnnotations.TextAnnotation.class);</span>
<span class="nc" id="L1028">        String word = currentWord.toLowerCase();</span>
<span class="nc" id="L1029">        word = word.replaceAll(&quot;(-)?\\d+(\\.\\d*)?&quot;, &quot;0&quot;);</span>
<span class="nc bnc" id="L1030" title="All 2 branches missed.">        if (embeddings.containsKey(word))</span>
<span class="nc" id="L1031">          embedding = embeddings.get(word);</span>
        else
<span class="nc" id="L1033">          embedding = embeddings.get(&quot;UNKNOWN&quot;);</span>
<span class="nc" id="L1034">      } else {</span>
<span class="nc" id="L1035">        embedding = embeddings.get(&quot;PADDING&quot;);</span>
      }

<span class="nc bnc" id="L1038" title="All 2 branches missed.">      for (int e = 0; e &lt; embedding.length; e++) {</span>
<span class="nc" id="L1039">        featuresC.add(&quot;EMBEDDING-(&quot; + (currLoc-loc) + &quot;)-&quot; + e);</span>
      }

<span class="nc bnc" id="L1042" title="All 2 branches missed.">      if (flags.addCapitalFeatures) {</span>
<span class="nc" id="L1043">        int numOfCapitalFeatures = 4;</span>
<span class="nc" id="L1044">        double[] newEmbedding = new double[embedding.length + numOfCapitalFeatures];</span>
<span class="nc" id="L1045">        int currLen = embedding.length;</span>
<span class="nc" id="L1046">        System.arraycopy(embedding, 0, newEmbedding, 0, currLen);</span>
<span class="nc bnc" id="L1047" title="All 2 branches missed.">        for (int e = 0; e &lt; numOfCapitalFeatures; e++)</span>
<span class="nc" id="L1048">          featuresC.add(&quot;CAPITAL-(&quot; + (currLoc-loc) + &quot;)-&quot; + e);</span>

<span class="nc bnc" id="L1050" title="All 4 branches missed.">        if (currLoc &gt;=0 &amp;&amp; currLoc &lt; info.size()) { // skip PADDING</span>
          // check if word is all caps
<span class="nc bnc" id="L1052" title="All 2 branches missed.">          if (currentWord.toUpperCase().equals(currentWord))</span>
<span class="nc" id="L1053">            newEmbedding[currLen] = 1;</span>
          else {
<span class="nc" id="L1055">            currLen += 1;</span>
            // check if word is all lower
<span class="nc bnc" id="L1057" title="All 2 branches missed.">            if (currentWord.toLowerCase().equals(currentWord))</span>
<span class="nc" id="L1058">              newEmbedding[currLen] = 1;</span>
            else {
<span class="nc" id="L1060">              currLen += 1;</span>
              // check first letter cap
<span class="nc bnc" id="L1062" title="All 2 branches missed.">              if (Character.isUpperCase(currentWord.charAt(0)))</span>
<span class="nc" id="L1063">                newEmbedding[currLen] = 1;</span>
              else {
<span class="nc" id="L1065">                currLen += 1;</span>
                // check if at least one non-initial letter is cap
<span class="nc" id="L1067">                String remainder = currentWord.substring(1);</span>
<span class="nc bnc" id="L1068" title="All 2 branches missed.">                if (!remainder.toLowerCase().equals(remainder))</span>
<span class="nc" id="L1069">                  newEmbedding[currLen] = 1;</span>
              }
            }
          }
        }
<span class="nc" id="L1074">        embedding = newEmbedding;</span>
      }

<span class="nc" id="L1077">      embeddingList.add(embedding);</span>
<span class="nc" id="L1078">      concatEmbeddingLen += embedding.length;</span>
    }
<span class="nc" id="L1080">    double[] concatEmbedding = new double[concatEmbeddingLen];</span>
<span class="nc" id="L1081">    int currPos = 0;</span>
<span class="nc bnc" id="L1082" title="All 2 branches missed.">    for (double[] em: embeddingList) {</span>
<span class="nc" id="L1083">      System.arraycopy(em, 0, concatEmbedding, currPos, em.length);</span>
<span class="nc" id="L1084">      currPos += em.length;</span>
<span class="nc" id="L1085">    }</span>

<span class="nc bnc" id="L1087" title="All 2 branches missed.">    if (flags.prependEmbedding) {</span>
<span class="nc" id="L1088">      int additionalFeatureCount = 0;</span>
<span class="nc bnc" id="L1089" title="All 2 branches missed.">      for (Clique c : windowCliques) {</span>
<span class="nc bnc" id="L1090" title="All 2 branches missed.">        for (FeatureFactory featureFactory : featureFactories) {</span>
<span class="nc" id="L1091">          Collection&lt;String&gt; fCol = featureFactory.getCliqueFeatures(pInfo, loc, c); //todo useless copy because of typing reasons</span>
<span class="nc" id="L1092">          featuresC.addAll(fCol);</span>
<span class="nc" id="L1093">          additionalFeatureCount += fCol.size();</span>
<span class="nc" id="L1094">        }</span>
<span class="nc" id="L1095">      }</span>
<span class="nc" id="L1096">      featureValArr = new double[concatEmbedding.length + additionalFeatureCount];</span>
<span class="nc" id="L1097">      System.arraycopy(concatEmbedding, 0, featureValArr, 0, concatEmbedding.length);</span>
<span class="nc" id="L1098">      Arrays.fill(featureValArr, concatEmbedding.length, featureValArr.length, 1.0);</span>
<span class="nc" id="L1099">    } else {</span>
<span class="nc" id="L1100">      featureValArr = concatEmbedding;</span>
    }

<span class="nc bnc" id="L1103" title="All 2 branches missed.">    if (flags.addBiasToEmbedding) {</span>
<span class="nc" id="L1104">      featuresC.add(&quot;BIAS-FEATURE&quot;);</span>
<span class="nc" id="L1105">      double[] newFeatureValArr = new double[featureValArr.length + 1];</span>
<span class="nc" id="L1106">      System.arraycopy(featureValArr, 0, newFeatureValArr, 0, featureValArr.length);</span>
<span class="nc" id="L1107">      newFeatureValArr[newFeatureValArr.length-1] = 1;</span>
<span class="nc" id="L1108">      featureValArr = newFeatureValArr;</span>
    }
<span class="nc" id="L1110">    return featureValArr;</span>
  }

  @Override
  public void dumpFeatures(Collection&lt;List&lt;IN&gt;&gt; docs) {
<span class="nc bnc" id="L1115" title="All 2 branches missed.">    if (flags.exportFeatures != null) {</span>
<span class="nc" id="L1116">      Timing timer = new Timing();</span>
<span class="nc" id="L1117">      CRFFeatureExporter&lt;IN&gt; featureExporter = new CRFFeatureExporter&lt;&gt;(this);</span>
<span class="nc" id="L1118">      featureExporter.printFeatures(flags.exportFeatures, docs);</span>
<span class="nc" id="L1119">      long elapsedMs = timer.stop();</span>
<span class="nc" id="L1120">      log.info(&quot;Time to export features: &quot; + Timing.toSecondsString(elapsedMs) + &quot; seconds&quot;);</span>
    }
<span class="nc" id="L1122">  }</span>

  @Override
  public List&lt;IN&gt; classify(List&lt;IN&gt; document) {
<span class="nc bnc" id="L1126" title="All 2 branches missed.">    if (flags.doGibbs) {</span>
      try {
<span class="nc" id="L1128">        return classifyGibbs(document);</span>
<span class="nc" id="L1129">      } catch (Exception e) {</span>
<span class="nc" id="L1130">        throw new RuntimeException(&quot;Error running testGibbs inference!&quot;, e);</span>
      }
<span class="nc bnc" id="L1132" title="All 2 branches missed.">    } else if (flags.crfType.equalsIgnoreCase(&quot;maxent&quot;)) {</span>
<span class="nc" id="L1133">      return classifyMaxEnt(document);</span>
    } else {
<span class="nc" id="L1135">      throw new RuntimeException(&quot;Unsupported inference type: &quot; + flags.crfType);</span>
    }
  }

  private List&lt;IN&gt; classify(List&lt;IN&gt; document, Triple&lt;int[][][], int[], double[][][]&gt; documentDataAndLabels) {
<span class="nc bnc" id="L1140" title="All 2 branches missed.">    if (flags.doGibbs) {</span>
      try {
<span class="nc" id="L1142">        return classifyGibbs(document, documentDataAndLabels);</span>
<span class="nc" id="L1143">      } catch (Exception e) {</span>
<span class="nc" id="L1144">        throw new RuntimeException(&quot;Error running testGibbs inference!&quot;, e);</span>
      }
<span class="nc bnc" id="L1146" title="All 2 branches missed.">    } else if (flags.crfType.equalsIgnoreCase(&quot;maxent&quot;)) {</span>
<span class="nc" id="L1147">      return classifyMaxEnt(document, documentDataAndLabels);</span>
    } else {
<span class="nc" id="L1149">      throw new RuntimeException(&quot;Unsupported inference type: &quot; + flags.crfType);</span>
    }
  }

  /**
   * This method is supposed to be used by CRFClassifierEvaluator only, should not have global visibility.
   * The generic {@code classifyAndWriteAnswers} omits the second argument {@code documentDataAndLabels}.
   */
  void classifyAndWriteAnswers(Collection&lt;List&lt;IN&gt;&gt; documents,
                                      List&lt;Triple&lt;int[][][], int[], double[][][]&gt;&gt; documentDataAndLabels,
                                      PrintWriter printWriter,
                                      DocumentReaderAndWriter&lt;IN&gt; readerAndWriter) throws IOException {
<span class="nc" id="L1161">    Timing timer = new Timing();</span>

<span class="nc" id="L1163">    Counter&lt;String&gt; entityTP = new ClassicCounter&lt;&gt;();</span>
<span class="nc" id="L1164">    Counter&lt;String&gt; entityFP = new ClassicCounter&lt;&gt;();</span>
<span class="nc" id="L1165">    Counter&lt;String&gt; entityFN = new ClassicCounter&lt;&gt;();</span>
<span class="nc" id="L1166">    boolean resultsCounted = true;</span>

<span class="nc" id="L1168">    int numWords = 0;</span>
<span class="nc" id="L1169">    int numDocs = 0;</span>
<span class="nc bnc" id="L1170" title="All 2 branches missed.">    for (List&lt;IN&gt; doc : documents) {</span>
<span class="nc" id="L1171">      classify(doc, documentDataAndLabels.get(numDocs));</span>
<span class="nc" id="L1172">      numWords += doc.size();</span>
<span class="nc" id="L1173">      writeAnswers(doc, printWriter, readerAndWriter);</span>
<span class="nc bnc" id="L1174" title="All 4 branches missed.">      resultsCounted = resultsCounted &amp;&amp; countResults(doc, entityTP, entityFP, entityFN);</span>
<span class="nc" id="L1175">      numDocs++;</span>
<span class="nc" id="L1176">    }</span>
<span class="nc" id="L1177">    long millis = timer.stop();</span>
<span class="nc" id="L1178">    double wordspersec = numWords / (((double) millis) / 1000);</span>
<span class="nc" id="L1179">    NumberFormat nf = new DecimalFormat(&quot;0.00&quot;); // easier way!</span>
<span class="nc bnc" id="L1180" title="All 2 branches missed.">    if (!flags.suppressTestDebug)</span>
<span class="nc" id="L1181">      log.info(StringUtils.getShortClassName(this) + &quot; tagged &quot; + numWords + &quot; words in &quot; + numDocs</span>
<span class="nc" id="L1182">        + &quot; documents at &quot; + nf.format(wordspersec) + &quot; words per second.&quot;);</span>
<span class="nc bnc" id="L1183" title="All 4 branches missed.">    if (resultsCounted &amp;&amp; ! flags.suppressTestDebug) {</span>
<span class="nc" id="L1184">      printResults(entityTP, entityFP, entityFN);</span>
    }
<span class="nc" id="L1186">  }</span>

  @Override
  public SequenceModel getSequenceModel(List&lt;IN&gt; doc) {
<span class="nc" id="L1190">    Triple&lt;int[][][], int[], double[][][]&gt; p = documentToDataAndLabels(doc);</span>
<span class="nc" id="L1191">    return getSequenceModel(p, doc);</span>
  }

  private SequenceModel getSequenceModel(Triple&lt;int[][][], int[], double[][][]&gt; documentDataAndLabels, List&lt;IN&gt; document) {
<span class="nc bnc" id="L1195" title="All 2 branches missed.">    return labelDictionary == null ? new TestSequenceModel(getCliqueTree(documentDataAndLabels)) :</span>
<span class="nc" id="L1196">      new TestSequenceModel(getCliqueTree(documentDataAndLabels), labelDictionary, document);</span>
  }

  protected CliquePotentialFunction getCliquePotentialFunctionForTest() {
<span class="nc bnc" id="L1200" title="All 2 branches missed.">    if (cliquePotentialFunction == null) {</span>
<span class="nc" id="L1201">      cliquePotentialFunction = new LinearCliquePotentialFunction(weights);</span>
    }
<span class="nc" id="L1203">    return cliquePotentialFunction;</span>
  }

  public void updateWeightsForTest(double[] x) {
<span class="nc" id="L1207">    cliquePotentialFunction = cliquePotentialFunctionHelper.getCliquePotentialFunction(x);</span>
<span class="nc" id="L1208">  }</span>

  /**
   * Do standard sequence inference, using either Viterbi or Beam inference
   * depending on the value of {@code flags.inferenceType}.
   *
   * @param document Document to classify. Classification happens in place.
   *          This document is modified.
   * @return The classified document
   */
  public List&lt;IN&gt; classifyMaxEnt(List&lt;IN&gt; document) {
<span class="nc bnc" id="L1219" title="All 2 branches missed.">    if (document.isEmpty()) {</span>
<span class="nc" id="L1220">      return document;</span>
    }

<span class="nc" id="L1223">    SequenceModel model = getSequenceModel(document);</span>
<span class="nc" id="L1224">    return classifyMaxEnt(document, model);</span>
  }

  private List&lt;IN&gt; classifyMaxEnt(List&lt;IN&gt; document, Triple&lt;int[][][], int[], double[][][]&gt; documentDataAndLabels) {
<span class="nc bnc" id="L1228" title="All 2 branches missed.">    if (document.isEmpty()) {</span>
<span class="nc" id="L1229">      return document;</span>
    }
<span class="nc" id="L1231">    SequenceModel model = getSequenceModel(documentDataAndLabels, document);</span>
<span class="nc" id="L1232">    return classifyMaxEnt(document, model);</span>
  }

  private List&lt;IN&gt; classifyMaxEnt(List&lt;IN&gt; document, SequenceModel model) {
<span class="nc bnc" id="L1236" title="All 2 branches missed.">    if (document.isEmpty()) {</span>
<span class="nc" id="L1237">      return document;</span>
    }

<span class="nc bnc" id="L1240" title="All 2 branches missed.">    if (flags.inferenceType == null) {</span>
<span class="nc" id="L1241">      flags.inferenceType = &quot;Viterbi&quot;;</span>
    }

    BestSequenceFinder tagInference;
<span class="nc bnc" id="L1245" title="All 2 branches missed.">    if (flags.inferenceType.equalsIgnoreCase(&quot;Viterbi&quot;)) {</span>
<span class="nc" id="L1246">      tagInference = new ExactBestSequenceFinder();</span>
<span class="nc bnc" id="L1247" title="All 2 branches missed.">    } else if (flags.inferenceType.equalsIgnoreCase(&quot;Beam&quot;)) {</span>
<span class="nc" id="L1248">      tagInference = new BeamBestSequenceFinder(flags.beamSize);</span>
    } else {
<span class="nc" id="L1250">      throw new RuntimeException(&quot;Unknown inference type: &quot; + flags.inferenceType + &quot;. Your options are Viterbi|Beam.&quot;);</span>
    }

<span class="nc" id="L1253">    int[] bestSequence = tagInference.bestSequence(model);</span>

<span class="nc bnc" id="L1255" title="All 2 branches missed.">    if (flags.useReverse) {</span>
<span class="nc" id="L1256">      Collections.reverse(document);</span>
    }
<span class="nc bnc" id="L1258" title="All 2 branches missed.">    for (int j = 0, docSize = document.size(); j &lt; docSize; j++) {</span>
<span class="nc" id="L1259">      IN wi = document.get(j);</span>
<span class="nc" id="L1260">      String guess = classIndex.get(bestSequence[j + windowSize - 1]);</span>
<span class="nc" id="L1261">      wi.set(CoreAnnotations.AnswerAnnotation.class, guess);</span>
    }
<span class="nc bnc" id="L1263" title="All 2 branches missed.">    if (flags.useReverse) {</span>
<span class="nc" id="L1264">      Collections.reverse(document);</span>
    }
<span class="nc" id="L1266">    return document;</span>
  }

  public List&lt;IN&gt; classifyGibbs(List&lt;IN&gt; document) throws ClassNotFoundException, SecurityException,
      NoSuchMethodException, IllegalArgumentException, InstantiationException, IllegalAccessException,
      InvocationTargetException {
<span class="nc" id="L1272">    Triple&lt;int[][][], int[], double[][][]&gt; p = documentToDataAndLabels(document);</span>
<span class="nc" id="L1273">    return classifyGibbs(document, p);</span>
  }

  public List&lt;IN&gt; classifyGibbs(List&lt;IN&gt; document, Triple&lt;int[][][], int[], double[][][]&gt; documentDataAndLabels)
      throws ClassNotFoundException, SecurityException, NoSuchMethodException, IllegalArgumentException,
      InstantiationException, IllegalAccessException, InvocationTargetException {
    // log.info(&quot;Testing using Gibbs sampling.&quot;);
<span class="nc" id="L1280">    List&lt;IN&gt; newDocument = document; // reversed if necessary</span>
<span class="nc bnc" id="L1281" title="All 2 branches missed.">    if (flags.useReverse) {</span>
<span class="nc" id="L1282">      Collections.reverse(document);</span>
<span class="nc" id="L1283">      newDocument = new ArrayList&lt;&gt;(document);</span>
<span class="nc" id="L1284">      Collections.reverse(document);</span>
    }

<span class="nc" id="L1287">    CRFCliqueTree&lt;? extends CharSequence&gt; cliqueTree = getCliqueTree(documentDataAndLabels);</span>

<span class="nc" id="L1289">    PriorModelFactory&lt;IN&gt; pmf = (PriorModelFactory&lt;IN&gt;) Class.forName(flags.priorModelFactory).newInstance();</span>
<span class="nc" id="L1290">    ListeningSequenceModel prior = pmf.getInstance(flags.backgroundSymbol, classIndex, tagIndex, newDocument, entityMatrices, flags);</span>

<span class="nc bnc" id="L1292" title="All 2 branches missed.">    if ( ! flags.useUniformPrior) {</span>
<span class="nc" id="L1293">      throw new RuntimeException(&quot;no prior specified&quot;);</span>
    }

<span class="nc" id="L1296">    SequenceModel model = new FactoredSequenceModel(cliqueTree, prior);</span>
<span class="nc" id="L1297">    SequenceListener listener = new FactoredSequenceListener(cliqueTree, prior);</span>

<span class="nc" id="L1299">    SequenceGibbsSampler sampler = new SequenceGibbsSampler(0, 0, listener);</span>
<span class="nc" id="L1300">    int[] sequence = new int[cliqueTree.length()];</span>

<span class="nc bnc" id="L1302" title="All 2 branches missed.">    if (flags.initViterbi) {</span>
<span class="nc" id="L1303">      TestSequenceModel testSequenceModel = new TestSequenceModel(cliqueTree);</span>
<span class="nc" id="L1304">      ExactBestSequenceFinder tagInference = new ExactBestSequenceFinder();</span>
<span class="nc" id="L1305">      int[] bestSequence = tagInference.bestSequence(testSequenceModel);</span>
<span class="nc" id="L1306">      System.arraycopy(bestSequence, windowSize - 1, sequence, 0, sequence.length);</span>
<span class="nc" id="L1307">    } else {</span>
<span class="nc" id="L1308">      int[] initialSequence = SequenceGibbsSampler.getRandomSequence(model);</span>
<span class="nc" id="L1309">      System.arraycopy(initialSequence, 0, sequence, 0, sequence.length);</span>
    }

<span class="nc" id="L1312">    sampler.verbose = 0;</span>

<span class="nc bnc" id="L1314" title="All 2 branches missed.">    if (flags.annealingType.equalsIgnoreCase(&quot;linear&quot;)) {</span>
<span class="nc" id="L1315">      sequence = sampler.findBestUsingAnnealing(model, CoolingSchedule.getLinearSchedule(1.0, flags.numSamples),</span>
          sequence);
<span class="nc bnc" id="L1317" title="All 4 branches missed.">    } else if (flags.annealingType.equalsIgnoreCase(&quot;exp&quot;) || flags.annealingType.equalsIgnoreCase(&quot;exponential&quot;)) {</span>
<span class="nc" id="L1318">      sequence = sampler.findBestUsingAnnealing(model, CoolingSchedule.getExponentialSchedule(1.0, flags.annealingRate,</span>
          flags.numSamples), sequence);
    } else {
<span class="nc" id="L1321">      throw new RuntimeException(&quot;No annealing type specified&quot;);</span>
    }

<span class="nc bnc" id="L1324" title="All 2 branches missed.">    if (flags.useReverse) {</span>
<span class="nc" id="L1325">      Collections.reverse(document);</span>
    }

<span class="nc bnc" id="L1328" title="All 2 branches missed.">    for (int j = 0, dsize = newDocument.size(); j &lt; dsize; j++) {</span>
<span class="nc" id="L1329">      IN wi = document.get(j);</span>
<span class="nc bnc" id="L1330" title="All 2 branches missed.">      if (wi == null) throw new RuntimeException(&quot;&quot;);</span>
<span class="nc bnc" id="L1331" title="All 2 branches missed.">      if (classIndex == null) throw new RuntimeException(&quot;&quot;);</span>
<span class="nc" id="L1332">      wi.set(CoreAnnotations.AnswerAnnotation.class, classIndex.get(sequence[j]));</span>
    }

<span class="nc bnc" id="L1335" title="All 2 branches missed.">    if (flags.useReverse) {</span>
<span class="nc" id="L1336">      Collections.reverse(document);</span>
    }

<span class="nc" id="L1339">    return document;</span>
  }

  /**
   * Takes a {@link List} of something that extends {@link CoreMap} and prints
   * the likelihood of each possible label at each point.
   *
   * @param document A {@link List} of something that extends CoreMap.
   * @return If verboseMode is set, a Pair of Counters recording classification decisions, else null.
   */
  @Override
  public Triple&lt;Counter&lt;Integer&gt;, Counter&lt;Integer&gt;, TwoDimensionalCounter&lt;Integer,String&gt;&gt; printProbsDocument(List&lt;IN&gt; document) {
    // TODO: Probably this would really be better with 11 bins, with edge ones from 0-0.5 and 0.95-1.0, a bit like 11-point ave precision
<span class="nc" id="L1352">    final int numBins = 10;</span>
<span class="nc" id="L1353">    boolean verbose = flags.verboseMode;</span>

<span class="nc" id="L1355">    Triple&lt;int[][][], int[], double[][][]&gt; p = documentToDataAndLabels(document);</span>
<span class="nc" id="L1356">    CRFCliqueTree&lt;String&gt; cliqueTree = getCliqueTree(p);</span>

<span class="nc" id="L1358">    Counter&lt;Integer&gt; calibration = new ClassicCounter&lt;&gt;();</span>
<span class="nc" id="L1359">    Counter&lt;Integer&gt; correctByBin = new ClassicCounter&lt;&gt;();</span>
<span class="nc" id="L1360">    TwoDimensionalCounter&lt;Integer,String&gt; calibratedTokens = new TwoDimensionalCounter&lt;&gt;();</span>

    // for (int i = 0; i &lt; factorTables.length; i++) {
<span class="nc bnc" id="L1363" title="All 2 branches missed.">    for (int i = 0; i &lt; cliqueTree.length(); i++) {</span>
<span class="nc" id="L1364">      IN wi = document.get(i);</span>
<span class="nc" id="L1365">      String token = wi.get(CoreAnnotations.TextAnnotation.class);</span>
<span class="nc" id="L1366">      String goldAnswer = wi.get(CoreAnnotations.GoldAnswerAnnotation.class);</span>
<span class="nc" id="L1367">      System.out.print(token);</span>
<span class="nc" id="L1368">      System.out.print('\t');</span>
<span class="nc" id="L1369">      System.out.print(goldAnswer);</span>
<span class="nc" id="L1370">      double maxProb = Double.NEGATIVE_INFINITY;</span>
<span class="nc" id="L1371">      String bestClass = &quot;&quot;;</span>
<span class="nc bnc" id="L1372" title="All 2 branches missed.">      for (String label : classIndex) {</span>
<span class="nc" id="L1373">        int index = classIndex.indexOf(label);</span>
        // double prob = Math.pow(Math.E, factorTables[i].logProbEnd(index));
<span class="nc" id="L1375">        double prob = cliqueTree.prob(i, index);</span>
<span class="nc bnc" id="L1376" title="All 2 branches missed.">        if (prob &gt; maxProb) {</span>
<span class="nc" id="L1377">          bestClass = label;</span>
        }
<span class="nc" id="L1379">        System.out.print('\t');</span>
<span class="nc" id="L1380">        System.out.print(label);</span>
<span class="nc" id="L1381">        System.out.print('=');</span>
<span class="nc" id="L1382">        System.out.print(prob);</span>
<span class="nc bnc" id="L1383" title="All 2 branches missed.">        if (verbose ) {</span>
<span class="nc" id="L1384">          int binnedProb = (int) (prob * numBins);</span>
<span class="nc bnc" id="L1385" title="All 2 branches missed.">          if (binnedProb &gt; (numBins - 1)) {</span>
<span class="nc" id="L1386">            binnedProb = numBins - 1;</span>
          }
<span class="nc" id="L1388">          calibration.incrementCount(binnedProb);</span>
<span class="nc bnc" id="L1389" title="All 2 branches missed.">          if (label.equals(goldAnswer)) {</span>
<span class="nc bnc" id="L1390" title="All 2 branches missed.">            if (bestClass.equals(goldAnswer)) {</span>
<span class="nc" id="L1391">              correctByBin.incrementCount(binnedProb);</span>
            }
<span class="nc bnc" id="L1393" title="All 2 branches missed.">            if ( ! label.equals(flags.backgroundSymbol)) {</span>
<span class="nc" id="L1394">              calibratedTokens.incrementCount(binnedProb, token);</span>
            }
          }
        }
<span class="nc" id="L1398">      }</span>
<span class="nc" id="L1399">      System.out.println();</span>
    }
<span class="nc bnc" id="L1401" title="All 2 branches missed.">    if (verbose) {</span>
<span class="nc" id="L1402">      return new Triple&lt;&gt;(calibration, correctByBin, calibratedTokens);</span>
    } else {
<span class="nc" id="L1404">      return null;</span>
    }
  }

  /**
   * Takes the file, reads it in, and prints out the likelihood of each possible
   * label at each point. This gives a simple way to examine the probability
   * distributions of the CRF. See {@code getCliqueTrees()} for more.
   *
   * @param filename The path to the specified file
   */
  public void printFirstOrderProbs(String filename, DocumentReaderAndWriter&lt;IN&gt; readerAndWriter) {
    // only for the OCR data does this matter
<span class="nc" id="L1417">    flags.ocrTrain = false;</span>

<span class="nc" id="L1419">    ObjectBank&lt;List&lt;IN&gt;&gt; docs = makeObjectBankFromFile(filename, readerAndWriter);</span>
<span class="nc" id="L1420">    printFirstOrderProbsDocuments(docs);</span>
<span class="nc" id="L1421">  }</span>

  /**
   * Takes a {@link List} of documents and prints the likelihood of each
   * possible label at each point.
   *
   * @param documents A {@link List} of {@link List} of INs.
   */
  public void printFirstOrderProbsDocuments(ObjectBank&lt;List&lt;IN&gt;&gt; documents) {
<span class="nc bnc" id="L1430" title="All 2 branches missed.">    for (List&lt;IN&gt; doc : documents) {</span>
<span class="nc" id="L1431">      printFirstOrderProbsDocument(doc);</span>
<span class="nc" id="L1432">      System.out.println();</span>
<span class="nc" id="L1433">    }</span>
<span class="nc" id="L1434">  }</span>

  /**
   * Takes the file, reads it in, and prints out the factor table at each position.
   *
   * @param filename The path to the specified file
   */
  public void printFactorTable(String filename, DocumentReaderAndWriter&lt;IN&gt; readerAndWriter) {
    // only for the OCR data does this matter
<span class="nc" id="L1443">    flags.ocrTrain = false;</span>

<span class="nc" id="L1445">    ObjectBank&lt;List&lt;IN&gt;&gt; docs = makeObjectBankFromFile(filename, readerAndWriter);</span>
<span class="nc" id="L1446">    printFactorTableDocuments(docs);</span>
<span class="nc" id="L1447">  }</span>

  /**
   * Takes a {@link List} of documents and prints the factor table
   * at each point.
   *
   * @param documents A {@link List} of {@link List} of INs.
   */
  public void printFactorTableDocuments(ObjectBank&lt;List&lt;IN&gt;&gt; documents) {
<span class="nc bnc" id="L1456" title="All 2 branches missed.">    for (List&lt;IN&gt; doc : documents) {</span>
<span class="nc" id="L1457">      printFactorTableDocument(doc);</span>
<span class="nc" id="L1458">      System.out.println();</span>
<span class="nc" id="L1459">    }</span>
<span class="nc" id="L1460">  }</span>

  /**
   * Want to make arbitrary probability queries? Then this is the method for
   * you. Given the filename, it reads it in and breaks it into documents, and
   * then makes a CRFCliqueTree for each document. you can then ask the clique
   * tree for marginals and conditional probabilities of almost anything you
   * want.
   */
  public List&lt;CRFCliqueTree&lt;String&gt;&gt; getCliqueTrees(String filename, DocumentReaderAndWriter&lt;IN&gt; readerAndWriter) {
    // only for the OCR data does this matter
<span class="nc" id="L1471">    flags.ocrTrain = false;</span>

<span class="nc" id="L1473">    List&lt;CRFCliqueTree&lt;String&gt;&gt; cts = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1474">    ObjectBank&lt;List&lt;IN&gt;&gt; docs = makeObjectBankFromFile(filename, readerAndWriter);</span>
<span class="nc bnc" id="L1475" title="All 2 branches missed.">    for (List&lt;IN&gt; doc : docs) {</span>
<span class="nc" id="L1476">      cts.add(getCliqueTree(doc));</span>
<span class="nc" id="L1477">    }</span>

<span class="nc" id="L1479">    return cts;</span>
  }

  public CRFCliqueTree&lt;String&gt; getCliqueTree(Triple&lt;int[][][], int[], double[][][]&gt; p) {
<span class="nc" id="L1483">    int[][][] data = p.first();</span>
<span class="nc" id="L1484">    double[][][] featureVal = p.third();</span>

<span class="nc" id="L1486">    return CRFCliqueTree.getCalibratedCliqueTree(data, labelIndices, classIndex.size(), classIndex,</span>
<span class="nc" id="L1487">        flags.backgroundSymbol, getCliquePotentialFunctionForTest(), featureVal);</span>
  }

  public CRFCliqueTree&lt;String&gt; getCliqueTree(List&lt;IN&gt; document) {
<span class="nc" id="L1491">    Triple&lt;int[][][], int[], double[][][]&gt; p = documentToDataAndLabels(document);</span>
<span class="nc" id="L1492">    return getCliqueTree(p);</span>
  }

  /**
   * Takes a {@link List} of something that extends {@link CoreMap} and prints
   * the factor table at each point.
   *
   * @param document A {@link List} of something that extends {@link CoreMap}.
   */
  public void printFactorTableDocument(List&lt;IN&gt; document) {

<span class="nc" id="L1503">    CRFCliqueTree&lt;String&gt; cliqueTree = getCliqueTree(document);</span>
<span class="nc" id="L1504">    FactorTable[] factorTables = cliqueTree.getFactorTables();</span>

<span class="nc" id="L1506">    StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L1507" title="All 2 branches missed.">    for (int i=0; i &lt; factorTables.length; i++) {</span>
<span class="nc" id="L1508">      IN wi = document.get(i);</span>
<span class="nc" id="L1509">      sb.append(wi.get(CoreAnnotations.TextAnnotation.class));</span>
<span class="nc" id="L1510">      sb.append('\t');</span>
<span class="nc" id="L1511">      FactorTable table = factorTables[i];</span>
<span class="nc bnc" id="L1512" title="All 2 branches missed.">      for (int j = 0; j &lt; table.size(); j++) {</span>
<span class="nc" id="L1513">        int[] arr = table.toArray(j);</span>
<span class="nc" id="L1514">        sb.append(classIndex.get(arr[0]));</span>
<span class="nc" id="L1515">        sb.append(':');</span>
<span class="nc" id="L1516">        sb.append(classIndex.get(arr[1]));</span>
<span class="nc" id="L1517">        sb.append(':');</span>
<span class="nc" id="L1518">        sb.append(cliqueTree.logProb(i, arr));</span>
<span class="nc" id="L1519">        sb.append(' ');</span>
      }
<span class="nc" id="L1521">      sb.append('\n');</span>
    }
<span class="nc" id="L1523">    System.out.print(sb);</span>
<span class="nc" id="L1524">  }</span>

  /**
   * Takes a {@link List} of something that extends {@link CoreMap} and prints
   * the likelihood of each possible label at each point.
   *
   * @param document A {@link List} of something that extends {@link CoreMap}.
   */
  public void printFirstOrderProbsDocument(List&lt;IN&gt; document) {

<span class="nc" id="L1534">    CRFCliqueTree&lt;String&gt; cliqueTree = getCliqueTree(document);</span>

    // for (int i = 0; i &lt; factorTables.length; i++) {
<span class="nc bnc" id="L1537" title="All 2 branches missed.">    for (int i = 0; i &lt; cliqueTree.length(); i++) {</span>
<span class="nc" id="L1538">      IN wi = document.get(i);</span>
<span class="nc" id="L1539">      System.out.print(wi.get(CoreAnnotations.TextAnnotation.class) + '\t');</span>
<span class="nc bnc" id="L1540" title="All 2 branches missed.">      for (Iterator&lt;String&gt; iter = classIndex.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L1541">        String label = iter.next();</span>
<span class="nc" id="L1542">        int index = classIndex.indexOf(label);</span>
<span class="nc bnc" id="L1543" title="All 2 branches missed.">        if (i == 0) {</span>
          // double prob = Math.pow(Math.E, factorTables[i].logProbEnd(index));
<span class="nc" id="L1545">          double prob = cliqueTree.prob(i, index);</span>
<span class="nc" id="L1546">          System.out.print(label + '=' + prob);</span>
<span class="nc bnc" id="L1547" title="All 2 branches missed.">          if (iter.hasNext()) {</span>
<span class="nc" id="L1548">            System.out.print(&quot;\t&quot;);</span>
          } else {
<span class="nc" id="L1550">            System.out.print(&quot;\n&quot;);</span>
          }
<span class="nc" id="L1552">        } else {</span>
<span class="nc bnc" id="L1553" title="All 2 branches missed.">          for (Iterator&lt;String&gt; iter1 = classIndex.iterator(); iter1.hasNext();) {</span>
<span class="nc" id="L1554">            String label1 = iter1.next();</span>
<span class="nc" id="L1555">            int index1 = classIndex.indexOf(label1);</span>
            // double prob = Math.pow(Math.E, factorTables[i].logProbEnd(new
            // int[]{index1, index}));
<span class="nc" id="L1558">            double prob = cliqueTree.prob(i, new int[] { index1, index });</span>
<span class="nc" id="L1559">            System.out.print(label1 + '_' + label + '=' + prob);</span>
<span class="nc bnc" id="L1560" title="All 4 branches missed.">            if (iter.hasNext() || iter1.hasNext()) {</span>
<span class="nc" id="L1561">              System.out.print(&quot;\t&quot;);</span>
            } else {
<span class="nc" id="L1563">              System.out.print(&quot;\n&quot;);</span>
            }
<span class="nc" id="L1565">          }</span>
        }
<span class="nc" id="L1567">      }</span>
    }
<span class="nc" id="L1569">  }</span>

  /**
   * Load auxiliary data to be used in constructing features and labels
   * Intended to be overridden by subclasses
   */
  protected Collection&lt;List&lt;IN&gt;&gt; loadAuxiliaryData(Collection&lt;List&lt;IN&gt;&gt; docs, DocumentReaderAndWriter&lt;IN&gt; readerAndWriter) {
<span class="nc" id="L1576">    return docs;</span>
  }

  /** {@inheritDoc} */
  @Override
  public void train(Collection&lt;List&lt;IN&gt;&gt; objectBankWrapper, DocumentReaderAndWriter&lt;IN&gt; readerAndWriter) {
<span class="nc" id="L1582">    Timing timer = new Timing();</span>

<span class="nc" id="L1584">    Collection&lt;List&lt;IN&gt;&gt; docs = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1585" title="All 2 branches missed.">    for (List&lt;IN&gt; doc : objectBankWrapper) {</span>
<span class="nc" id="L1586">      docs.add(doc);</span>
<span class="nc" id="L1587">    }</span>

<span class="nc bnc" id="L1589" title="All 2 branches missed.">    if (flags.numOfSlices &gt; 0) {</span>
<span class="nc" id="L1590">      log.info(&quot;Taking &quot; + flags.numOfSlices + &quot; out of &quot; + flags.totalDataSlice + &quot; slices of data for training&quot;);</span>
<span class="nc" id="L1591">      List&lt;List&lt;IN&gt;&gt; docsToShuffle = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1592" title="All 2 branches missed.">      for (List&lt;IN&gt; doc : docs) {</span>
<span class="nc" id="L1593">        docsToShuffle.add(doc);</span>
<span class="nc" id="L1594">      }</span>
<span class="nc" id="L1595">      Collections.shuffle(docsToShuffle, random);</span>
<span class="nc" id="L1596">      int cutOff = (int)(docsToShuffle.size() / (flags.totalDataSlice + 0.0) * flags.numOfSlices);</span>
<span class="nc" id="L1597">      docs = docsToShuffle.subList(0, cutOff);</span>
    }

<span class="nc" id="L1600">    Collection&lt;List&lt;IN&gt;&gt; totalDocs = loadAuxiliaryData(docs, readerAndWriter);</span>

<span class="nc" id="L1602">    makeAnswerArraysAndTagIndex(totalDocs);</span>

<span class="nc" id="L1604">    long elapsedMs = timer.stop();</span>
<span class="nc" id="L1605">    log.info(&quot;Time to convert docs to feature indices: &quot; + Timing.toSecondsString(elapsedMs) + &quot; seconds&quot;);</span>

<span class="nc bnc" id="L1607" title="All 2 branches missed.">    if (flags.serializeClassIndexTo != null) {</span>
<span class="nc" id="L1608">      timer.start();</span>
<span class="nc" id="L1609">      serializeClassIndex(flags.serializeClassIndexTo);</span>
<span class="nc" id="L1610">      elapsedMs = timer.stop();</span>
<span class="nc" id="L1611">      log.info(&quot;Time to export class index : &quot; + Timing.toSecondsString(elapsedMs) + &quot; seconds&quot;);</span>
    }

<span class="nc bnc" id="L1614" title="All 2 branches missed.">    if (flags.exportFeatures != null) {</span>
<span class="nc" id="L1615">      dumpFeatures(docs);</span>
    }

<span class="nc bnc" id="L1618" title="All 2 branches missed.">    for (int i = 0; i &lt;= flags.numTimesPruneFeatures; i++) {</span>
<span class="nc" id="L1619">      timer.start();</span>
<span class="nc" id="L1620">      Triple&lt;int[][][][], int[][], double[][][][]&gt; dataAndLabelsAndFeatureVals = documentsToDataAndLabels(docs);</span>
<span class="nc" id="L1621">      elapsedMs = timer.stop();</span>
<span class="nc" id="L1622">      log.info(&quot;Time to convert docs to data/labels: &quot; + Timing.toSecondsString(elapsedMs) + &quot; seconds&quot;);</span>

<span class="nc" id="L1624">      Evaluator[] evaluators = null;</span>
<span class="nc bnc" id="L1625" title="All 4 branches missed.">      if (flags.evaluateIters &gt; 0 || flags.terminateOnEvalImprovement) {</span>
<span class="nc" id="L1626">        List&lt;Evaluator&gt; evaluatorList = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1627" title="All 2 branches missed.">        if (flags.useMemoryEvaluator)</span>
<span class="nc" id="L1628">          evaluatorList.add(new MemoryEvaluator());</span>
<span class="nc bnc" id="L1629" title="All 2 branches missed.">        if (flags.evaluateTrain) {</span>
<span class="nc" id="L1630">          CRFClassifierEvaluator&lt;IN&gt; crfEvaluator = new CRFClassifierEvaluator&lt;&gt;(&quot;Train set&quot;, this);</span>
<span class="nc" id="L1631">          List&lt;Triple&lt;int[][][], int[], double[][][]&gt;&gt; trainDataAndLabels = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1632">          int[][][][] data = dataAndLabelsAndFeatureVals.first();</span>
<span class="nc" id="L1633">          int[][] labels = dataAndLabelsAndFeatureVals.second();</span>
<span class="nc" id="L1634">          double[][][][] featureVal = dataAndLabelsAndFeatureVals.third();</span>
<span class="nc bnc" id="L1635" title="All 2 branches missed.">          for (int j = 0; j &lt; data.length; j++) {</span>
<span class="nc" id="L1636">            Triple&lt;int[][][], int[], double[][][]&gt; p = new Triple&lt;&gt;(data[j], labels[j], featureVal[j]);</span>
<span class="nc" id="L1637">            trainDataAndLabels.add(p);</span>
          }
<span class="nc" id="L1639">          crfEvaluator.setTestData(docs, trainDataAndLabels);</span>
<span class="nc bnc" id="L1640" title="All 2 branches missed.">          if (flags.evalCmd.length() &gt; 0)</span>
<span class="nc" id="L1641">            crfEvaluator.setEvalCmd(flags.evalCmd);</span>
<span class="nc" id="L1642">          evaluatorList.add(crfEvaluator);</span>
        }
<span class="nc bnc" id="L1644" title="All 2 branches missed.">        if (flags.testFile != null) {</span>
<span class="nc" id="L1645">          CRFClassifierEvaluator&lt;IN&gt; crfEvaluator = new CRFClassifierEvaluator&lt;&gt;(&quot;Test set (&quot; + flags.testFile + &quot;)&quot;,</span>
                  this);
<span class="nc" id="L1647">          ObjectBank&lt;List&lt;IN&gt;&gt; testObjBank = makeObjectBankFromFile(flags.testFile, readerAndWriter);</span>
<span class="nc" id="L1648">          List&lt;List&lt;IN&gt;&gt; testDocs = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1649" title="All 2 branches missed.">          for (List&lt;IN&gt; doc : testObjBank) {</span>
<span class="nc" id="L1650">            testDocs.add(doc);</span>
<span class="nc" id="L1651">          }</span>
<span class="nc" id="L1652">          List&lt;Triple&lt;int[][][], int[], double[][][]&gt;&gt; testDataAndLabels = documentsToDataAndLabelsList(testDocs);</span>
<span class="nc" id="L1653">          crfEvaluator.setTestData(testDocs, testDataAndLabels);</span>
<span class="nc bnc" id="L1654" title="All 2 branches missed.">          if (flags.evalCmd.length() &gt; 0)</span>
<span class="nc" id="L1655">            crfEvaluator.setEvalCmd(flags.evalCmd);</span>
<span class="nc" id="L1656">          evaluatorList.add(crfEvaluator);</span>
        }
<span class="nc bnc" id="L1658" title="All 2 branches missed.">        if (flags.testFiles != null) {</span>
<span class="nc" id="L1659">          String[] testFiles = flags.testFiles.split(&quot;,&quot;);</span>
<span class="nc bnc" id="L1660" title="All 2 branches missed.">          for (String testFile : testFiles) {</span>
<span class="nc" id="L1661">            CRFClassifierEvaluator&lt;IN&gt; crfEvaluator = new CRFClassifierEvaluator&lt;&gt;(&quot;Test set (&quot; + testFile + ')', this);</span>
<span class="nc" id="L1662">            ObjectBank&lt;List&lt;IN&gt;&gt; testObjBank = makeObjectBankFromFile(testFile, readerAndWriter);</span>
<span class="nc" id="L1663">            List&lt;Triple&lt;int[][][], int[], double[][][]&gt;&gt; testDataAndLabels = documentsToDataAndLabelsList(testObjBank);</span>
<span class="nc" id="L1664">            crfEvaluator.setTestData(testObjBank, testDataAndLabels);</span>
<span class="nc bnc" id="L1665" title="All 2 branches missed.">            if (flags.evalCmd.length() &gt; 0)</span>
<span class="nc" id="L1666">              crfEvaluator.setEvalCmd(flags.evalCmd);</span>
<span class="nc" id="L1667">            evaluatorList.add(crfEvaluator);</span>
          }
        }
<span class="nc" id="L1670">        evaluators = new Evaluator[evaluatorList.size()];</span>
<span class="nc" id="L1671">        evaluatorList.toArray(evaluators);</span>
      }

<span class="nc bnc" id="L1674" title="All 2 branches missed.">      if (flags.numTimesPruneFeatures == i) {</span>
<span class="nc" id="L1675">        docs = null; // hopefully saves memory</span>
      }
      // save feature index to disk and read in later
<span class="nc" id="L1678">      File featIndexFile = null;</span>

      // CRFLogConditionalObjectiveFunction.featureIndex = featureIndex;
      // int numFeatures = featureIndex.size();
<span class="nc bnc" id="L1682" title="All 2 branches missed.">      if (flags.saveFeatureIndexToDisk) {</span>
        try {
<span class="nc" id="L1684">          log.info(&quot;Writing feature index to temporary file.&quot;);</span>
<span class="nc" id="L1685">          featIndexFile = IOUtils.writeObjectToTempFile(featureIndex, &quot;featIndex&quot; + i + &quot;.tmp&quot;);</span>
          // featureIndex = null;
<span class="nc" id="L1687">        } catch (IOException e) {</span>
<span class="nc" id="L1688">          throw new RuntimeException(&quot;Could not open temporary feature index file for writing.&quot;);</span>
<span class="nc" id="L1689">        }</span>
      }

      // first index is the number of the document
      // second index is position in the document also the index of the
      // clique/factor table
      // third index is the number of elements in the clique/window these
      // features are for (starting with last element)
      // fourth index is position of the feature in the array that holds them
      // element in data[i][j][k][m] is the index of the mth feature occurring
      // in position k of the jth clique of the ith document
<span class="nc" id="L1700">      int[][][][] data = dataAndLabelsAndFeatureVals.first();</span>
      // first index is the number of the document
      // second index is the position in the document
      // element in labels[i][j] is the index of the correct label (if it
      // exists) at position j in document i
<span class="nc" id="L1705">      int[][] labels = dataAndLabelsAndFeatureVals.second();</span>
<span class="nc" id="L1706">      double[][][][] featureVals = dataAndLabelsAndFeatureVals.third();</span>

<span class="nc bnc" id="L1708" title="All 2 branches missed.">      if (flags.loadProcessedData != null) {</span>
<span class="nc" id="L1709">        List&lt;List&lt;CRFDatum&lt;Collection&lt;String&gt;, String&gt;&gt;&gt; processedData = loadProcessedData(flags.loadProcessedData);</span>
<span class="nc bnc" id="L1710" title="All 2 branches missed.">        if (processedData != null) {</span>
          // enlarge the data and labels array
<span class="nc" id="L1712">          int[][][][] allData = new int[data.length + processedData.size()][][][];</span>
<span class="nc" id="L1713">          double[][][][] allFeatureVals = new double[featureVals.length + processedData.size()][][][];</span>
<span class="nc" id="L1714">          int[][] allLabels = new int[labels.length + processedData.size()][];</span>
<span class="nc" id="L1715">          System.arraycopy(data, 0, allData, 0, data.length);</span>
<span class="nc" id="L1716">          System.arraycopy(labels, 0, allLabels, 0, labels.length);</span>
<span class="nc" id="L1717">          System.arraycopy(featureVals, 0, allFeatureVals, 0, featureVals.length);</span>
          // add to the data and labels array
<span class="nc" id="L1719">          addProcessedData(processedData, allData, allLabels, allFeatureVals, data.length);</span>
<span class="nc" id="L1720">          data = allData;</span>
<span class="nc" id="L1721">          labels = allLabels;</span>
<span class="nc" id="L1722">          featureVals = allFeatureVals;</span>
        }
      }

<span class="nc" id="L1726">      double[] oneDimWeights = trainWeights(data, labels, evaluators, i, featureVals);</span>
<span class="nc bnc" id="L1727" title="All 2 branches missed.">      if (oneDimWeights != null) {</span>
<span class="nc" id="L1728">        this.weights = to2D(oneDimWeights, labelIndices, map);</span>
      }

      // if (flags.useFloat) {
      //   oneDimWeights = trainWeightsUsingFloatCRF(data, labels, evaluators, i, featureVals);
      // } else if (flags.numLopExpert &gt; 1) {
      //   oneDimWeights = trainWeightsUsingLopCRF(data, labels, evaluators, i, featureVals);
      // } else {
      //   oneDimWeights = trainWeightsUsingDoubleCRF(data, labels, evaluators, i, featureVals);
      // }

      // save feature index to disk and read in later
<span class="nc bnc" id="L1740" title="All 2 branches missed.">      if (flags.saveFeatureIndexToDisk) {</span>
        try {
<span class="nc" id="L1742">          log.info(&quot;Reading temporary feature index file.&quot;);</span>
<span class="nc" id="L1743">          featureIndex = IOUtils.readObjectFromFile(featIndexFile);</span>
<span class="nc" id="L1744">        } catch (Exception e) {</span>
<span class="nc" id="L1745">          throw new RuntimeException(&quot;Could not open temporary feature index file for reading.&quot;);</span>
<span class="nc" id="L1746">        }</span>
      }

<span class="nc bnc" id="L1749" title="All 2 branches missed.">      if (i != flags.numTimesPruneFeatures) {</span>
<span class="nc" id="L1750">        dropFeaturesBelowThreshold(flags.featureDiffThresh);</span>
<span class="nc" id="L1751">        log.info(&quot;Removing features with weight below &quot; + flags.featureDiffThresh + &quot; and retraining...&quot;);</span>
      }
    }
<span class="nc" id="L1754">  }</span>

  public static double[][] to2D(double[] weights, List&lt;Index&lt;CRFLabel&gt;&gt; labelIndices, int[] map) {
<span class="nc" id="L1757">    double[][] newWeights = new double[map.length][];</span>
<span class="nc" id="L1758">    int index = 0;</span>
<span class="nc bnc" id="L1759" title="All 2 branches missed.">    for (int i = 0; i &lt; map.length; i++) {</span>
<span class="nc" id="L1760">      newWeights[i] = new double[labelIndices.get(map[i]).size()];</span>
<span class="nc" id="L1761">      System.arraycopy(weights, index, newWeights[i], 0, labelIndices.get(map[i]).size());</span>
<span class="nc" id="L1762">      index += labelIndices.get(map[i]).size();</span>
    }
<span class="nc" id="L1764">    return newWeights;</span>
  }


  protected void pruneNodeFeatureIndices(int totalNumOfFeatureSlices, int numOfFeatureSlices) {
<span class="nc" id="L1769">    int numOfNodeFeatures = nodeFeatureIndicesMap.size();</span>
<span class="nc" id="L1770">    int beginIndex = 0;</span>
<span class="nc" id="L1771">    int endIndex = Math.min( (int)(numOfNodeFeatures / (totalNumOfFeatureSlices+0.0) * numOfFeatureSlices), numOfNodeFeatures);</span>
<span class="nc" id="L1772">    List&lt;Integer&gt; nodeFeatureOriginalIndices = nodeFeatureIndicesMap.objectsList();</span>
<span class="nc" id="L1773">    List&lt;Integer&gt; edgeFeatureOriginalIndices = edgeFeatureIndicesMap.objectsList();</span>

<span class="nc" id="L1775">    Index&lt;Integer&gt; newNodeFeatureIndex = new HashIndex&lt;&gt;();</span>
<span class="nc" id="L1776">    Index&lt;Integer&gt; newEdgeFeatureIndex = new HashIndex&lt;&gt;();</span>
<span class="nc" id="L1777">    Index&lt;String&gt; newFeatureIndex = new HashIndex&lt;&gt;();</span>

<span class="nc bnc" id="L1779" title="All 2 branches missed.">    for (int i = beginIndex; i &lt; endIndex; i++) {</span>
<span class="nc" id="L1780">      int oldIndex = nodeFeatureOriginalIndices.get(i);</span>
<span class="nc" id="L1781">      String f = featureIndex.get(oldIndex);</span>
<span class="nc" id="L1782">      int index = newFeatureIndex.addToIndex(f);</span>
<span class="nc" id="L1783">      newNodeFeatureIndex.add(index);</span>
    }
<span class="nc bnc" id="L1785" title="All 2 branches missed.">    for (Integer edgeFIndex: edgeFeatureOriginalIndices) {</span>
<span class="nc" id="L1786">      String f = featureIndex.get(edgeFIndex);</span>
<span class="nc" id="L1787">      int index = newFeatureIndex.addToIndex(f);</span>
<span class="nc" id="L1788">      newEdgeFeatureIndex.add(index);</span>
<span class="nc" id="L1789">    }</span>

<span class="nc" id="L1791">    nodeFeatureIndicesMap = newNodeFeatureIndex;</span>
<span class="nc" id="L1792">    edgeFeatureIndicesMap = newEdgeFeatureIndex;</span>

<span class="nc" id="L1794">    int[] newMap = new int[newFeatureIndex.size()];</span>
<span class="nc bnc" id="L1795" title="All 2 branches missed.">    for (int i = 0; i &lt; newMap.length; i++) {</span>
<span class="nc" id="L1796">      int index = featureIndex.indexOf(newFeatureIndex.get(i));</span>
<span class="nc" id="L1797">      newMap[i] = map[index];</span>
    }
<span class="nc" id="L1799">    map = newMap;</span>

<span class="nc" id="L1801">    featureIndex = newFeatureIndex;</span>
<span class="nc" id="L1802">  }</span>

  protected CRFLogConditionalObjectiveFunction getObjectiveFunction(int[][][][] data, int[][] labels) {
<span class="nc" id="L1805">    return new CRFLogConditionalObjectiveFunction(data, labels, windowSize, classIndex,</span>
      labelIndices, map, flags.priorType, flags.backgroundSymbol, flags.sigma, null, flags.multiThreadGrad);
  }

  protected double[] trainWeights(int[][][][] data, int[][] labels, Evaluator[] evaluators, int pruneFeatureItr, double[][][][] featureVals) {

<span class="nc" id="L1811">    CRFLogConditionalObjectiveFunction func = getObjectiveFunction(data, labels);</span>
<span class="nc" id="L1812">    cliquePotentialFunctionHelper = func;</span>

    // create feature grouping
    // todo [cdm 2016]: Use a CollectionValuedMap
<span class="nc" id="L1816">    Map&lt;String, Set&lt;Integer&gt;&gt; featureSets = null;</span>
<span class="nc bnc" id="L1817" title="All 2 branches missed.">    if (flags.groupByOutputClass) {</span>
<span class="nc" id="L1818">      featureSets = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1819" title="All 2 branches missed.">      if (flags.groupByFeatureTemplate) {</span>
<span class="nc" id="L1820">        int pIndex = 0;</span>
<span class="nc bnc" id="L1821" title="All 2 branches missed.">        for (int fIndex = 0; fIndex &lt; map.length; fIndex++) {</span>
<span class="nc" id="L1822">          int cliqueType = map[fIndex];</span>
<span class="nc" id="L1823">          int numCliqueTypeOutputClass = labelIndices.get(map[fIndex]).size();</span>
<span class="nc bnc" id="L1824" title="All 2 branches missed.">          for (int cliqueOutClass = 0; cliqueOutClass &lt; numCliqueTypeOutputClass; cliqueOutClass++) {</span>
<span class="nc" id="L1825">            String name = &quot;c:&quot;+cliqueType+&quot;-o:&quot;+cliqueOutClass+&quot;-g:&quot;+featureIndexToTemplateIndex.get(fIndex);</span>
<span class="nc bnc" id="L1826" title="All 2 branches missed.">            if (featureSets.containsKey(name)) {</span>
<span class="nc" id="L1827">              featureSets.get(name).add(pIndex);</span>
            } else {
<span class="nc" id="L1829">              Set&lt;Integer&gt; newSet = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1830">              newSet.add(pIndex);</span>
<span class="nc" id="L1831">              featureSets.put(name, newSet);</span>
            }
<span class="nc" id="L1833">            pIndex++;</span>
          }
        }
<span class="nc" id="L1836">      } else {</span>
<span class="nc" id="L1837">        int pIndex = 0;</span>
<span class="nc bnc" id="L1838" title="All 2 branches missed.">        for (int cliqueType : map) {</span>
<span class="nc" id="L1839">          int numCliqueTypeOutputClass = labelIndices.get(cliqueType).size();</span>
<span class="nc bnc" id="L1840" title="All 2 branches missed.">          for (int cliqueOutClass = 0; cliqueOutClass &lt; numCliqueTypeOutputClass; cliqueOutClass++) {</span>
<span class="nc" id="L1841">            String name = &quot;c:&quot; + cliqueType + &quot;-o:&quot; + cliqueOutClass;</span>
<span class="nc bnc" id="L1842" title="All 2 branches missed.">            if (featureSets.containsKey(name)) {</span>
<span class="nc" id="L1843">              featureSets.get(name).add(pIndex);</span>
            } else {
<span class="nc" id="L1845">              Set&lt;Integer&gt; newSet = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1846">              newSet.add(pIndex);</span>
<span class="nc" id="L1847">              featureSets.put(name, newSet);</span>
            }
<span class="nc" id="L1849">            pIndex++;</span>
          }
        }
<span class="nc" id="L1852">      }</span>
<span class="nc bnc" id="L1853" title="All 2 branches missed.">    } else if (flags.groupByFeatureTemplate) {</span>
<span class="nc" id="L1854">      featureSets = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1855">      int pIndex = 0;</span>
<span class="nc bnc" id="L1856" title="All 2 branches missed.">      for (int fIndex = 0; fIndex &lt; map.length; fIndex++) {</span>
<span class="nc" id="L1857">        int cliqueType = map[fIndex];</span>
<span class="nc" id="L1858">        int numCliqueTypeOutputClass = labelIndices.get(map[fIndex]).size();</span>
<span class="nc bnc" id="L1859" title="All 2 branches missed.">        for (int cliqueOutClass = 0; cliqueOutClass &lt; numCliqueTypeOutputClass; cliqueOutClass++) {</span>
<span class="nc" id="L1860">          String name = &quot;c:&quot;+cliqueType+&quot;-g:&quot;+featureIndexToTemplateIndex.get(fIndex);</span>
<span class="nc bnc" id="L1861" title="All 2 branches missed.">          if (featureSets.containsKey(name)) {</span>
<span class="nc" id="L1862">            featureSets.get(name).add(pIndex);</span>
          } else {
<span class="nc" id="L1864">            Set&lt;Integer&gt; newSet = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1865">            newSet.add(pIndex);</span>
<span class="nc" id="L1866">            featureSets.put(name, newSet);</span>
          }
<span class="nc" id="L1868">          pIndex++;</span>
        }
      }
    }
<span class="nc bnc" id="L1872" title="All 2 branches missed.">    if (featureSets != null) {</span>
<span class="nc" id="L1873">      int[][] fg = new int[featureSets.size()][];</span>
<span class="nc" id="L1874">      log.info(&quot;After feature grouping, total of &quot;+fg.length+&quot; groups&quot;);</span>
<span class="nc" id="L1875">      int count = 0;</span>
<span class="nc bnc" id="L1876" title="All 2 branches missed.">      for (Set&lt;Integer&gt; aSet: featureSets.values()) {</span>
<span class="nc" id="L1877">        fg[count] = new int[aSet.size()];</span>
<span class="nc" id="L1878">        int i = 0;</span>
<span class="nc bnc" id="L1879" title="All 2 branches missed.">        for (Integer val : aSet)</span>
<span class="nc" id="L1880">          fg[count][i++] = val;</span>
<span class="nc" id="L1881">        count++;</span>
<span class="nc" id="L1882">      }</span>
<span class="nc" id="L1883">      func.setFeatureGrouping(fg);</span>
    }

<span class="nc" id="L1886">    Minimizer&lt;DiffFunction&gt; minimizer = getMinimizer(pruneFeatureItr, evaluators);</span>

    double[] initialWeights;
<span class="nc bnc" id="L1889" title="All 2 branches missed.">    if (flags.initialWeights == null) {</span>
<span class="nc" id="L1890">      initialWeights = func.initial();</span>
    } else {
      try {
<span class="nc" id="L1893">        log.info(&quot;Reading initial weights from file &quot; + flags.initialWeights);</span>
<span class="nc" id="L1894">        DataInputStream dis = IOUtils.getDataInputStream(flags.initialWeights);</span>
<span class="nc" id="L1895">        initialWeights = ConvertByteArray.readDoubleArr(dis);</span>
<span class="nc" id="L1896">      } catch (IOException e) {</span>
<span class="nc" id="L1897">        throw new RuntimeException(&quot;Could not read from double initial weight file &quot; + flags.initialWeights);</span>
<span class="nc" id="L1898">      }</span>
    }
<span class="nc" id="L1900">    log.info(&quot;numWeights: &quot; + initialWeights.length);</span>

<span class="nc bnc" id="L1902" title="All 2 branches missed.">    if (flags.testObjFunction) {</span>
<span class="nc" id="L1903">      StochasticDiffFunctionTester tester = new StochasticDiffFunctionTester(func);</span>
<span class="nc bnc" id="L1904" title="All 2 branches missed.">      if (tester.testSumOfBatches(initialWeights, 1e-4)) {</span>
<span class="nc" id="L1905">        log.info(&quot;Successfully tested stochastic objective function.&quot;);</span>
      } else {
<span class="nc" id="L1907">        throw new IllegalStateException(&quot;Testing of stochastic objective function failed.&quot;);</span>
      }

    }
    //check gradient
<span class="nc bnc" id="L1912" title="All 2 branches missed.">    if (flags.checkGradient) {</span>
<span class="nc bnc" id="L1913" title="All 2 branches missed.">      if (func.gradientCheck()) {</span>
<span class="nc" id="L1914">        log.info(&quot;gradient check passed&quot;);</span>
      } else {
<span class="nc" id="L1916">        throw new RuntimeException(&quot;gradient check failed&quot;);</span>
      }
    }
<span class="nc" id="L1919">    return minimizer.minimize(func, flags.tolerance, initialWeights);</span>
  }

  public Minimizer&lt;DiffFunction&gt; getMinimizer() {
<span class="nc" id="L1923">    return getMinimizer(0, null);</span>
  }

  public Minimizer&lt;DiffFunction&gt; getMinimizer(int featurePruneIteration, Evaluator[] evaluators) {
<span class="nc" id="L1927">    Minimizer&lt;DiffFunction&gt; minimizer = null;</span>
<span class="nc" id="L1928">    QNMinimizer qnMinimizer = null;</span>

<span class="nc bnc" id="L1930" title="All 4 branches missed.">    if (flags.useQN || flags.useSGDtoQN) {</span>
      // share code for creation of QNMinimizer
      int qnMem;
<span class="nc bnc" id="L1933" title="All 2 branches missed.">      if (featurePruneIteration == 0) {</span>
<span class="nc" id="L1934">        qnMem = flags.QNsize;</span>
      } else {
<span class="nc" id="L1936">        qnMem = flags.QNsize2;</span>
      }

<span class="nc bnc" id="L1939" title="All 2 branches missed.">      if (flags.interimOutputFreq != 0) {</span>
<span class="nc" id="L1940">        Function monitor = new ResultStoringMonitor(flags.interimOutputFreq, flags.serializeTo);</span>
<span class="nc" id="L1941">        qnMinimizer = new QNMinimizer(monitor, qnMem, flags.useRobustQN);</span>
<span class="nc" id="L1942">      } else {</span>
<span class="nc" id="L1943">        qnMinimizer = new QNMinimizer(qnMem, flags.useRobustQN);</span>
      }

<span class="nc" id="L1946">      qnMinimizer.terminateOnMaxItr(flags.maxQNItr);</span>
<span class="nc" id="L1947">      qnMinimizer.terminateOnEvalImprovement(flags.terminateOnEvalImprovement);</span>
<span class="nc" id="L1948">      qnMinimizer.setTerminateOnEvalImprovementNumOfEpoch(flags.terminateOnEvalImprovementNumOfEpoch);</span>
<span class="nc" id="L1949">      qnMinimizer.suppressTestPrompt(flags.suppressTestDebug);</span>
<span class="nc bnc" id="L1950" title="All 2 branches missed.">      if (flags.useOWLQN) {</span>
<span class="nc" id="L1951">        qnMinimizer.useOWLQN(flags.useOWLQN, flags.priorLambda);</span>
      }
    }

<span class="nc bnc" id="L1955" title="All 2 branches missed.">    if (flags.useQN) {</span>
<span class="nc" id="L1956">      minimizer = qnMinimizer;</span>
<span class="nc bnc" id="L1957" title="All 2 branches missed.">    } else if (flags.useInPlaceSGD) {</span>
<span class="nc" id="L1958">      SGDMinimizer&lt;DiffFunction&gt; sgdMinimizer =</span>
              new SGDMinimizer&lt;&gt;(flags.sigma, flags.SGDPasses, flags.tuneSampleSize, flags.stochasticBatchSize);
<span class="nc bnc" id="L1960" title="All 2 branches missed.">      if (flags.useSGDtoQN) {</span>
<span class="nc" id="L1961">        minimizer = new HybridMinimizer(sgdMinimizer, qnMinimizer, flags.SGDPasses);</span>
      } else {
<span class="nc" id="L1963">        minimizer = sgdMinimizer;</span>
      }
<span class="nc bnc" id="L1965" title="All 2 branches missed.">    } else if (flags.useAdaGradFOBOS) {</span>
<span class="nc" id="L1966">      double lambda = 0.5 / (flags.sigma * flags.sigma);</span>
<span class="nc" id="L1967">      minimizer = new SGDWithAdaGradAndFOBOS&lt;&gt;(</span>
              flags.initRate, lambda, flags.SGDPasses, flags.stochasticBatchSize,
              flags.priorType, flags.priorAlpha, flags.useAdaDelta, flags.useAdaDiff, flags.adaGradEps, flags.adaDeltaRho);
<span class="nc" id="L1970">      ((SGDWithAdaGradAndFOBOS) minimizer).terminateOnEvalImprovement(flags.terminateOnEvalImprovement);</span>
<span class="nc" id="L1971">      ((SGDWithAdaGradAndFOBOS) minimizer).terminateOnAvgImprovement(flags.terminateOnAvgImprovement, flags.tolerance);</span>
<span class="nc" id="L1972">      ((SGDWithAdaGradAndFOBOS) minimizer).setTerminateOnEvalImprovementNumOfEpoch(flags.terminateOnEvalImprovementNumOfEpoch);</span>
<span class="nc" id="L1973">      ((SGDWithAdaGradAndFOBOS) minimizer).suppressTestPrompt(flags.suppressTestDebug);</span>
<span class="nc bnc" id="L1974" title="All 2 branches missed.">    } else if (flags.useSGDtoQN) {</span>
<span class="nc" id="L1975">      minimizer = new SGDToQNMinimizer(flags.initialGain, flags.stochasticBatchSize,</span>
                                       flags.SGDPasses, flags.QNPasses, flags.SGD2QNhessSamples,
                                       flags.QNsize, flags.outputIterationsToFile);
<span class="nc bnc" id="L1978" title="All 2 branches missed.">    } else if (flags.useSMD) {</span>
<span class="nc" id="L1979">      minimizer = new SMDMinimizer&lt;&gt;(flags.initialGain, flags.stochasticBatchSize, flags.stochasticMethod,</span>
              flags.SGDPasses);
<span class="nc bnc" id="L1981" title="All 2 branches missed.">    } else if (flags.useSGD) {</span>
<span class="nc" id="L1982">      minimizer = new InefficientSGDMinimizer&lt;&gt;(flags.initialGain, flags.stochasticBatchSize);</span>
<span class="nc bnc" id="L1983" title="All 2 branches missed.">    } else if (flags.useScaledSGD) {</span>
<span class="nc" id="L1984">      minimizer = new ScaledSGDMinimizer(flags.initialGain, flags.stochasticBatchSize, flags.SGDPasses,</span>
          flags.scaledSGDMethod);
<span class="nc bnc" id="L1986" title="All 2 branches missed.">    } else if (flags.l1reg &gt; 0.0) {</span>
<span class="nc" id="L1987">      minimizer = ReflectionLoading.loadByReflection(&quot;edu.stanford.nlp.optimization.OWLQNMinimizer&quot;, flags.l1reg);</span>
    } else {
<span class="nc" id="L1989">      throw new RuntimeException(&quot;No minimizer assigned!&quot;);</span>
    }

<span class="nc bnc" id="L1992" title="All 2 branches missed.">    if (minimizer instanceof HasEvaluators) {</span>
<span class="nc bnc" id="L1993" title="All 2 branches missed.">      if (minimizer instanceof QNMinimizer) {</span>
<span class="nc" id="L1994">        ((QNMinimizer) minimizer).setEvaluators(flags.evaluateIters, flags.startEvaluateIters, evaluators);</span>
      } else
<span class="nc" id="L1996">        ((HasEvaluators) minimizer).setEvaluators(flags.evaluateIters, evaluators);</span>
    }

<span class="nc" id="L1999">    return minimizer;</span>
  }

  /**
   * Creates a new CRFDatum from the preprocessed allData format, given the
   * document number, position number, and a List of Object labels.
   *
   * @return A new CRFDatum
   */
  protected List&lt;CRFDatum&lt;? extends Collection&lt;String&gt;, ? extends CharSequence&gt;&gt; extractDatumSequence(int[][][] allData, int beginPosition, int endPosition,
      List&lt;IN&gt; labeledWordInfos) {
<span class="nc" id="L2010">    List&lt;CRFDatum&lt;? extends Collection&lt;String&gt;, ? extends CharSequence&gt;&gt; result = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L2011">    int beginContext = beginPosition - windowSize + 1;</span>
<span class="nc bnc" id="L2012" title="All 2 branches missed.">    if (beginContext &lt; 0) {</span>
<span class="nc" id="L2013">      beginContext = 0;</span>
    }
    // for the beginning context, add some dummy datums with no features!
    // TODO: is there any better way to do this?
<span class="nc bnc" id="L2017" title="All 2 branches missed.">    for (int position = beginContext; position &lt; beginPosition; position++) {</span>
<span class="nc" id="L2018">      List&lt;Collection&lt;String&gt;&gt; cliqueFeatures = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L2019">      List&lt;double[]&gt; featureVals = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L2020" title="All 2 branches missed.">      for (int i = 0; i &lt; windowSize; i++) {</span>
        // create a feature list
<span class="nc" id="L2022">        cliqueFeatures.add(Collections.emptyList());</span>
<span class="nc" id="L2023">        featureVals.add(null);</span>
      }
<span class="nc" id="L2025">      CRFDatum&lt;Collection&lt;String&gt;, String&gt; datum = new CRFDatum&lt;&gt;(cliqueFeatures,</span>
<span class="nc" id="L2026">              labeledWordInfos.get(position).get(CoreAnnotations.AnswerAnnotation.class), featureVals);</span>
<span class="nc" id="L2027">      result.add(datum);</span>
    }
    // now add the real datums
<span class="nc bnc" id="L2030" title="All 2 branches missed.">    for (int position = beginPosition; position &lt;= endPosition; position++) {</span>
<span class="nc" id="L2031">      List&lt;Collection&lt;String&gt;&gt; cliqueFeatures = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L2032">      List&lt;double[]&gt; featureVals = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L2033" title="All 2 branches missed.">      for (int i = 0; i &lt; windowSize; i++) {</span>
        // create a feature list
<span class="nc" id="L2035">        Collection&lt;String&gt; features = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L2036" title="All 2 branches missed.">        for (int j = 0; j &lt; allData[position][i].length; j++) {</span>
<span class="nc" id="L2037">          features.add(featureIndex.get(allData[position][i][j]));</span>
        }
<span class="nc" id="L2039">        cliqueFeatures.add(features);</span>
<span class="nc" id="L2040">        featureVals.add(null);</span>
      }
<span class="nc" id="L2042">      CRFDatum&lt;Collection&lt;String&gt;,String&gt; datum = new CRFDatum&lt;&gt;(cliqueFeatures,</span>
<span class="nc" id="L2043">              labeledWordInfos.get(position).get(CoreAnnotations.AnswerAnnotation.class), featureVals);</span>
<span class="nc" id="L2044">      result.add(datum);</span>
    }
<span class="nc" id="L2046">    return result;</span>
  }

  /**
   * Adds the List of Lists of CRFDatums to the data and labels arrays, treating
   * each datum as if it were its own document. Adds context labels in addition
   * to the target label for each datum, meaning that for a particular document,
   * the number of labels will be windowSize-1 greater than the number of
   * datums.
   *
   * @param processedData A List of Lists of CRFDatums
   */
  protected void addProcessedData(List&lt;List&lt;CRFDatum&lt;Collection&lt;String&gt;, String&gt;&gt;&gt; processedData, int[][][][] data,
      int[][] labels, double[][][][] featureVals, int offset) {
<span class="nc bnc" id="L2060" title="All 2 branches missed.">    for (int i = 0, pdSize = processedData.size(); i &lt; pdSize; i++) {</span>
<span class="nc" id="L2061">      int dataIndex = i + offset;</span>
<span class="nc" id="L2062">      List&lt;CRFDatum&lt;Collection&lt;String&gt;, String&gt;&gt; document = processedData.get(i);</span>
<span class="nc" id="L2063">      int dsize = document.size();</span>
<span class="nc" id="L2064">      labels[dataIndex] = new int[dsize];</span>
<span class="nc" id="L2065">      data[dataIndex] = new int[dsize][][];</span>
<span class="nc bnc" id="L2066" title="All 2 branches missed.">      if (featureVals != null)</span>
<span class="nc" id="L2067">        featureVals[dataIndex] = new double[dsize][][];</span>
<span class="nc bnc" id="L2068" title="All 2 branches missed.">      for (int j = 0; j &lt; dsize; j++) {</span>
<span class="nc" id="L2069">        CRFDatum&lt;Collection&lt;String&gt;, String&gt; crfDatum = document.get(j);</span>
        // add label, they are offset by extra context
<span class="nc" id="L2071">        labels[dataIndex][j] = classIndex.indexOf(crfDatum.label());</span>
        // add featureVals
<span class="nc" id="L2073">        List&lt;double[]&gt; featureValList = null;</span>
<span class="nc bnc" id="L2074" title="All 2 branches missed.">        if (featureVals != null)</span>
<span class="nc" id="L2075">          featureValList = crfDatum.asFeatureVals();</span>
        // add features
<span class="nc" id="L2077">        List&lt;Collection&lt;String&gt;&gt; cliques = crfDatum.asFeatures();</span>
<span class="nc" id="L2078">        int csize = cliques.size();</span>
<span class="nc" id="L2079">        data[dataIndex][j] = new int[csize][];</span>
<span class="nc bnc" id="L2080" title="All 2 branches missed.">        if (featureVals != null)</span>
<span class="nc" id="L2081">          featureVals[dataIndex][j] = new double[csize][];</span>
<span class="nc bnc" id="L2082" title="All 2 branches missed.">        for (int k = 0; k &lt; csize; k++) {</span>
<span class="nc" id="L2083">          Collection&lt;String&gt; features = cliques.get(k);</span>

<span class="nc" id="L2085">          data[dataIndex][j][k] = new int[features.size()];</span>
<span class="nc bnc" id="L2086" title="All 2 branches missed.">          if (featureVals != null)</span>
<span class="nc" id="L2087">            featureVals[dataIndex][j][k] = featureValList.get(k);</span>

<span class="nc" id="L2089">          int m = 0;</span>
          try {
<span class="nc bnc" id="L2091" title="All 2 branches missed.">            for (String feature : features) {</span>
              // log.info(&quot;feature &quot; + feature);
              // if (featureIndex.indexOf(feature)) ;
<span class="nc bnc" id="L2094" title="All 2 branches missed.">              if (featureIndex == null) {</span>
<span class="nc" id="L2095">                System.out.println(&quot;Feature is NULL!&quot;);</span>
              }
<span class="nc" id="L2097">              data[dataIndex][j][k][m] = featureIndex.indexOf(feature);</span>
<span class="nc" id="L2098">              m++;</span>
<span class="nc" id="L2099">            }</span>
<span class="nc" id="L2100">          } catch (Exception e) {</span>
<span class="nc" id="L2101">            log.error(&quot;Add processed data failed.&quot;, e);</span>
<span class="nc" id="L2102">            log.info(String.format(&quot;[index=%d, j=%d, k=%d, m=%d]%n&quot;, dataIndex, j, k, m));</span>
<span class="nc" id="L2103">            log.info(&quot;data.length                    &quot; + data.length);</span>
<span class="nc" id="L2104">            log.info(&quot;data[dataIndex].length         &quot; + data[dataIndex].length);</span>
<span class="nc" id="L2105">            log.info(&quot;data[dataIndex][j].length      &quot; + data[dataIndex][j].length);</span>
<span class="nc" id="L2106">            log.info(&quot;data[dataIndex][j][k].length   &quot; + data[dataIndex][j].length);</span>
<span class="nc" id="L2107">            log.info(&quot;data[dataIndex][j][k][m]       &quot; + data[dataIndex][j][k][m]);</span>
<span class="nc" id="L2108">            return;</span>
<span class="nc" id="L2109">          }</span>
        }
      }
    }
<span class="nc" id="L2113">  }</span>

  protected static void saveProcessedData(List datums, String filename) {
<span class="nc" id="L2116">    log.info(&quot;Saving processed data of size &quot; + datums.size() + &quot; to serialized file...&quot;);</span>
<span class="nc" id="L2117">    ObjectOutputStream oos = null;</span>
    try {
<span class="nc" id="L2119">      oos = new ObjectOutputStream(new FileOutputStream(filename));</span>
<span class="nc" id="L2120">      oos.writeObject(datums);</span>
<span class="nc" id="L2121">    } catch (IOException e) {</span>
      // do nothing
    } finally {
<span class="nc" id="L2124">      IOUtils.closeIgnoringExceptions(oos);</span>
<span class="nc" id="L2125">    }</span>
<span class="nc" id="L2126">    log.info(&quot;done.&quot;);</span>
<span class="nc" id="L2127">  }</span>

  protected static List&lt;List&lt;CRFDatum&lt;Collection&lt;String&gt;, String&gt;&gt;&gt; loadProcessedData(String filename) {
    List&lt;List&lt;CRFDatum&lt;Collection&lt;String&gt;, String&gt;&gt;&gt; result;
    try {
<span class="nc" id="L2132">      result = IOUtils.readObjectFromURLOrClasspathOrFileSystem(filename);</span>
<span class="nc" id="L2133">    } catch (Exception e) {</span>
<span class="nc" id="L2134">      e.printStackTrace();</span>
<span class="nc" id="L2135">      result = Collections.emptyList();</span>
<span class="nc" id="L2136">    }</span>
<span class="nc" id="L2137">    log.info(&quot;Loading processed data from serialized file ... done. Got &quot; + result.size() + &quot; datums.&quot;);</span>
<span class="nc" id="L2138">    return result;</span>
  }

  protected void loadTextClassifier(BufferedReader br) throws Exception {
<span class="nc" id="L2142">    String line = br.readLine();</span>
    // first line should be this format:
    // labelIndices.size()=\t%d
<span class="nc" id="L2145">    String[] toks = line.split(&quot;\\t&quot;);</span>
<span class="nc bnc" id="L2146" title="All 2 branches missed.">    if (!toks[0].equals(&quot;labelIndices.length=&quot;)) {</span>
<span class="nc" id="L2147">      throw new RuntimeException(&quot;format error&quot;);</span>
    }
<span class="nc" id="L2149">    int size = Integer.parseInt(toks[1]);</span>
<span class="nc" id="L2150">    labelIndices = new ArrayList&lt;&gt;(size);</span>
<span class="nc bnc" id="L2151" title="All 2 branches missed.">    for (int labelIndicesIdx = 0; labelIndicesIdx &lt; size; labelIndicesIdx++) {</span>
<span class="nc" id="L2152">      line = br.readLine();</span>
      // first line should be this format:
      // labelIndices.length=\t%d
      // labelIndices[0].size()=\t%d
<span class="nc" id="L2156">      toks = line.split(&quot;\\t&quot;);</span>
<span class="nc bnc" id="L2157" title="All 4 branches missed.">      if (!(toks[0].startsWith(&quot;labelIndices[&quot;) &amp;&amp; toks[0].endsWith(&quot;].size()=&quot;))) {</span>
<span class="nc" id="L2158">        throw new RuntimeException(&quot;format error&quot;);</span>
      }
<span class="nc" id="L2160">      int labelIndexSize = Integer.parseInt(toks[1]);</span>
<span class="nc" id="L2161">      labelIndices.add(new HashIndex&lt;&gt;());</span>
<span class="nc" id="L2162">      int count = 0;</span>
<span class="nc bnc" id="L2163" title="All 2 branches missed.">      while (count &lt; labelIndexSize) {</span>
<span class="nc" id="L2164">        line = br.readLine();</span>
<span class="nc" id="L2165">        toks = line.split(&quot;\\t&quot;);</span>
<span class="nc" id="L2166">        int idx = Integer.parseInt(toks[0]);</span>
<span class="nc bnc" id="L2167" title="All 2 branches missed.">        if (count != idx) {</span>
<span class="nc" id="L2168">          throw new RuntimeException(&quot;format error&quot;);</span>
        }

<span class="nc" id="L2171">        String[] crflabelstr = toks[1].split(&quot; &quot;);</span>
<span class="nc" id="L2172">        int[] crflabel = new int[crflabelstr.length];</span>
<span class="nc bnc" id="L2173" title="All 2 branches missed.">        for (int i = 0; i &lt; crflabelstr.length; i++) {</span>
<span class="nc" id="L2174">          crflabel[i] = Integer.parseInt(crflabelstr[i]);</span>
        }
<span class="nc" id="L2176">        CRFLabel crfL = new CRFLabel(crflabel);</span>

<span class="nc" id="L2178">        labelIndices.get(labelIndicesIdx).add(crfL);</span>
<span class="nc" id="L2179">        count++;</span>
<span class="nc" id="L2180">      }</span>
    }

<span class="nc bnc" id="L2183" title="All 2 branches missed.">    for (Index&lt;CRFLabel&gt; index : labelIndices) {</span>
<span class="nc bnc" id="L2184" title="All 2 branches missed.">      for (int j = 0; j &lt; index.size(); j++) {</span>
<span class="nc" id="L2185">        int[] label = index.get(j).getLabel();</span>
<span class="nc" id="L2186">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L2187" title="All 2 branches missed.">        for (int l : label) {</span>
<span class="nc" id="L2188">          list.add(l);</span>
        }
      }
<span class="nc" id="L2191">    }</span>

<span class="nc" id="L2193">    line = br.readLine();</span>
<span class="nc" id="L2194">    toks = line.split(&quot;\\t&quot;);</span>
<span class="nc bnc" id="L2195" title="All 2 branches missed.">    if (!toks[0].equals(&quot;classIndex.size()=&quot;)) {</span>
<span class="nc" id="L2196">      throw new RuntimeException(&quot;format error&quot;);</span>
    }
<span class="nc" id="L2198">    int classIndexSize = Integer.parseInt(toks[1]);</span>
<span class="nc" id="L2199">    classIndex = new HashIndex&lt;&gt;();</span>
<span class="nc" id="L2200">    int count = 0;</span>
<span class="nc bnc" id="L2201" title="All 2 branches missed.">    while (count &lt; classIndexSize) {</span>
<span class="nc" id="L2202">      line = br.readLine();</span>
<span class="nc" id="L2203">      toks = line.split(&quot;\\t&quot;);</span>
<span class="nc" id="L2204">      int idx = Integer.parseInt(toks[0]);</span>
<span class="nc bnc" id="L2205" title="All 2 branches missed.">      if (count != idx) {</span>
<span class="nc" id="L2206">        throw new RuntimeException(&quot;format error&quot;);</span>
      }
<span class="nc" id="L2208">      classIndex.add(toks[1]);</span>
<span class="nc" id="L2209">      count++;</span>
<span class="nc" id="L2210">    }</span>

<span class="nc" id="L2212">    line = br.readLine();</span>
<span class="nc" id="L2213">    toks = line.split(&quot;\\t&quot;);</span>
<span class="nc bnc" id="L2214" title="All 2 branches missed.">    if (!toks[0].equals(&quot;featureIndex.size()=&quot;)) {</span>
<span class="nc" id="L2215">      throw new RuntimeException(&quot;format error&quot;);</span>
    }
<span class="nc" id="L2217">    int featureIndexSize = Integer.parseInt(toks[1]);</span>
<span class="nc" id="L2218">    featureIndex = new HashIndex&lt;&gt;();</span>
<span class="nc" id="L2219">    count = 0;</span>
<span class="nc bnc" id="L2220" title="All 2 branches missed.">    while (count &lt; featureIndexSize) {</span>
<span class="nc" id="L2221">      line = br.readLine();</span>
<span class="nc" id="L2222">      toks = line.split(&quot;\\t&quot;);</span>
<span class="nc" id="L2223">      int idx = Integer.parseInt(toks[0]);</span>
<span class="nc bnc" id="L2224" title="All 2 branches missed.">      if (count != idx) {</span>
<span class="nc" id="L2225">        throw new RuntimeException(&quot;format error&quot;);</span>
      }
<span class="nc" id="L2227">      featureIndex.add(toks[1]);</span>
<span class="nc" id="L2228">      count++;</span>
<span class="nc" id="L2229">    }</span>

<span class="nc" id="L2231">    line = br.readLine();</span>
<span class="nc bnc" id="L2232" title="All 2 branches missed.">    if (!line.equals(&quot;&lt;flags&gt;&quot;)) {</span>
<span class="nc" id="L2233">      throw new RuntimeException(&quot;format error&quot;);</span>
    }
<span class="nc" id="L2235">    Properties p = new Properties();</span>
<span class="nc" id="L2236">    line = br.readLine();</span>

<span class="nc bnc" id="L2238" title="All 2 branches missed.">    while (!line.equals(&quot;&lt;/flags&gt;&quot;)) {</span>
      // log.info(&quot;DEBUG: flags line: &quot;+line);
<span class="nc" id="L2240">      String[] keyValue = line.split(&quot;=&quot;);</span>
      // System.err.printf(&quot;DEBUG: p.setProperty(%s,%s)%n&quot;, keyValue[0],
      // keyValue[1]);
<span class="nc" id="L2243">      p.setProperty(keyValue[0], keyValue[1]);</span>
<span class="nc" id="L2244">      line = br.readLine();</span>
<span class="nc" id="L2245">    }</span>

    // log.info(&quot;DEBUG: out from flags&quot;);
<span class="nc" id="L2248">    flags = new SeqClassifierFlags(p);</span>

<span class="nc bnc" id="L2250" title="All 2 branches missed.">    if (flags.useEmbedding) {</span>
<span class="nc" id="L2251">      line = br.readLine();</span>
<span class="nc" id="L2252">      toks = line.split(&quot;\\t&quot;);</span>
<span class="nc bnc" id="L2253" title="All 2 branches missed.">      if (!toks[0].equals(&quot;embeddings.size()=&quot;)) {</span>
<span class="nc" id="L2254">        throw new RuntimeException(&quot;format error in embeddings&quot;);</span>
      }
<span class="nc" id="L2256">      int embeddingSize = Integer.parseInt(toks[1]);</span>
<span class="nc" id="L2257">      embeddings = Generics.newHashMap(embeddingSize);</span>
<span class="nc" id="L2258">      count = 0;</span>
<span class="nc bnc" id="L2259" title="All 2 branches missed.">      while (count &lt; embeddingSize) {</span>
<span class="nc" id="L2260">        line = br.readLine().trim();</span>
<span class="nc" id="L2261">        toks = line.split(&quot;\\t&quot;);</span>
<span class="nc" id="L2262">        String word = toks[0];</span>
<span class="nc" id="L2263">        double[] arr = ArrayUtils.toDoubleArray(toks[1].split(&quot; &quot;));</span>
<span class="nc" id="L2264">        embeddings.put(word, arr);</span>
<span class="nc" id="L2265">        count++;</span>
<span class="nc" id="L2266">      }</span>
    }

    // &lt;featureFactory&gt;
    // edu.stanford.nlp.wordseg.Gale2007ChineseSegmenterFeatureFactory
    // &lt;/featureFactory&gt;
<span class="nc" id="L2272">    line = br.readLine();</span>

<span class="nc" id="L2274">    String[] featureFactoryName = line.split(&quot; &quot;);</span>
<span class="nc bnc" id="L2275" title="All 6 branches missed.">    if (featureFactoryName.length &lt; 2 || !featureFactoryName[0].equals(&quot;&lt;featureFactory&gt;&quot;) || !featureFactoryName[featureFactoryName.length - 1].equals(&quot;&lt;/featureFactory&gt;&quot;)) {</span>
<span class="nc" id="L2276">      throw new RuntimeException(&quot;format error unexpected featureFactory line: &quot; + line);</span>
    }
<span class="nc" id="L2278">    featureFactories = Generics.newArrayList();</span>
<span class="nc bnc" id="L2279" title="All 2 branches missed.">    for (int ff = 1; ff &lt; featureFactoryName.length - 1; ++ff) {</span>
<span class="nc" id="L2280">      FeatureFactory featureFactory = (edu.stanford.nlp.sequences.FeatureFactory&lt;IN&gt;) Class.forName(featureFactoryName[1]).newInstance();</span>
<span class="nc" id="L2281">      featureFactory.init(flags);</span>
<span class="nc" id="L2282">      featureFactories.add(featureFactory);</span>
    }

<span class="nc" id="L2285">    reinit();</span>

    // &lt;windowSize&gt; 2 &lt;/windowSize&gt;
<span class="nc" id="L2288">    line = br.readLine();</span>

<span class="nc" id="L2290">    String[] windowSizeName = line.split(&quot; &quot;);</span>
<span class="nc bnc" id="L2291" title="All 4 branches missed.">    if (!windowSizeName[0].equals(&quot;&lt;windowSize&gt;&quot;) || !windowSizeName[2].equals(&quot;&lt;/windowSize&gt;&quot;)) {</span>
<span class="nc" id="L2292">      throw new RuntimeException(&quot;format error&quot;);</span>
    }
<span class="nc" id="L2294">    windowSize = Integer.parseInt(windowSizeName[1]);</span>

    // weights.length= 2655170
<span class="nc" id="L2297">    line = br.readLine();</span>

<span class="nc" id="L2299">    toks = line.split(&quot;\\t&quot;);</span>
<span class="nc bnc" id="L2300" title="All 2 branches missed.">    if (!toks[0].equals(&quot;weights.length=&quot;)) {</span>
<span class="nc" id="L2301">      throw new RuntimeException(&quot;format error&quot;);</span>
    }
<span class="nc" id="L2303">    int weightsLength = Integer.parseInt(toks[1]);</span>
<span class="nc" id="L2304">    weights = new double[weightsLength][];</span>
<span class="nc" id="L2305">    count = 0;</span>
<span class="nc bnc" id="L2306" title="All 2 branches missed.">    while (count &lt; weightsLength) {</span>
<span class="nc" id="L2307">      line = br.readLine();</span>

<span class="nc" id="L2309">      toks = line.split(&quot;\\t&quot;);</span>
<span class="nc" id="L2310">      int weights2Length = Integer.parseInt(toks[0]);</span>
<span class="nc" id="L2311">      weights[count] = new double[weights2Length];</span>
<span class="nc" id="L2312">      String[] weightsValue = toks[1].split(&quot; &quot;);</span>
<span class="nc bnc" id="L2313" title="All 2 branches missed.">      if (weights2Length != weightsValue.length) {</span>
<span class="nc" id="L2314">        throw new RuntimeException(&quot;weights format error&quot;);</span>
      }

<span class="nc bnc" id="L2317" title="All 2 branches missed.">      for (int i2 = 0; i2 &lt; weights2Length; i2++) {</span>
<span class="nc" id="L2318">        weights[count][i2] = Double.parseDouble(weightsValue[i2]);</span>
      }
<span class="nc" id="L2320">      count++;</span>
<span class="nc" id="L2321">    }</span>
<span class="nc" id="L2322">    System.err.printf(&quot;DEBUG: double[%d][] weights loaded%n&quot;, weightsLength);</span>
<span class="nc" id="L2323">    line = br.readLine();</span>

<span class="nc bnc" id="L2325" title="All 2 branches missed.">    if (line != null) {</span>
<span class="nc" id="L2326">      throw new RuntimeException(&quot;weights format error&quot;);</span>
    }
<span class="nc" id="L2328">  }</span>

  public void loadTextClassifier(String text, Properties props) throws ClassCastException, IOException,
      ClassNotFoundException, InstantiationException, IllegalAccessException {
    // log.info(&quot;DEBUG: in loadTextClassifier&quot;);
<span class="nc" id="L2333">    log.info(&quot;Loading Text Classifier from &quot; + text);</span>
    try {
<span class="nc" id="L2335">      BufferedReader br = IOUtils.readerFromString(text);</span>
<span class="nc" id="L2336">      loadTextClassifier(br);</span>
<span class="nc" id="L2337">      br.close();</span>
<span class="nc" id="L2338">    } catch (Exception ex) {</span>
<span class="nc" id="L2339">      log.info(&quot;Exception in loading text classifier from &quot; + text);</span>
<span class="nc" id="L2340">      ex.printStackTrace();</span>
<span class="nc" id="L2341">    }</span>
<span class="nc" id="L2342">  }</span>

  protected void serializeTextClassifier(PrintWriter pw) throws Exception {
<span class="nc" id="L2345">    pw.printf(&quot;labelIndices.length=\t%d%n&quot;, labelIndices.size());</span>
<span class="nc bnc" id="L2346" title="All 2 branches missed.">    for (int i = 0; i &lt; labelIndices.size(); i++) {</span>
<span class="nc" id="L2347">      pw.printf(&quot;labelIndices[%d].size()=\t%d%n&quot;, i, labelIndices.get(i).size());</span>
<span class="nc bnc" id="L2348" title="All 2 branches missed.">      for (int j = 0; j &lt; labelIndices.get(i).size(); j++) {</span>
<span class="nc" id="L2349">        int[] label = labelIndices.get(i).get(j).getLabel();</span>
<span class="nc" id="L2350">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L2351" title="All 2 branches missed.">        for (int l : label) {</span>
<span class="nc" id="L2352">          list.add(l);</span>
        }
<span class="nc" id="L2354">        pw.printf(&quot;%d\t%s%n&quot;, j, StringUtils.join(list, &quot; &quot;));</span>
      }
    }

<span class="nc" id="L2358">    pw.printf(&quot;classIndex.size()=\t%d%n&quot;, classIndex.size());</span>
<span class="nc bnc" id="L2359" title="All 2 branches missed.">    for (int i = 0; i &lt; classIndex.size(); i++) {</span>
<span class="nc" id="L2360">      pw.printf(&quot;%d\t%s%n&quot;, i, classIndex.get(i));</span>
    }
    // pw.printf(&quot;&lt;/classIndex&gt;%n&quot;);

<span class="nc" id="L2364">    pw.printf(&quot;featureIndex.size()=\t%d%n&quot;, featureIndex.size());</span>
<span class="nc bnc" id="L2365" title="All 2 branches missed.">    for (int i = 0; i &lt; featureIndex.size(); i++) {</span>
<span class="nc" id="L2366">      pw.printf(&quot;%d\t%s%n&quot;, i, featureIndex.get(i));</span>
    }
    // pw.printf(&quot;&lt;/featureIndex&gt;%n&quot;);

<span class="nc" id="L2370">    pw.println(&quot;&lt;flags&gt;&quot;);</span>
<span class="nc" id="L2371">    pw.print(flags);</span>
<span class="nc" id="L2372">    pw.println(&quot;&lt;/flags&gt;&quot;);</span>

<span class="nc bnc" id="L2374" title="All 2 branches missed.">    if (flags.useEmbedding) {</span>
<span class="nc" id="L2375">      pw.printf(&quot;embeddings.size()=\t%d%n&quot;, embeddings.size());</span>
<span class="nc bnc" id="L2376" title="All 2 branches missed.">      for (String word: embeddings.keySet()) {</span>
<span class="nc" id="L2377">        double[] arr = embeddings.get(word);</span>
<span class="nc" id="L2378">        Double[] arrUnboxed = new Double[arr.length];</span>
<span class="nc bnc" id="L2379" title="All 2 branches missed.">        for(int i = 0; i &lt; arr.length; i++)</span>
<span class="nc" id="L2380">          arrUnboxed[i] = arr[i];</span>
<span class="nc" id="L2381">        pw.printf(&quot;%s\t%s%n&quot;, word, StringUtils.join(arrUnboxed, &quot; &quot;));</span>
<span class="nc" id="L2382">      }</span>
    }

<span class="nc" id="L2385">    pw.printf(&quot;&lt;featureFactory&gt;&quot;);</span>
<span class="nc bnc" id="L2386" title="All 2 branches missed.">    for (FeatureFactory featureFactory : featureFactories) {</span>
<span class="nc" id="L2387">      pw.printf(&quot; %s &quot;, featureFactory.getClass().getName());</span>
<span class="nc" id="L2388">    }</span>
<span class="nc" id="L2389">    pw.printf(&quot;&lt;/featureFactory&gt;%n&quot;);</span>

<span class="nc" id="L2391">    pw.printf(&quot;&lt;windowSize&gt; %d &lt;/windowSize&gt;%n&quot;, windowSize);</span>

<span class="nc" id="L2393">    pw.printf(&quot;weights.length=\t%d%n&quot;, weights.length);</span>
<span class="nc bnc" id="L2394" title="All 2 branches missed.">    for (double[] ws : weights) {</span>
<span class="nc" id="L2395">      ArrayList&lt;Double&gt; list = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L2396" title="All 2 branches missed.">      for (double w : ws) {</span>
<span class="nc" id="L2397">        list.add(w);</span>
      }
<span class="nc" id="L2399">      pw.printf(&quot;%d\t%s%n&quot;, ws.length, StringUtils.join(list, &quot; &quot;));</span>
    }
<span class="nc" id="L2401">  }</span>

  /**
   * Serialize the model to a human readable format. It's not yet complete. It
   * should now work for Chinese segmenter though. TODO: check things in
   * serializeClassifier and add other necessary serialization back.
   *
   * @param serializePath
   *          File to write text format of classifier to.
   */
  public void serializeTextClassifier(String serializePath) {
<span class="nc" id="L2412">    log.info(&quot;Serializing Text classifier to &quot; + serializePath + &quot;...&quot;);</span>
    try {
<span class="nc" id="L2414">      PrintWriter pw = new PrintWriter(new GZIPOutputStream(new FileOutputStream(serializePath)));</span>
<span class="nc" id="L2415">      serializeTextClassifier(pw);</span>

<span class="nc" id="L2417">      pw.close();</span>
<span class="nc" id="L2418">      log.info(&quot;done.&quot;);</span>

<span class="nc" id="L2420">    } catch (Exception e) {</span>
<span class="nc" id="L2421">      log.info(&quot;Failed&quot;);</span>
<span class="nc" id="L2422">      e.printStackTrace();</span>
<span class="nc" id="L2423">    }</span>
<span class="nc" id="L2424">  }</span>

  public void serializeClassIndex(String serializePath) {
<span class="nc" id="L2427">    log.info(&quot;Serializing class index to &quot; + serializePath + &quot;...&quot;);</span>

<span class="nc" id="L2429">    ObjectOutputStream oos = null;</span>
    try {
<span class="nc" id="L2431">      oos = IOUtils.writeStreamFromString(serializePath);</span>
<span class="nc" id="L2432">      oos.writeObject(classIndex);</span>
<span class="nc" id="L2433">      log.info(&quot;done.&quot;);</span>
<span class="nc" id="L2434">    } catch (Exception e) {</span>
<span class="nc" id="L2435">      log.info(&quot;Failed&quot;);</span>
<span class="nc" id="L2436">      e.printStackTrace();</span>
    } finally {
<span class="nc" id="L2438">      IOUtils.closeIgnoringExceptions(oos);</span>
<span class="nc" id="L2439">    }</span>
<span class="nc" id="L2440">  }</span>

  public static Index&lt;String&gt; loadClassIndexFromFile(String serializePath) {
<span class="nc" id="L2443">    log.info(&quot;Reading class index from &quot; + serializePath + &quot;...&quot;);</span>

<span class="nc" id="L2445">    ObjectInputStream ois = null;</span>
<span class="nc" id="L2446">    Index&lt;String&gt; c = null;</span>
    try {
<span class="nc" id="L2448">      ois = IOUtils.readStreamFromString(serializePath);</span>
<span class="nc" id="L2449">      c = (Index&lt;String&gt;) ois.readObject();</span>
<span class="nc" id="L2450">      log.info(&quot;done.&quot;);</span>
<span class="nc" id="L2451">    } catch (Exception e) {</span>
<span class="nc" id="L2452">      log.info(&quot;Failed&quot;);</span>
<span class="nc" id="L2453">      e.printStackTrace();</span>
    } finally {
<span class="nc" id="L2455">      IOUtils.closeIgnoringExceptions(ois);</span>
<span class="nc" id="L2456">    }</span>

<span class="nc" id="L2458">    return c;</span>
  }

  public void serializeWeights(String serializePath) {
<span class="nc" id="L2462">    log.info(&quot;Serializing weights to &quot; + serializePath + &quot;...&quot;);</span>

<span class="nc" id="L2464">    ObjectOutputStream oos = null;</span>
    try {
<span class="nc" id="L2466">      oos = IOUtils.writeStreamFromString(serializePath);</span>
<span class="nc" id="L2467">      oos.writeObject(weights);</span>
<span class="nc" id="L2468">      log.info(&quot;done.&quot;);</span>
<span class="nc" id="L2469">    } catch (Exception e) {</span>
<span class="nc" id="L2470">      log.info(&quot;Failed&quot;);</span>
<span class="nc" id="L2471">      e.printStackTrace();</span>
    } finally {
<span class="nc" id="L2473">      IOUtils.closeIgnoringExceptions(oos);</span>
<span class="nc" id="L2474">    }</span>
<span class="nc" id="L2475">  }</span>

  public static double[][] loadWeightsFromFile(String serializePath) {
<span class="nc" id="L2478">    log.info(&quot;Reading weights from &quot; + serializePath + &quot;...&quot;);</span>

<span class="nc" id="L2480">    ObjectInputStream ois = null;</span>
<span class="nc" id="L2481">    double[][] w = null;</span>
    try {
<span class="nc" id="L2483">      ois = IOUtils.readStreamFromString(serializePath);</span>
<span class="nc" id="L2484">      w = (double[][]) ois.readObject();</span>
<span class="nc" id="L2485">      log.info(&quot;done.&quot;);</span>
<span class="nc" id="L2486">    } catch (Exception e) {</span>
<span class="nc" id="L2487">      log.info(&quot;Failed&quot;);</span>
<span class="nc" id="L2488">      e.printStackTrace();</span>
    } finally {
<span class="nc" id="L2490">      IOUtils.closeIgnoringExceptions(ois);</span>
<span class="nc" id="L2491">    }</span>

<span class="nc" id="L2493">    return w;</span>
  }

  public void serializeFeatureIndex(String serializePath) {
<span class="nc" id="L2497">    log.info(&quot;Serializing FeatureIndex to &quot; + serializePath + &quot;...&quot;);</span>

<span class="nc" id="L2499">    ObjectOutputStream oos = null;</span>
    try {
<span class="nc" id="L2501">      oos = IOUtils.writeStreamFromString(serializePath);</span>
<span class="nc" id="L2502">      oos.writeObject(featureIndex);</span>
<span class="nc" id="L2503">      log.info(&quot;done.&quot;);</span>
<span class="nc" id="L2504">    } catch (Exception e) {</span>
<span class="nc" id="L2505">      log.info(&quot;Failed&quot;);</span>
<span class="nc" id="L2506">      e.printStackTrace();</span>
    } finally {
<span class="nc" id="L2508">      IOUtils.closeIgnoringExceptions(oos);</span>
<span class="nc" id="L2509">    }</span>
<span class="nc" id="L2510">  }</span>

  public static Index&lt;String&gt; loadFeatureIndexFromFile(String serializePath) {
<span class="nc" id="L2513">    log.info(&quot;Reading FeatureIndex from &quot; + serializePath + &quot;...&quot;);</span>

<span class="nc" id="L2515">    ObjectInputStream ois = null;</span>
<span class="nc" id="L2516">    Index&lt;String&gt; f = null;</span>
    try {
<span class="nc" id="L2518">      ois = IOUtils.readStreamFromString(serializePath);</span>
<span class="nc" id="L2519">      f = (Index&lt;String&gt;) ois.readObject();</span>
<span class="nc" id="L2520">      log.info(&quot;done.&quot;);</span>
<span class="nc" id="L2521">    } catch (Exception e) {</span>
<span class="nc" id="L2522">      log.info(&quot;Failed&quot;);</span>
<span class="nc" id="L2523">      e.printStackTrace();</span>
    } finally {
<span class="nc" id="L2525">      IOUtils.closeIgnoringExceptions(ois);</span>
<span class="nc" id="L2526">    }</span>

<span class="nc" id="L2528">    return f;</span>
  }


  /**
   * {@inheritDoc}
   */
  @Override
  public void serializeClassifier(String serializePath) {
<span class="nc" id="L2537">    log.info(&quot;Serializing classifier to &quot; + serializePath + &quot;...&quot;);</span>

<span class="nc" id="L2539">    ObjectOutputStream oos = null;</span>
    try {
<span class="nc" id="L2541">      oos = IOUtils.writeStreamFromString(serializePath);</span>
<span class="nc" id="L2542">      serializeClassifier(oos);</span>
<span class="nc" id="L2543">      log.info(&quot;done.&quot;);</span>

<span class="nc" id="L2545">    } catch (Exception e) {</span>
<span class="nc" id="L2546">      throw new RuntimeIOException(&quot;Failed to save classifier&quot;, e);</span>
    } finally {
<span class="nc" id="L2548">      IOUtils.closeIgnoringExceptions(oos);</span>
<span class="nc" id="L2549">    }</span>
<span class="nc" id="L2550">  }</span>

  /**
   * Serialize the classifier to the given ObjectOutputStream.
   * &lt;br&gt;
   * (Since the classifier is a processor, we don't want to serialize the
   * whole classifier but just the data that represents a classifier model.)
   */
  @Override
  public void serializeClassifier(ObjectOutputStream oos) {
    try {
<span class="nc" id="L2561">      oos.writeObject(labelIndices);</span>
<span class="nc" id="L2562">      oos.writeObject(classIndex);</span>
<span class="nc" id="L2563">      oos.writeObject(featureIndex);</span>
<span class="nc" id="L2564">      oos.writeObject(flags);</span>
<span class="nc bnc" id="L2565" title="All 2 branches missed.">      if (flags.useEmbedding) {</span>
<span class="nc" id="L2566">        oos.writeObject(embeddings);</span>
      }
      // For some reason, writing out the array of FeatureFactory
      // objects doesn't seem to work.  The resulting classifier
      // doesn't have the lexicon (distsim object) correctly saved.  So now custom write the list
<span class="nc" id="L2571">      oos.writeObject(featureFactories.size());</span>
<span class="nc bnc" id="L2572" title="All 2 branches missed.">      for (FeatureFactory ff : featureFactories) {</span>
<span class="nc" id="L2573">        oos.writeObject(ff);</span>
<span class="nc" id="L2574">      }</span>
<span class="nc" id="L2575">      oos.writeInt(windowSize);</span>
<span class="nc" id="L2576">      oos.writeObject(weights);</span>
      // oos.writeObject(WordShapeClassifier.getKnownLowerCaseWords());

<span class="nc" id="L2579">      oos.writeObject(knownLCWords);</span>
<span class="nc bnc" id="L2580" title="All 2 branches missed.">      if (labelDictionary != null) {</span>
<span class="nc" id="L2581">        oos.writeObject(labelDictionary);</span>
      }
<span class="nc" id="L2583">    } catch (IOException e) {</span>
<span class="nc" id="L2584">      throw new RuntimeIOException(e);</span>
<span class="nc" id="L2585">    }</span>
<span class="nc" id="L2586">  }</span>

  /**
   * Loads a classifier from the specified InputStream. This version works
   * quietly (unless VERBOSE is true). If props is non-null then any properties
   * it specifies override those in the serialized file. However, only some
   * properties are sensible to change (you shouldn't change how features are
   * defined).
   * &lt;p&gt;
   * &lt;i&gt;Note:&lt;/i&gt; This method does not close the ObjectInputStream. (But earlier
   * versions of the code used to, so beware....)
   */
  @Override
  @SuppressWarnings( { &quot;unchecked&quot; })
  // can't have right types in deserialization
  public void loadClassifier(ObjectInputStream ois, Properties props) throws ClassCastException, IOException,
      ClassNotFoundException {
<span class="nc" id="L2603">    Object o = ois.readObject();</span>
    // TODO: when we next break serialization, get rid of this fork and only read the List&lt;Index&gt; (i.e., keep first case)
<span class="nc bnc" id="L2605" title="All 2 branches missed.">    if (o instanceof List) {</span>
<span class="nc" id="L2606">      labelIndices = (List&lt;Index&lt;CRFLabel&gt;&gt;) o;</span>
    } else {
<span class="nc" id="L2608">      Index&lt;CRFLabel&gt;[] indexArray = (Index&lt;CRFLabel&gt;[]) o;</span>
<span class="nc" id="L2609">      labelIndices = new ArrayList&lt;&gt;(indexArray.length);</span>
<span class="nc" id="L2610">      Collections.addAll(labelIndices, indexArray);</span>
    }
<span class="nc" id="L2612">    classIndex = (Index&lt;String&gt;) ois.readObject();</span>
<span class="nc" id="L2613">    featureIndex = (Index&lt;String&gt;) ois.readObject();</span>
<span class="nc" id="L2614">    flags = (SeqClassifierFlags) ois.readObject();</span>
<span class="nc bnc" id="L2615" title="All 2 branches missed.">    if (flags.useEmbedding) {</span>
<span class="nc" id="L2616">      embeddings = (Map&lt;String, double[]&gt;) ois.readObject();</span>
    }
<span class="nc" id="L2618">    Object featureFactory = ois.readObject();</span>
<span class="nc bnc" id="L2619" title="All 2 branches missed.">    if (featureFactory instanceof List) {</span>
<span class="nc" id="L2620">      featureFactories = ErasureUtils.uncheckedCast(featureFactories);</span>
//      int i = 0;
//      for (FeatureFactory ff : featureFactories) { // XXXX
//        System.err.println(&quot;List FF #&quot; + i + &quot;: &quot; + ((NERFeatureFactory) ff).describeDistsimLexicon()); // XXXX
//        i++;
//      }
<span class="nc bnc" id="L2626" title="All 2 branches missed.">    } else if (featureFactory instanceof FeatureFactory) {</span>
<span class="nc" id="L2627">      featureFactories = Generics.newArrayList();</span>
<span class="nc" id="L2628">      featureFactories.add((FeatureFactory) featureFactory);</span>
//      System.err.println(((NERFeatureFactory) featureFactory).describeDistsimLexicon()); // XXXX
<span class="nc bnc" id="L2630" title="All 2 branches missed.">    } else if (featureFactory instanceof Integer) {</span>
      // this is the current format (2014) since writing list didn't work (see note in serializeClassifier).
<span class="nc" id="L2632">      int size = (Integer) featureFactory;</span>
<span class="nc" id="L2633">      featureFactories = Generics.newArrayList(size);</span>
<span class="nc bnc" id="L2634" title="All 2 branches missed.">      for (int i = 0; i &lt; size; ++i) {</span>
<span class="nc" id="L2635">        featureFactory = ois.readObject();</span>
<span class="nc bnc" id="L2636" title="All 2 branches missed.">        if (!(featureFactory instanceof FeatureFactory)) {</span>
<span class="nc" id="L2637">          throw new RuntimeIOException(&quot;Should have FeatureFactory but got &quot; + featureFactory.getClass());</span>
        }
//        System.err.println(&quot;FF #&quot; + i + &quot;: &quot; + ((NERFeatureFactory) featureFactory).describeDistsimLexicon()); // XXXX
<span class="nc" id="L2640">        featureFactories.add((FeatureFactory) featureFactory);</span>
      }
    }

    // log.info(&quot;properties passed into CRF's loadClassifier are:&quot; + props);
<span class="nc bnc" id="L2645" title="All 2 branches missed.">    if (props != null) {</span>
<span class="nc" id="L2646">      flags.setProperties(props, false);</span>
    }

<span class="nc" id="L2649">    windowSize = ois.readInt();</span>
<span class="nc" id="L2650">    weights = (double[][]) ois.readObject();</span>

    // WordShapeClassifier.setKnownLowerCaseWords((Set) ois.readObject());
<span class="nc" id="L2653">    Set&lt;String&gt; lcWords = (Set&lt;String&gt;) ois.readObject();</span>
<span class="nc bnc" id="L2654" title="All 2 branches missed.">    if (lcWords instanceof MaxSizeConcurrentHashSet) {</span>
<span class="nc" id="L2655">      knownLCWords = (MaxSizeConcurrentHashSet&lt;String&gt;) lcWords;</span>
    } else {
<span class="nc" id="L2657">      knownLCWords = new MaxSizeConcurrentHashSet&lt;&gt;(lcWords);</span>
    }

<span class="nc" id="L2660">    reinit();</span>

<span class="nc bnc" id="L2662" title="All 2 branches missed.">    if (flags.labelDictionaryCutoff &gt; 0) {</span>
<span class="nc" id="L2663">      labelDictionary = (LabelDictionary) ois.readObject();</span>
    }

    if (VERBOSE) {
      log.info(&quot;windowSize=&quot; + windowSize);
      log.info(&quot;flags=\n&quot; + flags);
    }
<span class="nc" id="L2670">  }</span>

  /**
   * This is used to load the default supplied classifier stored within the jar
   * file. THIS FUNCTION WILL ONLY WORK IF THE CODE WAS LOADED FROM A JAR FILE
   * WHICH HAS A SERIALIZED CLASSIFIER STORED INSIDE IT.
   */
  public void loadDefaultClassifier() {
<span class="nc" id="L2678">    loadJarClassifier(DEFAULT_CLASSIFIER, null);</span>
<span class="nc" id="L2679">  }</span>

  public void loadTagIndex() {
<span class="nc bnc" id="L2682" title="All 2 branches missed.">    if (tagIndex == null) {</span>
<span class="nc" id="L2683">      tagIndex = new HashIndex&lt;&gt;();</span>
<span class="nc bnc" id="L2684" title="All 2 branches missed.">      for (String tag: classIndex.objectsList()) {</span>
<span class="nc" id="L2685">        String[] parts = tag.split(&quot;-&quot;);</span>
        // if (parts.length &gt; 1)
<span class="nc" id="L2687">        tagIndex.add(parts[parts.length-1]);</span>
<span class="nc" id="L2688">      }</span>
<span class="nc" id="L2689">      tagIndex.add(flags.backgroundSymbol);</span>
    }
<span class="nc bnc" id="L2691" title="All 2 branches missed.">    if (flags.useNERPriorBIO) {</span>
<span class="nc bnc" id="L2692" title="All 2 branches missed.">      if (entityMatrices == null)</span>
<span class="nc" id="L2693">        entityMatrices = readEntityMatrices(flags.entityMatrix, tagIndex);</span>
    }
<span class="nc" id="L2695">  }</span>

  private static double[][] parseMatrix(String[] lines, Index&lt;String&gt; tagIndex, int matrixSize, boolean smooth) {
<span class="nc" id="L2698">    return parseMatrix(lines, tagIndex, matrixSize, smooth, true);</span>
  }

  /**
   * @return a matrix where each entry m[i][j] is logP(j|i)
   * in other words, each row vector is normalized log conditional likelihood
   */
   static double[][] parseMatrix(String[] lines, Index&lt;String&gt; tagIndex, int matrixSize, boolean smooth, boolean useLogProb) {
<span class="nc" id="L2706">    double[][] matrix = new double[matrixSize][matrixSize];</span>
<span class="nc bnc" id="L2707" title="All 2 branches missed.">    for (int i = 0; i &lt; matrix.length; i++)</span>
<span class="nc" id="L2708">      matrix[i] = new double[matrixSize];</span>
<span class="nc bnc" id="L2709" title="All 2 branches missed.">    for (String line: lines) {</span>
<span class="nc" id="L2710">      String[] parts = line.split(&quot;\t&quot;);</span>
<span class="nc bnc" id="L2711" title="All 2 branches missed.">      for (String part: parts) {</span>
<span class="nc" id="L2712">        String[] subparts = part.split(&quot; &quot;);</span>
<span class="nc" id="L2713">        String[] subsubparts = subparts[0].split(&quot;:&quot;);</span>
<span class="nc" id="L2714">        double counts = Double.parseDouble(subparts[1]);</span>
<span class="nc bnc" id="L2715" title="All 4 branches missed.">        if (counts == 0.0 &amp;&amp; smooth) // smoothing</span>
<span class="nc" id="L2716">          counts = 1.0;</span>
<span class="nc" id="L2717">        int tagIndex1 = tagIndex.indexOf(subsubparts[0]);</span>
<span class="nc" id="L2718">        int tagIndex2 = tagIndex.indexOf(subsubparts[1]);</span>
<span class="nc" id="L2719">        matrix[tagIndex1][tagIndex2] = counts;</span>
      }
    }
<span class="nc bnc" id="L2722" title="All 2 branches missed.">    for (int i = 0; i &lt; matrix.length; i++) {</span>
<span class="nc" id="L2723">      double sum = ArrayMath.sum(matrix[i]);</span>
<span class="nc bnc" id="L2724" title="All 2 branches missed.">      for (int j = 0; j &lt; matrix[i].length; j++) {</span>
        // log conditional probability
<span class="nc bnc" id="L2726" title="All 2 branches missed.">        if (useLogProb)</span>
<span class="nc" id="L2727">          matrix[i][j] = Math.log(matrix[i][j] / sum);</span>
        else
<span class="nc" id="L2729">          matrix[i][j] = matrix[i][j] / sum;</span>
      }
    }
<span class="nc" id="L2732">    return matrix;</span>
  }

  static Pair&lt;double[][], double[][]&gt; readEntityMatrices(String fileName, Index&lt;String&gt; tagIndex) {
<span class="nc" id="L2736">    int numTags = tagIndex.size();</span>
<span class="nc" id="L2737">    int matrixSize = numTags-1;</span>

<span class="nc" id="L2739">    String[] matrixLines = new String[matrixSize];</span>
<span class="nc" id="L2740">    String[] subMatrixLines = new String[matrixSize];</span>
    try {
<span class="nc" id="L2742">      BufferedReader br = IOUtils.readerFromString(fileName);</span>
<span class="nc" id="L2743">      int lineCount = 0;</span>
<span class="nc bnc" id="L2744" title="All 2 branches missed.">      for (String line; (line = br.readLine()) != null; ) {</span>
<span class="nc" id="L2745">        line = line.trim();</span>
<span class="nc bnc" id="L2746" title="All 2 branches missed.">        if (lineCount &lt; matrixSize)</span>
<span class="nc" id="L2747">          matrixLines[lineCount] = line;</span>
        else
<span class="nc" id="L2749">          subMatrixLines[lineCount-matrixSize] = line;</span>
<span class="nc" id="L2750">        lineCount++;</span>
      }
<span class="nc" id="L2752">    } catch (Exception ex) {</span>
<span class="nc" id="L2753">      throw new RuntimeIOException(ex);</span>
<span class="nc" id="L2754">    }</span>

<span class="nc" id="L2756">    double[][] matrix = parseMatrix(matrixLines, tagIndex, matrixSize, true);</span>
<span class="nc" id="L2757">    double[][] subMatrix = parseMatrix(subMatrixLines, tagIndex, matrixSize, true);</span>

    // In Jenny's paper, use the square root of non-log prob for matrix, but not for subMatrix
<span class="nc bnc" id="L2760" title="All 2 branches missed.">    for (int i = 0; i &lt; matrix.length; i++) {</span>
<span class="nc bnc" id="L2761" title="All 2 branches missed.">      for (int j = 0; j &lt; matrix[i].length; j++)</span>
<span class="nc" id="L2762">        matrix[i][j] = matrix[i][j] / 2;</span>
    }

<span class="nc" id="L2765">    log.info(&quot;Matrix: &quot;);</span>
<span class="nc" id="L2766">    log.info(ArrayUtils.toString(matrix));</span>
<span class="nc" id="L2767">    log.info(&quot;SubMatrix: &quot;);</span>
<span class="nc" id="L2768">    log.info(ArrayUtils.toString(subMatrix));</span>

<span class="nc" id="L2770">    return new Pair&lt;&gt;(matrix, subMatrix);</span>
  }

  public void writeWeights(PrintStream p) {
<span class="nc bnc" id="L2774" title="All 2 branches missed.">    for (String feature : featureIndex) {</span>
<span class="nc" id="L2775">      int index = featureIndex.indexOf(feature);</span>
      // line.add(feature+&quot;[&quot;+(-p)+&quot;]&quot;);
      // rowHeaders.add(feature + '[' + (-p) + ']');
<span class="nc" id="L2778">      double[] v = weights[index];</span>
<span class="nc" id="L2779">      Index&lt;CRFLabel&gt; l = this.labelIndices.get(0);</span>
<span class="nc" id="L2780">      p.println(feature + &quot;\t\t&quot;);</span>
<span class="nc bnc" id="L2781" title="All 2 branches missed.">      for (CRFLabel label : l) {</span>
<span class="nc" id="L2782">        p.print(label.toString(classIndex) + &quot;:&quot; + v[l.indexOf(label)] + &quot;\t&quot;);</span>
<span class="nc" id="L2783">      }</span>
<span class="nc" id="L2784">      p.println();</span>

<span class="nc" id="L2786">    }</span>
<span class="nc" id="L2787">  }</span>

  public Map&lt;String, Counter&lt;String&gt;&gt; topWeights() {
<span class="nc" id="L2790">    Map&lt;String, Counter&lt;String&gt;&gt; w = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L2791" title="All 2 branches missed.">    for (String feature : featureIndex) {</span>
<span class="nc" id="L2792">      int index = featureIndex.indexOf(feature);</span>
      // line.add(feature+&quot;[&quot;+(-p)+&quot;]&quot;);
      // rowHeaders.add(feature + '[' + (-p) + ']');
<span class="nc" id="L2795">      double[] v = weights[index];</span>
<span class="nc" id="L2796">      Index&lt;CRFLabel&gt; l = this.labelIndices.get(0);</span>
<span class="nc bnc" id="L2797" title="All 2 branches missed.">      for (CRFLabel label : l) {</span>
<span class="nc bnc" id="L2798" title="All 2 branches missed.">        if(!w.containsKey(label.toString(classIndex)))</span>
<span class="nc" id="L2799">          w.put(label.toString(classIndex), new ClassicCounter&lt;&gt;());</span>
<span class="nc" id="L2800">        w.get(label.toString(classIndex)).setCount(feature, v[l.indexOf(label)]);</span>
<span class="nc" id="L2801">      }</span>
<span class="nc" id="L2802">    }</span>
<span class="nc" id="L2803">    return w;</span>
  }

  /** Read real-valued vector embeddings for (lowercased) word tokens.
   *  A lexicon is contained in the file flags.embeddingWords.
   *  The word vectors are then in the same order in the file flags.embeddingVectors.
   * @throws IOException
   */
  private void readEmbeddingsData() throws IOException {
<span class="nc" id="L2812">    System.err.printf(&quot;Reading embedding files %s and %s.%n&quot;, flags.embeddingWords, flags.embeddingVectors);</span>
<span class="nc" id="L2813">    BufferedReader br = IOUtils.readerFromString(flags.embeddingWords);</span>

<span class="nc" id="L2815">    List&lt;String&gt; wordList = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L2816" title="All 2 branches missed.">    for (String line ; (line = br.readLine()) != null; ) {</span>
<span class="nc" id="L2817">      wordList.add(line.trim());</span>
    }
<span class="nc" id="L2819">    log.info(&quot;Found a dictionary of size &quot; + wordList.size());</span>
<span class="nc" id="L2820">    br.close();</span>

<span class="nc" id="L2822">    embeddings = Generics.newHashMap();</span>
<span class="nc" id="L2823">    int count = 0;</span>
<span class="nc" id="L2824">    int vectorSize = -1;</span>
<span class="nc" id="L2825">    boolean warned = false;</span>
<span class="nc" id="L2826">    br = IOUtils.readerFromString(flags.embeddingVectors);</span>
<span class="nc bnc" id="L2827" title="All 2 branches missed.">    for (String line ; (line = br.readLine()) != null; ) {</span>
<span class="nc" id="L2828">      double[] vector = ArrayUtils.toDoubleArray(line.trim().split(&quot; &quot;));</span>
<span class="nc bnc" id="L2829" title="All 2 branches missed.">      if (vectorSize &lt; 0) {</span>
<span class="nc" id="L2830">        vectorSize = vector.length;</span>
      } else {
<span class="nc bnc" id="L2832" title="All 4 branches missed.">        if (vectorSize != vector.length &amp;&amp; ! warned) {</span>
<span class="nc" id="L2833">          log.info(&quot;Inconsistent vector lengths: &quot; + vectorSize + &quot; vs. &quot; + vector.length);</span>
<span class="nc" id="L2834">          warned = true;</span>
        }
      }
<span class="nc" id="L2837">      embeddings.put(wordList.get(count++), vector);</span>
<span class="nc" id="L2838">    }</span>
<span class="nc" id="L2839">    log.info(&quot;Found &quot; + count + &quot; matching embeddings of dimension &quot; + vectorSize);</span>
<span class="nc" id="L2840">  }</span>

  @Override
  public List&lt;IN&gt; classifyWithGlobalInformation(List&lt;IN&gt; tokenSeq, final CoreMap doc, final CoreMap sent) {
<span class="nc" id="L2844">    return classify(tokenSeq);</span>
  }



  /**
   * This is used to load the default supplied classifier stored within the jar
   * file. THIS FUNCTION WILL ONLY WORK IF THE CODE WAS LOADED FROM A JAR FILE
   * WHICH HAS A SERIALIZED CLASSIFIER STORED INSIDE IT.
   */
  public void loadDefaultClassifier(Properties props) {
<span class="nc" id="L2855">    loadJarClassifier(DEFAULT_CLASSIFIER, props);</span>
<span class="nc" id="L2856">  }</span>

  /**
   * Used to get the default supplied classifier inside the jar file. THIS
   * FUNCTION WILL ONLY WORK IF THE CODE WAS LOADED FROM A JAR FILE WHICH HAS A
   * SERIALIZED CLASSIFIER STORED INSIDE IT.
   *
   * @return The default CRFClassifier in the jar file (if there is one)
   */
  public static &lt;INN extends CoreMap&gt; CRFClassifier&lt;INN&gt; getDefaultClassifier() {
<span class="nc" id="L2866">    CRFClassifier&lt;INN&gt; crf = new CRFClassifier&lt;&gt;();</span>
<span class="nc" id="L2867">    crf.loadDefaultClassifier();</span>
<span class="nc" id="L2868">    return crf;</span>
  }

  /**
   * Used to get the default supplied classifier inside the jar file. THIS
   * FUNCTION WILL ONLY WORK IF THE CODE WAS LOADED FROM A JAR FILE WHICH HAS A
   * SERIALIZED CLASSIFIER STORED INSIDE IT.
   *
   * @return The default CRFClassifier in the jar file (if there is one)
   */
  public static &lt;INN extends CoreMap&gt; CRFClassifier&lt;INN&gt; getDefaultClassifier(Properties props) {
<span class="nc" id="L2879">    CRFClassifier&lt;INN&gt; crf = new CRFClassifier&lt;&gt;();</span>
<span class="nc" id="L2880">    crf.loadDefaultClassifier(props);</span>
<span class="nc" id="L2881">    return crf;</span>
  }

  /**
   * Used to load a classifier stored as a resource inside a jar file. THIS
   * FUNCTION WILL ONLY WORK IF THE CODE WAS LOADED FROM A JAR FILE WHICH HAS A
   * SERIALIZED CLASSIFIER STORED INSIDE IT.
   *
   * @param resourceName Name of classifier resource inside the jar file.
   * @return A CRFClassifier stored in the jar file
   */
  public static &lt;INN extends CoreMap&gt; CRFClassifier&lt;INN&gt; getJarClassifier(String resourceName, Properties props) {
<span class="nc" id="L2893">    CRFClassifier&lt;INN&gt; crf = new CRFClassifier&lt;&gt;();</span>
<span class="nc" id="L2894">    crf.loadJarClassifier(resourceName, props);</span>
<span class="nc" id="L2895">    return crf;</span>
  }

  /**
   * Loads a CRF classifier from a filepath, and returns it.
   *
   * @param file
   *          File to load classifier from
   * @return The CRF classifier
   *
   * @throws IOException
   *           If there are problems accessing the input stream
   * @throws ClassCastException
   *           If there are problems interpreting the serialized data
   * @throws ClassNotFoundException
   *           If there are problems interpreting the serialized data
   */
  public static &lt;INN extends CoreMap&gt; CRFClassifier&lt;INN&gt; getClassifier(File file) throws IOException, ClassCastException,
      ClassNotFoundException {
<span class="nc" id="L2914">    CRFClassifier&lt;INN&gt; crf = new CRFClassifier&lt;&gt;();</span>
<span class="nc" id="L2915">    crf.loadClassifier(file);</span>
<span class="nc" id="L2916">    return crf;</span>
  }

  /**
   * Loads a CRF classifier from an InputStream, and returns it. This method
   * does not buffer the InputStream, so you should have buffered it before
   * calling this method.
   *
   * @param in InputStream to load classifier from
   * @return The CRF classifier
   *
   * @throws IOException If there are problems accessing the input stream
   * @throws ClassCastException If there are problems interpreting the serialized data
   * @throws ClassNotFoundException If there are problems interpreting the serialized data
   */
  public static &lt;INN extends CoreMap&gt; CRFClassifier&lt;INN&gt; getClassifier(InputStream in) throws IOException, ClassCastException,
      ClassNotFoundException {
<span class="nc" id="L2933">    CRFClassifier&lt;INN&gt; crf = new CRFClassifier&lt;&gt;();</span>
<span class="nc" id="L2934">    crf.loadClassifier(in);</span>
<span class="nc" id="L2935">    return crf;</span>
  }

  // new method for getting a CRFClassifier from an ObjectInputStream
  public static &lt;INN extends CoreMap&gt; CRFClassifier&lt;INN&gt; getClassifier(ObjectInputStream ois) throws IOException,
          ClassCastException,
          ClassNotFoundException {
<span class="nc" id="L2942">    CRFClassifier&lt;INN&gt; crf = new CRFClassifier&lt;&gt;();</span>
<span class="nc" id="L2943">    crf.loadClassifier(ois,null);</span>
<span class="nc" id="L2944">    return crf;</span>
  }

  public static &lt;INN extends CoreMap&gt; CRFClassifier&lt;INN&gt; getClassifierNoExceptions(String loadPath) {
<span class="nc" id="L2948">    CRFClassifier&lt;INN&gt; crf = new CRFClassifier&lt;&gt;();</span>
<span class="nc" id="L2949">    crf.loadClassifierNoExceptions(loadPath);</span>
<span class="nc" id="L2950">    return crf;</span>
  }

  public static CRFClassifier&lt;CoreLabel&gt; getClassifier(String loadPath) throws IOException, ClassCastException,
      ClassNotFoundException {
<span class="nc" id="L2955">    CRFClassifier&lt;CoreLabel&gt; crf = new CRFClassifier&lt;&gt;();</span>
<span class="nc" id="L2956">    crf.loadClassifier(loadPath);</span>
<span class="nc" id="L2957">    return crf;</span>
  }

  public static &lt;INN extends CoreMap&gt; CRFClassifier&lt;INN&gt; getClassifier(String loadPath, Properties props) throws IOException, ClassCastException,
      ClassNotFoundException {
<span class="nc" id="L2962">    CRFClassifier&lt;INN&gt; crf = new CRFClassifier&lt;&gt;();</span>
<span class="nc" id="L2963">    crf.loadClassifier(loadPath, props);</span>
<span class="nc" id="L2964">    return crf;</span>
  }

  public static &lt;INN extends CoreMap&gt; CRFClassifier&lt;INN&gt; getClassifier(ObjectInputStream ois, Properties props) throws IOException, ClassCastException,
      ClassNotFoundException {
<span class="nc" id="L2969">    CRFClassifier&lt;INN&gt; crf = new CRFClassifier&lt;&gt;();</span>
<span class="nc" id="L2970">    crf.loadClassifier(ois, props);</span>
<span class="nc" id="L2971">    return crf;</span>
  }

  private static CRFClassifier&lt;CoreLabel&gt; chooseCRFClassifier(SeqClassifierFlags flags) {
    CRFClassifier&lt;CoreLabel&gt; crf; // initialized in if/else
<span class="nc bnc" id="L2976" title="All 2 branches missed.">    if (flags.useFloat) {</span>
<span class="nc" id="L2977">      crf = new CRFClassifierFloat&lt;&gt;(flags);</span>
<span class="nc bnc" id="L2978" title="All 2 branches missed.">    } else if (flags.nonLinearCRF) {</span>
<span class="nc" id="L2979">      crf = new CRFClassifierNonlinear&lt;&gt;(flags);</span>
<span class="nc bnc" id="L2980" title="All 2 branches missed.">    } else if (flags.numLopExpert &gt; 1) {</span>
<span class="nc" id="L2981">      crf = new CRFClassifierWithLOP&lt;&gt;(flags);</span>
<span class="nc bnc" id="L2982" title="All 2 branches missed.">    } else if (flags.priorType.equals(&quot;DROPOUT&quot;)) {</span>
<span class="nc" id="L2983">      crf = new CRFClassifierWithDropout&lt;&gt;(flags);</span>
<span class="nc bnc" id="L2984" title="All 2 branches missed.">    } else if (flags.useNoisyLabel) {</span>
<span class="nc" id="L2985">      crf = new CRFClassifierNoisyLabel&lt;&gt;(flags);</span>
    } else {
<span class="nc" id="L2987">      crf = new CRFClassifier&lt;&gt;(flags);</span>
    }
<span class="nc" id="L2989">    return crf;</span>
  }

  /** The main method. See the class documentation. */
  public static void main(String[] args) throws Exception {
<span class="nc" id="L2994">    StringUtils.logInvocationString(log, args);</span>

<span class="nc" id="L2996">    Properties props = StringUtils.argsToProperties(args);</span>
<span class="nc" id="L2997">    SeqClassifierFlags flags = new SeqClassifierFlags(props);</span>
<span class="nc" id="L2998">    CRFClassifier&lt;CoreLabel&gt; crf = chooseCRFClassifier(flags);</span>
<span class="nc" id="L2999">    String testFile = flags.testFile;</span>
<span class="nc" id="L3000">    String testFiles = flags.testFiles;</span>
<span class="nc" id="L3001">    String textFile = flags.textFile;</span>
<span class="nc" id="L3002">    String textFiles = flags.textFiles;</span>
<span class="nc" id="L3003">    String loadPath = flags.loadClassifier;</span>
<span class="nc" id="L3004">    String loadTextPath = flags.loadTextClassifier;</span>
<span class="nc" id="L3005">    String serializeTo = flags.serializeTo;</span>
<span class="nc" id="L3006">    String serializeToText = flags.serializeToText;</span>

<span class="nc bnc" id="L3008" title="All 6 branches missed.">    if (crf.flags.useEmbedding &amp;&amp; crf.flags.embeddingWords != null &amp;&amp; crf.flags.embeddingVectors != null) {</span>
<span class="nc" id="L3009">      crf.readEmbeddingsData();</span>
    }

<span class="nc bnc" id="L3012" title="All 2 branches missed.">    if (crf.flags.loadClassIndexFrom != null) {</span>
<span class="nc" id="L3013">      crf.classIndex = loadClassIndexFromFile(crf.flags.loadClassIndexFrom);</span>
    }

<span class="nc bnc" id="L3016" title="All 2 branches missed.">    if (loadPath != null) {</span>
<span class="nc" id="L3017">      crf.loadClassifierNoExceptions(loadPath, props);</span>
<span class="nc bnc" id="L3018" title="All 2 branches missed.">    } else if (loadTextPath != null) {</span>
<span class="nc" id="L3019">      log.info(&quot;Warning: this is now only tested for Chinese Segmenter&quot;);</span>
<span class="nc" id="L3020">      log.info(&quot;(Sun Dec 23 00:59:39 2007) (pichuan)&quot;);</span>
      try {
<span class="nc" id="L3022">        crf.loadTextClassifier(loadTextPath, props);</span>
        // log.info(&quot;DEBUG: out from crf.loadTextClassifier&quot;);
<span class="nc" id="L3024">      } catch (Exception e) {</span>
<span class="nc" id="L3025">        throw new RuntimeException(&quot;error loading &quot; + loadTextPath, e);</span>
<span class="nc" id="L3026">      }</span>
<span class="nc bnc" id="L3027" title="All 2 branches missed.">    } else if (crf.flags.loadJarClassifier != null) {</span>
<span class="nc" id="L3028">      crf.loadJarClassifier(crf.flags.loadJarClassifier, props);</span>
<span class="nc bnc" id="L3029" title="All 4 branches missed.">    } else if (crf.flags.trainFile != null || crf.flags.trainFileList != null) {</span>
<span class="nc" id="L3030">      Timing timing = new Timing();</span>
      // temporarily unlimited size of knownLCWords
<span class="nc" id="L3032">      int knownLCWordsLimit = crf.knownLCWords.getMaxSize();</span>
<span class="nc" id="L3033">      crf.knownLCWords.setMaxSize(-1);</span>
<span class="nc" id="L3034">      crf.train();</span>
<span class="nc" id="L3035">      crf.knownLCWords.setMaxSize(knownLCWordsLimit);</span>
<span class="nc" id="L3036">      timing.done(log, &quot;CRFClassifier training&quot;);</span>
<span class="nc" id="L3037">    } else {</span>
<span class="nc" id="L3038">      crf.loadDefaultClassifier();</span>
    }

<span class="nc" id="L3041">    crf.loadTagIndex();</span>

<span class="nc bnc" id="L3043" title="All 2 branches missed.">    if (serializeTo != null) {</span>
<span class="nc" id="L3044">      crf.serializeClassifier(serializeTo);</span>
    }

<span class="nc bnc" id="L3047" title="All 2 branches missed.">    if (crf.flags.serializeWeightsTo != null) {</span>
<span class="nc" id="L3048">      crf.serializeWeights(crf.flags.serializeWeightsTo);</span>
    }

<span class="nc bnc" id="L3051" title="All 2 branches missed.">    if (crf.flags.serializeFeatureIndexTo != null) {</span>
<span class="nc" id="L3052">      crf.serializeFeatureIndex(crf.flags.serializeFeatureIndexTo);</span>
    }

<span class="nc bnc" id="L3055" title="All 2 branches missed.">    if (serializeToText != null) {</span>
<span class="nc" id="L3056">      crf.serializeTextClassifier(serializeToText);</span>
    }

<span class="nc bnc" id="L3059" title="All 2 branches missed.">    if (testFile != null) {</span>
      // todo: Change testFile to call testFiles with a singleton list
<span class="nc" id="L3061">      DocumentReaderAndWriter&lt;CoreLabel&gt; readerAndWriter = crf.defaultReaderAndWriter();</span>
<span class="nc bnc" id="L3062" title="All 2 branches missed.">      if (crf.flags.searchGraphPrefix != null) {</span>
<span class="nc" id="L3063">        crf.classifyAndWriteViterbiSearchGraph(testFile, crf.flags.searchGraphPrefix, readerAndWriter);</span>
<span class="nc bnc" id="L3064" title="All 2 branches missed.">      } else if (crf.flags.printFirstOrderProbs) {</span>
<span class="nc" id="L3065">        crf.printFirstOrderProbs(testFile, readerAndWriter);</span>
<span class="nc bnc" id="L3066" title="All 2 branches missed.">      } else if (crf.flags.printFactorTable) {</span>
<span class="nc" id="L3067">        crf.printFactorTable(testFile, readerAndWriter);</span>
<span class="nc bnc" id="L3068" title="All 2 branches missed.">      } else if (crf.flags.printProbs) {</span>
<span class="nc" id="L3069">        crf.printProbs(testFile, readerAndWriter);</span>
<span class="nc bnc" id="L3070" title="All 2 branches missed.">      } else if (crf.flags.useKBest) {</span>
<span class="nc" id="L3071">        int k = crf.flags.kBest;</span>
<span class="nc" id="L3072">        crf.classifyAndWriteAnswersKBest(testFile, k, readerAndWriter);</span>
<span class="nc bnc" id="L3073" title="All 2 branches missed.">      } else if (crf.flags.printLabelValue) {</span>
<span class="nc" id="L3074">        crf.printLabelInformation(testFile, readerAndWriter);</span>
      } else {
<span class="nc" id="L3076">        crf.classifyAndWriteAnswers(testFile, readerAndWriter, true);</span>
      }
    }

<span class="nc bnc" id="L3080" title="All 2 branches missed.">    if (testFiles != null) {</span>
<span class="nc" id="L3081">      List&lt;File&gt; files = Arrays.stream(testFiles.split(&quot;,&quot;)).map(File::new).collect(Collectors.toList());</span>
<span class="nc bnc" id="L3082" title="All 2 branches missed.">      if (crf.flags.printProbs) {</span>
<span class="nc" id="L3083">        crf.printProbs(files, crf.defaultReaderAndWriter());</span>
      } else {
<span class="nc" id="L3085">        crf.classifyFilesAndWriteAnswers(files, crf.defaultReaderAndWriter(), true);</span>
      }
    }

<span class="nc bnc" id="L3089" title="All 2 branches missed.">    if (textFile != null) {</span>
<span class="nc" id="L3090">      crf.classifyAndWriteAnswers(textFile, crf.plainTextReaderAndWriter(), false);</span>
    }

<span class="nc bnc" id="L3093" title="All 2 branches missed.">    if (textFiles != null) {</span>
<span class="nc" id="L3094">      List&lt;File&gt; files = Arrays.stream(textFiles.split(&quot;,&quot;)).map(File::new).collect(Collectors.toList());</span>
<span class="nc" id="L3095">      crf.classifyFilesAndWriteAnswers(files);</span>
    }

<span class="nc bnc" id="L3098" title="All 2 branches missed.">    if (crf.flags.readStdin) {</span>
<span class="nc" id="L3099">      crf.classifyStdin();</span>
    }
<span class="nc" id="L3101">  } // end main</span>

} // end class CRFClassifier
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>