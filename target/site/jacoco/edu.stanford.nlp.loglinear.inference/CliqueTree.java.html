<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CliqueTree.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.loglinear.inference</a> &gt; <span class="el_source">CliqueTree.java</span></div><h1>CliqueTree.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.loglinear.inference;

import edu.stanford.nlp.util.logging.Redwood;
import edu.stanford.nlp.loglinear.model.ConcatVector;
import edu.stanford.nlp.loglinear.model.GraphicalModel;

import java.util.*;

/**
 * Created on 8/11/15.
 * @author keenon
 * &lt;p&gt;
 * This is instantiated once per model, so that it can keep caches of important stuff like messages and
 * local factors during many game playing sample steps. It assumes that the model that is passed in is by-reference,
 * and that it can change between inference calls in small ways, so that cacheing of some results is worthwhile.
 */
<span class="pc bpc" id="L17" title="1 of 2 branches missed.">public class CliqueTree  {</span>

  /** A logger for this class */
<span class="fc" id="L20">  private static final Redwood.RedwoodChannels log = Redwood.channels(CliqueTree.class);</span>
  private GraphicalModel model;
  private ConcatVector weights;

  // This is the metadata key for the model to store an observed value for a variable, as an int
  public static final String VARIABLE_OBSERVED_VALUE = &quot;inference.CliqueTree.VARIABLE_OBSERVED_VALUE&quot;;

  private static final boolean CACHE_MESSAGES = true;

  /**
   * Create an Inference object for a given set of weights, and a model.
   * &lt;p&gt;
   * The object is around to facilitate cacheing as an eventual optimization, when models are changing in minor ways
   * and inference is required several times. Work is done lazily, so is left until actual inference is requested.
   *
   * @param model   the model to be computed over, subject to change in the future
   * @param weights the weights to dot product with model features to get log-linear factors, is cloned internally so
   *                that no changes to the weights vector will be reflected by the CliqueTree. If you want to change
   *                the weights, you must create a new CliqueTree.
   */
<span class="fc" id="L40">  public CliqueTree(GraphicalModel model, ConcatVector weights) {</span>
<span class="fc" id="L41">    this.model = model;</span>
<span class="fc" id="L42">    this.weights = weights.deepClone();</span>
<span class="fc" id="L43">  }</span>

  /**
   * Little data structure for passing around the results of marginal computations.
   */
  public static class MarginalResult {
    public double[][] marginals;
    public double partitionFunction;
    public Map&lt;GraphicalModel.Factor, TableFactor&gt; jointMarginals;

<span class="fc" id="L53">    public MarginalResult(double[][] marginals, double partitionFunction, Map&lt;GraphicalModel.Factor, TableFactor&gt; jointMarginals) {</span>
<span class="fc" id="L54">      this.marginals = marginals;</span>
<span class="fc" id="L55">      this.partitionFunction = partitionFunction;</span>
<span class="fc" id="L56">      this.jointMarginals = jointMarginals;</span>
<span class="fc" id="L57">    }</span>
  }

  /**
   * This assumes that factors represent joint probabilities.
   *
   * @return global marginals
   */
  public MarginalResult calculateMarginals() {
<span class="fc" id="L66">    return messagePassing(MarginalizationMethod.SUM, true);</span>
  }

  /**
   * This will calculate marginals, but skip the stuff that is created for gradient descent: joint marginals and
   * partition functions. This makes it much faster. It is thus appropriate for gameplayer style work, where many
   * samples need to be drawn with the same marginals.
   *
   * @return an array, indexed first by variable, then by variable assignment, of global probability
   */
  public double[][] calculateMarginalsJustSingletons() {
<span class="nc" id="L77">    MarginalResult result = messagePassing(MarginalizationMethod.SUM, false);</span>
<span class="nc" id="L78">    return result.marginals;</span>
  }

  /**
   * This assumes that factors represent joint probabilities.
   *
   * @return an array, indexed by variable, of maximum likelihood assignments
   */
  public int[] calculateMAP() {
<span class="fc" id="L87">    double[][] mapMarginals = messagePassing(MarginalizationMethod.MAX, false).marginals;</span>
<span class="fc" id="L88">    int[] result = new int[mapMarginals.length];</span>
<span class="fc bfc" id="L89" title="All 2 branches covered.">    for (int i = 0; i &lt; result.length; i++) {</span>
<span class="fc bfc" id="L90" title="All 2 branches covered.">      if (mapMarginals[i] != null) {</span>
<span class="fc bfc" id="L91" title="All 2 branches covered.">        for (int j = 0; j &lt; mapMarginals[i].length; j++) {</span>
<span class="fc bfc" id="L92" title="All 2 branches covered.">          if (mapMarginals[i][j] &gt; mapMarginals[i][result[i]]) {</span>
<span class="fc" id="L93">            result[i] = j;</span>
          }
        }
      }
      // If there is no factor touching an observed variable, the resulting MAP won't reference the variable
      // observation since message passing won't touch the variable index
<span class="fc bfc" id="L99" title="All 2 branches covered.">      if (model.getVariableMetaDataByReference(i).containsKey(VARIABLE_OBSERVED_VALUE)) {</span>
<span class="fc" id="L100">        result[i] = Integer.parseInt(model.getVariableMetaDataByReference(i).get(VARIABLE_OBSERVED_VALUE));</span>
      }
    }
<span class="fc" id="L103">    return result;</span>
  }

  ////////////////////////////////////////////////////////////////////////////
  // PRIVATE IMPLEMENTATION
  ////////////////////////////////////////////////////////////////////////////

<span class="pc" id="L110">  private enum MarginalizationMethod {</span>
<span class="fc" id="L111">    SUM,</span>
<span class="fc" id="L112">    MAX</span>
  }

  // OPTIMIZATION:
  // cache the creation of TableFactors, to avoid redundant dot products

<span class="fc" id="L118">  private IdentityHashMap&lt;GraphicalModel.Factor, CachedFactorWithObservations&gt; cachedFactors = new IdentityHashMap&lt;&gt;();</span>

<span class="fc" id="L120">  private static class CachedFactorWithObservations {</span>
    TableFactor cachedFactor;
    int[] observations;
    boolean impossibleObservation;
  }

  // OPTIMIZATION:
  // cache the last list of factors, and the last set of messages passed, in case we can recycle some

  private TableFactor[] cachedCliqueList;
  private TableFactor[][] cachedMessages;
  private boolean[][] cachedBackwardPassedMessages;

  /**
   * Does tree shaped message passing. The algorithm calls for first passing down to the leaves, then passing back up
   * to the root.
   *
   * @param marginalize the method for marginalization, controls MAP or marginals
   * @return the marginal messages
   */
  private MarginalResult messagePassing(MarginalizationMethod marginalize, boolean includeJointMarginalsAndPartition) {

    // Using the behavior of brute force factor multiplication as ground truth, the desired
    // outcome of marginal calculation with an impossible factor is a uniform probability dist.,
    // since we have a resulting factor of all 0s. That is of course assuming that normalizing
    // all 0s gives you uniform, which is not real math, but that's a useful tolerance to include, so we do.

<span class="fc" id="L147">    boolean impossibleObservationMade = false;</span>

    // Message passing will look at fully observed cliques as non-entities, but their
    // log-likelihood (the log-likelihood of the single observed value) is still relevant for the
    // partition function.

<span class="fc" id="L153">    double partitionFunction = 1.0;</span>

<span class="fc bfc" id="L155" title="All 2 branches covered.">    if (includeJointMarginalsAndPartition) {</span>
      outer:
<span class="fc bfc" id="L157" title="All 2 branches covered.">      for (GraphicalModel.Factor f : model.factors) {</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">        for (int n : f.neigborIndices) {</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">          if (!model.getVariableMetaDataByReference(n).containsKey(VARIABLE_OBSERVED_VALUE)) continue outer;</span>
        }

<span class="fc" id="L162">        int[] assignment = new int[f.neigborIndices.length];</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">        for (int i = 0; i &lt; f.neigborIndices.length; i++) {</span>
<span class="fc" id="L164">          assignment[i] = Integer.parseInt(model.getVariableMetaDataByReference(f.neigborIndices[i]).get(VARIABLE_OBSERVED_VALUE));</span>
        }

<span class="fc" id="L167">        double assignmentValue = f.featuresTable.getAssignmentValue(assignment).get().dotProduct(weights);</span>
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">        if (Double.isInfinite(assignmentValue)) {</span>
<span class="nc" id="L169">          impossibleObservationMade = true;</span>
        } else {
<span class="fc" id="L171">          partitionFunction *= Math.exp(assignmentValue);</span>
        }
<span class="fc" id="L173">      }</span>
    }

    // Create the cliques by multiplying out table factors
    // TODO:OPT This could be made more efficient by observing first, then dot product

<span class="fc" id="L179">    List&lt;TableFactor&gt; cliquesList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L180">    Map&lt;Integer, GraphicalModel.Factor&gt; cliqueToFactor = new HashMap&lt;&gt;();</span>

<span class="fc" id="L182">    int numFactorsCached = 0;</span>

<span class="fc bfc" id="L184" title="All 2 branches covered.">    for (GraphicalModel.Factor f : model.factors) {</span>
<span class="fc" id="L185">      boolean allObserved = true;</span>
<span class="fc" id="L186">      int maxVar = 0;</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">      for (int n : f.neigborIndices) {</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">        if (!model.getVariableMetaDataByReference(n).containsKey(VARIABLE_OBSERVED_VALUE)) allObserved = false;</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">        if (n &gt; maxVar) maxVar = n;</span>
      }
<span class="fc bfc" id="L191" title="All 2 branches covered.">      if (allObserved) continue;</span>

<span class="fc" id="L193">      TableFactor clique = null;</span>

      // Retrieve cache if exists and none of the observations have changed

<span class="fc bfc" id="L197" title="All 2 branches covered.">      if (cachedFactors.containsKey(f)) {</span>
<span class="fc" id="L198">        CachedFactorWithObservations obs = cachedFactors.get(f);</span>
<span class="fc" id="L199">        boolean allConsistent = true;</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">        for (int i = 0; i &lt; f.neigborIndices.length; i++) {</span>
<span class="fc" id="L201">          int n = f.neigborIndices[i];</span>
<span class="pc bpc" id="L202" title="1 of 4 branches missed.">          if (model.getVariableMetaDataByReference(n).containsKey(VARIABLE_OBSERVED_VALUE) &amp;&amp;</span>
              (obs.observations[i] == -1 ||
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">                  Integer.parseInt(model.getVariableMetaDataByReference(n).get(VARIABLE_OBSERVED_VALUE)) != obs.observations[i])) {</span>
<span class="nc" id="L205">            allConsistent = false;</span>
<span class="nc" id="L206">            break;</span>
          }
          // NOTE: This disqualifies lots of stuff for some reason...
<span class="pc bpc" id="L209" title="1 of 4 branches missed.">          if (!model.getVariableMetaDataByReference(n).containsKey(VARIABLE_OBSERVED_VALUE) &amp;&amp; (obs.observations[i] != -1)) {</span>
<span class="nc" id="L210">            allConsistent = false;</span>
<span class="nc" id="L211">            break;</span>
          }
        }
<span class="pc bpc" id="L214" title="1 of 2 branches missed.">        if (allConsistent) {</span>
<span class="fc" id="L215">          clique = obs.cachedFactor;</span>
<span class="fc" id="L216">          numFactorsCached++;</span>
<span class="pc bpc" id="L217" title="1 of 2 branches missed.">          if (obs.impossibleObservation) {</span>
<span class="nc" id="L218">            impossibleObservationMade = true;</span>
          }
        }
      }

      // Otherwise make a new cache

<span class="fc bfc" id="L225" title="All 2 branches covered.">      if (clique == null) {</span>
<span class="fc" id="L226">        int[] observations = new int[f.neigborIndices.length];</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">        for (int i = 0; i &lt; observations.length; i++) {</span>
<span class="fc" id="L228">          Map&lt;String, String&gt; metadata = model.getVariableMetaDataByReference(f.neigborIndices[i]);</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">          if (metadata.containsKey(VARIABLE_OBSERVED_VALUE)) {</span>
<span class="fc" id="L230">            int value = Integer.parseInt(metadata.get(VARIABLE_OBSERVED_VALUE));</span>
<span class="fc" id="L231">            observations[i] = value;</span>
<span class="fc" id="L232">          } else {</span>
<span class="fc" id="L233">            observations[i] = -1;</span>
          }
        }

<span class="fc" id="L237">        clique = new TableFactor(weights, f, observations);</span>

<span class="fc" id="L239">        CachedFactorWithObservations cache = new CachedFactorWithObservations();</span>
<span class="fc" id="L240">        cache.cachedFactor = clique;</span>
<span class="fc" id="L241">        cache.observations = observations;</span>

        // Check for an impossible observation
<span class="fc" id="L244">        boolean nonZeroValue = false;</span>
<span class="pc bpc" id="L245" title="1 of 2 branches missed.">        for (int[] assignment : clique) {</span>
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">          if (clique.getAssignmentValue(assignment) &gt; 0) {</span>
<span class="fc" id="L247">            nonZeroValue = true;</span>
<span class="fc" id="L248">            break;</span>
          }
<span class="nc" id="L250">        }</span>
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">        if (!nonZeroValue) {</span>
<span class="nc" id="L252">          impossibleObservationMade = true;</span>
<span class="nc" id="L253">          cache.impossibleObservation = true;</span>
        }

<span class="fc" id="L256">        cachedFactors.put(f, cache);</span>
      }

<span class="fc" id="L259">      cliqueToFactor.put(cliquesList.size(), f);</span>
<span class="fc" id="L260">      cliquesList.add(clique);</span>
<span class="fc" id="L261">    }</span>

<span class="fc" id="L263">    TableFactor[] cliques = cliquesList.toArray(new TableFactor[cliquesList.size()]);</span>

    // If we made any impossible observations, we can just return a uniform distribution for all the variables that
    // weren't observed, since that's the semantically correct thing to do (our 'probability' is broken at this
    // point).

<span class="pc bpc" id="L269" title="1 of 2 branches missed.">    if (impossibleObservationMade) {</span>
<span class="nc" id="L270">      int maxVar = 0;</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">      for (TableFactor c : cliques) {</span>
<span class="nc bnc" id="L272" title="All 4 branches missed.">        for (int i : c.neighborIndices) if (i &gt; maxVar) maxVar = i;</span>
      }

<span class="nc" id="L275">      double[][] result = new double[maxVar + 1][];</span>

<span class="nc bnc" id="L277" title="All 2 branches missed.">      for (TableFactor c : cliques) {</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">        for (int i = 0; i &lt; c.neighborIndices.length; i++) {</span>
<span class="nc" id="L279">          result[c.neighborIndices[i]] = new double[c.getDimensions()[i]];</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">          for (int j = 0; j &lt; result[c.neighborIndices[i]].length; j++) {</span>
<span class="nc" id="L281">            result[c.neighborIndices[i]][j] = 1.0 / result[c.neighborIndices[i]].length;</span>
          }
        }
      }

      // Create a bunch of uniform joint marginals, constrained by observations, and fill up the joint marginals
      // with them

<span class="nc" id="L289">      Map&lt;GraphicalModel.Factor, TableFactor&gt; jointMarginals = new IdentityHashMap&lt;&gt;();</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">      if (includeJointMarginalsAndPartition) {</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">        for (GraphicalModel.Factor f : model.factors) {</span>
<span class="nc" id="L292">          TableFactor uniformZero = new TableFactor(f.neigborIndices, f.featuresTable.getDimensions());</span>

<span class="nc bnc" id="L294" title="All 2 branches missed.">          for (int[] assignment : uniformZero) {</span>
<span class="nc" id="L295">            uniformZero.setAssignmentValue(assignment, 0.0);</span>
<span class="nc" id="L296">          }</span>

<span class="nc" id="L298">          jointMarginals.put(f, uniformZero);</span>
<span class="nc" id="L299">        }</span>
      }

<span class="nc" id="L302">      return new MarginalResult(result, 1.0, jointMarginals);</span>
    }

    // Find the largest contained variable, so that we can size arrays appropriately

<span class="fc" id="L307">    int maxVar = 0;</span>
<span class="fc bfc" id="L308" title="All 2 branches covered.">    for (GraphicalModel.Factor fac : model.factors) {</span>
<span class="fc bfc" id="L309" title="All 4 branches covered.">      for (int i : fac.neigborIndices) if (i &gt; maxVar) maxVar = i;</span>
<span class="fc" id="L310">    }</span>


    // Indexed by (start-clique, end-clique), this array will remain mostly null in most graphs

<span class="fc" id="L315">    TableFactor[][] messages = new TableFactor[cliques.length][cliques.length];</span>

    // OPTIMIZATION:
    // check if we've only added one factor since the last time we ran marginal inference. If that's the case, we
    // can use the new factor as the root, all the messages passed in from the leaves will not have changed. That
    // means we can cut message passing computation in half.

<span class="fc" id="L322">    boolean[][] backwardPassedMessages = new boolean[cliques.length][cliques.length];</span>

<span class="fc" id="L324">    int forceRootForCachedMessagePassing = -1;</span>
<span class="fc" id="L325">    int[] cachedCliquesBackPointers = null;</span>

<span class="fc bfc" id="L327" title="All 4 branches covered.">    if (CACHE_MESSAGES &amp;&amp; (numFactorsCached == cliques.length - 1) &amp;&amp; (numFactorsCached &gt; 0)) {</span>
<span class="fc" id="L328">      cachedCliquesBackPointers = new int[cliques.length];</span>

      // Sometimes we'll have cached versions of the factors, but they're from inference steps a long time ago, so we
      // don't get consistent backpointers to our cache of factors. This is a flag to indicate if this happens.
<span class="fc" id="L332">      boolean backPointersConsistent = true;</span>

      // Calculate the correspondence between the old cliques list and the new cliques list

<span class="fc bfc" id="L336" title="All 2 branches covered.">      for (int i = 0; i &lt; cliques.length; i++) {</span>
<span class="fc" id="L337">        cachedCliquesBackPointers[i] = -1;</span>
<span class="fc bfc" id="L338" title="All 2 branches covered.">        for (int j = 0; j &lt; cachedCliqueList.length; j++) {</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">          if (cliques[i] == cachedCliqueList[j]) {</span>
<span class="fc" id="L340">            cachedCliquesBackPointers[i] = j;</span>
<span class="fc" id="L341">            break;</span>
          }
        }
<span class="fc bfc" id="L344" title="All 2 branches covered.">        if (cachedCliquesBackPointers[i] == -1) {</span>
<span class="pc bpc" id="L345" title="1 of 2 branches missed.">          if (forceRootForCachedMessagePassing != -1) {</span>
<span class="nc" id="L346">            backPointersConsistent = false;</span>
<span class="nc" id="L347">            break;</span>
          }
<span class="fc" id="L349">          forceRootForCachedMessagePassing = i;</span>
        }
      }

<span class="pc bpc" id="L353" title="1 of 2 branches missed.">      if (!backPointersConsistent) forceRootForCachedMessagePassing = -1;</span>
    }

    // Create the data structures to hold the tree pattern

<span class="fc" id="L358">    boolean[] visited = new boolean[cliques.length];</span>
<span class="fc" id="L359">    int numVisited = 0;</span>
<span class="fc" id="L360">    int[] visitedOrder = new int[cliques.length];</span>

<span class="fc" id="L362">    int[] parent = new int[cliques.length];</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">    for (int i = 0; i &lt; parent.length; i++) parent[i] = -1;</span>
    // Figure out which cliques are connected to which trees. This is important for calculating the partition
    // function later, since each tree will converge to its own partition function by multiplication, and we will
    // need to multiply the partition function of each of the trees to get the global one.
<span class="fc" id="L367">    int[] trees = new int[cliques.length];</span>

    // Forward pass, record a BFS forest pattern that we can use for message passing

<span class="fc" id="L371">    int treeIndex = -1;</span>
<span class="fc" id="L372">    boolean[] seenVariable = new boolean[maxVar + 1];</span>
<span class="fc bfc" id="L373" title="All 2 branches covered.">    while (numVisited &lt; cliques.length) {</span>
<span class="fc" id="L374">      treeIndex++;</span>

      // Pick the largest connected graph remaining as the root for message passing

<span class="fc" id="L378">      int root = -1;</span>

      // OPTIMIZATION: if there's a forced root for message passing (a node that we just added) then make it the
      // root

<span class="fc bfc" id="L383" title="All 4 branches covered.">      if (CACHE_MESSAGES &amp;&amp; forceRootForCachedMessagePassing != -1 &amp;&amp; !visited[forceRootForCachedMessagePassing]) {</span>
<span class="fc" id="L384">        root = forceRootForCachedMessagePassing;</span>
      } else {
<span class="fc bfc" id="L386" title="All 2 branches covered.">        for (int i = 0; i &lt; cliques.length; i++) {</span>
<span class="fc bfc" id="L387" title="All 6 branches covered.">          if (!visited[i] &amp;&amp;</span>
              (root == -1 || cliques[i].neighborIndices.length &gt; cliques[root].neighborIndices.length)) {
<span class="fc" id="L389">            root = i;</span>
          }
        }
      }
<span class="pc bpc" id="L393" title="2 of 4 branches missed.">      assert (root != -1);</span>

<span class="fc" id="L395">      Queue&lt;Integer&gt; toVisit = new ArrayDeque&lt;&gt;();</span>
<span class="fc" id="L396">      toVisit.add(root);</span>
<span class="fc" id="L397">      boolean[] toVisitArray = new boolean[cliques.length];</span>
<span class="fc" id="L398">      toVisitArray[root] = true;</span>

<span class="fc bfc" id="L400" title="All 2 branches covered.">      while (toVisit.size() &gt; 0) {</span>
<span class="fc" id="L401">        int cursor = toVisit.poll();</span>
        // toVisitArray[cursor] = false;
<span class="fc" id="L403">        trees[cursor] = treeIndex;</span>
<span class="pc bpc" id="L404" title="1 of 2 branches missed.">        if (visited[cursor]) {</span>
<span class="nc" id="L405">          log.info(&quot;Visited contains: &quot; + cursor);</span>
<span class="nc" id="L406">          log.info(&quot;Visited: &quot; + Arrays.toString(visited));</span>
<span class="nc" id="L407">          log.info(&quot;To visit: &quot; + toVisit);</span>
        }
<span class="pc bpc" id="L409" title="2 of 4 branches missed.">        assert (!visited[cursor]);</span>
<span class="fc" id="L410">        visited[cursor] = true;</span>
<span class="fc" id="L411">        visitedOrder[numVisited] = cursor;</span>
<span class="fc bfc" id="L412" title="All 2 branches covered.">        for (int i : cliques[cursor].neighborIndices) seenVariable[i] = true;</span>
<span class="fc" id="L413">        numVisited++;</span>

        childLoop:
<span class="fc bfc" id="L416" title="All 2 branches covered.">        for (int i = 0; i &lt; cliques.length; i++) {</span>
<span class="fc bfc" id="L417" title="All 2 branches covered.">          if (i == cursor) continue;</span>
<span class="fc bfc" id="L418" title="All 2 branches covered.">          if (i == parent[cursor]) continue;</span>
<span class="fc bfc" id="L419" title="All 2 branches covered.">          if (domainsOverlap(cliques[cursor], cliques[i])) {</span>

            // Make sure that for every variable that we've already seen somewhere in the graph, if it's
            // in the child, it's in the parent. Otherwise we'll break the property of continuous
            // transmission of information about variables through messages.

            childNeighborLoop:
<span class="fc bfc" id="L426" title="All 2 branches covered.">            for (int child : cliques[i].neighborIndices) {</span>
<span class="fc bfc" id="L427" title="All 2 branches covered.">              if (seenVariable[child]) {</span>
<span class="fc bfc" id="L428" title="All 2 branches covered.">                for (int j : cliques[cursor].neighborIndices) {</span>
<span class="fc bfc" id="L429" title="All 2 branches covered.">                  if (j == child) {</span>
<span class="fc" id="L430">                    continue childNeighborLoop;</span>
                  }
                }
                // If we get here it means that this clique is not good as a child, since we can't pass
                // it all the information it needs from other elements of the tree
<span class="fc" id="L435">                continue childLoop;</span>
              }
            }

<span class="pc bpc" id="L439" title="1 of 4 branches missed.">            if (parent[i] == -1 &amp;&amp; !visited[i]) {</span>
<span class="pc bpc" id="L440" title="1 of 2 branches missed.">              if (!toVisitArray[i]) {</span>
<span class="fc" id="L441">                toVisit.add(i);</span>
<span class="fc" id="L442">                toVisitArray[i] = true;</span>
<span class="fc bfc" id="L443" title="All 2 branches covered.">                for (int j : cliques[i].neighborIndices) seenVariable[j] = true;</span>
              }
<span class="fc" id="L445">              parent[i] = cursor;</span>
            }
          }
        }
<span class="fc" id="L449">      }</span>
      // No cycles in the tree
<span class="pc bpc" id="L451" title="2 of 4 branches missed.">      assert (parent[root] == -1);</span>
<span class="fc" id="L452">    }</span>

<span class="pc bpc" id="L454" title="2 of 4 branches missed.">    assert (numVisited == cliques.length);</span>

    // Backward pass, run the visited list in reverse

<span class="fc bfc" id="L458" title="All 2 branches covered.">    for (int i = numVisited - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L459">      int cursor = visitedOrder[i];</span>
<span class="fc bfc" id="L460" title="All 2 branches covered.">      if (parent[cursor] == -1) continue;</span>

<span class="fc" id="L462">      backwardPassedMessages[cursor][parent[cursor]] = true;</span>

      // OPTIMIZATION:
      // if these conditions are met we can avoid calculating the message, and instead retrieve from the cache,
      // since they should be the same

<span class="pc bpc" id="L468" title="1 of 10 branches missed.">      if (CACHE_MESSAGES</span>
          &amp;&amp; forceRootForCachedMessagePassing != -1
          &amp;&amp; cachedCliquesBackPointers[cursor] != -1
          &amp;&amp; cachedCliquesBackPointers[parent[cursor]] != -1
          &amp;&amp; cachedMessages[cachedCliquesBackPointers[cursor]][cachedCliquesBackPointers[parent[cursor]]] != null
          &amp;&amp; cachedBackwardPassedMessages[cachedCliquesBackPointers[cursor]][cachedCliquesBackPointers[parent[cursor]]]) {
<span class="fc" id="L474">        messages[cursor][parent[cursor]] =</span>
            cachedMessages[cachedCliquesBackPointers[cursor]][cachedCliquesBackPointers[parent[cursor]]];
      } else {

        // Calculate the message to the clique's parent, given all incoming messages so far

<span class="fc" id="L480">        TableFactor message = cliques[cursor];</span>
<span class="fc bfc" id="L481" title="All 2 branches covered.">        for (int k = 0; k &lt; cliques.length; k++) {</span>
<span class="fc bfc" id="L482" title="All 2 branches covered.">          if (k == parent[cursor]) continue;</span>
<span class="fc bfc" id="L483" title="All 2 branches covered.">          if (messages[k][cursor] != null) {</span>
<span class="fc" id="L484">            message = message.multiply(messages[k][cursor]);</span>
          }
        }

<span class="fc" id="L488">        messages[cursor][parent[cursor]] = marginalizeMessage(message, cliques[parent[cursor]].neighborIndices, marginalize);</span>

        // Invalidate any cached outgoing messages
<span class="fc bfc" id="L491" title="All 4 branches covered.">        if (CACHE_MESSAGES</span>
            &amp;&amp; forceRootForCachedMessagePassing != -1
            &amp;&amp; cachedCliquesBackPointers[parent[cursor]] != -1) {
<span class="fc bfc" id="L494" title="All 2 branches covered.">          for (int k = 0; k &lt; cachedCliqueList.length; k++) {</span>
<span class="fc" id="L495">            cachedMessages[cachedCliquesBackPointers[parent[cursor]]][k] = null;</span>
          }
        }
      }
    }

    // Forward pass, run the visited list forward

<span class="fc bfc" id="L503" title="All 2 branches covered.">    for (int i = 0; i &lt; numVisited; i++) {</span>
<span class="fc" id="L504">      int cursor = visitedOrder[i];</span>
<span class="fc bfc" id="L505" title="All 2 branches covered.">      for (int j = 0; j &lt; cliques.length; j++) {</span>
<span class="fc bfc" id="L506" title="All 2 branches covered.">        if (parent[j] != cursor) continue;</span>

<span class="fc" id="L508">        TableFactor message = cliques[cursor];</span>
<span class="fc bfc" id="L509" title="All 2 branches covered.">        for (int k = 0; k &lt; cliques.length; k++) {</span>
<span class="fc bfc" id="L510" title="All 2 branches covered.">          if (k == j) continue;</span>
<span class="fc bfc" id="L511" title="All 2 branches covered.">          if (messages[k][cursor] != null) {</span>
<span class="fc" id="L512">            message = message.multiply(messages[k][cursor]);</span>
          }
        }

<span class="fc" id="L516">        messages[cursor][j] = marginalizeMessage(message, cliques[j].neighborIndices, marginalize);</span>
      }
    }

    // OPTIMIZATION:
    // cache the messages, and the current list of cliques

    if (CACHE_MESSAGES) {
<span class="fc" id="L524">      cachedCliqueList = cliques;</span>
<span class="fc" id="L525">      cachedMessages = messages;</span>
<span class="fc" id="L526">      cachedBackwardPassedMessages = backwardPassedMessages;</span>
    }

    // Calculate final marginals for each variable

<span class="fc" id="L531">    double[][] marginals = new double[maxVar + 1][];</span>

    // Include observed variables as deterministic

<span class="fc bfc" id="L535" title="All 2 branches covered.">    for (GraphicalModel.Factor fac : model.factors) {</span>
<span class="fc bfc" id="L536" title="All 2 branches covered.">      for (int i = 0; i &lt; fac.neigborIndices.length; i++) {</span>
<span class="fc" id="L537">        int n = fac.neigborIndices[i];</span>
<span class="fc bfc" id="L538" title="All 2 branches covered.">        if (model.getVariableMetaDataByReference(n).containsKey(VARIABLE_OBSERVED_VALUE)) {</span>
<span class="fc" id="L539">          double[] deterministic = new double[fac.featuresTable.getDimensions()[i]];</span>
<span class="fc" id="L540">          int assignment = Integer.parseInt(model.getVariableMetaDataByReference(n).get(VARIABLE_OBSERVED_VALUE));</span>
<span class="pc bpc" id="L541" title="1 of 2 branches missed.">          if (assignment &gt; deterministic.length) {</span>
<span class="nc" id="L542">            throw new IllegalStateException(&quot;Variable &quot; + n + &quot;: Can't have as assignment (&quot; + assignment + &quot;) that is out of bounds for dimension size (&quot; + deterministic.length + &quot;)&quot;);</span>
          }
<span class="fc" id="L544">          deterministic[assignment] = 1.0;</span>
<span class="fc" id="L545">          marginals[n] = deterministic;</span>
        }
      }
<span class="fc" id="L548">    }</span>

<span class="fc" id="L550">    Map&lt;GraphicalModel.Factor, TableFactor&gt; jointMarginals = new IdentityHashMap&lt;&gt;();</span>

<span class="pc bpc" id="L552" title="1 of 4 branches missed.">    if (marginalize == MarginalizationMethod.SUM &amp;&amp; includeJointMarginalsAndPartition) {</span>
<span class="fc" id="L553">      boolean[] partitionIncludesTrees = new boolean[treeIndex + 1];</span>
<span class="fc" id="L554">      double[] treePartitionFunctions = new double[treeIndex + 1];</span>

<span class="fc bfc" id="L556" title="All 2 branches covered.">      for (int i = 0; i &lt; cliques.length; i++) {</span>
<span class="fc" id="L557">        TableFactor convergedClique = cliques[i];</span>

<span class="fc bfc" id="L559" title="All 2 branches covered.">        for (int j = 0; j &lt; cliques.length; j++) {</span>
<span class="fc bfc" id="L560" title="All 2 branches covered.">          if (i == j) continue;</span>
<span class="fc bfc" id="L561" title="All 2 branches covered.">          if (messages[j][i] == null) continue;</span>
<span class="fc" id="L562">          convergedClique = convergedClique.multiply(messages[j][i]);</span>
        }

        // Calculate the partition function when we're calculating marginals
        // We need one contribution per tree in our forest graph

<span class="fc bfc" id="L568" title="All 2 branches covered.">        if (!partitionIncludesTrees[trees[i]]) {</span>
<span class="fc" id="L569">          partitionIncludesTrees[trees[i]] = true;</span>
<span class="fc" id="L570">          treePartitionFunctions[trees[i]] = convergedClique.valueSum();</span>
<span class="fc" id="L571">          partitionFunction *= treePartitionFunctions[trees[i]];</span>
        } else {

          // This is all just an elaborate assert
          // Check that our partition function is the same as the trees we're attached to, or with %.1, for numerical reasons.
          // Sometimes the partition function will explode in value, which can make a non-%-based assert worthless here

<span class="pc bpc" id="L578" title="1 of 2 branches missed.">          if (assertsEnabled() &amp;&amp; !TableFactor.USE_EXP_APPROX) {</span>
<span class="fc" id="L579">            double valueSum = convergedClique.valueSum();</span>
<span class="pc bpc" id="L580" title="2 of 4 branches missed.">            if (Double.isFinite(valueSum) &amp;&amp; Double.isFinite(treePartitionFunctions[trees[i]])) {</span>
<span class="pc bpc" id="L581" title="1 of 2 branches missed.">              if (Math.abs(treePartitionFunctions[trees[i]] - valueSum) &gt;= 1.0e-3 * treePartitionFunctions[trees[i]]) {</span>
<span class="nc" id="L582">                log.info(&quot;Different partition functions for tree &quot; + trees[i] + &quot;: &quot;);</span>
<span class="nc" id="L583">                log.info(&quot;Pre-existing for tree: &quot; + treePartitionFunctions[trees[i]]);</span>
<span class="nc" id="L584">                log.info(&quot;This clique for tree: &quot; + valueSum);</span>
              }
<span class="pc bpc" id="L586" title="2 of 4 branches missed.">              assert (Math.abs(treePartitionFunctions[trees[i]] - valueSum) &lt; 1.0e-3 * treePartitionFunctions[trees[i]]);</span>
            }
          }
        }

        // Calculate the factor this clique corresponds to, and put in an entry for joint marginals

<span class="fc" id="L593">        GraphicalModel.Factor f = cliqueToFactor.get(i);</span>
<span class="pc bpc" id="L594" title="2 of 4 branches missed.">        assert (f != null);</span>
<span class="pc bpc" id="L595" title="1 of 2 branches missed.">        if (!jointMarginals.containsKey(f)) {</span>
<span class="fc" id="L596">          int[] observedAssignments = getObservedAssignments(f);</span>

          // Collect back pointers and check if this factor matches the clique we're using

<span class="fc" id="L600">          int[] backPointers = new int[observedAssignments.length];</span>
<span class="fc" id="L601">          int cursor = 0;</span>
<span class="fc bfc" id="L602" title="All 2 branches covered.">          for (int j = 0; j &lt; observedAssignments.length; j++) {</span>
<span class="fc bfc" id="L603" title="All 2 branches covered.">            if (observedAssignments[j] == -1) {</span>
<span class="fc" id="L604">              backPointers[j] = cursor;</span>
<span class="fc" id="L605">              cursor++;</span>
            }
            // This is not strictly necessary but will trigger array OOB exception if things go wrong, so is nice
<span class="fc" id="L608">            else backPointers[j] = -1;</span>
          }

<span class="fc" id="L611">          double sum = convergedClique.valueSum();</span>

<span class="fc" id="L613">          TableFactor jointMarginal = new TableFactor(f.neigborIndices, f.featuresTable.getDimensions());</span>

          // OPTIMIZATION:
          // Rather than use the standard iterator, which creates lots of int[] arrays on the heap, which need to be GC'd,
          // we use the fast version that just mutates one array. Since this is read once for us here, this is ideal.
<span class="fc" id="L618">          Iterator&lt;int[]&gt; fastPassByReferenceIterator = convergedClique.fastPassByReferenceIterator();</span>
<span class="fc" id="L619">          int[] assignment = fastPassByReferenceIterator.next();</span>
          while (true) {
<span class="fc bfc" id="L621" title="All 2 branches covered.">            if (backPointers.length == assignment.length) {</span>
<span class="fc" id="L622">              jointMarginal.setAssignmentValue(assignment, convergedClique.getAssignmentValue(assignment) / sum);</span>
            } else {
<span class="fc" id="L624">              int[] jointAssignment = new int[backPointers.length];</span>
<span class="fc bfc" id="L625" title="All 2 branches covered.">              for (int j = 0; j &lt; jointAssignment.length; j++) {</span>
<span class="fc bfc" id="L626" title="All 2 branches covered.">                if (observedAssignments[j] != -1) jointAssignment[j] = observedAssignments[j];</span>
<span class="fc" id="L627">                else jointAssignment[j] = assignment[backPointers[j]];</span>
              }
<span class="fc" id="L629">              jointMarginal.setAssignmentValue(jointAssignment, convergedClique.getAssignmentValue(assignment) / sum);</span>
            }

            // Set the assignment arrays correctly
<span class="fc bfc" id="L633" title="All 2 branches covered.">            if (fastPassByReferenceIterator.hasNext()) fastPassByReferenceIterator.next();</span>
            else break;
          }

<span class="fc" id="L637">          jointMarginals.put(f, jointMarginal);</span>
        }

<span class="fc" id="L640">        boolean anyNull = false;</span>
<span class="fc bfc" id="L641" title="All 2 branches covered.">        for (int j = 0; j &lt; convergedClique.neighborIndices.length; j++) {</span>
<span class="fc" id="L642">          int k = convergedClique.neighborIndices[j];</span>
<span class="fc bfc" id="L643" title="All 2 branches covered.">          if (marginals[k] == null) {</span>
<span class="fc" id="L644">            anyNull = true;</span>
          }
        }

<span class="fc bfc" id="L648" title="All 2 branches covered.">        if (anyNull) {</span>
<span class="fc" id="L649">          double[][] cliqueMarginals = null;</span>
<span class="pc bpc" id="L650" title="2 of 3 branches missed.">          switch (marginalize) {</span>
            case SUM:
<span class="fc" id="L652">              cliqueMarginals = convergedClique.getSummedMarginals();</span>
<span class="fc" id="L653">              break;</span>
            case MAX:
<span class="nc" id="L655">              cliqueMarginals = convergedClique.getMaxedMarginals();</span>
              break;
          }
<span class="fc bfc" id="L658" title="All 2 branches covered.">          for (int j = 0; j &lt; convergedClique.neighborIndices.length; j++) {</span>
<span class="fc" id="L659">            int k = convergedClique.neighborIndices[j];</span>
<span class="fc bfc" id="L660" title="All 2 branches covered.">            if (marginals[k] == null) {</span>
<span class="fc" id="L661">              marginals[k] = cliqueMarginals[j];</span>
            }
          }
        }
      }
<span class="fc" id="L666">    }</span>
    // If we don't care about joint marginals, we can be careful about not calculating more cliques than we need to,
    // by explicitly sorting by which cliques are most profitable to calculate over. In this way we can avoid, in
    // the case of a chain CRF, calculating almost half the joint factors.
    else {
      // First do a pass where we only calculate all-null neighbors
<span class="fc bfc" id="L672" title="All 2 branches covered.">      for (int i = 0; i &lt; cliques.length; i++) {</span>
<span class="fc" id="L673">        boolean allNull = true;</span>
<span class="fc bfc" id="L674" title="All 2 branches covered.">        for (int k : cliques[i].neighborIndices) {</span>
<span class="fc bfc" id="L675" title="All 2 branches covered.">          if (marginals[k] != null) allNull = false;</span>
        }
<span class="fc bfc" id="L677" title="All 2 branches covered.">        if (allNull) {</span>
<span class="fc" id="L678">          TableFactor convergedClique = cliques[i];</span>

<span class="fc bfc" id="L680" title="All 2 branches covered.">          for (int j = 0; j &lt; cliques.length; j++) {</span>
<span class="fc bfc" id="L681" title="All 2 branches covered.">            if (i == j) continue;</span>
<span class="fc bfc" id="L682" title="All 2 branches covered.">            if (messages[j][i] == null) continue;</span>
<span class="fc" id="L683">            convergedClique = convergedClique.multiply(messages[j][i]);</span>
          }

<span class="fc" id="L686">          double[][] cliqueMarginals = null;</span>
<span class="pc bpc" id="L687" title="2 of 3 branches missed.">          switch (marginalize) {</span>
            case SUM:
<span class="nc" id="L689">              cliqueMarginals = convergedClique.getSummedMarginals();</span>
<span class="nc" id="L690">              break;</span>
            case MAX:
<span class="fc" id="L692">              cliqueMarginals = convergedClique.getMaxedMarginals();</span>
              break;
          }
<span class="fc bfc" id="L695" title="All 2 branches covered.">          for (int j = 0; j &lt; convergedClique.neighborIndices.length; j++) {</span>
<span class="fc" id="L696">            int k = convergedClique.neighborIndices[j];</span>
<span class="pc bpc" id="L697" title="1 of 2 branches missed.">            if (marginals[k] == null) {</span>
<span class="fc" id="L698">              marginals[k] = cliqueMarginals[j];</span>
            }
          }
        }
      }
      // Now we calculate any remaining cliques with any non-null variables
<span class="fc bfc" id="L704" title="All 2 branches covered.">      for (int i = 0; i &lt; cliques.length; i++) {</span>
<span class="fc" id="L705">        boolean anyNull = false;</span>
<span class="fc bfc" id="L706" title="All 2 branches covered.">        for (int j = 0; j &lt; cliques[i].neighborIndices.length; j++) {</span>
<span class="fc" id="L707">          int k = cliques[i].neighborIndices[j];</span>
<span class="fc bfc" id="L708" title="All 2 branches covered.">          if (marginals[k] == null) {</span>
<span class="fc" id="L709">            anyNull = true;</span>
          }
        }

<span class="fc bfc" id="L713" title="All 2 branches covered.">        if (anyNull) {</span>
<span class="fc" id="L714">          TableFactor convergedClique = cliques[i];</span>

<span class="fc bfc" id="L716" title="All 2 branches covered.">          for (int j = 0; j &lt; cliques.length; j++) {</span>
<span class="fc bfc" id="L717" title="All 2 branches covered.">            if (i == j) continue;</span>
<span class="fc bfc" id="L718" title="All 2 branches covered.">            if (messages[j][i] == null) continue;</span>
<span class="fc" id="L719">            convergedClique = convergedClique.multiply(messages[j][i]);</span>
          }

<span class="fc" id="L722">          double[][] cliqueMarginals = null;</span>
<span class="pc bpc" id="L723" title="2 of 3 branches missed.">          switch (marginalize) {</span>
            case SUM:
<span class="nc" id="L725">              cliqueMarginals = convergedClique.getSummedMarginals();</span>
<span class="nc" id="L726">              break;</span>
            case MAX:
<span class="fc" id="L728">              cliqueMarginals = convergedClique.getMaxedMarginals();</span>
              break;
          }
<span class="fc bfc" id="L731" title="All 2 branches covered.">          for (int j = 0; j &lt; convergedClique.neighborIndices.length; j++) {</span>
<span class="fc" id="L732">            int k = convergedClique.neighborIndices[j];</span>
<span class="fc bfc" id="L733" title="All 2 branches covered.">            if (marginals[k] == null) {</span>
<span class="fc" id="L734">              marginals[k] = cliqueMarginals[j];</span>
            }
          }
        }
      }
    }

    // Add any factors to the joint marginal map that were fully observed and so didn't get cliques
<span class="pc bpc" id="L742" title="1 of 4 branches missed.">    if (marginalize == MarginalizationMethod.SUM &amp;&amp; includeJointMarginalsAndPartition) {</span>
<span class="fc bfc" id="L743" title="All 2 branches covered.">      for (GraphicalModel.Factor f : model.factors) {</span>
<span class="fc bfc" id="L744" title="All 2 branches covered.">        if (!jointMarginals.containsKey(f)) {</span>
          // This implies that every variable in the factor is observed. If that's the case, we need to construct
          // a one hot TableFactor representing the deterministic distribution.
<span class="fc" id="L747">          TableFactor deterministicJointMarginal = new TableFactor(f.neigborIndices, f.featuresTable.getDimensions());</span>
<span class="fc" id="L748">          int[] observedAssignment = getObservedAssignments(f);</span>
<span class="pc bpc" id="L749" title="2 of 6 branches missed.">          for (int i : observedAssignment) assert (i != -1);</span>
<span class="fc" id="L750">          deterministicJointMarginal.setAssignmentValue(observedAssignment, 1.0);</span>

<span class="fc" id="L752">          jointMarginals.put(f, deterministicJointMarginal);</span>
        }
<span class="fc" id="L754">      }</span>
    }

<span class="fc" id="L757">    return new MarginalResult(marginals, partitionFunction, jointMarginals);</span>
  }

  private int[] getObservedAssignments(GraphicalModel.Factor f) {
<span class="fc" id="L761">    int[] observedAssignments = new int[f.neigborIndices.length];</span>
<span class="fc bfc" id="L762" title="All 2 branches covered.">    for (int i = 0; i &lt; observedAssignments.length; i++) {</span>
<span class="fc bfc" id="L763" title="All 2 branches covered.">      if (model.getVariableMetaDataByReference(f.neigborIndices[i]).containsKey(VARIABLE_OBSERVED_VALUE)) {</span>
<span class="fc" id="L764">        observedAssignments[i] = Integer.parseInt(model.getVariableMetaDataByReference(f.neigborIndices[i]).get(VARIABLE_OBSERVED_VALUE));</span>
<span class="fc" id="L765">      } else observedAssignments[i] = -1;</span>
    }
<span class="fc" id="L767">    return observedAssignments;</span>
  }

  /**
   * This is a key step in message passing. When we are calculating a message, we want to marginalize out all variables
   * not relevant to the recipient of the message. This function does that.
   *
   * @param message     the message to marginalize
   * @param relevant    the variables that are relevant
   * @param marginalize whether to use sum of max marginalization, for marginal or MAP inference
   * @return the marginalized message
   */
  private static TableFactor marginalizeMessage(TableFactor message, int[] relevant, MarginalizationMethod marginalize) {
<span class="fc" id="L780">    TableFactor result = message;</span>

<span class="fc bfc" id="L782" title="All 2 branches covered.">    for (int i : message.neighborIndices) {</span>
<span class="fc" id="L783">      boolean contains = false;</span>
<span class="fc bfc" id="L784" title="All 2 branches covered.">      for (int j : relevant) {</span>
<span class="fc bfc" id="L785" title="All 2 branches covered.">        if (i == j) {</span>
<span class="fc" id="L786">          contains = true;</span>
<span class="fc" id="L787">          break;</span>
        }
      }
<span class="fc bfc" id="L790" title="All 2 branches covered.">      if (!contains) {</span>
<span class="pc bpc" id="L791" title="1 of 3 branches missed.">        switch (marginalize) {</span>
          case SUM:
<span class="fc" id="L793">            result = result.sumOut(i);</span>
<span class="fc" id="L794">            break;</span>
          case MAX:
<span class="fc" id="L796">            result = result.maxOut(i);</span>
            break;
        }
      }
    }

<span class="fc" id="L802">    return result;</span>
  }

  /**
   * Just a quick inline to check if two factors have overlapping domains. Since factor neighbor sets are super small,
   * this n^2 algorithm is fine.
   *
   * @param f1 first factor to compare
   * @param f2 second factor to compare
   * @return whether their domains overlap
   */
  private static boolean domainsOverlap(TableFactor f1, TableFactor f2) {
<span class="fc bfc" id="L814" title="All 2 branches covered.">    for (int n1 : f1.neighborIndices) {</span>
<span class="fc bfc" id="L815" title="All 2 branches covered.">      for (int n2 : f2.neighborIndices) {</span>
<span class="fc bfc" id="L816" title="All 2 branches covered.">        if (n1 == n2) return true;</span>
      }
    }
<span class="fc" id="L819">    return false;</span>
  }

  @SuppressWarnings({&quot;*&quot;, &quot;AssertWithSideEffects&quot;, &quot;ConstantConditions&quot;, &quot;UnusedAssignment&quot;})
  private static boolean assertsEnabled() {
<span class="fc" id="L824">    boolean assertsEnabled = false;</span>
<span class="pc bpc" id="L825" title="2 of 4 branches missed.">    assert (assertsEnabled = true); // intentional side effect</span>
<span class="fc" id="L826">    return assertsEnabled;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>