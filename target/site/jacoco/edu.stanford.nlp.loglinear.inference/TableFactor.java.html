<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TableFactor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.loglinear.inference</a> &gt; <span class="el_source">TableFactor.java</span></div><h1>TableFactor.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.loglinear.inference;

import edu.stanford.nlp.loglinear.model.ConcatVector;
import edu.stanford.nlp.loglinear.model.GraphicalModel;
import edu.stanford.nlp.loglinear.model.NDArrayDoubles;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.function.BiFunction;

/**
 * Created on 8/11/15.
 * @author keenon
 * &lt;p&gt;
 * Holds a factor populated by doubles that knows how to do all the important operations for PGM inference. Internally,
 * these are just different flavors of two basic data-flow operations:
 * &lt;p&gt;
 * - Factor product
 * - Factor marginalization
 * &lt;p&gt;
 * The output here is different ways to grow and shrink factors that turn out to be useful for downstream uses in PGMs.
 * Basically, we care about message passing, as that will be the primary operation.
 * &lt;p&gt;
 * Everything is represented as log-linear, because the primary use for TableFactor is in CliqueTree, and that is
 * intended for use with log-linear models.
 */
<span class="pc bpc" id="L28" title="1 of 2 branches missed.">public class TableFactor extends NDArrayDoubles {</span>
  public int[] neighborIndices;

  /**
   * Construct a TableFactor for inference within a model. This just copies the important bits from the model factor,
   * and replaces the ConcatVectorTable with an internal datastructure that has done all the dotproducts with the
   * weights out, and so stores only doubles.
   * &lt;p&gt;
   * Each element of the table is given by: t_i = exp(f_i*w)
   *
   * @param weights the vector to dot product with every element of the factor table
   * @param factor  the feature factor to be multiplied in
   */
  public TableFactor(ConcatVector weights, GraphicalModel.Factor factor) {
<span class="fc" id="L42">    super(factor.featuresTable.getDimensions());</span>
<span class="fc" id="L43">    this.neighborIndices = factor.neigborIndices;</span>

    // Calculate the factor residents by dot product with the weights

    // OPTIMIZATION:
    // Rather than use the standard iterator, which creates lots of int[] arrays on the heap, which need to be GC'd,
    // we use the fast version that just mutates one array. Since this is read once for us here, this is ideal.
<span class="fc" id="L50">    Iterator&lt;int[]&gt; fastPassByReferenceIterator = factor.featuresTable.fastPassByReferenceIterator();</span>
<span class="fc" id="L51">    int[] assignment = fastPassByReferenceIterator.next();</span>
    while (true) {
<span class="fc" id="L53">      setAssignmentLogValue(assignment, factor.featuresTable.getAssignmentValue(assignment).get().dotProduct(weights));</span>
      // This mutates the assignment[] array, rather than creating a new one
<span class="fc bfc" id="L55" title="All 2 branches covered.">      if (fastPassByReferenceIterator.hasNext()) fastPassByReferenceIterator.next();</span>
      else break;
    }
<span class="fc" id="L58">  }</span>

  /**
   * Fast approximation of the exp() function.
   * This approximation was suggested in the paper
   * A Fast, Compact Approximation of the Exponential Function
   * http://nic.schraudolph.org/pubs/Schraudolph99.pdf
   * by Nicol N. Schraudolph. However, it does not seem accurate
   * enough to be a good default for CRFs.
   *
   * @param val The value to be exponentiated
   * @return The exponentiated value
   */
  public static double exp(double val) {
<span class="nc" id="L72">    final long tmp = (long) (1512775 * val + 1072632447);</span>
<span class="nc" id="L73">    return Double.longBitsToDouble(tmp &lt;&lt; 32);</span>
  }

  public static final boolean USE_EXP_APPROX = false;

  /**
   * Construct a TableFactor for inference within a model. This is the same as the other constructor, except that the
   * table is observed out before any unnecessary dot products are done out, so hopefully we dramatically reduce the
   * number of computations required to calculate the resulting table.
   * &lt;p&gt;
   * Each element of the table is given by: t_i = exp(f_i*w)
   *
   * @param weights the vector to dot product with every element of the factor table
   * @param factor  the feature factor to be multiplied in
   */
  public TableFactor(ConcatVector weights, GraphicalModel.Factor factor, int[] observations) {
<span class="fc" id="L89">    super();</span>
<span class="pc bpc" id="L90" title="2 of 4 branches missed.">    assert (observations.length == factor.neigborIndices.length);</span>

<span class="fc" id="L92">    int size = 0;</span>
<span class="fc bfc" id="L93" title="All 4 branches covered.">    for (int observation : observations) if (observation == -1) size++;</span>

<span class="fc" id="L95">    neighborIndices = new int[size];</span>
<span class="fc" id="L96">    dimensions = new int[size];</span>
<span class="fc" id="L97">    int[] forwardPointers = new int[size];</span>
<span class="fc" id="L98">    int[] factorAssignment = new int[factor.neigborIndices.length];</span>

<span class="fc" id="L100">    int cursor = 0;</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">    for (int i = 0; i &lt; factor.neigborIndices.length; i++) {</span>
<span class="fc bfc" id="L102" title="All 2 branches covered.">      if (observations[i] == -1) {</span>
<span class="fc" id="L103">        neighborIndices[cursor] = factor.neigborIndices[i];</span>
<span class="fc" id="L104">        dimensions[cursor] = factor.featuresTable.getDimensions()[i];</span>
<span class="fc" id="L105">        forwardPointers[cursor] = i;</span>
<span class="fc" id="L106">        cursor++;</span>
<span class="fc" id="L107">      } else factorAssignment[i] = observations[i];</span>
    }
<span class="pc bpc" id="L109" title="2 of 4 branches missed.">    assert (cursor == size);</span>

<span class="fc" id="L111">    values = new double[combinatorialNeighborStatesCount()];</span>

<span class="fc bfc" id="L113" title="All 2 branches covered.">    for (int[] assn : this) {</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">      for (int i = 0; i &lt; assn.length; i++) {</span>
<span class="fc" id="L115">        factorAssignment[forwardPointers[i]] = assn[i];</span>
      }
<span class="fc" id="L117">      setAssignmentLogValue(assn, factor.featuresTable.getAssignmentValue(factorAssignment).get().dotProduct(weights));</span>
<span class="fc" id="L118">    }</span>
<span class="fc" id="L119">  }</span>

  /**
   * Remove a variable by observing it at a certain value, return a new factor without that variable.
   *
   * @param variable the variable to be observed
   * @param value    the value the variable takes when observed
   * @return a new factor with 'variable' in it
   */
  public TableFactor observe(int variable, final int value) {
<span class="fc" id="L129">    return marginalize(variable, 0, (marginalizedVariableValue, assignment) -&gt; {</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">      if (marginalizedVariableValue == value) {</span>
<span class="fc" id="L131">        return (old, n) -&gt; {</span>
          // This would mean that we're observing something with 0 probability, which will wonk up downstream
          // stuff
          // assert(n != 0);
<span class="fc" id="L135">          return n;</span>
        };
      } else {
<span class="fc" id="L138">        return (old, n) -&gt; old;</span>
      }
    });
  }

  /**
   * Returns the summed marginals for each element in the factor. These are represented in log space, and are summed
   * using the numerically stable variant, even though it's slightly slower.
   *
   * @return an array of doubles one-to-one with variable states for each variable
   */
  public double[][] getSummedMarginals() {
<span class="fc" id="L150">    double[][] results = new double[neighborIndices.length][];</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">    for (int i = 0; i &lt; neighborIndices.length; i++) {</span>
<span class="fc" id="L152">      results[i] = new double[getDimensions()[i]];</span>
    }

<span class="fc" id="L155">    double[][] maxValues = new double[neighborIndices.length][];</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">    for (int i = 0; i &lt; neighborIndices.length; i++) {</span>
<span class="fc" id="L157">      maxValues[i] = new double[getDimensions()[i]];</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">      for (int j = 0; j &lt; maxValues[i].length; j++) maxValues[i][j] = Double.NEGATIVE_INFINITY;</span>
    }

    // Get max values

    // OPTIMIZATION:
    // Rather than use the standard iterator, which creates lots of int[] arrays on the heap, which need to be GC'd,
    // we use the fast version that just mutates one array. Since this is read once for us here, this is ideal.

<span class="fc" id="L167">    Iterator&lt;int[]&gt; fastPassByReferenceIterator = fastPassByReferenceIterator();</span>
<span class="fc" id="L168">    int[] assignment = fastPassByReferenceIterator.next();</span>
    while (true) {
<span class="fc" id="L170">      double v = getAssignmentLogValue(assignment);</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">      for (int i = 0; i &lt; neighborIndices.length; i++) {</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">        if (maxValues[i][assignment[i]] &lt; v) maxValues[i][assignment[i]] = v;</span>
      }
      // This mutates the resultAssignment[] array, rather than creating a new one
<span class="fc bfc" id="L175" title="All 2 branches covered.">      if (fastPassByReferenceIterator.hasNext()) {</span>
<span class="fc" id="L176">        fastPassByReferenceIterator.next();</span>
      } else break;
<span class="fc" id="L178">    }</span>

    // Do the summation

    // OPTIMIZATION:
    // Rather than use the standard iterator, which creates lots of int[] arrays on the heap, which need to be GC'd,
    // we use the fast version that just mutates one array. Since this is read once for us here, this is ideal.

<span class="fc" id="L186">    Iterator&lt;int[]&gt; secondFastPassByReferenceIterator = fastPassByReferenceIterator();</span>
<span class="fc" id="L187">    assignment = secondFastPassByReferenceIterator.next();</span>
    while (true) {
<span class="fc" id="L189">      double v = getAssignmentLogValue(assignment);</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">      for (int i = 0; i &lt; neighborIndices.length; i++) {</span>
        if (USE_EXP_APPROX) {
          results[i][assignment[i]] += exp(v - maxValues[i][assignment[i]]);
        } else {
<span class="fc" id="L194">          results[i][assignment[i]] += Math.exp(v - maxValues[i][assignment[i]]);</span>
        }
      }
      // This mutates the resultAssignment[] array, rather than creating a new one
<span class="fc bfc" id="L198" title="All 2 branches covered.">      if (secondFastPassByReferenceIterator.hasNext()) {</span>
<span class="fc" id="L199">        secondFastPassByReferenceIterator.next();</span>
      } else break;
<span class="fc" id="L201">    }</span>

    // normalize results, and move to linear space

<span class="fc bfc" id="L205" title="All 2 branches covered.">    for (int i = 0; i &lt; neighborIndices.length; i++) {</span>
<span class="fc" id="L206">      double sum = 0.0;</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">      for (int j = 0; j &lt; results[i].length; j++) {</span>
        if (USE_EXP_APPROX) {
          results[i][j] = exp(maxValues[i][j]) * results[i][j];
        } else {
<span class="fc" id="L211">          results[i][j] = Math.exp(maxValues[i][j]) * results[i][j];</span>
        }
<span class="fc" id="L213">        sum += results[i][j];</span>
      }
<span class="pc bpc" id="L215" title="1 of 2 branches missed.">      if (Double.isInfinite(sum)) {</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">        for (int j = 0; j &lt; results[i].length; j++) {</span>
<span class="nc" id="L217">          results[i][j] = 1.0 / results[i].length;</span>
        }
      } else {
<span class="fc bfc" id="L220" title="All 2 branches covered.">        for (int j = 0; j &lt; results[i].length; j++) {</span>
<span class="fc" id="L221">          results[i][j] /= sum;</span>
        }
      }
    }

<span class="fc" id="L226">    return results;</span>
  }

  /**
   * Convenience function to max out all but one variable, and return the marginal array.
   *
   * @return an array of doubles one-to-one with variable states for each variable
   */
  public double[][] getMaxedMarginals() {
<span class="fc" id="L235">    double[][] maxValues = new double[neighborIndices.length][];</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">    for (int i = 0; i &lt; neighborIndices.length; i++) {</span>
<span class="fc" id="L237">      maxValues[i] = new double[getDimensions()[i]];</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">      for (int j = 0; j &lt; maxValues[i].length; j++) maxValues[i][j] = Double.NEGATIVE_INFINITY;</span>
    }

    // Get max values

    // OPTIMIZATION:
    // Rather than use the standard iterator, which creates lots of int[] arrays on the heap, which need to be GC'd,
    // we use the fast version that just mutates one array. Since this is read once for us here, this is ideal.

<span class="fc" id="L247">    Iterator&lt;int[]&gt; fastPassByReferenceIterator = fastPassByReferenceIterator();</span>
<span class="fc" id="L248">    int[] assignment = fastPassByReferenceIterator.next();</span>
    while (true) {
<span class="fc" id="L250">      double v = getAssignmentLogValue(assignment);</span>
<span class="fc bfc" id="L251" title="All 2 branches covered.">      for (int i = 0; i &lt; neighborIndices.length; i++) {</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">        if (maxValues[i][assignment[i]] &lt; v) maxValues[i][assignment[i]] = v;</span>
      }
      // This mutates the resultAssignment[] array, rather than creating a new one
<span class="fc bfc" id="L255" title="All 2 branches covered.">      if (fastPassByReferenceIterator.hasNext()) {</span>
<span class="fc" id="L256">        fastPassByReferenceIterator.next();</span>
      } else break;
<span class="fc" id="L258">    }</span>

<span class="fc bfc" id="L260" title="All 2 branches covered.">    for (int i = 0; i &lt; neighborIndices.length; i++) {</span>
<span class="fc" id="L261">      normalizeLogArr(maxValues[i]);</span>
    }

<span class="fc" id="L264">    return maxValues;</span>
  }

  /**
   * Marginalize out a variable by taking the max value.
   *
   * @param variable the variable to be maxed out.
   * @return a table factor that will contain the largest value of the variable being marginalized out.
   */
  public TableFactor maxOut(int variable) {
<span class="fc" id="L274">    return marginalize(variable, Double.NEGATIVE_INFINITY, (marginalizedVariableValue, assignment) -&gt; Math::max);</span>
  }

  /**
   * Marginalize out a variable by taking a sum.
   *
   * @param variable the variable to be summed out
   * @return a factor with variable removed
   */
  public TableFactor sumOut(int variable) {

    // OPTIMIZATION: This is by far the most common case, for linear chain inference, and is worth making fast
    // We can use closed loops, and not bother with using the basic iterator to loop through indices.
    // If this special case doesn't trip, we fall back to the standard (but slower) algorithm for the general case

<span class="fc bfc" id="L289" title="All 2 branches covered.">    if (getDimensions().length == 2) {</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">      if (neighborIndices[0] == variable) {</span>
<span class="fc" id="L291">        TableFactor marginalized = new TableFactor(new int[]{neighborIndices[1]}, new int[]{getDimensions()[1]});</span>

<span class="fc bfc" id="L293" title="All 2 branches covered.">        for (int i = 0; i &lt; marginalized.values.length; i++) marginalized.values[i] = 0;</span>

        // We use the stable log-sum-exp trick here, so first we calculate the max

<span class="fc" id="L297">        double[] max = new double[getDimensions()[1]];</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">        for (int j = 0; j &lt; getDimensions()[1]; j++) {</span>
<span class="fc" id="L299">          max[j] = Double.NEGATIVE_INFINITY;</span>
        }

<span class="fc bfc" id="L302" title="All 2 branches covered.">        for (int i = 0; i &lt; getDimensions()[0]; i++) {</span>
<span class="fc" id="L303">          int k = i * getDimensions()[1];</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">          for (int j = 0; j &lt; getDimensions()[1]; j++) {</span>
<span class="fc" id="L305">            int index = k + j;</span>
<span class="fc bfc" id="L306" title="All 2 branches covered.">            if (values[index] &gt; max[j]) {</span>
<span class="fc" id="L307">              max[j] = values[index];</span>
            }
          }
        }

        // Then we take the sum, minus the max

<span class="fc bfc" id="L314" title="All 2 branches covered.">        for (int i = 0; i &lt; getDimensions()[0]; i++) {</span>
<span class="fc" id="L315">          int k = i * getDimensions()[1];</span>
<span class="fc bfc" id="L316" title="All 2 branches covered.">          for (int j = 0; j &lt; getDimensions()[1]; j++) {</span>
<span class="fc" id="L317">            int index = k + j;</span>
<span class="pc bpc" id="L318" title="1 of 2 branches missed.">            if (Double.isFinite(max[j])) {</span>
              if (USE_EXP_APPROX) {
                marginalized.values[j] += exp(values[index] - max[j]);
              } else {
<span class="fc" id="L322">                marginalized.values[j] += Math.exp(values[index] - max[j]);</span>
              }
            }
          }
        }

        // And now we exponentiate, and add back in the values

<span class="fc bfc" id="L330" title="All 2 branches covered.">        for (int j = 0; j &lt; getDimensions()[1]; j++) {</span>
<span class="pc bpc" id="L331" title="1 of 2 branches missed.">          if (Double.isFinite(max[j])) {</span>
<span class="fc" id="L332">            marginalized.values[j] = max[j] + Math.log(marginalized.values[j]);</span>
          } else {
<span class="nc" id="L334">            marginalized.values[j] = max[j];</span>
          }
        }

<span class="fc" id="L338">        return marginalized;</span>
      } else {
<span class="pc bpc" id="L340" title="2 of 4 branches missed.">        assert (neighborIndices[1] == variable);</span>
<span class="fc" id="L341">        TableFactor marginalized = new TableFactor(new int[]{neighborIndices[0]}, new int[]{getDimensions()[0]});</span>

<span class="fc bfc" id="L343" title="All 2 branches covered.">        for (int i = 0; i &lt; marginalized.values.length; i++) marginalized.values[i] = 0;</span>

        // We use the stable log-sum-exp trick here, so first we calculate the max

<span class="fc" id="L347">        double[] max = new double[getDimensions()[0]];</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">        for (int i = 0; i &lt; getDimensions()[0]; i++) {</span>
<span class="fc" id="L349">          max[i] = Double.NEGATIVE_INFINITY;</span>
        }

<span class="fc bfc" id="L352" title="All 2 branches covered.">        for (int i = 0; i &lt; getDimensions()[0]; i++) {</span>
<span class="fc" id="L353">          int k = i * getDimensions()[1];</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">          for (int j = 0; j &lt; getDimensions()[1]; j++) {</span>
<span class="fc" id="L355">            int index = k + j;</span>
<span class="fc bfc" id="L356" title="All 2 branches covered.">            if (values[index] &gt; max[i]) {</span>
<span class="fc" id="L357">              max[i] = values[index];</span>
            }
          }
        }

        // Then we take the sum, minus the max

<span class="fc bfc" id="L364" title="All 2 branches covered.">        for (int i = 0; i &lt; getDimensions()[0]; i++) {</span>
<span class="fc" id="L365">          int k = i * getDimensions()[1];</span>
<span class="fc bfc" id="L366" title="All 2 branches covered.">          for (int j = 0; j &lt; getDimensions()[1]; j++) {</span>
<span class="fc" id="L367">            int index = k + j;</span>
<span class="pc bpc" id="L368" title="1 of 2 branches missed.">            if (Double.isFinite(max[i])) {</span>
              if (USE_EXP_APPROX) {
                marginalized.values[i] += exp(values[index] - max[i]);
              } else {
<span class="fc" id="L372">                marginalized.values[i] += Math.exp(values[index] - max[i]);</span>
              }
            }
          }
        }

        // And now we exponentiate, and add back in the values

<span class="fc bfc" id="L380" title="All 2 branches covered.">        for (int i = 0; i &lt; getDimensions()[0]; i++) {</span>
<span class="pc bpc" id="L381" title="1 of 2 branches missed.">          if (Double.isFinite(max[i])) {</span>
<span class="fc" id="L382">            marginalized.values[i] = max[i] + Math.log(marginalized.values[i]);</span>
          } else {
<span class="nc" id="L384">            marginalized.values[i] = max[i];</span>
          }
        }

<span class="fc" id="L388">        return marginalized;</span>
      }
    } else {
      // This is a little tricky because we need to use the stable log-sum-exp trick on top of our marginalize
      // dataflow operation.

      // First we calculate all the max values to use as pivots to prevent overflow
<span class="fc" id="L395">      TableFactor maxValues = maxOut(variable);</span>

      // Then we do the sum against an offset from the pivots
<span class="fc" id="L398">      TableFactor marginalized = marginalize(variable, 0, (marginalizedVariableValue, assignment) -&gt; (a, b) -&gt; a + (USE_EXP_APPROX ? exp(b - maxValues.getAssignmentLogValue(assignment)) : Math.exp(b - maxValues.getAssignmentLogValue(assignment))));</span>

      // Then we factor the max values back in, and
<span class="fc bfc" id="L401" title="All 2 branches covered.">      for (int[] assignment : marginalized) {</span>
<span class="fc" id="L402">        marginalized.setAssignmentLogValue(assignment, maxValues.getAssignmentLogValue(assignment) + Math.log(marginalized.getAssignmentLogValue(assignment)));</span>
<span class="fc" id="L403">      }</span>

<span class="fc" id="L405">      return marginalized;</span>
    }
  }

  /**
   * Product two factors, taking the multiplication at the intersections.
   *
   * @param other the other factor to be multiplied
   * @return a factor containing the union of both variable sets
   */
  public TableFactor multiply(TableFactor other) {

    // Calculate the result domain

<span class="fc" id="L419">    List&lt;Integer&gt; domain = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L420">    List&lt;Integer&gt; otherDomain = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L421">    List&lt;Integer&gt; resultDomain = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L423" title="All 2 branches covered.">    for (int n : neighborIndices) {</span>
<span class="fc" id="L424">      domain.add(n);</span>
<span class="fc" id="L425">      resultDomain.add(n);</span>
    }
<span class="fc bfc" id="L427" title="All 2 branches covered.">    for (int n : other.neighborIndices) {</span>
<span class="fc" id="L428">      otherDomain.add(n);</span>
<span class="fc bfc" id="L429" title="All 2 branches covered.">      if (!resultDomain.contains(n)) resultDomain.add(n);</span>
    }

    // Create result TableFactor

<span class="fc" id="L434">    int[] resultNeighborIndices = new int[resultDomain.size()];</span>
<span class="fc" id="L435">    int[] resultDimensions = new int[resultNeighborIndices.length];</span>
<span class="fc bfc" id="L436" title="All 2 branches covered.">    for (int i = 0; i &lt; resultDomain.size(); i++) {</span>
<span class="fc" id="L437">      int var = resultDomain.get(i);</span>
<span class="fc" id="L438">      resultNeighborIndices[i] = var;</span>
      // assert consistency about variable size, we can't have the same variable with two different sizes
<span class="pc bpc" id="L440" title="2 of 6 branches missed.">      assert ((getVariableSize(var) == 0 &amp;&amp; other.getVariableSize(var) &gt; 0) ||</span>
<span class="pc bpc" id="L441" title="1 of 4 branches missed.">          (getVariableSize(var) &gt; 0 &amp;&amp; other.getVariableSize(var) == 0) ||</span>
<span class="pc bpc" id="L442" title="1 of 2 branches missed.">          (getVariableSize(var) == other.getVariableSize(var)));</span>
<span class="fc" id="L443">      resultDimensions[i] = Math.max(getVariableSize(resultDomain.get(i)), other.getVariableSize(resultDomain.get(i)));</span>
    }
<span class="fc" id="L445">    TableFactor result = new TableFactor(resultNeighborIndices, resultDimensions);</span>

    // OPTIMIZATION:
    // If we're a factor of size 2 receiving a message of size 1, then we can optimize that pretty heavily
    // We could just use the general algorithm at the end of this set of special cases, but this is the fastest way
<span class="fc bfc" id="L450" title="All 6 branches covered.">    if (otherDomain.size() == 1 &amp;&amp; (resultDomain.size() == domain.size()) &amp;&amp; domain.size() == 2) {</span>
<span class="fc" id="L451">      int msgVar = otherDomain.get(0);</span>
<span class="fc" id="L452">      int msgIndex = resultDomain.indexOf(msgVar);</span>

<span class="fc bfc" id="L454" title="All 2 branches covered.">      if (msgIndex == 0) {</span>
<span class="fc bfc" id="L455" title="All 2 branches covered.">        for (int i = 0; i &lt; resultDimensions[0]; i++) {</span>
<span class="fc" id="L456">          double d = other.values[i];</span>
<span class="fc" id="L457">          int k = i * resultDimensions[1];</span>
<span class="fc bfc" id="L458" title="All 2 branches covered.">          for (int j = 0; j &lt; resultDimensions[1]; j++) {</span>
<span class="fc" id="L459">            int index = k + j;</span>
<span class="fc" id="L460">            result.values[index] = values[index] + d;</span>
          }
        }
<span class="pc bpc" id="L463" title="1 of 2 branches missed.">      } else if (msgIndex == 1) {</span>
<span class="fc bfc" id="L464" title="All 2 branches covered.">        for (int i = 0; i &lt; resultDimensions[0]; i++) {</span>
<span class="fc" id="L465">          int k = i * resultDimensions[1];</span>
<span class="fc bfc" id="L466" title="All 2 branches covered.">          for (int j = 0; j &lt; resultDimensions[1]; j++) {</span>
<span class="fc" id="L467">            int index = k + j;</span>
<span class="fc" id="L468">            result.values[index] = values[index] + other.values[j];</span>
          }
        }
      }
<span class="fc" id="L472">    }</span>
    // OPTIMIZATION:
    // The special case where we're a message of size 1, and the other factor is receiving the message, and of size 2
<span class="fc bfc" id="L475" title="All 6 branches covered.">    else if (domain.size() == 1 &amp;&amp; (resultDomain.size() == otherDomain.size()) &amp;&amp; resultDomain.size() == 2) {</span>
<span class="fc" id="L476">      return other.multiply(this);</span>
    }
    // Otherwise we follow the big comprehensive, slow general purpose algorithm
    else {

      // Calculate back-pointers from the result domain indices to original indices

<span class="fc" id="L483">      int[] mapping = new int[result.neighborIndices.length];</span>
<span class="fc" id="L484">      int[] otherMapping = new int[result.neighborIndices.length];</span>
<span class="fc bfc" id="L485" title="All 2 branches covered.">      for (int i = 0; i &lt; result.neighborIndices.length; i++) {</span>
<span class="fc" id="L486">        mapping[i] = domain.indexOf(result.neighborIndices[i]);</span>
<span class="fc" id="L487">        otherMapping[i] = otherDomain.indexOf(result.neighborIndices[i]);</span>
      }

      // Do the actual joining operation between the two tables, applying 'join' for each result element.

<span class="fc" id="L492">      int[] assignment = new int[neighborIndices.length];</span>
<span class="fc" id="L493">      int[] otherAssignment = new int[other.neighborIndices.length];</span>

      // OPTIMIZATION:
      // Rather than use the standard iterator, which creates lots of int[] arrays on the heap, which need to be GC'd,
      // we use the fast version that just mutates one array. Since this is read once for us here, this is ideal.
<span class="fc" id="L498">      Iterator&lt;int[]&gt; fastPassByReferenceIterator = result.fastPassByReferenceIterator();</span>
<span class="fc" id="L499">      int[] resultAssignment = fastPassByReferenceIterator.next();</span>
      while (true) {
        // Set the assignment arrays correctly
<span class="fc bfc" id="L502" title="All 2 branches covered.">        for (int i = 0; i &lt; resultAssignment.length; i++) {</span>
<span class="fc bfc" id="L503" title="All 2 branches covered.">          if (mapping[i] != -1) assignment[mapping[i]] = resultAssignment[i];</span>
<span class="fc bfc" id="L504" title="All 2 branches covered.">          if (otherMapping[i] != -1) otherAssignment[otherMapping[i]] = resultAssignment[i];</span>
        }
<span class="fc" id="L506">        result.setAssignmentLogValue(resultAssignment, getAssignmentLogValue(assignment) + other.getAssignmentLogValue(otherAssignment));</span>
        // This mutates the resultAssignment[] array, rather than creating a new one
<span class="fc bfc" id="L508" title="All 2 branches covered.">        if (fastPassByReferenceIterator.hasNext()) fastPassByReferenceIterator.next();</span>
        else break;
      }
    }

<span class="fc" id="L513">    return result;</span>
  }

  /**
   * This is useful for calculating the partition function, and is exposed here because when implemented internally
   * we can do a much more numerically stable summation.
   *
   * @return the sum of all values for all assignments to the TableFactor
   */
  public double valueSum() {

    // We want the exp(log-sum-exp), for stability
    // This rearranges to exp(a)*(sum-exp)

<span class="fc" id="L527">    double max = 0.0;</span>
<span class="fc bfc" id="L528" title="All 2 branches covered.">    for (int[] assignment : this) {</span>
<span class="fc" id="L529">      double v = getAssignmentLogValue(assignment);</span>
<span class="fc bfc" id="L530" title="All 2 branches covered.">      if (v &gt; max) {</span>
<span class="fc" id="L531">        max = v;</span>
      }
<span class="fc" id="L533">    }</span>

<span class="fc" id="L535">    double sumExp = 0.0;</span>
<span class="fc bfc" id="L536" title="All 2 branches covered.">    for (int[] assignment : this) {</span>
<span class="fc" id="L537">      sumExp += Math.exp(getAssignmentLogValue(assignment) - max);</span>
<span class="fc" id="L538">    }</span>

<span class="fc" id="L540">    return sumExp * Math.exp(max);</span>
  }

  /**
   * Just a pass through to the NDArray version, plus a Math.exp to ensure that to the outside world the TableFactor
   * doesn't look like it's in log-space
   *
   * @param assignment a list of variable settings, in the same order as the neighbors array of the factor
   * @return the value of the assignment
   */
  @Override
  public double getAssignmentValue(int[] assignment) {
<span class="fc" id="L552">    double d = super.getAssignmentValue(assignment);</span>
    // if (d == null) d = Double.NEGATIVE_INFINITY;
<span class="fc" id="L554">    return Math.exp(d);</span>
  }

  /**
   * Just a pass through to the NDArray version, plus a Math.log to ensure that to the outside world the TableFactor
   * doesn't look like it's in log-space
   *
   * @param assignment a list of variable settings, in the same order as the neighbors array of the factor
   * @param value      the value to put into the factor table
   */
  @Override
  public void setAssignmentValue(int[] assignment, double value) {
<span class="fc" id="L566">    super.setAssignmentValue(assignment, Math.log(value));</span>
<span class="fc" id="L567">  }</span>

  ////////////////////////////////////////////////////////////////////////////
  // PRIVATE IMPLEMENTATION
  ////////////////////////////////////////////////////////////////////////////

  private double getAssignmentLogValue(int[] assignment) {
<span class="fc" id="L574">    return super.getAssignmentValue(assignment);</span>
  }

  private void setAssignmentLogValue(int[] assignment, double value) {
<span class="fc" id="L578">    super.setAssignmentValue(assignment, value);</span>
<span class="fc" id="L579">  }</span>

  /**
   * Marginalizes out a variable by applying an associative join operation for each possible assignment to the
   * marginalized variable.
   *
   * @param variable      the variable (by 'name', not offset into neighborIndices)
   * @param startingValue associativeJoin is basically a foldr over a table, and this is the initialization
   * @param curriedFoldr  the associative function to use when applying the join operation, taking first the
   *                      assignment to the value being marginalized, and then a foldr operation
   * @return a new TableFactor that doesn't contain 'variable', where values were gotten through associative
   * marginalization.
   */
  private TableFactor marginalize(int variable, double startingValue, BiFunction&lt;Integer, int[], BiFunction&lt;Double, Double, Double&gt;&gt; curriedFoldr) {
    // Can't marginalize the last variable
<span class="pc bpc" id="L594" title="2 of 4 branches missed.">    assert (getDimensions().length &gt; 1);</span>

    // Calculate the result domain

<span class="fc" id="L598">    List&lt;Integer&gt; resultDomain = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L599" title="All 2 branches covered.">    for (int n : neighborIndices) {</span>
<span class="fc bfc" id="L600" title="All 2 branches covered.">      if (n != variable) {</span>
<span class="fc" id="L601">        resultDomain.add(n);</span>
      }
    }

    // Create result TableFactor

<span class="fc" id="L607">    int[] resultNeighborIndices = new int[resultDomain.size()];</span>
<span class="fc" id="L608">    int[] resultDimensions = new int[resultNeighborIndices.length];</span>
<span class="fc bfc" id="L609" title="All 2 branches covered.">    for (int i = 0; i &lt; resultDomain.size(); i++) {</span>
<span class="fc" id="L610">      int var = resultDomain.get(i);</span>
<span class="fc" id="L611">      resultNeighborIndices[i] = var;</span>
<span class="fc" id="L612">      resultDimensions[i] = getVariableSize(var);</span>
    }
<span class="fc" id="L614">    TableFactor result = new TableFactor(resultNeighborIndices, resultDimensions);</span>

    // Calculate forward-pointers from the old domain to new domain

<span class="fc" id="L618">    int[] mapping = new int[neighborIndices.length];</span>
<span class="fc bfc" id="L619" title="All 2 branches covered.">    for (int i = 0; i &lt; neighborIndices.length; i++) {</span>
<span class="fc" id="L620">      mapping[i] = resultDomain.indexOf(neighborIndices[i]);</span>
    }

    // Initialize

<span class="fc bfc" id="L625" title="All 2 branches covered.">    for (int[] assignment : result) {</span>
<span class="fc" id="L626">      result.setAssignmentLogValue(assignment, startingValue);</span>
<span class="fc" id="L627">    }</span>

    // Do the actual fold into the result

<span class="fc" id="L631">    int[] resultAssignment = new int[result.neighborIndices.length];</span>
<span class="fc" id="L632">    int marginalizedVariableValue = 0;</span>

    // OPTIMIZATION:
    // Rather than use the standard iterator, which creates lots of int[] arrays on the heap, which need to be GC'd,
    // we use the fast version that just mutates one array. Since this is read once for us here, this is ideal.
<span class="fc" id="L637">    Iterator&lt;int[]&gt; fastPassByReferenceIterator = fastPassByReferenceIterator();</span>
<span class="fc" id="L638">    int[] assignment = fastPassByReferenceIterator.next();</span>
    while (true) {
      // Set the assignment arrays correctly
<span class="fc bfc" id="L641" title="All 2 branches covered.">      for (int i = 0; i &lt; assignment.length; i++) {</span>
<span class="fc bfc" id="L642" title="All 2 branches covered.">        if (mapping[i] != -1) resultAssignment[mapping[i]] = assignment[i];</span>
<span class="fc" id="L643">        else marginalizedVariableValue = assignment[i];</span>
      }
<span class="fc" id="L645">      result.setAssignmentLogValue(resultAssignment, curriedFoldr.apply(marginalizedVariableValue, resultAssignment)</span>
<span class="fc" id="L646">          .apply(result.getAssignmentLogValue(resultAssignment), getAssignmentLogValue(assignment)));</span>
<span class="fc bfc" id="L647" title="All 2 branches covered.">      if (fastPassByReferenceIterator.hasNext()) fastPassByReferenceIterator.next();</span>
      else break;
    }

<span class="fc" id="L651">    return result;</span>
  }

  /**
   * Address a variable by index to get it's size. Basically just a convenience function.
   *
   * @param variable the name, not index into neighbors, of the variable in question
   * @return the size of the factor along this dimension
   */
  private int getVariableSize(int variable) {
<span class="fc bfc" id="L661" title="All 2 branches covered.">    for (int i = 0; i &lt; neighborIndices.length; i++) {</span>
<span class="fc bfc" id="L662" title="All 2 branches covered.">      if (neighborIndices[i] == variable) return getDimensions()[i];</span>
    }
<span class="fc" id="L664">    return 0;</span>
  }

  /**
   * Super basic in-place array normalization
   *
   * @param arr the array to normalize
   */
  private static void normalizeLogArr(double[] arr) {
    // Find the log-scale normalization value
<span class="fc" id="L674">    double max = Double.NEGATIVE_INFINITY;</span>
<span class="fc bfc" id="L675" title="All 2 branches covered.">    for (double d : arr) {</span>
<span class="fc bfc" id="L676" title="All 2 branches covered.">      if (d &gt; max) max = d;</span>
    }
<span class="fc" id="L678">    double expSum = 0.0;</span>
<span class="fc bfc" id="L679" title="All 2 branches covered.">    for (double d : arr) {</span>
<span class="fc" id="L680">      expSum += Math.exp(d - max);</span>
    }
<span class="fc" id="L682">    double logSumExp = max + Math.log(expSum);</span>

<span class="pc bpc" id="L684" title="1 of 2 branches missed.">    if (Double.isInfinite(logSumExp)) {</span>
      // Just put in uniform probabilities if we are normalizing all 0s
<span class="nc bnc" id="L686" title="All 2 branches missed.">      for (int i = 0; i &lt; arr.length; i++) {</span>
<span class="nc" id="L687">        arr[i] = 1.0 / arr.length;</span>
      }
    } else {
      // Normalize in log-scale before exponentiation, to help with stability
<span class="fc bfc" id="L691" title="All 2 branches covered.">      for (int i = 0; i &lt; arr.length; i++) {</span>
<span class="fc" id="L692">        arr[i] = Math.exp(arr[i] - logSumExp);</span>
      }
    }
<span class="fc" id="L695">  }</span>

  /**
   * FOR PRIVATE USE AND TESTING ONLY
   */
  TableFactor(int[] neighborIndices, int[] dimensions) {
<span class="fc" id="L701">    super(dimensions);</span>
<span class="fc" id="L702">    this.neighborIndices = neighborIndices;</span>
<span class="fc bfc" id="L703" title="All 2 branches covered.">    for (int i = 0; i &lt; values.length; i++) {</span>
<span class="fc" id="L704">      values[i] = Double.NEGATIVE_INFINITY;</span>
    }
<span class="fc" id="L706">  }</span>

  @SuppressWarnings(&quot;*&quot;)
  private boolean assertsEnabled() {
<span class="nc" id="L710">    boolean assertsEnabled = false;</span>
<span class="nc bnc" id="L711" title="All 4 branches missed.">    assert (assertsEnabled = true); // intentional side effect</span>
<span class="nc" id="L712">    return assertsEnabled;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>