<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Distribution.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.stats</a> &gt; <span class="el_source">Distribution.java</span></div><h1>Distribution.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.stats; 
import edu.stanford.nlp.util.logging.Redwood;

import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.util.*;

import edu.stanford.nlp.util.Generics;

/**
 * Immutable class for representing normalized, smoothed discrete distributions
 * from {@link Counters}. Smoothed counters reserve probability mass for unseen
 * items, so queries for the probability of unseen items will return a small
 * positive amount.  Normalization is L1 normalization:
 * {@link #totalCount} should always return 1.
 * &lt;p/&gt;
 * A Counter passed into a constructor is copied. This class is Serializable.
 *
 * @author Galen Andrew (galand@cs.stanford.edu), Sebastian Pado
 */
public class Distribution&lt;E&gt; implements Sampler&lt;E&gt;, ProbabilityDistribution&lt;E&gt;  {

  /** A logger for this class */
<span class="fc" id="L24">  private static Redwood.RedwoodChannels log = Redwood.channels(Distribution.class);</span>

  private static final long serialVersionUID = 6707148234288637809L;

  // todo [cdm Apr 2013]: Make these 3 variables final and put into constructor
  private int numberOfKeys;
  private double reservedMass;
  protected Counter&lt;E&gt; counter;
  private static final int NUM_ENTRIES_IN_STRING = 20;

  private static final boolean verbose = false;

  public Counter&lt;E&gt; getCounter() {
<span class="nc" id="L37">    return counter;</span>
  }


  /**
   * Exactly the same as sampleFrom(), needed for the Sampler interface.
   */
  @Override
  public E drawSample() {
<span class="nc" id="L46">    return sampleFrom();</span>
  }

  /**
   * A method to draw a sample, providing an own random number generator.
   * Needed for the ProbabilityDistribution interface.
   */
  @Override
  public E drawSample(Random random) {
<span class="nc" id="L55">    return sampleFrom(random);</span>
  }

  public String toString(NumberFormat nf) {
<span class="nc" id="L59">    return Counters.toString(counter, nf);</span>
  }

  public double getReservedMass() {
<span class="nc" id="L63">    return reservedMass;</span>
  }

  public int getNumberOfKeys() {
<span class="nc" id="L67">    return numberOfKeys;</span>
  }

  //--- cdm added Jan 2004 to help old code compile

  public Set&lt;E&gt; keySet() {
<span class="fc" id="L73">    return counter.keySet();</span>
  }

  public boolean containsKey(E key) {
<span class="fc" id="L77">    return counter.containsKey(key);</span>
  }

  /**
   * Returns the current count for the given key, which is 0 if it hasn't
   * been
   * seen before. This is a convenient version of &lt;code&gt;get&lt;/code&gt; that casts
   * and extracts the primitive value.
   *
   * @param key The key to look up.
   * @return The current count for the given key, which is 0 if it hasn't
   *     been seen before
   */
  public double getCount(E key) {
<span class="fc" id="L91">    return counter.getCount(key);</span>
  }

  //---- end cdm added

  //--- JM added for Distributions

  /**
   * Assuming that c has a total count &amp;lt; 1, returns a new Distribution using the counts in c as probabilities.
   * If c has a total count &amp;gt; 1, returns a normalized distribution with no remaining mass.
   */
  public static &lt;E&gt; Distribution&lt;E&gt; getDistributionFromPartiallySpecifiedCounter(Counter&lt;E&gt; c, int numKeys){
    Distribution&lt;E&gt; d;
<span class="nc" id="L104">    double total = c.totalCount();</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">    if (total &gt;= 1.0){</span>
<span class="nc" id="L106">      d = getDistribution(c);</span>
<span class="nc" id="L107">      d.numberOfKeys = numKeys;</span>
    } else {
<span class="nc" id="L109">      d = new Distribution&lt;&gt;();</span>
<span class="nc" id="L110">      d.numberOfKeys = numKeys;</span>
<span class="nc" id="L111">      d.counter = c;</span>
<span class="nc" id="L112">      d.reservedMass = 1.0 - total;</span>
    }
<span class="nc" id="L114">    return d;</span>
  }
  //--- end JM added


  /**
   * @param s a Collection of keys.
   */
  public static &lt;E&gt; Distribution&lt;E&gt; getUniformDistribution(Collection&lt;E&gt; s) {
<span class="nc" id="L123">    Distribution&lt;E&gt; norm = new Distribution&lt;&gt;();</span>
<span class="nc" id="L124">    norm.counter = new ClassicCounter&lt;&gt;();</span>
<span class="nc" id="L125">    norm.numberOfKeys = s.size();</span>
<span class="nc" id="L126">    norm.reservedMass = 0;</span>
<span class="nc" id="L127">    double total = s.size();</span>
<span class="nc" id="L128">    double count = 1.0 / total;</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">    for (E key : s) {</span>
<span class="nc" id="L130">      norm.counter.setCount(key, count);</span>
<span class="nc" id="L131">    }</span>
<span class="nc" id="L132">    return norm;</span>
  }

  /**
   * @param s a Collection of keys.
   */
  public static &lt;E&gt; Distribution&lt;E&gt; getPerturbedUniformDistribution(Collection&lt;E&gt; s, Random r) {
<span class="nc" id="L139">    Distribution&lt;E&gt; norm = new Distribution&lt;&gt;();</span>
<span class="nc" id="L140">    norm.counter = new ClassicCounter&lt;&gt;();</span>
<span class="nc" id="L141">    norm.numberOfKeys = s.size();</span>
<span class="nc" id="L142">    norm.reservedMass = 0;</span>
<span class="nc" id="L143">    double total = s.size();</span>
<span class="nc" id="L144">    double prob = 1.0 / total;</span>
<span class="nc" id="L145">    double stdev = prob / 1000.0;</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">    for (E key : s) {</span>
<span class="nc" id="L147">      norm.counter.setCount(key, prob + (r.nextGaussian() * stdev));</span>
<span class="nc" id="L148">    }</span>
<span class="nc" id="L149">    return norm;</span>
  }

  public static &lt;E&gt; Distribution&lt;E&gt; getPerturbedDistribution(Counter&lt;E&gt; wordCounter, Random r) {
<span class="nc" id="L153">    Distribution&lt;E&gt; norm = new Distribution&lt;&gt;();</span>
<span class="nc" id="L154">    norm.counter = new ClassicCounter&lt;&gt;();</span>
<span class="nc" id="L155">    norm.numberOfKeys = wordCounter.size();</span>
<span class="nc" id="L156">    norm.reservedMass = 0;</span>
<span class="nc" id="L157">    double totalCount = wordCounter.totalCount();</span>
<span class="nc" id="L158">    double stdev = 1.0 / norm.numberOfKeys / 1000.0; // tiny relative to average value</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">    for (E key : wordCounter.keySet()) {</span>
<span class="nc" id="L160">      double prob = wordCounter.getCount(key) / totalCount;</span>
<span class="nc" id="L161">      double perturbedProb = prob + (r.nextGaussian() * stdev);</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">      if (perturbedProb &lt; 0.0) {</span>
<span class="nc" id="L163">        perturbedProb = 0.0;</span>
      }
<span class="nc" id="L165">      norm.counter.setCount(key, perturbedProb);</span>
<span class="nc" id="L166">    }</span>
<span class="nc" id="L167">    return norm;</span>
  }

  /**
   * Creates a Distribution from the given counter. It makes an internal
   * copy of the counter and divides all counts by the total count.
   *
   * @return a new Distribution
   */
  public static &lt;E&gt; Distribution&lt;E&gt; getDistribution(Counter&lt;E&gt; counter) {
<span class="fc" id="L177">    return getDistributionWithReservedMass(counter, 0.0);</span>
  }

  public static &lt;E&gt; Distribution&lt;E&gt; getDistributionWithReservedMass(Counter&lt;E&gt; counter, double reservedMass) {
<span class="fc" id="L181">    Distribution&lt;E&gt; norm = new Distribution&lt;&gt;();</span>
<span class="fc" id="L182">    norm.counter = new ClassicCounter&lt;&gt;();</span>
<span class="fc" id="L183">    norm.numberOfKeys = counter.size();</span>
<span class="fc" id="L184">    norm.reservedMass = reservedMass;</span>
<span class="fc" id="L185">    double total = counter.totalCount() * (1 + reservedMass);</span>
<span class="pc bpc" id="L186" title="1 of 2 branches missed.">    if (total == 0.0) {</span>
<span class="nc" id="L187">      total = 1.0;</span>
    }
<span class="fc bfc" id="L189" title="All 2 branches covered.">    for (E key : counter.keySet()) {</span>
<span class="fc" id="L190">      double count = counter.getCount(key) / total;</span>
      //      if (Double.isNaN(count) || count &lt; 0.0 || count&gt; 1.0 ) throw new RuntimeException(&quot;count=&quot; + counter.getCount(key) + &quot; total=&quot; + total);
<span class="fc" id="L192">      norm.counter.setCount(key, count);</span>
<span class="fc" id="L193">    }</span>
<span class="fc" id="L194">    return norm;</span>
  }

  /**
   * Creates a Distribution from the given counter, ie makes an internal
   * copy of the counter and divides all counts by the total count.
   *
   * @return a new Distribution
   */
  public static &lt;E&gt; Distribution&lt;E&gt; getDistributionFromLogValues(Counter&lt;E&gt; counter) {
<span class="fc" id="L204">    Counter&lt;E&gt; c = new ClassicCounter&lt;&gt;();</span>
    // go through once to get the max
    // shift all by max so as to minimize the possibility of underflow
<span class="fc" id="L207">    double max = Counters.max(counter); // Thang 17Feb12: max should operate on counter instead of c, fixed!</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">    for (E key : counter.keySet()) {</span>
<span class="fc" id="L209">      double count = Math.exp(counter.getCount(key) - max);</span>
<span class="fc" id="L210">      c.setCount(key, count);</span>
<span class="fc" id="L211">    }</span>
<span class="fc" id="L212">    return getDistribution(c);</span>
  }

  public static &lt;E&gt; Distribution&lt;E&gt; absolutelyDiscountedDistribution(Counter&lt;E&gt; counter, int numberOfKeys, double discount) {
<span class="nc" id="L216">    Distribution&lt;E&gt; norm = new Distribution&lt;&gt;();</span>
<span class="nc" id="L217">    norm.counter = new ClassicCounter&lt;&gt;();</span>
<span class="nc" id="L218">    double total = counter.totalCount();</span>
<span class="nc" id="L219">    double reservedMass = 0.0;</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">    for (E key : counter.keySet()) {</span>
<span class="nc" id="L221">      double count = counter.getCount(key);</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">      if (count &gt; discount) {</span>
<span class="nc" id="L223">        double newCount = (count - discount) / total;</span>
<span class="nc" id="L224">        norm.counter.setCount(key, newCount); // a positive count left over</span>
        //        System.out.println(&quot;seen: &quot; + newCount);
<span class="nc" id="L226">        reservedMass += discount;</span>
<span class="nc" id="L227">      } else { // count &lt;= discount</span>
<span class="nc" id="L228">        reservedMass += count;</span>
        // if the count &lt;= discount, don't put key in counter, and we treat it as unseen!!
      }
<span class="nc" id="L231">    }</span>
<span class="nc" id="L232">    norm.numberOfKeys = numberOfKeys;</span>
<span class="nc" id="L233">    norm.reservedMass = reservedMass / total;</span>
    if (verbose) {
      log.info(&quot;unseenKeys=&quot; + (norm.numberOfKeys - norm.counter.size()) + &quot; seenKeys=&quot; + norm.counter.size() + &quot; reservedMass=&quot; + norm.reservedMass);
      double zeroCountProb = (norm.reservedMass / (numberOfKeys - norm.counter.size()));
      log.info(&quot;0 count prob: &quot; + zeroCountProb);
      if (discount &gt;= 1.0) {
        log.info(&quot;1 count prob: &quot; + zeroCountProb);
      } else {
        log.info(&quot;1 count prob: &quot; + (1.0 - discount) / total);
      }
      if (discount &gt;= 2.0) {
        log.info(&quot;2 count prob: &quot; + zeroCountProb);
      } else {
        log.info(&quot;2 count prob: &quot; + (2.0 - discount) / total);
      }
      if (discount &gt;= 3.0) {
        log.info(&quot;3 count prob: &quot; + zeroCountProb);
      } else {
        log.info(&quot;3 count prob: &quot; + (3.0 - discount) / total);
      }
    }
    //    System.out.println(&quot;UNSEEN: &quot; + reservedMass / total / (numberOfKeys - counter.size()));
<span class="nc" id="L255">    return norm;</span>
  }

  /**
   * Creates an Laplace smoothed Distribution from the given counter, ie adds one count
   * to every item, including unseen ones, and divides by the total count.
   *
   * @return a new add-1 smoothed Distribution
   */
  public static &lt;E&gt; Distribution&lt;E&gt; laplaceSmoothedDistribution(Counter&lt;E&gt; counter, int numberOfKeys) {
<span class="nc" id="L265">    return laplaceSmoothedDistribution(counter, numberOfKeys, 1.0);</span>
  }

  /**
   * Creates a smoothed Distribution using Lidstone's law, ie adds lambda (typically
   * between 0 and 1) to every item, including unseen ones, and divides by the total count.
   *
   * @return a new Lidstone smoothed Distribution
   */
  public static &lt;E&gt; Distribution&lt;E&gt; laplaceSmoothedDistribution(Counter&lt;E&gt; counter, int numberOfKeys, double lambda) {
<span class="nc" id="L275">    Distribution&lt;E&gt; norm = new Distribution&lt;&gt;();</span>
<span class="nc" id="L276">    norm.counter = new ClassicCounter&lt;&gt;();</span>
<span class="nc" id="L277">    double total = counter.totalCount();</span>
<span class="nc" id="L278">    double newTotal = total + (lambda * numberOfKeys);</span>
<span class="nc" id="L279">    double reservedMass = ((double) numberOfKeys - counter.size()) * lambda / newTotal;</span>
    if (verbose) {
      log.info(((double) numberOfKeys - counter.size()) + &quot; * &quot; + lambda + &quot; / (&quot; + total + &quot; + ( &quot; + lambda + &quot; * &quot; + (double) numberOfKeys + &quot;) )&quot;);
    }
<span class="nc" id="L283">    norm.numberOfKeys = numberOfKeys;</span>
<span class="nc" id="L284">    norm.reservedMass = reservedMass;</span>
    if (verbose) {
      log.info(&quot;reserved mass=&quot; + reservedMass);
    }
<span class="nc bnc" id="L288" title="All 2 branches missed.">    for (E key : counter.keySet()) {</span>
<span class="nc" id="L289">      double count = counter.getCount(key);</span>
<span class="nc" id="L290">      norm.counter.setCount(key, (count + lambda) / newTotal);</span>
<span class="nc" id="L291">    }</span>
    if (verbose) {
      log.info(&quot;unseenKeys=&quot; + (norm.numberOfKeys - norm.counter.size()) + &quot; seenKeys=&quot; + norm.counter.size() + &quot; reservedMass=&quot; + norm.reservedMass);
      log.info(&quot;0 count prob: &quot; + lambda / newTotal);
      log.info(&quot;1 count prob: &quot; + (1.0 + lambda) / newTotal);
      log.info(&quot;2 count prob: &quot; + (2.0 + lambda) / newTotal);
      log.info(&quot;3 count prob: &quot; + (3.0 + lambda) / newTotal);
    }
<span class="nc" id="L299">    return norm;</span>
  }

  /**
   * Creates a smoothed Distribution with Laplace smoothing, but assumes an explicit
   * count of &quot;UNKNOWN&quot; items.  Thus anything not in the original counter will have
   * probability zero.
   *
   * @param counter the counter to normalize
   * @param lambda  the value to add to each count
   * @param UNK     the UNKNOWN symbol
   * @return a new Laplace-smoothed distribution
   */
  public static &lt;E&gt; Distribution&lt;E&gt; laplaceWithExplicitUnknown(Counter&lt;E&gt; counter, double lambda, E UNK) {
<span class="nc" id="L313">    Distribution&lt;E&gt; norm = new Distribution&lt;&gt;();</span>
<span class="nc" id="L314">    norm.counter = new ClassicCounter&lt;&gt;();</span>
<span class="nc" id="L315">    double total = counter.totalCount() + (lambda * (counter.size() - 1));</span>
<span class="nc" id="L316">    norm.numberOfKeys = counter.size();</span>
<span class="nc" id="L317">    norm.reservedMass = 0.0;</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">    for (E key : counter.keySet()) {</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">      if (key.equals(UNK)) {</span>
<span class="nc" id="L320">        norm.counter.setCount(key, counter.getCount(key) / total);</span>
      } else {
<span class="nc" id="L322">        norm.counter.setCount(key, (counter.getCount(key) + lambda) / total);</span>
      }
<span class="nc" id="L324">    }</span>
<span class="nc" id="L325">    return norm;</span>
  }

  /**
   * Creates a Good-Turing smoothed Distribution from the given counter.
   *
   * @return a new Good-Turing smoothed Distribution.
   */
  public static &lt;E&gt; Distribution&lt;E&gt; goodTuringSmoothedCounter(Counter&lt;E&gt; counter, int numberOfKeys) {
    // gather count-counts
<span class="nc" id="L335">    int[] countCounts = getCountCounts(counter);</span>

    // if count-counts are unreliable, we shouldn't be using G-T
    // revert to laplace
<span class="nc bnc" id="L339" title="All 2 branches missed.">    for (int i = 1; i &lt;= 10; i++) {</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">      if (countCounts[i] &lt; 3) {</span>
<span class="nc" id="L341">        return laplaceSmoothedDistribution(counter, numberOfKeys, 0.5);</span>
      }
    }

<span class="nc" id="L345">    double observedMass = counter.totalCount();</span>
<span class="nc" id="L346">    double reservedMass = countCounts[1] / observedMass;</span>

    // calculate and cache adjusted frequencies
    // also adjusting total mass of observed items
<span class="nc" id="L350">    double[] adjustedFreq = new double[10];</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">    for (int freq = 1; freq &lt; 10; freq++) {</span>
<span class="nc" id="L352">      adjustedFreq[freq] = (double) (freq + 1) * (double) countCounts[freq + 1] / countCounts[freq];</span>
<span class="nc" id="L353">      observedMass -= (freq - adjustedFreq[freq]) * countCounts[freq];</span>
    }

<span class="nc" id="L356">    double normFactor = (1.0 - reservedMass) / observedMass;</span>

<span class="nc" id="L358">    Distribution&lt;E&gt; norm = new Distribution&lt;&gt;();</span>
<span class="nc" id="L359">    norm.counter = new ClassicCounter&lt;&gt;();</span>

    // fill in the new Distribution, renormalizing as we go
<span class="nc bnc" id="L362" title="All 2 branches missed.">    for (E key : counter.keySet()) {</span>
<span class="nc" id="L363">      int origFreq = (int) Math.round(counter.getCount(key));</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">      if (origFreq &lt; 10) {</span>
<span class="nc" id="L365">        norm.counter.setCount(key, adjustedFreq[origFreq] * normFactor);</span>
      } else {
<span class="nc" id="L367">        norm.counter.setCount(key, origFreq * normFactor);</span>
      }
<span class="nc" id="L369">    }</span>

<span class="nc" id="L371">    norm.numberOfKeys = numberOfKeys;</span>
<span class="nc" id="L372">    norm.reservedMass = reservedMass;</span>
<span class="nc" id="L373">    return norm;</span>
  }

  /**
   * Creates a Good-Turing smoothed Distribution from the given counter without
   * creating any reserved mass-- instead, the special object UNK in the counter
   * is assumed to be the count of &quot;UNSEEN&quot; items.  Probability of objects not in
   * original counter will be zero.
   *
   * @param counter the counter
   * @param UNK     the unknown symbol
   * @return a good-turing smoothed distribution
   */
  public static &lt;E&gt; Distribution&lt;E&gt; goodTuringWithExplicitUnknown(Counter&lt;E&gt; counter, E UNK) {
    // gather count-counts
<span class="nc" id="L388">    int[] countCounts = getCountCounts(counter);</span>

    // if count-counts are unreliable, we shouldn't be using G-T
    // revert to laplace
<span class="nc bnc" id="L392" title="All 2 branches missed.">    for (int i = 1; i &lt;= 10; i++) {</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">      if (countCounts[i] &lt; 3) {</span>
<span class="nc" id="L394">        return laplaceWithExplicitUnknown(counter, 0.5, UNK);</span>
      }
    }

<span class="nc" id="L398">    double observedMass = counter.totalCount();</span>

    // calculate and cache adjusted frequencies
    // also adjusting total mass of observed items
<span class="nc" id="L402">    double[] adjustedFreq = new double[10];</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">    for (int freq = 1; freq &lt; 10; freq++) {</span>
<span class="nc" id="L404">      adjustedFreq[freq] = (double) (freq + 1) * (double) countCounts[freq + 1] / countCounts[freq];</span>
<span class="nc" id="L405">      observedMass -= (freq - adjustedFreq[freq]) * countCounts[freq];</span>
    }

<span class="nc" id="L408">    Distribution&lt;E&gt; norm = new Distribution&lt;&gt;();</span>
<span class="nc" id="L409">    norm.counter = new ClassicCounter&lt;&gt;();</span>

    // fill in the new Distribution, renormalizing as we go
<span class="nc bnc" id="L412" title="All 2 branches missed.">    for (E key : counter.keySet()) {</span>
<span class="nc" id="L413">      int origFreq = (int) Math.round(counter.getCount(key));</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">      if (origFreq &lt; 10) {</span>
<span class="nc" id="L415">        norm.counter.setCount(key, adjustedFreq[origFreq] / observedMass);</span>
      } else {
<span class="nc" id="L417">        norm.counter.setCount(key, origFreq / observedMass);</span>
      }
<span class="nc" id="L419">    }</span>

<span class="nc" id="L421">    norm.numberOfKeys = counter.size();</span>
<span class="nc" id="L422">    norm.reservedMass = 0.0;</span>
<span class="nc" id="L423">    return norm;</span>

  }

  private static &lt;E&gt; int[] getCountCounts(Counter&lt;E&gt; counter) {
<span class="nc" id="L428">    int[] countCounts = new int[11];</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">    for (int i = 0; i &lt;= 10; i++) {</span>
<span class="nc" id="L430">      countCounts[i] = 0;</span>
    }
<span class="nc bnc" id="L432" title="All 2 branches missed.">    for (E key : counter.keySet()) {</span>
<span class="nc" id="L433">      int count = (int) Math.round(counter.getCount(key));</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">      if (count &lt;= 10) {</span>
<span class="nc" id="L435">        countCounts[count]++;</span>
      }
<span class="nc" id="L437">    }</span>
<span class="nc" id="L438">    return countCounts;</span>
  }


  // ----------------------------------------------------------------------------

  /**
   * Creates a Distribution from the given counter using Gale &amp;amp; Sampsons'
   * &quot;simple Good-Turing&quot; smoothing.
   *
   * @return a new simple Good-Turing smoothed Distribution.
   */
  public static &lt;E&gt; Distribution&lt;E&gt; simpleGoodTuring(Counter&lt;E&gt; counter, int numberOfKeys) {

    // check arguments
<span class="nc" id="L453">    validateCounter(counter);</span>
<span class="nc" id="L454">    int numUnseen = numberOfKeys - counter.size();</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">    if (numUnseen &lt; 1)</span>
<span class="nc" id="L456">      throw new IllegalArgumentException(String.format(&quot;ERROR: numberOfKeys %d must be &gt; size of counter %d!&quot;, numberOfKeys, counter.size()));</span>

    // do smoothing
<span class="nc" id="L459">    int[][] cc = countCounts2IntArrays(collectCountCounts(counter));</span>
<span class="nc" id="L460">    int[] r = cc[0];                    // counts</span>
<span class="nc" id="L461">    int[] n = cc[1];                    // counts of counts</span>
<span class="nc" id="L462">    SimpleGoodTuring sgt = new SimpleGoodTuring(r, n);</span>

    // collate results
<span class="nc" id="L465">    Counter&lt;Integer&gt; probsByCount = new ClassicCounter&lt;&gt;();</span>
<span class="nc" id="L466">    double[] probs = sgt.getProbabilities();</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">    for (int i = 0; i &lt; probs.length; i++) {</span>
<span class="nc" id="L468">      probsByCount.setCount(r[i], probs[i]);</span>
    }

    // make smoothed distribution
<span class="nc" id="L472">    Distribution&lt;E&gt; dist = new Distribution&lt;&gt;();</span>
<span class="nc" id="L473">    dist.counter = new ClassicCounter&lt;&gt;();</span>
<span class="nc bnc" id="L474" title="All 2 branches missed.">    for (Map.Entry&lt;E, Double&gt; entry : counter.entrySet()) {</span>
<span class="nc" id="L475">      E item = entry.getKey();</span>
<span class="nc" id="L476">      Integer count = (int) Math.round(entry.getValue());</span>
<span class="nc" id="L477">      dist.counter.setCount(item, probsByCount.getCount(count));</span>
<span class="nc" id="L478">    }</span>
<span class="nc" id="L479">    dist.numberOfKeys = numberOfKeys;</span>
<span class="nc" id="L480">    dist.reservedMass = sgt.getProbabilityForUnseen();</span>
<span class="nc" id="L481">    return dist;</span>

  }

  /* Helper to simpleGoodTuringSmoothedCounter() */
  private static &lt;E&gt; void validateCounter(Counter&lt;E&gt; counts) {
<span class="nc bnc" id="L487" title="All 2 branches missed.">    for (Map.Entry&lt;E, Double&gt; entry : counts.entrySet()) {</span>
<span class="nc" id="L488">      E item = entry.getKey();</span>
<span class="nc" id="L489">      Double dblCount = entry.getValue();</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">      if (dblCount == null) {</span>
<span class="nc" id="L491">        throw new IllegalArgumentException(&quot;ERROR: null count for item &quot; + item + &quot;!&quot;);</span>
      }
<span class="nc bnc" id="L493" title="All 2 branches missed.">      if (dblCount &lt; 0) {</span>
<span class="nc" id="L494">        throw new IllegalArgumentException(&quot;ERROR: negative count &quot; + dblCount + &quot; for item &quot; + item + &quot;!&quot;);</span>
      }
<span class="nc" id="L496">    }</span>
<span class="nc" id="L497">  }</span>

  /* Helper to simpleGoodTuringSmoothedCounter() */
  private static &lt;E&gt; Counter&lt;Integer&gt; collectCountCounts(Counter&lt;E&gt; counts) {
<span class="nc" id="L501">    Counter&lt;Integer&gt; cc = new ClassicCounter&lt;&gt;(); // counts of counts</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">    for (Map.Entry&lt;E, Double&gt; entry : counts.entrySet()) {</span>
      //E item = entry.getKey();
<span class="nc" id="L504">      Integer count = (int) Math.round(entry.getValue());</span>
<span class="nc" id="L505">      cc.incrementCount(count);</span>
<span class="nc" id="L506">    }</span>
<span class="nc" id="L507">    return cc;</span>
  }

  /* Helper to simpleGoodTuringSmoothedCounter() */
  private static int[][] countCounts2IntArrays(Counter&lt;Integer&gt; countCounts) {
<span class="nc" id="L512">    int size = countCounts.size();</span>
<span class="nc" id="L513">    int[][] arrays = new int[2][];</span>
<span class="nc" id="L514">    arrays[0] = new int[size]; // counts</span>
<span class="nc" id="L515">    arrays[1] = new int[size]; // count counts</span>
<span class="nc" id="L516">    PriorityQueue&lt;Integer&gt; q = new PriorityQueue&lt;&gt;(countCounts.keySet());</span>
<span class="nc" id="L517">    int i = 0;</span>
<span class="nc bnc" id="L518" title="All 2 branches missed.">    while (!q.isEmpty()) {</span>
<span class="nc" id="L519">      Integer count = q.poll();</span>
<span class="nc" id="L520">      Integer countCount = (int) Math.round(countCounts.getCount(count));</span>
<span class="nc" id="L521">      arrays[0][i] = count;</span>
<span class="nc" id="L522">      arrays[1][i] = countCount;</span>
<span class="nc" id="L523">      i++;</span>
<span class="nc" id="L524">    }</span>
<span class="nc" id="L525">    return arrays;</span>
  }


  // ----------------------------------------------------------------------------

  /**
   * Returns a Distribution that uses prior as a Dirichlet prior
   * weighted by weight.  Essentially adds &quot;pseudo-counts&quot; for each Object
   * in prior equal to that Object's mass in prior times weight,
   * then normalizes.
   * &lt;p/&gt;
   * WARNING: If unseen item is encountered in c, total may not be 1.
   * NOTE: This will not work if prior is a DynamicDistribution
   * to fix this, you could add a CounterView to Distribution and use that
   * in the linearCombination call below
   *
   * @param weight multiplier of prior to get &quot;pseudo-count&quot;
   * @return new Distribution
   */
  public static &lt;E&gt; Distribution&lt;E&gt; distributionWithDirichletPrior(Counter&lt;E&gt; c, Distribution&lt;E&gt; prior, double weight) {
<span class="nc" id="L546">    Distribution&lt;E&gt; norm = new Distribution&lt;&gt;();</span>
<span class="nc" id="L547">    double totalWeight = c.totalCount() + weight;</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">    if (prior instanceof DynamicDistribution) {</span>
<span class="nc" id="L549">      throw new UnsupportedOperationException(&quot;Cannot make normalized counter with Dynamic prior.&quot;);</span>
    }
<span class="nc" id="L551">    norm.counter = Counters.linearCombination(c, 1 / totalWeight, prior.counter, weight / totalWeight);</span>
<span class="nc" id="L552">    norm.numberOfKeys = prior.numberOfKeys;</span>
<span class="nc" id="L553">    norm.reservedMass = prior.reservedMass * weight / totalWeight;</span>
    //System.out.println(&quot;totalCount: &quot; + norm.totalCount());
<span class="nc" id="L555">    return norm;</span>
  }

  /**
   * Like normalizedCounterWithDirichletPrior except probabilities are
   * computed dynamically from the counter and prior instead of all at once up front.
   * The main advantage of this is if you are making many distributions from relatively
   * sparse counters using the same relatively dense prior, the prior is only represented
   * once, for major memory savings.
   *
   * @param weight multiplier of prior to get &quot;pseudo-count&quot;
   * @return new Distribution
   */
  public static &lt;E&gt; Distribution&lt;E&gt; dynamicCounterWithDirichletPrior(Counter&lt;E&gt; c, Distribution&lt;E&gt; prior, double weight) {
<span class="nc" id="L569">    double totalWeight = c.totalCount() + weight;</span>
<span class="nc" id="L570">    Distribution&lt;E&gt; norm = new DynamicDistribution&lt;&gt;(prior, weight / totalWeight);</span>
<span class="nc" id="L571">    norm.counter = new ClassicCounter&lt;&gt;();</span>
    // this might be done more efficiently with entrySet but there isn't a way to get
    // the entrySet from a Counter now.  In most cases c will be small(-ish) anyway
<span class="nc bnc" id="L574" title="All 2 branches missed.">    for (E key : c.keySet()) {</span>
<span class="nc" id="L575">      double count = c.getCount(key) / totalWeight;</span>
<span class="nc" id="L576">      prior.addToKeySet(key);</span>
<span class="nc" id="L577">      norm.counter.setCount(key, count);</span>
<span class="nc" id="L578">    }</span>
<span class="nc" id="L579">    norm.numberOfKeys = prior.numberOfKeys;</span>
<span class="nc" id="L580">    return norm;</span>
  }

  private static class DynamicDistribution&lt;E&gt; extends Distribution&lt;E&gt; {

    private static final long serialVersionUID = -6073849364871185L;
    private final Distribution&lt;E&gt; prior;
    private final double priorMultiplier;

    public DynamicDistribution(Distribution&lt;E&gt; prior, double priorMultiplier) {
<span class="nc" id="L590">      super();</span>
<span class="nc" id="L591">      this.prior = prior;</span>
<span class="nc" id="L592">      this.priorMultiplier = priorMultiplier;</span>
<span class="nc" id="L593">    }</span>

    @Override
    public double probabilityOf(E o) {
<span class="nc" id="L597">      return this.counter.getCount(o) + prior.probabilityOf(o) * priorMultiplier;</span>
    }

    @Override
    public double totalCount() {
<span class="nc" id="L602">      return this.counter.totalCount() + prior.totalCount() * priorMultiplier;</span>
    }

    @Override
    public Set&lt;E&gt; keySet() {
<span class="nc" id="L607">      return prior.keySet();</span>
    }

    @Override
    public void addToKeySet(E o) {
<span class="nc" id="L612">      prior.addToKeySet(o);</span>
<span class="nc" id="L613">    }</span>

    @Override
    public boolean containsKey(E key) {
<span class="nc" id="L617">      return prior.containsKey(key);</span>
    }

    @Override
    public E argmax() {
<span class="nc" id="L622">      return Counters.argmax(Counters.linearCombination(this.counter, 1.0, prior.counter, priorMultiplier));</span>
    }

    @Override
    public E sampleFrom() {
<span class="nc" id="L627">      double d = Math.random();</span>
<span class="nc" id="L628">      Set&lt;E&gt; s = prior.keySet();</span>
<span class="nc bnc" id="L629" title="All 2 branches missed.">      for (E o : s) {</span>
<span class="nc" id="L630">        d -= probabilityOf(o);</span>
<span class="nc bnc" id="L631" title="All 2 branches missed.">        if (d &lt; 0) {</span>
<span class="nc" id="L632">          return o;</span>
        }
<span class="nc" id="L634">      }</span>
<span class="nc" id="L635">      log.error(&quot;Distribution sums to less than 1&quot;);</span>
<span class="nc" id="L636">      log.info(&quot;Sampled &quot; + d + &quot;      sum is &quot; + totalCount());</span>
<span class="nc" id="L637">      throw new RuntimeException(&quot;&quot;);</span>
    }
  }

  /**
   * Maps a counter representing the linear weights of a multiclass
   * logistic regression model to the probabilities of each class.
   */
  public static &lt;E&gt; Distribution&lt;E&gt; distributionFromLogisticCounter(Counter&lt;E&gt; cntr) {
<span class="nc" id="L646">    double expSum = 0.0;</span>
<span class="nc" id="L647">    int numKeys = 0;</span>
<span class="nc bnc" id="L648" title="All 2 branches missed.">    for (E key : cntr.keySet()) {</span>
<span class="nc" id="L649">      expSum += Math.exp(cntr.getCount(key));</span>
<span class="nc" id="L650">      numKeys++;</span>
<span class="nc" id="L651">    }</span>
<span class="nc" id="L652">    Distribution&lt;E&gt; probs = new Distribution&lt;&gt;();</span>
<span class="nc" id="L653">    probs.counter = new ClassicCounter&lt;&gt;();</span>
<span class="nc" id="L654">    probs.reservedMass = 0.0;</span>
<span class="nc" id="L655">    probs.numberOfKeys = numKeys;</span>
<span class="nc bnc" id="L656" title="All 2 branches missed.">    for (E key : cntr.keySet()) {</span>
<span class="nc" id="L657">      probs.counter.setCount(key, Math.exp(cntr.getCount(key)) / expSum);</span>
<span class="nc" id="L658">    }</span>
<span class="nc" id="L659">    return probs;</span>
  }

  /**
   * Returns an object sampled from the distribution using Math.random().
   * There may be a faster way to do this if you need to...
   *
   * @return a sampled object
   */
  public E sampleFrom() {
<span class="nc" id="L669">    return Counters.sample(counter);</span>
  }
  /**
   * Returns an object sampled from the distribution using a self-provided
   * random number generator.
   *
   * @return a sampled object
   */
  public E sampleFrom(Random random) {
<span class="nc" id="L678">    return Counters.sample(counter, random);</span>
  }

  /**
   * Returns the normalized count of the given object.
   *
   * @return the normalized count of the object
   */
  public double probabilityOf(E key) {
<span class="nc bnc" id="L687" title="All 2 branches missed.">    if (counter.containsKey(key)) {</span>
<span class="nc" id="L688">      return counter.getCount(key);</span>
    } else {
<span class="nc" id="L690">      int remainingKeys = numberOfKeys - counter.size();</span>
<span class="nc bnc" id="L691" title="All 2 branches missed.">      if (remainingKeys &lt;= 0) {</span>
<span class="nc" id="L692">        return 0.0;</span>
      } else {
<span class="nc" id="L694">        return (reservedMass / remainingKeys);</span>
      }
    }
  }

  /**
   * Returns the natural logarithm of the object's probability
   *
   * @return the logarithm of the normalised count (may be NaN if Pr==0.0)
   */
  public double logProbabilityOf(E key) {
<span class="nc" id="L705">    double prob = probabilityOf(key);</span>
<span class="nc" id="L706">    return Math.log(prob);</span>
  }

  public E argmax() {
<span class="nc" id="L710">    return Counters.argmax(counter);</span>
  }

  public double totalCount() {
<span class="nc" id="L714">    return counter.totalCount() + reservedMass;</span>
  }

  /**
   * Insures that object is in keyset (with possibly zero value)
   *
   * @param o object to put in keyset
   */
  public void addToKeySet(E o) {
<span class="nc bnc" id="L723" title="All 2 branches missed.">    if (!counter.containsKey(o)) {</span>
<span class="nc" id="L724">      counter.setCount(o, 0);</span>
    }
<span class="nc" id="L726">  }</span>

  @Override
  @SuppressWarnings(&quot;unchecked&quot;)
  public boolean equals(Object o) {
<span class="nc bnc" id="L731" title="All 2 branches missed.">    if (this == o) {</span>
<span class="nc" id="L732">      return true;</span>
    }
<span class="nc bnc" id="L734" title="All 4 branches missed.">    return o instanceof Distribution &amp;&amp; equals((Distribution) o);</span>
  }

  public boolean equals(Distribution&lt;E&gt; distribution) {
<span class="nc bnc" id="L738" title="All 2 branches missed.">    if (numberOfKeys != distribution.numberOfKeys) {</span>
<span class="nc" id="L739">      return false;</span>
    }
<span class="nc bnc" id="L741" title="All 2 branches missed.">    if (reservedMass != distribution.reservedMass) {</span>
<span class="nc" id="L742">      return false;</span>
    }
<span class="nc" id="L744">    return counter.equals(distribution.counter);</span>
  }

  @Override
  public int hashCode() {
<span class="nc" id="L749">    int result = numberOfKeys;</span>
<span class="nc" id="L750">    long temp = Double.doubleToLongBits(reservedMass);</span>
<span class="nc" id="L751">    result = 29 * result + (int) (temp ^ (temp &gt;&gt;&gt; 32));</span>
<span class="nc" id="L752">    result = 29 * result + counter.hashCode();</span>
<span class="nc" id="L753">    return result;</span>
  }

  // no public constructor; use static methods instead
<span class="fc" id="L757">  private Distribution() {}</span>

  @Override
  public String toString() {
<span class="nc" id="L761">    NumberFormat nf = new DecimalFormat(&quot;0.0##E0&quot;);</span>
<span class="nc" id="L762">    List&lt;E&gt; keyList = new ArrayList&lt;&gt;(keySet());</span>
<span class="nc" id="L763">    Collections.sort(keyList, (o1, o2) -&gt; {</span>
<span class="nc bnc" id="L764" title="All 2 branches missed.">      if (probabilityOf(o1) &lt; probabilityOf(o2)) {</span>
<span class="nc" id="L765">        return 1;</span>
      } else {
<span class="nc" id="L767">        return -1;</span>
      }
    });
<span class="nc" id="L770">    StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L771">    sb.append(&quot;[&quot;);</span>
<span class="nc bnc" id="L772" title="All 2 branches missed.">    for (int i = 0; i &lt; NUM_ENTRIES_IN_STRING; i++) {</span>
<span class="nc bnc" id="L773" title="All 2 branches missed.">      if (keyList.size() &lt;= i) {</span>
<span class="nc" id="L774">        break;</span>
      }
<span class="nc" id="L776">      E o = keyList.get(i);</span>
<span class="nc" id="L777">      double prob = probabilityOf(o);</span>
<span class="nc" id="L778">      sb.append(o).append(&quot;:&quot;).append(nf.format(prob)).append(&quot; &quot;);</span>
    }
<span class="nc" id="L780">    sb.append(&quot;]&quot;);</span>
<span class="nc" id="L781">    return sb.toString();</span>
  }

  /**
   * For internal testing purposes only.
   */
  public static void main(String[] args) {
<span class="nc" id="L788">    Counter&lt;String&gt; c2 = new ClassicCounter&lt;&gt;();</span>
<span class="nc" id="L789">    c2.incrementCount(&quot;p&quot;, 13);</span>
<span class="nc" id="L790">    c2.setCount(&quot;q&quot;, 12);</span>
<span class="nc" id="L791">    c2.setCount(&quot;w&quot;, 5);</span>
<span class="nc" id="L792">    c2.incrementCount(&quot;x&quot;, 7.5);</span>
    // System.out.println(getDistribution(c2).getCount(&quot;w&quot;) + &quot; should be 0.13333&quot;);

<span class="nc" id="L795">    ClassicCounter&lt;String&gt; c = new ClassicCounter&lt;&gt;();</span>

<span class="nc" id="L797">    final double p = 1000;</span>

<span class="nc" id="L799">    String UNK = &quot;!*UNKNOWN*!&quot;;</span>
<span class="nc" id="L800">    Set&lt;String&gt; s = Generics.newHashSet();</span>
<span class="nc" id="L801">    s.add(UNK);</span>

    // fill counter with roughly Zipfian distribution
    //    &quot;1&quot; : 1000
    //    &quot;2&quot; :  500
    //    &quot;3&quot; :  333
    //       ...
    //  &quot;UNK&quot; :   45
    //       ...
    //  &quot;666&quot; :    2
    //  &quot;667&quot; :    1
    //       ...
    // &quot;1000&quot; :    1
<span class="nc bnc" id="L814" title="All 2 branches missed.">    for (int rank = 1; rank &lt; 2000; rank++) {</span>
<span class="nc" id="L815">      String i = String.valueOf(rank);</span>
<span class="nc" id="L816">      c.setCount(i, Math.round(p / rank));</span>
<span class="nc" id="L817">      s.add(i);</span>
    }
<span class="nc bnc" id="L819" title="All 2 branches missed.">    for (int rank = 2000; rank &lt;= 4000; rank++) {</span>
<span class="nc" id="L820">      String i = String.valueOf(rank);</span>
<span class="nc" id="L821">      s.add(i);</span>
    }

<span class="nc" id="L824">    Distribution&lt;String&gt; n = getDistribution(c);</span>
<span class="nc" id="L825">    Distribution&lt;String&gt; prior = getUniformDistribution(s);</span>
<span class="nc" id="L826">    Distribution&lt;String&gt; dir1 = distributionWithDirichletPrior(c, prior, 4000);</span>
<span class="nc" id="L827">    Distribution&lt;String&gt; dir2 = dynamicCounterWithDirichletPrior(c, prior, 4000);</span>
    Distribution&lt;String&gt; add1;
    Distribution&lt;String&gt; gt;
    if (true) {
<span class="nc" id="L831">      add1 = laplaceSmoothedDistribution(c, 4000);</span>
<span class="nc" id="L832">      gt = goodTuringSmoothedCounter(c, 4000);</span>
    } else {
      c.setCount(UNK, 45);
      add1 = laplaceWithExplicitUnknown(c, 0.5, UNK);
      gt = goodTuringWithExplicitUnknown(c, UNK);
    }
<span class="nc" id="L838">    Distribution&lt;String&gt; sgt = simpleGoodTuring(c, 4000);</span>

<span class="nc" id="L840">    System.out.printf(&quot;%10s %10s %10s %10s %10s %10s %10s%n&quot;,</span>
                      &quot;Freq&quot;, &quot;Norm&quot;, &quot;Add1&quot;, &quot;Dir1&quot;, &quot;Dir2&quot;, &quot;GT&quot;, &quot;SGT&quot;);
<span class="nc" id="L842">    System.out.printf(&quot;%10s %10s %10s %10s %10s %10s %10s%n&quot;,</span>
                      &quot;----------&quot;, &quot;----------&quot;, &quot;----------&quot;, &quot;----------&quot;, &quot;----------&quot;, &quot;----------&quot;, &quot;----------&quot;);

<span class="nc bnc" id="L845" title="All 2 branches missed.">    for (int i = 1; i &lt; 5; i++) {</span>
<span class="nc" id="L846">      System.out.printf(&quot;%10d &quot;, Math.round(p / i));</span>
<span class="nc" id="L847">      String in = String.valueOf(i);</span>
<span class="nc" id="L848">      System.out.printf(&quot;%10.8f &quot;, n.probabilityOf(String.valueOf(in)));</span>
<span class="nc" id="L849">      System.out.printf(&quot;%10.8f &quot;, add1.probabilityOf(in));</span>
<span class="nc" id="L850">      System.out.printf(&quot;%10.8f &quot;, dir1.probabilityOf(in));</span>
<span class="nc" id="L851">      System.out.printf(&quot;%10.8f &quot;, dir2.probabilityOf(in));</span>
<span class="nc" id="L852">      System.out.printf(&quot;%10.8f &quot;, gt.probabilityOf(in));</span>
<span class="nc" id="L853">      System.out.printf(&quot;%10.8f &quot;, sgt.probabilityOf(in));</span>
<span class="nc" id="L854">      System.out.println();</span>
    }

<span class="nc" id="L857">    System.out.printf(&quot;%10s %10s %10s %10s %10s %10s %10s%n&quot;,</span>
                      &quot;----------&quot;, &quot;----------&quot;, &quot;----------&quot;, &quot;----------&quot;, &quot;----------&quot;, &quot;----------&quot;, &quot;----------&quot;);
<span class="nc" id="L859">    System.out.printf(&quot;%10d &quot;, 1);</span>
<span class="nc" id="L860">    String last = String.valueOf(1500);</span>
<span class="nc" id="L861">    System.out.printf(&quot;%10.8f &quot;, n.probabilityOf(last));</span>
<span class="nc" id="L862">    System.out.printf(&quot;%10.8f &quot;, add1.probabilityOf(last));</span>
<span class="nc" id="L863">    System.out.printf(&quot;%10.8f &quot;, dir1.probabilityOf(last));</span>
<span class="nc" id="L864">    System.out.printf(&quot;%10.8f &quot;, dir2.probabilityOf(last));</span>
<span class="nc" id="L865">    System.out.printf(&quot;%10.8f &quot;, gt.probabilityOf(last));</span>
<span class="nc" id="L866">    System.out.printf(&quot;%10.8f &quot;, sgt.probabilityOf(last));</span>
<span class="nc" id="L867">    System.out.println();</span>

<span class="nc" id="L869">    System.out.printf(&quot;%10s %10s %10s %10s %10s %10s %10s%n&quot;,</span>
                      &quot;----------&quot;, &quot;----------&quot;, &quot;----------&quot;, &quot;----------&quot;, &quot;----------&quot;, &quot;----------&quot;, &quot;----------&quot;);
<span class="nc" id="L871">    System.out.printf(&quot;%10s &quot;, &quot;UNK&quot;);</span>
<span class="nc" id="L872">    System.out.printf(&quot;%10.8f &quot;, n.probabilityOf(UNK));</span>
<span class="nc" id="L873">    System.out.printf(&quot;%10.8f &quot;, add1.probabilityOf(UNK));</span>
<span class="nc" id="L874">    System.out.printf(&quot;%10.8f &quot;, dir1.probabilityOf(UNK));</span>
<span class="nc" id="L875">    System.out.printf(&quot;%10.8f &quot;, dir2.probabilityOf(UNK));</span>
<span class="nc" id="L876">    System.out.printf(&quot;%10.8f &quot;, gt.probabilityOf(UNK));</span>
<span class="nc" id="L877">    System.out.printf(&quot;%10.8f &quot;, sgt.probabilityOf(UNK));</span>
<span class="nc" id="L878">    System.out.println();</span>

<span class="nc" id="L880">    System.out.printf(&quot;%10s %10s %10s %10s %10s %10s %10s%n&quot;,</span>
                      &quot;----------&quot;, &quot;----------&quot;, &quot;----------&quot;, &quot;----------&quot;, &quot;----------&quot;, &quot;----------&quot;, &quot;----------&quot;);
<span class="nc" id="L882">    System.out.printf(&quot;%10s &quot;, &quot;RESERVE&quot;);</span>
<span class="nc" id="L883">    System.out.printf(&quot;%10.8f &quot;, n.getReservedMass());</span>
<span class="nc" id="L884">    System.out.printf(&quot;%10.8f &quot;, add1.getReservedMass());</span>
<span class="nc" id="L885">    System.out.printf(&quot;%10.8f &quot;, dir1.getReservedMass());</span>
<span class="nc" id="L886">    System.out.printf(&quot;%10.8f &quot;, dir2.getReservedMass());</span>
<span class="nc" id="L887">    System.out.printf(&quot;%10.8f &quot;, gt.getReservedMass());</span>
<span class="nc" id="L888">    System.out.printf(&quot;%10.8f &quot;, sgt.getReservedMass());</span>
<span class="nc" id="L889">    System.out.println();</span>

<span class="nc" id="L891">    System.out.printf(&quot;%10s %10s %10s %10s %10s %10s %10s%n&quot;,</span>
                      &quot;----------&quot;, &quot;----------&quot;, &quot;----------&quot;, &quot;----------&quot;, &quot;----------&quot;, &quot;----------&quot;, &quot;----------&quot;);
<span class="nc" id="L893">    System.out.printf(&quot;%10s &quot;, &quot;Total&quot;);</span>
<span class="nc" id="L894">    System.out.printf(&quot;%10.8f &quot;, n.totalCount());</span>
<span class="nc" id="L895">    System.out.printf(&quot;%10.8f &quot;, add1.totalCount());</span>
<span class="nc" id="L896">    System.out.printf(&quot;%10.8f &quot;, dir1.totalCount());</span>
<span class="nc" id="L897">    System.out.printf(&quot;%10.8f &quot;, dir2.totalCount());</span>
<span class="nc" id="L898">    System.out.printf(&quot;%10.8f &quot;, gt.totalCount());</span>
<span class="nc" id="L899">    System.out.printf(&quot;%10.8f &quot;, sgt.totalCount());</span>
<span class="nc" id="L900">    System.out.println();</span>

<span class="nc" id="L902">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>