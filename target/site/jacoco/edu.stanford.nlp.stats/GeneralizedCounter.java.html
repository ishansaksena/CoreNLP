<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GeneralizedCounter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.stats</a> &gt; <span class="el_source">GeneralizedCounter.java</span></div><h1>GeneralizedCounter.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.stats;

import java.io.PrintWriter;
import java.io.Serializable;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import edu.stanford.nlp.util.ErasureUtils;
import edu.stanford.nlp.util.Generics;
import edu.stanford.nlp.util.MutableDouble;

/**
 * A class for keeping double counts of {@link List}s of a
 * prespecified length.  A depth &lt;i&gt;n&lt;/i&gt; GeneralizedCounter can be
 * thought of as a conditionalized count over &lt;i&gt;n&lt;/i&gt; classes of
 * objects, in a prespecified order.  Also offers a read-only view as
 * a Counter.  &lt;p&gt; This class is serializable but no guarantees are
 * made about compatibility version to version.
 *
 * &lt;p/&gt;
 * This is the worst class. Use TwoDimensionalCounter. If you need a third,
 * write ThreeDimensionalCounter, but don't use this.
 *
 * @author Roger Levy
 */
public class GeneralizedCounter&lt;K&gt; implements Serializable {

  private static final long serialVersionUID = 1;

<span class="nc" id="L35">  private static final Object[] zeroKey = new Object[0];</span>

<span class="nc" id="L37">  private Map&lt;K,Object&gt; map = Generics.newHashMap();</span>

  private int depth;
  private double total;


  /**
   * GeneralizedCounter must be constructed with a depth parameter
   */
<span class="nc" id="L46">  private GeneralizedCounter() {</span>
<span class="nc" id="L47">  }</span>

  /**
   * Constructs a new GeneralizedCounter of a specified depth
   *
   * @param depth the depth of the GeneralizedCounter
   */
<span class="nc" id="L54">  public GeneralizedCounter(int depth) {</span>
<span class="nc" id="L55">    this.depth = depth;</span>
<span class="nc" id="L56">  }</span>

  /**
   * Returns the set of entries in the GeneralizedCounter.
   * Here, each key is a read-only {@link
   * List} of size equal to the depth of the GeneralizedCounter, and
   * each value is a {@link Double}.  Each entry is a {@link java.util.Map.Entry} object,
   * but these objects
   * do not support the {@link java.util.Map.Entry#setValue} method; attempts to call
   * that method with result
   * in an {@link UnsupportedOperationException} being thrown.
   */
  public Set&lt;Map.Entry&lt;List&lt;K&gt;,Double&gt;&gt; entrySet() {
<span class="nc" id="L69">    return ErasureUtils.&lt;Set&lt;Map.Entry&lt;List&lt;K&gt;,Double&gt;&gt;&gt;uncheckedCast(entrySet(new HashSet&lt;&gt;(), zeroKey, true));</span>
  }

  /* this is (non-tail) recursive right now, haven't figured out a way
  * to speed it up */
  private Set&lt;Map.Entry&lt;Object,Double&gt;&gt; entrySet(Set&lt;Map.Entry&lt;Object,Double&gt;&gt; s, Object[] key, boolean useLists) {
<span class="nc bnc" id="L75" title="All 2 branches missed.">    if (depth == 1) {</span>
      //System.out.println(&quot;key is long enough to add to set&quot;);
<span class="nc" id="L77">      Set&lt;K&gt; keys = map.keySet();</span>
<span class="nc bnc" id="L78" title="All 2 branches missed.">      for (K finalKey: keys) {</span>
        // array doesn't escape
<span class="nc" id="L80">        K[] newKey = ErasureUtils.&lt;K&gt;mkTArray(Object.class,key.length + 1);</span>
<span class="nc bnc" id="L81" title="All 2 branches missed.">        if (key.length &gt; 0) {</span>
<span class="nc" id="L82">          System.arraycopy(key, 0, newKey, 0, key.length);</span>
        }
<span class="nc" id="L84">        newKey[key.length] = finalKey;</span>
<span class="nc" id="L85">        MutableDouble value = (MutableDouble) map.get(finalKey);</span>
<span class="nc" id="L86">        Double value1 = new Double(value.doubleValue());</span>
<span class="nc bnc" id="L87" title="All 2 branches missed.">        if (useLists) {</span>
<span class="nc" id="L88">          s.add(new Entry&lt;&gt;(Arrays.asList(newKey), value1));</span>
        } else {
<span class="nc" id="L90">          s.add(new Entry&lt;&gt;(newKey[0], value1));</span>
        }

<span class="nc" id="L93">      }</span>
<span class="nc" id="L94">    } else {</span>
<span class="nc" id="L95">      Set&lt;K&gt; keys = map.keySet();</span>
      //System.out.println(&quot;key length &quot; + key.length);
      //System.out.println(&quot;keyset level &quot; + depth + &quot; &quot; + keys);
<span class="nc bnc" id="L98" title="All 2 branches missed.">      for (K o: keys) {</span>
<span class="nc" id="L99">        Object[] newKey = new Object[key.length + 1];</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">        if (key.length &gt; 0) {</span>
<span class="nc" id="L101">          System.arraycopy(key, 0, newKey, 0, key.length);</span>
        }
<span class="nc" id="L103">        newKey[key.length] = o;</span>
        //System.out.println(&quot;level &quot; + key.length + &quot; current key &quot; + Arrays.asList(newKey));
<span class="nc" id="L105">        conditionalizeHelper(o).entrySet(s, newKey, true);</span>
<span class="nc" id="L106">      }</span>
    }
    //System.out.println(&quot;leaving key length &quot; + key.length);
<span class="nc" id="L109">    return s;</span>
  }

  /**
   * Returns a set of entries, where each key is a read-only {@link
   * List} of size one less than the depth of the GeneralizedCounter, and
   * each value is a {@link ClassicCounter}.  Each entry is a {@link java.util.Map.Entry} object, but these objects
   * do not support the {@link java.util.Map.Entry#setValue} method; attempts to call that method with result
   * in an {@link UnsupportedOperationException} being thrown.
   */
  public Set&lt;Map.Entry&lt;List&lt;K&gt;, ClassicCounter&lt;K&gt;&gt;&gt; lowestLevelCounterEntrySet() {
<span class="nc" id="L120">    return ErasureUtils.&lt;Set&lt;Map.Entry&lt;List&lt;K&gt;, ClassicCounter&lt;K&gt;&gt;&gt;&gt;uncheckedCast(lowestLevelCounterEntrySet(new HashSet&lt;&gt;(), zeroKey, true));</span>
  }

  /* this is (non-tail) recursive right now, haven't figured out a way
  * to speed it up */
  private Set&lt;Map.Entry&lt;Object, ClassicCounter&lt;K&gt;&gt;&gt; lowestLevelCounterEntrySet(Set&lt;Map.Entry&lt;Object, ClassicCounter&lt;K&gt;&gt;&gt; s, Object[] key, boolean useLists) {
<span class="nc" id="L126">    Set&lt;K&gt; keys = map.keySet();</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">    if (depth == 2) {</span>
      // add these counters to set
<span class="nc bnc" id="L129" title="All 2 branches missed.">      for (K finalKey: keys) {</span>
<span class="nc" id="L130">        K[] newKey = ErasureUtils.&lt;K&gt;mkTArray(Object.class,key.length + 1);</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">        if (key.length &gt; 0) {</span>
<span class="nc" id="L132">          System.arraycopy(key, 0, newKey, 0, key.length);</span>
        }
<span class="nc" id="L134">        newKey[key.length] = finalKey;</span>
<span class="nc" id="L135">        ClassicCounter&lt;K&gt; c = conditionalizeHelper(finalKey).oneDimensionalCounterView();</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">        if (useLists) {</span>
<span class="nc" id="L137">          s.add(new Entry&lt;&gt;(Arrays.asList(newKey), c));</span>
        } else {
<span class="nc" id="L139">          s.add(new Entry&lt;&gt;(newKey[0], c));</span>
        }
<span class="nc" id="L141">      }</span>
    } else {
      //System.out.println(&quot;key length &quot; + key.length);
      //System.out.println(&quot;keyset level &quot; + depth + &quot; &quot; + keys);
<span class="nc bnc" id="L145" title="All 2 branches missed.">      for (K o: keys) {</span>
<span class="nc" id="L146">        Object[] newKey = new Object[key.length + 1];</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">        if (key.length &gt; 0) {</span>
<span class="nc" id="L148">          System.arraycopy(key, 0, newKey, 0, key.length);</span>
        }
<span class="nc" id="L150">        newKey[key.length] = o;</span>
        //System.out.println(&quot;level &quot; + key.length + &quot; current key &quot; + Arrays.asList(newKey));
<span class="nc" id="L152">        conditionalizeHelper(o).lowestLevelCounterEntrySet(s, newKey, true);</span>
<span class="nc" id="L153">      }</span>
    }
    //System.out.println(&quot;leaving key length &quot; + key.length);
<span class="nc" id="L156">    return s;</span>
  }

  private static class Entry&lt;K, V&gt; implements Map.Entry&lt;K, V&gt; {
    private K key;
    private V value;

<span class="nc" id="L163">    Entry(K key, V value) {</span>
<span class="nc" id="L164">      this.key = key;</span>
<span class="nc" id="L165">      this.value = value;</span>
<span class="nc" id="L166">    }</span>

    public K getKey() {
<span class="nc" id="L169">      return key;</span>
    }

    public V getValue() {
<span class="nc" id="L173">      return value;</span>
    }

    public V setValue(V value) {
<span class="nc" id="L177">      throw new UnsupportedOperationException();</span>
    }

    @Override
    public boolean equals(Object o) {
<span class="nc bnc" id="L182" title="All 2 branches missed.">      if (this == o) {</span>
<span class="nc" id="L183">        return true;</span>
      }
<span class="nc bnc" id="L185" title="All 2 branches missed.">      if (!(o instanceof Entry)) {</span>
<span class="nc" id="L186">        return false;</span>
      }
<span class="nc" id="L188">      Entry&lt;K,V&gt; e = ErasureUtils.&lt;Entry&lt;K,V&gt;&gt;uncheckedCast(o);</span>

<span class="nc" id="L190">      Object key1 = e.getKey();</span>
<span class="nc bnc" id="L191" title="All 4 branches missed.">      if (!(key != null &amp;&amp; key.equals(key1))) {</span>
<span class="nc" id="L192">        return false;</span>
      }

<span class="nc" id="L195">      Object value1 = e.getValue();</span>
<span class="nc bnc" id="L196" title="All 4 branches missed.">      if (!(value != null &amp;&amp; value.equals(value1))) {</span>
<span class="nc" id="L197">        return false;</span>
      }

<span class="nc" id="L200">      return true;</span>
    }

    @Override
    public int hashCode() {
<span class="nc bnc" id="L205" title="All 4 branches missed.">      if (key == null || value == null) {</span>
<span class="nc" id="L206">        return 0;</span>
      }
<span class="nc" id="L208">      return key.hashCode() ^ value.hashCode();</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L213">      return key.toString() + &quot;=&quot; + value.toString();</span>
    }

  } // end static class Entry


  /**
   * returns the total count of objects in the GeneralizedCounter.
   */
  public double totalCount() {
<span class="nc bnc" id="L223" title="All 2 branches missed.">    if (depth() == 1) {</span>
<span class="nc" id="L224">      return total; // I think this one is always OK.  Not very principled here, though.</span>
    } else {
<span class="nc" id="L226">      double result = 0.0;</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">      for (K o: topLevelKeySet()) {</span>
<span class="nc" id="L228">        result += conditionalizeOnce(o).totalCount();</span>
<span class="nc" id="L229">      }</span>
<span class="nc" id="L230">      return result;</span>
    }
  }

  /**
   * Returns the set of elements that occur in the 0th position of a
   * {@link List} key in the GeneralizedCounter.
   *
   * @see #conditionalize(List)
   * @see #getCount
   */
  public Set&lt;K&gt; topLevelKeySet() {
<span class="nc" id="L242">    return map.keySet();</span>
  }

  /**
   * Returns the set of keys, as read-only {@link List}s of size
   * equal to the depth of the GeneralizedCounter.
   */
  public Set&lt;List&lt;K&gt;&gt; keySet() {
<span class="nc" id="L250">    return ErasureUtils.&lt;Set&lt;List&lt;K&gt;&gt;&gt;uncheckedCast(keySet(Generics.newHashSet(), zeroKey, true));</span>
  }

  /* this is (non-tail) recursive right now, haven't figured out a way
  * to speed it up */
  private Set&lt;Object&gt; keySet(Set&lt;Object&gt; s, Object[] key, boolean useList) {
<span class="nc bnc" id="L256" title="All 2 branches missed.">    if (depth == 1) {</span>
      //System.out.println(&quot;key is long enough to add to set&quot;);
<span class="nc" id="L258">      Set&lt;K&gt; keys = map.keySet();</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">      for (Object oldKey: keys) {</span>
<span class="nc" id="L260">        Object[] newKey = new Object[key.length + 1];</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">        if (key.length &gt; 0) {</span>
<span class="nc" id="L262">          System.arraycopy(key, 0, newKey, 0, key.length);</span>
        }
<span class="nc" id="L264">        newKey[key.length] = oldKey;</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">        if (useList) {</span>
<span class="nc" id="L266">          s.add(Arrays.asList(newKey));</span>
        } else {
<span class="nc" id="L268">          s.add(newKey[0]);</span>
        }
<span class="nc" id="L270">      }</span>
<span class="nc" id="L271">    } else {</span>
<span class="nc" id="L272">      Set&lt;K&gt; keys = map.keySet();</span>
      //System.out.println(&quot;key length &quot; + key.length);
      //System.out.println(&quot;keyset level &quot; + depth + &quot; &quot; + keys);
<span class="nc bnc" id="L275" title="All 2 branches missed.">      for (K o: keys) {</span>
<span class="nc" id="L276">        Object[] newKey = new Object[key.length + 1];</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">        if (key.length &gt; 0) {</span>
<span class="nc" id="L278">          System.arraycopy(key, 0, newKey, 0, key.length);</span>
        }
<span class="nc" id="L280">        newKey[key.length] = o;</span>
        //System.out.println(&quot;level &quot; + key.length + &quot; current key &quot; + Arrays.asList(newKey));
<span class="nc" id="L282">        conditionalizeHelper(o).keySet(s, newKey, true);</span>
<span class="nc" id="L283">      }</span>
    }
    //System.out.println(&quot;leaving key length &quot; + key.length);
<span class="nc" id="L286">    return s;</span>
  }

  /**
   * Returns the depth of the GeneralizedCounter (i.e., the dimension
   * of the distribution).
   */
  public int depth() {
<span class="nc" id="L294">    return depth;</span>
  }

  /**
   * Returns true if nothing has a count.
   */
  public boolean isEmpty() {
<span class="nc" id="L301">    return map.isEmpty();</span>
  }


  /**
   * Equivalent to &lt;code&gt;{@link #getCounts}({o})&lt;/code&gt;; works only
   * for depth 1 GeneralizedCounters
   */
  public double getCount(Object o) {
<span class="nc bnc" id="L310" title="All 2 branches missed.">    if (depth &gt; 1) {</span>
<span class="nc" id="L311">      wrongDepth();</span>
    }
<span class="nc" id="L313">    Number count = (Number) map.get(o);</span>
<span class="nc bnc" id="L314" title="All 2 branches missed.">    if (count != null) {</span>
<span class="nc" id="L315">      return count.doubleValue();</span>
    } else {
<span class="nc" id="L317">      return 0.0;</span>
    }
  }

  /**
   * A convenience method equivalent to &lt;code&gt;{@link
   * #getCounts}({o1,o2})&lt;/code&gt;; works only for depth 2
   * GeneralizedCounters
   */
  public double getCount(K o1, K o2) {
<span class="nc bnc" id="L327" title="All 2 branches missed.">    if (depth != 2) {</span>
<span class="nc" id="L328">      wrongDepth();</span>
    }
<span class="nc" id="L330">    GeneralizedCounter&lt;K&gt; gc1 = ErasureUtils.&lt;GeneralizedCounter&lt;K&gt;&gt;uncheckedCast(map.get(o1));</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">    if (gc1 == null) {</span>
<span class="nc" id="L332">      return 0.0;</span>
    } else {
<span class="nc" id="L334">      return gc1.getCount(o2);</span>
    }
  }

  /**
   * A convenience method equivalent to &lt;code&gt;{@link
   * #getCounts}({o1,o2,o3})&lt;/code&gt;; works only for depth 3
   * GeneralizedCounters
   */
  public double getCount(K o1, K o2, K o3) {
<span class="nc bnc" id="L344" title="All 2 branches missed.">    if (depth != 3) {</span>
<span class="nc" id="L345">      wrongDepth();</span>
    }
<span class="nc" id="L347">    GeneralizedCounter&lt;K&gt; gc1 = ErasureUtils.&lt;GeneralizedCounter&lt;K&gt;&gt;uncheckedCast(map.get(o1));</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">    if (gc1 == null) {</span>
<span class="nc" id="L349">      return 0.0;</span>
    } else {
<span class="nc" id="L351">      return gc1.getCount(o2, o3);</span>
    }
  }


  /**
   * returns a {@code double[]} array of length
   * {@code depth+1}, containing the conditional counts on a
   * {@code depth}-length list given each level of conditional
   * distribution from 0 to {@code depth}.
   */
  public double[] getCounts(List&lt;K&gt; l) {
<span class="nc bnc" id="L363" title="All 2 branches missed.">    if (l.size() != depth) {</span>
<span class="nc" id="L364">      wrongDepth(); //throws exception</span>
    }

<span class="nc" id="L367">    double[] counts = new double[depth + 1];</span>

<span class="nc" id="L369">    GeneralizedCounter&lt;K&gt; next = this;</span>
<span class="nc" id="L370">    counts[0] = next.totalCount();</span>
<span class="nc" id="L371">    Iterator&lt;K&gt; i = l.iterator();</span>
<span class="nc" id="L372">    int j = 1;</span>
<span class="nc" id="L373">    K o = i.next();</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">    while (i.hasNext()) {</span>
<span class="nc" id="L375">      next = next.conditionalizeHelper(o);</span>
<span class="nc" id="L376">      counts[j] = next.totalCount();</span>
<span class="nc" id="L377">      o = i.next();</span>
<span class="nc" id="L378">      j++;</span>
    }
<span class="nc" id="L380">    counts[depth] = next.getCount(o);</span>

<span class="nc" id="L382">    return counts;</span>
  }

  /* haven't decided about access for this one yet */
  private GeneralizedCounter&lt;K&gt; conditionalizeHelper(K o) {
<span class="nc bnc" id="L387" title="All 2 branches missed.">    if (depth &gt; 1) {</span>
<span class="nc" id="L388">      GeneralizedCounter&lt;K&gt; next = ErasureUtils.&lt;GeneralizedCounter&lt;K&gt;&gt;uncheckedCast(map.get(o));</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">      if (next == null) // adds a new GeneralizedCounter if needed</span>
      {
<span class="nc" id="L391">        map.put(o, (next = new GeneralizedCounter&lt;&gt;(depth - 1)));</span>
      }
<span class="nc" id="L393">      return next;</span>
    } else {
<span class="nc" id="L395">      throw new RuntimeException(&quot;Error -- can't conditionalize a distribution of depth 1&quot;);</span>
    }
  }

  /**
   * returns a GeneralizedCounter conditioned on the objects in the
   * {@link List} argument. The length of the argument {@link List}
   * must be less than the depth of the GeneralizedCounter.
   */
  public GeneralizedCounter&lt;K&gt; conditionalize(List&lt;K&gt; l) {
<span class="nc" id="L405">    int n = l.size();</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">    if (n &gt;= depth()) {</span>
<span class="nc" id="L407">      throw new RuntimeException(&quot;Error -- attempted to conditionalize a GeneralizedCounter of depth &quot; + depth() + &quot; on a vector of length &quot; + n);</span>
    } else {
<span class="nc" id="L409">      GeneralizedCounter&lt;K&gt; next = this;</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">      for (K o: l) {</span>
<span class="nc" id="L411">        next = next.conditionalizeHelper(o);</span>
<span class="nc" id="L412">      }</span>
<span class="nc" id="L413">      return next;</span>
    }
  }

  /**
   * Returns a GeneralizedCounter conditioned on the given top level object.
   * This is just shorthand (and more efficient) for &lt;code&gt;conditionalize(new Object[] { o })&lt;/code&gt;.
   */
  public GeneralizedCounter&lt;K&gt; conditionalizeOnce(K o) {
<span class="nc bnc" id="L422" title="All 2 branches missed.">    if (depth() &lt; 1) {</span>
<span class="nc" id="L423">      throw new RuntimeException(&quot;Error -- attempted to conditionalize a GeneralizedCounter of depth &quot; + depth());</span>
    } else {
<span class="nc" id="L425">      return conditionalizeHelper(o);</span>
    }
  }

  /**
   * equivalent to incrementCount(l,o,1.0).
   */
  public void incrementCount(List&lt;K&gt; l, K o) {
<span class="nc" id="L433">    incrementCount(l, o, 1.0);</span>
<span class="nc" id="L434">  }</span>

  /**
   * same as incrementCount(List, double) but as if Object o were at the end of the list
   */
  public void incrementCount(List&lt;K&gt; l, K o, double count) {
<span class="nc bnc" id="L440" title="All 2 branches missed.">    if (l.size() != depth - 1) {</span>
<span class="nc" id="L441">      wrongDepth();</span>
    }

<span class="nc" id="L444">    GeneralizedCounter&lt;K&gt; next = this;</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">    for (K o2: l) {</span>
<span class="nc" id="L446">      next.addToTotal(count);</span>
<span class="nc" id="L447">      next = next.conditionalizeHelper(o2);</span>
<span class="nc" id="L448">    }</span>
<span class="nc" id="L449">    next.addToTotal(count);</span>

<span class="nc" id="L451">    next.incrementCount1D(o, count);</span>
<span class="nc" id="L452">  }</span>


  /**
   * Equivalent to incrementCount(l, 1.0).
   */
  public void incrementCount(List&lt;K&gt; l) {
<span class="nc" id="L459">    incrementCount(l, 1.0);</span>
<span class="nc" id="L460">  }</span>

  /**
   * adds to count for the {@link #depth()}-dimensional key &lt;code&gt;l&lt;/code&gt;.
   */
  public void incrementCount(List&lt;K&gt; l, double count) {
<span class="nc bnc" id="L466" title="All 2 branches missed.">    if (l.size() != depth) {</span>
<span class="nc" id="L467">      wrongDepth(); //throws exception</span>
    }

<span class="nc" id="L470">    GeneralizedCounter&lt;K&gt; next = this;</span>
<span class="nc" id="L471">    Iterator&lt;K&gt; i = l.iterator();</span>
<span class="nc" id="L472">    K o = i.next();</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">    while (i.hasNext()) {</span>
<span class="nc" id="L474">      next.addToTotal(count);</span>
<span class="nc" id="L475">      next = next.conditionalizeHelper(o);</span>
<span class="nc" id="L476">      o = i.next();</span>
    }
<span class="nc" id="L478">    next.incrementCount1D(o, count);</span>
<span class="nc" id="L479">  }</span>

  /**
   * Equivalent to incrementCount2D(first,second,1.0).
   */
  public void incrementCount2D(K first, K second) {
<span class="nc" id="L485">    incrementCount2D(first, second, 1.0);</span>
<span class="nc" id="L486">  }</span>

  /**
   * Equivalent to incrementCount( new Object[] { first, second }, count ).
   * Makes the special case easier, and also more efficient.
   */
  public void incrementCount2D(K first, K second, double count) {
<span class="nc bnc" id="L493" title="All 2 branches missed.">    if (depth != 2) {</span>
<span class="nc" id="L494">      wrongDepth(); //throws exception</span>
    }

<span class="nc" id="L497">    this.addToTotal(count);</span>
<span class="nc" id="L498">    GeneralizedCounter&lt;K&gt; next = this.conditionalizeHelper(first);</span>
<span class="nc" id="L499">    next.incrementCount1D(second, count);</span>
<span class="nc" id="L500">  }</span>

  /**
   * Equivalent to incrementCount3D(first,second,1.0).
   */
  public void incrementCount3D(K first, K second, K third) {
<span class="nc" id="L506">    incrementCount3D(first, second, third, 1.0);</span>
<span class="nc" id="L507">  }</span>

  /**
   * Equivalent to incrementCount( new Object[] { first, second, third }, count ).
   * Makes the special case easier, and also more efficient.
   */
  public void incrementCount3D(K first, K second, K third, double count) {
<span class="nc bnc" id="L514" title="All 2 branches missed.">    if (depth != 3) {</span>
<span class="nc" id="L515">      wrongDepth(); //throws exception</span>
    }

<span class="nc" id="L518">    this.addToTotal(count);</span>
<span class="nc" id="L519">    GeneralizedCounter&lt;K&gt; next = this.conditionalizeHelper(first);</span>
<span class="nc" id="L520">    next.incrementCount2D(second, third, count);</span>
<span class="nc" id="L521">  }</span>

  private void addToTotal(double d) {
<span class="nc" id="L524">    total += d;</span>
<span class="nc" id="L525">  }</span>

  // for more efficient memory usage
<span class="nc" id="L528">  private transient MutableDouble tempMDouble = null;</span>


  /**
   * Equivalent to incrementCount1D(o, 1.0).
   */
  public void incrementCount1D(K o) {
<span class="nc" id="L535">    incrementCount1D(o, 1.0);</span>
<span class="nc" id="L536">  }</span>

  /**
   * Equivalent to &lt;code&gt;{@link #incrementCount}({o}, count)&lt;/code&gt;;
   * only works for a depth 1 GeneralizedCounter.
   */
  public void incrementCount1D(K o, double count) {
<span class="nc bnc" id="L543" title="All 2 branches missed.">    if (depth &gt; 1) {</span>
<span class="nc" id="L544">      wrongDepth();</span>
    }

<span class="nc" id="L547">    addToTotal(count);</span>

<span class="nc bnc" id="L549" title="All 2 branches missed.">    if (tempMDouble == null) {</span>
<span class="nc" id="L550">      tempMDouble = new MutableDouble();</span>
    }
<span class="nc" id="L552">    tempMDouble.set(count);</span>
<span class="nc" id="L553">    MutableDouble oldMDouble = (MutableDouble) map.put(o, tempMDouble);</span>

<span class="nc bnc" id="L555" title="All 2 branches missed.">    if (oldMDouble != null) {</span>
<span class="nc" id="L556">      tempMDouble.set(count + oldMDouble.doubleValue());</span>
    }

<span class="nc" id="L559">    tempMDouble = oldMDouble;</span>

<span class="nc" id="L561">  }</span>

  /**
   * Like {@link ClassicCounter}, this currently returns true if the count is
   * explicitly 0.0 for something
   */
  public boolean containsKey(List&lt;K&gt; key) {
    //     if(! (key instanceof Object[]))
    //       return false;
    //    Object[] o = (Object[]) key;
<span class="nc" id="L571">    GeneralizedCounter&lt;K&gt; next = this;</span>
<span class="nc bnc" id="L572" title="All 2 branches missed.">    for (int i=0; i&lt;key.size()-1; i++) {</span>
<span class="nc" id="L573">      next = next.conditionalizeHelper(key.get(i));</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">      if (next==null) return false;</span>
    }
<span class="nc" id="L576">    return next.map.containsKey(key.get(key.size()-1));</span>
  }

  public GeneralizedCounter&lt;K&gt; reverseKeys() {
<span class="nc" id="L580">    GeneralizedCounter&lt;K&gt; result = new GeneralizedCounter&lt;&gt;();</span>
<span class="nc" id="L581">    Set&lt;Map.Entry&lt;List&lt;K&gt;,Double&gt;&gt; entries = entrySet();</span>
<span class="nc bnc" id="L582" title="All 2 branches missed.">    for (Map.Entry&lt;List&lt;K&gt;,Double&gt; entry: entries) {</span>
<span class="nc" id="L583">      List&lt;K&gt; list = entry.getKey();</span>
<span class="nc" id="L584">      double count = entry.getValue();</span>
<span class="nc" id="L585">      Collections.reverse(list);</span>
<span class="nc" id="L586">      result.incrementCount(list, count);</span>
<span class="nc" id="L587">    }</span>
<span class="nc" id="L588">    return result;</span>
  }


  private void wrongDepth() {
<span class="nc" id="L593">    throw new RuntimeException(&quot;Error -- attempt to operate with key of wrong length. depth=&quot; + depth);</span>
  }


  /**
   * Returns a read-only synchronous view (not a snapshot) of
   * &lt;code&gt;this&lt;/code&gt; as a {@link ClassicCounter}.  Any calls to
   * count-changing or entry-removing operations will result in an
   * {@link UnsupportedOperationException}.  At some point in the
   * future, this view may gain limited writable functionality.
   */
  public ClassicCounter&lt;List&lt;K&gt;&gt; counterView() {
<span class="nc" id="L605">    return new CounterView();</span>
  }

<span class="nc" id="L608">  private class CounterView extends ClassicCounter&lt;List&lt;K&gt;&gt; {</span>

    /**
     *
     */
    private static final long serialVersionUID = -1241712543674668918L;

    @Override
    public double incrementCount(List&lt;K&gt; o, double count) {
<span class="nc" id="L617">      throw new UnsupportedOperationException();</span>
    }

    @Override
    public void setCount(List&lt;K&gt; o, double count) {
<span class="nc" id="L622">      throw new UnsupportedOperationException();</span>
    }

    @Override
    public double totalCount() {
<span class="nc" id="L627">      return GeneralizedCounter.this.totalCount();</span>
    }

    @Override
    public double getCount(Object o) {
<span class="nc" id="L632">      List&lt;K&gt; l = (List&lt;K&gt;)o;</span>
<span class="nc bnc" id="L633" title="All 2 branches missed.">      if (l.size() != depth) {</span>
<span class="nc" id="L634">        return 0.0;</span>
      } else {
<span class="nc" id="L636">        return GeneralizedCounter.this.getCounts(l)[depth];</span>
      }
    }

    @Override
    public int size() {
<span class="nc" id="L642">      return GeneralizedCounter.this.map.size();</span>
    }

    @Override
    public Set&lt;List&lt;K&gt;&gt; keySet() {
<span class="nc" id="L647">      return GeneralizedCounter.this.keySet();</span>
    }

    @Override
    public double remove(List&lt;K&gt; o) {
<span class="nc" id="L652">      throw new UnsupportedOperationException();</span>
    }

    @Override
    public boolean containsKey(List&lt;K&gt; key) {
<span class="nc" id="L657">      return GeneralizedCounter.this.containsKey(key);</span>
    }

    @Override
    public void clear() {
<span class="nc" id="L662">      throw new UnsupportedOperationException();</span>
    }

    @Override
    public boolean isEmpty() {
<span class="nc" id="L667">      return GeneralizedCounter.this.isEmpty();</span>
    }

    @Override
    public Set&lt;Map.Entry&lt;List&lt;K&gt;, Double&gt;&gt; entrySet() {
<span class="nc" id="L672">      return GeneralizedCounter.this.entrySet();</span>
    }

    @Override
    public boolean equals(Object o) {
<span class="nc bnc" id="L677" title="All 2 branches missed.">      if (o == this) {</span>
<span class="nc" id="L678">        return true;</span>
      }
      //return false;
<span class="nc bnc" id="L681" title="All 2 branches missed.">      if (!(o instanceof ClassicCounter)) {</span>
<span class="nc" id="L682">        return false;</span>
      } else {
        // System.out.println(&quot;it's a counter!&quot;);
        // Set e = entrySet();
        // Set e1 = ((Counter) o).entrySet();
        // System.out.println(e + &quot;\n&quot; + e1);
<span class="nc" id="L688">        return entrySet().equals(((ClassicCounter&lt;?&gt;) o).entrySet());</span>
      }
    }

    @Override
    public int hashCode() {
<span class="nc" id="L694">      int total = 17;</span>
<span class="nc bnc" id="L695" title="All 2 branches missed.">      for (Object o: entrySet()) {</span>
<span class="nc" id="L696">        total = 37 * total + o.hashCode();</span>
<span class="nc" id="L697">      }</span>
<span class="nc" id="L698">      return total;</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L703">      StringBuffer sb = new StringBuffer(&quot;{&quot;);</span>
<span class="nc bnc" id="L704" title="All 2 branches missed.">      for (Iterator&lt;Map.Entry&lt;List&lt;K&gt;, Double&gt;&gt; i = entrySet().iterator(); i.hasNext();) {</span>
<span class="nc" id="L705">        Map.Entry&lt;List&lt;K&gt;, Double&gt; e = i.next();</span>
<span class="nc" id="L706">        sb.append(e.toString());</span>
<span class="nc bnc" id="L707" title="All 2 branches missed.">        if (i.hasNext()) {</span>
<span class="nc" id="L708">          sb.append(&quot;,&quot;);</span>
        }
<span class="nc" id="L710">      }</span>
<span class="nc" id="L711">      sb.append(&quot;}&quot;);</span>
<span class="nc" id="L712">      return sb.toString();</span>
    }

  } // end class CounterView


  /**
   * Returns a read-only synchronous view (not a snapshot) of
   * &lt;code&gt;this&lt;/code&gt; as a {@link ClassicCounter}.  Works only with one-dimensional
   * GeneralizedCounters.  Exactly like {@link #counterView}, except
   * that {@link #getCount} operates on primitive objects of the counter instead
   * of singleton lists.  Any calls to
   * count-changing or entry-removing operations will result in an
   * {@link UnsupportedOperationException}.  At some point in the
   * future, this view may gain limited writable functionality.
   */
  public ClassicCounter&lt;K&gt; oneDimensionalCounterView() {
<span class="nc bnc" id="L729" title="All 2 branches missed.">    if (depth != 1) {</span>
<span class="nc" id="L730">      throw new UnsupportedOperationException();</span>
    }
<span class="nc" id="L732">    return new OneDimensionalCounterView();</span>
  }

<span class="nc" id="L735">  private class OneDimensionalCounterView extends ClassicCounter&lt;K&gt; {</span>

    /**
     *
     */
    private static final long serialVersionUID = 5628505169749516972L;

    @Override
    public double incrementCount(K o, double count) {
<span class="nc" id="L744">      throw new UnsupportedOperationException();</span>
    }

    @Override
    public void setCount(K o, double count) {
<span class="nc" id="L749">      throw new UnsupportedOperationException();</span>
    }

    @Override
    public double totalCount() {
<span class="nc" id="L754">      return GeneralizedCounter.this.totalCount();</span>
    }

    @Override
    public double getCount(Object o) {
<span class="nc" id="L759">      return GeneralizedCounter.this.getCount(o);</span>
    }

    @Override
    public int size() {
<span class="nc" id="L764">      return GeneralizedCounter.this.map.size();</span>
    }

    @Override
    public Set&lt;K&gt; keySet() {
<span class="nc" id="L769">      return ErasureUtils.&lt;Set&lt;K&gt;&gt;uncheckedCast(GeneralizedCounter.this.keySet(Generics.newHashSet(), zeroKey, false));</span>
    }

    @Override
    public double remove(Object o) {
<span class="nc" id="L774">      throw new UnsupportedOperationException();</span>
    }

    @Override
    public boolean containsKey(Object key) {
<span class="nc" id="L779">      return GeneralizedCounter.this.map.containsKey(key);</span>
    }

    @Override
    public void clear() {
<span class="nc" id="L784">      throw new UnsupportedOperationException();</span>
    }

    @Override
    public boolean isEmpty() {
<span class="nc" id="L789">      return GeneralizedCounter.this.isEmpty();</span>
    }

    @Override
    public Set&lt;Map.Entry&lt;K, Double&gt;&gt; entrySet() {
<span class="nc" id="L794">      return ErasureUtils.&lt;Set&lt;Map.Entry&lt;K, Double&gt;&gt;&gt;uncheckedCast(GeneralizedCounter.this.entrySet(new HashSet&lt;&gt;(), zeroKey, false));</span>
    }

    @Override
    public boolean equals(Object o) {
<span class="nc bnc" id="L799" title="All 2 branches missed.">      if (o == this) {</span>
<span class="nc" id="L800">        return true;</span>
      }
      //return false;
<span class="nc bnc" id="L803" title="All 2 branches missed.">      if (!(o instanceof ClassicCounter)) {</span>
<span class="nc" id="L804">        return false;</span>
      } else {
        // System.out.println(&quot;it's a counter!&quot;);
        // Set e = entrySet();
        // Set e1 = ((Counter) o).map.entrySet();
        // System.out.println(e + &quot;\n&quot; + e1);
<span class="nc" id="L810">        return entrySet().equals(((ClassicCounter&lt;?&gt;) o).entrySet());</span>
      }
    }

    @Override
    public int hashCode() {
<span class="nc" id="L816">      int total = 17;</span>
<span class="nc bnc" id="L817" title="All 2 branches missed.">      for (Object o: entrySet()) {</span>
<span class="nc" id="L818">        total = 37 * total + o.hashCode();</span>
<span class="nc" id="L819">      }</span>
<span class="nc" id="L820">      return total;</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L825">      StringBuilder sb = new StringBuilder(&quot;{&quot;);</span>
<span class="nc bnc" id="L826" title="All 2 branches missed.">      for (Iterator&lt;Map.Entry&lt;K, Double&gt;&gt; i = entrySet().iterator(); i.hasNext();) {</span>
<span class="nc" id="L827">        Map.Entry&lt;K, Double&gt; e = i.next();</span>
<span class="nc" id="L828">        sb.append(e.toString());</span>
<span class="nc bnc" id="L829" title="All 2 branches missed.">        if (i.hasNext()) {</span>
<span class="nc" id="L830">          sb.append(&quot;,&quot;);</span>
        }
<span class="nc" id="L832">      }</span>
<span class="nc" id="L833">      sb.append(&quot;}&quot;);</span>
<span class="nc" id="L834">      return sb.toString();</span>
    }

  } // end class OneDimensionalCounterView


  @Override
  public String toString() {
<span class="nc" id="L842">    return map.toString();</span>
  }

  public String toString(String param) {
<span class="nc bnc" id="L846" title="All 10 branches missed.">    switch (param) {</span>
      case &quot;contingency&quot;: {
<span class="nc" id="L848">        StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L849" title="All 2 branches missed.">        for (K obj : ErasureUtils.sortedIfPossible(topLevelKeySet())) {</span>
<span class="nc" id="L850">          sb.append(obj);</span>
<span class="nc" id="L851">          sb.append(&quot; = &quot;);</span>
<span class="nc" id="L852">          GeneralizedCounter&lt;K&gt; gc = conditionalizeOnce(obj);</span>
<span class="nc" id="L853">          sb.append(gc);</span>
<span class="nc" id="L854">          sb.append(&quot;\n&quot;);</span>
<span class="nc" id="L855">        }</span>
<span class="nc" id="L856">        return sb.toString();</span>
      }
      case &quot;sorted&quot;: {
<span class="nc" id="L859">        StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L860">        sb.append(&quot;{\n&quot;);</span>
<span class="nc bnc" id="L861" title="All 2 branches missed.">        for (K obj : ErasureUtils.sortedIfPossible(topLevelKeySet())) {</span>
<span class="nc" id="L862">          sb.append(obj);</span>
<span class="nc" id="L863">          sb.append(&quot; = &quot;);</span>
<span class="nc" id="L864">          GeneralizedCounter&lt;K&gt; gc = conditionalizeOnce(obj);</span>
<span class="nc" id="L865">          sb.append(gc);</span>
<span class="nc" id="L866">          sb.append(&quot;\n&quot;);</span>
<span class="nc" id="L867">        }</span>
<span class="nc" id="L868">        sb.append(&quot;}\n&quot;);</span>
<span class="nc" id="L869">        return sb.toString();</span>
      }
      default:
<span class="nc" id="L872">        return toString();</span>
    }
  }


  /**
   * for testing purposes only
   */
  public static void main(String[] args) {

<span class="nc" id="L882">    Object[] a1 = new Object[]{&quot;a&quot;, &quot;b&quot;};</span>
<span class="nc" id="L883">    Object[] a2 = new Object[]{&quot;a&quot;, &quot;b&quot;};</span>

<span class="nc" id="L885">    System.out.println(Arrays.equals(a1, a2));</span>


<span class="nc" id="L888">    GeneralizedCounter&lt;String&gt; gc = new GeneralizedCounter&lt;&gt;(3);</span>
<span class="nc" id="L889">    gc.incrementCount(Arrays.asList(new String[]{&quot;a&quot;, &quot;j&quot;, &quot;x&quot;}), 3.0);</span>
<span class="nc" id="L890">    gc.incrementCount(Arrays.asList(new String[]{&quot;a&quot;, &quot;l&quot;, &quot;x&quot;}), 3.0);</span>
<span class="nc" id="L891">    gc.incrementCount(Arrays.asList(new String[]{&quot;b&quot;, &quot;k&quot;, &quot;y&quot;}), 3.0);</span>
<span class="nc" id="L892">    gc.incrementCount(Arrays.asList(new String[]{&quot;b&quot;, &quot;k&quot;, &quot;z&quot;}), 3.0);</span>

<span class="nc" id="L894">    System.out.println(&quot;incremented counts.&quot;);</span>

<span class="nc" id="L896">    System.out.println(gc.dumpKeys());</span>

<span class="nc" id="L898">    System.out.println(&quot;string representation of generalized counter:&quot;);</span>
<span class="nc" id="L899">    System.out.println(gc.toString());</span>


<span class="nc" id="L902">    gc.printKeySet();</span>

<span class="nc" id="L904">    System.out.println(&quot;entry set:\n&quot; + gc.entrySet());</span>


<span class="nc" id="L907">    arrayPrintDouble(gc.getCounts(Arrays.asList(new String[]{&quot;a&quot;, &quot;j&quot;, &quot;x&quot;})));</span>
<span class="nc" id="L908">    arrayPrintDouble(gc.getCounts(Arrays.asList(new String[]{&quot;a&quot;, &quot;j&quot;, &quot;z&quot;})));</span>
<span class="nc" id="L909">    arrayPrintDouble(gc.getCounts(Arrays.asList(new String[]{&quot;b&quot;, &quot;k&quot;, &quot;w&quot;})));</span>
<span class="nc" id="L910">    arrayPrintDouble(gc.getCounts(Arrays.asList(new String[]{&quot;b&quot;, &quot;k&quot;, &quot;z&quot;})));</span>

<span class="nc" id="L912">    GeneralizedCounter&lt;String&gt; gc1 = gc.conditionalize(Arrays.asList(new String[]{&quot;a&quot;}));</span>
<span class="nc" id="L913">    gc1.incrementCount(Arrays.asList(new String[]{&quot;j&quot;, &quot;x&quot;}));</span>
<span class="nc" id="L914">    gc1.incrementCount2D(&quot;j&quot;, &quot;z&quot;);</span>
<span class="nc" id="L915">    GeneralizedCounter&lt;String&gt; gc2 = gc1.conditionalize(Arrays.asList(new String[]{&quot;j&quot;}));</span>
<span class="nc" id="L916">    gc2.incrementCount1D(&quot;x&quot;);</span>
<span class="nc" id="L917">    System.out.println(&quot;Pretty-printing gc after incrementing gc1:&quot;);</span>
<span class="nc" id="L918">    gc.prettyPrint();</span>
<span class="nc" id="L919">    System.out.println(&quot;Total: &quot; + gc.totalCount());</span>

<span class="nc" id="L921">    gc1.printKeySet();</span>
<span class="nc" id="L922">    System.out.println(&quot;another entry set:\n&quot; + gc1.entrySet());</span>


<span class="nc" id="L925">    ClassicCounter&lt;List&lt;String&gt;&gt; c = gc.counterView();</span>

<span class="nc" id="L927">    System.out.println(&quot;string representation of counter view:&quot;);</span>
<span class="nc" id="L928">    System.out.println(c.toString());</span>

<span class="nc" id="L930">    double d1 = c.getCount(Arrays.asList(new String[]{&quot;a&quot;, &quot;j&quot;, &quot;x&quot;}));</span>
<span class="nc" id="L931">    double d2 = c.getCount(Arrays.asList(new String[]{&quot;a&quot;, &quot;j&quot;, &quot;w&quot;}));</span>

<span class="nc" id="L933">    System.out.println(d1 + &quot; &quot; + d2);</span>


<span class="nc" id="L936">    ClassicCounter&lt;List&lt;String&gt;&gt; c1 = gc1.counterView();</span>

<span class="nc" id="L938">    System.out.println(&quot;Count of {j,x} -- should be 3.0\t&quot; + c1.getCount(Arrays.asList(new String[]{&quot;j&quot;, &quot;x&quot;})));</span>


<span class="nc" id="L941">    System.out.println(c.keySet() + &quot; size &quot; + c.keySet().size());</span>
<span class="nc" id="L942">    System.out.println(c1.keySet() + &quot; size &quot; + c1.keySet().size());</span>

<span class="nc" id="L944">    System.out.println(c1.equals(c));</span>
<span class="nc" id="L945">    System.out.println(c.equals(c1));</span>
<span class="nc" id="L946">    System.out.println(c.equals(c));</span>

<span class="nc" id="L948">    System.out.println(&quot;### testing equality of regular Counter...&quot;);</span>

<span class="nc" id="L950">    ClassicCounter&lt;String&gt; z1 = new ClassicCounter&lt;&gt;();</span>
<span class="nc" id="L951">    ClassicCounter&lt;String&gt; z2 = new ClassicCounter&lt;&gt;();</span>

<span class="nc" id="L953">    z1.incrementCount(&quot;a1&quot;);</span>
<span class="nc" id="L954">    z1.incrementCount(&quot;a2&quot;);</span>

<span class="nc" id="L956">    z2.incrementCount(&quot;b&quot;);</span>

<span class="nc" id="L958">    System.out.println(z1.equals(z2));</span>

<span class="nc" id="L960">    System.out.println(z1.toString());</span>
<span class="nc" id="L961">    System.out.println(z1.keySet().toString());</span>


<span class="nc" id="L964">  }</span>


  // below is testing code

  private void printKeySet() {
<span class="nc" id="L970">    Set&lt;?&gt; keys = keySet();</span>
<span class="nc" id="L971">    System.out.println(&quot;printing keyset:&quot;);</span>
<span class="nc bnc" id="L972" title="All 2 branches missed.">    for (Object o: keys) {</span>
      //System.out.println(Arrays.asList((Object[]) i.next()));
<span class="nc" id="L974">      System.out.println(o);</span>
<span class="nc" id="L975">    }</span>
<span class="nc" id="L976">  }</span>


  private static void arrayPrintDouble(double[] o) {
<span class="nc bnc" id="L980" title="All 2 branches missed.">    for (double anO : o) {</span>
<span class="nc" id="L981">      System.out.print(anO + &quot;\t&quot;);</span>
    }
<span class="nc" id="L983">    System.out.println();</span>
<span class="nc" id="L984">  }</span>

  private Set&lt;?&gt; dumpKeys() {
<span class="nc" id="L987">    return map.keySet();</span>
  }

  /**
   * pretty-prints the GeneralizedCounter to {@link System#out}.
   */
  public void prettyPrint() {
<span class="nc" id="L994">    prettyPrint(new PrintWriter(System.out, true));</span>
<span class="nc" id="L995">  }</span>

  /**
   * pretty-prints the GeneralizedCounter, using a buffer increment of two spaces.
   */
  public void prettyPrint(PrintWriter pw) {
<span class="nc" id="L1001">    prettyPrint(pw, &quot;  &quot;);</span>
<span class="nc" id="L1002">  }</span>

  /**
   * pretty-prints the GeneralizedCounter.
   */
  public void prettyPrint(PrintWriter pw, String bufferIncrement) {
<span class="nc" id="L1008">    prettyPrint(pw, &quot;&quot;, bufferIncrement);</span>
<span class="nc" id="L1009">  }</span>

  private void prettyPrint(PrintWriter pw, String buffer, String bufferIncrement) {
<span class="nc bnc" id="L1012" title="All 2 branches missed.">    if (depth == 1) {</span>
<span class="nc bnc" id="L1013" title="All 2 branches missed.">      for (Map.Entry&lt;?, Double&gt; e: entrySet()) {</span>
<span class="nc" id="L1014">        Object key = e.getKey();</span>
<span class="nc" id="L1015">        double count = e.getValue();</span>
<span class="nc" id="L1016">        pw.println(buffer + key + &quot;\t&quot; + count);</span>
<span class="nc" id="L1017">      }</span>
    } else {
<span class="nc bnc" id="L1019" title="All 2 branches missed.">      for (K key: topLevelKeySet()) {</span>
<span class="nc" id="L1020">        GeneralizedCounter&lt;K&gt; gc1 = conditionalize(Arrays.asList(ErasureUtils.&lt;K[]&gt;uncheckedCast(new Object[]{key})));</span>
<span class="nc" id="L1021">        pw.println(buffer + key + &quot;\t&quot; + gc1.totalCount());</span>
<span class="nc" id="L1022">        gc1.prettyPrint(pw, buffer + bufferIncrement, bufferIncrement);</span>
<span class="nc" id="L1023">      }</span>
    }
<span class="nc" id="L1025">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>