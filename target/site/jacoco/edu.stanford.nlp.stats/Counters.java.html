<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Counters.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.stats</a> &gt; <span class="el_source">Counters.java</span></div><h1>Counters.java</h1><pre class="source lang-java linenums">// Stanford JavaNLP support classes
// Copyright (c) 2004-2008 The Board of Trustees of
// The Leland Stanford Junior University. All Rights Reserved.
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
//
// For more information, bug reports, fixes, contact:
//    Christopher Manning
//    Dept of Computer Science, Gates 1A
//    Stanford CA 94305-9010
//    USA
//    java-nlp-support@lists.stanford.edu
//    http://nlp.stanford.edu/software/

package edu.stanford.nlp.stats;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.lang.reflect.Constructor;
import java.text.NumberFormat;
import java.util.AbstractCollection;
import java.util.AbstractMap;
import java.util.AbstractSet;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.Set;
import java.util.Map.Entry;
import java.util.function.Function;
import java.util.regex.Pattern;

import edu.stanford.nlp.io.IOUtils;
import edu.stanford.nlp.math.ArrayMath;
import edu.stanford.nlp.math.SloppyMath;
import edu.stanford.nlp.util.*;
import edu.stanford.nlp.util.logging.Redwood;
import edu.stanford.nlp.util.logging.PrettyLogger;
import edu.stanford.nlp.util.logging.Redwood.RedwoodChannels;

/**
 * Static methods for operating on a {@link Counter}.
 * &lt;p&gt;
 * All methods that change their arguments change the &lt;i&gt;first&lt;/i&gt; argument
 * (only), and have &quot;InPlace&quot; in their name. This class also provides access to
 * Comparators that can be used to sort the keys or entries of this Counter by
 * the counts, in either ascending or descending order.
 *
 * @author Galen Andrew (galand@cs.stanford.edu)
 * @author Jeff Michels (jmichels@stanford.edu)
 * @author dramage
 * @author daniel cer (http://dmcer.net)
 * @author Christopher Manning
 * @author stefank (Optimized dot product)
 */
public class Counters  {

  /** A logger for this class */
<span class="fc" id="L86">  private static Redwood.RedwoodChannels log = Redwood.channels(Counters.class);</span>

<span class="fc" id="L88">  private static final double LOG_E_2 = Math.log(2.0);</span>

<span class="nc" id="L90">  private Counters() {} // only static methods</span>

  //
  // Log arithmetic operations
  //

  /**
   * Returns ArrayMath.logSum of the values in this counter.
   *
   * @param c Argument counter (which is not modified)
   * @return ArrayMath.logSum of the values in this counter.
   */
  public static &lt;E&gt; double logSum(Counter&lt;E&gt; c) {
<span class="fc" id="L103">    return ArrayMath.logSum(ArrayMath.unbox(c.values()));</span>
  }

  /**
   * Transform log space values into a probability distribution in place. On the
   * assumption that the values in the Counter are in log space, this method
   * calculates their sum, and then subtracts the log of their sum from each
   * element. That is, if a counter has keys c1, c2, c3 with values v1, v2, v3,
   * the value of c1 becomes v1 - log(e^v1 + e^v2 + e^v3). After this, e^v1 +
   * e^v2 + e^v3 = 1.0, so Counters.logSum(c) = 0.0 (approximately).
   *
   * @param c The Counter to log normalize in place
   */
  @SuppressWarnings( { &quot;UnnecessaryUnboxing&quot; })
  public static &lt;E&gt; void logNormalizeInPlace(Counter&lt;E&gt; c) {
<span class="fc" id="L118">    double logsum = logSum(c);</span>
    // for (E key : c.keySet()) {
    // c.incrementCount(key, -logsum);
    // }
    // This should be faster
<span class="fc bfc" id="L123" title="All 2 branches covered.">    for (Map.Entry&lt;E, Double&gt; e : c.entrySet()) {</span>
<span class="fc" id="L124">      e.setValue(e.getValue().doubleValue() - logsum);</span>
<span class="fc" id="L125">    }</span>
<span class="fc" id="L126">  }</span>

  //
  // Query operations
  //

  /**
   * Returns the value of the maximum entry in this counter. This is also the
   * L_infinity norm. An empty counter is given a max value of
   * Double.NEGATIVE_INFINITY.
   *
   * @param c The Counter to find the max of
   * @return The maximum value of the Counter
   */
  public static &lt;E&gt; double max(Counter&lt;E&gt; c) {
<span class="fc" id="L141">    return max(c, Double.NEGATIVE_INFINITY);  // note[gabor]: Should the default actually be 0 rather than negative_infinity?</span>
  }

  /**
   * Returns the value of the maximum entry in this counter. This is also the
   * L_infinity norm. An empty counter is given a max value of
   * Double.NEGATIVE_INFINITY.
   *
   * @param c The Counter to find the max of
   * @param valueIfEmpty The value to return if this counter is empty (i.e., the maximum is not well defined.
   * @return The maximum value of the Counter
   */
  public static &lt;E&gt; double max(Counter&lt;E&gt; c, double valueIfEmpty) {
<span class="pc bpc" id="L154" title="1 of 2 branches missed.">    if (c.size() == 0) {</span>
<span class="nc" id="L155">      return valueIfEmpty;</span>
    } else {
<span class="fc" id="L157">      double max = Double.NEGATIVE_INFINITY;</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">      for (double v : c.values()) {</span>
<span class="fc" id="L159">        max = Math.max(max, v);</span>
<span class="fc" id="L160">      }</span>
<span class="fc" id="L161">      return max;</span>
    }
  }

  /**
   * Takes in a Collection of something and makes a counter, incrementing once
   * for each object in the collection.
   *
   * @param c The Collection to turn into a counter
   * @return The counter made out of the collection
   */
  public static &lt;E&gt; Counter&lt;E&gt; asCounter(Collection&lt;E&gt; c) {
<span class="fc" id="L173">    Counter&lt;E&gt; count = new ClassicCounter&lt;&gt;();</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">    for (E elem : c) {</span>
<span class="fc" id="L175">      count.incrementCount(elem);</span>
<span class="fc" id="L176">    }</span>
<span class="fc" id="L177">    return count;</span>
  }

  /**
   * Returns the value of the smallest entry in this counter.
   *
   * @param c The Counter (not modified)
   * @return The minimum value in the Counter
   */
  public static &lt;E&gt; double min(Counter&lt;E&gt; c) {
<span class="fc" id="L187">    double min = Double.POSITIVE_INFINITY;</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">    for (double v : c.values()) {</span>
<span class="fc" id="L189">      min = Math.min(min, v);</span>
<span class="fc" id="L190">    }</span>
<span class="fc" id="L191">    return min;</span>
  }

  /**
   * Finds and returns the key in the Counter with the largest count. Returning
   * null if count is empty.
   *
   * @param c The Counter
   * @return The key in the Counter with the largest count.
   */
  public static &lt;E&gt; E argmax(Counter&lt;E&gt; c) {
<span class="pc" id="L202">    return argmax(c, (x, y) -&gt; 0, null);</span>

  }


  /**
   * Finds and returns the key in this Counter with the smallest count.
   *
   * @param c The Counter
   * @return The key in the Counter with the smallest count.
   */
  public static &lt;E&gt; E argmin(Counter&lt;E&gt; c) {
<span class="fc" id="L214">    double min = Double.POSITIVE_INFINITY;</span>
<span class="fc" id="L215">    E argmin = null;</span>

<span class="fc bfc" id="L217" title="All 2 branches covered.">    for (E key : c.keySet()) {</span>
<span class="fc" id="L218">      double count = c.getCount(key);</span>
<span class="fc bfc" id="L219" title="All 4 branches covered.">      if (argmin == null || count &lt; min) { // || (count == min &amp;&amp; tieBreaker.compare(key, argmin) &lt; 0)</span>
<span class="fc" id="L220">        min = count;</span>
<span class="fc" id="L221">        argmin = key;</span>
      }
<span class="fc" id="L223">    }</span>
<span class="fc" id="L224">    return argmin;</span>
  }

  /**
   * Finds and returns the key in the Counter with the largest count. Returning
   * null if count is empty.
   *
   * @param c The Counter
   * @param tieBreaker the tie breaker for when elements have the same value.
   * @return The key in the Counter with the largest count.
   */
  public static &lt;E&gt; E argmax(Counter&lt;E&gt; c, Comparator&lt;E&gt; tieBreaker) {
<span class="nc" id="L236">    return argmax(c, tieBreaker, (E) null);</span>
  }

  /**
   * Finds and returns the key in the Counter with the largest count. Returning
   * null if count is empty.
   *
   * @param c The Counter
   * @param tieBreaker the tie breaker for when elements have the same value.
   * @param defaultIfEmpty The value to return if the counter is empty.
   * @return The key in the Counter with the largest count.
   */
  public static &lt;E&gt; E argmax(Counter&lt;E&gt; c, Comparator&lt;E&gt; tieBreaker, E defaultIfEmpty) {
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">    if (Thread.interrupted()) {  // A good place to check for interrupts -- called from many annotators</span>
<span class="nc" id="L250">      throw new RuntimeInterruptedException();</span>
    }
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">    if (c.size() == 0) {</span>
<span class="nc" id="L253">      return defaultIfEmpty;</span>
    }
<span class="fc" id="L255">    double max = Double.NEGATIVE_INFINITY;</span>
<span class="fc" id="L256">    E argmax = null;</span>
<span class="fc bfc" id="L257" title="All 2 branches covered.">    for (E key : c.keySet()) {</span>
<span class="fc" id="L258">      double count = c.getCount(key);</span>
<span class="pc bpc" id="L259" title="3 of 8 branches missed.">      if (argmax == null || count &gt; max || (count == max &amp;&amp; tieBreaker.compare(key, argmax) &lt; 0)) {</span>
<span class="fc" id="L260">        max = count;</span>
<span class="fc" id="L261">        argmax = key;</span>
      }
<span class="fc" id="L263">    }</span>
<span class="fc" id="L264">    return argmax;</span>
  }

  /**
   * Finds and returns the key in this Counter with the smallest count.
   *
   * @param c The Counter
   * @return The key in the Counter with the smallest count.
   */
  public static &lt;E&gt; E argmin(Counter&lt;E&gt; c, Comparator&lt;E&gt; tieBreaker) {
<span class="nc" id="L274">    double min = Double.POSITIVE_INFINITY;</span>
<span class="nc" id="L275">    E argmin = null;</span>

<span class="nc bnc" id="L277" title="All 2 branches missed.">    for (E key : c.keySet()) {</span>
<span class="nc" id="L278">      double count = c.getCount(key);</span>
<span class="nc bnc" id="L279" title="All 8 branches missed.">      if (argmin == null || count &lt; min || (count == min &amp;&amp; tieBreaker.compare(key, argmin) &lt; 0)) {</span>
<span class="nc" id="L280">        min = count;</span>
<span class="nc" id="L281">        argmin = key;</span>
      }
<span class="nc" id="L283">    }</span>
<span class="nc" id="L284">    return argmin;</span>
  }

  /**
   * Returns the mean of all the counts (totalCount/size).
   *
   * @param c The Counter to find the mean of.
   * @return The mean of all the counts (totalCount/size).
   */
  public static &lt;E&gt; double mean(Counter&lt;E&gt; c) {
<span class="fc" id="L294">    return c.totalCount() / c.size();</span>
  }

  public static &lt;E&gt; double standardDeviation(Counter&lt;E&gt; c) {
<span class="fc" id="L298">    double std = 0;</span>
<span class="fc" id="L299">    double mean = c.totalCount() / c.size();</span>
<span class="fc bfc" id="L300" title="All 2 branches covered.">    for (Map.Entry&lt;E, Double&gt; en : c.entrySet()) {</span>
<span class="fc" id="L301">      std += (en.getValue() - mean) * (en.getValue() - mean);</span>
<span class="fc" id="L302">    }</span>
<span class="fc" id="L303">    return Math.sqrt(std / c.size());</span>
  }

  //
  // In-place arithmetic
  //

  /**
   * Sets each value of target to be target[k]+scale*arg[k] for all keys k in
   * target.
   *
   * @param target A Counter that is modified
   * @param arg The Counter whose contents are added to target
   * @param scale How the arg Counter is scaled before being added
   */
  // TODO: Rewrite to use arg.entrySet()
  public static &lt;E&gt; void addInPlace(Counter&lt;E&gt; target, Counter&lt;E&gt; arg, double scale) {
<span class="fc bfc" id="L320" title="All 2 branches covered.">    for (E key : arg.keySet()) {</span>
<span class="fc" id="L321">      target.incrementCount(key, scale * arg.getCount(key));</span>
<span class="fc" id="L322">    }</span>
<span class="fc" id="L323">  }</span>

  /**
   * Sets each value of target to be target[k]+arg[k] for all keys k in arg.
   */
  public static &lt;E&gt; void addInPlace(Counter&lt;E&gt; target, Counter&lt;E&gt; arg) {
<span class="fc bfc" id="L329" title="All 2 branches covered.">    for (Map.Entry&lt;E, Double&gt; entry : arg.entrySet()) {</span>
<span class="fc" id="L330">      double count = entry.getValue();</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">      if (count != 0) {</span>
<span class="fc" id="L332">        target.incrementCount(entry.getKey(), count);</span>
      }
<span class="fc" id="L334">    }</span>
<span class="fc" id="L335">  }</span>

  /**
   * Sets each value of double[] target to be
   * target[idx.indexOf(k)]+a.getCount(k) for all keys k in arg
   */
  public static &lt;E&gt; void addInPlace(double[] target, Counter&lt;E&gt; arg, Index&lt;E&gt; idx) {
<span class="nc bnc" id="L342" title="All 2 branches missed.">    for (Map.Entry&lt;E, Double&gt; entry : arg.entrySet()) {</span>
<span class="nc" id="L343">      target[idx.indexOf(entry.getKey())] += entry.getValue();</span>
<span class="nc" id="L344">    }</span>
<span class="nc" id="L345">  }</span>

  /**
   * For all keys (u,v) in arg1 and arg2, sets return[u,v] to be summation of both.
   * @param &lt;T1&gt;
   * @param &lt;T2&gt;
   */
  public static &lt;T1, T2&gt; TwoDimensionalCounter&lt;T1, T2&gt; add(TwoDimensionalCounter&lt;T1, T2&gt; arg1, TwoDimensionalCounter&lt;T1, T2&gt; arg2) {
<span class="nc" id="L353">    TwoDimensionalCounter&lt;T1, T2&gt; add = new TwoDimensionalCounter&lt;&gt;();</span>
<span class="nc" id="L354">    Counters.addInPlace(add , arg1);</span>
<span class="nc" id="L355">    Counters.addInPlace(add , arg2);</span>
<span class="nc" id="L356">    return add;</span>
  }

   /**
   * For all keys (u,v) in arg, sets target[u,v] to be target[u,v] + scale *
   * arg[u,v].
   *
   * @param &lt;T1&gt;
   * @param &lt;T2&gt;
   */
  public static &lt;T1, T2&gt; void addInPlace(TwoDimensionalCounter&lt;T1, T2&gt; target, TwoDimensionalCounter&lt;T1, T2&gt; arg, double scale) {
<span class="nc bnc" id="L367" title="All 2 branches missed.">    for (T1 outer : arg.firstKeySet())</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">      for (T2 inner : arg.secondKeySet()) {</span>
<span class="nc" id="L369">        target.incrementCount(outer, inner, scale * arg.getCount(outer, inner));</span>
<span class="nc" id="L370">      }</span>
<span class="nc" id="L371">  }</span>

  /**
   * For all keys (u,v) in arg, sets target[u,v] to be target[u,v] + arg[u,v].
   *
   * @param &lt;T1&gt;
   * @param &lt;T2&gt;
   */
  public static &lt;T1, T2&gt; void addInPlace(TwoDimensionalCounter&lt;T1, T2&gt; target, TwoDimensionalCounter&lt;T1, T2&gt; arg) {
<span class="nc bnc" id="L380" title="All 2 branches missed.">    for (T1 outer : arg.firstKeySet())</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">      for (T2 inner : arg.secondKeySet()) {</span>
<span class="nc" id="L382">        target.incrementCount(outer, inner, arg.getCount(outer, inner));</span>
<span class="nc" id="L383">      }</span>
<span class="nc" id="L384">  }</span>

  /**
   * Sets each value of target to be target[k]+
   * value*(num-of-times-it-occurs-in-collection) if the key is present in the arg
   * collection.
   */
  public static &lt;E&gt; void addInPlace(Counter&lt;E&gt; target, Collection&lt;E&gt; arg, double value) {
<span class="nc bnc" id="L392" title="All 2 branches missed.">    for (E key : arg) {</span>
<span class="nc" id="L393">      target.incrementCount(key, value);</span>
<span class="nc" id="L394">    }</span>
<span class="nc" id="L395">  }</span>

  /**
   * For all keys (u,v) in target, sets target[u,v] to be target[u,v] + value
   *
   * @param &lt;T1&gt;
   * @param &lt;T2&gt;
   */
  public static &lt;T1, T2&gt; void addInPlace(TwoDimensionalCounter&lt;T1, T2&gt; target, double value) {
<span class="nc bnc" id="L404" title="All 2 branches missed.">    for (T1 outer : target.firstKeySet()){</span>
<span class="nc" id="L405">        addInPlace(target.getCounter(outer), value);</span>
<span class="nc" id="L406">      }</span>
<span class="nc" id="L407">  }</span>

  /**
   * Sets each value of target to be target[k]+
   * num-of-times-it-occurs-in-collection if the key is present in the arg
   * collection.
   */
  public static &lt;E&gt; void addInPlace(Counter&lt;E&gt; target, Collection&lt;E&gt; arg) {
<span class="fc bfc" id="L415" title="All 2 branches covered.">    for (E key : arg) {</span>
<span class="fc" id="L416">      target.incrementCount(key, 1);</span>
<span class="fc" id="L417">    }</span>
<span class="fc" id="L418">  }</span>

  /**
   * Increments all keys in a Counter by a specific value.
   */
  public static &lt;E&gt; void addInPlace(Counter&lt;E&gt; target, double value) {
<span class="nc bnc" id="L424" title="All 2 branches missed.">    for (E key : target.keySet()) {</span>
<span class="nc" id="L425">      target.incrementCount(key, value);</span>
<span class="nc" id="L426">    }</span>
<span class="nc" id="L427">  }</span>

  /**
   * Sets each value of target to be target[k]-arg[k] for all keys k in target.
   */
  public static &lt;E&gt; void subtractInPlace(Counter&lt;E&gt; target, Counter&lt;E&gt; arg) {
<span class="fc bfc" id="L433" title="All 2 branches covered.">    for (E key : arg.keySet()) {</span>
<span class="fc" id="L434">      target.decrementCount(key, arg.getCount(key));</span>
<span class="fc" id="L435">    }</span>
<span class="fc" id="L436">  }</span>

  /**
   * Sets each value of double[] target to be
   * target[idx.indexOf(k)]-a.getCount(k) for all keys k in arg
   */
  public static &lt;E&gt; void subtractInPlace(double[] target, Counter&lt;E&gt; arg, Index&lt;E&gt; idx) {
<span class="nc bnc" id="L443" title="All 2 branches missed.">    for (Map.Entry&lt;E, Double&gt; entry : arg.entrySet()) {</span>
<span class="nc" id="L444">      target[idx.indexOf(entry.getKey())] -= entry.getValue();</span>
<span class="nc" id="L445">    }</span>
<span class="nc" id="L446">  }</span>

  /**
   * Divides every non-zero count in target by the corresponding value in the
   * denominator Counter. Beware that this can give NaN values for zero counts
   * in the denominator counter!
   */
  public static &lt;E&gt; void divideInPlace(Counter&lt;E&gt; target, Counter&lt;E&gt; denominator) {
<span class="fc bfc" id="L454" title="All 2 branches covered.">    for (E key : target.keySet()) {</span>
<span class="fc" id="L455">      target.setCount(key, target.getCount(key) / denominator.getCount(key));</span>
<span class="fc" id="L456">    }</span>
<span class="fc" id="L457">  }</span>

  /**
   * Multiplies every count in target by the corresponding value in the term
   * Counter.
   */
  public static &lt;E&gt; void dotProductInPlace(Counter&lt;E&gt; target, Counter&lt;E&gt; term) {
<span class="nc bnc" id="L464" title="All 2 branches missed.">    for (E key : target.keySet()) {</span>
<span class="nc" id="L465">      target.setCount(key, target.getCount(key) * term.getCount(key));</span>
<span class="nc" id="L466">    }</span>
<span class="nc" id="L467">  }</span>

  /**
   * Divides each value in target by the given divisor, in place.
   *
   * @param target The values in this Counter will be changed throughout by the
   *          multiplier
   * @param divisor The number by which to change each number in the Counter
   * @return The target Counter is returned (for easier method chaining)
   */
  public static &lt;E&gt; Counter&lt;E&gt; divideInPlace(Counter&lt;E&gt; target, double divisor) {
<span class="fc bfc" id="L478" title="All 2 branches covered.">    for (Entry&lt;E, Double&gt; entry : target.entrySet()) {</span>
<span class="fc" id="L479">      target.setCount(entry.getKey(), entry.getValue() / divisor);</span>
<span class="fc" id="L480">    }</span>
<span class="fc" id="L481">    return target;</span>
  }

  /**
   * Multiplies each value in target by the given multiplier, in place.
   *
   * @param target The values in this Counter will be multiplied by the
   *          multiplier
   * @param multiplier The number by which to change each number in the Counter
   */
  public static &lt;E&gt; Counter&lt;E&gt; multiplyInPlace(Counter&lt;E&gt; target, double multiplier) {
<span class="fc bfc" id="L492" title="All 2 branches covered.">    for (Entry&lt;E, Double&gt; entry : target.entrySet()) {</span>
<span class="fc" id="L493">      target.setCount(entry.getKey(), entry.getValue() * multiplier);</span>
<span class="fc" id="L494">    }</span>
<span class="fc" id="L495">    return target;</span>
  }

  /**
   * Multiplies each value in target by the count of the key in mult, in place. Returns non zero entries
   *
   * @param target The counter
   * @param mult The counter you want to multiply with target
   */
  public static &lt;E&gt; Counter&lt;E&gt; multiplyInPlace(Counter&lt;E&gt; target, Counter&lt;E&gt; mult) {
<span class="nc bnc" id="L505" title="All 2 branches missed.">    for (Entry&lt;E, Double&gt; entry : target.entrySet()) {</span>
<span class="nc" id="L506">      target.setCount(entry.getKey(), entry.getValue() * mult.getCount(entry.getKey()));</span>
<span class="nc" id="L507">    }</span>
<span class="nc" id="L508">    Counters.retainNonZeros(target);</span>
<span class="nc" id="L509">    return target;</span>
  }

  /**
   * Normalizes the target counter in-place, so the sum of the resulting values
   * equals 1.
   *
   * @param &lt;E&gt; Type of elements in Counter
   */
  public static &lt;E&gt; void normalize(Counter&lt;E&gt; target) {
<span class="nc" id="L519">    divideInPlace(target, target.totalCount());</span>
<span class="nc" id="L520">  }</span>

  /**
   * L1 normalize a counter. Return a counter that is a probability distribution,
   * so the sum of the resulting value equals 1.
   *
   * @param c The {@link Counter} to be L1 normalized. This counter is not
   *          modified.
   * @return A new L1-normalized Counter based on c.
   */
  public static &lt;E, C extends Counter&lt;E&gt;&gt; C asNormalizedCounter(C c) {
<span class="fc" id="L531">    return scale(c, 1.0 / c.totalCount());</span>
  }

  /**
   * Normalizes the target counter in-place, so the sum of the resulting values
   * equals 1.
   *
   * @param &lt;E&gt; Type of elements in TwoDimensionalCounter
   * @param &lt;F&gt; Type of elements in TwoDimensionalCounter
   */
  public static &lt;E, F&gt; void normalize(TwoDimensionalCounter&lt;E, F&gt; target) {
<span class="nc" id="L542">    Counters.divideInPlace(target, target.totalCount());</span>
<span class="nc" id="L543">  }</span>

  public static &lt;E&gt; void logInPlace(Counter&lt;E&gt; target) {
<span class="fc bfc" id="L546" title="All 2 branches covered.">    for (E key : target.keySet()) {</span>
<span class="fc" id="L547">      target.setCount(key, Math.log(target.getCount(key)));</span>
<span class="fc" id="L548">    }</span>
<span class="fc" id="L549">  }</span>

  //
  // Selection Operators
  //

  /**
   * Delete 'top' and 'bottom' number of elements from the top and bottom
   * respectively
   */
  public static &lt;E&gt; List&lt;E&gt; deleteOutofRange(Counter&lt;E&gt; c, int top, int bottom) {

<span class="nc" id="L561">    List&lt;E&gt; purgedItems = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L562">    int numToPurge = top + bottom;</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">    if (numToPurge &lt;= 0) {</span>
<span class="nc" id="L564">      return purgedItems;</span>
    }

<span class="nc" id="L567">    List&lt;E&gt; l = Counters.toSortedList(c);</span>
<span class="nc bnc" id="L568" title="All 2 branches missed.">    for (int i = 0; i &lt; top; i++) {</span>
<span class="nc" id="L569">      E item = l.get(i);</span>
<span class="nc" id="L570">      purgedItems.add(item);</span>
<span class="nc" id="L571">      c.remove(item);</span>
    }
<span class="nc" id="L573">    int size = c.size();</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">    for (int i = c.size() - 1; i &gt;= (size - bottom); i--) {</span>
<span class="nc" id="L575">      E item = l.get(i);</span>
<span class="nc" id="L576">      purgedItems.add(item);</span>
<span class="nc" id="L577">      c.remove(item);</span>
    }
<span class="nc" id="L579">    return purgedItems;</span>
  }

  /**
   * Removes all entries from c except for the top {@code num}.
   */
  public static &lt;E&gt; void retainTop(Counter&lt;E&gt; c, int num) {
<span class="fc" id="L586">    int numToPurge = c.size() - num;</span>
<span class="pc bpc" id="L587" title="1 of 2 branches missed.">    if (numToPurge &lt;= 0) {</span>
<span class="nc" id="L588">      return;</span>
    }

<span class="fc" id="L591">    List&lt;E&gt; l = Counters.toSortedList(c, true);</span>
<span class="fc bfc" id="L592" title="All 2 branches covered.">    for (int i = 0; i &lt; numToPurge; i++) {</span>
<span class="fc" id="L593">      c.remove(l.get(i));</span>
    }
<span class="fc" id="L595">  }</span>

  /**
   * Removes all entries from c except for the top {@code num}.
   */
  public static &lt;E extends Comparable&lt;E&gt;&gt; void retainTopKeyComparable(Counter&lt;E&gt; c, int num) {
<span class="nc" id="L601">    int numToPurge = c.size() - num;</span>
<span class="nc bnc" id="L602" title="All 2 branches missed.">    if (numToPurge &lt;= 0) {</span>
<span class="nc" id="L603">      return;</span>
    }

<span class="nc" id="L606">    List&lt;E&gt; l = Counters.toSortedListKeyComparable(c);</span>
<span class="nc" id="L607">    Collections.reverse(l);</span>
<span class="nc bnc" id="L608" title="All 2 branches missed.">    for (int i = 0; i &lt; numToPurge; i++) {</span>
<span class="nc" id="L609">      c.remove(l.get(i));</span>
    }
<span class="nc" id="L611">  }</span>

  /**
   * Removes all entries from c except for the bottom {@code num}.
   */
  public static &lt;E&gt; List&lt;E&gt; retainBottom(Counter&lt;E&gt; c, int num) {
<span class="nc" id="L617">    int numToPurge = c.size() - num;</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">    if (numToPurge &lt;= 0) {</span>
<span class="nc" id="L619">      return Generics.newArrayList();</span>
    }

<span class="nc" id="L622">    List&lt;E&gt; removed = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L623">    List&lt;E&gt; l = Counters.toSortedList(c);</span>
<span class="nc bnc" id="L624" title="All 2 branches missed.">    for (int i = 0; i &lt; numToPurge; i++) {</span>
<span class="nc" id="L625">      E rem = l.get(i);</span>
<span class="nc" id="L626">      removed.add(rem);</span>
<span class="nc" id="L627">      c.remove(rem);</span>
    }
<span class="nc" id="L629">    return removed;</span>
  }

  /**
   * Removes all entries with 0 count in the counter, returning the set of
   * removed entries.
   */
  public static &lt;E&gt; Set&lt;E&gt; retainNonZeros(Counter&lt;E&gt; counter) {
<span class="fc" id="L637">    Set&lt;E&gt; removed = Generics.newHashSet();</span>
<span class="fc bfc" id="L638" title="All 2 branches covered.">    for (E key : counter.keySet()) {</span>
<span class="fc bfc" id="L639" title="All 2 branches covered.">      if (counter.getCount(key) == 0.0) {</span>
<span class="fc" id="L640">        removed.add(key);</span>
      }
<span class="fc" id="L642">    }</span>
<span class="fc bfc" id="L643" title="All 2 branches covered.">    for (E key : removed) {</span>
<span class="fc" id="L644">      counter.remove(key);</span>
<span class="fc" id="L645">    }</span>
<span class="fc" id="L646">    return removed;</span>
  }

  /**
   * Removes all entries with counts below the given threshold, returning the
   * set of removed entries.
   *
   * @param counter The counter.
   * @param countThreshold
   *          The minimum count for an entry to be kept. Entries (strictly) less
   *          than this threshold are discarded.
   * @return The set of discarded entries.
   */
  public static &lt;E&gt; Set&lt;E&gt; retainAbove(Counter&lt;E&gt; counter, double countThreshold) {
<span class="fc" id="L660">    Set&lt;E&gt; removed = Generics.newHashSet();</span>
<span class="fc bfc" id="L661" title="All 2 branches covered.">    for (E key : counter.keySet()) {</span>
<span class="fc bfc" id="L662" title="All 2 branches covered.">      if (counter.getCount(key) &lt; countThreshold) {</span>
<span class="fc" id="L663">        removed.add(key);</span>
      }
<span class="fc" id="L665">    }</span>
<span class="fc bfc" id="L666" title="All 2 branches covered.">    for (E key : removed) {</span>
<span class="fc" id="L667">      counter.remove(key);</span>
<span class="fc" id="L668">    }</span>
<span class="fc" id="L669">    return removed;</span>
  }

  /**
   * Removes all entries with counts below the given threshold, returning the
   * set of removed entries.
   *
   * @param counter The counter.
   * @param countThreshold
   *          The minimum count for an entry to be kept. Entries (strictly) less
   *          than this threshold are discarded.
   * @return The set of discarded entries.
   */
  public static &lt;E1, E2&gt; Set&lt;Pair&lt;E1, E2&gt;&gt; retainAbove(
      TwoDimensionalCounter&lt;E1, E2&gt; counter, double countThreshold) {

<span class="nc" id="L685">    Set&lt;Pair&lt;E1, E2&gt;&gt; removed = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L686" title="All 2 branches missed.">    for (Entry&lt;E1, ClassicCounter&lt;E2&gt;&gt; en : counter.entrySet()) {</span>
<span class="nc bnc" id="L687" title="All 2 branches missed.">      for (Entry&lt;E2, Double&gt; en2 : en.getValue().entrySet()) {</span>
<span class="nc bnc" id="L688" title="All 2 branches missed.">        if (counter.getCount(en.getKey(), en2.getKey()) &lt; countThreshold) {</span>
<span class="nc" id="L689">          removed.add(new Pair&lt;&gt;(en.getKey(), en2.getKey()));</span>
        }
<span class="nc" id="L691">      }</span>
<span class="nc" id="L692">    }</span>
<span class="nc bnc" id="L693" title="All 2 branches missed.">    for (Pair&lt;E1, E2&gt; key : removed) {</span>
<span class="nc" id="L694">      counter.remove(key.first(), key.second());</span>
<span class="nc" id="L695">    }</span>
<span class="nc" id="L696">    return removed;</span>
  }

  /**
   * Removes all entries with counts above the given threshold, returning the
   * set of removed entries.
   *
   * @param counter The counter.
   * @param countMaxThreshold
   *          The maximum count for an entry to be kept. Entries (strictly) more
   *          than this threshold are discarded.
   * @return The set of discarded entries.
   */
  public static &lt;E&gt; Counter&lt;E&gt; retainBelow(Counter&lt;E&gt; counter, double countMaxThreshold) {
<span class="nc" id="L710">    Counter&lt;E&gt; removed = new ClassicCounter&lt;&gt;();</span>
<span class="nc bnc" id="L711" title="All 2 branches missed.">    for (E key : counter.keySet()) {</span>
<span class="nc" id="L712">      double count = counter.getCount(key);</span>
<span class="nc bnc" id="L713" title="All 2 branches missed.">      if (counter.getCount(key) &gt; countMaxThreshold) {</span>
<span class="nc" id="L714">        removed.setCount(key, count);</span>
      }
<span class="nc" id="L716">    }</span>
<span class="nc bnc" id="L717" title="All 2 branches missed.">    for (Entry&lt;E, Double&gt; key : removed.entrySet()) {</span>
<span class="nc" id="L718">      counter.remove(key.getKey());</span>
<span class="nc" id="L719">    }</span>
<span class="nc" id="L720">    return removed;</span>
  }

  /**
   * Removes all entries with keys that does not match one of the given patterns.
   *
   * @param counter The counter.
   * @param matchPatterns pattern for key to match
   * @return The set of discarded entries.
   */
  public static Set&lt;String&gt; retainMatchingKeys(Counter&lt;String&gt; counter, List&lt;Pattern&gt; matchPatterns) {
<span class="nc" id="L731">    Set&lt;String&gt; removed = Generics.newHashSet();</span>
<span class="nc bnc" id="L732" title="All 2 branches missed.">    for (String key : counter.keySet()) {</span>
<span class="nc" id="L733">      boolean matched = false;</span>
<span class="nc bnc" id="L734" title="All 2 branches missed.">      for (Pattern pattern : matchPatterns) {</span>
<span class="nc bnc" id="L735" title="All 2 branches missed.">        if (pattern.matcher(key).matches()) {</span>
<span class="nc" id="L736">          matched = true;</span>
<span class="nc" id="L737">          break;</span>
        }
<span class="nc" id="L739">      }</span>
<span class="nc bnc" id="L740" title="All 2 branches missed.">      if (!matched) {</span>
<span class="nc" id="L741">        removed.add(key);</span>
      }
<span class="nc" id="L743">    }</span>
<span class="nc bnc" id="L744" title="All 2 branches missed.">    for (String key : removed) {</span>
<span class="nc" id="L745">      counter.remove(key);</span>
<span class="nc" id="L746">    }</span>
<span class="nc" id="L747">    return removed;</span>
  }

  /**
   * Removes all entries with keys that does not match the given set of keys.
   *
   * @param counter The counter
   * @param matchKeys Keys to match
   * @return The set of discarded entries.
   */
  public static&lt;E&gt; Set&lt;E&gt; retainKeys(Counter&lt;E&gt; counter, Collection&lt;E&gt; matchKeys) {
<span class="nc" id="L758">    Set&lt;E&gt; removed = Generics.newHashSet();</span>
<span class="nc bnc" id="L759" title="All 2 branches missed.">    for (E key : counter.keySet()) {</span>
<span class="nc" id="L760">      boolean matched = matchKeys.contains(key);</span>
<span class="nc bnc" id="L761" title="All 2 branches missed.">      if (!matched) {</span>
<span class="nc" id="L762">        removed.add(key);</span>
      }
<span class="nc" id="L764">    }</span>
<span class="nc bnc" id="L765" title="All 2 branches missed.">    for (E key : removed) {</span>
<span class="nc" id="L766">      counter.remove(key);</span>
<span class="nc" id="L767">    }</span>
<span class="nc" id="L768">    return removed;</span>
  }

  /**
   * Removes all entries with keys in the given collection
   *
   * @param &lt;E&gt;
   * @param counter
   * @param removeKeysCollection
   */
  public static &lt;E&gt; void removeKeys(Counter&lt;E&gt; counter, Collection&lt;E&gt; removeKeysCollection) {

<span class="fc bfc" id="L780" title="All 2 branches covered.">    for (E key : removeKeysCollection)</span>
<span class="fc" id="L781">      counter.remove(key);</span>
<span class="fc" id="L782">  }</span>

  /**
   * Removes all entries with keys (first key set) in the given collection
   *
   * @param &lt;E&gt;
   * @param counter
   * @param removeKeysCollection
   */
  public static &lt;E, F&gt; void removeKeys(TwoDimensionalCounter&lt;E, F&gt; counter, Collection&lt;E&gt; removeKeysCollection) {

<span class="nc bnc" id="L793" title="All 2 branches missed.">    for (E key : removeKeysCollection)</span>
<span class="nc" id="L794">      counter.remove(key);</span>
<span class="nc" id="L795">  }</span>

  /**
   * Returns the set of keys whose counts are at or above the given threshold.
   * This set may have 0 elements but will not be null.
   *
   * @param c The Counter to examine
   * @param countThreshold
   *          Items equal to or above this number are kept
   * @return A (non-null) Set of keys whose counts are at or above the given
   *         threshold.
   */
  public static &lt;E&gt; Set&lt;E&gt; keysAbove(Counter&lt;E&gt; c, double countThreshold) {
<span class="fc" id="L808">    Set&lt;E&gt; keys = Generics.newHashSet();</span>
<span class="fc bfc" id="L809" title="All 2 branches covered.">    for (E key : c.keySet()) {</span>
<span class="fc bfc" id="L810" title="All 2 branches covered.">      if (c.getCount(key) &gt;= countThreshold) {</span>
<span class="fc" id="L811">        keys.add(key);</span>
      }
<span class="fc" id="L813">    }</span>
<span class="fc" id="L814">    return (keys);</span>
  }

  /**
   * Returns the set of keys whose counts are at or below the given threshold.
   * This set may have 0 elements but will not be null.
   */
  public static &lt;E&gt; Set&lt;E&gt; keysBelow(Counter&lt;E&gt; c, double countThreshold) {
<span class="fc" id="L822">    Set&lt;E&gt; keys = Generics.newHashSet();</span>
<span class="fc bfc" id="L823" title="All 2 branches covered.">    for (E key : c.keySet()) {</span>
<span class="fc bfc" id="L824" title="All 2 branches covered.">      if (c.getCount(key) &lt;= countThreshold) {</span>
<span class="fc" id="L825">        keys.add(key);</span>
      }
<span class="fc" id="L827">    }</span>
<span class="fc" id="L828">    return (keys);</span>
  }

  /**
   * Returns the set of keys that have exactly the given count. This set may
   * have 0 elements but will not be null.
   */
  public static &lt;E&gt; Set&lt;E&gt; keysAt(Counter&lt;E&gt; c, double count) {
<span class="fc" id="L836">    Set&lt;E&gt; keys = Generics.newHashSet();</span>
<span class="fc bfc" id="L837" title="All 2 branches covered.">    for (E key : c.keySet()) {</span>
<span class="fc bfc" id="L838" title="All 2 branches covered.">      if (c.getCount(key) == count) {</span>
<span class="fc" id="L839">        keys.add(key);</span>
      }
<span class="fc" id="L841">    }</span>
<span class="fc" id="L842">    return (keys);</span>
  }

  //
  // Transforms
  //

  /**
   * Returns the counter with keys modified according to function F. Eager
   * evaluation. If two keys are same after the transformation, one of the values is randomly chosen (depending on how the keyset is traversed)
   */
  public static &lt;T1, T2&gt; Counter&lt;T2&gt; transform(Counter&lt;T1&gt; c, Function&lt;T1, T2&gt; f) {
<span class="nc" id="L854">    Counter&lt;T2&gt; c2 = new ClassicCounter&lt;&gt;();</span>
<span class="nc bnc" id="L855" title="All 2 branches missed.">    for (T1 key : c.keySet()) {</span>
<span class="nc" id="L856">      c2.setCount(f.apply(key), c.getCount(key));</span>
<span class="nc" id="L857">    }</span>
<span class="nc" id="L858">    return c2;</span>
  }

  /**
   * Returns the counter with keys modified according to function F. If two keys are same after the transformation, their values get added up.
   */
  public static &lt;T1, T2&gt; Counter&lt;T2&gt; transformWithValuesAdd(Counter&lt;T1&gt; c, Function&lt;T1, T2&gt; f) {
<span class="fc" id="L865">    Counter&lt;T2&gt; c2 = new ClassicCounter&lt;&gt;();</span>
<span class="fc bfc" id="L866" title="All 2 branches covered.">    for (T1 key : c.keySet()) {</span>
<span class="fc" id="L867">      c2.incrementCount(f.apply(key), c.getCount(key));</span>
<span class="fc" id="L868">    }</span>
<span class="fc" id="L869">    return c2;</span>
  }

  //
  // Conversion to other types
  //

  /**
   * Returns a comparator backed by this counter: two objects are compared by
   * their associated values stored in the counter. This comparator returns keys
   * by ascending numeric value. Note that this ordering is not fixed, but
   * depends on the mutable values stored in the Counter. Doing this comparison
   * does not depend on the type of the key, since it uses the numeric value,
   * which is always Comparable.
   *
   * @param counter The Counter whose values are used for ordering the keys
   * @return A Comparator using this ordering
   */
  public static &lt;E&gt; Comparator&lt;E&gt; toComparator(final Counter&lt;E&gt; counter) {
<span class="fc" id="L888">    return (o1, o2) -&gt; Double.compare(counter.getCount(o1), counter.getCount(o2));</span>
  }

  /**
   * Returns a comparator backed by this counter: two objects are compared by
   * their associated values stored in the counter. This comparator returns keys
   * by ascending numeric value. Note that this ordering is not fixed, but
   * depends on the mutable values stored in the Counter. Doing this comparison
   * does not depend on the type of the key, since it uses the numeric value,
   * which is always Comparable.
   *
   * @param counter The Counter whose values are used for ordering the keys
   * @return A Comparator using this ordering
   */
  public static &lt;E extends Comparable&lt;E&gt;&gt; Comparator&lt;E&gt; toComparatorWithKeys(final Counter&lt;E&gt; counter) {
<span class="nc" id="L903">    return (o1, o2) -&gt; {</span>
<span class="nc" id="L904">      int res = Double.compare(counter.getCount(o1), counter.getCount(o2));</span>
<span class="nc bnc" id="L905" title="All 2 branches missed.">      if (res == 0) {</span>
<span class="nc" id="L906">        return o1.compareTo(o2);</span>
      } else {
<span class="nc" id="L908">        return res;</span>
      }
    };
  }

  /**
   * Returns a comparator backed by this counter: two objects are compared by
   * their associated values stored in the counter. This comparator returns keys
   * by descending numeric value. Note that this ordering is not fixed, but
   * depends on the mutable values stored in the Counter. Doing this comparison
   * does not depend on the type of the key, since it uses the numeric value,
   * which is always Comparable.
   *
   * @param counter The Counter whose values are used for ordering the keys
   * @return A Comparator using this ordering
   */
  public static &lt;E&gt; Comparator&lt;E&gt; toComparatorDescending(final Counter&lt;E&gt; counter) {
<span class="fc" id="L925">    return (o1, o2) -&gt; Double.compare(counter.getCount(o2), counter.getCount(o1));</span>
  }

  /**
   * Returns a comparator suitable for sorting this Counter's keys or entries by
   * their respective value or magnitude (by absolute value). If
   * &lt;tt&gt;ascending&lt;/tt&gt; is true, smaller magnitudes will be returned first,
   * otherwise higher magnitudes will be returned first.
   * &lt;p/&gt;
   * Sample usage:
   *
   * &lt;pre&gt;
   * Counter c = new Counter();
   * // add to the counter...
   * List biggestAbsKeys = new ArrayList(c.keySet());
   * Collections.sort(biggestAbsKeys, Counters.comparator(c, false, true));
   * List smallestEntries = new ArrayList(c.entrySet());
   * Collections.sort(smallestEntries, Counters.comparator(c, true, false));
   * &lt;/pre&gt;
   */
  public static &lt;E&gt; Comparator&lt;E&gt; toComparator(final Counter&lt;E&gt; counter, final boolean ascending, final boolean useMagnitude) {
<span class="fc" id="L946">    return (o1, o2) -&gt; {</span>
<span class="fc bfc" id="L947" title="All 2 branches covered.">      if (ascending) {</span>
<span class="pc bpc" id="L948" title="1 of 2 branches missed.">        if (useMagnitude) {</span>
<span class="fc" id="L949">          return Double.compare(Math.abs(counter.getCount(o1)), Math.abs(counter.getCount(o2)));</span>
        } else {
<span class="nc" id="L951">          return Double.compare(counter.getCount(o1), counter.getCount(o2));</span>
        }
      } else {
        // Descending
<span class="fc bfc" id="L955" title="All 2 branches covered.">        if (useMagnitude) {</span>
<span class="fc" id="L956">          return Double.compare(Math.abs(counter.getCount(o2)), Math.abs(counter.getCount(o1)));</span>
        } else {
<span class="fc" id="L958">          return Double.compare(counter.getCount(o2), counter.getCount(o1));</span>
        }
      }
    };
  }

  /**
   * A List of the keys in c, sorted from highest count to lowest.
   * So note that the default is descending!
   *
   * @return A List of the keys in c, sorted from highest count to lowest.
   */
  public static &lt;E&gt; List&lt;E&gt; toSortedList(Counter&lt;E&gt; c) {
<span class="fc" id="L971">    return toSortedList(c, false);</span>
  }

  /**
   * A List of the keys in c, sorted from highest count to lowest.
   *
   * @return A List of the keys in c, sorted from highest count to lowest.
   */
  public static &lt;E&gt; List&lt;E&gt; toSortedList(Counter&lt;E&gt; c, boolean ascending) {
<span class="fc" id="L980">    List&lt;E&gt; l = new ArrayList&lt;&gt;(c.keySet());</span>
<span class="fc bfc" id="L981" title="All 2 branches covered.">    Comparator&lt;E&gt; comp = ascending ? toComparator(c) : toComparatorDescending(c);</span>
<span class="fc" id="L982">    Collections.sort(l, comp);</span>
<span class="fc" id="L983">    return l;</span>
  }

  /**
   * A List of the keys in c, sorted from highest count to lowest.
   *
   * @return A List of the keys in c, sorted from highest count to lowest.
   */
  public static &lt;E extends Comparable&lt;E&gt;&gt; List&lt;E&gt; toSortedListKeyComparable(Counter&lt;E&gt; c) {
<span class="nc" id="L992">    List&lt;E&gt; l = new ArrayList&lt;&gt;(c.keySet());</span>
<span class="nc" id="L993">    Comparator&lt;E&gt; comp = toComparatorWithKeys(c);</span>
<span class="nc" id="L994">    Collections.sort(l, comp);</span>
<span class="nc" id="L995">    Collections.reverse(l);</span>
<span class="nc" id="L996">    return l;</span>
  }

  /**
   * Converts a counter to ranks; ranks start from 0
   *
   * @return A counter where the count is the rank in the original counter
   */
  public static &lt;E&gt; IntCounter&lt;E&gt; toRankCounter(Counter&lt;E&gt; c) {
<span class="nc" id="L1005">    IntCounter&lt;E&gt; rankCounter = new IntCounter&lt;&gt;();</span>
<span class="nc" id="L1006">    List&lt;E&gt; sortedList = toSortedList(c);</span>
<span class="nc bnc" id="L1007" title="All 2 branches missed.">    for (int i = 0; i &lt; sortedList.size(); i++) {</span>
<span class="nc" id="L1008">      rankCounter.setCount(sortedList.get(i), i);</span>
    }
<span class="nc" id="L1010">    return rankCounter;</span>
  }

  /**
   * Converts a counter to tied ranks; ranks start from 1
   *
   * @return A counter where the count is the rank in the original counter; when values are tied, the rank is the average of the ranks of the tied values
   */
  public static &lt;E&gt; Counter&lt;E&gt; toTiedRankCounter(Counter&lt;E&gt; c) {
<span class="fc" id="L1019">    Counter&lt;E&gt; rankCounter = new ClassicCounter&lt;&gt;();</span>
<span class="fc" id="L1020">    List&lt;Pair&lt;E, Double&gt;&gt; sortedList = toSortedListWithCounts(c);</span>

<span class="fc" id="L1022">    int i = 0;</span>
<span class="fc" id="L1023">    Iterator&lt;Pair&lt;E, Double&gt;&gt; it = sortedList.iterator();</span>
<span class="fc bfc" id="L1024" title="All 2 branches covered.">    while(it.hasNext()) {</span>
<span class="fc" id="L1025">      Pair&lt;E, Double&gt; iEn = it.next();</span>
<span class="fc" id="L1026">      double icount = iEn.second();</span>
<span class="fc" id="L1027">      E iKey = iEn.first();</span>

<span class="fc" id="L1029">      List&lt;Integer&gt; l = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1030">      List&lt;E&gt; keys = new ArrayList&lt;&gt;();</span>


<span class="fc" id="L1033">      l.add(i+1);</span>
<span class="fc" id="L1034">      keys.add(iKey);</span>

<span class="fc bfc" id="L1036" title="All 2 branches covered.">      for(int j = i +1; j &lt; sortedList.size(); j++){</span>
<span class="fc" id="L1037">        Pair&lt;E, Double&gt; jEn = sortedList.get(j);</span>
<span class="fc bfc" id="L1038" title="All 2 branches covered.">        if( icount == jEn.second()){</span>
<span class="fc" id="L1039">          l.add(j+1);</span>
<span class="fc" id="L1040">          keys.add(jEn.first());</span>
        }else
          break;
      }

<span class="fc bfc" id="L1045" title="All 2 branches covered.">      if(l.size() &gt; 1){</span>
<span class="fc" id="L1046">        double sum = 0;</span>
<span class="fc bfc" id="L1047" title="All 2 branches covered.">        for(Integer d: l)</span>
<span class="fc" id="L1048">          sum += d;</span>
<span class="fc" id="L1049">        double avgRank = sum/l.size();</span>
<span class="fc bfc" id="L1050" title="All 2 branches covered.">        for(int k = 0; k &lt; l.size(); k++){</span>
<span class="fc" id="L1051">          rankCounter.setCount(keys.get(k), avgRank);</span>
<span class="pc bpc" id="L1052" title="1 of 4 branches missed.">          if(k != l.size()-1 &amp;&amp; it.hasNext())</span>
<span class="fc" id="L1053">            it.next();</span>
<span class="fc" id="L1054">          i++;</span>
        }
<span class="fc" id="L1056">      }else{</span>
<span class="fc" id="L1057">        rankCounter.setCount(iKey, i+1);</span>
<span class="fc" id="L1058">        i++;</span>
      }
<span class="fc" id="L1060">    }</span>
<span class="fc" id="L1061">    return rankCounter;</span>
  }

  public static &lt;E&gt; List&lt;Pair&lt;E, Double&gt;&gt; toDescendingMagnitudeSortedListWithCounts(Counter&lt;E&gt; c) {
<span class="nc" id="L1065">    List&lt;E&gt; keys = new ArrayList&lt;&gt;(c.keySet());</span>
<span class="nc" id="L1066">    Collections.sort(keys, toComparator(c, false, true));</span>
<span class="nc" id="L1067">    List&lt;Pair&lt;E, Double&gt;&gt; l = new ArrayList&lt;&gt;(keys.size());</span>

<span class="nc bnc" id="L1069" title="All 2 branches missed.">    for (E key : keys) {</span>
<span class="nc" id="L1070">      l.add(new Pair&lt;&gt;(key, c.getCount(key)));</span>
<span class="nc" id="L1071">    }</span>

<span class="nc" id="L1073">    return l;</span>
  }

  /**
   * A List of the keys in c, sorted from highest count to lowest, paired with
   * counts
   *
   * @return A List of the keys in c, sorted from highest count to lowest.
   */
  public static &lt;E&gt; List&lt;Pair&lt;E, Double&gt;&gt; toSortedListWithCounts(Counter&lt;E&gt; c) {
<span class="fc" id="L1083">    List&lt;Pair&lt;E, Double&gt;&gt; l = new ArrayList&lt;&gt;(c.size());</span>
<span class="fc bfc" id="L1084" title="All 2 branches covered.">    for (E e : c.keySet()) {</span>
<span class="fc" id="L1085">      l.add(new Pair&lt;&gt;(e, c.getCount(e)));</span>
<span class="fc" id="L1086">    }</span>
    // descending order
<span class="fc" id="L1088">    Collections.sort(l, (a, b) -&gt; Double.compare(b.second, a.second));</span>
<span class="fc" id="L1089">    return l;</span>
  }

  /**
   * A List of the keys in c, sorted by the given comparator, paired with
   * counts.
   *
   * @return A List of the keys in c, sorted from highest count to lowest.
   */
  public static &lt;E&gt; List&lt;Pair&lt;E, Double&gt;&gt; toSortedListWithCounts(Counter&lt;E&gt; c, Comparator&lt;Pair&lt;E,Double&gt;&gt; comparator) {
<span class="nc" id="L1099">    List&lt;Pair&lt;E, Double&gt;&gt; l = new ArrayList&lt;&gt;(c.size());</span>
<span class="nc bnc" id="L1100" title="All 2 branches missed.">    for (E e : c.keySet()) {</span>
<span class="nc" id="L1101">      l.add(new Pair&lt;&gt;(e, c.getCount(e)));</span>
<span class="nc" id="L1102">    }</span>
    // descending order
<span class="nc" id="L1104">    Collections.sort(l, comparator);</span>
<span class="nc" id="L1105">    return l;</span>
  }

  /**
   * Returns a {@link edu.stanford.nlp.util.PriorityQueue} whose elements are
   * the keys of Counter c, and the score of each key in c becomes its priority.
   *
   * @param c Input Counter
   * @return A PriorityQueue where the count is a key's priority
   */
  // TODO: rewrite to use entrySet()
  public static &lt;E&gt; edu.stanford.nlp.util.PriorityQueue&lt;E&gt; toPriorityQueue(Counter&lt;E&gt; c) {
<span class="fc" id="L1117">    edu.stanford.nlp.util.PriorityQueue&lt;E&gt; queue = new BinaryHeapPriorityQueue&lt;&gt;();</span>
<span class="fc bfc" id="L1118" title="All 2 branches covered.">    for (E key : c.keySet()) {</span>
<span class="fc" id="L1119">      double count = c.getCount(key);</span>
<span class="fc" id="L1120">      queue.add(key, count);</span>
<span class="fc" id="L1121">    }</span>
<span class="fc" id="L1122">    return queue;</span>
  }

  //
  // Other Utilities
  //

  /**
   * Returns a Counter that is the union of the two Counters passed in (counts
   * are added).
   *
   * @return A Counter that is the union of the two Counters passed in (counts
   *         are added).
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static &lt;E, C extends Counter&lt;E&gt;&gt; C union(C c1, C c2) {
<span class="fc" id="L1138">    C result = (C) c1.getFactory().create();</span>
<span class="fc" id="L1139">    addInPlace(result, c1);</span>
<span class="fc" id="L1140">    addInPlace(result, c2);</span>
<span class="fc" id="L1141">    return result;</span>
  }

  /**
   * Returns a counter that is the intersection of c1 and c2. If both c1 and c2
   * contain a key, the min of the two counts is used.
   *
   * @return A counter that is the intersection of c1 and c2
   */
  public static &lt;E&gt; Counter&lt;E&gt; intersection(Counter&lt;E&gt; c1, Counter&lt;E&gt; c2) {
<span class="fc" id="L1151">    Counter&lt;E&gt; result = c1.getFactory().create();</span>
<span class="fc bfc" id="L1152" title="All 2 branches covered.">    for (E key : Sets.union(c1.keySet(), c2.keySet())) {</span>
<span class="fc" id="L1153">      double count1 = c1.getCount(key);</span>
<span class="fc" id="L1154">      double count2 = c2.getCount(key);</span>
<span class="fc bfc" id="L1155" title="All 2 branches covered.">      double minCount = (count1 &lt; count2 ? count1 : count2);</span>
<span class="fc bfc" id="L1156" title="All 2 branches covered.">      if (minCount &gt; 0) {</span>
<span class="fc" id="L1157">        result.setCount(key, minCount);</span>
      }
<span class="fc" id="L1159">    }</span>
<span class="fc" id="L1160">    return result;</span>
  }

  /**
   * Returns the Jaccard Coefficient of the two counters. Calculated as |c1
   * intersect c2| / ( |c1| + |c2| - |c1 intersect c2|
   *
   * @return The Jaccard Coefficient of the two counters
   */
  public static &lt;E&gt; double jaccardCoefficient(Counter&lt;E&gt; c1, Counter&lt;E&gt; c2) {
<span class="nc" id="L1170">    double minCount = 0.0, maxCount = 0.0;</span>
<span class="nc bnc" id="L1171" title="All 2 branches missed.">    for (E key : Sets.union(c1.keySet(), c2.keySet())) {</span>
<span class="nc" id="L1172">      double count1 = c1.getCount(key);</span>
<span class="nc" id="L1173">      double count2 = c2.getCount(key);</span>
<span class="nc bnc" id="L1174" title="All 2 branches missed.">      minCount += (count1 &lt; count2 ? count1 : count2);</span>
<span class="nc bnc" id="L1175" title="All 2 branches missed.">      maxCount += (count1 &gt; count2 ? count1 : count2);</span>
<span class="nc" id="L1176">    }</span>
<span class="nc" id="L1177">    return minCount / maxCount;</span>
  }

  /**
   * Returns the product of c1 and c2.
   *
   * @return The product of c1 and c2.
   */
  public static &lt;E&gt; Counter&lt;E&gt; product(Counter&lt;E&gt; c1, Counter&lt;E&gt; c2) {
<span class="fc" id="L1186">    Counter&lt;E&gt; result = c1.getFactory().create();</span>
<span class="fc bfc" id="L1187" title="All 2 branches covered.">    for (E key : Sets.intersection(c1.keySet(), c2.keySet())) {</span>
<span class="fc" id="L1188">      result.setCount(key, c1.getCount(key) * c2.getCount(key));</span>
<span class="fc" id="L1189">    }</span>
<span class="fc" id="L1190">    return result;</span>
  }

  /**
   * Returns the product of c1 and c2.
   *
   * @return The product of c1 and c2.
   */
  public static &lt;E&gt; double dotProduct(Counter&lt;E&gt; c1, Counter&lt;E&gt; c2) {
<span class="fc" id="L1199">    double dotProd = 0.0;</span>
<span class="pc bpc" id="L1200" title="1 of 2 branches missed.">    if (c1.size() &gt; c2.size()) {</span>
<span class="nc" id="L1201">      Counter&lt;E&gt; tmpCnt = c1;</span>
<span class="nc" id="L1202">      c1 = c2;</span>
<span class="nc" id="L1203">      c2 = tmpCnt;</span>
    }
<span class="fc bfc" id="L1205" title="All 2 branches covered.">    for (E key : c1.keySet()) {</span>
<span class="fc" id="L1206">      double count1 = c1.getCount(key);</span>
<span class="pc bpc" id="L1207" title="2 of 4 branches missed.">      if (Double.isNaN(count1) || Double.isInfinite(count1)) {</span>
<span class="nc" id="L1208">        throw new RuntimeException(&quot;Counters.dotProduct infinite or NaN value for key: &quot; + key + '\t' + c1.getCount(key) + '\t' + c2.getCount(key));</span>
      }
<span class="pc bpc" id="L1210" title="1 of 2 branches missed.">      if (count1 != 0.0) {</span>
<span class="fc" id="L1211">        double count2 = c2.getCount(key);</span>
<span class="pc bpc" id="L1212" title="2 of 4 branches missed.">        if (Double.isNaN(count2) || Double.isInfinite(count2)) {</span>
<span class="nc" id="L1213">          throw new RuntimeException(&quot;Counters.dotProduct infinite or NaN value for key: &quot; + key + '\t' + c1.getCount(key) + '\t' + c2.getCount(key));</span>
        }
<span class="fc bfc" id="L1215" title="All 2 branches covered.">        if (count2 != 0.0) {</span>
          // this is the inner product
<span class="fc" id="L1217">          dotProd += (count1 * count2);</span>
        }
      }
<span class="fc" id="L1220">    }</span>
<span class="fc" id="L1221">    return dotProd;</span>
  }

  /**
   * Returns the product of Counter c and double[] a, using Index idx to map
   * entries in C onto a.
   *
   * @return The product of c and a.
   */
  public static &lt;E&gt; double dotProduct(Counter&lt;E&gt; c, double[] a, Index&lt;E&gt; idx) {
<span class="nc" id="L1231">    double dotProd = 0.0;</span>
<span class="nc bnc" id="L1232" title="All 2 branches missed.">    for (Map.Entry&lt;E, Double&gt; entry : c.entrySet()) {</span>
<span class="nc" id="L1233">      int keyIdx = idx.indexOf(entry.getKey());</span>
<span class="nc bnc" id="L1234" title="All 2 branches missed.">      if (keyIdx &gt;= 0) {</span>
<span class="nc" id="L1235">        dotProd += entry.getValue() * a[keyIdx];</span>
      }
<span class="nc" id="L1237">    }</span>
<span class="nc" id="L1238">    return dotProd;</span>
  }

  public static &lt;E&gt; double sumEntries(Counter&lt;E&gt; c1, Collection&lt;E&gt; entries) {
<span class="nc" id="L1242">    double dotProd = 0.0;</span>
<span class="nc bnc" id="L1243" title="All 2 branches missed.">    for (E entry : entries) {</span>
<span class="nc" id="L1244">      dotProd += c1.getCount(entry);</span>
<span class="nc" id="L1245">    }</span>
<span class="nc" id="L1246">    return dotProd;</span>
  }


  public static &lt;E&gt; Counter&lt;E&gt; add(Counter&lt;E&gt; c1, Collection&lt;E&gt; c2) {
<span class="nc" id="L1251">    Counter&lt;E&gt; result = c1.getFactory().create();</span>
<span class="nc" id="L1252">    addInPlace(result, c1);</span>
<span class="nc bnc" id="L1253" title="All 2 branches missed.">    for (E key : c2) {</span>
<span class="nc" id="L1254">      result.incrementCount(key, 1);</span>
<span class="nc" id="L1255">    }</span>
<span class="nc" id="L1256">    return result;</span>
  }

  public static &lt;E&gt; Counter&lt;E&gt; add(Counter&lt;E&gt; c1, Counter&lt;E&gt; c2) {
<span class="nc" id="L1260">    Counter&lt;E&gt; result = c1.getFactory().create();</span>
<span class="nc bnc" id="L1261" title="All 2 branches missed.">    for (E key : Sets.union(c1.keySet(), c2.keySet())) {</span>
<span class="nc" id="L1262">      result.setCount(key, c1.getCount(key) + c2.getCount(key));</span>
<span class="nc" id="L1263">    }</span>
<span class="nc" id="L1264">    retainNonZeros(result);</span>
<span class="nc" id="L1265">    return result;</span>
  }

  /**
   * increments every key in the counter by value
   */
  public static &lt;E&gt; Counter&lt;E&gt; add(Counter&lt;E&gt; c1, double value) {
<span class="fc" id="L1272">    Counter&lt;E&gt; result = c1.getFactory().create();</span>
<span class="fc bfc" id="L1273" title="All 2 branches covered.">    for (E key : c1.keySet()) {</span>
<span class="fc" id="L1274">      result.setCount(key, c1.getCount(key) + value);</span>
<span class="fc" id="L1275">    }</span>
<span class="fc" id="L1276">    return result;</span>
  }

  /**
   * This method does not check entries for NAN or INFINITY values in the
   * doubles returned. It also only iterates over the counter with the smallest
   * number of keys to help speed up computation. Pair this method with
   * normalizing your counters before hand and you have a reasonably quick
   * implementation of cosine.
   *
   * @param &lt;E&gt;
   * @param c1
   * @param c2
   * @return The dot product of the two counter (as vectors)
   */
  public static &lt;E&gt; double optimizedDotProduct(Counter&lt;E&gt; c1, Counter&lt;E&gt; c2) {
<span class="fc" id="L1292">    int size1 = c1.size();</span>
<span class="fc" id="L1293">    int size2 = c2.size();</span>
<span class="fc bfc" id="L1294" title="All 2 branches covered.">    if (size1 &lt; size2) {</span>
<span class="fc" id="L1295">      return getDotProd(c1, c2);</span>
    } else {
<span class="fc" id="L1297">      return getDotProd(c2, c1);</span>
    }
  }

  private static &lt;E&gt; double getDotProd(Counter&lt;E&gt; c1, Counter&lt;E&gt; c2) {
<span class="fc" id="L1302">    double dotProd = 0.0;</span>
<span class="fc bfc" id="L1303" title="All 2 branches covered.">    for (E key : c1.keySet()) {</span>
<span class="fc" id="L1304">      double count1 = c1.getCount(key);</span>
<span class="pc bpc" id="L1305" title="1 of 2 branches missed.">      if (count1 != 0.0) {</span>
<span class="fc" id="L1306">        double count2 = c2.getCount(key);</span>
<span class="fc bfc" id="L1307" title="All 2 branches covered.">        if (count2 != 0.0)</span>
<span class="fc" id="L1308">          dotProd += (count1 * count2);</span>
      }
<span class="fc" id="L1310">    }</span>
<span class="fc" id="L1311">    return dotProd;</span>
  }

  /**
   * Returns |c1 - c2|.
   *
   * @return The difference between sets c1 and c2.
   */
  public static &lt;E&gt; Counter&lt;E&gt; absoluteDifference(Counter&lt;E&gt; c1, Counter&lt;E&gt; c2) {
<span class="fc" id="L1320">    Counter&lt;E&gt; result = c1.getFactory().create();</span>
<span class="fc bfc" id="L1321" title="All 2 branches covered.">    for (E key : Sets.union(c1.keySet(), c2.keySet())) {</span>
<span class="fc" id="L1322">      double newCount = Math.abs(c1.getCount(key) - c2.getCount(key));</span>
<span class="pc bpc" id="L1323" title="1 of 2 branches missed.">      if (newCount &gt; 0) {</span>
<span class="fc" id="L1324">        result.setCount(key, newCount);</span>
      }
<span class="fc" id="L1326">    }</span>
<span class="fc" id="L1327">    return result;</span>
  }

  /**
   * Returns c1 divided by c2. Note that this can create NaN if c1 has non-zero
   * counts for keys that c2 has zero counts.
   *
   * @return c1 divided by c2.
   */
  public static &lt;E&gt; Counter&lt;E&gt; division(Counter&lt;E&gt; c1, Counter&lt;E&gt; c2) {
<span class="nc" id="L1337">    Counter&lt;E&gt; result = c1.getFactory().create();</span>
<span class="nc bnc" id="L1338" title="All 2 branches missed.">    for (E key : Sets.union(c1.keySet(), c2.keySet())) {</span>
<span class="nc" id="L1339">      result.setCount(key, c1.getCount(key) / c2.getCount(key));</span>
<span class="nc" id="L1340">    }</span>
<span class="nc" id="L1341">    return result;</span>
  }

  /**
   * Returns c1 divided by c2. Safe - will not calculate scores for keys that are zero or that do not exist in c2
   *
   * @return c1 divided by c2.
   */
  public static &lt;E&gt; Counter&lt;E&gt; divisionNonNaN(Counter&lt;E&gt; c1, Counter&lt;E&gt; c2) {
<span class="nc" id="L1350">    Counter&lt;E&gt; result = c1.getFactory().create();</span>
<span class="nc bnc" id="L1351" title="All 2 branches missed.">    for (E key : Sets.union(c1.keySet(), c2.keySet())) {</span>
<span class="nc bnc" id="L1352" title="All 2 branches missed.">      if(c2.getCount(key) != 0)</span>
<span class="nc" id="L1353">        result.setCount(key, c1.getCount(key) / c2.getCount(key));</span>
<span class="nc" id="L1354">    }</span>
<span class="nc" id="L1355">    return result;</span>
  }


  /**
   * Calculates the entropy of the given counter (in bits). This method
   * internally uses normalized counts (so they sum to one), but the value
   * returned is meaningless if some of the counts are negative.
   *
   * @return The entropy of the given counter (in bits)
   */
  public static &lt;E&gt; double entropy(Counter&lt;E&gt; c) {
<span class="nc" id="L1367">    double entropy = 0.0;</span>
<span class="nc" id="L1368">    double total = c.totalCount();</span>
<span class="nc bnc" id="L1369" title="All 2 branches missed.">    for (E key : c.keySet()) {</span>
<span class="nc" id="L1370">      double count = c.getCount(key);</span>
<span class="nc bnc" id="L1371" title="All 2 branches missed.">      if (count == 0) {</span>
<span class="nc" id="L1372">        continue; // 0.0 doesn't add entropy but may cause -Inf</span>
      }
<span class="nc" id="L1374">      count /= total; // use normalized count</span>
<span class="nc" id="L1375">      entropy -= count * (Math.log(count) / LOG_E_2);</span>
<span class="nc" id="L1376">    }</span>
<span class="nc" id="L1377">    return entropy;</span>
  }

  /**
   * Note that this implementation doesn't normalize the &quot;from&quot; Counter. It
   * does, however, normalize the &quot;to&quot; Counter. Result is meaningless if any of
   * the counts are negative.
   *
   * @return The cross entropy of H(from, to)
   */
  public static &lt;E&gt; double crossEntropy(Counter&lt;E&gt; from, Counter&lt;E&gt; to) {
<span class="nc" id="L1388">    double tot2 = to.totalCount();</span>
<span class="nc" id="L1389">    double result = 0.0;</span>
<span class="nc bnc" id="L1390" title="All 2 branches missed.">    for (E key : from.keySet()) {</span>
<span class="nc" id="L1391">      double count1 = from.getCount(key);</span>
<span class="nc bnc" id="L1392" title="All 2 branches missed.">      if (count1 == 0.0) {</span>
<span class="nc" id="L1393">        continue;</span>
      }
<span class="nc" id="L1395">      double count2 = to.getCount(key);</span>
<span class="nc" id="L1396">      double logFract = Math.log(count2 / tot2);</span>
<span class="nc bnc" id="L1397" title="All 2 branches missed.">      if (logFract == Double.NEGATIVE_INFINITY) {</span>
<span class="nc" id="L1398">        return Double.NEGATIVE_INFINITY; // can't recover</span>
      }
<span class="nc" id="L1400">      result += count1 * (logFract / LOG_E_2); // express it in log base 2</span>
<span class="nc" id="L1401">    }</span>
<span class="nc" id="L1402">    return result;</span>
  }

  /**
   * Calculates the KL divergence between the two counters. That is, it
   * calculates KL(from || to). This method internally uses normalized counts
   * (so they sum to one), but the value returned is meaningless if any of the
   * counts are negative. In other words, how well can c1 be represented by c2.
   * if there is some value in c1 that gets zero prob in c2, then return
   * positive infinity.
   *
   * @return The KL divergence between the distributions
   */
  public static &lt;E&gt; double klDivergence(Counter&lt;E&gt; from, Counter&lt;E&gt; to) {
<span class="fc" id="L1416">    double result = 0.0;</span>
<span class="fc" id="L1417">    double tot = (from.totalCount());</span>
<span class="fc" id="L1418">    double tot2 = (to.totalCount());</span>
    // System.out.println(&quot;tot is &quot; + tot + &quot; tot2 is &quot; + tot2);
<span class="fc bfc" id="L1420" title="All 2 branches covered.">    for (E key : from.keySet()) {</span>
<span class="fc" id="L1421">      double num = (from.getCount(key));</span>
<span class="fc bfc" id="L1422" title="All 2 branches covered.">      if (num == 0) {</span>
<span class="fc" id="L1423">        continue;</span>
      }
<span class="fc" id="L1425">      num /= tot;</span>
<span class="fc" id="L1426">      double num2 = (to.getCount(key));</span>
<span class="fc" id="L1427">      num2 /= tot2;</span>
      // System.out.println(&quot;num is &quot; + num + &quot; num2 is &quot; + num2);
<span class="fc" id="L1429">      double logFract = Math.log(num / num2);</span>
<span class="pc bpc" id="L1430" title="1 of 2 branches missed.">      if (logFract == Double.NEGATIVE_INFINITY) {</span>
<span class="nc" id="L1431">        return Double.NEGATIVE_INFINITY; // can't recover</span>
      }
<span class="fc" id="L1433">      result += num * (logFract / LOG_E_2); // express it in log base 2</span>
<span class="fc" id="L1434">    }</span>
<span class="fc" id="L1435">    return result;</span>
  }

  /**
   * Calculates the Jensen-Shannon divergence between the two counters. That is,
   * it calculates 1/2 [KL(c1 || avg(c1,c2)) + KL(c2 || avg(c1,c2))] .
   * This code assumes that the Counters have only non-negative values in them.
   *
   * @return The Jensen-Shannon divergence between the distributions
   */
  public static &lt;E&gt; double jensenShannonDivergence(Counter&lt;E&gt; c1, Counter&lt;E&gt; c2) {
    // need to normalize the counters first before averaging them! Else buggy if not a probability distribution
<span class="fc" id="L1447">    Counter&lt;E&gt; d1 = asNormalizedCounter(c1);</span>
<span class="fc" id="L1448">    Counter&lt;E&gt; d2 = asNormalizedCounter(c2);</span>
<span class="fc" id="L1449">    Counter&lt;E&gt; average = average(d1, d2);</span>
<span class="fc" id="L1450">    double kl1 = klDivergence(d1, average);</span>
<span class="fc" id="L1451">    double kl2 = klDivergence(d2, average);</span>
<span class="fc" id="L1452">    return (kl1 + kl2) / 2.0;</span>
  }

  /**
   * Calculates the skew divergence between the two counters. That is, it
   * calculates KL(c1 || (c2*skew + c1*(1-skew))) . In other words, how well can
   * c1 be represented by a &quot;smoothed&quot; c2.
   *
   * @return The skew divergence between the distributions
   */
  public static &lt;E&gt; double skewDivergence(Counter&lt;E&gt; c1, Counter&lt;E&gt; c2, double skew) {
<span class="nc" id="L1463">    Counter&lt;E&gt; d1 = asNormalizedCounter(c1);</span>
<span class="nc" id="L1464">    Counter&lt;E&gt; d2 = asNormalizedCounter(c2);</span>
<span class="nc" id="L1465">    Counter&lt;E&gt; average = linearCombination(d2, skew, d1, (1.0 - skew));</span>
<span class="nc" id="L1466">    return klDivergence(d1, average);</span>
  }

  /**
   * Return the l2 norm (Euclidean vector length) of a Counter.
   * &lt;i&gt;Implementation note:&lt;/i&gt; The method name favors legibility of the L over
   * the convention of using lowercase names for methods.
   *
   * @param c The Counter
   * @return Its length
   */
  public static &lt;E, C extends Counter&lt;E&gt;&gt; double L2Norm(C c) {
<span class="fc" id="L1478">    return Math.sqrt(Counters.sumSquares(c));</span>
  }

  /**
   * Return the sum of squares (squared L2 norm).
   *
   * @param c The Counter
   * @return the L2 norm of the values in c
   */
  public static &lt;E, C extends Counter&lt;E&gt;&gt; double sumSquares(C c) {
<span class="fc" id="L1488">    double lenSq = 0.0;</span>
<span class="fc bfc" id="L1489" title="All 2 branches covered.">    for (E key : c.keySet()) {</span>
<span class="fc" id="L1490">      double count = c.getCount(key);</span>
<span class="fc" id="L1491">      lenSq += (count * count);</span>
<span class="fc" id="L1492">    }</span>
<span class="fc" id="L1493">    return lenSq;</span>
  }

  /**
   * Return the L1 norm of a counter. &lt;i&gt;Implementation note:&lt;/i&gt; The method
   * name favors legibility of the L over the convention of using lowercase
   * names for methods.
   *
   * @param c The Counter
   * @return Its length
   */
  public static &lt;E, C extends Counter&lt;E&gt;&gt; double L1Norm(C c) {
<span class="nc" id="L1505">    double sumAbs = 0.0;</span>
<span class="nc bnc" id="L1506" title="All 2 branches missed.">    for (E key : c.keySet()) {</span>
<span class="nc" id="L1507">      double count = c.getCount(key);</span>
<span class="nc bnc" id="L1508" title="All 2 branches missed.">      if (count != 0.0) {</span>
<span class="nc" id="L1509">        sumAbs += Math.abs(count);</span>
      }
<span class="nc" id="L1511">    }</span>
<span class="nc" id="L1512">    return sumAbs;</span>
  }

  /**
   * L2 normalize a counter.
   *
   * @param c The {@link Counter} to be L2 normalized. This counter is not
   *          modified.
   * @return A new l2-normalized Counter based on c.
   */
  public static &lt;E, C extends Counter&lt;E&gt;&gt; C L2Normalize(C c) {
<span class="fc" id="L1523">    return scale(c, 1.0 / L2Norm(c));</span>
  }

  /**
   * L2 normalize a counter in place.
   *
   * @param c The {@link Counter} to be L2 normalized. This counter is modified
   * @return the passed in counter l2-normalized
   */
  public static &lt;E&gt; Counter&lt;E&gt; L2NormalizeInPlace(Counter&lt;E&gt; c) {
<span class="nc" id="L1533">    return multiplyInPlace(c, 1.0 / L2Norm(c));</span>
  }

  /**
   * For counters with large # of entries, this scales down each entry in the
   * sum, to prevent an extremely large sum from building up and overwhelming
   * the max double. This may also help reduce error by preventing loss of SD's
   * with extremely large values.
   *
   * @param &lt;E&gt;
   * @param &lt;C&gt;
   */
  public static &lt;E, C extends Counter&lt;E&gt;&gt; double saferL2Norm(C c) {
<span class="nc" id="L1546">    double maxVal = 0.0;</span>
<span class="nc bnc" id="L1547" title="All 2 branches missed.">    for (E key : c.keySet()) {</span>
<span class="nc" id="L1548">      double value = Math.abs(c.getCount(key));</span>
<span class="nc bnc" id="L1549" title="All 2 branches missed.">      if (value &gt; maxVal)</span>
<span class="nc" id="L1550">        maxVal = value;</span>
<span class="nc" id="L1551">    }</span>
<span class="nc" id="L1552">    double sqrSum = 0.0;</span>
<span class="nc bnc" id="L1553" title="All 2 branches missed.">    for (E key : c.keySet()) {</span>
<span class="nc" id="L1554">      double count = c.getCount(key);</span>
<span class="nc" id="L1555">      sqrSum += Math.pow(count / maxVal, 2);</span>
<span class="nc" id="L1556">    }</span>
<span class="nc" id="L1557">    return maxVal * Math.sqrt(sqrSum);</span>
  }

  /**
   * L2 normalize a counter, using the &quot;safer&quot; L2 normalizer.
   *
   * @param c The {@link Counter} to be L2 normalized. This counter is not
   *          modified.
   * @return A new L2-normalized Counter based on c.
   */
  public static &lt;E, C extends Counter&lt;E&gt;&gt; C saferL2Normalize(C c) {
<span class="nc" id="L1568">    return scale(c, 1.0 / saferL2Norm(c));</span>
  }

  public static &lt;E&gt; double cosine(Counter&lt;E&gt; c1, Counter&lt;E&gt; c2) {
<span class="nc" id="L1572">    double dotProd = 0.0;</span>
<span class="nc" id="L1573">    double lsq1 = 0.0;</span>
<span class="nc" id="L1574">    double lsq2 = 0.0;</span>
<span class="nc bnc" id="L1575" title="All 2 branches missed.">    for (E key : c1.keySet()) {</span>
<span class="nc" id="L1576">      double count1 = c1.getCount(key);</span>
<span class="nc bnc" id="L1577" title="All 2 branches missed.">      if (count1 != 0.0) {</span>
<span class="nc" id="L1578">        lsq1 += (count1 * count1);</span>
<span class="nc" id="L1579">        double count2 = c2.getCount(key);</span>
<span class="nc bnc" id="L1580" title="All 2 branches missed.">        if (count2 != 0.0) {</span>
          // this is the inner product
<span class="nc" id="L1582">          dotProd += (count1 * count2);</span>
        }
      }
<span class="nc" id="L1585">    }</span>
<span class="nc bnc" id="L1586" title="All 2 branches missed.">    for (E key : c2.keySet()) {</span>
<span class="nc" id="L1587">      double count2 = c2.getCount(key);</span>
<span class="nc bnc" id="L1588" title="All 2 branches missed.">      if (count2 != 0.0) {</span>
<span class="nc" id="L1589">        lsq2 += (count2 * count2);</span>
      }
<span class="nc" id="L1591">    }</span>
<span class="nc bnc" id="L1592" title="All 4 branches missed.">    if (lsq1 != 0.0 &amp;&amp; lsq2 != 0.0) {</span>
<span class="nc" id="L1593">      double denom = (Math.sqrt(lsq1) * Math.sqrt(lsq2));</span>
<span class="nc" id="L1594">      return dotProd / denom;</span>
    }
<span class="nc" id="L1596">    return 0.0;</span>
  }

  /**
   * Returns a new Counter with counts averaged from the two given Counters. The
   * average Counter will contain the union of keys in both source Counters, and
   * each count will be the average of the two source counts for that key, where
   * as usual a missing count in one Counter is treated as count 0.
   *
   * @return A new counter with counts that are the mean of the resp. counts in
   *         the given counters.
   */
  public static &lt;E&gt; Counter&lt;E&gt; average(Counter&lt;E&gt; c1, Counter&lt;E&gt; c2) {
<span class="fc" id="L1609">    Counter&lt;E&gt; average = c1.getFactory().create();</span>
<span class="fc" id="L1610">    Set&lt;E&gt; allKeys = Generics.newHashSet(c1.keySet());</span>
<span class="fc" id="L1611">    allKeys.addAll(c2.keySet());</span>
<span class="fc bfc" id="L1612" title="All 2 branches covered.">    for (E key : allKeys) {</span>
<span class="fc" id="L1613">      average.setCount(key, (c1.getCount(key) + c2.getCount(key)) * 0.5);</span>
<span class="fc" id="L1614">    }</span>
<span class="fc" id="L1615">    return average;</span>
  }

  /**
   * Returns a Counter which is a weighted average of c1 and c2. Counts from c1
   * are weighted with weight w1 and counts from c2 are weighted with w2.
   */
  public static &lt;E&gt; Counter&lt;E&gt; linearCombination(Counter&lt;E&gt; c1, double w1, Counter&lt;E&gt; c2, double w2) {
<span class="nc" id="L1623">    Counter&lt;E&gt; result = c1.getFactory().create();</span>
<span class="nc bnc" id="L1624" title="All 2 branches missed.">    for (E o : c1.keySet()) {</span>
<span class="nc" id="L1625">      result.incrementCount(o, c1.getCount(o) * w1);</span>
<span class="nc" id="L1626">    }</span>
<span class="nc bnc" id="L1627" title="All 2 branches missed.">    for (E o : c2.keySet()) {</span>
<span class="nc" id="L1628">      result.incrementCount(o, c2.getCount(o) * w2);</span>
<span class="nc" id="L1629">    }</span>
<span class="nc" id="L1630">    return result;</span>
  }

  public static &lt;T1, T2&gt; double pointwiseMutualInformation(Counter&lt;T1&gt; var1Distribution, Counter&lt;T2&gt; var2Distribution, Counter&lt;Pair&lt;T1, T2&gt;&gt; jointDistribution, Pair&lt;T1, T2&gt; values) {
<span class="fc" id="L1634">    double var1Prob = var1Distribution.getCount(values.first);</span>
<span class="fc" id="L1635">    double var2Prob = var2Distribution.getCount(values.second);</span>
<span class="fc" id="L1636">    double jointProb = jointDistribution.getCount(values);</span>
<span class="fc" id="L1637">    double pmi = Math.log(jointProb) - Math.log(var1Prob) - Math.log(var2Prob);</span>
<span class="fc" id="L1638">    return pmi / LOG_E_2;</span>
  }

  /**
   * Calculate h-Index (Hirsch, 2005) of an author.
   *
   * A scientist has index h if h of their Np papers have at least h citations
   * each, and the other (Np − h) papers have at most h citations each.
   *
   * @param citationCounts
   *          Citation counts for each of the articles written by the author.
   *          The keys can be anything, but the values should be integers.
   * @return The h-Index of the author.
   */
  public static &lt;E&gt; int hIndex(Counter&lt;E&gt; citationCounts) {
<span class="fc" id="L1653">    Counter&lt;Integer&gt; countCounts = new ClassicCounter&lt;&gt;();</span>
<span class="fc bfc" id="L1654" title="All 2 branches covered.">    for (double value : citationCounts.values()) {</span>
<span class="fc bfc" id="L1655" title="All 2 branches covered.">      for (int i = 0; i &lt;= value; ++i) {</span>
<span class="fc" id="L1656">        countCounts.incrementCount(i);</span>
      }
<span class="fc" id="L1658">    }</span>
<span class="fc" id="L1659">    List&lt;Integer&gt; citationCountValues = CollectionUtils.sorted(countCounts.keySet());</span>
<span class="fc" id="L1660">    Collections.reverse(citationCountValues);</span>
<span class="fc bfc" id="L1661" title="All 2 branches covered.">    for (int citationCount : citationCountValues) {</span>
<span class="fc" id="L1662">      double occurrences = countCounts.getCount(citationCount);</span>
<span class="fc bfc" id="L1663" title="All 2 branches covered.">      if (occurrences &gt;= citationCount) {</span>
<span class="fc" id="L1664">        return citationCount;</span>
      }
<span class="fc" id="L1666">    }</span>
<span class="fc" id="L1667">    return 0;</span>
  }

  @SuppressWarnings(&quot;unchecked&quot;)
  public static &lt;E, C extends Counter&lt;E&gt;&gt; C perturbCounts(C c, Random random, double p) {
<span class="nc" id="L1672">    C result = (C) c.getFactory().create();</span>
<span class="nc bnc" id="L1673" title="All 2 branches missed.">    for (E key : c.keySet()) {</span>
<span class="nc" id="L1674">      double count = c.getCount(key);</span>
<span class="nc" id="L1675">      double noise = -Math.log(1.0 - random.nextDouble()); // inverse of CDF for</span>
                                                           // exponential
                                                           // distribution
      // log.info(&quot;noise=&quot; + noise);
<span class="nc" id="L1679">      double perturbedCount = count + noise * p;</span>
<span class="nc" id="L1680">      result.setCount(key, perturbedCount);</span>
<span class="nc" id="L1681">    }</span>
<span class="nc" id="L1682">    return result;</span>
  }

  /**
   * Great for debugging.
   *
   */
  public static &lt;E&gt; void printCounterComparison(Counter&lt;E&gt; a, Counter&lt;E&gt; b) {
<span class="nc" id="L1690">    printCounterComparison(a, b, System.err);</span>
<span class="nc" id="L1691">  }</span>

  /**
   * Great for debugging.
   *
   */
  public static &lt;E&gt; void printCounterComparison(Counter&lt;E&gt; a, Counter&lt;E&gt; b, PrintStream out) {
<span class="nc" id="L1698">    printCounterComparison(a, b, new PrintWriter(out, true));</span>
<span class="nc" id="L1699">  }</span>

  /**
   * Prints one or more lines (with a newline at the end) describing the
   * difference between the two Counters. Great for debugging.
   *
   */
  public static &lt;E&gt; void printCounterComparison(Counter&lt;E&gt; a, Counter&lt;E&gt; b, PrintWriter out) {
<span class="nc bnc" id="L1707" title="All 2 branches missed.">    if (a.equals(b)) {</span>
<span class="nc" id="L1708">      out.println(&quot;Counters are equal.&quot;);</span>
<span class="nc" id="L1709">      return;</span>
    }
<span class="nc bnc" id="L1711" title="All 2 branches missed.">    for (E key : a.keySet()) {</span>
<span class="nc" id="L1712">      double aCount = a.getCount(key);</span>
<span class="nc" id="L1713">      double bCount = b.getCount(key);</span>
<span class="nc bnc" id="L1714" title="All 2 branches missed.">      if (Math.abs(aCount - bCount) &gt; 1e-5) {</span>
<span class="nc" id="L1715">        out.println(&quot;Counters differ on key &quot; + key + '\t' + a.getCount(key) + &quot; vs. &quot; + b.getCount(key));</span>
      }
<span class="nc" id="L1717">    }</span>
    // left overs
<span class="nc" id="L1719">    Set&lt;E&gt; rest = Generics.newHashSet(b.keySet());</span>
<span class="nc" id="L1720">    rest.removeAll(a.keySet());</span>

<span class="nc bnc" id="L1722" title="All 2 branches missed.">    for (E key : rest) {</span>
<span class="nc" id="L1723">      double aCount = a.getCount(key);</span>
<span class="nc" id="L1724">      double bCount = b.getCount(key);</span>
<span class="nc bnc" id="L1725" title="All 2 branches missed.">      if (Math.abs(aCount - bCount) &gt; 1e-5) {</span>
<span class="nc" id="L1726">        out.println(&quot;Counters differ on key &quot; + key + '\t' + a.getCount(key) + &quot; vs. &quot; + b.getCount(key));</span>
      }
<span class="nc" id="L1728">    }</span>
<span class="nc" id="L1729">  }</span>

  public static &lt;E&gt; Counter&lt;Double&gt; getCountCounts(Counter&lt;E&gt; c) {
<span class="nc" id="L1732">    Counter&lt;Double&gt; result = new ClassicCounter&lt;&gt;();</span>
<span class="nc bnc" id="L1733" title="All 2 branches missed.">    for (double v : c.values()) {</span>
<span class="nc" id="L1734">      result.incrementCount(v);</span>
<span class="nc" id="L1735">    }</span>
<span class="nc" id="L1736">    return result;</span>
  }

  /**
   * Returns a new Counter which is scaled by the given scale factor.
   *
   * @param c The counter to scale. It is not changed
   * @param s The constant to scale the counter by
   * @return A new Counter which is the argument scaled by the given scale
   *         factor.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static &lt;E, C extends Counter&lt;E&gt;&gt; C scale(C c, double s) {
<span class="fc" id="L1749">    C scaled = (C) c.getFactory().create();</span>
<span class="fc bfc" id="L1750" title="All 2 branches covered.">    for (E key : c.keySet()) {</span>
<span class="fc" id="L1751">      scaled.setCount(key, c.getCount(key) * s);</span>
<span class="fc" id="L1752">    }</span>
<span class="fc" id="L1753">    return scaled;</span>
  }

  /**
   * Returns a new Counter which is the input counter with log tf scaling
   *
   * @param c The counter to scale. It is not changed
   * @param base The base of the logarithm used for tf scaling by 1 + log tf
   * @return A new Counter which is the argument scaled by the given scale
   *         factor.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static &lt;E, C extends Counter&lt;E&gt;&gt; C tfLogScale(C c, double base) {
<span class="nc" id="L1766">    C scaled = (C) c.getFactory().create();</span>
<span class="nc bnc" id="L1767" title="All 2 branches missed.">    for (E key : c.keySet()) {</span>
<span class="nc" id="L1768">      double cnt = c.getCount(key);</span>
<span class="nc" id="L1769">      double scaledCnt = 0.0;</span>
<span class="nc bnc" id="L1770" title="All 2 branches missed.">      if (cnt &gt; 0) {</span>
<span class="nc" id="L1771">        scaledCnt = 1.0 + SloppyMath.log(cnt, base);</span>
      }
<span class="nc" id="L1773">      scaled.setCount(key, scaledCnt);</span>
<span class="nc" id="L1774">    }</span>
<span class="nc" id="L1775">    return scaled;</span>
  }

  public static &lt;E extends Comparable&lt;E&gt;&gt; void printCounterSortedByKeys(Counter&lt;E&gt; c) {
<span class="nc" id="L1779">    List&lt;E&gt; keyList = new ArrayList&lt;&gt;(c.keySet());</span>
<span class="nc" id="L1780">    Collections.sort(keyList);</span>
<span class="nc bnc" id="L1781" title="All 2 branches missed.">    for (E o : keyList) {</span>
<span class="nc" id="L1782">      System.out.println(o + &quot;:&quot; + c.getCount(o));</span>
<span class="nc" id="L1783">    }</span>
<span class="nc" id="L1784">  }</span>

  /**
   * Loads a Counter from a text file. File must have the format of one
   * key/count pair per line, separated by whitespace.
   *
   * @param filename The path to the file to load the Counter from
   * @param c The Class to instantiate each member of the set. Must have a
   *          String constructor.
   * @return The counter loaded from the file.
   */
  public static &lt;E&gt; ClassicCounter&lt;E&gt; loadCounter(String filename, Class&lt;E&gt; c) throws RuntimeException {
<span class="nc" id="L1796">    ClassicCounter&lt;E&gt; counter = new ClassicCounter&lt;&gt;();</span>
<span class="nc" id="L1797">    loadIntoCounter(filename, c, counter);</span>
<span class="nc" id="L1798">    return counter;</span>
  }

  /**
   * Loads a Counter from a text file. File must have the format of one
   * key/count pair per line, separated by whitespace.
   *
   * @param filename The path to the file to load the Counter from
   * @param c The Class to instantiate each member of the set. Must have a
   *          String constructor.
   * @return The counter loaded from the file.
   */
  public static &lt;E&gt; IntCounter&lt;E&gt; loadIntCounter(String filename, Class&lt;E&gt; c) throws Exception {
<span class="nc" id="L1811">    IntCounter&lt;E&gt; counter = new IntCounter&lt;&gt;();</span>
<span class="nc" id="L1812">    loadIntoCounter(filename, c, counter);</span>
<span class="nc" id="L1813">    return counter;</span>
  }

  /**
   * Loads a file into an GenericCounter.
   */
  private static &lt;E&gt; void loadIntoCounter(String filename, Class&lt;E&gt; c, Counter&lt;E&gt; counter) throws RuntimeException {
    try {
<span class="nc" id="L1821">      Constructor&lt;E&gt; m = c.getConstructor(String.class);</span>
<span class="nc" id="L1822">      BufferedReader in = IOUtils.getBufferedFileReader(filename);</span>
<span class="nc bnc" id="L1823" title="All 2 branches missed.">      for (String line; (line = in.readLine()) != null;) {</span>
<span class="nc" id="L1824">        String[] tokens = line.trim().split(&quot;\\s+&quot;);</span>
<span class="nc bnc" id="L1825" title="All 2 branches missed.">        if (tokens.length != 2) throw new RuntimeException();</span>
<span class="nc" id="L1826">        double value = Double.parseDouble(tokens[1]);</span>
<span class="nc" id="L1827">        counter.setCount(m.newInstance(tokens[0]), value);</span>
<span class="nc" id="L1828">      }</span>
<span class="nc" id="L1829">      in.close();</span>
<span class="nc" id="L1830">    } catch (Exception e) {</span>
<span class="nc" id="L1831">      throw new RuntimeException(e);</span>
<span class="nc" id="L1832">    }</span>
<span class="nc" id="L1833">  }</span>

  /**
   * Saves a Counter as one key/count pair per line separated by white space to
   * the given OutputStream. Does not close the stream.
   */
  public static &lt;E&gt; void saveCounter(Counter&lt;E&gt; c, OutputStream stream) {
<span class="nc" id="L1840">    PrintStream out = new PrintStream(stream);</span>
<span class="nc bnc" id="L1841" title="All 2 branches missed.">    for (E key : c.keySet()) {</span>
<span class="nc" id="L1842">      out.println(key + &quot; &quot; + c.getCount(key));</span>
<span class="nc" id="L1843">    }</span>
<span class="nc" id="L1844">  }</span>

  /**
   * Saves a Counter to a text file. Counter written as one key/count pair per
   * line, separated by whitespace.
   */
  public static &lt;E&gt; void saveCounter(Counter&lt;E&gt; c, String filename) throws IOException {
<span class="nc" id="L1851">    FileOutputStream fos = new FileOutputStream(filename);</span>
<span class="nc" id="L1852">    saveCounter(c, fos);</span>
<span class="nc" id="L1853">    fos.close();</span>
<span class="nc" id="L1854">  }</span>

  public static &lt;T1, T2&gt; TwoDimensionalCounter&lt;T1, T2&gt; load2DCounter(String filename, Class&lt;T1&gt; t1, Class&lt;T2&gt; t2) throws RuntimeException {
    try {
<span class="nc" id="L1858">      TwoDimensionalCounter&lt;T1, T2&gt; tdc = new TwoDimensionalCounter&lt;&gt;();</span>
<span class="nc" id="L1859">      loadInto2DCounter(filename, t1, t2, tdc);</span>
<span class="nc" id="L1860">      return tdc;</span>
<span class="nc" id="L1861">    } catch (Exception e) {</span>
<span class="nc" id="L1862">      throw new RuntimeException(e);</span>
    }
  }

  public static &lt;T1, T2&gt; void loadInto2DCounter(String filename, Class&lt;T1&gt; t1, Class&lt;T2&gt; t2, TwoDimensionalCounter&lt;T1, T2&gt; tdc) throws RuntimeException {
    try {
<span class="nc" id="L1868">      Constructor&lt;T1&gt; m1 = t1.getConstructor(String.class);</span>
<span class="nc" id="L1869">      Constructor&lt;T2&gt; m2 = t2.getConstructor(String.class);</span>
<span class="nc" id="L1870">      BufferedReader in = IOUtils.getBufferedFileReader(filename);// new</span>
                                                                  // BufferedReader(new
                                                                  // FileReader(filename));
<span class="nc bnc" id="L1873" title="All 2 branches missed.">      for (String line; (line = in.readLine()) != null;) {</span>
<span class="nc" id="L1874">        String[] tuple = line.trim().split(&quot;\t&quot;);</span>
<span class="nc" id="L1875">        String outer = tuple[0];</span>
<span class="nc" id="L1876">        String inner = tuple[1];</span>
<span class="nc" id="L1877">        String valStr = tuple[2];</span>
<span class="nc" id="L1878">        tdc.setCount(m1.newInstance(outer.trim()), m2.newInstance(inner.trim()), Double.parseDouble(valStr.trim()));</span>
<span class="nc" id="L1879">      }</span>
<span class="nc" id="L1880">      in.close();</span>
<span class="nc" id="L1881">    } catch (Exception e) {</span>
<span class="nc" id="L1882">      throw new RuntimeException(e);</span>
<span class="nc" id="L1883">    }</span>
<span class="nc" id="L1884">  }</span>

  public static &lt;T1, T2&gt; void loadIncInto2DCounter(String filename, Class&lt;T1&gt; t1, Class&lt;T2&gt; t2,
                                                   TwoDimensionalCounterInterface&lt;T1, T2&gt; tdc) throws RuntimeException {
    try {
<span class="nc" id="L1889">      Constructor&lt;T1&gt; m1 = t1.getConstructor(String.class);</span>
<span class="nc" id="L1890">      Constructor&lt;T2&gt; m2 = t2.getConstructor(String.class);</span>
<span class="nc" id="L1891">      BufferedReader in = IOUtils.getBufferedFileReader(filename);// new</span>
                                                                  // BufferedReader(new
                                                                  // FileReader(filename));
<span class="nc bnc" id="L1894" title="All 2 branches missed.">      for (String line; (line = in.readLine()) != null;) {</span>
<span class="nc" id="L1895">        String[] tuple = line.trim().split(&quot;\t&quot;);</span>
<span class="nc" id="L1896">        String outer = tuple[0];</span>
<span class="nc" id="L1897">        String inner = tuple[1];</span>
<span class="nc" id="L1898">        String valStr = tuple[2];</span>
<span class="nc" id="L1899">        tdc.incrementCount(m1.newInstance(outer.trim()), m2.newInstance(inner.trim()), Double.parseDouble(valStr.trim()));</span>
<span class="nc" id="L1900">      }</span>
<span class="nc" id="L1901">      in.close();</span>
<span class="nc" id="L1902">    } catch (Exception e) {</span>
<span class="nc" id="L1903">      throw new RuntimeException(e);</span>
<span class="nc" id="L1904">    }</span>
<span class="nc" id="L1905">  }</span>

  public static &lt;T1, T2&gt; void save2DCounter(TwoDimensionalCounter&lt;T1, T2&gt; tdc, String filename) throws IOException {
<span class="nc" id="L1908">    PrintWriter out = new PrintWriter(new FileWriter(filename));</span>
<span class="nc bnc" id="L1909" title="All 2 branches missed.">    for (T1 outer : tdc.firstKeySet()) {</span>
<span class="nc bnc" id="L1910" title="All 2 branches missed.">      for (T2 inner : tdc.secondKeySet()) {</span>
<span class="nc" id="L1911">        out.println(outer + &quot;\t&quot; + inner + '\t' + tdc.getCount(outer, inner));</span>
<span class="nc" id="L1912">      }</span>
<span class="nc" id="L1913">    }</span>
<span class="nc" id="L1914">    out.close();</span>
<span class="nc" id="L1915">  }</span>

  public static &lt;T1, T2&gt; void save2DCounterSorted(TwoDimensionalCounterInterface&lt;T1, T2&gt; tdc, String filename) throws IOException {
<span class="nc" id="L1918">    PrintWriter out = new PrintWriter(new FileWriter(filename));</span>
<span class="nc bnc" id="L1919" title="All 2 branches missed.">    for (T1 outer : tdc.firstKeySet()) {</span>
<span class="nc" id="L1920">      Counter&lt;T2&gt; c = tdc.getCounter(outer);</span>
<span class="nc" id="L1921">      List&lt;T2&gt; keys = Counters.toSortedList(c);</span>
<span class="nc bnc" id="L1922" title="All 2 branches missed.">      for (T2 inner : keys) {</span>
<span class="nc" id="L1923">        out.println(outer + &quot;\t&quot; + inner + '\t' + c.getCount(inner));</span>
<span class="nc" id="L1924">      }</span>
<span class="nc" id="L1925">    }</span>
<span class="nc" id="L1926">    out.close();</span>
<span class="nc" id="L1927">  }</span>

  /**
   * Serialize a counter into an efficient string TSV
   * @param c The counter to serialize
   * @param filename The file to serialize to
   * @param minMagnitude Ignore values under this magnitude
   * @throws IOException
   *
   * @see Counters#deserializeStringCounter(String)
   */
  public static void serializeStringCounter(Counter&lt;String&gt; c,
                                            String filename,
                                            double minMagnitude) throws IOException {
<span class="fc" id="L1941">    PrintWriter writer = IOUtils.getPrintWriter(filename);</span>
<span class="fc bfc" id="L1942" title="All 2 branches covered.">    for (Entry&lt;String, Double&gt; entry : c.entrySet()) {</span>
<span class="pc bpc" id="L1943" title="1 of 2 branches missed.">      if (Math.abs(entry.getValue()) &lt; minMagnitude) { continue; }</span>
<span class="fc" id="L1944">      Triple&lt;Boolean, Long, Integer&gt; parts = SloppyMath.segmentDouble(entry.getValue());</span>
<span class="fc" id="L1945">      writer.println(</span>
<span class="fc" id="L1946">          entry.getKey().replace('\t', 'ߝ') + &quot;\t&quot; +</span>
<span class="fc bfc" id="L1947" title="All 2 branches covered.">              (parts.first ? '-' : '+') + &quot;\t&quot; +</span>
              parts.second + &quot;\t&quot; +
              parts.third
      );
<span class="fc" id="L1951">    }</span>
<span class="fc" id="L1952">    writer.close();</span>
<span class="fc" id="L1953">  }</span>

  /** @see Counters#serializeStringCounter(Counter, String, double) */
  public static void serializeStringCounter(Counter&lt;String&gt; c,
                                            String filename) throws IOException {
<span class="fc" id="L1958">    serializeStringCounter(c, filename, 0.0);</span>
<span class="fc" id="L1959">  }</span>


  /**
   * Read a Counter from a serialized file
   * @param filename The file to read from
   *
   * @see Counters#serializeStringCounter(Counter, String, double)
   */
  public static ClassicCounter&lt;String&gt; deserializeStringCounter(String filename) throws IOException {
<span class="fc" id="L1969">    String[] fields = new String[4];</span>
<span class="fc" id="L1970">    BufferedReader reader = IOUtils.readerFromString(filename);</span>
    String line;
<span class="fc" id="L1972">    ClassicCounter&lt;String&gt; counts = new ClassicCounter&lt;&gt;(1000000);</span>
<span class="fc bfc" id="L1973" title="All 2 branches covered.">    while ( (line = reader.readLine()) != null) {</span>
<span class="fc" id="L1974">      StringUtils.splitOnChar(fields, line, '\t');</span>
<span class="fc" id="L1975">      long mantissa = SloppyMath.parseInt(fields[2]);</span>
<span class="fc" id="L1976">      int exponent = (int) SloppyMath.parseInt(fields[3]);</span>
<span class="fc" id="L1977">      double value = SloppyMath.parseDouble(fields[1].equals(&quot;-&quot;), mantissa, exponent);</span>
<span class="fc" id="L1978">      counts.setCount(fields[0], value);</span>
<span class="fc" id="L1979">    }</span>
<span class="fc" id="L1980">    return counts;</span>
  }



  public static &lt;T&gt; void serializeCounter(Counter&lt;T&gt; c, String filename) throws IOException {
    // serialize to file
<span class="nc" id="L1987">    ObjectOutputStream out = new ObjectOutputStream(new BufferedOutputStream(new FileOutputStream(filename)));</span>
<span class="nc" id="L1988">    out.writeObject(c);</span>
<span class="nc" id="L1989">    out.close();</span>
<span class="nc" id="L1990">  }</span>

  public static &lt;T&gt; ClassicCounter&lt;T&gt; deserializeCounter(String filename) throws Exception {
    // reconstitute
<span class="nc" id="L1994">    ObjectInputStream in = new ObjectInputStream(new BufferedInputStream(new FileInputStream(filename)));</span>
<span class="nc" id="L1995">    ClassicCounter&lt;T&gt; c = ErasureUtils.uncheckedCast(in.readObject());</span>
<span class="nc" id="L1996">    in.close();</span>
<span class="nc" id="L1997">    return c;</span>
  }

  /**
   * Returns a string representation of a Counter, displaying the keys and their
   * counts in decreasing order of count. At most k keys are displayed.
   *
   * Note that this method subsumes many of the other toString methods, e.g.:
   *
   * toString(c, k) and toBiggestValuesFirstString(c, k) =&amp;gt; toSortedString(c, k,
   * &quot;%s=%f&quot;, &quot;, &quot;, &quot;[%s]&quot;)
   *
   * toVerticalString(c, k) =&amp;gt; toSortedString(c, k, &quot;%2$g\t%1$s&quot;, &quot;\n&quot;, &quot;%s\n&quot;)
   *
   * @param counter A Counter.
   * @param k The number of keys to include. Use Integer.MAX_VALUE to include
   *          all keys.
   * @param itemFormat
   *          The format string for key/count pairs, where the key is first and
   *          the value is second. To display the value first, use argument
   *          indices, e.g. &quot;%2$f %1$s&quot;.
   * @param joiner The string used between pairs of key/value strings.
   * @param wrapperFormat
   *          The format string for wrapping text around the joined items, where
   *          the joined item string value is &quot;%s&quot;.
   * @return The top k values from the Counter, formatted as specified.
   */
  public static &lt;T&gt; String toSortedString(Counter&lt;T&gt; counter, int k, String itemFormat, String joiner, String wrapperFormat) {
<span class="fc" id="L2025">    PriorityQueue&lt;T&gt; queue = toPriorityQueue(counter);</span>
<span class="fc" id="L2026">    List&lt;String&gt; strings = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L2027" title="All 4 branches covered.">    for (int rank = 0; rank &lt; k &amp;&amp; !queue.isEmpty(); ++rank) {</span>
<span class="fc" id="L2028">      T key = queue.removeFirst();</span>
<span class="fc" id="L2029">      double value = counter.getCount(key);</span>
<span class="fc" id="L2030">      strings.add(String.format(itemFormat, key, value));</span>
    }
<span class="fc" id="L2032">    return String.format(wrapperFormat, StringUtils.join(strings, joiner));</span>
  }

  /**
   * Returns a string representation of a Counter, displaying the keys and their
   * counts in decreasing order of count. At most k keys are displayed.
   *
   * @param counter A Counter.
   * @param k
   *          The number of keys to include. Use Integer.MAX_VALUE to include
   *          all keys.
   * @param itemFormat
   *          The format string for key/count pairs, where the key is first and
   *          the value is second. To display the value first, use argument
   *          indices, e.g. &quot;%2$f %1$s&quot;.
   * @param joiner
   *          The string used between pairs of key/value strings.
   * @return The top k values from the Counter, formatted as specified.
   */
  public static &lt;T&gt; String toSortedString(Counter&lt;T&gt; counter, int k, String itemFormat, String joiner) {
<span class="fc" id="L2052">    return toSortedString(counter, k, itemFormat, joiner, &quot;%s&quot;);</span>
  }

  /**
   * Returns a string representation of a Counter, where (key, value) pairs are
   * sorted by key, and formatted as specified.
   *
   * @param counter The Counter.
   * @param itemFormat
   *          The format string for key/count pairs, where the key is first and
   *          the value is second. To display the value first, use argument
   *          indices, e.g. &quot;%2$f %1$s&quot;.
   * @param joiner
   *          The string used between pairs of key/value strings.
   * @param wrapperFormat
   *          The format string for wrapping text around the joined items, where
   *          the joined item string value is &quot;%s&quot;.
   * @return The Counter, formatted as specified.
   */
  public static &lt;T extends Comparable&lt;T&gt;&gt; String toSortedByKeysString(Counter&lt;T&gt; counter, String itemFormat, String joiner, String wrapperFormat) {
<span class="fc" id="L2072">    List&lt;String&gt; strings = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L2073" title="All 2 branches covered.">    for (T key : CollectionUtils.sorted(counter.keySet())) {</span>
<span class="fc" id="L2074">      strings.add(String.format(itemFormat, key, counter.getCount(key)));</span>
<span class="fc" id="L2075">    }</span>
<span class="fc" id="L2076">    return String.format(wrapperFormat, StringUtils.join(strings, joiner));</span>
  }

  /**
   * Returns a string representation which includes no more than the
   * maxKeysToPrint elements with largest counts. If maxKeysToPrint is
   * non-positive, all elements are printed.
   *
   * @param counter The Counter
   * @param maxKeysToPrint Max keys to print
   * @return A partial string representation
   */
  public static &lt;E&gt; String toString(Counter&lt;E&gt; counter, int maxKeysToPrint) {
<span class="fc" id="L2089">    return Counters.toPriorityQueue(counter).toString(maxKeysToPrint);</span>
  }

  public static &lt;E&gt; String toString(Counter&lt;E&gt; counter, NumberFormat nf) {
<span class="nc" id="L2093">    StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L2094">    sb.append('{');</span>
<span class="nc" id="L2095">    List&lt;E&gt; list = ErasureUtils.sortedIfPossible(counter.keySet());</span>
    // */
<span class="nc bnc" id="L2097" title="All 2 branches missed.">    for (Iterator&lt;E&gt; iter = list.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L2098">      E key = iter.next();</span>
<span class="nc" id="L2099">      sb.append(key);</span>
<span class="nc" id="L2100">      sb.append('=');</span>
<span class="nc" id="L2101">      sb.append(nf.format(counter.getCount(key)));</span>
<span class="nc bnc" id="L2102" title="All 2 branches missed.">      if (iter.hasNext()) {</span>
<span class="nc" id="L2103">        sb.append(&quot;, &quot;);</span>
      }
<span class="nc" id="L2105">    }</span>
<span class="nc" id="L2106">    sb.append('}');</span>
<span class="nc" id="L2107">    return sb.toString();</span>
  }

  /**
   * Pretty print a Counter. This one has more flexibility in formatting, and
   * doesn't sort the keys.
   */
  public static &lt;E&gt; String toString(Counter&lt;E&gt; counter, NumberFormat nf, String preAppend, String postAppend, String keyValSeparator, String itemSeparator) {
<span class="nc" id="L2115">    StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L2116">    sb.append(preAppend);</span>
    // List&lt;E&gt; list = new ArrayList&lt;E&gt;(map.keySet());
    // try {
    // Collections.sort(list); // see if it can be sorted
    // } catch (Exception e) {
    // }
<span class="nc bnc" id="L2122" title="All 2 branches missed.">    for (Iterator&lt;E&gt; iter = counter.keySet().iterator(); iter.hasNext();) {</span>
<span class="nc" id="L2123">      E key = iter.next();</span>
<span class="nc" id="L2124">      double d = counter.getCount(key);</span>
<span class="nc" id="L2125">      sb.append(key);</span>
<span class="nc" id="L2126">      sb.append(keyValSeparator);</span>
<span class="nc" id="L2127">      sb.append(nf.format(d));</span>
<span class="nc bnc" id="L2128" title="All 2 branches missed.">      if (iter.hasNext()) {</span>
<span class="nc" id="L2129">        sb.append(itemSeparator);</span>
      }
<span class="nc" id="L2131">    }</span>
<span class="nc" id="L2132">    sb.append(postAppend);</span>
<span class="nc" id="L2133">    return sb.toString();</span>
  }

  public static &lt;E&gt; String toBiggestValuesFirstString(Counter&lt;E&gt; c) {
<span class="nc" id="L2137">    return toPriorityQueue(c).toString();</span>
  }

  // TODO this method seems badly written. It should exploit topK printing of PriorityQueue
  public static &lt;E&gt; String toBiggestValuesFirstString(Counter&lt;E&gt; c, int k) {
<span class="fc" id="L2142">    PriorityQueue&lt;E&gt; pq = toPriorityQueue(c);</span>
<span class="fc" id="L2143">    PriorityQueue&lt;E&gt; largestK = new BinaryHeapPriorityQueue&lt;&gt;();</span>
    // TODO: Is there any reason the original (commented out) line is better
    // than the one replacing it?
    // while (largestK.size() &lt; k &amp;&amp; ((Iterator&lt;E&gt;)pq).hasNext()) {
<span class="pc bpc" id="L2147" title="1 of 4 branches missed.">    while (largestK.size() &lt; k &amp;&amp; !pq.isEmpty()) {</span>
<span class="fc" id="L2148">      double firstScore = pq.getPriority(pq.getFirst());</span>
<span class="fc" id="L2149">      E first = pq.removeFirst();</span>
<span class="fc" id="L2150">      largestK.changePriority(first, firstScore);</span>
<span class="fc" id="L2151">    }</span>
<span class="fc" id="L2152">    return largestK.toString();</span>
  }

  public static &lt;T&gt; String toBiggestValuesFirstString(Counter&lt;Integer&gt; c, int k, Index&lt;T&gt; index) {
<span class="nc" id="L2156">    PriorityQueue&lt;Integer&gt; pq = toPriorityQueue(c);</span>
<span class="nc" id="L2157">    PriorityQueue&lt;T&gt; largestK = new BinaryHeapPriorityQueue&lt;&gt;();</span>
    // while (largestK.size() &lt; k &amp;&amp; ((Iterator)pq).hasNext()) { //same as above
<span class="nc bnc" id="L2159" title="All 4 branches missed.">    while (largestK.size() &lt; k &amp;&amp; !pq.isEmpty()) {</span>
<span class="nc" id="L2160">      double firstScore = pq.getPriority(pq.getFirst());</span>
<span class="nc" id="L2161">      int first = pq.removeFirst();</span>
<span class="nc" id="L2162">      largestK.changePriority(index.get(first), firstScore);</span>
<span class="nc" id="L2163">    }</span>
<span class="nc" id="L2164">    return largestK.toString();</span>
  }

  public static &lt;E&gt; String toVerticalString(Counter&lt;E&gt; c) {
<span class="nc" id="L2168">    return toVerticalString(c, Integer.MAX_VALUE);</span>
  }

  public static &lt;E&gt; String toVerticalString(Counter&lt;E&gt; c, int k) {
<span class="fc" id="L2172">    return toVerticalString(c, k, &quot;%g\t%s&quot;, false);</span>
  }

  public static &lt;E&gt; String toVerticalString(Counter&lt;E&gt; c, String fmt) {
<span class="nc" id="L2176">    return toVerticalString(c, Integer.MAX_VALUE, fmt, false);</span>
  }

  public static &lt;E&gt; String toVerticalString(Counter&lt;E&gt; c, int k, String fmt) {
<span class="nc" id="L2180">    return toVerticalString(c, k, fmt, false);</span>
  }

  /**
   * Returns a {@code String} representation of the {@code k} keys
   * with the largest counts in the given {@link Counter}, using the given
   * format string.
   *
   * @param c A Counter
   * @param k How many keys to print
   * @param fmt A format string, such as &quot;%.0f\t%s&quot; (do not include final &quot;%n&quot;).
   *            If swap is false, you will get val, key as arguments, if true, key, val.
   * @param swap Whether the count should appear after the key
   */
  public static &lt;E&gt; String toVerticalString(Counter&lt;E&gt; c, int k, String fmt, boolean swap) {
<span class="fc" id="L2195">    PriorityQueue&lt;E&gt; q = Counters.toPriorityQueue(c);</span>
<span class="fc" id="L2196">    List&lt;E&gt; sortedKeys = q.toSortedList();</span>
<span class="fc" id="L2197">    StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L2198">    int i = 0;</span>
<span class="pc bpc" id="L2199" title="1 of 4 branches missed.">    for (Iterator&lt;E&gt; keyI = sortedKeys.iterator(); keyI.hasNext() &amp;&amp; i &lt; k; i++) {</span>
<span class="fc" id="L2200">      E key = keyI.next();</span>
<span class="fc" id="L2201">      double val = q.getPriority(key);</span>
<span class="pc bpc" id="L2202" title="1 of 2 branches missed.">      if (swap) {</span>
<span class="nc" id="L2203">        sb.append(String.format(fmt, key, val));</span>
      } else {
<span class="fc" id="L2205">        sb.append(String.format(fmt, val, key));</span>
      }
<span class="pc bpc" id="L2207" title="1 of 2 branches missed.">      if (keyI.hasNext()) {</span>
<span class="fc" id="L2208">        sb.append('\n');</span>
      }
    }
<span class="fc" id="L2211">    return sb.toString();</span>
  }

  /**
   *
   * @return Returns the maximum element of c that is within the restriction
   *         Collection
   */
  public static &lt;E&gt; E restrictedArgMax(Counter&lt;E&gt; c, Collection&lt;E&gt; restriction) {
<span class="nc" id="L2220">    E maxKey = null;</span>
<span class="nc" id="L2221">    double max = Double.NEGATIVE_INFINITY;</span>
<span class="nc bnc" id="L2222" title="All 2 branches missed.">    for (E key : restriction) {</span>
<span class="nc" id="L2223">      double count = c.getCount(key);</span>
<span class="nc bnc" id="L2224" title="All 2 branches missed.">      if (count &gt; max) {</span>
<span class="nc" id="L2225">        max = count;</span>
<span class="nc" id="L2226">        maxKey = key;</span>
      }
<span class="nc" id="L2228">    }</span>
<span class="nc" id="L2229">    return maxKey;</span>
  }

  public static &lt;T&gt; Counter&lt;T&gt; toCounter(double[] counts, Index&lt;T&gt; index) {
<span class="nc bnc" id="L2233" title="All 2 branches missed.">    if (index.size() &lt; counts.length)</span>
<span class="nc" id="L2234">      throw new IllegalArgumentException(&quot;Index not large enough to name all the array elements!&quot;);</span>
<span class="nc" id="L2235">    Counter&lt;T&gt; c = new ClassicCounter&lt;&gt;();</span>
<span class="nc bnc" id="L2236" title="All 2 branches missed.">    for (int i = 0; i &lt; counts.length; i++) {</span>
<span class="nc bnc" id="L2237" title="All 2 branches missed.">      if (counts[i] != 0.0)</span>
<span class="nc" id="L2238">        c.setCount(index.get(i), counts[i]);</span>
    }
<span class="nc" id="L2240">    return c;</span>
  }

  /**
   * Turns the given map and index into a counter instance. For each entry in
   * counts, its key is converted to a counter key via lookup in the given
   * index.
   */
  public static &lt;E&gt; Counter&lt;E&gt; toCounter(Map&lt;Integer, ? extends Number&gt; counts, Index&lt;E&gt; index) {

<span class="nc" id="L2250">    Counter&lt;E&gt; counter = new ClassicCounter&lt;&gt;();</span>
<span class="nc bnc" id="L2251" title="All 2 branches missed.">    for (Map.Entry&lt;Integer, ? extends Number&gt; entry : counts.entrySet()) {</span>
<span class="nc" id="L2252">      counter.setCount(index.get(entry.getKey()), entry.getValue().doubleValue());</span>
<span class="nc" id="L2253">    }</span>
<span class="nc" id="L2254">    return counter;</span>
  }

  /**
   * Convert a counter to an array using a specified key index. Infer the dimension of
   * the returned vector from the index.
   */
  public static &lt;E&gt; double[] asArray(Counter&lt;E&gt; counter, Index&lt;E&gt; index) {
<span class="nc" id="L2262">    return Counters.asArray(counter, index, index.size());</span>
  }

  /**
   * Convert a counter to an array using a specified key index. This method does *not* expand
   * the index, so all keys in the set keys(counter) - keys(index) are not added to the
   * output array. Also note that if counter is being used as a sparse array, the result
   * will be a dense array with zero entries.
   *
   * @return the values corresponding to the index
   */
  public static &lt;E&gt; double[] asArray(Counter&lt;E&gt; counter, Index&lt;E&gt; index, int dimension) {
<span class="nc bnc" id="L2274" title="All 2 branches missed.">    if (index.size() == 0) {</span>
<span class="nc" id="L2275">      throw new IllegalArgumentException(&quot;Empty index&quot;);</span>
    }
<span class="nc" id="L2277">    Set&lt;E&gt; keys = counter.keySet();</span>
<span class="nc" id="L2278">    double[] array = new double[dimension];</span>
<span class="nc bnc" id="L2279" title="All 2 branches missed.">    for (E key : keys) {</span>
<span class="nc" id="L2280">      int i = index.indexOf(key);</span>
<span class="nc bnc" id="L2281" title="All 2 branches missed.">      if (i &gt;= 0) {</span>
<span class="nc" id="L2282">        array[i] = counter.getCount(key);</span>
      }
<span class="nc" id="L2284">    }</span>
<span class="nc" id="L2285">    return array;</span>
  }

  /**
   * Convert a counter to an array, the order of the array is random
   */
  public static &lt;E&gt; double[] asArray(Counter&lt;E&gt; counter) {
<span class="nc" id="L2292">    Set&lt;E&gt; keys = counter.keySet();</span>
<span class="nc" id="L2293">    double[] array = new double[counter.size()];</span>
<span class="nc" id="L2294">    int i = 0;</span>
<span class="nc bnc" id="L2295" title="All 2 branches missed.">    for (E key : keys) {</span>
<span class="nc" id="L2296">      array[i] = counter.getCount(key);</span>
<span class="nc" id="L2297">      i++;</span>
<span class="nc" id="L2298">    }</span>
<span class="nc" id="L2299">    return array;</span>
  }


  /**
   * Creates a new TwoDimensionalCounter where all the counts are scaled by d.
   * Internally, uses Counters.scale();
   *
   * @return The TwoDimensionalCounter
   */
  public static &lt;T1, T2&gt; TwoDimensionalCounter&lt;T1, T2&gt; scale(TwoDimensionalCounter&lt;T1, T2&gt; c, double d) {
<span class="nc" id="L2310">    TwoDimensionalCounter&lt;T1, T2&gt; result = new TwoDimensionalCounter&lt;&gt;(c.getOuterMapFactory(), c.getInnerMapFactory());</span>
<span class="nc bnc" id="L2311" title="All 2 branches missed.">    for (T1 key : c.firstKeySet()) {</span>
<span class="nc" id="L2312">      ClassicCounter&lt;T2&gt; ctr = c.getCounter(key);</span>
<span class="nc" id="L2313">      result.setCounter(key, scale(ctr, d));</span>
<span class="nc" id="L2314">    }</span>
<span class="nc" id="L2315">    return result;</span>
  }

<span class="fc" id="L2318">  static final Random RAND = new Random();</span>

  /**
   * Does not assumes c is normalized.
   *
   * @return A sample from c
   */
  public static &lt;T&gt; T sample(Counter&lt;T&gt; c, Random rand) {
    // OMITTED: Seems like there should be a way to directly check if T is comparable
    // Set&lt;T&gt; keySet = c.keySet();
    // if (!keySet.isEmpty() &amp;&amp; keySet.iterator().next() instanceof Comparable) {
    //   List l = new ArrayList&lt;T&gt;(keySet);
    //   Collections.sort(l);
    //   objects = l;
    // } else {
    //   throw new RuntimeException(&quot;Results won't be stable since Counters keys are comparable.&quot;);
    // }
<span class="nc bnc" id="L2335" title="All 2 branches missed.">    if (rand == null) rand = RAND;</span>
<span class="nc" id="L2336">    double r = rand.nextDouble() * c.totalCount();</span>
<span class="nc" id="L2337">    double total = 0.0;</span>

<span class="nc bnc" id="L2339" title="All 2 branches missed.">    for (T t : c.keySet()) { // arbitrary ordering, but presumably stable</span>
<span class="nc" id="L2340">      total += c.getCount(t);</span>
<span class="nc bnc" id="L2341" title="All 2 branches missed.">      if (total &gt;= r)</span>
<span class="nc" id="L2342">        return t;</span>
<span class="nc" id="L2343">    }</span>
    // only chance of reaching here is if c isn't properly normalized, or if
    // double math makes total&lt;1.0
<span class="nc" id="L2346">    return c.keySet().iterator().next();</span>
  }

  /**
   * Does not assumes c is normalized.
   *
   * @return A sample from c
   */

  public static &lt;T&gt; T sample(Counter&lt;T&gt; c) {
<span class="nc" id="L2356">    return sample(c, null);</span>
  }

  /**
   * Returns a counter where each element corresponds to the normalized count of
   * the corresponding element in c raised to the given power.
   */
  public static &lt;E&gt; Counter&lt;E&gt; powNormalized(Counter&lt;E&gt; c, double temp) {
<span class="nc" id="L2364">    Counter&lt;E&gt; d = c.getFactory().create();</span>
<span class="nc" id="L2365">    double total = c.totalCount();</span>
<span class="nc bnc" id="L2366" title="All 2 branches missed.">    for (E e : c.keySet()) {</span>
<span class="nc" id="L2367">      d.setCount(e, Math.pow(c.getCount(e) / total, temp));</span>
<span class="nc" id="L2368">    }</span>
<span class="nc" id="L2369">    return d;</span>
  }

  public static &lt;T&gt; Counter&lt;T&gt; pow(Counter&lt;T&gt; c, double temp) {
<span class="nc" id="L2373">    Counter&lt;T&gt; d = c.getFactory().create();</span>
<span class="nc bnc" id="L2374" title="All 2 branches missed.">    for (T t : c.keySet()) {</span>
<span class="nc" id="L2375">      d.setCount(t, Math.pow(c.getCount(t), temp));</span>
<span class="nc" id="L2376">    }</span>
<span class="nc" id="L2377">    return d;</span>
  }

  public static &lt;T&gt; void powInPlace(Counter&lt;T&gt; c, double temp) {
<span class="nc bnc" id="L2381" title="All 2 branches missed.">    for (T t : c.keySet()) {</span>
<span class="nc" id="L2382">      c.setCount(t, Math.pow(c.getCount(t), temp));</span>
<span class="nc" id="L2383">    }</span>
<span class="nc" id="L2384">  }</span>

  public static &lt;T&gt; Counter&lt;T&gt; exp(Counter&lt;T&gt; c) {
<span class="nc" id="L2387">    Counter&lt;T&gt; d = c.getFactory().create();</span>
<span class="nc bnc" id="L2388" title="All 2 branches missed.">    for (T t : c.keySet()) {</span>
<span class="nc" id="L2389">      d.setCount(t, Math.exp(c.getCount(t)));</span>
<span class="nc" id="L2390">    }</span>
<span class="nc" id="L2391">    return d;</span>
  }

  public static &lt;T&gt; void expInPlace(Counter&lt;T&gt; c) {
<span class="nc bnc" id="L2395" title="All 2 branches missed.">    for (T t : c.keySet()) {</span>
<span class="nc" id="L2396">      c.setCount(t, Math.exp(c.getCount(t)));</span>
<span class="nc" id="L2397">    }</span>
<span class="nc" id="L2398">  }</span>

  public static &lt;T&gt; Counter&lt;T&gt; diff(Counter&lt;T&gt; goldFeatures, Counter&lt;T&gt; guessedFeatures) {
<span class="nc" id="L2401">    Counter&lt;T&gt; result = goldFeatures.getFactory().create();</span>
<span class="nc bnc" id="L2402" title="All 2 branches missed.">    for (T key : Sets.union(goldFeatures.keySet(), guessedFeatures.keySet())) {</span>
<span class="nc" id="L2403">      result.setCount(key, goldFeatures.getCount(key) - guessedFeatures.getCount(key));</span>
<span class="nc" id="L2404">    }</span>
<span class="nc" id="L2405">    retainNonZeros(result);</span>
<span class="nc" id="L2406">    return result;</span>
  }

  /**
   * Default equality comparison for two counters potentially backed by
   * alternative implementations.
   */
  public static &lt;E&gt; boolean equals(Counter&lt;E&gt; o1, Counter&lt;E&gt; o2) {
<span class="fc" id="L2414">    return equals(o1, o2, 0.0);</span>
  }

  /**
   * Equality comparison between two counters, allowing for a tolerance fudge factor.
   */
  public static &lt;E&gt; boolean equals(Counter&lt;E&gt; o1, Counter&lt;E&gt; o2, double tolerance) {
<span class="pc bpc" id="L2421" title="1 of 2 branches missed.">    if (o1 == o2) {</span>
<span class="nc" id="L2422">      return true;</span>
    }

<span class="fc bfc" id="L2425" title="All 2 branches covered.">    if (Math.abs(o1.totalCount() - o2.totalCount()) &gt; tolerance) {</span>
<span class="fc" id="L2426">      return false;</span>
    }

<span class="pc bpc" id="L2429" title="1 of 2 branches missed.">    if (!o1.keySet().equals(o2.keySet())) {</span>
<span class="nc" id="L2430">      return false;</span>
    }

<span class="fc bfc" id="L2433" title="All 2 branches covered.">    for (E key : o1.keySet()) {</span>
<span class="pc bpc" id="L2434" title="1 of 2 branches missed.">      if (Math.abs(o1.getCount(key) - o2.getCount(key)) &gt; tolerance) {</span>
<span class="nc" id="L2435">        return false;</span>
      }
<span class="fc" id="L2437">    }</span>

<span class="fc" id="L2439">    return true;</span>

  }

  /**
   * Returns unmodifiable view of the counter. changes to the underlying Counter
   * are written through to this Counter.
   *
   * @param counter
   *          The counter
   * @return unmodifiable view of the counter
   */
  public static &lt;T&gt; Counter&lt;T&gt; unmodifiableCounter(final Counter&lt;T&gt; counter) {

<span class="nc" id="L2453">    return new AbstractCounter&lt;T&gt;() {</span>

      public void clear() {
<span class="nc" id="L2456">        throw new UnsupportedOperationException();</span>
      }

      public boolean containsKey(T key) {
<span class="nc" id="L2460">        return counter.containsKey(key);</span>
      }

      public double getCount(Object key) {
<span class="nc" id="L2464">        return counter.getCount(key);</span>
      }

      public Factory&lt;Counter&lt;T&gt;&gt; getFactory() {
<span class="nc" id="L2468">        return counter.getFactory();</span>
      }

      public double remove(T key) {
<span class="nc" id="L2472">        throw new UnsupportedOperationException();</span>
      }

      public void setCount(T key, double value) {
<span class="nc" id="L2476">        throw new UnsupportedOperationException();</span>
      }

      @Override
      public double incrementCount(T key, double value) {
<span class="nc" id="L2481">        throw new UnsupportedOperationException();</span>
      }

      @Override
      public double incrementCount(T key) {
<span class="nc" id="L2486">        throw new UnsupportedOperationException();</span>
      }

      @Override
      public double logIncrementCount(T key, double value) {
<span class="nc" id="L2491">        throw new UnsupportedOperationException();</span>
      }

      public int size() {
<span class="nc" id="L2495">        return counter.size();</span>
      }

      public double totalCount() {
<span class="nc" id="L2499">        return counter.totalCount();</span>
      }

      public Collection&lt;Double&gt; values() {
<span class="nc" id="L2503">        return counter.values();</span>
      }

      public Set&lt;T&gt; keySet() {
<span class="nc" id="L2507">        return Collections.unmodifiableSet(counter.keySet());</span>
      }

      public Set&lt;Entry&lt;T, Double&gt;&gt; entrySet() {
<span class="nc" id="L2511">        return Collections.unmodifiableSet(new AbstractSet&lt;Map.Entry&lt;T, Double&gt;&gt;() {</span>
          @Override
          public Iterator&lt;Entry&lt;T, Double&gt;&gt; iterator() {
<span class="nc" id="L2514">            return new Iterator&lt;Entry&lt;T, Double&gt;&gt;() {</span>
<span class="nc" id="L2515">              final Iterator&lt;Entry&lt;T, Double&gt;&gt; inner = counter.entrySet().iterator();</span>

              public boolean hasNext() {
<span class="nc" id="L2518">                return inner.hasNext();</span>
              }

              public Entry&lt;T, Double&gt; next() {
<span class="nc" id="L2522">                return new Map.Entry&lt;T, Double&gt;() {</span>
<span class="nc" id="L2523">                  final Entry&lt;T, Double&gt; e = inner.next();</span>

                  @Override
                  public T getKey() {
<span class="nc" id="L2527">                    return e.getKey();</span>
                  }

                  @Override
                  @SuppressWarnings( { &quot;UnnecessaryBoxing&quot;, &quot;UnnecessaryUnboxing&quot; })
                  public Double getValue() {
<span class="nc" id="L2533">                    return Double.valueOf(e.getValue().doubleValue());</span>
                  }

                  @Override
                  public Double setValue(Double value) {
<span class="nc" id="L2538">                    throw new UnsupportedOperationException();</span>
                  }
                };
              }

              @Override
              public void remove() {
<span class="nc" id="L2545">                throw new UnsupportedOperationException();</span>
              }
            };
          }

          @Override
          public int size() {
<span class="nc" id="L2552">            return counter.size();</span>
          }
        });
      }

      @Override
      public void setDefaultReturnValue(double rv) {
<span class="nc" id="L2559">        throw new UnsupportedOperationException();</span>
      }

      @Override
      public double defaultReturnValue() {
<span class="nc" id="L2564">        return counter.defaultReturnValue();</span>
      }

      /**
       * {@inheritDoc}
       */
      public void prettyLog(RedwoodChannels channels, String description) {
<span class="nc" id="L2571">        PrettyLogger.log(channels, description, asMap(this));</span>
<span class="nc" id="L2572">      }</span>
    };
  } // end unmodifiableCounter()

  /**
   * Returns a counter whose keys are the elements in this priority queue, and
   * whose counts are the priorities in this queue. In the event there are
   * multiple instances of the same element in the queue, the counter's count
   * will be the sum of the instances' priorities.
   *
   */
  public static &lt;E&gt; Counter&lt;E&gt; asCounter(FixedPrioritiesPriorityQueue&lt;E&gt; p) {
<span class="nc" id="L2584">    FixedPrioritiesPriorityQueue&lt;E&gt; pq = p.clone();</span>
<span class="nc" id="L2585">    ClassicCounter&lt;E&gt; counter = new ClassicCounter&lt;&gt;();</span>
<span class="nc bnc" id="L2586" title="All 2 branches missed.">    while (pq.hasNext()) {</span>
<span class="nc" id="L2587">      double priority = pq.getPriority();</span>
<span class="nc" id="L2588">      E element = pq.next();</span>
<span class="nc" id="L2589">      counter.incrementCount(element, priority);</span>
<span class="nc" id="L2590">    }</span>
<span class="nc" id="L2591">    return counter;</span>
  }

  /**
   * Returns a counter view of the given map. Infers the numeric type of the
   * values from the first element in map.values().
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static &lt;E, N extends Number&gt; Counter&lt;E&gt; fromMap(final Map&lt;E, N&gt; map) {
<span class="nc bnc" id="L2600" title="All 2 branches missed.">    if (map.isEmpty()) {</span>
<span class="nc" id="L2601">      throw new IllegalArgumentException(&quot;Map must have at least one element&quot; + &quot; to infer numeric type; add an element first or use e.g.&quot; + &quot; fromMap(map, Integer.class)&quot;);</span>
    }
<span class="nc" id="L2603">    return fromMap(map, (Class) map.values().iterator().next().getClass());</span>
  }

  /**
   * Returns a counter view of the given map. The type parameter is the type of
   * the values in the map, which because of Java's generics type erasure, can't
   * be discovered by reflection if the map is currently empty.
   */
  public static &lt;E, N extends Number&gt; Counter&lt;E&gt; fromMap(final Map&lt;E, N&gt; map, final Class&lt;N&gt; type) {
    // get our initial total
<span class="fc" id="L2613">    double initialTotal = 0.0;</span>
<span class="pc bpc" id="L2614" title="1 of 2 branches missed.">    for (Map.Entry&lt;E, N&gt; entry : map.entrySet()) {</span>
<span class="nc" id="L2615">      initialTotal += entry.getValue().doubleValue();</span>
<span class="nc" id="L2616">    }</span>

    // and pass it in to the returned inner class with a final variable
<span class="fc" id="L2619">    final double initialTotalFinal = initialTotal;</span>

<span class="fc" id="L2621">    return new AbstractCounter&lt;E&gt;() {</span>
<span class="fc" id="L2622">      double total = initialTotalFinal;</span>
<span class="fc" id="L2623">      double defRV = 0.0;</span>

      @Override
      public void clear() {
<span class="fc" id="L2627">        map.clear();</span>
<span class="fc" id="L2628">        total = 0.0;</span>
<span class="fc" id="L2629">      }</span>

      @Override
      public boolean containsKey(E key) {
<span class="fc" id="L2633">        return map.containsKey(key);</span>
      }

      @Override
      public void setDefaultReturnValue(double rv) {
<span class="fc" id="L2638">        defRV = rv;</span>
<span class="fc" id="L2639">      }</span>

      @Override
      public double defaultReturnValue() {
<span class="fc" id="L2643">        return defRV;</span>
      }

      @Override
      @SuppressWarnings(&quot;unchecked&quot;)
      public boolean equals(Object o) {
<span class="pc bpc" id="L2649" title="1 of 2 branches missed.">        if (this == o) {</span>
<span class="nc" id="L2650">          return true;</span>
<span class="pc bpc" id="L2651" title="1 of 2 branches missed.">        } else if (!(o instanceof Counter)) {</span>
<span class="nc" id="L2652">          return false;</span>
        } else {
<span class="fc" id="L2654">          return Counters.equals(this, (Counter&lt;E&gt;) o);</span>
        }
      }

      @Override
      public int hashCode() {
<span class="nc" id="L2660">        return map.hashCode();</span>
      }

      public Set&lt;Entry&lt;E, Double&gt;&gt; entrySet() {
<span class="fc" id="L2664">        return new AbstractSet&lt;Entry&lt;E, Double&gt;&gt;() {</span>
<span class="fc" id="L2665">          Set&lt;Entry&lt;E, N&gt;&gt; entries = map.entrySet();</span>

          @Override
          public Iterator&lt;Entry&lt;E, Double&gt;&gt; iterator() {
<span class="fc" id="L2669">            return new Iterator&lt;Entry&lt;E, Double&gt;&gt;() {</span>
<span class="fc" id="L2670">              Iterator&lt;Entry&lt;E, N&gt;&gt; it = entries.iterator();</span>
              Entry&lt;E, N&gt; lastEntry; // = null;

              public boolean hasNext() {
<span class="fc" id="L2674">                return it.hasNext();</span>
              }

              public Entry&lt;E, Double&gt; next() {
<span class="fc" id="L2678">                final Entry&lt;E, N&gt; entry = it.next();</span>
<span class="fc" id="L2679">                lastEntry = entry;</span>

<span class="fc" id="L2681">                return new Entry&lt;E, Double&gt;() {</span>
                  public E getKey() {
<span class="fc" id="L2683">                    return entry.getKey();</span>
                  }

                  public Double getValue() {
<span class="fc" id="L2687">                    return entry.getValue().doubleValue();</span>
                  }

                  public Double setValue(Double value) {
<span class="fc" id="L2691">                    final double lastValue = entry.getValue().doubleValue();</span>
                    double rv;

<span class="pc bpc" id="L2694" title="1 of 2 branches missed.">                    if (type == Double.class) {</span>
<span class="fc" id="L2695">                      rv = ErasureUtils.&lt;Entry&lt;E, Double&gt;&gt; uncheckedCast(entry).setValue(value);</span>
<span class="nc bnc" id="L2696" title="All 2 branches missed.">                    } else if (type == Integer.class) {</span>
<span class="nc" id="L2697">                      rv = ErasureUtils.&lt;Entry&lt;E, Integer&gt;&gt; uncheckedCast(entry).setValue(value.intValue());</span>
<span class="nc bnc" id="L2698" title="All 2 branches missed.">                    } else if (type == Float.class) {</span>
<span class="nc" id="L2699">                      rv = ErasureUtils.&lt;Entry&lt;E, Float&gt;&gt; uncheckedCast(entry).setValue(value.floatValue());</span>
<span class="nc bnc" id="L2700" title="All 2 branches missed.">                    } else if (type == Long.class) {</span>
<span class="nc" id="L2701">                      rv = ErasureUtils.&lt;Entry&lt;E, Long&gt;&gt; uncheckedCast(entry).setValue(value.longValue());</span>
<span class="nc bnc" id="L2702" title="All 2 branches missed.">                    } else if (type == Short.class) {</span>
<span class="nc" id="L2703">                      rv = ErasureUtils.&lt;Entry&lt;E, Short&gt;&gt; uncheckedCast(entry).setValue(value.shortValue());</span>
                    } else {
<span class="nc" id="L2705">                      throw new RuntimeException(&quot;Unrecognized numeric type in wrapped counter&quot;);</span>
                    }

                    // need to call getValue().doubleValue() to make sure
                    // we keep the same precision as the underlying map
<span class="fc" id="L2710">                    total += entry.getValue().doubleValue() - lastValue;</span>

<span class="fc" id="L2712">                    return rv;</span>
                  }
                };
              }

              public void remove() {
<span class="nc" id="L2718">                total -= lastEntry.getValue().doubleValue();</span>
<span class="nc" id="L2719">                it.remove();</span>
<span class="nc" id="L2720">              }</span>
            };
          }

          @Override
          public int size() {
<span class="nc" id="L2726">            return map.size();</span>
          }
        };
      }

      public double getCount(Object key) {
<span class="fc" id="L2732">        final Number value = map.get(key);</span>
<span class="fc bfc" id="L2733" title="All 2 branches covered.">        return value != null ? value.doubleValue() : defRV;</span>
      }

      public Factory&lt;Counter&lt;E&gt;&gt; getFactory() {
<span class="fc" id="L2737">        return new Factory&lt;Counter&lt;E&gt;&gt;() {</span>

          private static final long serialVersionUID = -4063129407369590522L;

          public Counter&lt;E&gt; create() {
            // return a HashMap backed by the same numeric type to
            // keep the precision of the returned counter consistent with
            // this one's precision
<span class="fc" id="L2745">            return fromMap(Generics.&lt;E, N&gt;newHashMap(), type);</span>
          }
        };
      }

      public Set&lt;E&gt; keySet() {
<span class="fc" id="L2751">        return new AbstractSet&lt;E&gt;() {</span>
          @Override
          public Iterator&lt;E&gt; iterator() {
<span class="fc" id="L2754">            return new Iterator&lt;E&gt;() {</span>
<span class="fc" id="L2755">              Iterator&lt;E&gt; it = map.keySet().iterator();</span>

              public boolean hasNext() {
<span class="fc" id="L2758">                return it.hasNext();</span>
              }

              public E next() {
<span class="fc" id="L2762">                return it.next();</span>
              }

              public void remove() {
<span class="nc" id="L2766">                throw new UnsupportedOperationException(&quot;Cannot remove from key set&quot;);</span>
              }
            };
          }

          @Override
          public int size() {
<span class="fc" id="L2773">            return map.size();</span>
          }
        };
      }

      public double remove(E key) {
<span class="fc" id="L2779">        final Number removed = map.remove(key);</span>
<span class="pc bpc" id="L2780" title="1 of 2 branches missed.">        if (removed != null) {</span>
<span class="fc" id="L2781">          final double rv = removed.doubleValue();</span>
<span class="fc" id="L2782">          total -= rv;</span>
<span class="fc" id="L2783">          return rv;</span>
        }
<span class="nc" id="L2785">        return defRV;</span>
      }

      public void setCount(E key, double value) {
        final Double lastValue;
        double newValue;

<span class="pc bpc" id="L2792" title="1 of 2 branches missed.">        if (type == Double.class) {</span>
<span class="fc" id="L2793">          lastValue = ErasureUtils.&lt;Map&lt;E, Double&gt;&gt; uncheckedCast(map).put(key, value);</span>
<span class="fc" id="L2794">          newValue = value;</span>
<span class="nc bnc" id="L2795" title="All 2 branches missed.">        } else if (type == Integer.class) {</span>
<span class="nc" id="L2796">          final Integer last = ErasureUtils.&lt;Map&lt;E, Integer&gt;&gt; uncheckedCast(map).put(key, (int) value);</span>
<span class="nc bnc" id="L2797" title="All 2 branches missed.">          lastValue = last != null ? last.doubleValue() : null;</span>
<span class="nc" id="L2798">          newValue = ((int) value);</span>
<span class="nc bnc" id="L2799" title="All 2 branches missed.">        } else if (type == Float.class) {</span>
<span class="nc" id="L2800">          final Float last = ErasureUtils.&lt;Map&lt;E, Float&gt;&gt; uncheckedCast(map).put(key, (float) value);</span>
<span class="nc bnc" id="L2801" title="All 2 branches missed.">          lastValue = last != null ? last.doubleValue() : null;</span>
<span class="nc" id="L2802">          newValue = ((float) value);</span>
<span class="nc bnc" id="L2803" title="All 2 branches missed.">        } else if (type == Long.class) {</span>
<span class="nc" id="L2804">          final Long last = ErasureUtils.&lt;Map&lt;E, Long&gt;&gt; uncheckedCast(map).put(key, (long) value);</span>
<span class="nc bnc" id="L2805" title="All 2 branches missed.">          lastValue = last != null ? last.doubleValue() : null;</span>
<span class="nc" id="L2806">          newValue = ((long) value);</span>
<span class="nc bnc" id="L2807" title="All 2 branches missed.">        } else if (type == Short.class) {</span>
<span class="nc" id="L2808">          final Short last = ErasureUtils.&lt;Map&lt;E, Short&gt;&gt; uncheckedCast(map).put(key, (short) value);</span>
<span class="nc bnc" id="L2809" title="All 2 branches missed.">          lastValue = last != null ? last.doubleValue() : null;</span>
<span class="nc" id="L2810">          newValue = ((short) value);</span>
<span class="nc" id="L2811">        } else {</span>
<span class="nc" id="L2812">          throw new RuntimeException(&quot;Unrecognized numeric type in wrapped counter&quot;);</span>
        }

        // need to use newValue instead of value to make sure we
        // keep same precision as underlying map.
<span class="fc bfc" id="L2817" title="All 2 branches covered.">        total += newValue - (lastValue != null ? lastValue : 0);</span>
<span class="fc" id="L2818">      }</span>

      public int size() {
<span class="fc" id="L2821">        return map.size();</span>
      }

      public double totalCount() {
<span class="fc" id="L2825">        return total;</span>
      }

      public Collection&lt;Double&gt; values() {
<span class="fc" id="L2829">        return new AbstractCollection&lt;Double&gt;() {</span>
          @Override
          public Iterator&lt;Double&gt; iterator() {
<span class="fc" id="L2832">            return new Iterator&lt;Double&gt;() {</span>
<span class="fc" id="L2833">              final Iterator&lt;N&gt; it = map.values().iterator();</span>

              public boolean hasNext() {
<span class="fc" id="L2836">                return it.hasNext();</span>
              }

              public Double next() {
<span class="fc" id="L2840">                return it.next().doubleValue();</span>
              }

              public void remove() {
<span class="nc" id="L2844">                throw new UnsupportedOperationException(&quot;Cannot remove from values collection&quot;);</span>
              }
            };
          }

          @Override
          public int size() {
<span class="nc" id="L2851">            return map.size();</span>
          }
        };
      }

      /**
       * {@inheritDoc}
       */
      public void prettyLog(RedwoodChannels channels, String description) {
<span class="nc" id="L2860">        PrettyLogger.log(channels, description, map);</span>
<span class="nc" id="L2861">      }</span>
    };
  } // end fromMap()

  /**
   * Returns a map view of the given counter.
   */
  public static &lt;E&gt; Map&lt;E, Double&gt; asMap(final Counter&lt;E&gt; counter) {
<span class="nc" id="L2869">    return new AbstractMap&lt;E, Double&gt;() {</span>
      @Override
      public int size() {
<span class="nc" id="L2872">        return counter.size();</span>
      }

      @Override
      public Set&lt;Entry&lt;E, Double&gt;&gt; entrySet() {
<span class="nc" id="L2877">        return counter.entrySet();</span>
      }

      @Override
      @SuppressWarnings(&quot;unchecked&quot;)
      public boolean containsKey(Object key) {
<span class="nc" id="L2883">        return counter.containsKey((E) key);</span>
      }

      @Override
      @SuppressWarnings(&quot;unchecked&quot;)
      public Double get(Object key) {
<span class="nc" id="L2889">        return counter.getCount((E) key);</span>
      }

      @Override
      public Double put(E key, Double value) {
<span class="nc" id="L2894">        double last = counter.getCount(key);</span>
<span class="nc" id="L2895">        counter.setCount(key, value);</span>
<span class="nc" id="L2896">        return last;</span>
      }

      @Override
      @SuppressWarnings(&quot;unchecked&quot;)
      public Double remove(Object key) {
<span class="nc" id="L2902">        return counter.remove((E) key);</span>
      }

      @Override
      public Set&lt;E&gt; keySet() {
<span class="nc" id="L2907">        return counter.keySet();</span>
      }
    };
  }

  /**
   * Check if this counter is a uniform distribution.
   * That is, it should sum to 1.0, and every value should be equal to every other value.
   * @param distribution The distribution to check.
   * @param tolerance The tolerance for floating point error, in both the equality and total count checks.
   * @param &lt;E&gt; The type of the counter.
   * @return True if this counter is the uniform distribution over its domain.
   */
  public static &lt;E&gt; boolean isUniformDistribution(Counter&lt;E&gt; distribution, double tolerance) {
<span class="nc" id="L2921">    double value = Double.NaN;</span>
<span class="nc" id="L2922">    double totalCount = 0.0;</span>
<span class="nc bnc" id="L2923" title="All 2 branches missed.">    for (double val : distribution.values()) {</span>
<span class="nc bnc" id="L2924" title="All 2 branches missed.">      if (Double.isNaN(value)) { value = val; }</span>
<span class="nc bnc" id="L2925" title="All 2 branches missed.">      if (Math.abs(val - value) &gt; tolerance) { return false; }</span>
<span class="nc" id="L2926">      totalCount += val;</span>
<span class="nc" id="L2927">    }</span>
<span class="nc bnc" id="L2928" title="All 2 branches missed.">    return Math.abs(totalCount - 1.0) &lt; tolerance;</span>
  }

  /**
   * Default comparator for breaking ties in argmin and argmax.
   * //TODO: What type should this be?
   * // Unused, so who cares?
   * private static final Comparator&lt;Object&gt; hashCodeComparator =
   *   new Comparator&lt;Object&gt;() {
   *     public int compare(Object o1, Object o2) {
   *      return o1.hashCode() - o2.hashCode();
   *     }
   *
   *     public boolean equals(Comparator comparator) {
   *       return (comparator == this);
   *     }
   *  };
   */

  /**
   * Comparator that uses natural ordering. Returns 0 if o1 is not Comparable.
   */
  static class NaturalComparator&lt;E&gt; implements Comparator&lt;E&gt; {
<span class="nc" id="L2951">    public NaturalComparator() {</span>
<span class="nc" id="L2952">    }</span>

    @Override
    public String toString() {
<span class="nc" id="L2956">      return &quot;NaturalComparator&quot;;</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    public int compare(E o1, E o2) {
<span class="nc bnc" id="L2961" title="All 2 branches missed.">      if (o1 instanceof Comparable) {</span>
<span class="nc" id="L2962">        return (((Comparable&lt;E&gt;) o1).compareTo(o2));</span>
      }
<span class="nc" id="L2964">      return 0; // soft-fail</span>
    }
  }

  /**
   *
   * @param &lt;E&gt;
   * @param originalCounter
   * @return a copy of the original counter
   */
  public static &lt;E&gt; Counter&lt;E&gt; getCopy(Counter&lt;E&gt; originalCounter) {
<span class="nc" id="L2975">    Counter&lt;E&gt; copyCounter = new ClassicCounter&lt;&gt;();</span>
<span class="nc" id="L2976">    copyCounter.addAll(originalCounter);</span>
<span class="nc" id="L2977">    return copyCounter;</span>
  }

  /**
   * Places the maximum of first and second keys values in the first counter.
   * @param &lt;E&gt;
   */
  public static &lt;E&gt; void maxInPlace(Counter&lt;E&gt; target, Counter&lt;E&gt; other) {
<span class="nc bnc" id="L2985" title="All 2 branches missed.">   for(E e: CollectionUtils.union(other.keySet(), target.keySet())){</span>
<span class="nc" id="L2986">     target.setCount(e, Math.max(target.getCount(e), other.getCount(e)));</span>
<span class="nc" id="L2987">   }</span>
<span class="nc" id="L2988">  }</span>

  /**
   * Places the minimum of first and second keys values in the first counter.
   * @param &lt;E&gt;
   */
  public static &lt;E&gt; void minInPlace(Counter&lt;E&gt; target, Counter&lt;E&gt; other){
<span class="nc bnc" id="L2995" title="All 2 branches missed.">   for(E e: CollectionUtils.union(other.keySet(), target.keySet())){</span>
<span class="nc" id="L2996">     target.setCount(e, Math.min(target.getCount(e), other.getCount(e)));</span>
<span class="nc" id="L2997">   }</span>
<span class="nc" id="L2998">  }</span>

  /**
   * Retains the minimal set of top keys such that their count sum is more than thresholdCount.
   * @param counter
   * @param thresholdCount
   */
  public static&lt;E&gt; void retainTopMass(Counter&lt;E&gt; counter, double thresholdCount){
<span class="fc" id="L3006">    PriorityQueue&lt;E&gt; queue = Counters.toPriorityQueue(counter);</span>
<span class="fc" id="L3007">    counter.clear();</span>

<span class="fc" id="L3009">    double mass = 0;</span>
<span class="pc bpc" id="L3010" title="1 of 4 branches missed.">    while (mass &lt; thresholdCount &amp;&amp; !queue.isEmpty()) {</span>
<span class="fc" id="L3011">      double value = queue.getPriority();</span>
<span class="fc" id="L3012">      E key = queue.removeFirst();</span>
<span class="fc" id="L3013">      counter.setCount(key, value);</span>
<span class="fc" id="L3014">      mass += value;</span>
<span class="fc" id="L3015">    }</span>
<span class="fc" id="L3016">  }</span>

  public static&lt;A,B&gt; void divideInPlace(TwoDimensionalCounter&lt;A, B&gt; counter, double divisor) {
<span class="fc bfc" id="L3019" title="All 2 branches covered.">    for(Entry&lt;A, ClassicCounter&lt;B&gt;&gt; c: counter.entrySet()){</span>
<span class="fc" id="L3020">      Counters.divideInPlace(c.getValue(), divisor);</span>
<span class="fc" id="L3021">    }</span>
<span class="fc" id="L3022">    counter.recomputeTotal();</span>
<span class="fc" id="L3023">  }</span>

  public static&lt;E&gt; double pearsonsCorrelationCoefficient(Counter&lt;E&gt; x, Counter&lt;E&gt; y){
<span class="fc" id="L3026">    double stddevX = Counters.standardDeviation(x);</span>
<span class="fc" id="L3027">    double stddevY = Counters.standardDeviation(y);</span>
<span class="fc" id="L3028">    double meanX = Counters.mean(x);</span>
<span class="fc" id="L3029">    double meanY = Counters.mean(y);</span>
<span class="fc" id="L3030">    Counter&lt;E&gt; t1 = Counters.add(x, -meanX);</span>
<span class="fc" id="L3031">    Counter&lt;E&gt; t2 = Counters.add(y, -meanY);</span>
<span class="fc" id="L3032">    Counters.divideInPlace(t1, stddevX);</span>
<span class="fc" id="L3033">    Counters.divideInPlace(t2, stddevY);</span>
<span class="fc" id="L3034">    return Counters.dotProduct(t1, t2)/ (double)(x.size() -1);</span>
  }

  public static&lt;E&gt; double spearmanRankCorrelation(Counter&lt;E&gt; x, Counter&lt;E&gt; y){
<span class="nc" id="L3038">    Counter&lt;E&gt; xrank = Counters.toTiedRankCounter(x);</span>
<span class="nc" id="L3039">    Counter&lt;E&gt; yrank = Counters.toTiedRankCounter(y);</span>
<span class="nc" id="L3040">    return Counters.pearsonsCorrelationCoefficient(xrank, yrank);</span>
  }

  /**
   * ensures that counter t has all keys in keys. If the counter does not have the keys, then add the key with count value.
   * Note that it does not change counts that exist in the counter
   */
  public static&lt;E&gt; void ensureKeys(Counter&lt;E&gt; t, Collection&lt;E&gt; keys, double value){
<span class="nc bnc" id="L3048" title="All 2 branches missed.">    for(E k: keys){</span>
<span class="nc bnc" id="L3049" title="All 2 branches missed.">      if(!t.containsKey(k))</span>
<span class="nc" id="L3050">        t.setCount(k, value);</span>
<span class="nc" id="L3051">    }</span>
<span class="nc" id="L3052">  }</span>

  public static&lt;E&gt; List&lt;E&gt; topKeys(Counter&lt;E&gt; t, int topNum){
<span class="nc" id="L3055">    List&lt;E&gt; list = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L3056">    PriorityQueue&lt;E&gt; q = Counters.toPriorityQueue(t);</span>
<span class="nc" id="L3057">    int num = 0;</span>
<span class="nc bnc" id="L3058" title="All 4 branches missed.">    while(!q.isEmpty() &amp;&amp; num &lt; topNum){</span>
<span class="nc" id="L3059">     num++;</span>
<span class="nc" id="L3060">     list.add(q.removeFirst());</span>
    }
<span class="nc" id="L3062">    return list;</span>
  }

  public static&lt;E&gt; List&lt;Pair&lt;E, Double&gt;&gt; topKeysWithCounts(Counter&lt;E&gt; t, int topNum){
<span class="nc" id="L3066">    List&lt;Pair&lt;E, Double&gt;&gt; list = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L3067">    PriorityQueue&lt;E&gt; q = Counters.toPriorityQueue(t);</span>
<span class="nc" id="L3068">    int num = 0;</span>
<span class="nc bnc" id="L3069" title="All 4 branches missed.">    while(!q.isEmpty() &amp;&amp; num &lt; topNum){</span>
<span class="nc" id="L3070">     num++;</span>
<span class="nc" id="L3071">     E k = q.removeFirst();</span>
<span class="nc" id="L3072">     list.add(new Pair&lt;&gt;(k, t.getCount(k)));</span>
<span class="nc" id="L3073">    }</span>
<span class="nc" id="L3074">    return list;</span>
  }

  public static&lt;E&gt; Counter&lt;E&gt; getFCounter(Counter&lt;E&gt; precision, Counter&lt;E&gt; recall, double beta){
<span class="nc" id="L3078">    Counter&lt;E&gt; fscores = new ClassicCounter&lt;&gt;();</span>
<span class="nc bnc" id="L3079" title="All 2 branches missed.">    for(E k: precision.keySet()){</span>
<span class="nc" id="L3080">      fscores.setCount(k, precision.getCount(k)*recall.getCount(k)*(1+beta*beta)/(beta*beta*precision.getCount(k) + recall.getCount(k)));</span>
<span class="nc" id="L3081">    }</span>
<span class="nc" id="L3082">    return fscores;</span>
  }

  public static &lt;E&gt; void transformValuesInPlace(Counter&lt;E&gt; counter, Function&lt;Double, Double&gt; func){
<span class="nc bnc" id="L3086" title="All 2 branches missed.">    for(E key: counter.keySet()){</span>
<span class="nc" id="L3087">      counter.setCount(key, func.apply(counter.getCount(key)));</span>
<span class="nc" id="L3088">    }</span>
<span class="nc" id="L3089">  }</span>

  public static&lt;E&gt; Counter&lt;E&gt; getCounts(Counter&lt;E&gt; c, Collection&lt;E&gt; keys){
<span class="nc" id="L3092">    Counter&lt;E&gt; newcounter = new ClassicCounter&lt;&gt;();</span>
<span class="nc bnc" id="L3093" title="All 2 branches missed.">    for(E k : keys)</span>
<span class="nc" id="L3094">      newcounter.setCount(k, c.getCount(k));</span>
<span class="nc" id="L3095">    return newcounter;</span>
  }


  public static&lt;E&gt; void retainKeys(Counter&lt;E&gt; counter, Function&lt;E, Boolean&gt; retainFunction) {
<span class="nc" id="L3100">    Set&lt;E&gt; remove = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L3101" title="All 2 branches missed.">    for(Entry&lt;E, Double&gt; en: counter.entrySet()){</span>
<span class="nc bnc" id="L3102" title="All 2 branches missed.">      if(!retainFunction.apply(en.getKey())){</span>
<span class="nc" id="L3103">        remove.add(en.getKey());</span>
      }
<span class="nc" id="L3105">    }</span>
<span class="nc" id="L3106">    Counters.removeKeys(counter, remove);</span>
<span class="nc" id="L3107">  }</span>

  public static&lt;E, E2&gt; Counter&lt;E&gt; flatten(Map&lt;E2, Counter&lt;E&gt;&gt; hier){
<span class="fc" id="L3110">    Counter&lt;E&gt; flat = new ClassicCounter&lt;&gt;();</span>
<span class="fc bfc" id="L3111" title="All 2 branches covered.">    for(Entry&lt;E2, Counter&lt;E&gt;&gt; en: hier.entrySet()){</span>
<span class="fc" id="L3112">      flat.addAll(en.getValue());</span>
<span class="fc" id="L3113">    }</span>
<span class="fc" id="L3114">    return flat;</span>
  }

  /**
   * Returns true if the given counter contains only finite, non-NaN values.
   * @param counts The counter to validate.
   * @param &lt;E&gt; The parameterized type of the counter.
   * @return True if the counter is finite and not NaN on every value.
   */
  public static &lt;E&gt; boolean isFinite(Counter&lt;E&gt; counts) {
<span class="nc bnc" id="L3124" title="All 2 branches missed.">    for (double value : counts.values()) {</span>
<span class="nc bnc" id="L3125" title="All 4 branches missed.">      if (Double.isInfinite(value) || Double.isNaN(value)) {</span>
<span class="nc" id="L3126">        return false;</span>
      }
<span class="nc" id="L3128">    }</span>
<span class="nc" id="L3129">    return true;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>