<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IntervalTree.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.util</a> &gt; <span class="el_source">IntervalTree.java</span></div><h1>IntervalTree.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.util; 
import edu.stanford.nlp.util.logging.Redwood;

import java.util.*;
import java.util.function.Function;

/**
 * An interval tree maintains a tree so that all intervals to the left start
 * before current interval and all intervals to the right start after.
 *
 * @author Angel Chang
 */
<span class="fc" id="L13">public class IntervalTree&lt;E extends Comparable&lt;E&gt;, T extends HasInterval&lt;E&gt;&gt; extends AbstractCollection&lt;T&gt;</span>
{
  private static final double defaultAlpha = 0.65; // How balanced we want this tree (between 0.5 and 1.0)
  private static final boolean debug = false;

<span class="fc" id="L18">  private TreeNode&lt;E,T&gt; root = new TreeNode&lt;&gt;();</span>

  // Tree node
<span class="fc" id="L21">  public static class TreeNode&lt;E extends Comparable&lt;E&gt;, T extends HasInterval&lt;E&gt;&gt; {</span>
    T value;
    E maxEnd;    // Maximum end in this subtree
    int size;

    TreeNode&lt;E,T&gt; left;
    TreeNode&lt;E,T&gt; right;

    TreeNode&lt;E,T&gt; parent; // Parent for convenience

<span class="fc bfc" id="L31" title="All 2 branches covered.">    public boolean isEmpty() { return value == null; }</span>

    public void clear() {
<span class="fc" id="L34">      value = null;</span>
<span class="fc" id="L35">      maxEnd = null;</span>
<span class="fc" id="L36">      size = 0;</span>
<span class="fc" id="L37">      left = null;</span>
<span class="fc" id="L38">      right = null;</span>
//      parent = null;
<span class="fc" id="L40">    }</span>
  }

  @Override
<span class="nc" id="L44">  public boolean isEmpty() { return root.isEmpty(); }</span>

  @Override
  public void clear() {
<span class="fc" id="L48">    root.clear();</span>
<span class="fc" id="L49">  }</span>

  public String toString() {
<span class="nc" id="L52">    return &quot;Size: &quot; + root.size;</span>
  }

  @Override
  public boolean add(T target) {
<span class="fc" id="L57">    return add(root, target, defaultAlpha);</span>
  }

  public boolean add(TreeNode&lt;E,T&gt; node, T target) {
<span class="nc" id="L61">    return add(node, target, defaultAlpha);</span>
  }

  // Add node to tree - attempting to maintain alpha balance
  public boolean add(TreeNode&lt;E,T&gt; node, T target, double alpha) {
<span class="pc bpc" id="L66" title="1 of 2 branches missed.">    if (target == null) return false;</span>
<span class="fc" id="L67">    TreeNode&lt;E,T&gt; n = node;</span>
<span class="fc" id="L68">    int depth = 0;</span>
<span class="fc bfc" id="L69" title="All 2 branches covered.">    int thresholdDepth = (node.size &gt; 10)? ((int) (-Math.log(node.size)/Math.log(alpha)+1)):10;</span>
<span class="pc bpc" id="L70" title="1 of 2 branches missed.">    while (n != null) {</span>
<span class="fc bfc" id="L71" title="All 2 branches covered.">      if (n.value == null) {</span>
<span class="fc" id="L72">        n.value = target;</span>
<span class="fc" id="L73">        n.maxEnd = target.getInterval().getEnd();</span>
<span class="fc" id="L74">        n.size = 1;</span>
<span class="fc bfc" id="L75" title="All 2 branches covered.">        if (depth &gt; thresholdDepth) {</span>
          // Do rebalancing
<span class="fc" id="L77">          TreeNode&lt;E,T&gt; p = n.parent;</span>
<span class="fc bfc" id="L78" title="All 2 branches covered.">          while (p != null) {</span>
<span class="fc bfc" id="L79" title="All 4 branches covered.">            if (p.size &gt; 10 &amp;&amp; !isAlphaBalanced(p,alpha)) {</span>
<span class="fc" id="L80">              TreeNode&lt;E,T&gt; newParent = balance(p);</span>
<span class="fc bfc" id="L81" title="All 2 branches covered.">              if (p == root) root = newParent;</span>
              if (debug) this.check();
              break;
            }
<span class="fc" id="L85">            p = p.parent;</span>
          }
        }
<span class="fc" id="L88">        return true;</span>
      } else {
<span class="fc" id="L90">        depth++;</span>
<span class="fc" id="L91">        n.maxEnd = Interval.max(n.maxEnd, target.getInterval().getEnd());</span>
<span class="fc" id="L92">        n.size++;</span>
<span class="fc bfc" id="L93" title="All 2 branches covered.">        if (target.getInterval().compareTo(n.value.getInterval()) &lt;= 0) {</span>
          // Should go on left
<span class="fc bfc" id="L95" title="All 2 branches covered.">          if (n.left == null) {</span>
<span class="fc" id="L96">            n.left = new TreeNode&lt;&gt;();</span>
<span class="fc" id="L97">            n.left.parent = n;</span>
          }
<span class="fc" id="L99">          n = n.left;</span>
        } else {
          // Should go on right
<span class="fc bfc" id="L102" title="All 2 branches covered.">          if (n.right == null) {</span>
<span class="fc" id="L103">            n.right = new TreeNode&lt;&gt;();</span>
<span class="fc" id="L104">            n.right.parent = n;</span>
          }
<span class="fc" id="L106">          n = n.right;</span>
        }
      }
    }
<span class="nc" id="L110">    return false;</span>
  }

  @Override
  public int size()
  {
<span class="fc" id="L116">    return root.size;</span>
  }

  @Override
  public Iterator&lt;T&gt; iterator() {
<span class="fc" id="L121">    return new TreeNodeIterator&lt;&gt;(root);</span>
  }

  private static class TreeNodeIterator&lt;E extends Comparable&lt;E&gt;, T extends HasInterval&lt;E&gt;&gt; extends AbstractIterator&lt;T&gt; {
    TreeNode&lt;E,T&gt; node;
    Iterator&lt;T&gt; curIter;
<span class="fc" id="L127">    int stage = -1;</span>
    T next;

<span class="fc" id="L130">    public TreeNodeIterator(TreeNode&lt;E,T&gt; node) {</span>
<span class="fc" id="L131">      this.node = node;</span>
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">      if (node.isEmpty()) {</span>
<span class="nc" id="L133">        stage = 3;</span>
      }
<span class="fc" id="L135">    }</span>

    @Override
    public boolean hasNext() {
<span class="fc bfc" id="L139" title="All 2 branches covered.">      if (next == null) {</span>
<span class="fc" id="L140">        next = getNext();</span>
      }
<span class="fc bfc" id="L142" title="All 2 branches covered.">      return next != null;</span>
    }

    @Override
    public T next() {
<span class="pc bpc" id="L147" title="1 of 2 branches missed.">      if (hasNext()) {</span>
<span class="fc" id="L148">        T x = next;</span>
<span class="fc" id="L149">        next = getNext();</span>
<span class="fc" id="L150">        return x;</span>
<span class="nc" id="L151">      } else throw new NoSuchElementException();</span>
    }

    private T getNext() {
      // TODO: Do more efficient traversal down the tree
<span class="fc bfc" id="L156" title="All 2 branches covered.">      if (stage &gt; 2) return null;</span>
<span class="fc bfc" id="L157" title="All 4 branches covered.">      while (curIter == null || !curIter.hasNext()) {</span>
<span class="fc" id="L158">        stage++;</span>
<span class="fc bfc" id="L159" title="All 4 branches covered.">        switch (stage) {</span>
          case 0:
<span class="fc bfc" id="L161" title="All 2 branches covered.">            curIter = (node.left != null)? new TreeNodeIterator&lt;&gt;(node.left):null;</span>
<span class="fc" id="L162">            break;</span>
          case 1:
<span class="fc" id="L164">            curIter = null;</span>
<span class="fc" id="L165">            return node.value;</span>
          case 2:
<span class="fc bfc" id="L167" title="All 2 branches covered.">            curIter = (node.right != null)? new TreeNodeIterator&lt;&gt;(node.right):null;</span>
<span class="fc" id="L168">            break;</span>
          default:
<span class="fc" id="L170">            return null;</span>
        }
      }
<span class="pc bpc" id="L173" title="2 of 4 branches missed.">      if (curIter != null &amp;&amp; curIter.hasNext()) {</span>
<span class="fc" id="L174">        return curIter.next();</span>
<span class="nc" id="L175">      } else return null;</span>
    }
  }

  @Override
  public boolean removeAll(Collection&lt;?&gt; c) {
<span class="nc" id="L181">    boolean modified = false;</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">    for (Object t:c) {</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">      if (remove(t)) { modified = true; }</span>
<span class="nc" id="L184">    }</span>
<span class="nc" id="L185">    return modified;</span>
  }

  @Override
  public boolean retainAll(Collection&lt;?&gt; c) {
<span class="nc" id="L190">    throw new UnsupportedOperationException(&quot;retainAll not implemented&quot;);</span>
  }

  @Override
  public boolean contains(Object o) {
    try {
<span class="nc" id="L196">      return contains((T) o);</span>
<span class="nc" id="L197">    } catch (ClassCastException ex) {</span>
<span class="nc" id="L198">      return false;</span>
    }
  }

  @Override
  public boolean remove(Object o) {
    try {
<span class="nc" id="L205">      return remove((T) o);</span>
<span class="nc" id="L206">    } catch (ClassCastException ex) {</span>
<span class="nc" id="L207">      return false;</span>
    }
  }

  public boolean remove(T target) {
<span class="fc" id="L212">    return remove(root, target);</span>
  }

  public boolean remove(TreeNode&lt;E,T&gt; node, T target)
  {
<span class="pc bpc" id="L217" title="1 of 2 branches missed.">    if (target == null) return false;</span>
<span class="pc bpc" id="L218" title="1 of 2 branches missed.">    if (node.value == null) return false;</span>
<span class="pc bpc" id="L219" title="1 of 2 branches missed.">    if (target.equals(node.value)) {</span>
<span class="pc bpc" id="L220" title="1 of 2 branches missed.">      int leftSize = (node.left != null)? node.left.size:0;</span>
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">      int rightSize = (node.right != null)? node.right.size:0;</span>
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">      if (leftSize == 0) {</span>
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">        if (rightSize == 0) {</span>
<span class="fc" id="L224">          node.clear();</span>
        } else {
<span class="nc" id="L226">          node.value = node.right.value;</span>
<span class="nc" id="L227">          node.size = node.right.size;</span>
<span class="nc" id="L228">          node.maxEnd = node.right.maxEnd;</span>
<span class="nc" id="L229">          node.left = node.right.left;</span>
<span class="nc" id="L230">          node.right = node.right.right;</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">          if (node.left != null) node.left.parent = node;</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">          if (node.right != null) node.right.parent = node;</span>
        }
<span class="nc bnc" id="L234" title="All 2 branches missed.">      } else if (rightSize == 0) {</span>
<span class="nc" id="L235">        node.value = node.left.value;</span>
<span class="nc" id="L236">        node.size = node.left.size;</span>
<span class="nc" id="L237">        node.maxEnd = node.left.maxEnd;</span>
<span class="nc" id="L238">        node.left = node.left.left;</span>
<span class="nc" id="L239">        node.right = node.left.right;</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">        if (node.left != null) node.left.parent = node;</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">        if (node.right != null) node.right.parent = node;</span>
      } else {
        // Rotate left up
<span class="nc" id="L244">        node.value = node.left.value;</span>
<span class="nc" id="L245">        node.size--;</span>
<span class="nc" id="L246">        node.maxEnd = Interval.max(node.left.maxEnd, node.right.maxEnd);</span>
<span class="nc" id="L247">        TreeNode&lt;E,T&gt; origRight = node.right;</span>
<span class="nc" id="L248">        node.right = node.left.right;</span>
<span class="nc" id="L249">        node.left = node.left.left;</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">        if (node.left != null) node.left.parent = node;</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">        if (node.right != null) node.right.parent = node;</span>

        // Attach origRight somewhere...
<span class="nc" id="L254">        TreeNode&lt;E,T&gt; rightmost = getRightmostNode(node);</span>
<span class="nc" id="L255">        rightmost.right = origRight;</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">        if (rightmost.right != null) {</span>
<span class="nc" id="L257">          rightmost.right.parent = rightmost;</span>
          // adjust maxEnd and sizes on the right
<span class="nc" id="L259">          adjustUpwards(rightmost.right,node);</span>
        }
      }
<span class="fc" id="L262">      return true;</span>
    } else {
<span class="nc bnc" id="L264" title="All 2 branches missed.">      if (target.getInterval().compareTo(node.value.getInterval()) &lt;= 0) {</span>
        // Should go on left
<span class="nc bnc" id="L266" title="All 2 branches missed.">        if (node.left == null) {</span>
<span class="nc" id="L267">          return false;</span>
        }
<span class="nc" id="L269">        boolean res = remove(node.left, target);</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">        if (res) {</span>
<span class="nc" id="L271">          node.maxEnd = Interval.max(node.maxEnd, node.left.maxEnd);</span>
<span class="nc" id="L272">          node.size--;</span>
        }
<span class="nc" id="L274">        return res;</span>
      } else {
        // Should go on right
<span class="nc bnc" id="L277" title="All 2 branches missed.">        if (node.right == null) {</span>
<span class="nc" id="L278">          return false;</span>
        }
<span class="nc" id="L280">        boolean res = remove(node.right, target);</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">        if (res) {</span>
<span class="nc" id="L282">          node.maxEnd = Interval.max(node.maxEnd, node.right.maxEnd);</span>
<span class="nc" id="L283">          node.size--;</span>
        }
<span class="nc" id="L285">        return res;</span>
      }
    }
  }

  private void adjustUpwards(TreeNode&lt;E,T&gt; node) {
<span class="nc" id="L291">    adjustUpwards(node, null);</span>
<span class="nc" id="L292">  }</span>

  // Adjust upwards starting at this node until stopAt
  private void adjustUpwards(TreeNode&lt;E,T&gt; node, TreeNode&lt;E,T&gt; stopAt) {
<span class="fc" id="L296">    TreeNode&lt;E,T&gt; n = node;</span>
<span class="pc bpc" id="L297" title="1 of 4 branches missed.">    while (n != null &amp;&amp; n != stopAt) {</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">      int leftSize = (n.left != null)? n.left.size:0;</span>
<span class="fc bfc" id="L299" title="All 2 branches covered.">      int rightSize = (n.right != null)? n.right.size:0;</span>
<span class="fc" id="L300">      n.maxEnd = n.value.getInterval().getEnd();</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">      if (n.left != null) {</span>
<span class="fc" id="L302">        n.maxEnd = Interval.max(n.maxEnd, n.left.maxEnd);</span>
      }
<span class="fc bfc" id="L304" title="All 2 branches covered.">      if (n.right != null) {</span>
<span class="fc" id="L305">        n.maxEnd = Interval.max(n.maxEnd, n.right.maxEnd);</span>
      }
<span class="fc" id="L307">      n.size = leftSize + 1 + rightSize;</span>
<span class="pc bpc" id="L308" title="1 of 2 branches missed.">      if (n == n.parent) {</span>
<span class="nc" id="L309">         throw new IllegalStateException(&quot;node is same as parent!!!&quot;);</span>
      }
<span class="fc" id="L311">      n = n.parent;</span>
<span class="fc" id="L312">    }</span>
<span class="fc" id="L313">  }</span>

  private void adjust(TreeNode&lt;E,T&gt; node) {
<span class="fc" id="L316">    adjustUpwards(node, node.parent);</span>
<span class="fc" id="L317">  }</span>

  public void check() {
<span class="fc" id="L320">    check(root);</span>
<span class="fc" id="L321">  }</span>

  public void check(TreeNode&lt;E,T&gt; treeNode) {
<span class="fc" id="L324">    Stack&lt;TreeNode&lt;E,T&gt;&gt; todo = new Stack&lt;&gt;();</span>
<span class="fc" id="L325">    todo.add(treeNode);</span>
<span class="fc bfc" id="L326" title="All 2 branches covered.">    while (!todo.isEmpty()) {</span>
<span class="fc" id="L327">      TreeNode&lt;E,T&gt; node = todo.pop();</span>
<span class="pc bpc" id="L328" title="1 of 2 branches missed.">      if (node == node.parent) {</span>
<span class="nc" id="L329">        throw new IllegalStateException(&quot;node is same as parent!!!&quot;);</span>
      }
<span class="pc bpc" id="L331" title="1 of 2 branches missed.">      if (node.isEmpty()) {</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">        if (node.left != null) throw new IllegalStateException(&quot;Empty node shouldn't have left branch&quot;);</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">        if (node.right != null) throw new IllegalStateException(&quot;Empty node shouldn't have right branch&quot;);</span>
        continue;
      }
<span class="fc bfc" id="L336" title="All 2 branches covered.">      int leftSize = (node.left != null)? node.left.size:0;</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">      int rightSize = (node.right != null)? node.right.size:0;</span>
<span class="fc bfc" id="L338" title="All 2 branches covered.">      E leftMax = (node.left != null)? node.left.maxEnd:null;</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">      E rightMax = (node.right != null)? node.right.maxEnd:null;</span>
<span class="fc" id="L340">      E maxEnd = node.value.getInterval().getEnd();</span>
<span class="pc bpc" id="L341" title="1 of 4 branches missed.">      if (leftMax != null &amp;&amp; leftMax.compareTo(maxEnd) &gt; 0) {</span>
<span class="nc" id="L342">        maxEnd = leftMax;</span>
      }
<span class="pc bpc" id="L344" title="1 of 4 branches missed.">      if (rightMax != null &amp;&amp; rightMax.compareTo(maxEnd) &gt; 0) {</span>
<span class="fc" id="L345">        maxEnd = rightMax;</span>
      }
<span class="pc bpc" id="L347" title="1 of 2 branches missed.">      if (!maxEnd.equals(node.maxEnd)) {</span>
<span class="nc" id="L348">        throw new IllegalStateException(&quot;max end is not as expected!!!&quot;);</span>
      }
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">      if (node.size != leftSize + rightSize + 1) {</span>
<span class="nc" id="L351">        throw new IllegalStateException(&quot;node size is not one plus the sum of left and right!!!&quot;);</span>
      }
<span class="fc bfc" id="L353" title="All 2 branches covered.">      if (node.left != null) {</span>
<span class="pc bpc" id="L354" title="1 of 2 branches missed.">        if (node.left.parent != node) {</span>
<span class="nc" id="L355">          throw new IllegalStateException(&quot;node left parent is not same as node!!!&quot;);</span>
        }
      }
<span class="fc bfc" id="L358" title="All 2 branches covered.">      if (node.right != null) {</span>
<span class="pc bpc" id="L359" title="1 of 2 branches missed.">        if (node.right.parent != node) {</span>
<span class="nc" id="L360">          throw new IllegalStateException(&quot;node right parent is not same as node!!!&quot;);</span>
        }
      }
<span class="fc bfc" id="L363" title="All 2 branches covered.">      if (node.parent != null) {</span>
        // Go up parent and make sure we are on correct side
<span class="fc" id="L365">        TreeNode&lt;E,T&gt; n = node;</span>
<span class="pc bpc" id="L366" title="1 of 4 branches missed.">        while (n != null &amp;&amp; n.parent != null) {</span>
          // Check we are either right or left
<span class="fc bfc" id="L368" title="All 2 branches covered.">          if (n == n.parent.left) {</span>
            // Check that node is less than the parent
<span class="pc bpc" id="L370" title="1 of 2 branches missed.">            if (node.value != null) {</span>
<span class="pc bpc" id="L371" title="1 of 2 branches missed.">              if (node.value.getInterval().compareTo(n.parent.value.getInterval()) &gt; 0) {</span>
<span class="nc" id="L372">                throw new IllegalStateException(&quot;node is not on the correct side!!!&quot;);</span>
              }
            }
<span class="pc bpc" id="L375" title="1 of 2 branches missed.">          } else if (n == n.parent.right) {</span>
            // Check that node is greater than the parent
<span class="pc bpc" id="L377" title="1 of 2 branches missed.">            if (node.value.getInterval().compareTo(n.parent.value.getInterval()) &lt;= 0) {</span>
<span class="nc" id="L378">              throw new IllegalStateException(&quot;node is not on the correct side!!!&quot;);</span>
            }
          } else {
<span class="nc" id="L381">            throw new IllegalStateException(&quot;node is not parent's left or right child!!!&quot;);</span>
          }
<span class="fc" id="L383">          n = n.parent;</span>
        }
      }
<span class="fc bfc" id="L386" title="All 2 branches covered.">      if (node.left != null) todo.add(node.left);</span>
<span class="fc bfc" id="L387" title="All 2 branches covered.">      if (node.right != null) todo.add(node.right);</span>
<span class="fc" id="L388">    }</span>
<span class="fc" id="L389">  }</span>


  public boolean isAlphaBalanced(TreeNode&lt;E,T&gt; node, double alpha) {
<span class="fc bfc" id="L393" title="All 2 branches covered.">    int leftSize = (node.left != null)? node.left.size:0;</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">    int rightSize = (node.right != null)? node.right.size:0;</span>
<span class="fc" id="L395">    int threshold = (int) (alpha*node.size) + 1;</span>
<span class="fc bfc" id="L396" title="All 4 branches covered.">    return (leftSize &lt;= threshold) &amp;&amp; (rightSize &lt;= threshold);</span>
  }

  public void balance() {
<span class="fc" id="L400">    root = balance(root);</span>
<span class="fc" id="L401">  }</span>

  // Balances this tree
  public TreeNode&lt;E,T&gt; balance(TreeNode&lt;E,T&gt; node) {
    if (debug) check(node);
<span class="fc" id="L406">    Stack&lt;TreeNode&lt;E,T&gt;&gt; todo = new Stack&lt;&gt;();</span>
<span class="fc" id="L407">    todo.add(node);</span>
<span class="fc" id="L408">    TreeNode&lt;E,T&gt; newRoot = null;</span>
<span class="fc bfc" id="L409" title="All 2 branches covered.">    while (!todo.isEmpty()) {</span>
<span class="fc" id="L410">      TreeNode&lt;E,T&gt; n = todo.pop();</span>
      // Balance tree between this node
      // Select median nodes and try to balance the tree
<span class="fc" id="L413">      int medianAt = n.size/2;</span>
<span class="fc" id="L414">      TreeNode&lt;E,T&gt; median = getNode(n, medianAt);</span>
      // Okay, this is going to be our root
<span class="pc bpc" id="L416" title="1 of 4 branches missed.">      if (median != null &amp;&amp; median != n) {</span>
        // Yes, there is indeed something to be done
<span class="fc" id="L418">        rotateUp(median, n);</span>
      }
<span class="fc bfc" id="L420" title="All 2 branches covered.">      if (newRoot == null) {</span>
<span class="fc" id="L421">        newRoot = median;</span>
      }
<span class="fc bfc" id="L423" title="All 2 branches covered.">      if (median.left != null) todo.push(median.left);</span>
<span class="fc bfc" id="L424" title="All 2 branches covered.">      if (median.right != null) todo.push(median.right);</span>
<span class="fc" id="L425">    }</span>
<span class="pc bpc" id="L426" title="1 of 2 branches missed.">    if (newRoot == null) return node;</span>
<span class="fc" id="L427">    else return newRoot;</span>
  }

  // Moves this node up the tree until it replaces the target node
  public void rotateUp(TreeNode&lt;E,T&gt; node, TreeNode&lt;E,T&gt; target) {
<span class="fc" id="L432">    TreeNode&lt;E,T&gt; n = node;</span>
<span class="fc" id="L433">    boolean done = false;</span>
<span class="pc bpc" id="L434" title="1 of 6 branches missed.">    while (n != null &amp;&amp; n.parent != null &amp;&amp; !done) {</span>
      // Check if we are the left or right child
<span class="fc bfc" id="L436" title="All 2 branches covered.">      done = (n.parent == target);</span>
<span class="fc bfc" id="L437" title="All 2 branches covered.">      if (n == n.parent.left) {</span>
<span class="fc" id="L438">        n = rightRotate(n.parent);</span>
<span class="pc bpc" id="L439" title="1 of 2 branches missed.">      } else if (n == n.parent.right) {</span>
<span class="fc" id="L440">        n = leftRotate(n.parent);</span>
      } else {
<span class="nc" id="L442">        throw new IllegalStateException(&quot;Not on parent's left or right branches.&quot;);</span>
      }
      if (debug) check(n);
    }
<span class="fc" id="L446">  }</span>

  // Moves this node to the right and the left child up and returns the new root
  public TreeNode&lt;E,T&gt; rightRotate(TreeNode&lt;E,T&gt; oldRoot) {
<span class="pc bpc" id="L450" title="3 of 6 branches missed.">    if (oldRoot == null || oldRoot.isEmpty() || oldRoot.left == null) return oldRoot;</span>

<span class="fc" id="L452">    TreeNode&lt;E,T&gt; oldLeftRight = oldRoot.left.right;</span>

<span class="fc" id="L454">    TreeNode&lt;E,T&gt; newRoot = oldRoot.left;</span>
<span class="fc" id="L455">    newRoot.right = oldRoot;</span>
<span class="fc" id="L456">    oldRoot.left = oldLeftRight;</span>

    // Adjust parents and such
<span class="fc" id="L459">    newRoot.parent = oldRoot.parent;</span>
<span class="fc" id="L460">    newRoot.maxEnd = oldRoot.maxEnd;</span>
<span class="fc" id="L461">    newRoot.size = oldRoot.size;</span>
<span class="pc bpc" id="L462" title="1 of 2 branches missed.">    if (newRoot.parent != null) {</span>
<span class="fc bfc" id="L463" title="All 2 branches covered.">      if (newRoot.parent.left == oldRoot) {</span>
<span class="fc" id="L464">        newRoot.parent.left = newRoot;</span>
<span class="pc bpc" id="L465" title="1 of 2 branches missed.">      } else if (newRoot.parent.right == oldRoot) {</span>
<span class="fc" id="L466">        newRoot.parent.right = newRoot;</span>
      } else {
<span class="nc" id="L468">        throw new IllegalStateException(&quot;Old root not a child of it's parent&quot;);</span>
      }
    }

<span class="fc" id="L472">    oldRoot.parent = newRoot;</span>
<span class="fc bfc" id="L473" title="All 2 branches covered.">    if (oldLeftRight != null) oldLeftRight.parent = oldRoot;</span>
<span class="fc" id="L474">    adjust(oldRoot);</span>
<span class="fc" id="L475">    return newRoot;</span>
  }

  // Moves this node to the left and the right child up and returns the new root
  public TreeNode&lt;E,T&gt; leftRotate(TreeNode&lt;E,T&gt; oldRoot) {
<span class="pc bpc" id="L480" title="3 of 6 branches missed.">    if (oldRoot == null || oldRoot.isEmpty() || oldRoot.right == null) return oldRoot;</span>

<span class="fc" id="L482">    TreeNode&lt;E,T&gt; oldRightLeft = oldRoot.right.left;</span>

<span class="fc" id="L484">    TreeNode&lt;E,T&gt; newRoot = oldRoot.right;</span>
<span class="fc" id="L485">    newRoot.left = oldRoot;</span>
<span class="fc" id="L486">    oldRoot.right = oldRightLeft;</span>

    // Adjust parents and such
<span class="fc" id="L489">    newRoot.parent = oldRoot.parent;</span>
<span class="fc" id="L490">    newRoot.maxEnd = oldRoot.maxEnd;</span>
<span class="fc" id="L491">    newRoot.size = oldRoot.size;</span>
<span class="fc bfc" id="L492" title="All 2 branches covered.">    if (newRoot.parent != null) {</span>
<span class="fc bfc" id="L493" title="All 2 branches covered.">      if (newRoot.parent.left == oldRoot) {</span>
<span class="fc" id="L494">        newRoot.parent.left = newRoot;</span>
<span class="pc bpc" id="L495" title="1 of 2 branches missed.">      } else if (newRoot.parent.right == oldRoot) {</span>
<span class="fc" id="L496">        newRoot.parent.right = newRoot;</span>
      } else {
<span class="nc" id="L498">        throw new IllegalStateException(&quot;Old root not a child of it's parent&quot;);</span>
      }
    }

<span class="fc" id="L502">    oldRoot.parent = newRoot;</span>
<span class="fc bfc" id="L503" title="All 2 branches covered.">    if (oldRightLeft != null) oldRightLeft.parent = oldRoot;</span>
<span class="fc" id="L504">    adjust(oldRoot);</span>
<span class="fc" id="L505">    return newRoot;</span>
  }

<span class="fc" id="L508">  public int height() { return height(root); }</span>

  public int height(TreeNode&lt;E,T&gt; node) {
<span class="pc bpc" id="L511" title="1 of 2 branches missed.">    if (node.value == null) return 0;</span>
<span class="fc bfc" id="L512" title="All 2 branches covered.">    int lh = (node.left != null)? height(node.left):0;</span>
<span class="fc bfc" id="L513" title="All 2 branches covered.">    int rh = (node.right != null)? height(node.right):0;</span>
<span class="fc" id="L514">    return Math.max(lh,rh) + 1;</span>
  }

  public TreeNode&lt;E,T&gt; getLeftmostNode(TreeNode&lt;E,T&gt; node)
  {
<span class="nc" id="L519">    TreeNode&lt;E,T&gt; n = node;</span>
<span class="nc bnc" id="L520" title="All 2 branches missed.">    while (n.left != null) {</span>
<span class="nc" id="L521">      n = n.left;</span>
    }
<span class="nc" id="L523">    return n;</span>
  }

  public TreeNode&lt;E,T&gt; getRightmostNode(TreeNode&lt;E,T&gt; node)
  {
<span class="nc" id="L528">    TreeNode&lt;E,T&gt; n = node;</span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">    while (n.right != null) {</span>
<span class="nc" id="L530">      n = n.right;</span>
    }
<span class="nc" id="L532">    return n;</span>
  }

  // Returns ith node
  public TreeNode&lt;E,T&gt; getNode(TreeNode&lt;E,T&gt; node, int nodeIndex) {
<span class="fc" id="L537">    int i = nodeIndex;</span>
<span class="fc" id="L538">    TreeNode&lt;E,T&gt; n = node;</span>
<span class="pc bpc" id="L539" title="1 of 2 branches missed.">    while (n != null) {</span>
<span class="pc bpc" id="L540" title="2 of 4 branches missed.">      if (i &lt; 0 || i &gt;= n.size) return null;</span>
<span class="fc bfc" id="L541" title="All 2 branches covered.">      int leftSize = (n.left != null)? n.left.size:0;</span>
<span class="fc bfc" id="L542" title="All 2 branches covered.">      if (i == leftSize) {</span>
<span class="fc" id="L543">        return n;</span>
<span class="fc bfc" id="L544" title="All 2 branches covered.">      } else if (i &gt; leftSize) {</span>
        // Look for in right side of tree
<span class="fc" id="L546">        n = n.right;</span>
<span class="fc" id="L547">        i = i - leftSize - 1;</span>
      } else {
<span class="fc" id="L549">        n = n.left;</span>
      }
<span class="fc" id="L551">    }</span>
<span class="nc" id="L552">    return null;</span>
  }

  public boolean addNonOverlapping(T target)
  {
<span class="fc bfc" id="L557" title="All 2 branches covered.">    if (overlaps(target)) return false;</span>
<span class="fc" id="L558">    add(target);</span>
<span class="fc" id="L559">    return true;</span>
  }

  public boolean addNonNested(T target)
  {
<span class="nc bnc" id="L564" title="All 2 branches missed.">    if (containsInterval(target, false)) return false;</span>
<span class="nc" id="L565">    add(target);</span>
<span class="nc" id="L566">    return true;</span>
  }

  public boolean overlaps(T target) {
<span class="fc" id="L570">    return overlaps(root, target.getInterval());</span>
  }

  public List&lt;T&gt; getOverlapping(T target) {
<span class="fc" id="L574">    return getOverlapping(root, target.getInterval());</span>
  }

  public static &lt;E extends Comparable&lt;E&gt;, T extends HasInterval&lt;E&gt;&gt; List&lt;T&gt; getOverlapping(TreeNode&lt;E,T&gt; n, E p)
  {
<span class="nc" id="L579">    List&lt;T&gt; overlapping = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L580">    getOverlapping(n, p, overlapping);</span>
<span class="nc" id="L581">    return overlapping;</span>
  }

  public static &lt;E extends Comparable&lt;E&gt;, T extends HasInterval&lt;E&gt;&gt; List&lt;T&gt; getOverlapping(TreeNode&lt;E,T&gt; n, Interval&lt;E&gt; target)
  {
<span class="fc" id="L586">    List&lt;T&gt; overlapping = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L587">    getOverlapping(n, target, overlapping);</span>
<span class="fc" id="L588">    return overlapping;</span>
  }

  // Search for all intervals which contain p, starting with the
  // node &quot;n&quot; and adding matching intervals to the list &quot;result&quot;
  public static &lt;E extends Comparable&lt;E&gt;, T extends HasInterval&lt;E&gt;&gt; void getOverlapping(TreeNode&lt;E,T&gt; n, E p, List&lt;T&gt; result) {
<span class="nc" id="L594">    getOverlapping(n, Interval.toInterval(p,p), result);</span>
<span class="nc" id="L595">  }</span>

  public static &lt;E extends Comparable&lt;E&gt;, T extends HasInterval&lt;E&gt;&gt; void getOverlapping(TreeNode&lt;E,T&gt; node, Interval&lt;E&gt; target, List&lt;T&gt; result) {
<span class="fc" id="L598">    Queue&lt;TreeNode&lt;E,T&gt;&gt; todo = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L599">    todo.add(node);</span>
<span class="fc bfc" id="L600" title="All 2 branches covered.">    while (!todo.isEmpty()) {</span>
<span class="fc" id="L601">      TreeNode&lt;E,T&gt; n = todo.poll();</span>
      // Don't search nodes that don't exist
<span class="pc bpc" id="L603" title="2 of 4 branches missed.">      if (n == null || n.isEmpty())</span>
<span class="nc" id="L604">        continue;</span>

      // If target is to the right of the rightmost point of any interval
      // in this node and all children, there won't be any matches.
<span class="fc bfc" id="L608" title="All 2 branches covered.">      if (target.first.compareTo(n.maxEnd) &gt; 0)</span>
<span class="fc" id="L609">        continue;</span>

      // Search left children
<span class="fc bfc" id="L612" title="All 2 branches covered.">      if (n.left != null) {</span>
<span class="fc" id="L613">          todo.add(n.left);</span>
      }

      // Check this node
<span class="fc bfc" id="L617" title="All 2 branches covered.">      if (n.value.getInterval().overlaps(target)) {</span>
<span class="fc" id="L618">          result.add(n.value);</span>
      }

      // If target is to the left of the start of this interval,
      // then it can't be in any child to the right.
<span class="fc bfc" id="L623" title="All 2 branches covered.">      if (target.second.compareTo(n.value.getInterval().first()) &lt; 0)  {</span>
<span class="fc" id="L624">        continue;</span>
      }

      // Otherwise, search right children
<span class="fc bfc" id="L628" title="All 2 branches covered.">      if (n.right != null)  {</span>
<span class="fc" id="L629">        todo.add(n.right);</span>
      }
<span class="fc" id="L631">    }</span>
<span class="fc" id="L632">  }</span>

  public static &lt;E extends Comparable&lt;E&gt;, T extends HasInterval&lt;E&gt;&gt; boolean overlaps(TreeNode&lt;E,T&gt; n, E p) {
<span class="nc" id="L635">    return overlaps(n, Interval.toInterval(p,p));</span>
  }
  public static &lt;E extends Comparable&lt;E&gt;, T extends HasInterval&lt;E&gt;&gt; boolean overlaps(TreeNode&lt;E,T&gt; node, Interval&lt;E&gt; target) {
<span class="fc" id="L638">    Stack&lt;TreeNode&lt;E,T&gt;&gt; todo = new Stack&lt;&gt;();</span>
<span class="fc" id="L639">    todo.push(node);</span>

<span class="fc bfc" id="L641" title="All 2 branches covered.">    while (!todo.isEmpty()) {</span>
<span class="fc" id="L642">      TreeNode&lt;E,T&gt; n = todo.pop();</span>
      // Don't search nodes that don't exist
<span class="pc bpc" id="L644" title="1 of 4 branches missed.">      if (n == null || n.isEmpty()) continue;</span>

      // If target is to the right of the rightmost point of any interval
      // in this node and all children, there won't be any matches.
<span class="fc bfc" id="L648" title="All 2 branches covered.">      if (target.first.compareTo(n.maxEnd) &gt; 0)</span>
<span class="fc" id="L649">          continue;</span>

      // Check this node
<span class="fc bfc" id="L652" title="All 2 branches covered.">      if (n.value.getInterval().overlaps(target)) {</span>
<span class="fc" id="L653">          return true;</span>
      }

      // Search left children
<span class="fc bfc" id="L657" title="All 2 branches covered.">      if (n.left != null) {</span>
<span class="fc" id="L658">        todo.add(n.left);</span>
      }

      // If target is to the left of the start of this interval,
      // then it can't be in any child to the right.
<span class="fc bfc" id="L663" title="All 2 branches covered.">      if (target.second.compareTo(n.value.getInterval().first()) &lt; 0)  {</span>
<span class="fc" id="L664">        continue;</span>
      }

<span class="pc bpc" id="L667" title="1 of 2 branches missed.">      if (n.right != null)  {</span>
<span class="fc" id="L668">        todo.add(n.right);</span>
      }
<span class="fc" id="L670">    }</span>
<span class="fc" id="L671">    return false;</span>
  }

  public boolean contains(T target) {
<span class="nc" id="L675">    return containsValue(this, target);</span>
  }

  public boolean containsInterval(T target, boolean exact) {
<span class="nc" id="L679">    return containsInterval(this, target.getInterval(), exact);</span>
  }

  public static &lt;E extends Comparable&lt;E&gt;, T extends HasInterval&lt;E&gt;&gt; boolean containsInterval(IntervalTree&lt;E,T&gt; n, E p, boolean exact) {
<span class="nc" id="L683">    return containsInterval(n, Interval.toInterval(p, p), exact);</span>
  }

  public static &lt;E extends Comparable&lt;E&gt;, T extends HasInterval&lt;E&gt;&gt; boolean containsInterval(IntervalTree&lt;E,T&gt; node, Interval&lt;E&gt; target, boolean exact) {
<span class="nc" id="L687">    Function&lt;T,Boolean&gt; containsTargetFunction = new ContainsIntervalFunction(target, exact);</span>
<span class="nc" id="L688">    return contains(node, target.getInterval(), containsTargetFunction);</span>
  }

  public static &lt;E extends Comparable&lt;E&gt;, T extends HasInterval&lt;E&gt;&gt; boolean containsValue(IntervalTree&lt;E,T&gt; node, T target) {
<span class="nc" id="L692">    Function&lt;T,Boolean&gt; containsTargetFunction = new ContainsValueFunction(target);</span>
<span class="nc" id="L693">    return contains(node, target.getInterval(), containsTargetFunction);</span>
  }

  private static class ContainsValueFunction&lt;E extends Comparable&lt;E&gt;, T extends HasInterval&lt;E&gt;&gt;
      implements Function&lt;T,Boolean&gt; {
    private T target;

<span class="nc" id="L700">    public ContainsValueFunction(T target) {</span>
<span class="nc" id="L701">      this.target = target;</span>
<span class="nc" id="L702">    }</span>

    @Override
    public Boolean apply(T in) {
<span class="nc" id="L706">      return in.equals(target);</span>
    }
  }

  private static class ContainsIntervalFunction&lt;E extends Comparable&lt;E&gt;, T extends HasInterval&lt;E&gt;&gt;
      implements Function&lt;T,Boolean&gt; {
    private Interval&lt;E&gt; target;
    private boolean exact;

<span class="nc" id="L715">    public ContainsIntervalFunction(Interval&lt;E&gt; target, boolean exact) {</span>
<span class="nc" id="L716">      this.target = target;</span>
<span class="nc" id="L717">      this.exact = exact;</span>
<span class="nc" id="L718">    }</span>

    @Override
    public Boolean apply(T in) {
<span class="nc bnc" id="L722" title="All 2 branches missed.">      if (exact) {</span>
<span class="nc" id="L723">        return in.getInterval().equals(target);</span>
      } else {
<span class="nc" id="L725">        return in.getInterval().contains(target);</span>
      }
    }
  }

  private static &lt;E extends Comparable&lt;E&gt;, T extends HasInterval&lt;E&gt;&gt;
    boolean contains(IntervalTree&lt;E,T&gt; tree, Interval&lt;E&gt; target, Function&lt;T,Boolean&gt; containsTargetFunction) {
<span class="nc" id="L732">    return contains(tree.root, target, containsTargetFunction);</span>
  }

  private static &lt;E extends Comparable&lt;E&gt;, T extends HasInterval&lt;E&gt;&gt;
    boolean contains(TreeNode&lt;E,T&gt; node, Interval&lt;E&gt; target, Function&lt;T,Boolean&gt; containsTargetFunction) {
<span class="nc" id="L737">    Stack&lt;TreeNode&lt;E,T&gt;&gt; todo = new Stack&lt;&gt;();</span>
<span class="nc" id="L738">    todo.push(node);</span>

    // Don't search nodes that don't exist
<span class="nc bnc" id="L741" title="All 2 branches missed.">    while (!todo.isEmpty()) {</span>
<span class="nc" id="L742">      TreeNode&lt;E,T&gt; n = todo.pop();</span>
      // Don't search nodes that don't exist
<span class="nc bnc" id="L744" title="All 4 branches missed.">      if (n == null || n.isEmpty()) continue;</span>

      // If target is to the right of the rightmost point of any interval
      // in this node and all children, there won't be any matches.
<span class="nc bnc" id="L748" title="All 2 branches missed.">      if (target.first.compareTo(n.maxEnd) &gt; 0) {</span>
<span class="nc" id="L749">        continue;</span>
      }

      // Check this node
<span class="nc bnc" id="L753" title="All 2 branches missed.">      if (containsTargetFunction.apply(n.value))</span>
<span class="nc" id="L754">        return true;</span>

<span class="nc bnc" id="L756" title="All 2 branches missed.">      if (n.left != null) {</span>
<span class="nc" id="L757">        todo.push(n.left);</span>
      }
      // If target is to the left of the start of this interval, then no need to search right
<span class="nc bnc" id="L760" title="All 2 branches missed.">      if (target.second.compareTo(n.value.getInterval().first()) &lt;= 0)  {</span>
<span class="nc" id="L761">        continue;</span>
      }

      // Need to check right children
<span class="nc bnc" id="L765" title="All 2 branches missed.">      if (n.right != null)  {</span>
<span class="nc" id="L766">        todo.push(n.right);</span>
      }
<span class="nc" id="L768">    }</span>
<span class="nc" id="L769">    return false;</span>
  }

  public static &lt;T, E extends Comparable&lt;E&gt;&gt; List&lt;T&gt; getNonOverlapping(
          List&lt;? extends T&gt; items, Function&lt;? super T,Interval&lt;E&gt;&gt; toIntervalFunc)
  {
<span class="fc" id="L775">    List&lt;T&gt; nonOverlapping = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L776">    IntervalTree&lt;E,Interval&lt;E&gt;&gt; intervals = new IntervalTree&lt;&gt;();</span>
<span class="fc bfc" id="L777" title="All 2 branches covered.">    for (T item:items) {</span>
<span class="fc" id="L778">      Interval&lt;E&gt; i = toIntervalFunc.apply(item);</span>
<span class="fc" id="L779">      boolean addOk = intervals.addNonOverlapping(i);</span>
<span class="fc bfc" id="L780" title="All 2 branches covered.">      if (addOk) {</span>
<span class="fc" id="L781">        nonOverlapping.add(item);</span>
      }
<span class="fc" id="L783">    }</span>
<span class="fc" id="L784">    return nonOverlapping;</span>
  }

  public static &lt;T, E extends Comparable&lt;E&gt;&gt; List&lt;T&gt; getNonOverlapping(
          List&lt;? extends T&gt; items, Function&lt;? super T,Interval&lt;E&gt;&gt; toIntervalFunc, Comparator&lt;? super T&gt; compareFunc)
  {
<span class="fc" id="L790">    List&lt;T&gt; sorted = new ArrayList&lt;&gt;(items);</span>
<span class="fc" id="L791">    Collections.sort(sorted, compareFunc);</span>
<span class="fc" id="L792">    return getNonOverlapping(sorted, toIntervalFunc);</span>
  }

  public static &lt;T extends HasInterval&lt;E&gt;, E extends Comparable&lt;E&gt;&gt; List&lt;T&gt; getNonOverlapping(
          List&lt;? extends T&gt; items, Comparator&lt;? super T&gt; compareFunc)
  {
<span class="fc" id="L798">    Function&lt;T,Interval&lt;E&gt;&gt; toIntervalFunc = in -&gt; in.getInterval();</span>
<span class="fc" id="L799">    return getNonOverlapping(items, toIntervalFunc, compareFunc);</span>
  }

  public static &lt;T extends HasInterval&lt;E&gt;, E extends Comparable&lt;E&gt;&gt; List&lt;T&gt; getNonOverlapping(
          List&lt;? extends T&gt; items)
  {
<span class="nc" id="L805">    Function&lt;T,Interval&lt;E&gt;&gt; toIntervalFunc = in -&gt; in.getInterval();</span>
<span class="nc" id="L806">    return getNonOverlapping(items, toIntervalFunc);</span>
  }

<span class="fc" id="L809">  private static class PartialScoredList&lt;T,E&gt; {</span>
    T object;
    E lastMatchKey;
    int size;
    double score;
  }
  public static &lt;T, E extends Comparable&lt;E&gt;&gt; List&lt;T&gt; getNonOverlappingMaxScore(
      List&lt;? extends T&gt; items, Function&lt;? super T,Interval&lt;E&gt;&gt; toIntervalFunc, Function&lt;? super T, Double&gt; scoreFunc)
  {
<span class="pc bpc" id="L818" title="1 of 2 branches missed.">    if (items.size() &gt; 1) {</span>
<span class="fc" id="L819">      Map&lt;E,PartialScoredList&lt;T,E&gt;&gt; bestNonOverlapping = new TreeMap&lt;&gt;();</span>
<span class="fc bfc" id="L820" title="All 2 branches covered.">      for (T item:items) {</span>
<span class="fc" id="L821">        Interval&lt;E&gt; itemInterval = toIntervalFunc.apply(item);</span>
<span class="fc" id="L822">        E mBegin = itemInterval.getBegin();</span>
<span class="fc" id="L823">        E mEnd = itemInterval.getEnd();</span>
<span class="fc" id="L824">        PartialScoredList&lt;T,E&gt; bestk = bestNonOverlapping.get(mEnd);</span>
<span class="fc" id="L825">        double itemScore = scoreFunc.apply(item);</span>
<span class="pc bpc" id="L826" title="1 of 2 branches missed.">        if (bestk == null) {</span>
<span class="fc" id="L827">          bestk = new PartialScoredList&lt;&gt;();</span>
<span class="fc" id="L828">          bestk.size = 1;</span>
<span class="fc" id="L829">          bestk.score = itemScore;</span>
<span class="fc" id="L830">          bestk.object = item;</span>
<span class="fc" id="L831">          bestNonOverlapping.put(mEnd, bestk);</span>
        }
        // Assumes map is ordered
<span class="pc bpc" id="L834" title="1 of 2 branches missed.">        for (E j:bestNonOverlapping.keySet()) {</span>
<span class="fc bfc" id="L835" title="All 2 branches covered.">          if (j.compareTo(mBegin) &gt; 0) break;</span>
          // Consider adding this match into the bestNonOverlapping strand at j
<span class="fc" id="L837">          PartialScoredList&lt;T,E&gt; bestj = bestNonOverlapping.get(j);</span>
<span class="fc" id="L838">          double withMatchScore = bestj.score + itemScore;</span>
<span class="fc" id="L839">          boolean better = false;</span>
<span class="pc bpc" id="L840" title="1 of 2 branches missed.">          if (withMatchScore &gt; bestk.score) {</span>
<span class="fc" id="L841">            better = true;</span>
<span class="nc bnc" id="L842" title="All 2 branches missed.">          } else if (withMatchScore == bestk.score) {</span>
<span class="nc bnc" id="L843" title="All 2 branches missed.">            if (bestj.size + 1 &lt; bestk.size) {</span>
<span class="nc" id="L844">              better = true;</span>
            }
          }
<span class="pc bpc" id="L847" title="1 of 2 branches missed.">          if (better) {</span>
<span class="fc" id="L848">            bestk.size = bestj.size + 1;</span>
<span class="fc" id="L849">            bestk.score = withMatchScore;</span>
<span class="fc" id="L850">            bestk.object = item;</span>
<span class="fc" id="L851">            bestk.lastMatchKey = j;</span>
          }
<span class="fc" id="L853">        }</span>
<span class="fc" id="L854">      }</span>

<span class="fc" id="L856">      PartialScoredList&lt;T,E&gt; best = null;</span>
<span class="fc bfc" id="L857" title="All 2 branches covered.">      for (PartialScoredList&lt;T,E&gt; v: bestNonOverlapping.values()) {</span>
<span class="pc bpc" id="L858" title="1 of 4 branches missed.">        if (best == null || v.score &gt; best.score) {</span>
<span class="fc" id="L859">          best = v;</span>
        }
<span class="fc" id="L861">      }</span>
<span class="fc" id="L862">      List&lt;T&gt; nonOverlapping = new ArrayList&lt;&gt;(best.size);</span>
<span class="fc" id="L863">      PartialScoredList&lt;T,E&gt; prev = best;</span>
<span class="fc bfc" id="L864" title="All 2 branches covered.">      while (prev != null) {</span>
<span class="pc bpc" id="L865" title="1 of 2 branches missed.">        if (prev.object != null) {</span>
<span class="fc" id="L866">          nonOverlapping.add(prev.object);</span>
        }
<span class="fc bfc" id="L868" title="All 2 branches covered.">        if (prev.lastMatchKey != null) {</span>
<span class="fc" id="L869">          prev = bestNonOverlapping.get(prev.lastMatchKey);</span>
        } else {
<span class="fc" id="L871">          prev = null;</span>
        }
      }
<span class="fc" id="L874">      Collections.reverse(nonOverlapping);</span>
<span class="fc" id="L875">      return nonOverlapping;</span>
    } else {
<span class="nc" id="L877">      List&lt;T&gt; nonOverlapping = new ArrayList&lt;&gt;(items);</span>
<span class="nc" id="L878">      return nonOverlapping;</span>
    }
  }
  public static &lt;T extends HasInterval&lt;E&gt;, E extends Comparable&lt;E&gt;&gt; List&lt;T&gt; getNonOverlappingMaxScore(
      List&lt;? extends T&gt; items, Function&lt;? super T, Double&gt; scoreFunc)
  {
<span class="fc" id="L884">    Function&lt;T,Interval&lt;E&gt;&gt; toIntervalFunc = in -&gt; in.getInterval();</span>
<span class="fc" id="L885">    return getNonOverlappingMaxScore(items, toIntervalFunc, scoreFunc);</span>
  }

  public static &lt;T, E extends Comparable&lt;E&gt;&gt; List&lt;T&gt; getNonNested(
          List&lt;? extends T&gt; items, Function&lt;? super T,Interval&lt;E&gt;&gt; toIntervalFunc, Comparator&lt;? super T&gt; compareFunc)
  {
<span class="nc" id="L891">    List&lt;T&gt; sorted = new ArrayList&lt;&gt;(items);</span>
<span class="nc" id="L892">    Collections.sort(sorted, compareFunc);</span>
<span class="nc" id="L893">    List&lt;T&gt; res = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L894">    IntervalTree&lt;E,Interval&lt;E&gt;&gt; intervals = new IntervalTree&lt;&gt;();</span>
<span class="nc bnc" id="L895" title="All 2 branches missed.">    for (T item:sorted) {</span>
<span class="nc" id="L896">      Interval&lt;E&gt; i = toIntervalFunc.apply(item);</span>
<span class="nc" id="L897">      boolean addOk = intervals.addNonNested(i);</span>
<span class="nc bnc" id="L898" title="All 2 branches missed.">      if (addOk) {</span>
<span class="nc" id="L899">        res.add(item);</span>
      } else {
        //        log.info(&quot;Discarding &quot; + item);
      }
<span class="nc" id="L903">    }</span>
<span class="nc" id="L904">    return res;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>