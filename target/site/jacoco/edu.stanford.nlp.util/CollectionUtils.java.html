<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CollectionUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.util</a> &gt; <span class="el_source">CollectionUtils.java</span></div><h1>CollectionUtils.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.util; 
import edu.stanford.nlp.util.logging.Redwood;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.*;
import java.util.function.Function;
import java.util.function.Predicate;

import edu.stanford.nlp.stats.ClassicCounter;
import edu.stanford.nlp.stats.Counter;
import edu.stanford.nlp.stats.Counters;

/**
 * Collection of useful static methods for working with Collections. Includes
 * methods to increment counts in maps and cast list/map elements to common
 * types.
 *
 * @author Joseph Smarr (jsmarr@stanford.edu)
 */
<span class="pc bpc" id="L25" title="1 of 2 branches missed.">public class CollectionUtils  {</span>

  /** A logger for this class */
<span class="fc" id="L28">  private static Redwood.RedwoodChannels log = Redwood.channels(CollectionUtils.class);</span>

  /**
   * Private constructor to prevent direct instantiation.
   */
<span class="nc" id="L33">  private CollectionUtils() {</span>
<span class="nc" id="L34">  }</span>

  // Utils for making collections out of arrays of primitive types.

  public static List&lt;Integer&gt; asList(int[] a) {
<span class="nc" id="L39">    List&lt;Integer&gt; result = new ArrayList&lt;&gt;(a.length);</span>
<span class="nc bnc" id="L40" title="All 2 branches missed.">    for (int j : a) {</span>
<span class="nc" id="L41">      result.add(Integer.valueOf(j));</span>
    }
<span class="nc" id="L43">    return result;</span>
  }

  public static List&lt;Double&gt; asList(double[] a) {
<span class="nc" id="L47">    List&lt;Double&gt; result = new ArrayList&lt;&gt;(a.length);</span>
<span class="nc bnc" id="L48" title="All 2 branches missed.">    for (double v : a) {</span>
<span class="nc" id="L49">      result.add(new Double(v));</span>
    }
<span class="nc" id="L51">    return result;</span>
  }

  // Inverses of the above

  public static int[] asIntArray(Collection&lt;Integer&gt; coll) {
<span class="nc" id="L57">    int[] result = new int[coll.size()];</span>
<span class="nc" id="L58">    int index = 0;</span>
<span class="nc bnc" id="L59" title="All 2 branches missed.">    for (Integer element : coll) {</span>
<span class="nc" id="L60">      result[index] = element;</span>
<span class="nc" id="L61">      index++;</span>
<span class="nc" id="L62">    }</span>

<span class="nc" id="L64">    return result;</span>
  }

  public static double[] asDoubleArray(Collection&lt;Double&gt; coll) {
<span class="nc" id="L68">    double[] result = new double[coll.size()];</span>
<span class="nc" id="L69">    int index = 0;</span>
<span class="nc bnc" id="L70" title="All 2 branches missed.">    for (Double element : coll) {</span>
<span class="nc" id="L71">      result[index] = element;</span>
<span class="nc" id="L72">      index++;</span>
<span class="nc" id="L73">    }</span>

<span class="nc" id="L75">    return result;</span>
  }

  /** Returns a new List containing the given objects. */
  @SafeVarargs
  public static &lt;T&gt; List&lt;T&gt; makeList(T... items) {
<span class="nc" id="L81">    return new ArrayList&lt;&gt;(Arrays.asList(items));</span>
  }

  /** Returns a new Set containing all the objects in the specified array. */
  @SafeVarargs
  public static &lt;T&gt; Set&lt;T&gt; asSet(T... o) {
<span class="fc" id="L87">    return Generics.newHashSet(Arrays.asList(o));</span>
  }

  public static &lt;T&gt; Set&lt;T&gt; intersection(Set&lt;T&gt; set1, Set&lt;T&gt; set2) {
<span class="fc" id="L91">    Set&lt;T&gt; intersect = Generics.newHashSet();</span>
<span class="fc bfc" id="L92" title="All 2 branches covered.">    for (T t : set1) {</span>
<span class="fc bfc" id="L93" title="All 2 branches covered.">      if (set2.contains(t)) {</span>
<span class="fc" id="L94">        intersect.add(t);</span>
      }
<span class="fc" id="L96">    }</span>
<span class="fc" id="L97">    return intersect;</span>
  }

  public static &lt;T&gt; Collection&lt;T&gt; union(Collection&lt;T&gt; set1, Collection&lt;T&gt; set2) {
<span class="nc" id="L101">    Collection&lt;T&gt; union = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">    for (T t : set1) {</span>
<span class="nc" id="L103">      union.add(t);</span>
<span class="nc" id="L104">    }</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">    for (T t : set2) {</span>
<span class="nc" id="L106">      union.add(t);</span>
<span class="nc" id="L107">    }</span>
<span class="nc" id="L108">    return union;</span>
  }

  public static &lt;T&gt; Set&lt;T&gt; unionAsSet(Collection&lt;T&gt; set1, Collection&lt;T&gt; set2) {
<span class="nc" id="L112">    Set&lt;T&gt; union = Generics.newHashSet();</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">    for (T t : set1) {</span>
<span class="nc" id="L114">      union.add(t);</span>
<span class="nc" id="L115">    }</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">    for (T t : set2) {</span>
<span class="nc" id="L117">      union.add(t);</span>
<span class="nc" id="L118">    }</span>
<span class="nc" id="L119">    return union;</span>
  }

  @SafeVarargs
  public static &lt;T&gt; Set&lt;T&gt; unionAsSet(Collection&lt;T&gt;... sets) {
<span class="nc" id="L124">    Set&lt;T&gt; union = Generics.newHashSet();</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">    for(Collection&lt;T&gt; set: sets){</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">      for (T t : set) {</span>
<span class="nc" id="L127">        union.add(t);</span>
<span class="nc" id="L128">      }</span>
    }
<span class="nc" id="L130">    return union;</span>
  }

  /**
   * Returns all objects in list1 that are not in list2.
   *
   * @param &lt;T&gt; Type of items in the collection
   * @param list1 First collection
   * @param list2 Second collection
   * @return The collection difference list1 - list2
   */
  public static &lt;T&gt; Collection&lt;T&gt; diff(Collection&lt;T&gt; list1, Collection&lt;T&gt; list2) {
<span class="fc" id="L142">    Collection&lt;T&gt; diff = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">    for (T t : list1) {</span>
<span class="pc bpc" id="L144" title="1 of 2 branches missed.">      if (!list2.contains(t)) {</span>
<span class="nc" id="L145">        diff.add(t);</span>
      }
<span class="fc" id="L147">    }</span>
<span class="fc" id="L148">    return diff;</span>
  }

  /**
   * Returns all objects in list1 that are not in list2.
   *
   * @param &lt;T&gt; Type of items in the collection
   * @param list1 First collection
   * @param list2 Second collection
   * @return The collection difference list1 - list2
   */
  public static &lt;T&gt; Set&lt;T&gt; diffAsSet(Collection&lt;T&gt; list1, Collection&lt;T&gt; list2) {
<span class="nc" id="L160">    Set&lt;T&gt; diff = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">    for (T t : list1) {</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">      if (!list2.contains(t)) {</span>
<span class="nc" id="L163">        diff.add(t);</span>
      }
<span class="nc" id="L165">    }</span>
<span class="nc" id="L166">    return diff;</span>
  }

  // Utils for loading and saving Collections to/from text files

  /**
   * @param filename The path to the file to load the List from
   * @param c The Class to instantiate each member of the List. Must have a
   *          String constructor.
   */
  public static &lt;T&gt; Collection&lt;T&gt; loadCollection(String filename, Class&lt;T&gt; c, CollectionFactory&lt;T&gt; cf) throws Exception {
<span class="nc" id="L177">    return loadCollection(new File(filename), c, cf);</span>
  }

  /**
   * @param file The file to load the List from
   * @param c The Class to instantiate each member of the List. Must have a
   *          String constructor.
   */
  public static &lt;T&gt; Collection&lt;T&gt; loadCollection(File file, Class&lt;T&gt; c, CollectionFactory&lt;T&gt; cf) throws Exception {
<span class="nc" id="L186">    Constructor&lt;T&gt; m = c.getConstructor(new Class[] { String.class });</span>
<span class="nc" id="L187">    Collection&lt;T&gt; result = cf.newCollection();</span>
<span class="nc" id="L188">    BufferedReader in = new BufferedReader(new FileReader(file));</span>
<span class="nc" id="L189">    String line = in.readLine();</span>
<span class="nc bnc" id="L190" title="All 4 branches missed.">    while (line != null &amp;&amp; line.length() &gt; 0) {</span>
      try {
<span class="nc" id="L192">        T o = m.newInstance(line);</span>
<span class="nc" id="L193">        result.add(o);</span>
<span class="nc" id="L194">      } catch (Exception e) {</span>
<span class="nc" id="L195">        log.info(&quot;Couldn't build object from line: &quot; + line);</span>
<span class="nc" id="L196">        e.printStackTrace();</span>
<span class="nc" id="L197">      }</span>
<span class="nc" id="L198">      line = in.readLine();</span>
    }
<span class="nc" id="L200">    in.close();</span>
<span class="nc" id="L201">    return result;</span>
  }

  /**
   * Adds the items from the file to the collection.
   *
   * @param &lt;T&gt; The type of the items.
   * @param fileName The name of the file from which items should be loaded.
   * @param itemClass The class of the items (must have a constructor that accepts a String).
   * @param collection The collection to which items should be added.
   */
  public static &lt;T&gt; void loadCollection(String fileName, Class&lt;T&gt; itemClass, Collection&lt;T&gt; collection) throws NoSuchMethodException, InstantiationException,
      IllegalAccessException, InvocationTargetException, IOException {
<span class="fc" id="L214">    loadCollection(new File(fileName), itemClass, collection);</span>
<span class="fc" id="L215">  }</span>

  /**
   * Adds the items from the file to the collection.
   *
   * @param &lt;T&gt; The type of the items.
   * @param file The file from which items should be loaded.
   * @param itemClass The class of the items (must have a constructor that accepts a String).
   * @param collection The collection to which items should be added.
   */
  public static &lt;T&gt; void loadCollection(File file, Class&lt;T&gt; itemClass, Collection&lt;T&gt; collection) throws NoSuchMethodException, InstantiationException, IllegalAccessException,
      InvocationTargetException, IOException {
<span class="fc" id="L227">    Constructor&lt;T&gt; itemConstructor = itemClass.getConstructor(String.class);</span>
<span class="fc" id="L228">    BufferedReader in = new BufferedReader(new FileReader(file));</span>
<span class="fc" id="L229">    String line = in.readLine();</span>
<span class="pc bpc" id="L230" title="1 of 4 branches missed.">    while (line != null &amp;&amp; line.length() &gt; 0) {</span>
<span class="fc" id="L231">      T t = itemConstructor.newInstance(line);</span>
<span class="fc" id="L232">      collection.add(t);</span>
<span class="fc" id="L233">      line = in.readLine();</span>
<span class="fc" id="L234">    }</span>
<span class="fc" id="L235">    in.close();</span>
<span class="fc" id="L236">  }</span>

  public static &lt;K, V&gt; Map&lt;K, V&gt; getMapFromString(String s, Class&lt;K&gt; keyClass, Class&lt;V&gt; valueClass, MapFactory&lt;K, V&gt; mapFactory) throws ClassNotFoundException,
      NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
<span class="nc" id="L240">    Constructor&lt;K&gt; keyC = keyClass.getConstructor(new Class[] { String.class });</span>
<span class="nc" id="L241">    Constructor&lt;V&gt; valueC = valueClass.getConstructor(new Class[] { String.class });</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">    if (s.charAt(0) != '{')</span>
<span class="nc" id="L243">      throw new RuntimeException(&quot;&quot;);</span>
<span class="nc" id="L244">    s = s.substring(1); // get rid of first brace</span>
<span class="nc" id="L245">    String[] fields = s.split(&quot;\\s+&quot;);</span>
<span class="nc" id="L246">    Map&lt;K, V&gt; m = mapFactory.newMap();</span>
    // populate m
<span class="nc bnc" id="L248" title="All 2 branches missed.">    for (int i = 0; i &lt; fields.length; i++) {</span>
      // log.info(&quot;Parsing &quot; + fields[i]);
<span class="nc" id="L250">      fields[i] = fields[i].substring(0, fields[i].length() - 1); // get rid of</span>
      // following
      // comma or
      // brace
<span class="nc" id="L254">      String[] a = fields[i].split(&quot;=&quot;);</span>
<span class="nc" id="L255">      K key = keyC.newInstance(a[0]);</span>
      V value;
<span class="nc bnc" id="L257" title="All 2 branches missed.">      if (a.length &gt; 1) {</span>
<span class="nc" id="L258">        value = valueC.newInstance(a[1]);</span>
      } else {
<span class="nc" id="L260">        value = valueC.newInstance(&quot;&quot;);</span>
      }
<span class="nc" id="L262">      m.put(key, value);</span>
    }
<span class="nc" id="L264">    return m;</span>
  }

  /**
   * Checks whether a Collection contains a specified Object. Object equality
   * (==), rather than .equals(), is used.
   */
  public static &lt;T&gt; boolean containsObject(Collection&lt;T&gt; c, T o) {
<span class="nc bnc" id="L272" title="All 2 branches missed.">    for (Object o1 : c) {</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">      if (o == o1) {</span>
<span class="nc" id="L274">        return true;</span>
      }
<span class="nc" id="L276">    }</span>
<span class="nc" id="L277">    return false;</span>
  }

  /**
   * Removes the first occurrence in the list of the specified object, using
   * object identity (==) not equality as the criterion for object presence. If
   * this list does not contain the element, it is unchanged.
   *
   * @param l The {@link List} from which to remove the object
   * @param o The object to be removed.
   * @return Whether or not the List was changed.
   */
  public static &lt;T&gt; boolean removeObject(List&lt;T&gt; l, T o) {
<span class="nc" id="L290">    int i = 0;</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">    for (Object o1 : l) {</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">      if (o == o1) {</span>
<span class="nc" id="L293">        l.remove(i);</span>
<span class="nc" id="L294">        return true;</span>
      } else
<span class="nc" id="L296">        i++;</span>
<span class="nc" id="L297">    }</span>
<span class="nc" id="L298">    return false;</span>
  }

  /**
   * Returns the index of the first occurrence in the list of the specified
   * object, using object identity (==) not equality as the criterion for object
   * presence. If this list does not contain the element, return -1.
   *
   * @param l The {@link List} to find the object in.
   * @param o The sought-after object.
   * @return Whether or not the List was changed.
   */
  public static &lt;T&gt; int getIndex(List&lt;T&gt; l, T o) {
<span class="nc" id="L311">    int i = 0;</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">    for (Object o1 : l) {</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">      if (o == o1)</span>
<span class="nc" id="L314">        return i;</span>
      else
<span class="nc" id="L316">        i++;</span>
<span class="nc" id="L317">    }</span>
<span class="nc" id="L318">    return -1;</span>
  }

  /**
   * Returns the index of the first occurrence after the startIndex (exclusive)
   * in the list of the specified object, using object equals function. If this
   * list does not contain the element, return -1.
   *
   * @param l The {@link List} to find the object in.
   * @param o The sought-after object.
   * @param fromIndex The start index
   * @return Whether or not the List was changed.
   */
  public static &lt;T&gt; int getIndex(List&lt;T&gt; l, T o, int fromIndex) {
<span class="fc" id="L332">    int i = -1;</span>
<span class="pc bpc" id="L333" title="1 of 2 branches missed.">    for (T o1 : l) {</span>
<span class="fc" id="L334">      i++;</span>
<span class="fc bfc" id="L335" title="All 2 branches covered.">      if (i &lt; fromIndex) {</span>
<span class="fc" id="L336">        continue;</span>
      }
<span class="fc bfc" id="L338" title="All 2 branches covered.">      if (o.equals(o1)) {</span>
<span class="fc" id="L339">        return i;</span>
      }
<span class="fc" id="L341">    }</span>
<span class="nc" id="L342">    return -1;</span>
  }

  /**
   * Samples without replacement from a collection.
   *
   * @param c The collection to be sampled from
   * @param n The number of samples to take
   * @return a new collection with the sample
   */
  public static &lt;E&gt; Collection&lt;E&gt; sampleWithoutReplacement(Collection&lt;E&gt; c, int n) {
<span class="nc" id="L353">    return sampleWithoutReplacement(c, n, new Random());</span>
  }

  /**
   * Samples without replacement from a collection, using your own
   * {@link Random} number generator.
   *
   * @param c The collection to be sampled from
   * @param n The number of samples to take
   * @param r The random number generator
   * @return a new collection with the sample
   */
  public static &lt;E&gt; Collection&lt;E&gt; sampleWithoutReplacement(Collection&lt;E&gt; c, int n, Random r) {
<span class="nc bnc" id="L366" title="All 2 branches missed.">    if (n &lt; 0)</span>
<span class="nc" id="L367">      throw new IllegalArgumentException(&quot;n &lt; 0: &quot; + n);</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">    if (n &gt; c.size())</span>
<span class="nc" id="L369">      throw new IllegalArgumentException(&quot;n &gt; size of collection: &quot; + n + &quot;, &quot; + c.size());</span>
<span class="nc" id="L370">    List&lt;E&gt; copy = new ArrayList&lt;&gt;(c.size());</span>
<span class="nc" id="L371">    copy.addAll(c);</span>
<span class="nc" id="L372">    Collection&lt;E&gt; result = new ArrayList&lt;&gt;(n);</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">    for (int k = 0; k &lt; n; k++) {</span>
<span class="nc" id="L374">      double d = r.nextDouble();</span>
<span class="nc" id="L375">      int x = (int) (d * copy.size());</span>
<span class="nc" id="L376">      result.add(copy.remove(x));</span>
    }
<span class="nc" id="L378">    return result;</span>
  }

  public static &lt;E&gt; E sample(List&lt;E&gt; l, Random r) {
<span class="nc" id="L382">    int i = r.nextInt(l.size());</span>
<span class="nc" id="L383">    return l.get(i);</span>
  }

  /**
   * Samples with replacement from a collection.
   *
   * @param c The collection to be sampled from
   * @param n The number of samples to take
   * @return a new collection with the sample
   */
  public static &lt;E&gt; Collection&lt;E&gt; sampleWithReplacement(Collection&lt;E&gt; c, int n) {
<span class="nc" id="L394">    return sampleWithReplacement(c, n, new Random());</span>
  }

  /**
   * Samples with replacement from a collection, using your own {@link Random}
   * number generator.
   *
   * @param c The collection to be sampled from
   * @param n The number of samples to take
   * @param r The random number generator
   * @return a new collection with the sample
   */
  public static &lt;E&gt; Collection&lt;E&gt; sampleWithReplacement(Collection&lt;E&gt; c, int n, Random r) {
<span class="nc bnc" id="L407" title="All 2 branches missed.">    if (n &lt; 0)</span>
<span class="nc" id="L408">      throw new IllegalArgumentException(&quot;n &lt; 0: &quot; + n);</span>
<span class="nc" id="L409">    List&lt;E&gt; copy = new ArrayList&lt;&gt;(c.size());</span>
<span class="nc" id="L410">    copy.addAll(c);</span>
<span class="nc" id="L411">    Collection&lt;E&gt; result = new ArrayList&lt;&gt;(n);</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">    for (int k = 0; k &lt; n; k++) {</span>
<span class="nc" id="L413">      double d = r.nextDouble();</span>
<span class="nc" id="L414">      int x = (int) (d * copy.size());</span>
<span class="nc" id="L415">      result.add(copy.get(x));</span>
    }
<span class="nc" id="L417">    return result;</span>
  }

  /**
   * Returns true iff l1 is a sublist of l (i.e., every member of l1 is in l,
   * and for every e1 &amp;lt; e2 in l1, there is an e1 &amp;lt; e2 occurrence in l).
   */
  public static &lt;T&gt; boolean isSubList(List&lt;T&gt; l1, List&lt;? super T&gt; l) {
<span class="fc" id="L425">    Iterator&lt;? super T&gt; it = l.iterator();</span>
<span class="fc bfc" id="L426" title="All 2 branches covered.">    for (T o1 : l1) {</span>
<span class="fc bfc" id="L427" title="All 2 branches covered.">      if (!it.hasNext()) {</span>
<span class="fc" id="L428">        return false;</span>
      }
<span class="fc" id="L430">      Object o = it.next();</span>
<span class="pc bpc" id="L431" title="4 of 8 branches missed.">      while ((o == null &amp;&amp; !(o1 == null)) || (o != null &amp;&amp; !o.equals(o1))) {</span>
<span class="pc bpc" id="L432" title="1 of 2 branches missed.">        if (!it.hasNext()) {</span>
<span class="nc" id="L433">          return false;</span>
        }
<span class="fc" id="L435">        o = it.next();</span>
      }
<span class="fc" id="L437">    }</span>
<span class="fc" id="L438">    return true;</span>
  }

  public static &lt;K, V&gt; String toVerticalString(Map&lt;K, V&gt; m) {
<span class="nc" id="L442">    StringBuilder b = new StringBuilder();</span>
<span class="nc" id="L443">    Set&lt;Map.Entry&lt;K, V&gt;&gt; entries = m.entrySet();</span>
<span class="nc bnc" id="L444" title="All 2 branches missed.">    for (Map.Entry&lt;K, V&gt; e : entries) {</span>
<span class="nc" id="L445">      b.append(e.getKey()).append('=').append(e.getValue()).append('\n');</span>
<span class="nc" id="L446">    }</span>
<span class="nc" id="L447">    return b.toString();</span>
  }

  /**
   * Provides a consistent ordering over lists. First compares by the first
   * element. If that element is equal, the next element is considered, and so
   * on.
   */
  public static &lt;T extends Comparable&lt;T&gt;&gt; int compareLists(List&lt;T&gt; list1, List&lt;T&gt; list2) {
<span class="pc bpc" id="L456" title="3 of 4 branches missed.">    if (list1 == null &amp;&amp; list2 == null)</span>
<span class="nc" id="L457">      return 0;</span>
<span class="pc bpc" id="L458" title="2 of 4 branches missed.">    if (list1 == null || list2 == null) {</span>
<span class="nc" id="L459">      throw new IllegalArgumentException();</span>
    }
<span class="fc" id="L461">    int size1 = list1.size();</span>
<span class="fc" id="L462">    int size2 = list2.size();</span>
<span class="fc" id="L463">    int size = Math.min(size1, size2);</span>
<span class="fc bfc" id="L464" title="All 2 branches covered.">    for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L465">      int c = list1.get(i).compareTo(list2.get(i));</span>
<span class="fc bfc" id="L466" title="All 2 branches covered.">      if (c != 0)</span>
<span class="fc" id="L467">        return c;</span>
    }
<span class="fc bfc" id="L469" title="All 2 branches covered.">    if (size1 &lt; size2)</span>
<span class="fc" id="L470">      return -1;</span>
<span class="fc bfc" id="L471" title="All 2 branches covered.">    if (size1 &gt; size2)</span>
<span class="fc" id="L472">      return 1;</span>
<span class="fc" id="L473">    return 0;</span>
  }

  public static &lt;C extends Comparable&lt;C&gt;&gt; Comparator&lt;List&lt;C&gt;&gt; getListComparator() {
<span class="nc" id="L477">    return CollectionUtils::compareLists;</span>
  }

  /**
   * Return the items of an Iterable as a sorted list.
   *
   * @param &lt;T&gt; The type of items in the Iterable.
   * @param items The collection to be sorted.
   * @return A list containing the same items as the Iterable, but sorted.
   */
  public static &lt;T extends Comparable&lt;T&gt;&gt; List&lt;T&gt; sorted(Iterable&lt;T&gt; items) {
<span class="fc" id="L488">    List&lt;T&gt; result = toList(items);</span>
<span class="fc" id="L489">    Collections.sort(result);</span>
<span class="fc" id="L490">    return result;</span>
  }

  /**
   * Return the items of an Iterable as a sorted list.
   *
   * @param &lt;T&gt; The type of items in the Iterable.
   * @param items The collection to be sorted.
   * @return A list containing the same items as the Iterable, but sorted.
   */
  public static &lt;T&gt; List&lt;T&gt; sorted(Iterable&lt;T&gt; items, Comparator&lt;T&gt; comparator) {
<span class="fc" id="L501">    List&lt;T&gt; result = toList(items);</span>
<span class="fc" id="L502">    Collections.sort(result, comparator);</span>
<span class="fc" id="L503">    return result;</span>
  }

  /**
   * Create a list out of the items in the Iterable.
   *
   * @param &lt;T&gt; The type of items in the Iterable.
   * @param items The items to be made into a list.
   * @return A list consisting of the items of the Iterable, in the same order.
   */
  public static &lt;T&gt; List&lt;T&gt; toList(Iterable&lt;T&gt; items) {
<span class="fc" id="L514">    List&lt;T&gt; list = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L515">    addAll(list, items);</span>
<span class="fc" id="L516">    return list;</span>
  }

  /**
   * Create a set out of the items in the Iterable.
   *
   * @param &lt;T&gt; The type of items in the Iterable.
   * @param items The items to be made into a set.
   * @return A set consisting of the items from the Iterable.
   */
  public static &lt;T&gt; Set&lt;T&gt; toSet(Iterable&lt;T&gt; items) {
<span class="fc" id="L527">    Set&lt;T&gt; set = Generics.newHashSet();</span>
<span class="fc" id="L528">    addAll(set, items);</span>
<span class="fc" id="L529">    return set;</span>
  }

  /**
   * Add all the items from an iterable to a collection.
   *
   * @param &lt;T&gt; The type of items in the iterable and the collection
   * @param collection The collection to which the items should be added.
   * @param items The items to add to the collection.
   */
  public static &lt;T&gt; void addAll(Collection&lt;T&gt; collection, Iterable&lt;? extends T&gt; items) {
<span class="fc bfc" id="L540" title="All 2 branches covered.">    for (T item : items) {</span>
<span class="fc" id="L541">      collection.add(item);</span>
<span class="fc" id="L542">    }</span>
<span class="fc" id="L543">  }</span>

  /**
   * Get all sub-lists of the given list of the given sizes.
   *
   * For example:
   *
   * &lt;pre&gt;
   * List&amp;lt;String&amp;gt; items = Arrays.asList(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;d&amp;quot;);
   * System.out.println(CollectionUtils.getNGrams(items, 1, 2));
   * &lt;/pre&gt;
   *
   * would print out:
   *
   * &lt;pre&gt;
   * [[a], [a, b], [b], [b, c], [c], [c, d], [d]]
   * &lt;/pre&gt;
   *
   * @param &lt;T&gt; The type of items contained in the list.
   * @param items The list of items.
   * @param minSize The minimum size of an ngram.
   * @param maxSize The maximum size of an ngram.
   * @return All sub-lists of the given sizes.
   */
  public static &lt;T&gt; List&lt;List&lt;T&gt;&gt; getNGrams(List&lt;T&gt; items, int minSize, int maxSize) {
<span class="fc" id="L568">    List&lt;List&lt;T&gt;&gt; ngrams = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L569">    int listSize = items.size();</span>
<span class="fc bfc" id="L570" title="All 2 branches covered.">    for (int i = 0; i &lt; listSize; ++i) {</span>
<span class="fc bfc" id="L571" title="All 2 branches covered.">      for (int ngramSize = minSize; ngramSize &lt;= maxSize; ++ngramSize) {</span>
<span class="fc bfc" id="L572" title="All 2 branches covered.">        if (i + ngramSize &lt;= listSize) {</span>
<span class="fc" id="L573">          List&lt;T&gt; ngram = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L574" title="All 2 branches covered.">          for (int j = i; j &lt; i + ngramSize; ++j) {</span>
<span class="fc" id="L575">            ngram.add(items.get(j));</span>
          }
<span class="fc" id="L577">          ngrams.add(ngram);</span>
        }
      }
    }
<span class="fc" id="L581">    return ngrams;</span>
  }

  /**
   * Get all prefix/suffix combinations from a list. It can extract just
   * prefixes, just suffixes, or prefixes and suffixes of the same length.
   *
   * For example:
   *
   * &lt;pre&gt;
   * List&amp;lt;String&amp;gt; items = Arrays.asList(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;d&amp;quot;);
   * System.out.println(CollectionUtils.getPrefixesAndSuffixes(items, 1, 2, null, true, true));
   * &lt;/pre&gt;
   *
   * would print out:
   *
   * &lt;pre&gt;
   * [[d], [a], [a, d], [d, c], [a, b], [a, b, c, d]]
   * &lt;/pre&gt;
   *
   * and
   *
   * &lt;pre&gt;
   * List&amp;lt;String&amp;gt; items2 = Arrays.asList(&amp;quot;a&amp;quot;);
   * System.out.println(CollectionUtils.getPrefixesAndSuffixes(items2, 1, 2, null, true, true));
   * &lt;/pre&gt;
   *
   * would print:
   *
   * &lt;pre&gt;
   * [[a], [a], [a, a], [a, null], [a, null], [a, null, a, null]]
   * &lt;/pre&gt;
   *
   * @param &lt;T&gt; The type of items contained in the list.
   * @param items The list of items.
   * @param minSize The minimum length of a prefix/suffix span (should be at least 1)
   * @param maxSize The maximum length of a prefix/suffix span
   * @param paddingSymbol Symbol to be included if we run out of bounds (e.g. if items has
   *          size 3 and we try to extract a span of length 4).
   * @param includePrefixes Whether to extract prefixes
   * @param includeSuffixes Whether to extract suffixes
   * @return All prefix/suffix combinations of the given sizes.
   */
  public static &lt;T&gt; List&lt;List&lt;T&gt;&gt; getPrefixesAndSuffixes(List&lt;T&gt; items, int minSize, int maxSize, T paddingSymbol, boolean includePrefixes, boolean includeSuffixes) {
<span class="nc bnc" id="L625" title="All 4 branches missed.">    assert minSize &gt; 0;</span>
<span class="nc bnc" id="L626" title="All 4 branches missed.">    assert maxSize &gt;= minSize;</span>
<span class="nc bnc" id="L627" title="All 6 branches missed.">    assert includePrefixes || includeSuffixes;</span>

<span class="nc" id="L629">    List&lt;List&lt;T&gt;&gt; prefixesAndSuffixes = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L630" title="All 2 branches missed.">    for (int span = minSize - 1; span &lt; maxSize; span++) {</span>
<span class="nc" id="L631">      List&lt;Integer&gt; indices = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L632">      List&lt;T&gt; seq = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L633" title="All 2 branches missed.">      if (includePrefixes) {</span>
<span class="nc bnc" id="L634" title="All 2 branches missed.">        for (int i = 0; i &lt;= span; i++) {</span>
<span class="nc" id="L635">          indices.add(i);</span>
        }
      }
<span class="nc bnc" id="L638" title="All 2 branches missed.">      if (includeSuffixes) {</span>
<span class="nc" id="L639">        int maxIndex = items.size() - 1;</span>
<span class="nc bnc" id="L640" title="All 2 branches missed.">        for (int i = span; i &gt;= 0; i--) {</span>
<span class="nc" id="L641">          indices.add(maxIndex - i);</span>
        }
      }

<span class="nc bnc" id="L645" title="All 2 branches missed.">      for (int i : indices) {</span>
        try {
<span class="nc" id="L647">          seq.add(items.get(i));</span>
<span class="nc" id="L648">        } catch (IndexOutOfBoundsException ioobe) {</span>
<span class="nc" id="L649">          seq.add(paddingSymbol);</span>
<span class="nc" id="L650">        }</span>
<span class="nc" id="L651">      }</span>

<span class="nc" id="L653">      prefixesAndSuffixes.add(seq);</span>
    }

<span class="nc" id="L656">    return prefixesAndSuffixes;</span>
  }

  public static &lt;T, M&gt; List&lt;T&gt; mergeList(List&lt;? extends T&gt; list, Collection&lt;M&gt; matched, Function&lt;M, Interval&lt;Integer&gt;&gt; toIntervalFunc, Function&lt;List&lt;? extends T&gt;, T&gt; aggregator) {
<span class="nc" id="L660">    List&lt;Interval&lt;Integer&gt;&gt; matchedIntervals = new ArrayList&lt;&gt;(matched.size());</span>
<span class="nc bnc" id="L661" title="All 2 branches missed.">    for (M m : matched) {</span>
<span class="nc" id="L662">      matchedIntervals.add(toIntervalFunc.apply(m));</span>
<span class="nc" id="L663">    }</span>
<span class="nc" id="L664">    return mergeList(list, matchedIntervals, aggregator);</span>
  }

  public static &lt;T&gt; List&lt;T&gt; mergeList(List&lt;? extends T&gt; list, List&lt;? extends HasInterval&lt;Integer&gt;&gt; matched, Function&lt;List&lt;? extends T&gt;, T&gt; aggregator) {
<span class="nc" id="L668">    Collections.sort(matched, HasInterval.ENDPOINTS_COMPARATOR);</span>
<span class="nc" id="L669">    return mergeListWithSortedMatched(list, matched, aggregator);</span>
  }

  public static &lt;T&gt; List&lt;T&gt; mergeListWithSortedMatched(List&lt;? extends T&gt; list, List&lt;? extends HasInterval&lt;Integer&gt;&gt; matched, Function&lt;List&lt;? extends T&gt;, T&gt; aggregator) {
<span class="nc" id="L673">    List&lt;T&gt; merged = new ArrayList&lt;&gt;(list.size()); // Approximate size</span>
<span class="nc" id="L674">    int last = 0;</span>
<span class="nc bnc" id="L675" title="All 2 branches missed.">    for (HasInterval&lt;Integer&gt; m : matched) {</span>
<span class="nc" id="L676">      Interval&lt;Integer&gt; interval = m.getInterval();</span>
<span class="nc" id="L677">      int start = interval.getBegin();</span>
<span class="nc" id="L678">      int end = interval.getEnd();</span>
<span class="nc bnc" id="L679" title="All 2 branches missed.">      if (start &gt;= last) {</span>
<span class="nc" id="L680">        merged.addAll(list.subList(last, start));</span>
<span class="nc" id="L681">        T t = aggregator.apply(list.subList(start, end));</span>
<span class="nc" id="L682">        merged.add(t);</span>
<span class="nc" id="L683">        last = end;</span>
      }
<span class="nc" id="L685">    }</span>
    // Add rest of elements
<span class="nc bnc" id="L687" title="All 2 branches missed.">    if (last &lt; list.size()) {</span>
<span class="nc" id="L688">      merged.addAll(list.subList(last, list.size()));</span>
    }
<span class="nc" id="L690">    return merged;</span>
  }

  public static &lt;T&gt; List&lt;T&gt; mergeListWithSortedMatchedPreAggregated(List&lt;? extends T&gt; list, List&lt;? extends T&gt; matched, Function&lt;T, Interval&lt;Integer&gt;&gt; toIntervalFunc) {
<span class="nc" id="L694">    List&lt;T&gt; merged = new ArrayList&lt;&gt;(list.size()); // Approximate size</span>
<span class="nc" id="L695">    int last = 0;</span>
<span class="nc bnc" id="L696" title="All 2 branches missed.">    for (T m : matched) {</span>
<span class="nc" id="L697">      Interval&lt;Integer&gt; interval = toIntervalFunc.apply(m);</span>
<span class="nc" id="L698">      int start = interval.getBegin();</span>
<span class="nc" id="L699">      int end = interval.getEnd();</span>
<span class="nc bnc" id="L700" title="All 2 branches missed.">      if (start &gt;= last) {</span>
<span class="nc" id="L701">        merged.addAll(list.subList(last, start));</span>
<span class="nc" id="L702">        merged.add(m);</span>
<span class="nc" id="L703">        last = end;</span>
      }
<span class="nc" id="L705">    }</span>
    // Add rest of elements
<span class="nc bnc" id="L707" title="All 2 branches missed.">    if (last &lt; list.size()) {</span>
<span class="nc" id="L708">      merged.addAll(list.subList(last, list.size()));</span>
    }
<span class="nc" id="L710">    return merged;</span>
  }

  /**
   * Combines all the lists in a collection to a single list.
   */
  public static &lt;T&gt; List&lt;T&gt; flatten(Collection&lt;List&lt;T&gt;&gt; nestedList) {
<span class="nc" id="L717">    List&lt;T&gt; result = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L718" title="All 2 branches missed.">    for (List&lt;T&gt; list : nestedList) {</span>
<span class="nc" id="L719">      result.addAll(list);</span>
<span class="nc" id="L720">    }</span>
<span class="nc" id="L721">    return result;</span>
  }

  /**
   * Makes it possible to uniquify a collection of objects which are normally
   * non-hashable. Alternatively, it lets you define an alternate hash function
   * for them for limited-use hashing.
   */
  public static &lt;ObjType, Hashable&gt; Collection&lt;ObjType&gt; uniqueNonhashableObjects(Collection&lt;ObjType&gt; objects, Function&lt;ObjType, Hashable&gt; customHasher) {
<span class="nc" id="L730">    Map&lt;Hashable, ObjType&gt; hashesToObjects = Generics.newHashMap();</span>
<span class="nc bnc" id="L731" title="All 2 branches missed.">    for (ObjType object : objects) {</span>
<span class="nc" id="L732">      hashesToObjects.put(customHasher.apply(object), object);</span>
<span class="nc" id="L733">    }</span>
<span class="nc" id="L734">    return hashesToObjects.values();</span>
  }

  /**
   * if any item in toCheck is present in collection
   *
   * @param collection
   * @param toCheck
   */
  public static &lt;T&gt; boolean containsAny(Collection&lt;T&gt; collection, Collection&lt;T&gt; toCheck){
<span class="fc bfc" id="L744" title="All 2 branches covered.">    for(T c: toCheck){</span>
<span class="fc bfc" id="L745" title="All 2 branches covered.">      if(collection.contains(c))</span>
<span class="fc" id="L746">        return true;</span>
<span class="fc" id="L747">    }</span>
<span class="fc" id="L748">    return false;</span>

  }

  /**
   * Split a list into numFolds (roughly) equally sized folds. The earlier folds
   * may have one more item in them than later folds.
   * &lt;br&gt;
   * The lists returned are subList()s of the original list.
   * Therefore, don't try to modify the sublists, and don't modify the
   * original list while the sublists are in use.
   */
  public static &lt;T&gt; List&lt;List&lt;T&gt;&gt; partitionIntoFolds(List&lt;T&gt; values, int numFolds) {
<span class="nc" id="L761">    List&lt;List&lt;T&gt;&gt; folds = Generics.newArrayList();</span>
<span class="nc" id="L762">    int numValues = values.size();</span>
<span class="nc" id="L763">    int foldSize = numValues / numFolds;</span>
<span class="nc" id="L764">    int remainder = numValues % numFolds;</span>

<span class="nc" id="L766">    int start = 0;</span>
<span class="nc" id="L767">    int end = foldSize;</span>
<span class="nc bnc" id="L768" title="All 2 branches missed.">    for (int foldNum = 0; foldNum &lt; numFolds; foldNum++) {</span>
      // if we're in the first 'remainder' folds, we get an extra item
<span class="nc bnc" id="L770" title="All 2 branches missed.">      if (foldNum &lt; remainder) {</span>
<span class="nc" id="L771">        end++;</span>
      }
<span class="nc" id="L773">      folds.add(values.subList(start, end));</span>

<span class="nc" id="L775">      start = end;</span>
<span class="nc" id="L776">      end += foldSize;</span>
    }

<span class="nc" id="L779">    return folds;</span>
  }

  /**
   * Split a list into train, test pairs for use in k-fold crossvalidation. This
   * returns a list of numFold (train, test) pairs where each train list will
   * contain (numFolds-1)/numFolds of the original values and the test list will
   * contain the remaining 1/numFolds of the original values.
   */
  public static &lt;T&gt; Collection&lt;Pair&lt;Collection&lt;T&gt;, Collection&lt;T&gt;&gt;&gt; trainTestFoldsForCV(List&lt;T&gt; values, int numFolds) {
<span class="nc" id="L789">    Collection&lt;Pair&lt;Collection&lt;T&gt;, Collection&lt;T&gt;&gt;&gt; trainTestPairs = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L790">    List&lt;List&lt;T&gt;&gt; folds = partitionIntoFolds(values, numFolds);</span>
<span class="nc bnc" id="L791" title="All 2 branches missed.">    for (int splitNum = 0; splitNum &lt; numFolds; splitNum++) {</span>
<span class="nc" id="L792">      Collection&lt;T&gt; test = folds.get(splitNum);</span>
<span class="nc" id="L793">      Collection&lt;T&gt; train = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L794" title="All 2 branches missed.">      for (int foldNum = 0; foldNum &lt; numFolds; foldNum++) {</span>
<span class="nc bnc" id="L795" title="All 2 branches missed.">        if (foldNum != splitNum) {</span>
<span class="nc" id="L796">          train.addAll(folds.get(foldNum));</span>
        }
      }

<span class="nc" id="L800">      trainTestPairs.add(new Pair&lt;&gt;(train, test));</span>
    }

<span class="nc" id="L803">    return trainTestPairs;</span>
  }

  /**
   * Returns a list of all modes in the Collection.  (If the Collection has multiple items with the
   * highest frequency, all of them will be returned.)
   */
  public static &lt;T&gt; Set&lt;T&gt; modes(Collection&lt;T&gt; values) {
<span class="nc" id="L811">    Counter&lt;T&gt; counter = new ClassicCounter&lt;&gt;(values);</span>
<span class="nc" id="L812">    List&lt;Double&gt; sortedCounts = CollectionUtils.sorted(counter.values());</span>
<span class="nc" id="L813">    Double highestCount = sortedCounts.get(sortedCounts.size() - 1);</span>
<span class="nc" id="L814">    Counters.retainAbove(counter, highestCount);</span>
<span class="nc" id="L815">    return counter.keySet();</span>
  }

  /**
   * Returns the mode in the Collection.  If the Collection has multiple modes, this method picks one
   * arbitrarily.
   */
  public static &lt;T&gt; T mode(Collection&lt;T&gt; values) {
<span class="nc" id="L823">    Set&lt;T&gt; modes = modes(values);</span>
<span class="nc" id="L824">    return modes.iterator().next();</span>
  }


  /**
   * Transforms the keyset of collection according to the given Function and returns a set of the keys.
   *
   */
  public static&lt;T1, T2&gt; Set&lt;T2&gt; transformAsSet(Collection&lt;? extends T1&gt; original, Function&lt;T1, ? extends T2&gt; f){
<span class="nc" id="L833">    Set&lt;T2&gt; transformed = Generics.newHashSet();</span>
<span class="nc bnc" id="L834" title="All 2 branches missed.">    for(T1 t: original){</span>
<span class="nc" id="L835">      transformed.add(f.apply(t));</span>
<span class="nc" id="L836">    }</span>
<span class="nc" id="L837">    return transformed;</span>
  }


  /**
   * Transforms the keyset of collection according to the given Function and returns a list.
   *
   */
  public static&lt;T1, T2&gt; List&lt;T2&gt; transformAsList(Collection&lt;? extends T1&gt; original, Function&lt;T1, ? extends T2&gt; f){
<span class="fc" id="L846">    List&lt;T2&gt; transformed = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L847" title="All 2 branches covered.">    for(T1 t: original){</span>
<span class="fc" id="L848">      transformed.add(f.apply(t));</span>
<span class="fc" id="L849">    }</span>
<span class="fc" id="L850">    return transformed;</span>
  }

  /**
   * Filters the objects in the collection according to the given Filter and returns a list.
   *
   */
  public static&lt;T&gt; List&lt;T&gt; filterAsList(Collection&lt;? extends T&gt; original, Predicate&lt;? super T&gt; f){
<span class="nc" id="L858">    List&lt;T&gt; transformed = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L859" title="All 2 branches missed.">    for (T t: original) {</span>
<span class="nc bnc" id="L860" title="All 2 branches missed.">      if (f.test(t)) {</span>
<span class="nc" id="L861">        transformed.add(t);</span>
      }
<span class="nc" id="L863">    }</span>
<span class="nc" id="L864">    return transformed;</span>
  }

  /**
   * Get all values corresponding to the indices (if they exist in the map).
   *
   * @param map Any map from T to V
   * @param indices A collection of indices of type T
   * @return The corresponding list of values of type V
   */
  public static&lt;T,V&gt; List&lt;V&gt; getAll(Map&lt;T, V&gt; map, Collection&lt;T&gt; indices) {
<span class="nc" id="L875">    List&lt;V&gt; result = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L876" title="All 2 branches missed.">    for(T i: indices)</span>
<span class="nc bnc" id="L877" title="All 2 branches missed.">      if(map.containsKey(i)){</span>
<span class="nc" id="L878">        result.add(map.get(i));</span>
      }
<span class="nc" id="L880">    return result;</span>
  }

  public static&lt;T extends Comparable&lt;? super T&gt;&gt; int maxIndex(List&lt;T&gt; list){
<span class="fc" id="L884">   T max = null;</span>
<span class="fc" id="L885">   int i = 0;</span>
<span class="fc" id="L886">   int maxIndex = -1;</span>
<span class="fc bfc" id="L887" title="All 2 branches covered.">   for(T t: list)</span>
   {
<span class="fc bfc" id="L889" title="All 4 branches covered.">     if(max == null || t.compareTo(max) &gt; 0)</span>
     {
<span class="fc" id="L891">       max = t;</span>
<span class="fc" id="L892">       maxIndex = i;</span>
     }
<span class="fc" id="L894">     i++;</span>
<span class="fc" id="L895">   }</span>
<span class="fc" id="L896">   return maxIndex;</span>
  }


  /**
   * Concatenate a number of iterators together, to form one big iterator.
   * This should respect the remove() functionality of the constituent iterators.
   *
   * @param iterators The iterators to concatenate.
   * @param &lt;E&gt; The type of the iterators.
   * @return An iterator consisting of all the component iterators concatenated together in order.
   */
  @SafeVarargs
  public static &lt;E&gt; Iterator&lt;E&gt; concatIterators(final Iterator&lt;E&gt;... iterators) {
<span class="fc" id="L910">    return new Iterator&lt;E&gt;() {</span>
<span class="fc" id="L911">      Iterator&lt;E&gt; lastIter = null;</span>
<span class="fc" id="L912">      List&lt;Iterator&lt;E&gt;&gt; iters = new LinkedList&lt;&gt;(Arrays.asList(iterators));</span>
      @Override
      public boolean hasNext() {
<span class="pc bpc" id="L915" title="1 of 4 branches missed.">        return !iters.isEmpty() &amp;&amp; iters.get(0).hasNext();</span>
      }
      @Override
      public E next() {
<span class="pc bpc" id="L919" title="1 of 2 branches missed.">        if (!hasNext()) {</span>
<span class="nc" id="L920">          throw new IllegalArgumentException(&quot;Iterator is empty!&quot;);</span>
        }
<span class="fc" id="L922">        E next = iters.get(0).next();</span>
<span class="fc" id="L923">        lastIter = iters.get(0);</span>
<span class="fc bfc" id="L924" title="All 4 branches covered.">        while (!iters.isEmpty() &amp;&amp; !iters.get(0).hasNext()) {</span>
<span class="fc" id="L925">          iters.remove(0);</span>
        }
<span class="fc" id="L927">        return next;</span>
      }
      @Override
      public void remove() {
<span class="pc bpc" id="L931" title="1 of 2 branches missed.">        if (lastIter == null) {</span>
<span class="nc" id="L932">          throw new IllegalStateException(&quot;Call next() before calling remove()!&quot;);</span>
        }
<span class="fc" id="L934">        lastIter.remove();</span>
<span class="fc" id="L935">      }</span>
    };
  }

  public static &lt;E&gt; Iterator&lt;E&gt; iteratorFromEnumerator(final Enumeration&lt;E&gt; lst_) {
<span class="nc" id="L940">    return new Iterator&lt;E&gt;() {</span>
<span class="nc" id="L941">      private final Enumeration&lt;E&gt; lst = lst_;</span>
      @Override
      public boolean hasNext() {
<span class="nc" id="L944">        return lst.hasMoreElements();</span>
      }

      @Override
      public E next() {
<span class="nc" id="L949">        return lst.nextElement();</span>
      }
    };
  }

  public static &lt;E&gt; Iterable&lt;E&gt; iterableFromEnumerator(final Enumeration&lt;E&gt; lst) {
<span class="nc" id="L955">    return new IterableIterator&lt;&gt;(iteratorFromEnumerator(lst));</span>
  }


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>