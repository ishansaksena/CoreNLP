<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MetaClass.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.util</a> &gt; <span class="el_source">MetaClass.java</span></div><h1>MetaClass.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.util;

import edu.stanford.nlp.io.IOUtils;
import edu.stanford.nlp.io.RuntimeIOException;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.trees.LabeledScoredTreeFactory;
import edu.stanford.nlp.trees.PennTreeReader;
import edu.stanford.nlp.trees.Tree;

import java.io.*;
import java.lang.reflect.*;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.*;

/**
 * A meta class using Java's reflection library. Can be used to create a single
 * instance, or a factory, where each Class from the factory share their
 * constructor parameters.
 *
 * @author Gabor Angeli
 */
public class MetaClass {

  public static class ClassCreationException extends RuntimeException {

    private static final long serialVersionUID = -5980065992461870357L;

    private ClassCreationException() {
<span class="nc" id="L30">      super();</span>
<span class="nc" id="L31">    }</span>

    private ClassCreationException(String msg) {
<span class="fc" id="L34">      super(msg);</span>
<span class="fc" id="L35">    }</span>

    private ClassCreationException(Throwable cause) {
<span class="nc" id="L38">      super(cause);</span>
<span class="nc" id="L39">    }</span>

    private ClassCreationException(String msg, Throwable cause) {
<span class="nc" id="L42">      super(msg, cause);</span>
<span class="nc" id="L43">    }</span>

  }

  public static final class ConstructorNotFoundException extends ClassCreationException {
    private static final long serialVersionUID = -5980065992461870357L;

    private ConstructorNotFoundException() {
<span class="nc" id="L51">      super();</span>
<span class="nc" id="L52">    }</span>

    private ConstructorNotFoundException(String msg) {
<span class="fc" id="L55">      super(msg);</span>
<span class="fc" id="L56">    }</span>

    private ConstructorNotFoundException(Throwable cause) {
<span class="nc" id="L59">      super(cause);</span>
<span class="nc" id="L60">    }</span>

    private ConstructorNotFoundException(String msg, Throwable cause) {
<span class="nc" id="L63">      super(msg, cause);</span>
<span class="nc" id="L64">    }</span>


  }

  public static final class ClassFactory&lt;T&gt; {
    private Class&lt;?&gt;[] classParams;
    private Class&lt;T&gt; cl;
    private Constructor&lt;T&gt; constructor;

    private static boolean samePrimitive(Class&lt;?&gt; a, Class&lt;?&gt; b){
<span class="pc bpc" id="L75" title="1 of 4 branches missed.">      if(!a.isPrimitive() &amp;&amp; !b.isPrimitive()) return false;</span>
<span class="pc bpc" id="L76" title="1 of 2 branches missed.">      if(a.isPrimitive()){</span>
        try {
<span class="nc" id="L78">          Class&lt;?&gt; type = (Class&lt;?&gt;) b.getField(&quot;TYPE&quot;).get(null);</span>
<span class="nc" id="L79">          return type.equals(a);</span>
<span class="nc" id="L80">        } catch (Exception e) {</span>
<span class="nc" id="L81">          return false;</span>
        }
      }
<span class="pc bpc" id="L84" title="1 of 2 branches missed.">      if(b.isPrimitive()){</span>
        try {
<span class="fc" id="L86">          Class&lt;?&gt; type = (Class&lt;?&gt;) a.getField(&quot;TYPE&quot;).get(null);</span>
<span class="fc" id="L87">          return type.equals(b);</span>
<span class="fc" id="L88">        } catch (Exception e) {</span>
<span class="fc" id="L89">          return false;</span>
        }
      }
<span class="nc" id="L92">      throw new IllegalStateException(&quot;Impossible case&quot;);</span>
    }

    private static int superDistance(Class&lt;?&gt; candidate, Class&lt;?&gt; target) {
<span class="fc bfc" id="L96" title="All 2 branches covered.">      if (candidate == null) {</span>
        // --base case: does not implement
<span class="fc" id="L98">        return Integer.MIN_VALUE;</span>
<span class="fc bfc" id="L99" title="All 2 branches covered.">      } else if (candidate.equals(target)) {</span>
        // --base case: exact match
<span class="fc" id="L101">        return 0;</span>
<span class="fc bfc" id="L102" title="All 2 branches covered.">      } else if(samePrimitive(candidate, target)){</span>
        // --base case: primitive and wrapper
<span class="fc" id="L104">        return 0;</span>
      } else {
        // --recursive case: try superclasses
        // case: direct superclass
<span class="fc" id="L108">        Class&lt;?&gt; directSuper = candidate.getSuperclass();</span>
<span class="fc" id="L109">        int superDist = superDistance(directSuper, target);</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">        if (superDist &gt;= 0)</span>
<span class="fc" id="L111">          return superDist + 1; // case: superclass distance</span>
        // case: implementing interfaces
<span class="fc" id="L113">        Class&lt;?&gt;[] interfaces = candidate.getInterfaces();</span>
<span class="fc" id="L114">        int minDist = Integer.MAX_VALUE;</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">        for (Class&lt;?&gt; i : interfaces) {</span>
<span class="fc" id="L116">          superDist = superDistance(i, target);</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">          if (superDist &gt;= 0) {</span>
<span class="fc" id="L118">            minDist = Math.min(minDist, superDist);</span>
          }
        }
<span class="fc bfc" id="L121" title="All 2 branches covered.">        if (minDist != Integer.MAX_VALUE)</span>
<span class="fc" id="L122">          return minDist + 1; // case: interface distance</span>
        else
<span class="fc" id="L124">          return -1; // case: failure</span>
      }
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    private void construct(String classname, Class&lt;?&gt;... params)
        throws ClassNotFoundException, NoSuchMethodException {
      // (save class parameters)
<span class="fc" id="L132">      this.classParams = params;</span>
      // (create class)
      try {
<span class="fc" id="L135">        this.cl = (Class&lt;T&gt;) Class.forName(classname);</span>
<span class="nc" id="L136">      } catch (ClassCastException e) {</span>
<span class="nc" id="L137">        throw new ClassCreationException(&quot;Class &quot; + classname</span>
            + &quot; could not be cast to the correct type&quot;);
<span class="fc" id="L139">      }</span>
      // --Find Constructor
      // (get constructors)
<span class="fc" id="L142">      Constructor&lt;?&gt;[] constructors = cl.getDeclaredConstructors();</span>
<span class="fc" id="L143">      Constructor&lt;?&gt;[] potentials = new Constructor&lt;?&gt;[constructors.length];</span>
<span class="fc" id="L144">      Class&lt;?&gt;[][] constructorParams = new Class&lt;?&gt;[constructors.length][];</span>
<span class="fc" id="L145">      int[] distances = new int[constructors.length]; //distance from base class</span>
      // (filter: length)
<span class="fc bfc" id="L147" title="All 2 branches covered.">      for (int i = 0; i &lt; constructors.length; i++) {</span>
<span class="fc" id="L148">        constructorParams[i] = constructors[i].getParameterTypes();</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">        if (params.length == constructorParams[i].length) { // length is good</span>
<span class="fc" id="L150">          potentials[i] = constructors[i];</span>
<span class="fc" id="L151">          distances[i] = 0;</span>
        } else { // length is bad
<span class="fc" id="L153">          potentials[i] = null;</span>
<span class="fc" id="L154">          distances[i] = -1;</span>
        }
      }
      // (filter:type)
<span class="fc bfc" id="L158" title="All 2 branches covered.">      for (int paramIndex = 0; paramIndex &lt; params.length; paramIndex++) { // for each parameter...</span>
<span class="fc" id="L159">        Class&lt;?&gt; target = params[paramIndex];</span>
<span class="fc bfc" id="L160" title="All 2 branches covered.">        for (int conIndex = 0; conIndex &lt; potentials.length; conIndex++) { // for each constructor...</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">          if (potentials[conIndex] != null) { // if the constructor is in the pool...</span>
<span class="fc" id="L162">            Class&lt;?&gt; cand = constructorParams[conIndex][paramIndex];</span>
<span class="fc" id="L163">            int dist = superDistance(target, cand);</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">            if (dist &gt;= 0) { // and if the constructor matches...</span>
<span class="fc" id="L165">              distances[conIndex] += dist; // keep it</span>
            } else {
<span class="fc" id="L167">              potentials[conIndex] = null; // else, remove it from the pool</span>
<span class="fc" id="L168">              distances[conIndex] = -1;</span>
            }
          }
        }
      }
      // (filter:min)
<span class="fc" id="L174">      this.constructor = (Constructor&lt;T&gt;) argmin(potentials, distances, 0);</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">      if (this.constructor == null) {</span>
<span class="fc" id="L176">        StringBuilder b = new StringBuilder();</span>
<span class="fc" id="L177">        b.append(classname).append(&quot;(&quot;);</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">        for (Class&lt;?&gt; c : params) {</span>
<span class="fc" id="L179">          b.append(c.getName()).append(&quot;, &quot;);</span>
        }
<span class="pc bpc" id="L181" title="1 of 2 branches missed.">        String target = b.substring(0, params.length==0 ? b.length() : b.length() - 2) + &quot;)&quot;;</span>
<span class="fc" id="L182">        throw new ConstructorNotFoundException(</span>
            &quot;No constructor found to match: &quot; + target);
      }
<span class="fc" id="L185">    }</span>

    private ClassFactory(String classname, Class&lt;?&gt;... params)
<span class="fc" id="L188">        throws ClassNotFoundException, NoSuchMethodException {</span>
      // (generic construct)
<span class="fc" id="L190">      construct(classname, params);</span>
<span class="fc" id="L191">    }</span>

    private ClassFactory(String classname, Object... params)
<span class="fc" id="L194">        throws ClassNotFoundException, NoSuchMethodException {</span>
      // (convert class parameters)
<span class="fc" id="L196">      Class&lt;?&gt;[] classParams = new Class[params.length];</span>
<span class="fc bfc" id="L197" title="All 2 branches covered.">      for (int i = 0; i &lt; params.length; i++) {</span>
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">        if(params[i] == null) throw new ClassCreationException(&quot;Argument &quot; + i + &quot; to class constructor is null&quot;);</span>
<span class="fc" id="L199">        classParams[i] = params[i].getClass();</span>
      }
      // (generic construct)
<span class="fc" id="L202">      construct(classname, classParams);</span>
<span class="fc" id="L203">    }</span>

    private ClassFactory(String classname, String... params)
<span class="nc" id="L206">        throws ClassNotFoundException, NoSuchMethodException {</span>
      // (convert class parameters)
<span class="nc" id="L208">      Class&lt;?&gt;[] classParams = new Class[params.length];</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">      for (int i = 0; i &lt; params.length; i++) {</span>
<span class="nc" id="L210">        classParams[i] = Class.forName(params[i]);</span>
      }
      // (generic construct)
<span class="nc" id="L213">      construct(classname, classParams);</span>
<span class="nc" id="L214">    }</span>

    /**
     * Creates an instance of the class produced in this factory
     *
     * @param params
     *            The arguments to the constructor of the class NOTE: the
     *            resulting instance will [unlike java] invoke the most
     *            narrow constructor rather than the one which matches the
     *            signature passed to this function
     * @return An instance of the class
     */
    public T createInstance(Object... params) {
      try {
<span class="fc" id="L228">        boolean accessible = true;</span>
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">        if(!constructor.isAccessible()){</span>
<span class="fc" id="L230">          accessible = false;</span>
<span class="fc" id="L231">          constructor.setAccessible(true);</span>
        }
<span class="fc" id="L233">        T rtn = constructor.newInstance(params);</span>
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">        if(!accessible){ constructor.setAccessible(false); }</span>
<span class="fc" id="L235">        return rtn;</span>
<span class="nc" id="L236">      } catch (Exception e) {</span>
<span class="nc" id="L237">        throw new ClassCreationException(&quot;MetaClass couldn't create &quot; + constructor + &quot; with args &quot; + Arrays.toString(params), e);</span>
      }
    }

    /**
     * Returns the full class name for the objects being produced
     *
     * @return The class name for the objects produced
     */
    public String getName() {
<span class="nc" id="L247">      return cl.getName();</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L252">      StringBuilder b = new StringBuilder();</span>
<span class="nc" id="L253">      b.append(cl.getName()).append('(');</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">      for (Class&lt;?&gt; cl : classParams) {</span>
<span class="nc" id="L255">        b.append(' ').append(cl.getName()).append(',');</span>
      }
<span class="nc" id="L257">      b.replace(b.length() - 1, b.length(), &quot; &quot;);</span>
<span class="nc" id="L258">      b.append(')');</span>
<span class="nc" id="L259">      return b.toString();</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public boolean equals(Object o) {
<span class="nc bnc" id="L265" title="All 2 branches missed.">      if (o instanceof ClassFactory) {</span>
<span class="nc" id="L266">        ClassFactory other = (ClassFactory) o;</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">        if (!this.cl.equals(other.cl))</span>
<span class="nc" id="L268">          return false;</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">        for (int i = 0; i &lt; classParams.length; i++) {</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">          if (!this.classParams[i].equals(other.classParams[i]))</span>
<span class="nc" id="L271">            return false;</span>
        }
<span class="nc" id="L273">        return true;</span>
      } else {
<span class="nc" id="L275">        return false;</span>
      }
    }

    @Override
    public int hashCode() {
<span class="nc" id="L281">      return cl.hashCode();</span>
    }

  } // end static class ClassFactory

  private String classname;

  /**
   * Creates a new MetaClass producing objects of the given type
   *
   * @param classname
   *            The full classname of the objects to create
   */
<span class="fc" id="L294">  public MetaClass(String classname) {</span>
<span class="fc" id="L295">    this.classname = classname;</span>
<span class="fc" id="L296">  }</span>

  /**
   * Creates a new MetaClass producing objects of the given type
   *
   * @param classname
   *            The class to create
   */
<span class="fc" id="L304">  public MetaClass(Class&lt;?&gt; classname) {</span>
<span class="fc" id="L305">    this.classname = classname.getName();</span>
<span class="fc" id="L306">  }</span>

  /**
   * Creates a factory for producing instances of this class from a
   * constructor taking the given types as arguments
   *
   * @param &lt;E&gt;
   *            The type of the objects to be produced
   * @param classes
   *            The types used in the constructor
   * @return A ClassFactory of the given type
   */
  public &lt;E&gt; ClassFactory&lt;E&gt; createFactory(Class&lt;?&gt;... classes) {
    try {
<span class="fc" id="L320">      return new ClassFactory&lt;&gt;(classname, classes);</span>
<span class="nc" id="L321">    } catch (ClassCreationException e){</span>
<span class="nc" id="L322">      throw e;</span>
<span class="nc" id="L323">    } catch (Exception e) {</span>
<span class="nc" id="L324">      throw new ClassCreationException(e);</span>
    }
  }

  /**
   * Creates a factory for producing instances of this class from a
   * constructor taking the given types as arguments
   *
   * @param &lt;E&gt;
   *            The type of the objects to be produced
   * @param classes
   *            The types used in the constructor
   * @return A ClassFactory of the given type
   */
  public &lt;E&gt; ClassFactory&lt;E&gt; createFactory(String... classes) {
    try {
<span class="nc" id="L340">      return new ClassFactory&lt;&gt;(classname, classes);</span>
<span class="nc" id="L341">    } catch (ClassCreationException e){</span>
<span class="nc" id="L342">      throw e;</span>
<span class="nc" id="L343">    } catch (Exception e) {</span>
<span class="nc" id="L344">      throw new ClassCreationException(e);</span>
    }
  }

  /**
   * Creates a factory for producing instances of this class from a
   * constructor taking objects of the types given
   *
   * @param &lt;E&gt;
   *            The type of the objects to be produced
   * @param objects
   *            Instances of the types used in the constructor
   * @return A ClassFactory of the given type
   */
  public &lt;E&gt; ClassFactory&lt;E&gt; createFactory(Object... objects) {
    try {
<span class="fc" id="L360">      return new ClassFactory&lt;&gt;(classname, objects);</span>
<span class="fc" id="L361">    } catch (ClassCreationException e){</span>
<span class="fc" id="L362">      throw e;</span>
<span class="nc" id="L363">    } catch (Exception e) {</span>
<span class="nc" id="L364">      throw new ClassCreationException(e);</span>
    }
  }

  /**
   * Create an instance of the class, inferring the type automatically, and
   * given an array of objects as constructor parameters NOTE: the resulting
   * instance will [unlike java] invoke the most narrow constructor rather
   * than the one which matches the signature passed to this function
   *
   * @param &lt;E&gt;
   *            The type of the object returned
   * @param objects
   *            The arguments to the constructor of the class
   * @return An instance of the class
   */
  public &lt;E&gt; E createInstance(Object... objects) {
<span class="fc" id="L381">    ClassFactory&lt;E&gt; fact = createFactory(objects);</span>
<span class="fc" id="L382">    return fact.createInstance(objects);</span>
  }

  /**
   * Creates an instance of the class, forcing a cast to a certain type and
   * given an array of objects as constructor parameters NOTE: the resulting
   * instance will [unlike java] invoke the most narrow constructor rather
   * than the one which matches the signature passed to this function
   *
   * @param &lt;E&gt;
   *            The type of the object returned
   * @param type
   *            The class of the object returned
   * @param params
   *            The arguments to the constructor of the class
   * @return An instance of the class
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public &lt;E,F extends E&gt; F createInstance(Class&lt;E&gt; type, Object... params) {
<span class="nc" id="L401">    Object obj = createInstance(params);</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">    if (type.isInstance(obj)) {</span>
<span class="nc" id="L403">      return (F) obj;</span>
    } else {
<span class="nc" id="L405">      throw new ClassCreationException(&quot;Cannot cast &quot; + classname</span>
<span class="nc" id="L406">          + &quot; into &quot; + type.getName());</span>
    }
  }

  public boolean checkConstructor(Object... params){
    try{
<span class="nc" id="L412">      createInstance(params);</span>
<span class="nc" id="L413">      return true;</span>
<span class="nc" id="L414">    } catch(ConstructorNotFoundException e){</span>
<span class="nc" id="L415">      return false;</span>
    }
  }

  @Override
  public String toString() {
<span class="nc" id="L421">    return classname;</span>
  }

  @Override
  public boolean equals(Object o) {
<span class="nc bnc" id="L426" title="All 2 branches missed.">    if (o instanceof MetaClass) {</span>
<span class="nc" id="L427">      return ((MetaClass) o).classname.equals(this.classname);</span>
    }
<span class="nc" id="L429">    return false;</span>
  }

  @Override
  public int hashCode() {
<span class="nc" id="L434">    return classname.hashCode();</span>
  }

  /**
   * Creates a new MetaClass (helper method)
   *
   * @param classname
   *            The name of the class to create
   * @return A new MetaClass object of the given class
   */
  public static MetaClass create(String classname) {
<span class="fc" id="L445">    return new MetaClass(classname);</span>
  }

  /**
   * Creates a new MetaClass (helper method)
   *
   * @param clazz
   *            The class to create
   * @return A new MetaClass object of the given class
   */
  public static MetaClass create(Class &lt;?&gt; clazz) {
<span class="fc" id="L456">    return new MetaClass(clazz);</span>
  }

  /**
   * Utility method for cast
   * @param type The type to cast into a class
   * @return The class corresponding to the passed in type
   */
  private static Class &lt;?&gt; type2class(Type type){
<span class="nc bnc" id="L465" title="All 2 branches missed.">		if(type instanceof Class &lt;?&gt;){</span>
<span class="nc" id="L466">			return (Class &lt;?&gt;) type;	//base case</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">		}else if(type instanceof ParameterizedType){</span>
<span class="nc" id="L468">			return type2class( ((ParameterizedType) type).getRawType() );</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">		}else if(type instanceof TypeVariable&lt;?&gt;){</span>
<span class="nc" id="L470">			return type2class( ((TypeVariable&lt;?&gt;) type).getBounds()[0] );</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">		}else if(type instanceof WildcardType){</span>
<span class="nc" id="L472">			return type2class( ((WildcardType) type).getUpperBounds()[0] );</span>
		}else{
<span class="nc" id="L474">			throw new IllegalArgumentException(&quot;Cannot convert type to class: &quot; + type);</span>
		}
	}

  /**
   * Cast a String representation of an object into that object.
   * E.g. &quot;5.4&quot; will be cast to a Double; &quot;[1,2,3]&quot; will be cast
   * to an Integer[].
   *
   * NOTE: Date parses from a Long
   *
   * @param &lt;E&gt; The type of the object returned (same as type)
   * @param value The string representation of the object
   * @param type The type (usually class) to be returned (same as E)
   * @return An object corresponding to the String value passed
   */
  @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
  public static &lt;E&gt; E cast(String value, Type type){
    //--Get Type
    Class &lt;?&gt; clazz;
<span class="pc bpc" id="L494" title="1 of 2 branches missed.">    if (type instanceof Class) {</span>
<span class="fc" id="L495">      clazz = (Class &lt;?&gt;) type;</span>
<span class="nc bnc" id="L496" title="All 2 branches missed.">    } else if (type instanceof ParameterizedType) {</span>
<span class="nc" id="L497">      ParameterizedType pt = (ParameterizedType) type;</span>
<span class="nc" id="L498">      clazz = (Class &lt;?&gt;) pt.getRawType();</span>
<span class="nc" id="L499">    } else {</span>
<span class="nc" id="L500">      throw new IllegalArgumentException(&quot;Cannot cast to type (unhandled type): &quot; + type);</span>
    }
    //--Cast
<span class="fc bfc" id="L503" title="All 2 branches covered.">    if (String.class.isAssignableFrom(clazz)) {</span>
      // (case: String)
<span class="fc" id="L505">      return (E) value;</span>
<span class="pc bpc" id="L506" title="1 of 4 branches missed.">    } else if (Boolean.class.isAssignableFrom(clazz) || boolean.class.isAssignableFrom(clazz)) {</span>
      //(case: boolean)
<span class="fc bfc" id="L508" title="All 2 branches covered.">      if(&quot;1&quot;.equals(value)){ return (E) Boolean.TRUE; }</span>
<span class="fc" id="L509">      return (E) Boolean.valueOf(Boolean.parseBoolean(value));</span>
<span class="fc bfc" id="L510" title="All 4 branches covered.">    } else if (Integer.class.isAssignableFrom(clazz) || int.class.isAssignableFrom(clazz)) {</span>
      //(case: integer)
      try {
<span class="fc" id="L513">        return (E) new Integer(Integer.parseInt(value));</span>
<span class="fc" id="L514">      } catch (NumberFormatException e) {</span>
<span class="fc" id="L515">        return (E) new Integer((int) Double.parseDouble(value));</span>
      }
<span class="pc bpc" id="L517" title="1 of 2 branches missed.">    } else if (BigInteger.class.isAssignableFrom(clazz)) {</span>
      //(case: biginteger)
<span class="nc bnc" id="L519" title="All 2 branches missed.">      if(value == null){ return (E) BigInteger.ZERO; }</span>
<span class="nc" id="L520">      return (E) new BigInteger(value);</span>
<span class="pc bpc" id="L521" title="1 of 4 branches missed.">    } else if (Long.class.isAssignableFrom(clazz) || long.class.isAssignableFrom(clazz)) {</span>
      //(case: long)
      try {
<span class="nc" id="L524">        return (E) new Long(Long.parseLong(value));</span>
<span class="fc" id="L525">      } catch (NumberFormatException e) {</span>
<span class="fc" id="L526">        return (E) new Long((long) Double.parseDouble(value));</span>
      }
<span class="pc bpc" id="L528" title="2 of 4 branches missed.">    } else if (Float.class.isAssignableFrom(clazz) || float.class.isAssignableFrom(clazz)) {</span>
      //(case: float)
<span class="nc bnc" id="L530" title="All 2 branches missed.">      if(value == null){ return (E) new Float(Float.NaN); }</span>
<span class="nc" id="L531">      return (E) new Float(Float.parseFloat(value));</span>
<span class="pc bpc" id="L532" title="1 of 4 branches missed.">    } else if (Double.class.isAssignableFrom(clazz) || double.class.isAssignableFrom(clazz)) {</span>
      //(case: double)
<span class="pc bpc" id="L534" title="1 of 2 branches missed.">      if(value == null){ return (E) new Double(Double.NaN); }</span>
<span class="fc" id="L535">      return (E) new Double(Double.parseDouble(value));</span>
<span class="pc bpc" id="L536" title="1 of 2 branches missed.">    } else if (BigDecimal.class.isAssignableFrom(clazz)) {</span>
      //(case: bigdecimal)
<span class="nc bnc" id="L538" title="All 2 branches missed.">      if(value == null){ return (E) BigDecimal.ZERO; }</span>
<span class="nc" id="L539">      return (E) new BigDecimal(value);</span>
<span class="pc bpc" id="L540" title="1 of 4 branches missed.">    } else if (Short.class.isAssignableFrom(clazz) || short.class.isAssignableFrom(clazz)) {</span>
      //(case: short)
      try {
<span class="nc" id="L543">        return (E) new Short(Short.parseShort(value));</span>
<span class="fc" id="L544">      } catch (NumberFormatException e) {</span>
<span class="fc" id="L545">        return (E) new Short((short) Double.parseDouble(value));</span>
      }
<span class="pc bpc" id="L547" title="1 of 4 branches missed.">    } else if (Byte.class.isAssignableFrom(clazz) || byte.class.isAssignableFrom(clazz)) {</span>
      //(case: byte)
      try {
<span class="nc" id="L550">        return (E) new Byte(Byte.parseByte(value));</span>
<span class="fc" id="L551">      } catch (NumberFormatException e) {</span>
<span class="fc" id="L552">        return (E) new Byte((byte) Double.parseDouble(value));</span>
      }
<span class="pc bpc" id="L554" title="1 of 4 branches missed.">    } else if(Character.class.isAssignableFrom(clazz) || char.class.isAssignableFrom(clazz)) {</span>
      //(case: char)
<span class="nc" id="L556">      return (E) new Character((char) Integer.parseInt(value));</span>
<span class="pc bpc" id="L557" title="1 of 2 branches missed.">    } else if(Lazy.class.isAssignableFrom(clazz)) {</span>
      //(case: Lazy)
<span class="nc" id="L559">      final String v = value;</span>
<span class="nc" id="L560">      return (E) Lazy.of(() -&gt; MetaClass.castWithoutKnowingType(v) );</span>
<span class="pc bpc" id="L561" title="1 of 2 branches missed.">    } else if (Optional.class.isAssignableFrom(clazz)) {</span>
      //(case: Optional)
<span class="nc bnc" id="L563" title="All 8 branches missed.">      return (E) ((value == null || &quot;null&quot;.equals(value.toLowerCase()) || &quot;empty&quot;.equals(value.toLowerCase()) || &quot;none&quot;.equals(value.toLowerCase())) ? Optional.empty() : Optional.of(value));</span>
<span class="fc bfc" id="L564" title="All 2 branches covered.">    } else if (java.util.Date.class.isAssignableFrom(clazz)) {</span>
      //(case: date)
      try {
<span class="nc" id="L567">        return (E) new Date(Long.parseLong(value));</span>
<span class="fc" id="L568">      } catch (NumberFormatException e) {</span>
<span class="fc" id="L569">        return null;</span>
      }
<span class="pc bpc" id="L571" title="1 of 2 branches missed.">    } else if (java.util.Calendar.class.isAssignableFrom(clazz)) {</span>
      //(case: date)
      try {
<span class="nc" id="L574">        Date d = new Date(Long.parseLong(value));</span>
<span class="nc" id="L575">        GregorianCalendar cal = new GregorianCalendar();</span>
<span class="nc" id="L576">        cal.setTime(d);</span>
<span class="nc" id="L577">        return (E) cal;</span>
<span class="nc" id="L578">      } catch (NumberFormatException e) {</span>
<span class="nc" id="L579">        return null;</span>
      }
<span class="pc bpc" id="L581" title="1 of 2 branches missed.">    } else if (FileWriter.class.isAssignableFrom(clazz)) {</span>
      try {
<span class="nc" id="L583">        return (E) new FileWriter(new File(value));</span>
<span class="nc" id="L584">      } catch (IOException e) {</span>
<span class="nc" id="L585">        throw new RuntimeIOException(e);</span>
      }
<span class="pc bpc" id="L587" title="1 of 2 branches missed.">    } else if (BufferedReader.class.isAssignableFrom(clazz)) {</span>
      try {
<span class="nc" id="L589">        return (E) IOUtils.getBufferedReaderFromClasspathOrFileSystem(value);</span>
<span class="nc" id="L590">      } catch (IOException e) {</span>
<span class="nc" id="L591">        throw new RuntimeIOException(e);</span>
      }
<span class="pc bpc" id="L593" title="1 of 2 branches missed.">    } else if (FileReader.class.isAssignableFrom(clazz)) {</span>
      try {
<span class="nc" id="L595">        return (E) new FileReader(new File(value));</span>
<span class="nc" id="L596">      } catch (IOException e) {</span>
<span class="nc" id="L597">        throw new RuntimeIOException(e);</span>
      }
<span class="fc bfc" id="L599" title="All 2 branches covered.">    } else if (File.class.isAssignableFrom(clazz)) {</span>
<span class="fc" id="L600">      return (E) new File(value);</span>
<span class="pc bpc" id="L601" title="1 of 2 branches missed.">    } else if (Class.class.isAssignableFrom(clazz)) {</span>
      try {
<span class="nc" id="L603">        return (E) Class.forName(value);</span>
<span class="nc" id="L604">      } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L605">        return null;</span>
      }
<span class="fc bfc" id="L607" title="All 2 branches covered.">    } else if (clazz.isArray()) {</span>
<span class="pc bpc" id="L608" title="1 of 2 branches missed.">      if (value == null) { return null; }</span>
<span class="fc" id="L609">      Class &lt;?&gt; subType = clazz.getComponentType();</span>
      // (case: array)
<span class="fc" id="L611">      String[] strings = StringUtils.decodeArray(value);</span>
<span class="fc" id="L612">      Object[] array = (Object[]) Array.newInstance(clazz.getComponentType(), strings.length);</span>
<span class="fc bfc" id="L613" title="All 2 branches covered.">      for(int i=0; i&lt;strings.length; i++){</span>
<span class="fc" id="L614">        array[i] = cast(strings[i], subType);</span>
      }
<span class="fc" id="L616">      return (E) array;</span>
<span class="fc bfc" id="L617" title="All 2 branches covered.">    } else if (Map.class.isAssignableFrom(clazz)) {</span>
<span class="fc" id="L618">      return (E) StringUtils.decodeMap(value);</span>
<span class="fc bfc" id="L619" title="All 2 branches covered.">    } else if (clazz.isEnum()) {</span>
      // (case: enumeration)
<span class="fc" id="L621">      Class c = (Class) clazz;</span>
<span class="pc bpc" id="L622" title="1 of 2 branches missed.">      if(value == null){ return null; }</span>
<span class="pc bpc" id="L623" title="1 of 2 branches missed.">      if (value.charAt(0) == '&quot;') value = value.substring(1);</span>
<span class="pc bpc" id="L624" title="1 of 2 branches missed.">      if (value.charAt(value.length()-1) == '&quot;') value = value.substring(0, value.length() - 1);</span>
      try {
<span class="fc" id="L626">        return (E) Enum.valueOf(c, value);</span>
<span class="fc" id="L627">      } catch (Exception e){</span>
        try {
<span class="fc" id="L629">          return (E) Enum.valueOf(c, value.toLowerCase());</span>
<span class="fc" id="L630">        } catch (Exception e2){</span>
          try {
<span class="fc" id="L632">            return (E) Enum.valueOf(c, value.toUpperCase());</span>
<span class="fc" id="L633">          } catch (Exception e3){</span>
<span class="fc" id="L634">            return (E) Enum.valueOf(c,</span>
<span class="pc bpc" id="L635" title="1 of 2 branches missed.">                (Character.isUpperCase(value.charAt(0)) ? Character.toLowerCase(value.charAt(0)) : Character.toUpperCase(value.charAt(0))) +</span>
<span class="fc" id="L636">                    value.substring(1));</span>
          }
        }
      }
<span class="fc bfc" id="L640" title="All 2 branches covered.">    } else if (ObjectOutputStream.class.isAssignableFrom(clazz)) {</span>
      // (case: object output stream)
      try {
<span class="fc" id="L643">        return (E) new ObjectOutputStream((OutputStream) cast(value, OutputStream.class));</span>
<span class="nc" id="L644">      } catch (IOException e) {</span>
<span class="nc" id="L645">        throw new RuntimeException(e);</span>
      }
<span class="pc bpc" id="L647" title="1 of 2 branches missed.">    } else if (ObjectInputStream.class.isAssignableFrom(clazz)) {</span>
      // (case: object input stream)
      try {
<span class="nc" id="L650">        return (E) new ObjectInputStream((InputStream) cast(value, InputStream.class));</span>
<span class="nc" id="L651">      } catch (IOException e) {</span>
<span class="nc" id="L652">        throw new RuntimeException(e);</span>
      }
<span class="pc bpc" id="L654" title="1 of 2 branches missed.">    } else if (PrintStream.class.isAssignableFrom(clazz)) {</span>
      // (case: input stream)
<span class="nc bnc" id="L656" title="All 4 branches missed.">      if (value.equalsIgnoreCase(&quot;stdout&quot;) || value.equalsIgnoreCase(&quot;out&quot;)) { return (E) System.out; }</span>
<span class="nc bnc" id="L657" title="All 4 branches missed.">      if (value.equalsIgnoreCase(&quot;stderr&quot;) || value.equalsIgnoreCase(&quot;err&quot;)) { return (E) System.err; }</span>
      try {
<span class="nc" id="L659">        return (E) new PrintStream(new FileOutputStream(value));</span>
<span class="nc" id="L660">      } catch (IOException e) {</span>
<span class="nc" id="L661">        throw new RuntimeException(e);</span>
      }
<span class="pc bpc" id="L663" title="1 of 2 branches missed.">    } else if (PrintWriter.class.isAssignableFrom(clazz)) {</span>
      // (case: input stream)
<span class="nc bnc" id="L665" title="All 4 branches missed.">      if (value.equalsIgnoreCase(&quot;stdout&quot;) || value.equalsIgnoreCase(&quot;out&quot;)) { return (E) new PrintWriter(System.out); }</span>
<span class="nc bnc" id="L666" title="All 4 branches missed.">      if (value.equalsIgnoreCase(&quot;stderr&quot;) || value.equalsIgnoreCase(&quot;err&quot;)) { return (E) new PrintWriter(System.err); }</span>
      try {
<span class="nc" id="L668">        return (E) IOUtils.getPrintWriter(value);</span>
<span class="nc" id="L669">      } catch (IOException e) {</span>
<span class="nc" id="L670">        throw new RuntimeException(e);</span>
      }
<span class="fc bfc" id="L672" title="All 2 branches covered.">    } else if (OutputStream.class.isAssignableFrom(clazz)) {</span>
      // (case: output stream)
<span class="fc bfc" id="L674" title="All 4 branches covered.">      if (value.equalsIgnoreCase(&quot;stdout&quot;) || value.equalsIgnoreCase(&quot;out&quot;)) { return (E) System.out; }</span>
<span class="pc bpc" id="L675" title="1 of 4 branches missed.">      if (value.equalsIgnoreCase(&quot;stderr&quot;) || value.equalsIgnoreCase(&quot;err&quot;)) { return (E) System.err; }</span>
<span class="nc" id="L676">      File toWriteTo = cast(value, File.class);</span>
      try {
<span class="nc bnc" id="L678" title="All 6 branches missed.">        if (toWriteTo == null || (!toWriteTo.exists() &amp;&amp; !toWriteTo.createNewFile())) {</span>
<span class="nc" id="L679">          throw new IllegalStateException(&quot;Could not create output stream (cannot write file): &quot; + value);</span>
        }
<span class="nc" id="L681">        return (E) IOUtils.getFileOutputStream(value);</span>
<span class="nc" id="L682">      } catch (IOException e) {</span>
<span class="nc" id="L683">        throw new RuntimeException(e);</span>
      }
<span class="pc bpc" id="L685" title="1 of 2 branches missed.">    } else if (InputStream.class.isAssignableFrom(clazz)) {</span>
      // (case: input stream)
<span class="nc bnc" id="L687" title="All 4 branches missed.">      if (value.equalsIgnoreCase(&quot;stdin&quot;) || value.equalsIgnoreCase(&quot;in&quot;)) { return (E) System.in; }</span>
      try {
<span class="nc" id="L689">        return (E) IOUtils.getInputStreamFromURLOrClasspathOrFileSystem(value);</span>
<span class="nc" id="L690">      } catch (IOException e) {</span>
<span class="nc" id="L691">        throw new RuntimeException(e);</span>
      }
    } else {
      try {
        // (case: can parse from string)
<span class="fc" id="L696">        Method decode = clazz.getMethod(&quot;fromString&quot;, String.class);</span>
<span class="fc" id="L697">        return (E) decode.invoke(MetaClass.create(clazz), value);</span>
<span class="fc" id="L698">      } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException | ClassCastException e) {</span>
        // Silent errors for misc failures
      }

      // Pass 2: Guess what the object could be
<span class="pc bpc" id="L703" title="1 of 2 branches missed.">      if (Tree.class.isAssignableFrom(clazz)) {</span>
        // (case: reading a tree)
        try {
<span class="nc" id="L706">          return (E) new PennTreeReader(new StringReader(value), new LabeledScoredTreeFactory(CoreLabel.factory())).readTree();</span>
<span class="nc" id="L707">        } catch (IOException e) {</span>
<span class="nc" id="L708">          throw new RuntimeException(e);</span>
        }
<span class="pc bpc" id="L710" title="1 of 2 branches missed.">      } else if (Collection.class.isAssignableFrom(clazz)) {</span>
        // (case: reading a collection)
        Collection rtn;
<span class="pc bpc" id="L713" title="1 of 2 branches missed.">        if (Modifier.isAbstract(clazz.getModifiers())) {</span>
<span class="fc" id="L714">          rtn = abstractToConcreteCollectionMap.get(clazz).createInstance();</span>
        } else {
<span class="nc" id="L716">          rtn = MetaClass.create(clazz).createInstance();</span>
        }
<span class="fc" id="L718">        Class &lt;?&gt; subType = clazz.getComponentType();</span>
<span class="fc" id="L719">        String[] strings = StringUtils.decodeArray(value);</span>
<span class="fc bfc" id="L720" title="All 2 branches covered.">        for (String string : strings) {</span>
<span class="pc bpc" id="L721" title="1 of 2 branches missed.">          if (subType == null) {</span>
<span class="fc" id="L722">            rtn.add(castWithoutKnowingType(string));</span>
          } else {
<span class="nc" id="L724">            rtn.add(cast(string, subType));</span>
          }
        }
<span class="fc" id="L727">        return (E) rtn;</span>
      } else {
        // We could not cast this object
<span class="nc" id="L730">        return null;</span>
      }
    }
  }

  public static &lt;E&gt; E castWithoutKnowingType(String value){
<span class="fc" id="L736">    Class[] typesToTry = new Class[]{</span>
      Integer.class, Double.class,
      File.class, Date.class, List.class, Set.class, Queue.class,
      Integer[].class, Double[].class, Character[].class,
      String.class
    };
<span class="pc bpc" id="L742" title="1 of 2 branches missed.">    for (Class toTry : typesToTry) {</span>
<span class="pc bpc" id="L743" title="2 of 6 branches missed.">      if (Collection.class.isAssignableFrom(toTry) &amp;&amp; !value.contains(&quot;,&quot;) || value.contains(&quot; &quot;)) { continue; }</span>
      //noinspection EmptyCatchBlock
      try {
        Object rtn;
<span class="fc bfc" id="L747" title="All 2 branches covered.">        if ((rtn = cast(value, toTry)) != null &amp;&amp;</span>
<span class="pc bpc" id="L748" title="1 of 4 branches missed.">            (!File.class.isAssignableFrom(rtn.getClass()) || ((File) rtn).exists())) {</span>
<span class="fc" id="L749">          return ErasureUtils.uncheckedCast(rtn);</span>
        }
<span class="fc" id="L751">      } catch (NumberFormatException e) { }</span>
    }
<span class="nc" id="L753">    return null;</span>
  }

  private static &lt;E&gt; E argmin(E[] elems, int[] scores, int atLeast) {
<span class="fc" id="L757">    int argmin = argmin(scores, atLeast);</span>
<span class="fc bfc" id="L758" title="All 2 branches covered.">    return argmin &gt;= 0 ? elems[argmin] : null;</span>
  }

  private static int argmin(int[] scores, int atLeast) {
<span class="fc" id="L762">    int min = Integer.MAX_VALUE;</span>
<span class="fc" id="L763">    int argmin = -1;</span>
<span class="fc bfc" id="L764" title="All 2 branches covered.">    for(int i=0; i&lt;scores.length; i++){</span>
<span class="fc bfc" id="L765" title="All 4 branches covered.">      if(scores[i] &lt; min &amp;&amp; scores[i] &gt;= atLeast){</span>
<span class="fc" id="L766">        min = scores[i];</span>
<span class="fc" id="L767">        argmin = i;</span>
      }
    }
<span class="fc" id="L770">    return argmin;</span>
  }

<span class="fc" id="L773">  private static final HashMap&lt;Class, MetaClass&gt; abstractToConcreteCollectionMap = new HashMap&lt;&gt;();</span>
  static {
<span class="fc" id="L775">    abstractToConcreteCollectionMap.put(Collection.class, MetaClass.create(ArrayList.class));</span>
<span class="fc" id="L776">    abstractToConcreteCollectionMap.put(List.class, MetaClass.create(ArrayList.class));</span>
<span class="fc" id="L777">    abstractToConcreteCollectionMap.put(Set.class, MetaClass.create(HashSet.class));</span>
<span class="fc" id="L778">    abstractToConcreteCollectionMap.put(Queue.class, MetaClass.create(LinkedList.class));</span>
<span class="fc" id="L779">    abstractToConcreteCollectionMap.put(Deque.class, MetaClass.create(LinkedList.class));</span>
<span class="fc" id="L780">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>