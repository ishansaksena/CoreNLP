<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>XMLUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.util</a> &gt; <span class="el_source">XMLUtils.java</span></div><h1>XMLUtils.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.util;

import java.io.*;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.xml.XMLConstants;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.validation.Schema;
import javax.xml.validation.SchemaFactory;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;
import org.xml.sax.ErrorHandler;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;

import edu.stanford.nlp.io.IOUtils;
import edu.stanford.nlp.util.logging.Redwood;


/**
 * Provides some utilities for dealing with XML files, both by properly
 * parsing them and by using the methods of a desperate Perl hacker.
 *
 * @author Teg Grenager
 * @author Grace Muzny
 */
public class XMLUtils  {

  /** A logger for this class */
<span class="fc" id="L38">  private static Redwood.RedwoodChannels log = Redwood.channels(XMLUtils.class);</span>

<span class="nc" id="L40">  private XMLUtils() {} // only static methods</span>

  /**
   * Returns the text content of all nodes in the given file with the given tag.
   *
   * @return List of String text contents of tags.
   */
  public static List&lt;String&gt; getTextContentFromTagsFromFile(File f, String tag) {
<span class="nc" id="L48">    List&lt;String&gt; sents = Generics.newArrayList();</span>
    try {
<span class="nc" id="L50">      sents = getTextContentFromTagsFromFileSAXException(f, tag);</span>
<span class="nc" id="L51">    } catch (SAXException e) {</span>
<span class="nc" id="L52">      log.info(e);</span>
<span class="nc" id="L53">    }</span>
<span class="nc" id="L54">    return sents;</span>
  }

  /**
   * Returns the text content of all nodes in the given file with the given tag.
   * If the text contents contains embedded tags, strips the embedded tags out
   * of the returned text. e.g. &lt;s&gt;This is a &lt;s&gt;sentence&lt;/s&gt; with embedded tags
   * &lt;/s&gt; would return the list containing [&quot;This is a sentence with embedded
   * tags&quot;, &quot;sentence&quot;].
   *
   * @throws SAXException if tag doesn't exist in the file.
   * @return List of String text contents of tags.
   */
  private static List&lt;String&gt; getTextContentFromTagsFromFileSAXException(
          File f, String tag) throws SAXException {
<span class="nc" id="L69">    List&lt;String&gt; sents = Generics.newArrayList();</span>
    try {
<span class="nc" id="L71">      DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span>
<span class="nc" id="L72">      DocumentBuilder db = dbf.newDocumentBuilder();</span>
<span class="nc" id="L73">      Document doc = db.parse(f);</span>
<span class="nc" id="L74">      doc.getDocumentElement().normalize();</span>

<span class="nc" id="L76">      NodeList nodeList=doc.getElementsByTagName(tag);</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">      for (int i = 0; i &lt; nodeList.getLength(); i++) {</span>
        // Get element
<span class="nc" id="L79">        Element element = (Element)nodeList.item(i);</span>
<span class="nc" id="L80">        String raw = element.getTextContent();</span>
<span class="nc" id="L81">        StringBuilder builtUp = new StringBuilder();</span>
<span class="nc" id="L82">        boolean inTag = false;</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">        for (int j = 0; j &lt; raw.length(); j++) {</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">          if (raw.charAt(j) == '&lt;') {</span>
<span class="nc" id="L85">            inTag = true;</span>
          }
<span class="nc bnc" id="L87" title="All 2 branches missed.">          if (!inTag) {</span>
<span class="nc" id="L88">            builtUp.append(raw.charAt(j));</span>
          }
<span class="nc bnc" id="L90" title="All 2 branches missed.">          if (raw.charAt(j) == '&gt;') {</span>
<span class="nc" id="L91">            inTag = false;</span>
          }
        }
<span class="nc" id="L94">        sents.add(builtUp.toString());</span>
      }
<span class="nc" id="L96">    } catch (IOException | ParserConfigurationException e) {</span>
<span class="nc" id="L97">      log.info(e);</span>
<span class="nc" id="L98">    }</span>
<span class="nc" id="L99">    return sents;</span>
  }


  /**
   * Returns the text content of all nodes in the given file with the given tag.
   *
   * @return List of String text contents of tags.
   */
  public static List&lt;Element&gt; getTagElementsFromFile(File f, String tag) {
<span class="nc" id="L109">    List&lt;Element&gt; sents = Generics.newArrayList();</span>
    try {
<span class="nc" id="L111">      sents = getTagElementsFromFileSAXException(f, tag);</span>
<span class="nc" id="L112">    } catch (SAXException e) {</span>
<span class="nc" id="L113">      log.info(e);</span>
<span class="nc" id="L114">    }</span>
<span class="nc" id="L115">    return sents;</span>
  }

  /**
   * Returns the text content of all nodes in the given file with the given tag.
   * If the text contents contains embedded tags, strips the embedded tags out
   * of the returned text. e.g. &lt;s&gt;This is a &lt;s&gt;sentence&lt;/s&gt; with embedded tags
   * &lt;/s&gt; would return the list containing [&quot;This is a sentence with embedded
   * tags&quot;, &quot;sentence&quot;].
   *
   * @throws SAXException if tag doesn't exist in the file.
   * @return List of String text contents of tags.
   */
  private static List&lt;Element&gt; getTagElementsFromFileSAXException(
          File f, String tag) throws SAXException {
<span class="nc" id="L130">    List&lt;Element&gt; sents = Generics.newArrayList();</span>
    try {
<span class="nc" id="L132">      DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span>
<span class="nc" id="L133">      DocumentBuilder db = dbf.newDocumentBuilder();</span>
<span class="nc" id="L134">      Document doc = db.parse(f);</span>
<span class="nc" id="L135">      doc.getDocumentElement().normalize();</span>

<span class="nc" id="L137">      NodeList nodeList=doc.getElementsByTagName(tag);</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">      for (int i = 0; i &lt; nodeList.getLength(); i++) {</span>
        // Get element
<span class="nc" id="L140">        Element element = (Element)nodeList.item(i);</span>
<span class="nc" id="L141">        sents.add(element);</span>
      }
<span class="nc" id="L143">    } catch (IOException | ParserConfigurationException e) {</span>
<span class="nc" id="L144">      log.info(e);</span>
<span class="nc" id="L145">    }</span>
<span class="nc" id="L146">    return sents;</span>
  }

  /**
   * Returns the elements in the given file with the given tag associated with
   * the text content of the two previous siblings and two next siblings.
   *
   * @return List of {@code Triple&lt;String, Element, String&gt;} Targeted elements surrounded
   * by the text content of the two previous siblings and two next siblings.
   */
  public static List&lt;Triple&lt;String, Element, String&gt;&gt; getTagElementTriplesFromFile(File f, String tag) {
<span class="nc" id="L157">    List&lt;Triple&lt;String, Element, String&gt;&gt; sents = Generics.newArrayList();</span>
    try {
<span class="nc" id="L159">      sents = getTagElementTriplesFromFileSAXException(f, tag);</span>
<span class="nc" id="L160">    } catch (SAXException e) {</span>
<span class="nc" id="L161">      System.err.println(e);</span>
<span class="nc" id="L162">    }</span>
<span class="nc" id="L163">    return sents;</span>
  }

  /**
   * Returns the elements in the given file with the given tag associated with
   * the text content of the previous and next siblings up to max numIncludedSiblings.
   *
   * @return List of Triple&lt;String, Element, String&gt; Targeted elements surrounded
   * by the text content of the two previous siblings and two next siblings.
   */
  public static List&lt;Triple&lt;String, Element, String&gt;&gt; getTagElementTriplesFromFileNumBounded(File f,
                                                                                             String tag,
                                                                                             int num) {
<span class="nc" id="L176">    List&lt;Triple&lt;String, Element, String&gt;&gt; sents = Generics.newArrayList();</span>
    try {
<span class="nc" id="L178">      sents = getTagElementTriplesFromFileNumBoundedSAXException(f, tag, num);</span>
<span class="nc" id="L179">    } catch (SAXException e) {</span>
<span class="nc" id="L180">      System.err.println(e);</span>
<span class="nc" id="L181">    }</span>
<span class="nc" id="L182">    return sents;</span>
  }

  /**
   * Returns the elements in the given file with the given tag associated with
   * the text content of the two previous siblings and two next siblings.
   *
   * @throws SAXException if tag doesn't exist in the file.
   * @return List of {@code Triple&lt;String, Element, String&gt;} Targeted elements surrounded
   * by the text content of the two previous siblings and two next siblings.
   */
  public static List&lt;Triple&lt;String, Element, String&gt;&gt; getTagElementTriplesFromFileSAXException(
      File f, String tag) throws SAXException {
<span class="nc" id="L195">    return  getTagElementTriplesFromFileNumBoundedSAXException(f, tag, 2);</span>
  }

  /**
   * Returns the elements in the given file with the given tag associated with
   * the text content of the previous and next siblings up to max numIncludedSiblings.
   *
   * @throws SAXException if tag doesn't exist in the file.
   * @return List of Triple&lt;String, Element, String&gt; Targeted elements surrounded
   * by the text content of the two previous siblings and two next siblings.
   */
  public static List&lt;Triple&lt;String, Element, String&gt;&gt; getTagElementTriplesFromFileNumBoundedSAXException(
      File f, String tag, int numIncludedSiblings) throws SAXException {
<span class="nc" id="L208">    List&lt;Triple&lt;String, Element, String&gt;&gt; sents = Generics.newArrayList();</span>
    try {
<span class="nc" id="L210">      DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span>
<span class="nc" id="L211">      DocumentBuilder db = dbf.newDocumentBuilder();</span>
<span class="nc" id="L212">      Document doc = db.parse(f);</span>
<span class="nc" id="L213">      doc.getDocumentElement().normalize();</span>

<span class="nc" id="L215">      NodeList nodeList=doc.getElementsByTagName(tag);</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">      for (int i = 0; i &lt; nodeList.getLength(); i++) {</span>
        // Get element
<span class="nc" id="L218">        Node prevNode = nodeList.item(i).getPreviousSibling();</span>
<span class="nc" id="L219">        String prev = &quot;&quot;;</span>
<span class="nc" id="L220">        int count = 0;</span>
<span class="nc bnc" id="L221" title="All 4 branches missed.">        while (prevNode != null &amp;&amp; count &lt;= numIncludedSiblings) {</span>
<span class="nc" id="L222">          prev = prevNode.getTextContent() + prev;</span>
<span class="nc" id="L223">          prevNode = prevNode.getPreviousSibling();</span>
<span class="nc" id="L224">          count++;</span>
        }

<span class="nc" id="L227">        Node nextNode = nodeList.item(i).getNextSibling();</span>
<span class="nc" id="L228">        String next = &quot;&quot;;</span>
<span class="nc" id="L229">        count = 0;</span>
<span class="nc bnc" id="L230" title="All 4 branches missed.">        while (nextNode != null &amp;&amp; count &lt;= numIncludedSiblings) {</span>
<span class="nc" id="L231">          next = next + nextNode.getTextContent();</span>
<span class="nc" id="L232">          nextNode = nextNode.getNextSibling();</span>
<span class="nc" id="L233">          count++;</span>
        }
<span class="nc" id="L235">        Element element = (Element)nodeList.item(i);</span>
<span class="nc" id="L236">        Triple&lt;String, Element, String&gt; t = new Triple&lt;&gt;(prev, element, next);</span>
<span class="nc" id="L237">        sents.add(t);</span>
      }
<span class="nc" id="L239">    } catch (IOException | ParserConfigurationException e) {</span>
<span class="nc" id="L240">      System.err.println(e);</span>
<span class="nc" id="L241">    }</span>
<span class="nc" id="L242">    return sents;</span>
  }


  /**
   * Returns a non-validating XML parser. The parser ignores both DTDs and XSDs.
   *
   * @return An XML parser in the form of a DocumentBuilder
   */
  public static DocumentBuilder getXmlParser() {
<span class="nc" id="L252">    DocumentBuilder db = null;</span>
    try {
<span class="nc" id="L254">      DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span>
<span class="nc" id="L255">      dbf.setValidating(false);</span>

      //Disable DTD loading and validation
      //See http://stackoverflow.com/questions/155101/make-documentbuilder-parse-ignore-dtd-references
<span class="nc" id="L259">      dbf.setFeature(&quot;http://apache.org/xml/features/nonvalidating/load-dtd-grammar&quot;, false);</span>
<span class="nc" id="L260">      dbf.setFeature(&quot;http://apache.org/xml/features/nonvalidating/load-external-dtd&quot;, false);</span>

<span class="nc" id="L262">      db = dbf.newDocumentBuilder();</span>
<span class="nc" id="L263">      db.setErrorHandler(new SAXErrorHandler());</span>

<span class="nc" id="L265">    } catch (ParserConfigurationException e) {</span>
<span class="nc" id="L266">      System.err.printf(&quot;%s: Unable to create XML parser\n&quot;, XMLUtils.class.getName());</span>
<span class="nc" id="L267">      e.printStackTrace();</span>

<span class="nc" id="L269">    } catch(UnsupportedOperationException e) {</span>
<span class="nc" id="L270">      System.err.printf(&quot;%s: API error while setting up XML parser. Check your JAXP version\n&quot;, XMLUtils.class.getName());</span>
<span class="nc" id="L271">      e.printStackTrace();</span>
<span class="nc" id="L272">    }</span>

<span class="nc" id="L274">    return db;</span>
  }

  /**
   * Returns a validating XML parser given an XSD (not DTD!).
   *
   * @param schemaFile File wit hXML schema
   * @return An XML parser in the form of a DocumentBuilder
   */
  public static DocumentBuilder getValidatingXmlParser(File schemaFile) {
<span class="nc" id="L284">    DocumentBuilder db = null;</span>
    try {
<span class="nc" id="L286">      DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span>

<span class="nc" id="L288">      SchemaFactory factory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);</span>
<span class="nc" id="L289">      Schema schema = factory.newSchema(schemaFile);</span>
<span class="nc" id="L290">      dbf.setSchema(schema);</span>

<span class="nc" id="L292">      db = dbf.newDocumentBuilder();</span>
<span class="nc" id="L293">      db.setErrorHandler(new SAXErrorHandler());</span>

<span class="nc" id="L295">    } catch (ParserConfigurationException e) {</span>
<span class="nc" id="L296">      System.err.printf(&quot;%s: Unable to create XML parser\n&quot;, XMLUtils.class.getName());</span>
<span class="nc" id="L297">      e.printStackTrace();</span>

<span class="nc" id="L299">    } catch (SAXException e) {</span>
<span class="nc" id="L300">      System.err.printf(&quot;%s: XML parsing exception while loading schema %s\n&quot;, XMLUtils.class.getName(),schemaFile.getPath());</span>
<span class="nc" id="L301">      e.printStackTrace();</span>

<span class="nc" id="L303">    } catch(UnsupportedOperationException e) {</span>
<span class="nc" id="L304">      System.err.printf(&quot;%s: API error while setting up XML parser. Check your JAXP version\n&quot;, XMLUtils.class.getName());</span>
<span class="nc" id="L305">      e.printStackTrace();</span>
<span class="nc" id="L306">    }</span>

<span class="nc" id="L308">    return db;</span>
  }

  /**
   * Block-level HTML tags that are rendered with surrounding line breaks.
   */
<span class="fc" id="L314">  private static final Set&lt;String&gt; breakingTags = Generics.newHashSet(Arrays.asList(new String[] {&quot;blockquote&quot;, &quot;br&quot;, &quot;div&quot;, &quot;h1&quot;, &quot;h2&quot;, &quot;h3&quot;, &quot;h4&quot;, &quot;h5&quot;, &quot;h6&quot;, &quot;hr&quot;, &quot;li&quot;, &quot;ol&quot;, &quot;p&quot;, &quot;pre&quot;, &quot;ul&quot;, &quot;tr&quot;, &quot;td&quot;}));</span>

  /**
   * @param r       the reader to read the XML/HTML from
   * @param mapBack a List of Integers mapping the positions in the result buffer
   *                to positions in the original Reader, will be cleared on receipt
   * @return the String containing the resulting text
   */
  public static String stripTags(Reader r, List&lt;Integer&gt; mapBack, boolean markLineBreaks) {
<span class="pc bpc" id="L323" title="1 of 2 branches missed.">    if (mapBack != null) {</span>
<span class="nc" id="L324">      mapBack.clear(); // just in case it has something in it!</span>
    }
<span class="fc" id="L326">    StringBuilder result = new StringBuilder();</span>
    try {
<span class="fc" id="L328">      int position = 0;</span>
      do {
<span class="fc" id="L330">        String text = XMLUtils.readUntilTag(r);</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">        if (text.length() &gt; 0) {</span>
          // add offsets to the map back
<span class="fc bfc" id="L333" title="All 2 branches covered.">          for (int i = 0; i &lt; text.length(); i++) {</span>
<span class="fc" id="L334">            result.append(text.charAt(i));</span>
<span class="pc bpc" id="L335" title="1 of 2 branches missed.">            if (mapBack != null) {</span>
<span class="nc" id="L336">              mapBack.add(Integer.valueOf(position + i));</span>
            }
          }
<span class="fc" id="L339">          position += text.length();</span>
        }
        //        System.out.println(position + &quot; got text: &quot; + text);
<span class="fc" id="L342">        String tag = XMLUtils.readTag(r);</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">        if (tag == null) {</span>
<span class="fc" id="L344">          break;</span>
        }
<span class="fc bfc" id="L346" title="All 4 branches covered.">        if (markLineBreaks &amp;&amp; XMLUtils.isBreaking(parseTag(tag))) {</span>
<span class="fc" id="L347">          result.append(&quot;\n&quot;);</span>
<span class="pc bpc" id="L348" title="1 of 2 branches missed.">          if (mapBack != null) {</span>
<span class="nc" id="L349">            mapBack.add(Integer.valueOf(-position));</span>
          }
        }
<span class="fc" id="L352">        position += tag.length();</span>
        //        System.out.println(position + &quot; got tag: &quot; + tag);
<span class="fc" id="L354">      } while (true);</span>
<span class="nc" id="L355">    } catch (IOException e) {</span>
<span class="nc" id="L356">      log.info(&quot;Error reading string&quot;);</span>
<span class="nc" id="L357">      e.printStackTrace();</span>
<span class="fc" id="L358">    }</span>
<span class="fc" id="L359">    return result.toString();</span>
  }

  public static boolean isBreaking(String tag) {
<span class="nc" id="L363">    return breakingTags.contains(tag);</span>
  }

  public static boolean isBreaking(XMLTag tag) {
<span class="fc" id="L367">    return breakingTags.contains(tag.name);</span>
  }

  /**
   * Reads all text up to next XML tag and returns it as a String.
   *
   * @return the String of the text read, which may be empty.
   */
  public static String readUntilTag(Reader r) throws IOException {
<span class="pc bpc" id="L376" title="1 of 2 branches missed.">    if (!r.ready()) {</span>
<span class="nc" id="L377">      return &quot;&quot;;</span>
    }
<span class="fc" id="L379">    StringBuilder b = new StringBuilder();</span>
<span class="fc" id="L380">    int c = r.read();</span>
<span class="fc bfc" id="L381" title="All 4 branches covered.">    while (c &gt;= 0 &amp;&amp; c != '&lt;') {</span>
<span class="fc" id="L382">      b.append((char) c);</span>
<span class="fc" id="L383">      c = r.read();</span>
    }
<span class="fc" id="L385">    return b.toString();</span>
  }

  /**
   * @return the new XMLTag object, or null if couldn't be created
   */
  public static XMLTag readAndParseTag(Reader r) throws IOException {
<span class="fc" id="L392">    String s = readTag(r);</span>
<span class="fc bfc" id="L393" title="All 2 branches covered.">    if (s == null) {</span>
<span class="fc" id="L394">      return null;</span>
    }
<span class="fc" id="L396">    XMLTag ret = null;</span>
    try {
<span class="fc" id="L398">      ret = new XMLTag(s);</span>
<span class="nc" id="L399">    } catch (Exception e) {</span>
<span class="nc" id="L400">      log.info(&quot;Failed to handle |&quot; + s + &quot;|&quot;);</span>
<span class="fc" id="L401">    }</span>
<span class="fc" id="L402">    return ret;</span>
  }

  // Pattern is reentrant, going by the statement
  // &quot;many matchers can share the same pattern&quot;
  // on the Pattern javadoc.  Therefore, this should be
  // safe as a static final variable.
<span class="fc" id="L409">  private static final Pattern xmlEscapingPattern = Pattern.compile(&quot;\\&amp;.+?;&quot;);</span>

  public static String unescapeStringForXML(String s) {
<span class="fc" id="L412">    StringBuilder result = new StringBuilder();</span>
<span class="fc" id="L413">    Matcher m = xmlEscapingPattern.matcher(s);</span>
<span class="fc" id="L414">    int end = 0;</span>
<span class="pc bpc" id="L415" title="1 of 2 branches missed.">    while (m.find()) {</span>
<span class="nc" id="L416">      int start = m.start();</span>
<span class="nc" id="L417">      result.append(s.substring(end, start));</span>
<span class="nc" id="L418">      end = m.end();</span>
<span class="nc" id="L419">      result.append(translate(s.substring(start, end)));</span>
<span class="nc" id="L420">    }</span>
<span class="fc" id="L421">    result.append(s.substring(end, s.length()));</span>
<span class="fc" id="L422">    return result.toString();</span>
  }

  private static char translate(String s) {
<span class="nc bnc" id="L426" title="All 1072 branches missed.">    switch (s) {</span>
      case &quot;&amp;amp;&quot;:
<span class="nc" id="L428">        return '&amp;';</span>
      case &quot;&amp;lt;&quot;:
      case &quot;&amp;Lt;&quot;:
<span class="nc" id="L431">        return '&lt;';</span>
      case &quot;&amp;gt;&quot;:
      case &quot;&amp;Gt;&quot;:
<span class="nc" id="L434">        return '&gt;';</span>
      case &quot;&amp;quot;&quot;:
<span class="nc" id="L436">        return '\&quot;';</span>
      case &quot;&amp;apos;&quot;:
<span class="nc" id="L438">        return '\'';</span>
      case &quot;&amp;ast;&quot;:
      case &quot;&amp;sharp;&quot;:
<span class="nc" id="L441">        return '-';</span>
      case &quot;&amp;equals;&quot;:
<span class="nc" id="L443">        return '=';</span>
      case &quot;&amp;nbsp;&quot;:
<span class="nc" id="L445">        return (char) 0xA0;</span>
      case &quot;&amp;iexcl;&quot;:
<span class="nc" id="L447">        return (char) 0xA1;</span>
      case &quot;&amp;cent;&quot;:
      case &quot;&amp;shilling;&quot;:
<span class="nc" id="L450">        return (char) 0xA2;</span>
      case &quot;&amp;pound;&quot;:
<span class="nc" id="L452">        return (char) 0xA3;</span>
      case &quot;&amp;curren;&quot;:
<span class="nc" id="L454">        return (char) 0xA4;</span>
      case &quot;&amp;yen;&quot;:
<span class="nc" id="L456">        return (char) 0xA5;</span>
      case &quot;&amp;brvbar;&quot;:
<span class="nc" id="L458">        return (char) 0xA6;</span>
      case &quot;&amp;sect;&quot;:
<span class="nc" id="L460">        return (char) 0xA7;</span>
      case &quot;&amp;uml;&quot;:
<span class="nc" id="L462">        return (char) 0xA8;</span>
      case &quot;&amp;copy;&quot;:
<span class="nc" id="L464">        return (char) 0xA9;</span>
      case &quot;&amp;ordf;&quot;:
<span class="nc" id="L466">        return (char) 0xAA;</span>
      case &quot;&amp;laquo; &quot;:
<span class="nc" id="L468">        return (char) 0xAB;</span>
      case &quot;&amp;not;&quot;:
<span class="nc" id="L470">        return (char) 0xAC;</span>
      case &quot;&amp;shy; &quot;:
<span class="nc" id="L472">        return (char) 0xAD;</span>
      case &quot;&amp;reg;&quot;:
<span class="nc" id="L474">        return (char) 0xAE;</span>
      case &quot;&amp;macr;&quot;:
<span class="nc" id="L476">        return (char) 0xAF;</span>
      case &quot;&amp;deg;&quot;:
<span class="nc" id="L478">        return (char) 0xB0;</span>
      case &quot;&amp;plusmn;&quot;:
<span class="nc" id="L480">        return (char) 0xB1;</span>
      case &quot;&amp;sup2;&quot;:
<span class="nc" id="L482">        return (char) 0xB2;</span>
      case &quot;&amp;sup3;&quot;:
<span class="nc" id="L484">        return (char) 0xB3;</span>
      case &quot;&amp;acute;&quot;:
<span class="nc" id="L486">        return (char) 0xB4;</span>
      case &quot;&amp;micro;&quot;:
<span class="nc" id="L488">        return (char) 0xB5;</span>
      case &quot;&amp;middot;&quot;:
<span class="nc" id="L490">        return (char) 0xB7;</span>
      case &quot;&amp;cedil;&quot;:
<span class="nc" id="L492">        return (char) 0xB8;</span>
      case &quot;&amp;sup1;&quot;:
<span class="nc" id="L494">        return (char) 0xB9;</span>
      case &quot;&amp;ordm;&quot;:
<span class="nc" id="L496">        return (char) 0xBA;</span>
      case &quot;&amp;raquo;&quot;:
<span class="nc" id="L498">        return (char) 0xBB;</span>
      case &quot;&amp;frac14; &quot;:
<span class="nc" id="L500">        return (char) 0xBC;</span>
      case &quot;&amp;frac12;&quot;:
<span class="nc" id="L502">        return (char) 0xBD;</span>
      case &quot;&amp;frac34; &quot;:
<span class="nc" id="L504">        return (char) 0xBE;</span>
      case &quot;&amp;iquest;&quot;:
<span class="nc" id="L506">        return (char) 0xBF;</span>
      case &quot;&amp;Agrave;&quot;:
<span class="nc" id="L508">        return (char) 0xC0;</span>
      case &quot;&amp;Aacute;&quot;:
<span class="nc" id="L510">        return (char) 0xC1;</span>
      case &quot;&amp;Acirc;&quot;:
<span class="nc" id="L512">        return (char) 0xC2;</span>
      case &quot;&amp;Atilde;&quot;:
<span class="nc" id="L514">        return (char) 0xC3;</span>
      case &quot;&amp;Auml;&quot;:
<span class="nc" id="L516">        return (char) 0xC4;</span>
      case &quot;&amp;Aring;&quot;:
<span class="nc" id="L518">        return (char) 0xC5;</span>
      case &quot;&amp;AElig;&quot;:
<span class="nc" id="L520">        return (char) 0xC6;</span>
      case &quot;&amp;Ccedil;&quot;:
<span class="nc" id="L522">        return (char) 0xC7;</span>
      case &quot;&amp;Egrave;&quot;:
<span class="nc" id="L524">        return (char) 0xC8;</span>
      case &quot;&amp;Eacute;&quot;:
<span class="nc" id="L526">        return (char) 0xC9;</span>
      case &quot;&amp;Ecirc;&quot;:
<span class="nc" id="L528">        return (char) 0xCA;</span>
      case &quot;&amp;Euml;&quot;:
<span class="nc" id="L530">        return (char) 0xCB;</span>
      case &quot;&amp;Igrave;&quot;:
<span class="nc" id="L532">        return (char) 0xCC;</span>
      case &quot;&amp;Iacute;&quot;:
<span class="nc" id="L534">        return (char) 0xCD;</span>
      case &quot;&amp;Icirc;&quot;:
<span class="nc" id="L536">        return (char) 0xCE;</span>
      case &quot;&amp;Iuml;&quot;:
<span class="nc" id="L538">        return (char) 0xCF;</span>
      case &quot;&amp;ETH;&quot;:
<span class="nc" id="L540">        return (char) 0xD0;</span>
      case &quot;&amp;Ntilde;&quot;:
<span class="nc" id="L542">        return (char) 0xD1;</span>
      case &quot;&amp;Ograve;&quot;:
<span class="nc" id="L544">        return (char) 0xD2;</span>
      case &quot;&amp;Oacute;&quot;:
<span class="nc" id="L546">        return (char) 0xD3;</span>
      case &quot;&amp;Ocirc;&quot;:
<span class="nc" id="L548">        return (char) 0xD4;</span>
      case &quot;&amp;Otilde;&quot;:
<span class="nc" id="L550">        return (char) 0xD5;</span>
      case &quot;&amp;Ouml;&quot;:
<span class="nc" id="L552">        return (char) 0xD6;</span>
      case &quot;&amp;times;&quot;:
<span class="nc" id="L554">        return (char) 0xD7;</span>
      case &quot;&amp;Oslash;&quot;:
<span class="nc" id="L556">        return (char) 0xD8;</span>
      case &quot;&amp;Ugrave;&quot;:
<span class="nc" id="L558">        return (char) 0xD9;</span>
      case &quot;&amp;Uacute;&quot;:
<span class="nc" id="L560">        return (char) 0xDA;</span>
      case &quot;&amp;Ucirc;&quot;:
<span class="nc" id="L562">        return (char) 0xDB;</span>
      case &quot;&amp;Uuml;&quot;:
<span class="nc" id="L564">        return (char) 0xDC;</span>
      case &quot;&amp;Yacute;&quot;:
<span class="nc" id="L566">        return (char) 0xDD;</span>
      case &quot;&amp;THORN;&quot;:
<span class="nc" id="L568">        return (char) 0xDE;</span>
      case &quot;&amp;szlig;&quot;:
<span class="nc" id="L570">        return (char) 0xDF;</span>
      case &quot;&amp;agrave;&quot;:
<span class="nc" id="L572">        return (char) 0xE0;</span>
      case &quot;&amp;aacute;&quot;:
<span class="nc" id="L574">        return (char) 0xE1;</span>
      case &quot;&amp;acirc;&quot;:
<span class="nc" id="L576">        return (char) 0xE2;</span>
      case &quot;&amp;atilde;&quot;:
<span class="nc" id="L578">        return (char) 0xE3;</span>
      case &quot;&amp;auml;&quot;:
<span class="nc" id="L580">        return (char) 0xE4;</span>
      case &quot;&amp;aring;&quot;:
<span class="nc" id="L582">        return (char) 0xE5;</span>
      case &quot;&amp;aelig;&quot;:
<span class="nc" id="L584">        return (char) 0xE6;</span>
      case &quot;&amp;ccedil;&quot;:
<span class="nc" id="L586">        return (char) 0xE7;</span>
      case &quot;&amp;egrave;&quot;:
<span class="nc" id="L588">        return (char) 0xE8;</span>
      case &quot;&amp;eacute;&quot;:
<span class="nc" id="L590">        return (char) 0xE9;</span>
      case &quot;&amp;ecirc;&quot;:
<span class="nc" id="L592">        return (char) 0xEA;</span>
      case &quot;&amp;euml; &quot;:
<span class="nc" id="L594">        return (char) 0xEB;</span>
      case &quot;&amp;igrave;&quot;:
<span class="nc" id="L596">        return (char) 0xEC;</span>
      case &quot;&amp;iacute;&quot;:
<span class="nc" id="L598">        return (char) 0xED;</span>
      case &quot;&amp;icirc;&quot;:
<span class="nc" id="L600">        return (char) 0xEE;</span>
      case &quot;&amp;iuml;&quot;:
<span class="nc" id="L602">        return 0xEF;</span>
      case &quot;&amp;eth;&quot;:
<span class="nc" id="L604">        return (char) 0xF0;</span>
      case &quot;&amp;ntilde;&quot;:
<span class="nc" id="L606">        return (char) 0xF1;</span>
      case &quot;&amp;ograve;&quot;:
<span class="nc" id="L608">        return (char) 0xF2;</span>
      case &quot;&amp;oacute;&quot;:
<span class="nc" id="L610">        return (char) 0xF3;</span>
      case &quot;&amp;ocirc;&quot;:
<span class="nc" id="L612">        return (char) 0xF4;</span>
      case &quot;&amp;otilde;&quot;:
<span class="nc" id="L614">        return (char) 0xF5;</span>
      case &quot;&amp;ouml;&quot;:
<span class="nc" id="L616">        return (char) 0xF6;</span>
      case &quot;&amp;divide;&quot;:
<span class="nc" id="L618">        return (char) 0xF7;</span>
      case &quot;&amp;oslash;&quot;:
<span class="nc" id="L620">        return (char) 0xF8;</span>
      case &quot;&amp;ugrave;&quot;:
<span class="nc" id="L622">        return (char) 0xF9;</span>
      case &quot;&amp;uacute;&quot;:
<span class="nc" id="L624">        return (char) 0xFA;</span>
      case &quot;&amp;ucirc;&quot;:
<span class="nc" id="L626">        return (char) 0xFB;</span>
      case &quot;&amp;uuml;&quot;:
<span class="nc" id="L628">        return (char) 0xFC;</span>
      case &quot;&amp;yacute;&quot;:
<span class="nc" id="L630">        return (char) 0xFD;</span>
      case &quot;&amp;thorn;&quot;:
<span class="nc" id="L632">        return (char) 0xFE;</span>
      case &quot;&amp;yuml;&quot;:
<span class="nc" id="L634">        return (char) 0xFF;</span>
      case &quot;&amp;OElig;&quot;:
<span class="nc" id="L636">        return (char) 0x152;</span>
      case &quot;&amp;oelig;&quot;:
<span class="nc" id="L638">        return (char) 0x153;</span>
      case &quot;&amp;Scaron;&quot;:
<span class="nc" id="L640">        return (char) 0x160;</span>
      case &quot;&amp;scaron;&quot;:
<span class="nc" id="L642">        return (char) 0x161;</span>
      case &quot;&amp;Yuml;&quot;:
<span class="nc" id="L644">        return (char) 0x178;</span>
      case &quot;&amp;circ;&quot;:
<span class="nc" id="L646">        return (char) 0x2C6;</span>
      case &quot;&amp;tilde;&quot;:
<span class="nc" id="L648">        return (char) 0x2DC;</span>
      case &quot;&amp;lrm;&quot;:
<span class="nc" id="L650">        return (char) 0x200E;</span>
      case &quot;&amp;rlm;&quot;:
<span class="nc" id="L652">        return (char) 0x200F;</span>
      case &quot;&amp;ndash;&quot;:
<span class="nc" id="L654">        return (char) 0x2013;</span>
      case &quot;&amp;mdash;&quot;:
<span class="nc" id="L656">        return (char) 0x2014;</span>
      case &quot;&amp;lsquo;&quot;:
<span class="nc" id="L658">        return (char) 0x2018;</span>
      case &quot;&amp;rsquo;&quot;:
<span class="nc" id="L660">        return (char) 0x2019;</span>
      case &quot;&amp;sbquo;&quot;:
<span class="nc" id="L662">        return (char) 0x201A;</span>
      case &quot;&amp;ldquo;&quot;:
      case &quot;&amp;bquo;&quot;:
      case &quot;&amp;bq;&quot;:
<span class="nc" id="L666">        return (char) 0x201C;</span>
      case &quot;&amp;rdquo;&quot;:
      case &quot;&amp;equo;&quot;:
<span class="nc" id="L669">        return (char) 0X201D;</span>
      case &quot;&amp;bdquo;&quot;:
<span class="nc" id="L671">        return (char) 0x201E;</span>
      case &quot;&amp;sim;&quot;:
<span class="nc" id="L673">        return (char) 0x223C;</span>
      case &quot;&amp;radic;&quot;:
<span class="nc" id="L675">        return (char) 0x221A;</span>
      case &quot;&amp;le;&quot;:
<span class="nc" id="L677">        return (char) 0x2264;</span>
      case &quot;&amp;ge;&quot;:
<span class="nc" id="L679">        return (char) 0x2265;</span>
      case &quot;&amp;larr;&quot;:
<span class="nc" id="L681">        return (char) 0x2190;</span>
      case &quot;&amp;darr;&quot;:
<span class="nc" id="L683">        return (char) 0x2193;</span>
      case &quot;&amp;rarr;&quot;:
<span class="nc" id="L685">        return (char) 0x2192;</span>
      case &quot;&amp;hellip;&quot;:
<span class="nc" id="L687">        return (char) 0x2026;</span>
      case &quot;&amp;prime;&quot;:
<span class="nc" id="L689">        return (char) 0x2032;</span>
      case &quot;&amp;Prime;&quot;:
      case &quot;&amp;ins;&quot;:
<span class="nc" id="L692">        return (char) 0x2033;</span>
      case &quot;&amp;trade;&quot;:
<span class="nc" id="L694">        return (char) 0x2122;</span>
      case &quot;&amp;Alpha;&quot;:
      case &quot;&amp;Agr;&quot;:
<span class="nc" id="L697">        return (char) 0x391;</span>
      case &quot;&amp;Beta;&quot;:
      case &quot;&amp;Bgr;&quot;:
<span class="nc" id="L700">        return (char) 0x392;</span>
      case &quot;&amp;Gamma;&quot;:
      case &quot;&amp;Ggr;&quot;:
<span class="nc" id="L703">        return (char) 0x393;</span>
      case &quot;&amp;Delta;&quot;:
      case &quot;&amp;Dgr;&quot;:
<span class="nc" id="L706">        return (char) 0x394;</span>
      case &quot;&amp;Epsilon;&quot;:
      case &quot;&amp;Egr;&quot;:
<span class="nc" id="L709">        return (char) 0x395;</span>
      case &quot;&amp;Zeta;&quot;:
      case &quot;&amp;Zgr;&quot;:
<span class="nc" id="L712">        return (char) 0x396;</span>
      case &quot;&amp;Eta;&quot;:
<span class="nc" id="L714">        return (char) 0x397;</span>
      case &quot;&amp;Theta;&quot;:
      case &quot;&amp;THgr;&quot;:
<span class="nc" id="L717">        return (char) 0x398;</span>
      case &quot;&amp;Iota;&quot;:
      case &quot;&amp;Igr;&quot;:
<span class="nc" id="L720">        return (char) 0x399;</span>
      case &quot;&amp;Kappa;&quot;:
      case &quot;&amp;Kgr;&quot;:
<span class="nc" id="L723">        return (char) 0x39A;</span>
      case &quot;&amp;Lambda;&quot;:
      case &quot;&amp;Lgr;&quot;:
<span class="nc" id="L726">        return (char) 0x39B;</span>
      case &quot;&amp;Mu;&quot;:
      case &quot;&amp;Mgr;&quot;:
<span class="nc" id="L729">        return (char) 0x39C;</span>
      case &quot;&amp;Nu;&quot;:
      case &quot;&amp;Ngr;&quot;:
<span class="nc" id="L732">        return (char) 0x39D;</span>
      case &quot;&amp;Xi;&quot;:
      case &quot;&amp;Xgr;&quot;:
<span class="nc" id="L735">        return (char) 0x39E;</span>
      case &quot;&amp;Omicron;&quot;:
      case &quot;&amp;Ogr;&quot;:
<span class="nc" id="L738">        return (char) 0x39F;</span>
      case &quot;&amp;Pi;&quot;:
      case &quot;&amp;Pgr;&quot;:
<span class="nc" id="L741">        return (char) 0x3A0;</span>
      case &quot;&amp;Rho;&quot;:
      case &quot;&amp;Rgr;&quot;:
<span class="nc" id="L744">        return (char) 0x3A1;</span>
      case &quot;&amp;Sigma;&quot;:
      case &quot;&amp;Sgr;&quot;:
<span class="nc" id="L747">        return (char) 0x3A3;</span>
      case &quot;&amp;Tau;&quot;:
      case &quot;&amp;Tgr;&quot;:
<span class="nc" id="L750">        return (char) 0x3A4;</span>
      case &quot;&amp;Upsilon;&quot;:
      case &quot;&amp;Ugr;&quot;:
<span class="nc" id="L753">        return (char) 0x3A5;</span>
      case &quot;&amp;Phi;&quot;:
      case &quot;&amp;PHgr;&quot;:
<span class="nc" id="L756">        return (char) 0x3A6;</span>
      case &quot;&amp;Chi;&quot;:
      case &quot;&amp;KHgr;&quot;:
<span class="nc" id="L759">        return (char) 0x3A7;</span>
      case &quot;&amp;Psi;&quot;:
      case &quot;&amp;PSgr;&quot;:
<span class="nc" id="L762">        return (char) 0x3A8;</span>
      case &quot;&amp;Omega;&quot;:
      case &quot;&amp;OHgr;&quot;:
<span class="nc" id="L765">        return (char) 0x3A9;</span>
      case &quot;&amp;alpha;&quot;:
      case &quot;&amp;agr;&quot;:
<span class="nc" id="L768">        return (char) 0x3B1;</span>
      case &quot;&amp;beta;&quot;:
      case &quot;&amp;bgr;&quot;:
<span class="nc" id="L771">        return (char) 0x3B2;</span>
      case &quot;&amp;gamma;&quot;:
      case &quot;&amp;ggr;&quot;:
<span class="nc" id="L774">        return (char) 0x3B3;</span>
      case &quot;&amp;delta;&quot;:
      case &quot;&amp;dgr;&quot;:
<span class="nc" id="L777">        return (char) 0x3B4;</span>
      case &quot;&amp;epsilon;&quot;:
      case &quot;&amp;egr;&quot;:
<span class="nc" id="L780">        return (char) 0x3B5;</span>
      case &quot;&amp;zeta;&quot;:
      case &quot;&amp;zgr;&quot;:
<span class="nc" id="L783">        return (char) 0x3B6;</span>
      case &quot;&amp;eta;&quot;:
      case &quot;&amp;eegr;&quot;:
<span class="nc" id="L786">        return (char) 0x3B7;</span>
      case &quot;&amp;theta;&quot;:
      case &quot;&amp;thgr;&quot;:
<span class="nc" id="L789">        return (char) 0x3B8;</span>
      case &quot;&amp;iota;&quot;:
      case &quot;&amp;igr;&quot;:
<span class="nc" id="L792">        return (char) 0x3B9;</span>
      case &quot;&amp;kappa;&quot;:
      case &quot;&amp;kgr;&quot;:
<span class="nc" id="L795">        return (char) 0x3BA;</span>
      case &quot;&amp;lambda;&quot;:
      case &quot;&amp;lgr;&quot;:
<span class="nc" id="L798">        return (char) 0x3BB;</span>
      case &quot;&amp;mu;&quot;:
      case &quot;&amp;mgr;&quot;:
<span class="nc" id="L801">        return (char) 0x3BC;</span>
      case &quot;&amp;nu;&quot;:
      case &quot;&amp;ngr;&quot;:
<span class="nc" id="L804">        return (char) 0x3BD;</span>
      case &quot;&amp;xi;&quot;:
      case &quot;&amp;xgr;&quot;:
<span class="nc" id="L807">        return (char) 0x3BE;</span>
      case &quot;&amp;omicron;&quot;:
      case &quot;&amp;ogr;&quot;:
<span class="nc" id="L810">        return (char) 0x3BF;</span>
      case &quot;&amp;pi;&quot;:
      case &quot;&amp;pgr;&quot;:
<span class="nc" id="L813">        return (char) 0x3C0;</span>
      case &quot;&amp;rho;&quot;:
      case &quot;&amp;rgr;&quot;:
<span class="nc" id="L816">        return (char) 0x3C1;</span>
      case &quot;&amp;sigma;&quot;:
      case &quot;&amp;sgr;&quot;:
<span class="nc" id="L819">        return (char) 0x3C3;</span>
      case &quot;&amp;tau;&quot;:
      case &quot;&amp;tgr;&quot;:
<span class="nc" id="L822">        return (char) 0x3C4;</span>
      case &quot;&amp;upsilon;&quot;:
      case &quot;&amp;ugr;&quot;:
<span class="nc" id="L825">        return (char) 0x3C5;</span>
      case &quot;&amp;phi;&quot;:
      case &quot;&amp;phgr;&quot;:
<span class="nc" id="L828">        return (char) 0x3C6;</span>
      case &quot;&amp;chi;&quot;:
      case &quot;&amp;khgr;&quot;:
<span class="nc" id="L831">        return (char) 0x3C7;</span>
      case &quot;&amp;psi;&quot;:
      case &quot;&amp;psgr;&quot;:
<span class="nc" id="L834">        return (char) 0x3C8;</span>
      case &quot;&amp;omega;&quot;:
      case &quot;&amp;ohgr;&quot;:
<span class="nc" id="L837">        return (char) 0x3C9;</span>
      case &quot;&amp;bull;&quot;:
<span class="nc" id="L839">        return (char) 0x2022;</span>
      case &quot;&amp;percnt;&quot;:
<span class="nc" id="L841">        return '%';</span>
      case &quot;&amp;plus;&quot;:
<span class="nc" id="L843">        return '+';</span>
      case &quot;&amp;dash;&quot;:
<span class="nc" id="L845">        return '-';</span>
      case &quot;&amp;abreve;&quot;:
      case &quot;&amp;amacr;&quot;:
      case &quot;&amp;ape;&quot;:
      case &quot;&amp;aogon;&quot;:
<span class="nc" id="L850">        return 'a';</span>
      case &quot;&amp;Amacr;&quot;:
<span class="nc" id="L852">        return 'A';</span>
      case &quot;&amp;cacute;&quot;:
      case &quot;&amp;ccaron;&quot;:
      case &quot;&amp;ccirc;&quot;:
<span class="nc" id="L856">        return 'c';</span>
      case &quot;&amp;Ccaron;&quot;:
<span class="nc" id="L858">        return 'C';</span>
      case &quot;&amp;dcaron;&quot;:
<span class="nc" id="L860">        return 'd';</span>
      case &quot;&amp;ecaron;&quot;:
      case &quot;&amp;emacr;&quot;:
      case &quot;&amp;eogon;&quot;:
<span class="nc" id="L864">        return 'e';</span>
      case &quot;&amp;Emacr;&quot;:
      case &quot;&amp;Ecaron;&quot;:
<span class="nc" id="L867">        return 'E';</span>
      case &quot;&amp;lacute;&quot;:
<span class="nc" id="L869">        return 'l';</span>
      case &quot;&amp;Lacute;&quot;:
<span class="nc" id="L871">        return 'L';</span>
      case &quot;&amp;nacute;&quot;:
      case &quot;&amp;ncaron;&quot;:
      case &quot;&amp;ncedil;&quot;:
<span class="nc" id="L875">        return 'n';</span>
      case &quot;&amp;rcaron;&quot;:
      case &quot;&amp;racute;&quot;:
<span class="nc" id="L878">        return 'r';</span>
      case &quot;&amp;Rcaron;&quot;:
<span class="nc" id="L880">        return 'R';</span>
      case &quot;&amp;omacr;&quot;:
<span class="nc" id="L882">        return 'o';</span>
      case &quot;&amp;imacr;&quot;:
<span class="nc" id="L884">        return 'i';</span>
      case &quot;&amp;sacute;&quot;:
      case &quot;&amp;scedil;&quot;:
      case &quot;&amp;scirc;&quot;:
<span class="nc" id="L888">        return 's';</span>
      case &quot;&amp;Sacute&quot;:
      case &quot;&amp;Scedil;&quot;:
<span class="nc" id="L891">        return 'S';</span>
      case &quot;&amp;tcaron;&quot;:
      case &quot;&amp;tcedil;&quot;:
<span class="nc" id="L894">        return 't';</span>
      case &quot;&amp;umacr;&quot;:
      case &quot;&amp;uring;&quot;:
<span class="nc" id="L897">        return 'u';</span>
      case &quot;&amp;wcirc;&quot;:
<span class="nc" id="L899">        return 'w';</span>
      case &quot;&amp;Ycirc;&quot;:
<span class="nc" id="L901">        return 'Y';</span>
      case &quot;&amp;ycirc;&quot;:
<span class="nc" id="L903">        return 'y';</span>
      case &quot;&amp;zcaron;&quot;:
      case &quot;&amp;zacute;&quot;:
<span class="nc" id="L906">        return 'z';</span>
      case &quot;&amp;Zcaron;&quot;:
<span class="nc" id="L908">        return 'Z';</span>
      case &quot;&amp;hearts;&quot;:
<span class="nc" id="L910">        return (char) 0x2665;</span>
      case &quot;&amp;infin;&quot;:
<span class="nc" id="L912">        return (char) 0x221E;</span>
      case &quot;&amp;dollar;&quot;:
<span class="nc" id="L914">        return '$';</span>
      case &quot;&amp;sub;&quot;:
      case &quot;&amp;lcub;&quot;:
<span class="nc" id="L917">        return (char) 0x2282;</span>
      case &quot;&amp;sup;&quot;:
      case &quot;&amp;rcub;&quot;:
<span class="nc" id="L920">        return (char) 0x2283;</span>
      case &quot;&amp;lsqb;&quot;:
<span class="nc" id="L922">        return '[';</span>
      case &quot;&amp;rsqb;&quot;:
<span class="nc" id="L924">        return ']';</span>
      default:
<span class="nc" id="L926">        return ' ';</span>
    }
  }


  /** Returns a String in which all the XML special characters have been
   *  escaped. The resulting String is valid to print in an XML file as an
   *  attribute or element value in all circumstances.  (Note that it may
   *  escape characters that didn't need to be escaped.)
   *
   *  @param in The String to escape
   *  @return The escaped String
   */
  public static String escapeXML(String in) {
<span class="fc" id="L940">    int leng = in.length();</span>
<span class="fc" id="L941">    StringBuilder sb = new StringBuilder(leng);</span>
<span class="fc bfc" id="L942" title="All 2 branches covered.">    for (int i = 0; i &lt; leng; i++) {</span>
<span class="fc" id="L943">      char c = in.charAt(i);</span>
<span class="fc bfc" id="L944" title="All 2 branches covered.">      if (c == '&amp;') {</span>
<span class="fc" id="L945">        sb.append(&quot;&amp;amp;&quot;);</span>
<span class="pc bpc" id="L946" title="1 of 2 branches missed.">      } else if (c == '&lt;') {</span>
<span class="nc" id="L947">        sb.append(&quot;&amp;lt;&quot;);</span>
<span class="fc bfc" id="L948" title="All 2 branches covered.">      } else if (c == '&gt;') {</span>
<span class="fc" id="L949">        sb.append(&quot;&amp;gt;&quot;);</span>
<span class="fc bfc" id="L950" title="All 2 branches covered.">      } else if (c == '&quot;') {</span>
<span class="fc" id="L951">        sb.append(&quot;&amp;quot;&quot;);</span>
<span class="fc bfc" id="L952" title="All 2 branches covered.">      } else if (c == '\'') {</span>
<span class="fc" id="L953">        sb.append(&quot;&amp;apos;&quot;);</span>
      } else {
<span class="fc" id="L955">        sb.append(c);</span>
      }
    }
<span class="fc" id="L958">    return sb.toString();</span>
  }


  /** Returns a String in which some the XML special characters have been
   *  escaped: just the ones that need escaping in an element content.
   *
   *  @param in The String to escape
   *  @return The escaped String
   */
  public static String escapeElementXML(String in) {
<span class="nc" id="L969">    int leng = in.length();</span>
<span class="nc" id="L970">    StringBuilder sb = new StringBuilder(leng);</span>
<span class="nc bnc" id="L971" title="All 2 branches missed.">    for (int i = 0; i &lt; leng; i++) {</span>
<span class="nc" id="L972">      char c = in.charAt(i);</span>
<span class="nc bnc" id="L973" title="All 2 branches missed.">      if (c == '&amp;') {</span>
<span class="nc" id="L974">        sb.append(&quot;&amp;amp;&quot;);</span>
<span class="nc bnc" id="L975" title="All 2 branches missed.">      } else if (c == '&lt;') {</span>
<span class="nc" id="L976">        sb.append(&quot;&amp;lt;&quot;);</span>
<span class="nc bnc" id="L977" title="All 2 branches missed.">      } else if (c == '&gt;') {</span>
<span class="nc" id="L978">        sb.append(&quot;&amp;gt;&quot;);</span>
      } else {
<span class="nc" id="L980">        sb.append(c);</span>
      }
    }
<span class="nc" id="L983">    return sb.toString();</span>
  }


  /** Returns a String in which some XML special characters have been
   *  escaped. This just escapes attribute value ones, assuming that
   *  you're going to quote with double quotes.
   *  That is, only &quot; and &amp; are escaped.
   *
   *  @param in The String to escape
   *  @return The escaped String
   */
  public static String escapeAttributeXML(String in) {
<span class="nc" id="L996">    int leng = in.length();</span>
<span class="nc" id="L997">    StringBuilder sb = new StringBuilder(leng);</span>
<span class="nc bnc" id="L998" title="All 2 branches missed.">    for (int i = 0; i &lt; leng; i++) {</span>
<span class="nc" id="L999">      char c = in.charAt(i);</span>
<span class="nc bnc" id="L1000" title="All 2 branches missed.">      if (c == '&amp;') {</span>
<span class="nc" id="L1001">        sb.append(&quot;&amp;amp;&quot;);</span>
<span class="nc bnc" id="L1002" title="All 2 branches missed.">      } else if (c == '&quot;') {</span>
<span class="nc" id="L1003">        sb.append(&quot;&amp;quot;&quot;);</span>
      } else {
<span class="nc" id="L1005">        sb.append(c);</span>
      }
    }
<span class="nc" id="L1008">    return sb.toString();</span>
  }


  public static String escapeTextAroundXMLTags(String s) {
<span class="nc" id="L1013">    StringBuilder result = new StringBuilder();</span>
<span class="nc" id="L1014">    Reader r = new StringReader(s);</span>
    try {
      do {
<span class="nc" id="L1017">        String text = readUntilTag(r);</span>
        //      System.out.println(&quot;got text: &quot; + text);
<span class="nc" id="L1019">        result.append(escapeXML(text));</span>
<span class="nc" id="L1020">        XMLTag tag = readAndParseTag(r);</span>
        //      System.out.println(&quot;got tag: &quot; + tag);
<span class="nc bnc" id="L1022" title="All 2 branches missed.">        if (tag == null) {</span>
<span class="nc" id="L1023">          break;</span>
        }
<span class="nc" id="L1025">        result.append(tag.toString());</span>
<span class="nc" id="L1026">      } while (true);</span>
<span class="nc" id="L1027">    } catch (IOException e) {</span>
<span class="nc" id="L1028">      log.info(&quot;Error reading string&quot;);</span>
<span class="nc" id="L1029">      e.printStackTrace();</span>
<span class="nc" id="L1030">    }</span>
<span class="nc" id="L1031">    return result.toString();</span>
  }

  /**
   * return either the first space or the first nbsp
   */
  public static int findSpace(String haystack, int begin) {
<span class="fc" id="L1038">    int space = haystack.indexOf(' ', begin);</span>
<span class="fc" id="L1039">    int nbsp = haystack.indexOf('\u00A0', begin);</span>
<span class="fc bfc" id="L1040" title="All 4 branches covered.">    if (space == -1 &amp;&amp; nbsp == -1) {</span>
<span class="fc" id="L1041">      return -1;</span>
<span class="pc bpc" id="L1042" title="1 of 4 branches missed.">    } else if (space &gt;= 0 &amp;&amp; nbsp &gt;= 0) {</span>
<span class="nc" id="L1043">      return Math.min(space, nbsp);</span>
    } else {
      // eg one is -1, and the other is &gt;= 0
<span class="fc" id="L1046">      return Math.max(space, nbsp);</span>
    }
  }

  public static class XMLTag {
    public String text;
    public String name;
    public Map&lt;String,String&gt; attributes;
    public boolean isEndTag;
    public boolean isSingleTag;

    /**
     * Assumes that String contains an XML tag.
     *
     * @param tag String to turn into an XMLTag object
     */
<span class="fc" id="L1062">    public XMLTag(String tag) {</span>
<span class="pc bpc" id="L1063" title="2 of 4 branches missed.">      if (tag == null || tag.length() == 0) {</span>
<span class="nc" id="L1064">        throw new NullPointerException(&quot;Attempted to parse empty/null tag&quot;);</span>
      }
<span class="pc bpc" id="L1066" title="1 of 2 branches missed.">      if (tag.charAt(0) != '&lt;') {</span>
<span class="nc" id="L1067">        throw new IllegalArgumentException(&quot;Tag did not start with &lt;&quot;);</span>
      }
<span class="pc bpc" id="L1069" title="1 of 2 branches missed.">      if (tag.charAt(tag.length() - 1) != '&gt;') {</span>
<span class="nc" id="L1070">        throw new IllegalArgumentException(&quot;Tag did not end with &gt;&quot;);</span>
      }
<span class="fc" id="L1072">      text = tag;</span>
<span class="fc" id="L1073">      int begin = 1;</span>
<span class="fc bfc" id="L1074" title="All 2 branches covered.">      if (tag.charAt(1) == '/') {</span>
<span class="fc" id="L1075">        begin = 2;</span>
<span class="fc" id="L1076">        isEndTag = true;</span>
      } else {
<span class="fc" id="L1078">        isEndTag = false;</span>
      }
<span class="fc" id="L1080">      int end = tag.length() - 1;</span>
<span class="fc bfc" id="L1081" title="All 2 branches covered.">      if (tag.charAt(tag.length() - 2) == '/') {</span>
<span class="fc" id="L1082">        end = tag.length() - 2;</span>
<span class="fc" id="L1083">        isSingleTag = true;</span>
      } else {
<span class="fc" id="L1085">        isSingleTag = false;</span>
      }
<span class="fc" id="L1087">      tag = tag.substring(begin, end);</span>
<span class="fc" id="L1088">      attributes = Generics.newHashMap();</span>
<span class="fc" id="L1089">      begin = 0;</span>
<span class="fc" id="L1090">      end = findSpace(tag, 0);</span>

<span class="fc bfc" id="L1092" title="All 2 branches covered.">      if (end &lt; 0) {</span>
<span class="fc" id="L1093">        name = tag;</span>
      } else {
<span class="fc" id="L1095">        name = tag.substring(begin, end);</span>
        do {
<span class="fc" id="L1097">          begin = end + 1;</span>
<span class="fc bfc" id="L1098" title="All 4 branches covered.">          while (begin &lt; tag.length() &amp;&amp; tag.charAt(begin) &lt; 0x21) {</span>
<span class="fc" id="L1099">            begin++; // get rid of leading whitespace</span>
          }
<span class="fc bfc" id="L1101" title="All 2 branches covered.">          if (begin == tag.length()) {</span>
<span class="fc" id="L1102">            break;</span>
          }
<span class="fc" id="L1104">          end = tag.indexOf('=', begin);</span>
<span class="pc bpc" id="L1105" title="1 of 2 branches missed.">          if (end &lt; 0) {</span>
<span class="nc" id="L1106">            String att = tag.substring(begin);</span>
<span class="nc" id="L1107">            attributes.put(att, &quot;&quot;);</span>
<span class="nc" id="L1108">            break;</span>
          }
<span class="fc" id="L1110">          String att = tag.substring(begin, end).trim();</span>
<span class="fc" id="L1111">          begin = end + 1;</span>
<span class="fc" id="L1112">          String value = null;</span>
<span class="pc bpc" id="L1113" title="1 of 2 branches missed.">          if (tag.length() &gt; begin) {</span>
<span class="pc bpc" id="L1114" title="1 of 4 branches missed.">            while (begin &lt; tag.length() &amp;&amp; tag.charAt(begin) &lt; 0x21) {</span>
<span class="fc" id="L1115">              begin++;</span>
            }
<span class="pc bpc" id="L1117" title="2 of 4 branches missed.">            if (begin &lt; tag.length() &amp;&amp; tag.charAt(begin) == '\&quot;') {</span>
              // get quoted expression
<span class="fc" id="L1119">              begin++;</span>
<span class="fc" id="L1120">              end = tag.indexOf('\&quot;', begin);</span>
<span class="pc bpc" id="L1121" title="1 of 2 branches missed.">              if (end &lt; 0) {</span>
<span class="nc" id="L1122">                break; // this is a problem</span>
              }
<span class="fc" id="L1124">              value = tag.substring(begin, end);</span>
<span class="fc" id="L1125">              end++;</span>
            } else {
              // get unquoted expression
<span class="nc" id="L1128">              end = findSpace(tag, begin);</span>
<span class="nc bnc" id="L1129" title="All 2 branches missed.">              if (end &lt; 0) {</span>
<span class="nc" id="L1130">                end = tag.length();</span>
              }
//              System.out.println(begin + &quot; &quot; + end);
<span class="nc" id="L1133">              value = tag.substring(begin, end);</span>
            }
          }
<span class="fc" id="L1136">          attributes.put(att, value);</span>
<span class="fc bfc" id="L1137" title="All 2 branches covered.">        } while (end &lt; tag.length() - 3);</span>
      }
<span class="fc" id="L1139">    }</span>

    public String toString() {
<span class="fc" id="L1142">      return text;</span>
    }
  } // end static class XMLTag


  /**
   * Reads all text of the XML tag and returns it as a String.
   * Assumes that a '&lt;' character has already been read.
   *
   * @param r The reader to read from
   * @return The String representing the tag, or null if one couldn't be read
   *         (i.e., EOF).  The returned item is a complete tag including angle
   *         brackets, such as &lt;code&gt;&amp;lt;TXT&amp;gt;&lt;/code&gt;
   */
  public static String readTag(Reader r) throws IOException {
<span class="pc bpc" id="L1157" title="1 of 2 branches missed.">    if ( ! r.ready()) {</span>
<span class="nc" id="L1158">      return null;</span>
    }
<span class="fc" id="L1160">    StringBuilder b = new StringBuilder(&quot;&lt;&quot;);</span>
<span class="fc" id="L1161">    int c = r.read();</span>
<span class="fc bfc" id="L1162" title="All 2 branches covered.">    while (c &gt;= 0) {</span>
<span class="fc" id="L1163">      b.append((char) c);</span>
<span class="fc bfc" id="L1164" title="All 2 branches covered.">      if (c == '&gt;') {</span>
<span class="fc" id="L1165">        break;</span>
      }
<span class="fc" id="L1167">      c = r.read();</span>
    }
<span class="fc bfc" id="L1169" title="All 2 branches covered.">    if (b.length() == 1) {</span>
<span class="fc" id="L1170">      return null;</span>
    }
<span class="fc" id="L1172">    return b.toString();</span>
  }

  public static XMLTag parseTag(String tagString) {
<span class="pc bpc" id="L1176" title="2 of 4 branches missed.">    if (tagString == null || tagString.isEmpty()) {</span>
<span class="nc" id="L1177">      return null;</span>
    }
<span class="fc bfc" id="L1179" title="All 2 branches covered.">    if (tagString.charAt(0) != '&lt;' ||</span>
<span class="pc bpc" id="L1180" title="1 of 2 branches missed.">        tagString.charAt(tagString.length() - 1) != '&gt;') {</span>
<span class="fc" id="L1181">      return null;</span>
    }
<span class="fc" id="L1183">    return new XMLTag(tagString);</span>
  }

  public static Document readDocumentFromFile(String filename)
    throws Exception
  {
<span class="nc" id="L1189">    InputSource in = new InputSource(new FileReader(filename));</span>
<span class="nc" id="L1190">    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();</span>
<span class="nc" id="L1191">    factory.setNamespaceAware(false);</span>
<span class="nc" id="L1192">    DocumentBuilder db = factory.newDocumentBuilder();</span>
<span class="nc" id="L1193">    db.setErrorHandler(new SAXErrorHandler());</span>
<span class="nc" id="L1194">    return db.parse(in);</span>
  }

<span class="nc" id="L1197">  private static class SAXErrorHandler implements ErrorHandler {</span>

    public static String makeBetterErrorString(String msg,
                                               SAXParseException ex) {
<span class="nc" id="L1201">      StringBuilder sb = new StringBuilder(msg);</span>
<span class="nc" id="L1202">      sb.append(&quot;: &quot;);</span>
<span class="nc" id="L1203">      String str = ex.getMessage();</span>
<span class="nc bnc" id="L1204" title="All 2 branches missed.">      if (str.lastIndexOf('.') == str.length() - 1) {</span>
<span class="nc" id="L1205">        str = str.substring(0, str.length() - 1);</span>
      }
<span class="nc" id="L1207">      sb.append(str);</span>
<span class="nc" id="L1208">      sb.append(&quot; at document line &quot;).append(ex.getLineNumber());</span>
<span class="nc" id="L1209">      sb.append(&quot;, column &quot;).append(ex.getColumnNumber());</span>
<span class="nc bnc" id="L1210" title="All 2 branches missed.">      if (ex.getSystemId() != null) {</span>
<span class="nc" id="L1211">        sb.append(&quot; in entity from systemID &quot;).append(ex.getSystemId());</span>
<span class="nc bnc" id="L1212" title="All 2 branches missed.">      } else if (ex.getPublicId() != null) {</span>
<span class="nc" id="L1213">        sb.append(&quot; in entity from publicID &quot;).append(ex.getPublicId());</span>
      }
<span class="nc" id="L1215">      sb.append(&quot;.&quot;);</span>
<span class="nc" id="L1216">      return sb.toString();</span>
    }

    public void warning(SAXParseException exception) {
<span class="nc" id="L1220">      log.info(makeBetterErrorString(&quot;Warning&quot;, exception));</span>
<span class="nc" id="L1221">    }</span>

    public void error(SAXParseException exception) {
<span class="nc" id="L1224">      log.info(makeBetterErrorString(&quot;Error&quot;, exception));</span>
<span class="nc" id="L1225">    }</span>

    public void fatalError(SAXParseException ex) throws SAXParseException {
<span class="nc" id="L1228">      throw new SAXParseException(makeBetterErrorString(&quot;Fatal Error&quot;, ex), ex.getPublicId(), ex.getSystemId(), ex.getLineNumber(), ex.getColumnNumber());</span>
      // throw new RuntimeException(makeBetterErrorString(&quot;Fatal Error&quot;, ex));
    }

  } // end class SAXErrorHandler

  public static Document readDocumentFromString(String s) throws Exception {
<span class="nc" id="L1235">    InputSource in = new InputSource(new StringReader(s));</span>
<span class="nc" id="L1236">    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();</span>
<span class="nc" id="L1237">    factory.setNamespaceAware(false);</span>
<span class="nc" id="L1238">    return factory.newDocumentBuilder().parse(in);</span>
  }

  /** Tests a few methods.
   *  If the first arg is -readDoc then this method tests
   *  readDocumentFromFile.
   *  Otherwise, it tests readTag/readUntilTag and slurpFile.
   */
  public static void main(String[] args) throws Exception {
<span class="nc bnc" id="L1247" title="All 2 branches missed.">    if (args[0].equals(&quot;-readDoc&quot;)) {</span>
<span class="nc" id="L1248">      Document doc = readDocumentFromFile(args[1]);</span>
<span class="nc" id="L1249">      System.out.println(doc);</span>
<span class="nc" id="L1250">    } else {</span>
<span class="nc" id="L1251">      String s = IOUtils.slurpFile(args[0]);</span>
<span class="nc" id="L1252">      Reader r = new StringReader(s);</span>
<span class="nc" id="L1253">      String tag = readTag(r);</span>
<span class="nc bnc" id="L1254" title="All 4 branches missed.">      while (tag != null &amp;&amp; tag.length() &gt; 0) {</span>
<span class="nc" id="L1255">        readUntilTag(r);</span>
<span class="nc" id="L1256">        tag = readTag(r);</span>
<span class="nc bnc" id="L1257" title="All 4 branches missed.">        if (tag == null || tag.isEmpty()) {</span>
<span class="nc" id="L1258">          break;</span>
        }
<span class="nc" id="L1260">        System.out.println(&quot;got tag=&quot; + new XMLTag(tag));</span>
      }
    }
<span class="nc" id="L1263">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>