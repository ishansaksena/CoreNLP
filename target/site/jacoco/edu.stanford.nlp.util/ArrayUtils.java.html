<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ArrayUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.util</a> &gt; <span class="el_source">ArrayUtils.java</span></div><h1>ArrayUtils.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.util; 
import edu.stanford.nlp.util.logging.Redwood;

import java.lang.reflect.Array;
import java.util.*;
import java.util.function.Function;
import java.util.function.Predicate;


/**
 * Static utility methods for operating on arrays.
 *
 * Note: You can also find some methods for printing arrays that are tables in
 * StringUtils.  (Search for makeTextTable, etc.)
 *
 * @author Huy Nguyen (htnguyen@cs.stanford.edu)
 * @author Michel Galley (mgalley@stanford.edu)
 */
public class ArrayUtils  {

  /** A logger for this class */
<span class="fc" id="L22">  private static Redwood.RedwoodChannels log = Redwood.channels(ArrayUtils.class);</span>

  /**
   * Should not be instantiated
   */
<span class="nc" id="L27">  private ArrayUtils() {}</span>

  public static byte[] gapEncode(int[] orig) {
<span class="fc" id="L30">    List&lt;Byte&gt; encodedList = gapEncodeList(orig);</span>
<span class="fc" id="L31">    byte[] arr = new byte[encodedList.size()];</span>
<span class="fc" id="L32">    int i = 0;</span>
<span class="fc bfc" id="L33" title="All 2 branches covered.">    for (byte b : encodedList) { arr[i++] = b; }</span>
<span class="fc" id="L34">    return arr;</span>
  }

  public static List&lt;Byte&gt; gapEncodeList(int[] orig) {
<span class="fc bfc" id="L38" title="All 2 branches covered.">    for (int i = 1; i &lt; orig.length; i++) {</span>
<span class="fc bfc" id="L39" title="All 2 branches covered.">      if (orig[i] &lt; orig[i-1]) {</span>
<span class="fc" id="L40">        throw new IllegalArgumentException(&quot;Array must be sorted!&quot;);</span>
      }
    }

<span class="fc" id="L44">    List&lt;Byte&gt; bytes = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L46">    int index = 0;</span>
<span class="fc" id="L47">    int prevNum = 0;</span>
<span class="fc" id="L48">    byte currByte = 0 &lt;&lt; 8;</span>

<span class="fc bfc" id="L50" title="All 2 branches covered.">    for (int f : orig) {</span>
<span class="pc bpc" id="L51" title="1 of 2 branches missed.">      String n = (f == prevNum ? &quot;&quot; : Integer.toString(f-prevNum, 2));</span>
<span class="fc bfc" id="L52" title="All 2 branches covered.">      for (int ii = 0; ii &lt; n.length(); ii++) {</span>
<span class="fc bfc" id="L53" title="All 2 branches covered.">        if (index == 8) {</span>
<span class="fc" id="L54">          bytes.add(currByte);</span>
<span class="fc" id="L55">          currByte = 0 &lt;&lt; 8;</span>
<span class="fc" id="L56">          index = 0;</span>
        }
<span class="fc" id="L58">        currByte &lt;&lt;= 1;</span>
<span class="fc" id="L59">        currByte++;</span>
<span class="fc" id="L60">        index++;</span>
      }

<span class="fc bfc" id="L63" title="All 2 branches covered.">      if (index == 8) {</span>
<span class="fc" id="L64">        bytes.add(currByte);</span>
<span class="fc" id="L65">        currByte = 0 &lt;&lt; 8;</span>
<span class="fc" id="L66">        index = 0;</span>
      }
<span class="fc" id="L68">      currByte &lt;&lt;= 1;</span>
<span class="fc" id="L69">      index++;</span>

<span class="fc bfc" id="L71" title="All 2 branches covered.">      for (int i = 1; i &lt; n.length(); i++) {</span>
<span class="fc bfc" id="L72" title="All 2 branches covered.">        if (index == 8) {</span>
<span class="fc" id="L73">          bytes.add(currByte);</span>
<span class="fc" id="L74">          currByte = 0 &lt;&lt; 8;</span>
<span class="fc" id="L75">          index = 0;</span>
        }
<span class="fc" id="L77">        currByte &lt;&lt;= 1;</span>
<span class="fc bfc" id="L78" title="All 2 branches covered.">        if (n.charAt(i) == '1') {</span>
<span class="fc" id="L79">          currByte++;</span>
        }
<span class="fc" id="L81">        index++;</span>
      }
<span class="fc" id="L83">      prevNum = f;</span>
    }

<span class="pc bpc" id="L86" title="2 of 4 branches missed.">    while (index &gt; 0 &amp;&amp; index &lt; 9) {</span>
<span class="fc bfc" id="L87" title="All 2 branches covered.">      if (index == 8) {</span>
<span class="fc" id="L88">        bytes.add(currByte);</span>
<span class="fc" id="L89">        break;</span>
      }
<span class="fc" id="L91">      currByte &lt;&lt;= 1;</span>
<span class="fc" id="L92">      currByte++;</span>
<span class="fc" id="L93">      index++;</span>
    }

<span class="fc" id="L96">    return bytes;</span>
  }

  public static int[] gapDecode(byte[] gapEncoded) {
<span class="fc" id="L100">    return gapDecode(gapEncoded, 0, gapEncoded.length);</span>
  }

  public static int[] gapDecode(byte[] gapEncoded, int startIndex, int endIndex) {
<span class="fc" id="L104">    List&lt;Integer&gt; ints = gapDecodeList(gapEncoded, startIndex, endIndex);</span>
<span class="fc" id="L105">    int[] arr = new int[ints.size()];</span>
<span class="fc" id="L106">    int index = 0;</span>
<span class="fc bfc" id="L107" title="All 2 branches covered.">    for (int i : ints) { arr[index++] = i; }</span>
<span class="fc" id="L108">    return arr;</span>
  }

  public static List&lt;Integer&gt; gapDecodeList(byte[] gapEncoded) {
<span class="nc" id="L112">    return gapDecodeList(gapEncoded, 0, gapEncoded.length);</span>
  }

  public static List&lt;Integer&gt; gapDecodeList(byte[] gapEncoded, int startIndex, int endIndex) {

<span class="fc" id="L117">    boolean gettingSize = true;</span>
<span class="fc" id="L118">    int size = 0;</span>
<span class="fc" id="L119">    List&lt;Integer&gt; ints = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L120">    int gap = 0;</span>
<span class="fc" id="L121">    int prevNum = 0;</span>

<span class="fc bfc" id="L123" title="All 2 branches covered.">    for (int i = startIndex; i &lt; endIndex; i++) {</span>
<span class="fc" id="L124">      byte b = gapEncoded[i];</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">      for (int index = 7; index &gt;= 0; index--) {</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">        boolean value = ((b &gt;&gt; index) &amp; 1) == 1;</span>

<span class="fc bfc" id="L128" title="All 2 branches covered.">        if (gettingSize) {</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">          if (value) { size++; }</span>
          else {
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">            if (size == 0) {</span>
<span class="nc" id="L132">              ints.add(prevNum);</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">            } else if (size == 1) {</span>
<span class="fc" id="L134">              prevNum++;</span>
<span class="fc" id="L135">              ints.add(prevNum);</span>
<span class="fc" id="L136">              size = 0;</span>
            } else {
<span class="fc" id="L138">              gettingSize = false;</span>
<span class="fc" id="L139">              gap = 1;</span>
<span class="fc" id="L140">              size--;</span>
            }
          }
        } else {
<span class="fc" id="L144">          gap &lt;&lt;= 1;</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">          if (value) { gap++; }</span>
<span class="fc" id="L146">          size--;</span>
<span class="fc bfc" id="L147" title="All 2 branches covered.">          if (size == 0) {</span>
<span class="fc" id="L148">            prevNum += gap;</span>
<span class="fc" id="L149">            ints.add(prevNum);</span>
<span class="fc" id="L150">            gettingSize = true;</span>
          }
        }
      }
    }

<span class="fc" id="L156">    return ints;</span>
  }

  public static byte[] deltaEncode(int[] orig) {
<span class="fc" id="L160">    List&lt;Byte&gt; encodedList = deltaEncodeList(orig);</span>
<span class="fc" id="L161">    byte[] arr = new byte[encodedList.size()];</span>
<span class="fc" id="L162">    int i = 0;</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">    for (byte b : encodedList) { arr[i++] = b; }</span>
<span class="fc" id="L164">    return arr;</span>
  }

  public static List&lt;Byte&gt; deltaEncodeList(int[] orig) {

<span class="fc bfc" id="L169" title="All 2 branches covered.">    for (int i = 1; i &lt; orig.length; i++) {</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">      if (orig[i] &lt; orig[i-1]) {</span>
<span class="fc" id="L171">        throw new IllegalArgumentException(&quot;Array must be sorted!&quot;);</span>
      }
    }

<span class="fc" id="L175">    List&lt;Byte&gt; bytes = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L177">    int index = 0;</span>
<span class="fc" id="L178">    int prevNum = 0;</span>
<span class="fc" id="L179">    byte currByte = 0 &lt;&lt; 8;</span>

<span class="fc bfc" id="L181" title="All 2 branches covered.">    for (int f : orig) {</span>
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">      String n = (f == prevNum ? &quot;&quot; : Integer.toString(f-prevNum, 2));</span>
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">      String n1 = (n.isEmpty() ? &quot;&quot; : Integer.toString(n.length(), 2));</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">      for (int ii = 0; ii &lt; n1.length(); ii++) {</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">        if (index == 8) {</span>
<span class="fc" id="L186">          bytes.add(currByte);</span>
<span class="fc" id="L187">          currByte = 0 &lt;&lt; 8;</span>
<span class="fc" id="L188">          index = 0;</span>
        }
<span class="fc" id="L190">        currByte &lt;&lt;= 1;</span>
<span class="fc" id="L191">        currByte++;</span>
<span class="fc" id="L192">        index++;</span>
      }

<span class="fc bfc" id="L195" title="All 2 branches covered.">      if (index == 8) {</span>
<span class="fc" id="L196">        bytes.add(currByte);</span>
<span class="fc" id="L197">        currByte = 0 &lt;&lt; 8;</span>
<span class="fc" id="L198">        index = 0;</span>
      }
<span class="fc" id="L200">      currByte &lt;&lt;= 1;</span>
<span class="fc" id="L201">      index++;</span>

<span class="fc bfc" id="L203" title="All 2 branches covered.">      for (int i = 1; i &lt; n1.length(); i++) {</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">        if (index == 8) {</span>
<span class="fc" id="L205">          bytes.add(currByte);</span>
<span class="fc" id="L206">          currByte = 0 &lt;&lt; 8;</span>
<span class="fc" id="L207">          index = 0;</span>
        }
<span class="fc" id="L209">        currByte &lt;&lt;= 1;</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">        if (n1.charAt(i) == '1') {</span>
<span class="fc" id="L211">          currByte++;</span>
        }
<span class="fc" id="L213">        index++;</span>
      }

<span class="fc bfc" id="L216" title="All 2 branches covered.">      for (int i = 1; i &lt; n.length(); i++) {</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">        if (index == 8) {</span>
<span class="fc" id="L218">          bytes.add(currByte);</span>
<span class="fc" id="L219">          currByte = 0 &lt;&lt; 8;</span>
<span class="fc" id="L220">          index = 0;</span>
        }
<span class="fc" id="L222">        currByte &lt;&lt;= 1;</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">        if (n.charAt(i) == '1') {</span>
<span class="fc" id="L224">          currByte++;</span>
        }
<span class="fc" id="L226">        index++;</span>
      }

<span class="fc" id="L229">      prevNum = f;</span>

    }

<span class="pc bpc" id="L233" title="2 of 4 branches missed.">    while (index &gt; 0 &amp;&amp; index &lt; 9) {</span>
<span class="fc bfc" id="L234" title="All 2 branches covered.">      if (index == 8) {</span>
<span class="fc" id="L235">        bytes.add(currByte);</span>
<span class="fc" id="L236">        break;</span>
      }
<span class="fc" id="L238">      currByte &lt;&lt;= 1;</span>
<span class="fc" id="L239">      currByte++;</span>
<span class="fc" id="L240">      index++;</span>
    }

<span class="fc" id="L243">    return bytes;</span>
  }


  public static int[] deltaDecode(byte[] deltaEncoded) {
<span class="fc" id="L248">    return deltaDecode(deltaEncoded, 0, deltaEncoded.length);</span>
  }

  public static int[] deltaDecode(byte[] deltaEncoded, int startIndex, int endIndex) {
<span class="fc" id="L252">    List&lt;Integer&gt; ints = deltaDecodeList(deltaEncoded);</span>
<span class="fc" id="L253">    int[] arr = new int[ints.size()];</span>
<span class="fc" id="L254">    int index = 0;</span>
<span class="fc bfc" id="L255" title="All 2 branches covered.">    for (int i : ints) { arr[index++] = i; }</span>
<span class="fc" id="L256">    return arr;</span>
  }

  public static List&lt;Integer&gt; deltaDecodeList(byte[] deltaEncoded) {
<span class="fc" id="L260">    return deltaDecodeList(deltaEncoded, 0, deltaEncoded.length);</span>
  }

  public static List&lt;Integer&gt; deltaDecodeList(byte[] deltaEncoded, int startIndex, int endIndex) {

<span class="fc" id="L265">    boolean gettingSize1 = true;</span>
<span class="fc" id="L266">    boolean gettingSize2 = false;</span>
<span class="fc" id="L267">    int size1 = 0;</span>
<span class="fc" id="L268">    List&lt;Integer&gt; ints = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L269">    int gap = 0;</span>
<span class="fc" id="L270">    int size2 = 0;</span>
<span class="fc" id="L271">    int prevNum = 0;</span>

<span class="fc bfc" id="L273" title="All 2 branches covered.">    for (int i = startIndex; i &lt; endIndex; i++) {</span>
<span class="fc" id="L274">      byte b = deltaEncoded[i];</span>
<span class="fc bfc" id="L275" title="All 2 branches covered.">      for (int index = 7; index &gt;= 0; index--) {</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">        boolean value = ((b &gt;&gt; index) &amp; 1) == 1;</span>

<span class="fc bfc" id="L278" title="All 2 branches covered.">        if (gettingSize1) {</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">          if (value) { size1++; }</span>
          else {
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">            if (size1 == 0) {</span>
<span class="nc" id="L282">              ints.add(prevNum);</span>
<span class="fc bfc" id="L283" title="All 2 branches covered.">            } else if (size1 == 1) {</span>
<span class="fc" id="L284">              prevNum++;</span>
<span class="fc" id="L285">              ints.add(prevNum);</span>
<span class="fc" id="L286">              size1 = 0;</span>
            } else {
<span class="fc" id="L288">              gettingSize1 = false;</span>
<span class="fc" id="L289">              gettingSize2 = true;</span>
<span class="fc" id="L290">              size2 = 1;</span>
<span class="fc" id="L291">              size1--;</span>
            }
          }
<span class="fc bfc" id="L294" title="All 2 branches covered.">        } else if (gettingSize2) {</span>
<span class="fc" id="L295">          size2 &lt;&lt;= 1;</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">          if (value) { size2++; }</span>
<span class="fc" id="L297">          size1--;</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">          if (size1 == 0) {</span>
<span class="fc" id="L299">            gettingSize2 = false;</span>
<span class="fc" id="L300">            gap = 1;</span>
<span class="fc" id="L301">            size2--;</span>
          }
        } else {
<span class="fc" id="L304">          gap &lt;&lt;= 1;</span>
<span class="fc bfc" id="L305" title="All 2 branches covered.">          if (value) { gap++; }</span>
<span class="fc" id="L306">          size2--;</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">          if (size2 == 0) {</span>
<span class="fc" id="L308">            prevNum += gap;</span>
<span class="fc" id="L309">            ints.add(prevNum);</span>
<span class="fc" id="L310">            gettingSize1 = true;</span>
          }
        }
      }
    }

<span class="fc" id="L316">    return ints;</span>
  }

  /** helper for gap encoding. */
  private static byte[] bitSetToByteArray(BitSet bitSet) {

<span class="nc bnc" id="L322" title="All 2 branches missed.">    while (bitSet.length() % 8 != 0) { bitSet.set(bitSet.length(), true); }</span>

<span class="nc" id="L324">    byte[] array = new byte[bitSet.length()/8];</span>

<span class="nc bnc" id="L326" title="All 2 branches missed.">    for (int i = 0; i &lt; array.length; i++) {</span>
<span class="nc" id="L327">      int offset = i * 8;</span>

<span class="nc" id="L329">      int index = 0;</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">      for (int j = 0; j &lt; 8; j++) {</span>
<span class="nc" id="L331">        index &lt;&lt;= 1;</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">        if (bitSet.get(offset+j)) { index++; }</span>
      }

<span class="nc" id="L335">      array[i] = (byte)(index - 128);</span>
    }

<span class="nc" id="L338">    return array;</span>
  }

  /** helper for gap encoding. */
  private static BitSet byteArrayToBitSet(byte[] array) {

<span class="nc" id="L344">    BitSet bitSet = new BitSet();</span>
<span class="nc" id="L345">    int index = 0;</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">    for (byte b : array) {</span>
<span class="nc" id="L347">      int b1 = ((int)b) + 128;</span>

<span class="nc bnc" id="L349" title="All 2 branches missed.">      bitSet.set(index++, ((b1 &gt;&gt; 7) &amp; 1) == 1);</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">      bitSet.set(index++, ((b1 &gt;&gt; 6) &amp; 1) == 1);</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">      bitSet.set(index++, ((b1 &gt;&gt; 5) &amp; 1) == 1);</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">      bitSet.set(index++, ((b1 &gt;&gt; 4) &amp; 1) == 1);</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">      bitSet.set(index++, ((b1 &gt;&gt; 3) &amp; 1) == 1);</span>
<span class="nc bnc" id="L354" title="All 2 branches missed.">      bitSet.set(index++, ((b1 &gt;&gt; 2) &amp; 1) == 1);</span>
<span class="nc bnc" id="L355" title="All 2 branches missed.">      bitSet.set(index++, ((b1 &gt;&gt; 1) &amp; 1) == 1);</span>
<span class="nc bnc" id="L356" title="All 2 branches missed.">      bitSet.set(index++, (b1 &amp; 1) == 1);</span>
    }

<span class="nc" id="L359">    return bitSet;</span>
  }

//     for (int i = 1; i &lt; orig.length; i++) {
//       if (orig[i] &lt; orig[i-1]) { throw new RuntimeException(&quot;Array must be sorted!&quot;); }

//       StringBuilder bits = new StringBuilder();
//       int prevNum = 0;
//       for (int f : orig) {
//         StringBuilder bits1 = new StringBuilder();
//               log.info(f+&quot;\t&quot;);
//               String n = Integer.toString(f-prevNum, 2);
//               String n1 = Integer.toString(n.length(), 2);
//               for (int ii = 0; ii &lt; n1.length(); ii++) {
//                 bits1.append(&quot;1&quot;);
//               }
//               bits1.append(&quot;0&quot;);
//               bits1.append(n1.substring(1));
//               bits1.append(n.substring(1));
//               log.info(bits1+&quot;\t&quot;);
//               bits.append(bits1);
//               prevNum = f;
//             }



  public static double[] flatten(double[][] array) {
<span class="nc" id="L386">    int size = 0;</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">    for (double[] a : array) {</span>
<span class="nc" id="L388">      size += a.length;</span>
    }
<span class="nc" id="L390">    double[] newArray = new double[size];</span>
<span class="nc" id="L391">    int i = 0;</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">    for (double[] a : array) {</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">      for (double d : a) {</span>
<span class="nc" id="L394">        newArray[i++] = d;</span>
      }
    }
<span class="nc" id="L397">    return newArray;</span>
  }

  public static double[][] to2D(double[] array, int dim1Size) {
<span class="nc" id="L401">    int dim2Size = array.length/dim1Size;</span>
<span class="nc" id="L402">    return to2D(array, dim1Size, dim2Size);</span>
  }

  public static double[][] to2D(double[] array, int dim1Size, int dim2Size) {
<span class="nc" id="L406">    double[][] newArray = new double[dim1Size][dim2Size];</span>
<span class="nc" id="L407">    int k = 0;</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">    for (int i = 0; i &lt; newArray.length; i++) {</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">      for (int j = 0; j &lt; newArray[i].length; j++) {</span>
<span class="nc" id="L410">        newArray[i][j] = array[k++];</span>
      }
    }
<span class="nc" id="L413">    return newArray;</span>
  }

  /**
   * Removes the element at the specified index from the array, and returns
   * a new array containing the remaining elements.  If &lt;tt&gt;index&lt;/tt&gt; is
   * invalid, returns &lt;tt&gt;array&lt;/tt&gt; unchanged.
   */
  public static double[] removeAt(double[] array, int index) {
<span class="nc bnc" id="L422" title="All 2 branches missed.">    if (array == null) {</span>
<span class="nc" id="L423">      return null;</span>
    }
<span class="nc bnc" id="L425" title="All 4 branches missed.">    if (index &lt; 0 || index &gt;= array.length) {</span>
<span class="nc" id="L426">      return array;</span>
    }

<span class="nc" id="L429">    double[] retVal = new double[array.length - 1];</span>
<span class="nc bnc" id="L430" title="All 2 branches missed.">    for (int i = 0; i &lt; array.length; i++) {</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">      if (i &lt; index) {</span>
<span class="nc" id="L432">        retVal[i] = array[i];</span>
<span class="nc bnc" id="L433" title="All 2 branches missed.">      } else if (i &gt; index) {</span>
<span class="nc" id="L434">        retVal[i - 1] = array[i];</span>
      }
    }
<span class="nc" id="L437">    return retVal;</span>
  }

  /**
   * Removes the element at the specified index from the array, and returns
   * a new array containing the remaining elements.  If &lt;tt&gt;index&lt;/tt&gt; is
   * invalid, returns &lt;tt&gt;array&lt;/tt&gt; unchanged.  Uses reflection to determine
   * the type of the array and returns an array of the appropriate type.
   */
  public static Object[] removeAt(Object[] array, int index) {
<span class="pc bpc" id="L447" title="1 of 2 branches missed.">    if (array == null) {</span>
<span class="nc" id="L448">      return null;</span>
    }
<span class="pc bpc" id="L450" title="2 of 4 branches missed.">    if (index &lt; 0 || index &gt;= array.length) {</span>
<span class="nc" id="L451">      return array;</span>
    }

<span class="fc" id="L454">    Object[] retVal = (Object[]) Array.newInstance(array[0].getClass(), array.length - 1);</span>
<span class="fc bfc" id="L455" title="All 2 branches covered.">    for (int i = 0; i &lt; array.length; i++) {</span>
<span class="fc bfc" id="L456" title="All 2 branches covered.">      if (i &lt; index) {</span>
<span class="fc" id="L457">        retVal[i] = array[i];</span>
<span class="pc bpc" id="L458" title="1 of 2 branches missed.">      } else if (i &gt; index) {</span>
<span class="nc" id="L459">        retVal[i - 1] = array[i];</span>
      }
    }
<span class="fc" id="L462">    return retVal;</span>
  }

  public static String toString(int[][] a) {
<span class="nc" id="L466">    StringBuilder result = new StringBuilder(&quot;[&quot;);</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">    for (int i = 0; i &lt; a.length; i++) {</span>
<span class="nc" id="L468">      result.append(Arrays.toString(a[i]));</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">      if(i &lt; a.length-1)</span>
<span class="nc" id="L470">        result.append(',');</span>
      }
<span class="nc" id="L472">    result.append(']');</span>
<span class="nc" id="L473">    return result.toString();</span>
  }

  /**
   * Tests two int[][] arrays for having equal contents.
   * @return true iff for each i, &lt;code&gt;equalContents(xs[i],ys[i])&lt;/code&gt; is true
   */
  public static boolean equalContents(int[][] xs, int[][] ys) {
<span class="nc bnc" id="L481" title="All 2 branches missed.">    if(xs ==null)</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">      return ys == null;</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">    if(ys == null)</span>
<span class="nc" id="L484">      return false;</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">    if(xs.length != ys.length)</span>
<span class="nc" id="L486">      return false;</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">    for(int i = xs.length-1; i &gt;= 0; i--) {</span>
<span class="nc bnc" id="L488" title="All 2 branches missed.">      if(! equalContents(xs[i],ys[i]))</span>
<span class="nc" id="L489">        return false;</span>
    }
<span class="nc" id="L491">    return true;</span>
  }

  /**
   * Tests two double[][] arrays for having equal contents.
   * @return true iff for each i, &lt;code&gt;equals(xs[i],ys[i])&lt;/code&gt; is true
   */
  public static boolean equals(double[][] xs, double[][] ys) {
<span class="nc bnc" id="L499" title="All 2 branches missed.">    if(xs == null)</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">      return ys == null;</span>
<span class="nc bnc" id="L501" title="All 2 branches missed.">    if(ys == null)</span>
<span class="nc" id="L502">      return false;</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">    if(xs.length != ys.length)</span>
<span class="nc" id="L504">      return false;</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">    for(int i = xs.length-1; i &gt;= 0; i--) {</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">      if(!Arrays.equals(xs[i],ys[i]))</span>
<span class="nc" id="L507">        return false;</span>
    }
<span class="nc" id="L509">    return true;</span>
  }


  /**
   * tests two int[] arrays for having equal contents
   * @return true iff xs and ys have equal length, and for each i, &lt;code&gt;xs[i]==ys[i]&lt;/code&gt;
   */
  public static boolean equalContents(int[] xs, int[] ys) {
<span class="fc bfc" id="L518" title="All 2 branches covered.">    if(xs.length != ys.length)</span>
<span class="fc" id="L519">      return false;</span>
<span class="fc bfc" id="L520" title="All 2 branches covered.">    for(int i = xs.length-1; i &gt;= 0; i--) {</span>
<span class="pc bpc" id="L521" title="1 of 2 branches missed.">      if(xs[i] != ys[i])</span>
<span class="nc" id="L522">        return false;</span>
    }
<span class="fc" id="L524">    return true;</span>
  }

  /**
   * Tests two boolean[][] arrays for having equal contents.
   * @return true iff for each i, &lt;code&gt;Arrays.equals(xs[i],ys[i])&lt;/code&gt; is true
   */
  @SuppressWarnings(&quot;null&quot;)
  public static boolean equals(boolean[][] xs, boolean[][] ys) {
<span class="nc bnc" id="L533" title="All 4 branches missed.">    if(xs == null &amp;&amp; ys != null)</span>
<span class="nc" id="L534">      return false;</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">    if(ys == null)</span>
<span class="nc" id="L536">      return false;</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">    if(xs.length != ys.length)</span>
<span class="nc" id="L538">      return false;</span>
<span class="nc bnc" id="L539" title="All 2 branches missed.">    for(int i = xs.length-1; i &gt;= 0; i--) {</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">      if(! Arrays.equals(xs[i],ys[i]))</span>
<span class="nc" id="L541">        return false;</span>
    }
<span class="nc" id="L543">    return true;</span>
  }


  /** Returns true iff object o equals (not ==) some element of array a. */
  public static &lt;T&gt; boolean contains(T[] a, T o) {
<span class="fc bfc" id="L549" title="All 2 branches covered.">    for (T item : a) {</span>
<span class="pc bpc" id="L550" title="1 of 2 branches missed.">      if (item.equals(o)) return true;</span>
    }
<span class="fc" id="L552">    return false;</span>
  }

  // from stackoverflow
  //  http://stackoverflow.com/questions/80476/how-to-concatenate-two-arrays-in-java
  /**
   * Concatenates two arrays and returns the result
   */
  public static &lt;T&gt; T[] concatenate(T[] first, T[] second) {
<span class="fc" id="L561">    T[] result = Arrays.copyOf(first, first.length + second.length);</span>
<span class="fc" id="L562">    System.arraycopy(second, 0, result, first.length, second.length);</span>
<span class="fc" id="L563">    return result;</span>
  }

  /**
   * Returns an array with only the elements accepted by &lt;code&gt;filter&lt;/code&gt;
   * &lt;br&gt;
   * Implementation notes: creates two arrays, calls &lt;code&gt;filter&lt;/code&gt;
   * once for each element, does not alter &lt;code&gt;original&lt;/code&gt;
   */
  public static &lt;T&gt; T[] filter(T[] original, Predicate&lt;? super T&gt; filter) {
<span class="fc" id="L573">    T[] result = Arrays.copyOf(original, original.length); // avoids generic array creation compile error</span>
<span class="fc" id="L574">    int size = 0;</span>
<span class="fc bfc" id="L575" title="All 2 branches covered.">    for (T value : original) {</span>
<span class="pc bpc" id="L576" title="1 of 2 branches missed.">      if (filter.test(value)) {</span>
<span class="fc" id="L577">        result[size] = value;</span>
<span class="fc" id="L578">        size++;</span>
      }
    }
<span class="pc bpc" id="L581" title="1 of 2 branches missed.">    if (size == original.length) {</span>
<span class="fc" id="L582">      return result;</span>
    }
<span class="nc" id="L584">    return Arrays.copyOf(result, size);</span>
  }

  /** Return a Set containing the same elements as the specified array.
   */
  public static &lt;T&gt; Set&lt;T&gt; asSet(T[] a) {
<span class="fc" id="L590">    return Generics.newHashSet(Arrays.asList(a));</span>
  }

  /** Return an immutable Set containing the same elements as the specified
   *  array. Arrays with 0 or 1 elements are special cased to return the
   *  efficient small sets from the Collections class.
   */
  public static &lt;T&gt; Set&lt;T&gt; asImmutableSet(T[] a) {
<span class="pc bpc" id="L598" title="1 of 2 branches missed.">    if (a.length == 0) {</span>
<span class="nc" id="L599">      return Collections.emptySet();</span>
<span class="pc bpc" id="L600" title="1 of 2 branches missed.">    } else if (a.length == 1) {</span>
<span class="fc" id="L601">      return Collections.singleton(a[0]);</span>
    } else {
<span class="nc" id="L603">      return Collections.unmodifiableSet(Generics.newHashSet(Arrays.asList(a)));</span>
    }
  }

  public static void fill(double[][] d, double val) {
<span class="nc bnc" id="L608" title="All 2 branches missed.">    for (double[] aD : d) {</span>
<span class="nc" id="L609">      Arrays.fill(aD, val);</span>
    }
<span class="nc" id="L611">  }</span>

  public static void fill(double[][][] d, double val) {
<span class="nc bnc" id="L614" title="All 2 branches missed.">    for (double[][] aD : d) {</span>
<span class="nc" id="L615">      fill(aD, val);</span>
    }
<span class="nc" id="L617">  }</span>

  public static void fill(double[][][][] d, double val) {
<span class="nc bnc" id="L620" title="All 2 branches missed.">    for (double[][][] aD : d) {</span>
<span class="nc" id="L621">      fill(aD, val);</span>
    }
<span class="nc" id="L623">  }</span>

  public static void fill(boolean[][] d, boolean val) {
<span class="nc bnc" id="L626" title="All 2 branches missed.">    for (boolean[] aD : d) {</span>
<span class="nc" id="L627">      Arrays.fill(aD, val);</span>
    }
<span class="nc" id="L629">  }</span>

  public static void fill(boolean[][][] d, boolean val) {
<span class="nc bnc" id="L632" title="All 2 branches missed.">    for (boolean[][] aD : d) {</span>
<span class="nc" id="L633">      fill(aD, val);</span>
    }
<span class="nc" id="L635">  }</span>

  public static void fill(boolean[][][][] d, boolean val) {
<span class="nc bnc" id="L638" title="All 2 branches missed.">    for (boolean[][][] aD : d) {</span>
<span class="nc" id="L639">      fill(aD, val);</span>
    }
<span class="nc" id="L641">  }</span>



  /**
  * Casts to a double array
  */
  public static double[] toDouble(float[] a) {
<span class="nc" id="L649">    double[] d = new double[a.length];</span>
<span class="nc bnc" id="L650" title="All 2 branches missed.">    for (int i = 0; i &lt; a.length; i++) {</span>
<span class="nc" id="L651">      d[i] = a[i];</span>
    }
<span class="nc" id="L653">    return d;</span>
  }

  /**
   * Casts to a double array.
   */
  public static double[] toDouble(int[] array) {
<span class="nc" id="L660">    double[] rv = new double[array.length];</span>
<span class="nc bnc" id="L661" title="All 2 branches missed.">    for (int i = 0; i &lt; array.length; i++) {</span>
<span class="nc" id="L662">      rv[i] = array[i];</span>
    }
<span class="nc" id="L664">    return rv;</span>
  }

  /** needed because Arrays.asList() won't to autoboxing,
   * so if you give it a primitive array you get a
   * singleton list back with just that array as an element.
   */
  public static List&lt;Integer&gt; asList(int[] array) {
<span class="nc" id="L672">    List&lt;Integer&gt; l = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L673" title="All 2 branches missed.">    for (int i : array) {</span>
<span class="nc" id="L674">      l.add(i);</span>
    }
<span class="nc" id="L676">    return l;</span>
  }


  public static double[] asPrimitiveDoubleArray(Collection&lt;Double&gt; d) {
<span class="nc" id="L681">    double[] newD = new double[d.size()];</span>
<span class="nc" id="L682">    int i = 0;</span>
<span class="nc bnc" id="L683" title="All 2 branches missed.">    for (Double j : d) {</span>
<span class="nc" id="L684">      newD[i++] = j;</span>
<span class="nc" id="L685">    }</span>
<span class="nc" id="L686">    return newD;</span>
  }


  public static int[] asPrimitiveIntArray(Collection&lt;Integer&gt; d) {
<span class="nc" id="L691">    int[] newI = new int[d.size()];</span>
<span class="nc" id="L692">    int i = 0;</span>
<span class="nc bnc" id="L693" title="All 2 branches missed.">    for (Integer j : d) {</span>
<span class="nc" id="L694">      newI[i++] = j;</span>
<span class="nc" id="L695">    }</span>
<span class="nc" id="L696">    return newI;</span>
  }

  public static long[] copy(long[] arr) {
<span class="nc bnc" id="L700" title="All 2 branches missed.">    if (arr == null) { return null; }</span>
<span class="nc" id="L701">    long[] newArr = new long[arr.length];</span>
<span class="nc" id="L702">    System.arraycopy(arr, 0, newArr, 0, arr.length);</span>
<span class="nc" id="L703">    return newArr;</span>
  }

  public static int[] copy(int[] i) {
<span class="pc bpc" id="L707" title="1 of 2 branches missed.">    if (i == null) { return null; }</span>
<span class="fc" id="L708">    int[] newI = new int[i.length];</span>
<span class="fc" id="L709">    System.arraycopy(i, 0, newI, 0, i.length);</span>
<span class="fc" id="L710">    return newI;</span>
  }

  public static int[][] copy(int[][] i) {
<span class="nc bnc" id="L714" title="All 2 branches missed.">    if (i == null) { return null; }</span>
<span class="nc" id="L715">    int[][] newI = new int[i.length][];</span>
<span class="nc bnc" id="L716" title="All 2 branches missed.">    for (int j = 0; j &lt; newI.length; j++) {</span>
<span class="nc" id="L717">      newI[j] = copy(i[j]);</span>
    }
<span class="nc" id="L719">    return newI;</span>
  }


  public static double[] copy(double[] d) {
<span class="nc bnc" id="L724" title="All 2 branches missed.">    if (d == null) { return null; }</span>
<span class="nc" id="L725">    double[] newD = new double[d.length];</span>
<span class="nc" id="L726">    System.arraycopy(d, 0, newD, 0, d.length);</span>
<span class="nc" id="L727">    return newD;</span>
  }

  public static double[][] copy(double[][] d) {
<span class="nc bnc" id="L731" title="All 2 branches missed.">    if (d == null) { return null; }</span>
<span class="nc" id="L732">    double[][] newD = new double[d.length][];</span>
<span class="nc bnc" id="L733" title="All 2 branches missed.">    for (int i = 0; i &lt; newD.length; i++) {</span>
<span class="nc" id="L734">      newD[i] = copy(d[i]);</span>
    }
<span class="nc" id="L736">    return newD;</span>
  }

  public static double[][][] copy(double[][][] d) {
<span class="nc bnc" id="L740" title="All 2 branches missed.">    if (d == null) { return null; }</span>
<span class="nc" id="L741">    double[][][] newD = new double[d.length][][];</span>
<span class="nc bnc" id="L742" title="All 2 branches missed.">    for (int i = 0; i &lt; newD.length; i++) {</span>
<span class="nc" id="L743">      newD[i] = copy(d[i]);</span>
    }
<span class="nc" id="L745">    return newD;</span>
  }

  public static float[] copy(float[] d) {
<span class="nc bnc" id="L749" title="All 2 branches missed.">    if (d == null) { return null; }</span>
<span class="nc" id="L750">    float[] newD = new float[d.length];</span>
<span class="nc" id="L751">    System.arraycopy(d, 0, newD, 0, d.length);</span>
<span class="nc" id="L752">    return newD;</span>
  }

  public static float[][] copy(float[][] d) {
<span class="nc bnc" id="L756" title="All 2 branches missed.">    if (d == null) { return null; }</span>
<span class="nc" id="L757">    float[][] newD = new float[d.length][];</span>
<span class="nc bnc" id="L758" title="All 2 branches missed.">    for (int i = 0; i &lt; newD.length; i++) {</span>
<span class="nc" id="L759">      newD[i] = copy(d[i]);</span>
    }
<span class="nc" id="L761">    return newD;</span>
  }

  public static float[][][] copy(float[][][] d) {
<span class="nc bnc" id="L765" title="All 2 branches missed.">    if (d == null) { return null; }</span>
<span class="nc" id="L766">    float[][][] newD = new float[d.length][][];</span>
<span class="nc bnc" id="L767" title="All 2 branches missed.">    for (int i = 0; i &lt; newD.length; i++) {</span>
<span class="nc" id="L768">      newD[i] = copy(d[i]);</span>
    }
<span class="nc" id="L770">    return newD;</span>
  }

  public static String toString(double[][] b) {
<span class="nc" id="L774">    StringBuilder result = new StringBuilder(&quot;[&quot;);</span>
<span class="nc bnc" id="L775" title="All 2 branches missed.">    for (int i = 0; i &lt; b.length; i++) {</span>
<span class="nc" id="L776">      result.append(Arrays.toString(b[i]));</span>
<span class="nc bnc" id="L777" title="All 2 branches missed.">      if(i &lt; b.length-1)</span>
<span class="nc" id="L778">        result.append(',');</span>
      }
<span class="nc" id="L780">    result.append(']');</span>
<span class="nc" id="L781">    return result.toString();</span>
  }

  public static String toString(boolean[][] b) {
<span class="nc" id="L785">    StringBuilder result = new StringBuilder(&quot;[&quot;);</span>
<span class="nc bnc" id="L786" title="All 2 branches missed.">    for (int i = 0; i &lt; b.length; i++) {</span>
<span class="nc" id="L787">      result.append(Arrays.toString(b[i]));</span>
<span class="nc bnc" id="L788" title="All 2 branches missed.">      if(i &lt; b.length-1)</span>
<span class="nc" id="L789">        result.append(',');</span>
      }
<span class="nc" id="L791">    result.append(']');</span>
<span class="nc" id="L792">    return result.toString();</span>
  }

  public static long[] toPrimitive(Long[] in) {
<span class="nc" id="L796">    return toPrimitive(in,0L);</span>
  }

  public static int[] toPrimitive(Integer[] in) {
<span class="nc" id="L800">    return toPrimitive(in,0);</span>
  }

  public static short[] toPrimitive(Short[] in) {
<span class="nc" id="L804">    return toPrimitive(in,(short)0);</span>
  }

  public static char[] toPrimitive(Character[] in) {
<span class="nc" id="L808">    return toPrimitive(in,(char)0);</span>
  }

  public static double[] toPrimitive(Double[] in) {
<span class="nc" id="L812">    return toPrimitive(in,0.0);</span>
  }

  public static long[] toPrimitive(Long[] in, long valueForNull) {
<span class="nc bnc" id="L816" title="All 2 branches missed.">    if (in == null)</span>
<span class="nc" id="L817">      return null;</span>
<span class="nc" id="L818">    final long[] out = new long[in.length];</span>
<span class="nc bnc" id="L819" title="All 2 branches missed.">    for (int i = 0; i &lt; in.length; i++) {</span>
<span class="nc" id="L820">      Long b = in[i];</span>
<span class="nc bnc" id="L821" title="All 2 branches missed.">      out[i] = (b == null ? valueForNull : b);</span>
    }
<span class="nc" id="L823">    return out;</span>
  }

  public static int[] toPrimitive(Integer[] in, int valueForNull) {
<span class="nc bnc" id="L827" title="All 2 branches missed.">    if (in == null)</span>
<span class="nc" id="L828">      return null;</span>
<span class="nc" id="L829">    final int[] out = new int[in.length];</span>
<span class="nc bnc" id="L830" title="All 2 branches missed.">    for (int i = 0; i &lt; in.length; i++) {</span>
<span class="nc" id="L831">      Integer b = in[i];</span>
<span class="nc bnc" id="L832" title="All 2 branches missed.">      out[i] = (b == null ? valueForNull : b);</span>
    }
<span class="nc" id="L834">    return out;</span>
  }

   public static short[] toPrimitive(Short[] in, short valueForNull) {
<span class="nc bnc" id="L838" title="All 2 branches missed.">    if (in == null)</span>
<span class="nc" id="L839">      return null;</span>
<span class="nc" id="L840">    final short[] out = new short[in.length];</span>
<span class="nc bnc" id="L841" title="All 2 branches missed.">    for (int i = 0; i &lt; in.length; i++) {</span>
<span class="nc" id="L842">      Short b = in[i];</span>
<span class="nc bnc" id="L843" title="All 2 branches missed.">      out[i] = (b == null ? valueForNull : b);</span>
    }
<span class="nc" id="L845">    return out;</span>
  }

   public static char[] toPrimitive(Character[] in, char valueForNull) {
<span class="nc bnc" id="L849" title="All 2 branches missed.">    if (in == null)</span>
<span class="nc" id="L850">      return null;</span>
<span class="nc" id="L851">    final char[] out = new char[in.length];</span>
<span class="nc bnc" id="L852" title="All 2 branches missed.">    for (int i = 0; i &lt; in.length; i++) {</span>
<span class="nc" id="L853">      Character b = in[i];</span>
<span class="nc bnc" id="L854" title="All 2 branches missed.">      out[i] = (b == null ? valueForNull : b);</span>
    }
<span class="nc" id="L856">    return out;</span>
  }

  public static double[] toDoubleArray(String[] in) {
<span class="nc" id="L860">    double[] ret = new double[in.length];</span>
<span class="nc bnc" id="L861" title="All 2 branches missed.">    for (int i = 0; i &lt; in.length; i++)</span>
<span class="nc" id="L862">      ret[i] = Double.parseDouble(in[i]);</span>

<span class="nc" id="L864">    return ret;</span>
  }

  public static double[] toPrimitive(Double[] in, double valueForNull) {
<span class="nc bnc" id="L868" title="All 2 branches missed.">    if (in == null)</span>
<span class="nc" id="L869">      return null;</span>
<span class="nc" id="L870">    final double[] out = new double[in.length];</span>
<span class="nc bnc" id="L871" title="All 2 branches missed.">    for (int i = 0; i &lt; in.length; i++) {</span>
<span class="nc" id="L872">      Double b = in[i];</span>
<span class="nc bnc" id="L873" title="All 2 branches missed.">      out[i] = (b == null ? valueForNull : b);</span>
    }
<span class="nc" id="L875">    return out;</span>
  }

  /**
   * Provides a consistent ordering over arrays. First compares by the
   * first element. If that element is equal, the next element is
   * considered, and so on. This is the array version of
   * {@link edu.stanford.nlp.util.CollectionUtils#compareLists}
   * and uses the same logic when the arrays are of different lengths.
   */
  public static &lt;T extends Comparable&lt;T&gt;&gt; int compareArrays(T[] first, T[] second) {
<span class="fc" id="L886">    List&lt;T&gt; firstAsList = Arrays.asList(first);</span>
<span class="fc" id="L887">    List&lt;T&gt; secondAsList = Arrays.asList(second);</span>
<span class="fc" id="L888">    return CollectionUtils.compareLists(firstAsList, secondAsList);</span>
  }

  /* -- This is an older more direct implementation of the above, but not necessary unless for performance
   public static &lt;C extends Comparable&lt;C&gt;&gt; int compareArrays(C[] a1, C[] a2) {
    int len = Math.min(a1.length, a2.length);
    for (int i = 0; i &lt; len; i++) {
      int comparison = a1[i].compareTo(a2[i]);
      if (comparison != 0) return comparison;
    }
    // one is a prefix of the other, or they're identical
    if (a1.length &lt; a2.length) return -1;
    if (a1.length &gt; a2.length) return 1;
    return 0;
  }
   */

  public static List&lt;Integer&gt; getSubListIndex(Object[] tofind, Object[] tokens){
<span class="fc" id="L906">     return getSubListIndex(tofind, tokens, (o1) -&gt; o1.first().equals(o1.second()));</span>
  }

  /**
   * If tofind is a part of tokens, it finds the ****starting index***** of tofind in tokens
   * If tofind is not a sub-array of tokens, then it returns null
   * note that tokens sublist should have the exact elements and order as in tofind
   * @param tofind array you want to find in tokens
   * @param tokens
   * @param matchingFunction function that takes (tofindtoken, token) pair and returns whether they match
   * @return starting index of the sublist
   */
  public static List&lt;Integer&gt; getSubListIndex(Object[] tofind, Object[] tokens, Function&lt;Pair, Boolean&gt; matchingFunction){
<span class="pc bpc" id="L919" title="1 of 2 branches missed.">    if(tofind.length &gt; tokens.length)</span>
<span class="nc" id="L920">      return null;</span>
<span class="fc" id="L921">    List&lt;Integer&gt; allIndices = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L922">    boolean matched = false;</span>
<span class="fc" id="L923">    int index = -1;</span>
<span class="fc" id="L924">    int lastUnmatchedIndex = 0;</span>
<span class="fc bfc" id="L925" title="All 2 branches covered.">    for(int i = 0 ; i &lt; tokens.length;){</span>
<span class="pc bpc" id="L926" title="1 of 2 branches missed.">      for(int j = 0; j &lt; tofind.length ;){</span>
<span class="fc bfc" id="L927" title="All 2 branches covered.">        if(matchingFunction.apply(new Pair(tofind[j], tokens[i]))){</span>
<span class="fc" id="L928">          index = i;</span>
<span class="fc" id="L929">          i++;</span>
<span class="fc" id="L930">          j++;</span>
<span class="fc bfc" id="L931" title="All 2 branches covered.">          if(j == tofind.length)</span>
          {
<span class="fc" id="L933">            matched = true;</span>
<span class="fc" id="L934">            break;</span>
          }
        }else{
<span class="fc" id="L937">          j = 0;</span>
<span class="fc" id="L938">          i = lastUnmatchedIndex +1;</span>
<span class="fc" id="L939">          lastUnmatchedIndex = i;</span>
<span class="fc" id="L940">          index = -1;</span>
<span class="fc bfc" id="L941" title="All 2 branches covered.">          if(lastUnmatchedIndex == tokens.length)</span>
<span class="fc" id="L942">            break;</span>
        }
<span class="fc bfc" id="L944" title="All 2 branches covered.">        if(i &gt;= tokens.length){</span>
<span class="fc" id="L945">          index = -1;</span>
<span class="fc" id="L946">          break;</span>
        }
      }
<span class="pc bpc" id="L949" title="1 of 4 branches missed.">      if(i == tokens.length || matched){</span>
<span class="fc bfc" id="L950" title="All 2 branches covered.">        if(index &gt;= 0)</span>
          //index = index - l1.length + 1;
<span class="fc" id="L952">          allIndices.add(index - tofind.length + 1);</span>
<span class="fc" id="L953">        matched = false;</span>
<span class="fc" id="L954">        lastUnmatchedIndex = index;</span>

        //break;
      }
    }
    //get starting point

<span class="fc" id="L961">    return allIndices;</span>
  }

  /** Returns a new array which has the numbers in the input array
   *  L1-normalized.
   *
   *  @param ar Input array
   *  @return New array that has L1 normalized form of input array
   */
  public static double[] normalize(double[] ar) {
<span class="nc" id="L971">    double[] ar2 = new double[ar.length];</span>
<span class="nc" id="L972">    double total = 0.0;</span>
<span class="nc bnc" id="L973" title="All 2 branches missed.">    for (double d : ar) {</span>
<span class="nc" id="L974">      total += d;</span>
    }
<span class="nc bnc" id="L976" title="All 2 branches missed.">    for (int i = 0; i &lt; ar.length; i++) {</span>
<span class="nc" id="L977">      ar2[i] = ar[i]/total;</span>
    }
<span class="nc" id="L979">    return ar2;</span>
  }

  public static Object[] subArray(Object[] arr, int startindexInclusive, int endindexExclusive){
<span class="nc bnc" id="L983" title="All 2 branches missed.">    if(arr == null)</span>
<span class="nc" id="L984">      return arr;</span>
<span class="nc" id="L985">    Class type = arr.getClass().getComponentType();</span>
<span class="nc bnc" id="L986" title="All 4 branches missed.">    if(endindexExclusive &lt; startindexInclusive || startindexInclusive &gt; arr.length -1 )</span>
<span class="nc" id="L987">      return (Object[]) Array.newInstance(type, 0);</span>
<span class="nc bnc" id="L988" title="All 2 branches missed.">    if(endindexExclusive &gt; arr.length)</span>
<span class="nc" id="L989">      endindexExclusive = arr.length;</span>
<span class="nc bnc" id="L990" title="All 2 branches missed.">    if(startindexInclusive &lt; 0)</span>
<span class="nc" id="L991">      startindexInclusive = 0;</span>
<span class="nc" id="L992">    Object[] b = (Object[]) Array.newInstance(type, endindexExclusive - startindexInclusive);</span>
<span class="nc" id="L993">    System.arraycopy(arr, startindexInclusive, b, 0, endindexExclusive - startindexInclusive);</span>
<span class="nc" id="L994">    return b;</span>
  }

  public static int compareBooleanArrays(boolean[] a1, boolean[] a2) {
<span class="nc" id="L998">    int len = Math.min(a1.length, a2.length);</span>
<span class="nc bnc" id="L999" title="All 2 branches missed.">    for (int i = 0; i &lt; len; i++) {</span>
<span class="nc bnc" id="L1000" title="All 4 branches missed.">      if (!a1[i] &amp;&amp; a2[i]) return -1;</span>
<span class="nc bnc" id="L1001" title="All 4 branches missed.">      if (a1[i] &amp;&amp; !a2[i]) return 1;</span>
    }
    // one is a prefix of the other, or they're identical
<span class="nc bnc" id="L1004" title="All 2 branches missed.">    if (a1.length &lt; a2.length) return -1;</span>
<span class="nc bnc" id="L1005" title="All 2 branches missed.">    if (a1.length &gt; a2.length) return 1;</span>
<span class="nc" id="L1006">    return 0;</span>
  }

  public static String toString(double[] doubles, String glue) {
<span class="nc" id="L1010">    String s = &quot;&quot;;</span>
<span class="nc bnc" id="L1011" title="All 2 branches missed.">    for(int i = 0; i &lt; doubles.length; i++){</span>
<span class="nc bnc" id="L1012" title="All 2 branches missed.">      if(i==0)</span>
<span class="nc" id="L1013">        s = String.valueOf(doubles[i]);</span>
      else
<span class="nc" id="L1015">        s+= glue + String.valueOf(doubles[i]);</span>
    }
<span class="nc" id="L1017">    return s;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>