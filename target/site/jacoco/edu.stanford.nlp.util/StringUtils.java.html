<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StringUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.util</a> &gt; <span class="el_source">StringUtils.java</span></div><h1>StringUtils.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.util;

import edu.stanford.nlp.io.IOUtils;
import edu.stanford.nlp.io.RuntimeIOException;
import edu.stanford.nlp.ling.CoreAnnotations;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.ling.HasOffset;
import edu.stanford.nlp.ling.HasWord;
import edu.stanford.nlp.math.SloppyMath;
import edu.stanford.nlp.util.logging.Redwood;

import java.io.*;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.text.Normalizer;
import java.util.*;
import java.util.Map.Entry;
import java.util.function.Function;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Stream;

/**
 * StringUtils is a class for random String things, including output formatting and command line argument parsing.
 * &lt;p&gt;
 * Many of these methods will be familiar to perl users: {@link #join(Iterable)}, {@link #split(String, String)}, {@link
 * #trim(String, int)}, {@link #find(String, String)}, {@link #lookingAt(String, String)}, and {@link #matches(String,
 * String)}.
 * &lt;p&gt;
 * There are also useful methods for padding Strings/Objects with spaces on the right or left for printing even-width
 * table columns: {@link #padLeft(int, int)}, {@link #pad(String, int)}.
 *
 * &lt;p&gt;Example: print a comma-separated list of numbers:&lt;/p&gt;
 * &lt;p&gt;{@code System.out.println(StringUtils.pad(nums, &amp;quot;, &amp;quot;));}&lt;/p&gt;
 * &lt;p&gt;Example: print a 2D array of numbers with 8-char cells:&lt;/p&gt;
 * &lt;p&gt;&lt;code&gt;for(int i = 0; i &amp;lt; nums.length; i++) {&lt;br&gt;
 * &amp;nbsp;&amp;nbsp;&amp;nbsp; for(int j = 0; j &amp;lt; nums[i].length; j++) {&lt;br&gt;
 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
 * System.out.print(StringUtils.leftPad(nums[i][j], 8));&lt;br&gt;
 * &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br&gt;
 * &amp;nbsp;&amp;nbsp;&amp;nbsp; System.out.println();&lt;br&gt;
 * &lt;/code&gt;&lt;/p&gt;
 *
 * @author Dan Klein
 * @author Christopher Manning
 * @author Tim Grow (grow@stanford.edu)
 * @author Chris Cox
 * @version 2006/02/03
 */
<span class="pc bpc" id="L51" title="1 of 2 branches missed.">public class StringUtils  {</span>

  // todo [cdm 2016]: Remove CoreMap/CoreLabel methods from this class
  // todo [cdm 2016]: Write a really good join method for this class, like William's Ruby one

  /** A logger for this class */
<span class="fc" id="L57">  private static final Redwood.RedwoodChannels log = Redwood.channels(StringUtils.class);</span>

  /**
   * Don't let anyone instantiate this class.
   */
<span class="nc" id="L62">  private StringUtils() {}</span>

<span class="fc" id="L64">  public static final String[] EMPTY_STRING_ARRAY = new String[0];</span>
  private static final String PROP = &quot;prop&quot;;
  private static final String PROPS = &quot;props&quot;;
  private static final String PROPERTIES = &quot;properties&quot;;
  private static final String ARGS = &quot;args&quot;;
  private static final String ARGUMENTS = &quot;arguments&quot;;

  /**
   * Say whether this regular expression can be found inside
   * this String.  This method provides one of the two &quot;missing&quot;
   * convenience methods for regular expressions in the String class
   * in JDK1.4.  This is the one you'll want to use all the time if
   * you're used to Perl.  What were they smoking?
   *
   * @param str   String to search for match in
   * @param regex String to compile as the regular expression
   * @return Whether the regex can be found in str
   */
  public static boolean find(String str, String regex) {
<span class="fc" id="L83">    return Pattern.compile(regex).matcher(str).find();</span>
  }

  /**
   * Convenience method: a case-insensitive variant of Collection.contains.
   *
   * @param c Collection&amp;lt;String&amp;gt;
   * @param s String
   * @return true if s case-insensitively matches a string in c
   */
  public static boolean containsIgnoreCase(Collection&lt;String&gt; c, String s) {
<span class="nc bnc" id="L94" title="All 2 branches missed.">    for (String sPrime: c) {</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">      if (sPrime.equalsIgnoreCase(s))</span>
<span class="nc" id="L96">        return true;</span>
<span class="nc" id="L97">    }</span>
<span class="nc" id="L98">    return false;</span>
  }

  /**
   * Say whether this regular expression can be found at the beginning of
   * this String.  This method provides one of the two &quot;missing&quot;
   * convenience methods for regular expressions in the String class
   * in JDK1.4.
   *
   * @param str   String to search for match at start of
   * @param regex String to compile as the regular expression
   * @return Whether the regex can be found at the start of str
   */
  public static boolean lookingAt(String str, String regex) {
<span class="nc" id="L112">    return Pattern.compile(regex).matcher(str).lookingAt();</span>
  }

  /**
   * Takes a string of the form &quot;x1=y1,x2=y2,...&quot; such
   * that each y is an integer and each x is a key.  A
   * String[] s is returned such that s[yn]=xn.
   *
   * @param map A string of the form &quot;x1=y1,x2=y2,...&quot; such
   *     that each y is an integer and each x is a key.
   * @return  A String[] s is returned such that s[yn]=xn
   */
  public static String[] mapStringToArray(String map) {
<span class="fc" id="L125">    String[] m = map.split(&quot;[,;]&quot;);</span>
<span class="fc" id="L126">    int maxIndex = 0;</span>
<span class="fc" id="L127">    String[] keys = new String[m.length];</span>
<span class="fc" id="L128">    int[] indices = new int[m.length];</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">    for (int i = 0; i &lt; m.length; i++) {</span>
<span class="fc" id="L130">      int index = m[i].lastIndexOf('=');</span>
<span class="fc" id="L131">      keys[i] = m[i].substring(0, index);</span>
<span class="fc" id="L132">      indices[i] = Integer.parseInt(m[i].substring(index + 1));</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">      if (indices[i] &gt; maxIndex) {</span>
<span class="fc" id="L134">        maxIndex = indices[i];</span>
      }
    }
<span class="fc" id="L137">    String[] mapArr = new String[maxIndex + 1];</span>
    // Arrays.fill(mapArr, null); // not needed; Java arrays zero initialized
<span class="fc bfc" id="L139" title="All 2 branches covered.">    for (int i = 0; i &lt; m.length; i++) {</span>
<span class="fc" id="L140">      mapArr[indices[i]] = keys[i];</span>
    }
<span class="fc" id="L142">    return mapArr;</span>
  }


  /**
   * Takes a string of the form &quot;x1=y1,x2=y2,...&quot; and returns Map.
   *
   * @param map A string of the form &quot;x1=y1,x2=y2,...&quot;
   * @return  A Map m is returned such that m.get(xn) = yn
   */
  public static Map&lt;String, String&gt; mapStringToMap(String map) {
<span class="nc" id="L153">    String[] m = map.split(&quot;[,;]&quot;);</span>
<span class="nc" id="L154">    Map&lt;String, String&gt; res = Generics.newHashMap();</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">    for (String str : m) {</span>
<span class="nc" id="L156">      int index = str.lastIndexOf('=');</span>
<span class="nc" id="L157">      String key = str.substring(0, index);</span>
<span class="nc" id="L158">      String val = str.substring(index + 1);</span>
<span class="nc" id="L159">      res.put(key.trim(), val.trim());</span>
    }
<span class="nc" id="L161">    return res;</span>
  }

  public static List&lt;Pattern&gt; regexesToPatterns(Iterable&lt;String&gt; regexes) {
<span class="nc" id="L165">    List&lt;Pattern&gt; patterns = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">    for (String regex:regexes) {</span>
<span class="nc" id="L167">      patterns.add(Pattern.compile(regex));</span>
<span class="nc" id="L168">    }</span>
<span class="nc" id="L169">    return patterns;</span>
  }

  /**
   * Given a pattern, which contains one or more capturing groups, and a String,
   * returns a list with the values of the
   * captured groups in the pattern. If the pattern does not match, returns
   * null. Note that this uses Matcher.find() rather than Matcher.matches().
   * If str is null, returns null.
   */
  public static List&lt;String&gt; regexGroups(Pattern regex, String str) {
<span class="pc bpc" id="L180" title="1 of 2 branches missed.">    if (str == null) {</span>
<span class="nc" id="L181">      return null;</span>
    }

<span class="fc" id="L184">    Matcher matcher = regex.matcher(str);</span>
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">    if ( ! matcher.find()) {</span>
<span class="nc" id="L186">      return null;</span>
    }

<span class="fc" id="L189">    List&lt;String&gt; groups = new ArrayList&lt;&gt;(matcher.groupCount());</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">    for (int index = 1; index &lt;= matcher.groupCount(); index++) {</span>
<span class="fc" id="L191">      groups.add(matcher.group(index));</span>
    }

<span class="fc" id="L194">    return groups;</span>
  }

  /**
   * Say whether this regular expression matches
   * this String.  This method is the same as the String.matches() method,
   * and is included just to give a call that is parallel to the other
   * static regex methods in this class.
   *
   * @param str   String to search for match at start of
   * @param regex String to compile as the regular expression
   * @return Whether the regex matches the whole of this str
   */
  public static boolean matches(String str, String regex) {
<span class="nc" id="L208">    return Pattern.compile(regex).matcher(str).matches();</span>
  }


  public static Set&lt;String&gt; stringToSet(String str, String delimiter)
  {
<span class="nc" id="L214">    Set&lt;String&gt; ret = null;</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">    if (str != null) {</span>
<span class="nc" id="L216">      String[] fields = str.split(delimiter);</span>
<span class="nc" id="L217">      ret = Generics.newHashSet(fields.length);</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">      for (String field:fields) {</span>
<span class="nc" id="L219">        field = field.trim();</span>
<span class="nc" id="L220">        ret.add(field);</span>
      }
    }
<span class="nc" id="L223">    return ret;</span>
  }


  public static String joinWords(Iterable&lt;? extends HasWord&gt; l, String glue) {
<span class="nc bnc" id="L228" title="All 2 branches missed.">    StringBuilder sb = new StringBuilder(l instanceof Collection ? ((Collection) l).size() : 64);</span>
<span class="nc" id="L229">    boolean first = true;</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">    for (HasWord o : l) {</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">      if ( ! first) {</span>
<span class="nc" id="L232">        sb.append(glue);</span>
      } else {
<span class="nc" id="L234">        first = false;</span>
      }
<span class="nc" id="L236">      sb.append(o.word());</span>
<span class="nc" id="L237">    }</span>
<span class="nc" id="L238">    return sb.toString();</span>
  }


  public static &lt;E&gt; String join(List&lt;? extends E&gt; l, String glue, Function&lt;E,String&gt; toStringFunc, int start, int end) {
<span class="nc" id="L243">    StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L244">    boolean first = true;</span>
<span class="nc" id="L245">    start = Math.max(start, 0);</span>
<span class="nc" id="L246">    end = Math.min(end, l.size());</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">    for (int i = start; i &lt; end; i++) {</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">      if ( ! first) {</span>
<span class="nc" id="L249">        sb.append(glue);</span>
      } else {
<span class="nc" id="L251">        first = false;</span>
      }
<span class="nc" id="L253">      sb.append(toStringFunc.apply(l.get(i)));</span>
    }
<span class="nc" id="L255">    return sb.toString();</span>
  }

  public static String joinWords(List&lt;? extends HasWord&gt; l, String glue, int start, int end) {
<span class="nc" id="L259">    return join(l, glue, HasWord::word, start, end);</span>
  }

<span class="fc" id="L262">  private static final Function&lt;Object,String&gt; DEFAULT_TOSTRING = Object::toString;</span>

  public static String joinFields(List&lt;? extends CoreMap&gt; l, final Class field, final String defaultFieldValue,
                                  String glue, int start, int end, final Function&lt;Object,String&gt; toStringFunc) {
<span class="nc" id="L266">    return join(l, glue, new Function&lt;CoreMap, String&gt;() {</span>
      public String apply(CoreMap in) {
<span class="nc" id="L268">        Object val = in.get(field);</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">        return (val != null)? toStringFunc.apply(val):defaultFieldValue;</span>
      }
    }, start, end);
  }

  public static String joinFields(List&lt;? extends CoreMap&gt; l, final Class field, final String defaultFieldValue,
                                  String glue, int start, int end) {
<span class="nc" id="L276">    return joinFields(l, field, defaultFieldValue, glue, start, end, DEFAULT_TOSTRING);</span>
  }

  public static String joinFields(List&lt;? extends CoreMap&gt; l, final Class field, final Function&lt;Object,String&gt; toStringFunc) {
<span class="nc" id="L280">    return joinFields(l, field, &quot;-&quot;, &quot; &quot;, 0, l.size(), toStringFunc);</span>
  }

  public static String joinFields(List&lt;? extends CoreMap&gt; l, final Class field) {
<span class="nc" id="L284">    return joinFields(l, field, &quot;-&quot;, &quot; &quot;, 0, l.size());</span>
  }

  public static String joinMultipleFields(List&lt;? extends CoreMap&gt; l, final Class[] fields, final String defaultFieldValue,
                                          final String fieldGlue, String glue, int start, int end, final Function&lt;Object,String&gt; toStringFunc) {
<span class="nc" id="L289">    return join(l, glue, (Function&lt;CoreMap, String&gt;) in -&gt; {</span>
<span class="nc" id="L290">      StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">      for (Class field: fields) {</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">        if (sb.length() &gt; 0) {</span>
<span class="nc" id="L293">          sb.append(fieldGlue);</span>
        }
<span class="nc" id="L295">        Object val = in.get(field);</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">        String str = (val != null)? toStringFunc.apply(val):defaultFieldValue;</span>
<span class="nc" id="L297">        sb.append(str);</span>
      }
<span class="nc" id="L299">      return sb.toString();</span>
    }, start, end);
  }

  public static String joinMultipleFields(List&lt;? extends CoreMap&gt; l, final Class[] fields, final Function&lt;Object,String&gt; toStringFunc) {
<span class="nc" id="L304">    return joinMultipleFields(l, fields, &quot;-&quot;, &quot;/&quot;, &quot; &quot;, 0, l.size(), toStringFunc);</span>
  }

  public static String joinMultipleFields(List&lt;? extends CoreMap&gt; l, final Class[] fields, final String defaultFieldValue,
                                          final String fieldGlue, String glue, int start, int end) {
<span class="nc" id="L309">    return joinMultipleFields(l, fields, defaultFieldValue, fieldGlue, glue, start, end, DEFAULT_TOSTRING);</span>
  }

  public static String joinMultipleFields(List&lt;? extends CoreMap&gt; l, final Class[] fields) {
<span class="nc" id="L313">    return joinMultipleFields(l, fields, &quot;-&quot;, &quot;/&quot;, &quot; &quot;, 0, l.size());</span>
  }

  /**
   * Joins all the tokens together (more or less) according to their original whitespace.
   * It assumes all whitespace was &quot; &quot;.
   *
   * @param tokens list of tokens which implement {@link HasOffset} and {@link HasWord}
   * @return a string of the tokens with the appropriate amount of spacing
   */
  public static String joinWithOriginalWhiteSpace(List&lt;CoreLabel&gt; tokens) {
<span class="nc bnc" id="L324" title="All 2 branches missed.">    if (tokens.isEmpty()) {</span>
<span class="nc" id="L325">      return &quot;&quot;;</span>
    }

<span class="nc" id="L328">    CoreLabel lastToken = tokens.get(0);</span>
<span class="nc" id="L329">    StringBuilder buffer = new StringBuilder(lastToken.word());</span>

<span class="nc bnc" id="L331" title="All 2 branches missed.">    for (int i = 1; i &lt; tokens.size(); i++) {</span>
<span class="nc" id="L332">      CoreLabel currentToken = tokens.get(i);</span>
<span class="nc" id="L333">      int numSpaces = currentToken.beginPosition() - lastToken.endPosition();</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">      if (numSpaces &lt; 0) {</span>
<span class="nc" id="L335">        numSpaces = 0;</span>
      }

<span class="nc" id="L338">      buffer.append(repeat(' ', numSpaces)).append(currentToken.word());</span>
<span class="nc" id="L339">      lastToken = currentToken;</span>
    }

<span class="nc" id="L342">    return buffer.toString();</span>
  }

  /**
   * Joins each elem in the {@link Iterable} with the given glue.
   * For example, given a list of {@code Integers}, you can create
   * a comma-separated list by calling {@code join(numbers, &quot;, &quot;)}.
   *
   * @see StringUtils#join(Stream, String)
   */
  public static &lt;X&gt; String join(Iterable&lt;X&gt; l, String glue) {
<span class="fc" id="L353">    StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L354">    boolean first = true;</span>
<span class="fc bfc" id="L355" title="All 2 branches covered.">    for (X o : l) {</span>
<span class="fc bfc" id="L356" title="All 2 branches covered.">      if ( ! first) {</span>
<span class="fc" id="L357">        sb.append(glue);</span>
      } else {
<span class="fc" id="L359">        first = false;</span>
      }
<span class="fc" id="L361">      sb.append(o);</span>
<span class="fc" id="L362">    }</span>
<span class="fc" id="L363">    return sb.toString();</span>
  }

  /**
   * Joins each elem in the {@link Stream} with the given glue.
   * For example, given a list of {@code Integers}, you can create
   * a comma-separated list by calling {@code join(numbers, &quot;, &quot;)}.
   *
   * @see StringUtils#join(Iterable, String)
   */
  public static &lt;X&gt; String join(Stream&lt;X&gt; l, String glue) {
<span class="fc" id="L374">    StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L375">    boolean first = true;</span>
<span class="fc" id="L376">    Iterator&lt;X&gt; iter = l.iterator();</span>
<span class="fc bfc" id="L377" title="All 2 branches covered.">    while (iter.hasNext()) {</span>
<span class="fc bfc" id="L378" title="All 2 branches covered.">      if ( ! first) {</span>
<span class="fc" id="L379">        sb.append(glue);</span>
      } else {
<span class="fc" id="L381">        first = false;</span>
      }
<span class="fc" id="L383">      sb.append(iter.next());</span>
    }
<span class="fc" id="L385">    return sb.toString();</span>
  }

  /**
   * Joins each elem in the array with the given glue. For example, given a
   * list of ints, you can create a comma-separated list by calling
   * {@code join(numbers, &quot;, &quot;)}.
   */
  public static String join(Object[] elements, String glue) {
<span class="fc" id="L394">    return (join(Arrays.asList(elements), glue));</span>
  }

  /**
   * Joins an array of elements in a given span.
   * @param elements The elements to join.
   * @param start The start index to join from.
   * @param end The end (non-inclusive) to join until.
   * @param glue The glue to hold together the elements.
   * @return The string form of the sub-array, joined on the given glue.
   */
  public static String join(Object[] elements, int start, int end, String glue) {
<span class="nc" id="L406">    StringBuilder b = new StringBuilder(127);</span>
<span class="nc" id="L407">    boolean isFirst = true;</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">    for (int i = start; i &lt; end; ++i) {</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">      if (isFirst) {</span>
<span class="nc" id="L410">        b.append(elements[i].toString());</span>
<span class="nc" id="L411">        isFirst = false;</span>
      } else {
<span class="nc" id="L413">        b.append(glue).append(elements[i].toString());</span>
      }
    }
<span class="nc" id="L416">    return b.toString();</span>
  }

  /**
   * Joins each element in the given array with the given glue. For example,
   * given an array of Integers, you can create a comma-separated list by calling
   * {@code join(numbers, &quot;, &quot;)}.
   */
  public static String join(String[] items, String glue) {
<span class="fc" id="L425">    return join(Arrays.asList(items), glue);</span>
  }


  /**
   * Joins elems with a space.
   */
  public static String join(Iterable&lt;?&gt; l) {
<span class="nc" id="L433">    return join(l, &quot; &quot;);</span>
  }

  /**
   * Joins elements with a space.
   */
  public static String join(Object[] elements) {
<span class="fc" id="L440">    return (join(elements, &quot; &quot;));</span>
  }


  /**
   * Splits on whitespace (\\s+).
   * @param s String to split
   * @return List&lt;String&gt; of split strings
   */
  public static List&lt;String&gt; split(String s) {
<span class="nc" id="L450">    return split(s, &quot;\\s+&quot;);</span>
  }

  /**
   * Splits the given string using the given regex as delimiters.
   * This method is the same as the String.split() method (except it throws
   * the results in a List),
   * and is included just to give a call that is parallel to the other
   * static regex methods in this class.
   *
   * @param str   String to split up
   * @param regex String to compile as the regular expression
   * @return List of Strings resulting from splitting on the regex
   */
  public static List&lt;String&gt; split(String str, String regex) {
<span class="nc" id="L465">    return (Arrays.asList(str.split(regex)));</span>
  }

  /**
   * Split a string on a given single character.
   * This method is often faster than the regular split() method.
   * @param input The input to split.
   * @param delimiter The character to split on.
   * @return An array of Strings corresponding to the original input split on the delimiter character.
   */
  public static String[] splitOnChar(String input, char delimiter) {
    // State
<span class="fc" id="L477">    String[] out = new String[input.length() + 1];</span>
<span class="fc" id="L478">    int nextIndex = 0;</span>
<span class="fc" id="L479">    int lastDelimiterIndex = -1;</span>
<span class="fc" id="L480">    char[] chars = input.toCharArray();</span>
    // Split
<span class="fc bfc" id="L482" title="All 2 branches covered.">    for ( int i = 0; i &lt;= chars.length; ++i ) {</span>
<span class="fc bfc" id="L483" title="All 4 branches covered.">      if (i &gt;= chars.length || chars[i] == delimiter) {</span>
<span class="fc" id="L484">        char[] tokenChars = new char[i - (lastDelimiterIndex + 1)];</span>
<span class="fc" id="L485">        System.arraycopy(chars, lastDelimiterIndex + 1, tokenChars, 0, tokenChars.length);</span>
<span class="fc" id="L486">        out[nextIndex] = new String(tokenChars);</span>
<span class="fc" id="L487">        nextIndex += 1;</span>
<span class="fc" id="L488">        lastDelimiterIndex = i;</span>
      }
    }
    // Clean Result
<span class="fc" id="L492">    String[] trimmedOut = new String[nextIndex];</span>
<span class="fc" id="L493">    System.arraycopy(out, 0, trimmedOut, 0, trimmedOut.length);</span>
<span class="fc" id="L494">    return trimmedOut;</span>
  }

  /**
   * Splits a string into whitespace tokenized fields based on a delimiter and then whitespace.
   * For example, &quot;aa bb | bb cc | ccc ddd&quot; would be split into &quot;[aa,bb],[bb,cc],[ccc,ddd]&quot; based on
   * the delimiter &quot;|&quot;. This method uses the old StringTokenizer class, which is up to
   * 3x faster than the regex-based &quot;split()&quot; methods.
   *
   * @param delimiter String to split on
   * @return List of lists of strings.
   */
  public static List&lt;List&lt;String&gt;&gt; splitFieldsFast(String str, String delimiter) {
<span class="nc" id="L507">    List&lt;List&lt;String&gt;&gt; fields = Generics.newArrayList();</span>
<span class="nc" id="L508">    StringTokenizer tokenizer = new StringTokenizer(str.trim());</span>
<span class="nc" id="L509">    List&lt;String&gt; currentField = Generics.newArrayList();</span>
<span class="nc bnc" id="L510" title="All 2 branches missed.">    while(tokenizer.hasMoreTokens()) {</span>
<span class="nc" id="L511">      String token = tokenizer.nextToken();</span>
<span class="nc bnc" id="L512" title="All 2 branches missed.">      if (token.equals(delimiter)) {</span>
<span class="nc" id="L513">        fields.add(currentField);</span>
<span class="nc" id="L514">        currentField = Generics.newArrayList();</span>
      } else {
<span class="nc" id="L516">        currentField.add(token.trim());</span>
      }
<span class="nc" id="L518">    }</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">    if (currentField.size() &gt; 0) {</span>
<span class="nc" id="L520">      fields.add(currentField);</span>
    }
<span class="nc" id="L522">    return fields;</span>
  }


  /**
   * Split on a given character, filling out the fields in the output array.
   * This is suitable for, e.g., splitting a TSV file of known column count.
   * @param out The output array to fill
   * @param input The input to split
   * @param delimiter The delimiter to split on.
   */
  public static void splitOnChar(String[] out, String input, char delimiter) {
<span class="fc" id="L534">    int lastSplit = 0;</span>
<span class="fc" id="L535">    int outI = 0;</span>
<span class="fc" id="L536">    char[] chars = input.toCharArray();</span>
<span class="fc bfc" id="L537" title="All 2 branches covered.">    for (int i = 0; i &lt; chars.length; ++i) {</span>
<span class="fc bfc" id="L538" title="All 2 branches covered.">      if (chars[i] == delimiter) {</span>
<span class="fc" id="L539">        out[outI] = new String(chars, lastSplit, i - lastSplit);</span>
<span class="fc" id="L540">        outI += 1;</span>
<span class="fc" id="L541">        lastSplit = i + 1;</span>
      }
    }
<span class="pc bpc" id="L544" title="1 of 2 branches missed.">    if (outI &lt; out.length) {</span>
<span class="fc" id="L545">      out[outI] = input.substring(lastSplit);</span>
    }
<span class="fc" id="L547">  }</span>

  /** Split a string into tokens.  Because there is a tokenRegex as well as a
   *  separatorRegex (unlike for the conventional split), you can do things
   *  like correctly split quoted strings or parenthesized arguments.
   *  However, it doesn't do the unquoting of quoted Strings for you.
   *  An empty String argument is returned at the beginning, if valueRegex
   *  accepts the empty String and str begins with separatorRegex.
   *  But str can end with either valueRegex or separatorRegex and this does
   *  not generate an empty String at the end (indeed, valueRegex need not
   *  even accept the empty String in this case.  However, if it does accept
   *  the empty String and there are multiple trailing separators, then
   *  empty values will be returned.
   *
   *  @param str The String to split
   *  @param valueRegex Must match a token. You may wish to let it match the empty String
   *  @param separatorRegex Must match a separator
   *  @return The List of tokens
   *  @throws IllegalArgumentException if str cannot be tokenized by the two regex
   */
  public static List&lt;String&gt; valueSplit(String str, String valueRegex, String separatorRegex) {
<span class="fc" id="L568">    Pattern vPat = Pattern.compile(valueRegex);</span>
<span class="fc" id="L569">    Pattern sPat = Pattern.compile(separatorRegex);</span>
<span class="fc" id="L570">    List&lt;String&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L571" title="All 2 branches covered.">    while (str.length() &gt; 0) {</span>
<span class="fc" id="L572">      Matcher vm = vPat.matcher(str);</span>
<span class="pc bpc" id="L573" title="1 of 2 branches missed.">      if (vm.lookingAt()) {</span>
<span class="fc" id="L574">        ret.add(vm.group());</span>
<span class="fc" id="L575">        str = str.substring(vm.end());</span>
        // String got = vm.group();
        // log.info(&quot;vmatched &quot; + got + &quot;; now str is &quot; + str);
      } else {
<span class="nc" id="L579">        throw new IllegalArgumentException(&quot;valueSplit: &quot; + valueRegex + &quot; doesn't match &quot; + str);</span>
      }
<span class="fc bfc" id="L581" title="All 2 branches covered.">      if (str.length() &gt; 0) {</span>
<span class="fc" id="L582">        Matcher sm = sPat.matcher(str);</span>
<span class="pc bpc" id="L583" title="1 of 2 branches missed.">        if (sm.lookingAt()) {</span>
<span class="fc" id="L584">          str = str.substring(sm.end());</span>
          // String got = sm.group();
          // log.info(&quot;smatched &quot; + got + &quot;; now str is &quot; + str);
        } else {
<span class="nc" id="L588">          throw new IllegalArgumentException(&quot;valueSplit: &quot; + separatorRegex + &quot; doesn't match &quot; + str);</span>
        }
      }
<span class="fc" id="L591">    } // end while</span>
<span class="fc" id="L592">    return ret;</span>
  }


  /**
   * Return a String of length a minimum of totalChars characters by
   * padding the input String str at the right end with spaces.
   * If str is already longer
   * than totalChars, it is returned unchanged.
   */
  public static String pad(String str, int totalChars) {
<span class="nc" id="L603">    return pad(str, totalChars, ' ');</span>
  }

  /**
   * Return a String of length a minimum of totalChars characters by
   * padding the input String str at the right end with spaces.
   * If str is already longer
   * than totalChars, it is returned unchanged.
   */
  public static String pad(String str, int totalChars, char pad) {
<span class="nc bnc" id="L613" title="All 2 branches missed.">    if (str == null) {</span>
<span class="nc" id="L614">      str = &quot;null&quot;;</span>
    }
<span class="nc" id="L616">    int slen = str.length();</span>
<span class="nc" id="L617">    StringBuilder sb = new StringBuilder(str);</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">    for (int i = 0; i &lt; totalChars - slen; i++) {</span>
<span class="nc" id="L619">      sb.append(pad);</span>
    }
<span class="nc" id="L621">    return sb.toString();</span>
  }

  /**
   * Pads the toString value of the given Object.
   */
  public static String pad(Object obj, int totalChars) {
<span class="nc" id="L628">    return pad(obj.toString(), totalChars);</span>
  }


  /**
   * Pad or trim so as to produce a string of exactly a certain length.
   *
   * @param str The String to be padded or truncated
   * @param num The desired length
   */
  public static String padOrTrim(String str, int num) {
<span class="nc bnc" id="L639" title="All 2 branches missed.">    if (str == null) {</span>
<span class="nc" id="L640">      str = &quot;null&quot;;</span>
    }
<span class="nc" id="L642">    int leng = str.length();</span>
<span class="nc bnc" id="L643" title="All 2 branches missed.">    if (leng &lt; num) {</span>
<span class="nc" id="L644">      StringBuilder sb = new StringBuilder(str);</span>
<span class="nc bnc" id="L645" title="All 2 branches missed.">      for (int i = 0; i &lt; num - leng; i++) {</span>
<span class="nc" id="L646">        sb.append(' ');</span>
      }
<span class="nc" id="L648">      return sb.toString();</span>
<span class="nc bnc" id="L649" title="All 2 branches missed.">    } else if (leng &gt; num) {</span>
<span class="nc" id="L650">      return str.substring(0, num);</span>
    } else {
<span class="nc" id="L652">      return str;</span>
    }
  }

  /**
   * Pad or trim so as to produce a string of exactly a certain length.
   *
   * @param str The String to be padded or truncated
   * @param num The desired length
   */
  public static String padLeftOrTrim(String str, int num) {
<span class="nc bnc" id="L663" title="All 2 branches missed.">    if (str == null) {</span>
<span class="nc" id="L664">      str = &quot;null&quot;;</span>
    }
<span class="nc" id="L666">    int leng = str.length();</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">    if (leng &lt; num) {</span>
<span class="nc" id="L668">      StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L669" title="All 2 branches missed.">      for (int i = 0; i &lt; num - leng; i++) {</span>
<span class="nc" id="L670">        sb.append(' ');</span>
      }
<span class="nc" id="L672">      sb.append(str);</span>
<span class="nc" id="L673">      return sb.toString();</span>
<span class="nc bnc" id="L674" title="All 2 branches missed.">    } else if (leng &gt; num) {</span>
<span class="nc" id="L675">      return str.substring(str.length() - num);</span>
    } else {
<span class="nc" id="L677">      return str;</span>
    }
  }

  /**
   * Pad or trim the toString value of the given Object.
   */
  public static String padOrTrim(Object obj, int totalChars) {
<span class="nc" id="L685">    return padOrTrim(obj.toString(), totalChars);</span>
  }


  /**
   * Pads the given String to the left with the given character ch to ensure that
   * it's at least totalChars long.
   */
  public static String padLeft(String str, int totalChars, char ch) {
<span class="pc bpc" id="L694" title="1 of 2 branches missed.">    if (str == null) {</span>
<span class="nc" id="L695">      str = &quot;null&quot;;</span>
    }
<span class="fc" id="L697">    StringBuilder sb = new StringBuilder();</span>
<span class="fc bfc" id="L698" title="All 2 branches covered.">    for (int i = 0, num = totalChars - str.length(); i &lt; num; i++) {</span>
<span class="fc" id="L699">      sb.append(ch);</span>
    }
<span class="fc" id="L701">    sb.append(str);</span>
<span class="fc" id="L702">    return sb.toString();</span>
  }


  /**
   * Pads the given String to the left with spaces to ensure that it's
   * at least totalChars long.
   */
  public static String padLeft(String str, int totalChars) {
<span class="fc" id="L711">    return padLeft(str, totalChars, ' ');</span>
  }


  public static String padLeft(Object obj, int totalChars) {
<span class="nc" id="L716">    return padLeft(obj.toString(), totalChars);</span>
  }

  public static String padLeft(int i, int totalChars) {
<span class="nc" id="L720">    return padLeft(Integer.valueOf(i), totalChars);</span>
  }

  public static String padLeft(double d, int totalChars) {
<span class="nc" id="L724">    return padLeft(new Double(d), totalChars);</span>
  }

  /**
   * Returns s if it's at most maxWidth chars, otherwise chops right side to fit.
   */
  public static String trim(String s, int maxWidth) {
<span class="nc bnc" id="L731" title="All 2 branches missed.">    if (s.length() &lt;= maxWidth) {</span>
<span class="nc" id="L732">      return (s);</span>
    }
<span class="nc" id="L734">    return s.substring(0, maxWidth);</span>
  }

  public static String trim(Object obj, int maxWidth) {
<span class="nc" id="L738">    return trim(obj.toString(), maxWidth);</span>
  }

  public static String trimWithEllipsis(String s, int width) {
<span class="nc bnc" id="L742" title="All 2 branches missed.">    if (s.length() &gt; width) s = s.substring(0, width - 3) + &quot;...&quot;;</span>
<span class="nc" id="L743">    return s;</span>
  }

  public static String trimWithEllipsis(Object o, int width) {
<span class="nc" id="L747">    return trimWithEllipsis(o.toString(), width);</span>
  }


  public static String repeat(String s, int times) {
<span class="pc bpc" id="L752" title="1 of 2 branches missed.">    if (times == 0) {</span>
<span class="nc" id="L753">      return &quot;&quot;;</span>
    }
<span class="fc" id="L755">    StringBuilder sb = new StringBuilder(times * s.length());</span>
<span class="fc bfc" id="L756" title="All 2 branches covered.">    for (int i = 0; i &lt; times; i++) {</span>
<span class="fc" id="L757">      sb.append(s);</span>
    }
<span class="fc" id="L759">    return sb.toString();</span>
  }

  public static String repeat(char ch, int times) {
<span class="fc bfc" id="L763" title="All 2 branches covered.">    if (times == 0) {</span>
<span class="fc" id="L764">      return &quot;&quot;;</span>
    }
<span class="fc" id="L766">    StringBuilder sb = new StringBuilder(times);</span>
<span class="fc bfc" id="L767" title="All 2 branches covered.">    for (int i = 0; i &lt; times; i++) {</span>
<span class="fc" id="L768">      sb.append(ch);</span>
    }
<span class="fc" id="L770">    return sb.toString();</span>
  }

  /**
   * Returns a &quot;clean&quot; version of the given filename in which spaces have
   * been converted to dashes and all non-alphanumeric chars are underscores.
   */
  public static String fileNameClean(String s) {
<span class="nc" id="L778">    char[] chars = s.toCharArray();</span>
<span class="nc" id="L779">    StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L780" title="All 2 branches missed.">    for (char c : chars) {</span>
<span class="nc bnc" id="L781" title="All 14 branches missed.">      if ((c &gt;= 'A' &amp;&amp; c &lt;= 'Z') || (c &gt;= 'a' &amp;&amp; c &lt;= 'z') || (c &gt;= '0' &amp;&amp; c &lt;= '9') || (c == '_')) {</span>
<span class="nc" id="L782">        sb.append(c);</span>
      } else {
<span class="nc bnc" id="L784" title="All 4 branches missed.">        if (c == ' ' || c == '-') {</span>
<span class="nc" id="L785">          sb.append('_');</span>
        } else {
<span class="nc" id="L787">          sb.append('x').append((int) c).append('x');</span>
        }
      }
    }
<span class="nc" id="L791">    return sb.toString();</span>
  }

  /**
   * Returns the index of the &lt;i&gt;n&lt;/i&gt;th occurrence of ch in s, or -1
   * if there are less than n occurrences of ch.
   */
  public static int nthIndex(String s, char ch, int n) {
<span class="nc" id="L799">    int index = 0;</span>
<span class="nc bnc" id="L800" title="All 2 branches missed.">    for (int i = 0; i &lt; n; i++) {</span>
      // if we're already at the end of the string,
      // and we need to find another ch, return -1
<span class="nc bnc" id="L803" title="All 2 branches missed.">      if (index == s.length() - 1) {</span>
<span class="nc" id="L804">        return -1;</span>
      }
<span class="nc" id="L806">      index = s.indexOf(ch, index + 1);</span>
<span class="nc bnc" id="L807" title="All 2 branches missed.">      if (index == -1) {</span>
<span class="nc" id="L808">        return (-1);</span>
      }
    }
<span class="nc" id="L811">    return index;</span>
  }


  /**
   * This returns a string from decimal digit smallestDigit to decimal digit
   * biggest digit. Smallest digit is labeled 1, and the limits are
   * inclusive.
   */
  public static String truncate(int n, int smallestDigit, int biggestDigit) {
<span class="nc" id="L821">    int numDigits = biggestDigit - smallestDigit + 1;</span>
<span class="nc" id="L822">    char[] result = new char[numDigits];</span>
<span class="nc bnc" id="L823" title="All 2 branches missed.">    for (int j = 1; j &lt; smallestDigit; j++) {</span>
<span class="nc" id="L824">      n = n / 10;</span>
    }
<span class="nc bnc" id="L826" title="All 2 branches missed.">    for (int j = numDigits - 1; j &gt;= 0; j--) {</span>
<span class="nc" id="L827">      result[j] = Character.forDigit(n % 10, 10);</span>
<span class="nc" id="L828">      n = n / 10;</span>
    }
<span class="nc" id="L830">    return new String(result);</span>
  }

  /**
   * Parses command line arguments into a Map. Arguments of the form
   * &lt;p/&gt;
   * {@code -flag1 arg1a arg1b ... arg1m -flag2 -flag3 arg3a ... arg3n}
   * &lt;p/&gt;
   * will be parsed so that the flag is a key in the Map (including
   * the hyphen) and its value will be a {@link String}[] containing
   * the optional arguments (if present).  The non-flag values not
   * captured as flag arguments are collected into a String[] array
   * and returned as the value of {@code null} in the Map.  In
   * this invocation, flags cannot take arguments, so all the {@link
   * String} array values other than the value for {@code null}
   * will be zero-length.
   *
   * @param args A command-line arguments array
   * @return a {@link Map} of flag names to flag argument {@link
   *         String} arrays.
   */
  public static Map&lt;String, String[]&gt; argsToMap(String[] args) {
<span class="nc" id="L852">    return argsToMap(args, Collections.emptyMap());</span>
  }

  /**
   * Parses command line arguments into a Map. Arguments of the form
   * &lt;p/&gt;
   * {@code -flag1 arg1a arg1b ... arg1m -flag2 -flag3 arg3a ... arg3n}
   * &lt;p/&gt;
   * will be parsed so that the flag is a key in the Map (including
   * the hyphen) and its value will be a {@link String}[] containing
   * the optional arguments (if present).  The non-flag values not
   * captured as flag arguments are collected into a String[] array
   * and returned as the value of {@code null} in the Map.  In
   * this invocation, the maximum number of arguments for each flag
   * can be specified as an {@link Integer} value of the appropriate
   * flag key in the {@code flagsToNumArgs} {@link Map}
   * argument. (By default, flags cannot take arguments.)
   * &lt;p/&gt;
   * Example of usage:
   * &lt;p/&gt;
   * &lt;code&gt;
   * Map flagsToNumArgs = new HashMap();
   * flagsToNumArgs.put(&quot;-x&quot;,new Integer(2));
   * flagsToNumArgs.put(&quot;-d&quot;,new Integer(1));
   * Map result = argsToMap(args,flagsToNumArgs);
   * &lt;/code&gt;
   * &lt;p/&gt;
   * If a given flag appears more than once, the extra args are appended to
   * the String[] value for that flag.
   *
   * @param args           the argument array to be parsed
   * @param flagsToNumArgs a {@link Map} of flag names to {@link Integer}
   *                       values specifying the number of arguments
   *                       for that flag (default min 0, max 1).
   * @return a {@link Map} of flag names to flag argument {@link String}
   */
  public static Map&lt;String, String[]&gt; argsToMap(String[] args, Map&lt;String, Integer&gt; flagsToNumArgs) {
<span class="nc" id="L889">    Map&lt;String, String[]&gt; result = Generics.newHashMap();</span>
<span class="nc" id="L890">    List&lt;String&gt; remainingArgs = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L891" title="All 2 branches missed.">    for (int i = 0; i &lt; args.length; i++) {</span>
<span class="nc" id="L892">      String key = args[i];</span>
<span class="nc bnc" id="L893" title="All 2 branches missed.">      if (key.charAt(0) == '-') { // found a flag</span>
<span class="nc" id="L894">        Integer numFlagArgs = flagsToNumArgs.get(key);</span>
<span class="nc bnc" id="L895" title="All 2 branches missed.">        int max = numFlagArgs == null ? 1 : numFlagArgs.intValue();</span>
<span class="nc bnc" id="L896" title="All 2 branches missed.">        int min = numFlagArgs == null ? 0 : numFlagArgs.intValue();</span>
<span class="nc" id="L897">        List&lt;String&gt; flagArgs = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L898" title="All 10 branches missed.">        for (int j = 0; j &lt; max &amp;&amp; i + 1 &lt; args.length &amp;&amp; (j &lt; min || args[i + 1].length() == 0 || args[i + 1].charAt(0) != '-'); i++, j++) {</span>
<span class="nc" id="L899">          flagArgs.add(args[i + 1]);</span>
        }
<span class="nc bnc" id="L901" title="All 2 branches missed.">        if (result.containsKey(key)) { // append the second specification into the args.</span>
<span class="nc" id="L902">          String[] newFlagArg = new String[result.get(key).length + flagsToNumArgs.get(key)];</span>
<span class="nc" id="L903">          int oldNumArgs = result.get(key).length;</span>
<span class="nc" id="L904">          System.arraycopy(result.get(key), 0, newFlagArg, 0, oldNumArgs);</span>
<span class="nc bnc" id="L905" title="All 2 branches missed.">          for (int j = 0; j &lt; flagArgs.size(); j++) {</span>
<span class="nc" id="L906">            newFlagArg[j + oldNumArgs] = flagArgs.get(j);</span>
          }
<span class="nc" id="L908">          result.put(key, newFlagArg);</span>
<span class="nc" id="L909">        } else {</span>
<span class="nc" id="L910">          result.put(key, flagArgs.toArray(new String[flagArgs.size()]));</span>
        }
<span class="nc" id="L912">      } else {</span>
<span class="nc" id="L913">        remainingArgs.add(args[i]);</span>
      }
    }
<span class="nc" id="L916">    result.put(null, remainingArgs.toArray(new String[remainingArgs.size()]));</span>
<span class="nc" id="L917">    return result;</span>
  }

  /**
   * In this version each flag has zero or one argument. It has one argument
   * if there is a thing following a flag that does not begin with '-'.  See
   * {@link #argsToProperties(String[], Map)} for full documentation.
   *
   * @param args Command line arguments
   * @return A Properties object representing the arguments.
   */
  public static Properties argsToProperties(String... args) {
<span class="fc" id="L929">    return argsToProperties(args, Collections.emptyMap());</span>
  }

  /**
   * Analogous to {@link #argsToMap}.  However, there are several key differences between this method and {@link #argsToMap}:
   * &lt;ul&gt;
   * &lt;li&gt; Hyphens are stripped from flag names &lt;/li&gt;
   * &lt;li&gt; Since Properties objects are String to String mappings, the default number of arguments to a flag is
   * assumed to be 1 and not 0. &lt;/li&gt;
   * &lt;li&gt; Furthermore, the list of arguments not bound to a flag is mapped to the &quot;&quot; property, not null &lt;/li&gt;
   * &lt;li&gt; The special flags &quot;-prop&quot;, &quot;-props&quot;, &quot;-properties&quot;, &quot;-args&quot;, or &quot;-arguments&quot; will load the property file
   *      specified by its argument. &lt;/li&gt;
   * &lt;li&gt; The value for flags without arguments is set to &quot;true&quot; &lt;/li&gt;
   * &lt;li&gt; If a flag has multiple arguments, the value of the property is all
   * of the arguments joined together with a space (&quot; &quot;) character between them.&lt;/li&gt;
   * &lt;li&gt; The value strings are trimmed so trailing spaces do not stop you from loading a file.&lt;/li&gt;
   * &lt;/ul&gt;
   * Properties are read from left to right, and later properties will override earlier ones with the same name.
   * Properties loaded from a Properties file with the special args are defaults that can be overriden by command line
   * flags (or earlier Properties files if there is nested usage of the special args.
   *
   * @param args Command line arguments
   * @param flagsToNumArgs Map of how many arguments flags should have. The keys are without the minus signs.
   * @return A Properties object representing the arguments.
   */
  public static Properties argsToProperties(String[] args, Map&lt;String,Integer&gt; flagsToNumArgs) {
<span class="fc" id="L955">    Properties result = new Properties();</span>
<span class="fc" id="L956">    List&lt;String&gt; remainingArgs = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L957" title="All 2 branches covered.">    for (int i = 0; i &lt; args.length; i++) {</span>
<span class="fc" id="L958">      String key = args[i];</span>
<span class="pc bpc" id="L959" title="1 of 4 branches missed.">      if ( ! key.isEmpty() &amp;&amp; key.charAt(0) == '-') { // found a flag</span>
<span class="pc bpc" id="L960" title="2 of 4 branches missed.">        if (key.length() &gt; 1 &amp;&amp; key.charAt(1) == '-') {</span>
<span class="nc" id="L961">          key = key.substring(2); // strip off 2 hyphens</span>
        } else {
<span class="fc" id="L963">          key = key.substring(1); // strip off the hyphen</span>
        }

<span class="fc" id="L966">        Integer maxFlagArgs = flagsToNumArgs.get(key);</span>
<span class="fc bfc" id="L967" title="All 2 branches covered.">        int max = maxFlagArgs == null ? 1 : maxFlagArgs;</span>
<span class="fc bfc" id="L968" title="All 2 branches covered.">        int min = maxFlagArgs == null ? 0 : maxFlagArgs;</span>
<span class="pc bpc" id="L969" title="3 of 6 branches missed.">        if (maxFlagArgs != null &amp;&amp; maxFlagArgs == 0 &amp;&amp; i &lt; args.length - 1 &amp;&amp;</span>
<span class="nc bnc" id="L970" title="All 4 branches missed.">            (&quot;true&quot;.equalsIgnoreCase(args[i + 1]) || &quot;false&quot;.equalsIgnoreCase(args[i + 1]))) {</span>
<span class="nc" id="L971">          max = 1;  // case: we're reading a boolean flag. TODO(gabor) there's gotta be a better way...</span>
        }
<span class="fc" id="L973">        List&lt;String&gt; flagArgs = new ArrayList&lt;&gt;();</span>
        // cdm oct 2007: add length check to allow for empty string argument!
<span class="pc bpc" id="L975" title="2 of 10 branches missed.">        for (int j = 0; j &lt; max &amp;&amp; i + 1 &lt; args.length &amp;&amp; (j &lt; min || args[i + 1].isEmpty() || args[i + 1].charAt(0) != '-'); i++, j++) {</span>
<span class="fc" id="L976">          flagArgs.add(args[i + 1]);</span>
        }
        String value;
<span class="fc bfc" id="L979" title="All 2 branches covered.">        if (flagArgs.isEmpty()) {</span>
<span class="fc" id="L980">          value = &quot;true&quot;;</span>
        } else {
<span class="fc" id="L982">          value = join(flagArgs, &quot; &quot;);</span>
        }
<span class="pc bpc" id="L984" title="5 of 10 branches missed.">        if (key.equalsIgnoreCase(PROP) || key.equalsIgnoreCase(PROPS) || key.equalsIgnoreCase(PROPERTIES) || key.equalsIgnoreCase(ARGUMENTS) || key.equalsIgnoreCase(ARGS)) {</span>
<span class="nc" id="L985">          result.setProperty(PROPERTIES, value);</span>
        } else {
<span class="fc" id="L987">          result.setProperty(key, value);</span>
        }
<span class="fc" id="L989">      } else {</span>
<span class="fc" id="L990">        remainingArgs.add(args[i]);</span>
      }
    }
<span class="fc bfc" id="L993" title="All 2 branches covered.">    if ( ! remainingArgs.isEmpty()) {</span>
<span class="fc" id="L994">      result.setProperty(&quot;&quot;, join(remainingArgs, &quot; &quot;));</span>
    }

    /* Processing in reverse order, add properties that aren't present only. Thus, later ones override earlier ones. */
<span class="pc bpc" id="L998" title="1 of 2 branches missed.">    while (result.containsKey(PROPERTIES)) {</span>
<span class="nc" id="L999">      String file = result.getProperty(PROPERTIES);</span>
<span class="nc" id="L1000">      result.remove(PROPERTIES);</span>
<span class="nc" id="L1001">      Properties toAdd = new Properties();</span>
<span class="nc" id="L1002">      BufferedReader reader = null;</span>
      try {
<span class="nc" id="L1004">        reader = IOUtils.readerFromString(file);</span>
<span class="nc" id="L1005">        toAdd.load(reader);</span>
        // trim all values
<span class="nc bnc" id="L1007" title="All 2 branches missed.">        for (String propKey : toAdd.stringPropertyNames()) {</span>
<span class="nc" id="L1008">          String newVal = toAdd.getProperty(propKey);</span>
<span class="nc" id="L1009">          toAdd.setProperty(propKey, newVal.trim());</span>
<span class="nc" id="L1010">        }</span>
<span class="nc" id="L1011">      } catch (IOException e) {</span>
<span class="nc" id="L1012">        String msg = &quot;argsToProperties could not read properties file: &quot; + file;</span>
<span class="nc" id="L1013">        throw new RuntimeIOException(msg, e);</span>
      } finally {
<span class="nc" id="L1015">        IOUtils.closeIgnoringExceptions(reader);</span>
<span class="nc" id="L1016">      }</span>

<span class="nc bnc" id="L1018" title="All 2 branches missed.">      for (String key : toAdd.stringPropertyNames()) {</span>
<span class="nc" id="L1019">        String val = toAdd.getProperty(key);</span>
<span class="nc bnc" id="L1020" title="All 2 branches missed.">        if ( ! result.containsKey(key)) {</span>
<span class="nc" id="L1021">          result.setProperty(key, val);</span>
        }
<span class="nc" id="L1023">      }</span>
<span class="nc" id="L1024">    }</span>

<span class="fc" id="L1026">    return result;</span>
  }


  /**
   * This method reads in properties listed in a file in the format prop=value, one property per line.
   * Although {@code Properties.load(InputStream)} exists, I implemented this method to trim the lines,
   * something not implemented in the {@code load()} method.
   *
   * @param filename A properties file to read
   * @return The corresponding Properties object
   */
  public static Properties propFileToProperties(String filename) {
<span class="nc" id="L1039">    Properties result = new Properties();</span>
    try {
<span class="nc" id="L1041">      InputStream is = new BufferedInputStream(new FileInputStream(filename));</span>
<span class="nc" id="L1042">      result.load(is);</span>
      // trim all values
<span class="nc bnc" id="L1044" title="All 2 branches missed.">      for (String propKey : result.stringPropertyNames()){</span>
<span class="nc" id="L1045">        String newVal = result.getProperty(propKey);</span>
<span class="nc" id="L1046">        result.setProperty(propKey,newVal.trim());</span>
<span class="nc" id="L1047">      }</span>
<span class="nc" id="L1048">      is.close();</span>
<span class="nc" id="L1049">      return result;</span>
<span class="nc" id="L1050">    } catch (IOException e) {</span>
<span class="nc" id="L1051">      throw new RuntimeIOException(&quot;propFileToProperties could not read properties file: &quot; + filename, e);</span>
    }
  }

  /**
   * This method converts a comma-separated String (with whitespace
   * optionally allowed after the comma) representing properties
   * to a Properties object.  Each property is &quot;property=value&quot;.  The value
   * for properties without an explicitly given value is set to &quot;true&quot;. This can be used for a 2nd level
   * of properties, for example, when you have a commandline argument like &quot;-outputOptions style=xml,tags&quot;.
   */
  public static Properties stringToProperties(String str) {
<span class="fc" id="L1063">    Properties result = new Properties();</span>
<span class="fc" id="L1064">    return stringToProperties(str, result);</span>
  }

  /**
   * This method updates a Properties object based on
   * a comma-separated String (with whitespace
   * optionally allowed after the comma) representing properties
   * to a Properties object.  Each property is &quot;property=value&quot;.  The value
   * for properties without an explicitly given value is set to &quot;true&quot;.
   */
  public static Properties stringToProperties(String str, Properties props) {
<span class="fc" id="L1075">    String[] propsStr = str.trim().split(&quot;,\\s*&quot;);</span>
<span class="fc bfc" id="L1076" title="All 2 branches covered.">    for (String term : propsStr) {</span>
<span class="fc" id="L1077">      int divLoc = term.indexOf('=');</span>
      String key;
      String value;
<span class="fc bfc" id="L1080" title="All 2 branches covered.">      if (divLoc &gt;= 0) {</span>
<span class="fc" id="L1081">        key = term.substring(0, divLoc).trim();</span>
<span class="fc" id="L1082">        value = term.substring(divLoc + 1).trim();</span>
      } else {
<span class="fc" id="L1084">        key = term.trim();</span>
<span class="fc" id="L1085">        value = &quot;true&quot;;</span>
      }
<span class="fc" id="L1087">      props.setProperty(key, value);</span>
    }
<span class="fc" id="L1089">    return props;</span>
  }

  /**
   * If any of the given list of properties are not found, returns the
   * name of that property.  Otherwise, returns null.
   */
  public static String checkRequiredProperties(Properties props,
                                               String ... requiredProps) {
<span class="nc bnc" id="L1098" title="All 2 branches missed.">    for (String required : requiredProps) {</span>
<span class="nc bnc" id="L1099" title="All 2 branches missed.">      if (props.getProperty(required) == null) {</span>
<span class="nc" id="L1100">        return required;</span>
      }
    }
<span class="nc" id="L1103">    return null;</span>
  }


  /**
   * Prints to a file.  If the file already exists, appends if
   * {@code append=true}, and overwrites if {@code append=false}.
   */
  public static void printToFile(File file, String message, boolean append,
                                 boolean printLn, String encoding) {
<span class="nc" id="L1113">    PrintWriter pw = null;</span>
    try {
      Writer fw;
<span class="nc bnc" id="L1116" title="All 2 branches missed.">      if (encoding != null) {</span>
<span class="nc" id="L1117">        fw = new OutputStreamWriter(new FileOutputStream(file, append),</span>
                                         encoding);
      } else {
<span class="nc" id="L1120">        fw = new FileWriter(file, append);</span>
      }
<span class="nc" id="L1122">      pw = new PrintWriter(fw);</span>
<span class="nc bnc" id="L1123" title="All 2 branches missed.">      if (printLn) {</span>
<span class="nc" id="L1124">        pw.println(message);</span>
      } else {
<span class="nc" id="L1126">        pw.print(message);</span>
      }
<span class="nc" id="L1128">    } catch (Exception e) {</span>
<span class="nc" id="L1129">      log.info(&quot;Exception: in printToFile &quot; + file.getAbsolutePath());</span>
<span class="nc" id="L1130">      e.printStackTrace();</span>
    } finally {
<span class="nc bnc" id="L1132" title="All 6 branches missed.">      if (pw != null) {</span>
<span class="nc" id="L1133">        pw.flush();</span>
<span class="nc" id="L1134">        pw.close();</span>
      }
    }
<span class="nc" id="L1137">  }</span>


  /**
   * Prints to a file.  If the file already exists, appends if
   * {@code append=true}, and overwrites if {@code append=false}.
   */
  public static void printToFileLn(File file, String message, boolean append) {
<span class="nc" id="L1145">    PrintWriter pw = null;</span>
    try {
<span class="nc" id="L1147">      Writer fw = new FileWriter(file, append);</span>
<span class="nc" id="L1148">      pw = new PrintWriter(fw);</span>
<span class="nc" id="L1149">      pw.println(message);</span>
<span class="nc" id="L1150">    } catch (Exception e) {</span>
<span class="nc" id="L1151">      log.info(&quot;Exception: in printToFileLn &quot; + file.getAbsolutePath() + ' ' + message);</span>
<span class="nc" id="L1152">      e.printStackTrace();</span>
    } finally {
<span class="nc bnc" id="L1154" title="All 6 branches missed.">      if (pw != null) {</span>
<span class="nc" id="L1155">        pw.flush();</span>
<span class="nc" id="L1156">        pw.close();</span>
      }
    }
<span class="nc" id="L1159">  }</span>

  /**
   * Prints to a file.  If the file already exists, appends if
   * {@code append=true}, and overwrites if {@code append=false}.
   */
  public static void printToFile(File file, String message, boolean append) {
<span class="fc" id="L1166">    PrintWriter pw = null;</span>
    try {
<span class="fc" id="L1168">      Writer fw = new FileWriter(file, append);</span>
<span class="fc" id="L1169">      pw = new PrintWriter(fw);</span>
<span class="fc" id="L1170">      pw.print(message);</span>
<span class="nc" id="L1171">    } catch (Exception e) {</span>
<span class="nc" id="L1172">      throw new RuntimeIOException(&quot;Exception in printToFile &quot; + file.getAbsolutePath(), e);</span>
    } finally {
<span class="pc" id="L1174">      IOUtils.closeIgnoringExceptions(pw);</span>
<span class="fc" id="L1175">    }</span>
<span class="fc" id="L1176">  }</span>


  /**
   * Prints to a file.  If the file does not exist, rewrites the file;
   * does not append.
   */
  public static void printToFile(File file, String message) {
<span class="fc" id="L1184">    printToFile(file, message, false);</span>
<span class="fc" id="L1185">  }</span>

  /**
   * Prints to a file.  If the file already exists, appends if
   * {@code append=true}, and overwrites if {@code append=false}.
   */
  public static void printToFile(String filename, String message, boolean append) {
<span class="nc" id="L1192">    printToFile(new File(filename), message, append);</span>
<span class="nc" id="L1193">  }</span>

  /**
   * Prints to a file.  If the file already exists, appends if
   * {@code append=true}, and overwrites if {@code append=false}.
   */
  public static void printToFileLn(String filename, String message, boolean append) {
<span class="nc" id="L1200">    printToFileLn(new File(filename), message, append);</span>
<span class="nc" id="L1201">  }</span>


  /**
   * Prints to a file.  If the file does not exist, rewrites the file;
   * does not append.
   */
  public static void printToFile(String filename, String message) {
<span class="nc" id="L1209">    printToFile(new File(filename), message, false);</span>
<span class="nc" id="L1210">  }</span>

  /**
   * A simpler form of command line argument parsing.
   * Dan thinks this is highly superior to the overly complexified code that
   * comes before it.
   * Parses command line arguments into a Map. Arguments of the form
   * -flag1 arg1 -flag2 -flag3 arg3
   * will be parsed so that the flag is a key in the Map (including the hyphen)
   * and the
   * optional argument will be its value (if present).
   *
   * @return A Map from keys to possible values (String or null)
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static Map&lt;String, String&gt; parseCommandLineArguments(String[] args) {
<span class="nc" id="L1226">    return (Map)parseCommandLineArguments(args, false);</span>
  }

  /**
   * A simpler form of command line argument parsing.
   * Dan thinks this is highly superior to the overly complexified code that
   * comes before it.
   * Parses command line arguments into a Map. Arguments of the form
   * -flag1 arg1 -flag2 -flag3 arg3
   * will be parsed so that the flag is a key in the Map (including the hyphen)
   * and the
   * optional argument will be its value (if present).
   * In this version, if the argument is numeric, it will be a Double value
   * in the map, not a String.
   *
   * @return A Map from keys to possible values (String or null)
   */
  public static Map&lt;String, Object&gt; parseCommandLineArguments(String[] args, boolean parseNumbers) {
<span class="nc" id="L1244">    Map&lt;String, Object&gt; result = Generics.newHashMap();</span>
<span class="nc bnc" id="L1245" title="All 2 branches missed.">    for (int i = 0; i &lt; args.length; i++) {</span>
<span class="nc" id="L1246">      String key = args[i];</span>
<span class="nc bnc" id="L1247" title="All 2 branches missed.">      if (key.charAt(0) == '-') {</span>
<span class="nc bnc" id="L1248" title="All 2 branches missed.">        if (i + 1 &lt; args.length) {</span>
<span class="nc" id="L1249">          String value = args[i + 1];</span>
<span class="nc bnc" id="L1250" title="All 2 branches missed.">          if (value.charAt(0) != '-') {</span>
<span class="nc bnc" id="L1251" title="All 2 branches missed.">            if (parseNumbers) {</span>
<span class="nc" id="L1252">              Object numericValue = value;</span>
              try {
<span class="nc" id="L1254">                numericValue = Double.parseDouble(value);</span>
<span class="nc" id="L1255">              } catch (NumberFormatException e2) {</span>
                // ignore
<span class="nc" id="L1257">              }</span>
<span class="nc" id="L1258">              result.put(key, numericValue);</span>
<span class="nc" id="L1259">            } else {</span>
<span class="nc" id="L1260">              result.put(key, value);</span>
            }
<span class="nc" id="L1262">            i++;</span>
          } else {
<span class="nc" id="L1264">            result.put(key, null);</span>
          }
<span class="nc" id="L1266">        } else {</span>
<span class="nc" id="L1267">          result.put(key, null);</span>
        }
      }
    }
<span class="nc" id="L1271">    return result;</span>
  }

  public static String stripNonAlphaNumerics(String orig) {
<span class="nc" id="L1275">    StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L1276" title="All 2 branches missed.">    for (int i = 0; i &lt; orig.length(); i++) {</span>
<span class="nc" id="L1277">      char c = orig.charAt(i);</span>
<span class="nc bnc" id="L1278" title="All 12 branches missed.">      if ((c &gt;= 'a' &amp;&amp; c &lt;= 'z') || (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') || (c &gt;= '0' &amp;&amp; c &lt;= '9')) {</span>
<span class="nc" id="L1279">        sb.append(c);</span>
      }
    }
<span class="nc" id="L1282">    return sb.toString();</span>
  }

  public static String stripSGML(String orig) {
<span class="nc" id="L1286">      Pattern sgmlPattern = Pattern.compile(&quot;&lt;.*?&gt;&quot;, Pattern.DOTALL);</span>
<span class="nc" id="L1287">      Matcher sgmlMatcher = sgmlPattern.matcher(orig);</span>
<span class="nc" id="L1288">      return sgmlMatcher.replaceAll(&quot;&quot;);</span>
  }

  public static void printStringOneCharPerLine(String s) {
<span class="nc bnc" id="L1292" title="All 2 branches missed.">    for (int i = 0; i &lt; s.length(); i++) {</span>
<span class="nc" id="L1293">      int c = s.charAt(i);</span>
<span class="nc" id="L1294">      System.out.println(c + &quot; \'&quot; + (char) c + &quot;\' &quot;);</span>
    }
<span class="nc" id="L1296">  }</span>

  public static String escapeString(String s, char[] charsToEscape, char escapeChar) {
<span class="nc" id="L1299">    StringBuilder result = new StringBuilder();</span>
<span class="nc bnc" id="L1300" title="All 2 branches missed.">    for (int i = 0; i &lt; s.length(); i++) {</span>
<span class="nc" id="L1301">      char c = s.charAt(i);</span>
<span class="nc bnc" id="L1302" title="All 2 branches missed.">      if (c == escapeChar) {</span>
<span class="nc" id="L1303">        result.append(escapeChar);</span>
      } else {
<span class="nc bnc" id="L1305" title="All 2 branches missed.">        for (char charToEscape : charsToEscape) {</span>
<span class="nc bnc" id="L1306" title="All 2 branches missed.">          if (c == charToEscape) {</span>
<span class="nc" id="L1307">            result.append(escapeChar);</span>
<span class="nc" id="L1308">            break;</span>
          }
        }
      }
<span class="nc" id="L1312">      result.append(c);</span>
    }
<span class="nc" id="L1314">    return result.toString();</span>
  }

  /**
   * This function splits the String s into multiple Strings using the
   * splitChar.  However, it provides a quoting facility: it is possible to
   * quote strings with the quoteChar.
   * If the quoteChar occurs within the quotedExpression, it must be prefaced
   * by the escapeChar.
   * This routine can be useful for processing a line of a CSV file.
   *
   * @param s         The String to split into fields. Cannot be null.
   * @param splitChar The character to split on
   * @param quoteChar The character to quote items with
   * @param escapeChar The character to escape the quoteChar with
   * @return An array of Strings that s is split into
   */
  public static String[] splitOnCharWithQuoting(String s, char splitChar, char quoteChar, char escapeChar) {
<span class="fc" id="L1332">    List&lt;String&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1333">    int i = 0;</span>
<span class="fc" id="L1334">    int length = s.length();</span>
<span class="fc" id="L1335">    StringBuilder b = new StringBuilder();</span>
<span class="fc bfc" id="L1336" title="All 2 branches covered.">    while (i &lt; length) {</span>
<span class="fc" id="L1337">      char curr = s.charAt(i);</span>
<span class="fc bfc" id="L1338" title="All 2 branches covered.">      if (curr == splitChar) {</span>
        // add last buffer
        // cdm 2014: Do this even if the field is empty!
        // if (b.length() &gt; 0) {
<span class="fc" id="L1342">        result.add(b.toString());</span>
<span class="fc" id="L1343">        b = new StringBuilder();</span>
        // }
<span class="fc" id="L1345">        i++;</span>
<span class="fc bfc" id="L1346" title="All 2 branches covered.">      } else if (curr == quoteChar) {</span>
        // find next instance of quoteChar
<span class="fc" id="L1348">        i++;</span>
<span class="pc bpc" id="L1349" title="1 of 2 branches missed.">        while (i &lt; length) {</span>
<span class="fc" id="L1350">          curr = s.charAt(i);</span>
          // mrsmith: changed this condition from
          // if (curr == escapeChar) {
<span class="fc bfc" id="L1353" title="All 6 branches covered.">          if ((curr == escapeChar) &amp;&amp; (i+1 &lt; length) &amp;&amp; (s.charAt(i+1) == quoteChar)) {</span>
<span class="fc" id="L1354">            b.append(s.charAt(i + 1));</span>
<span class="fc" id="L1355">            i += 2;</span>
<span class="fc bfc" id="L1356" title="All 2 branches covered.">          } else if (curr == quoteChar) {</span>
<span class="fc" id="L1357">            i++;</span>
<span class="fc" id="L1358">            break; // break this loop</span>
          } else {
<span class="fc" id="L1360">            b.append(s.charAt(i));</span>
<span class="fc" id="L1361">            i++;</span>
          }
        }
      } else {
<span class="fc" id="L1365">        b.append(curr);</span>
<span class="fc" id="L1366">        i++;</span>
      }
<span class="fc" id="L1368">    }</span>
    // RFC 4180 disallows final comma. At any rate, don't produce a field after it unless non-empty
<span class="fc bfc" id="L1370" title="All 2 branches covered.">    if (b.length() &gt; 0) {</span>
<span class="fc" id="L1371">      result.add(b.toString());</span>
    }
<span class="fc" id="L1373">    return result.toArray(new String[result.size()]);</span>
  }

  /**
   * Computes the longest common substring of s and t.
   * The longest common substring of a and b is the longest run of
   * characters that appear in order inside both a and b. Both a and b
   * may have other extraneous characters along the way. This is like
   * edit distance but with no substitution and a higher number means
   * more similar. For example, the LCS of &quot;abcD&quot; and &quot;aXbc&quot; is 3 (abc).
   */
  public static int longestCommonSubstring(String s, String t) {
    int[][] d; // matrix
    int n; // length of s
    int m; // length of t
    int i; // iterates through s
    int j; // iterates through t
    // int cost; // cost
    // Step 1
<span class="fc" id="L1392">    n = s.length();</span>
<span class="fc" id="L1393">    m = t.length();</span>
<span class="pc bpc" id="L1394" title="1 of 2 branches missed.">    if (n == 0) {</span>
<span class="nc" id="L1395">      return 0;</span>
    }
<span class="pc bpc" id="L1397" title="1 of 2 branches missed.">    if (m == 0) {</span>
<span class="nc" id="L1398">      return 0;</span>
    }
<span class="fc" id="L1400">    d = new int[n + 1][m + 1];</span>
    // Step 2
<span class="fc bfc" id="L1402" title="All 2 branches covered.">    for (i = 0; i &lt;= n; i++) {</span>
<span class="fc" id="L1403">      d[i][0] = 0;</span>
    }
<span class="fc bfc" id="L1405" title="All 2 branches covered.">    for (j = 0; j &lt;= m; j++) {</span>
<span class="fc" id="L1406">      d[0][j] = 0;</span>
    }
    // Step 3
<span class="fc bfc" id="L1409" title="All 2 branches covered.">    for (i = 1; i &lt;= n; i++) {</span>
<span class="fc" id="L1410">      char s_i = s.charAt(i - 1); // ith character of s</span>
// Step 4
<span class="fc bfc" id="L1412" title="All 2 branches covered.">      for (j = 1; j &lt;= m; j++) {</span>
<span class="fc" id="L1413">        char t_j = t.charAt(j - 1); // jth character of t</span>
// Step 5
        // js: if the chars match, you can get an extra point
        // otherwise you have to skip an insertion or deletion (no subs)
<span class="fc bfc" id="L1417" title="All 2 branches covered.">        if (s_i == t_j) {</span>
<span class="fc" id="L1418">          d[i][j] = SloppyMath.max(d[i - 1][j], d[i][j - 1], d[i - 1][j - 1] + 1);</span>
        } else {
<span class="fc" id="L1420">          d[i][j] = Math.max(d[i - 1][j], d[i][j - 1]);</span>
        }
      }
    }
    /* ----
      // num chars needed to display longest num
      int numChars = (int) Math.ceil(Math.log(d[n][m]) / Math.log(10));
      for (i = 0; i &lt; numChars + 3; i++) {
        log.info(' ');
      }
      for (j = 0; j &lt; m; j++) {
        log.info(t.charAt(j) + &quot; &quot;);
      }
      log.info();
      for (i = 0; i &lt;= n; i++) {
        log.info((i == 0 ? ' ' : s.charAt(i - 1)) + &quot; &quot;);
        for (j = 0; j &lt;= m; j++) {
          log.info(d[i][j] + &quot; &quot;);
        }
        log.info();
      }
    ---- */
    // Step 7
<span class="fc" id="L1443">    return d[n][m];</span>
  }

  /**
   * Computes the longest common contiguous substring of s and t.
   * The LCCS is the longest run of characters that appear consecutively in
   * both s and t. For instance, the LCCS of &quot;color&quot; and &quot;colour&quot; is 4, because
   * of &quot;colo&quot;.
   */
  public static int longestCommonContiguousSubstring(String s, String t) {
<span class="nc bnc" id="L1453" title="All 4 branches missed.">    if (s.isEmpty() || t.isEmpty()) {</span>
<span class="nc" id="L1454">      return 0;</span>
    }
<span class="nc" id="L1456">    int M = s.length();</span>
<span class="nc" id="L1457">    int N = t.length();</span>
<span class="nc" id="L1458">    int[][] d = new int[M + 1][N + 1];</span>
<span class="nc bnc" id="L1459" title="All 2 branches missed.">    for (int j = 0; j &lt;= N; j++) {</span>
<span class="nc" id="L1460">      d[0][j] = 0;</span>
    }
<span class="nc bnc" id="L1462" title="All 2 branches missed.">    for (int i = 0; i &lt;= M; i++) {</span>
<span class="nc" id="L1463">      d[i][0] = 0;</span>
    }

<span class="nc" id="L1466">    int max = 0;</span>
<span class="nc bnc" id="L1467" title="All 2 branches missed.">    for (int i = 1; i &lt;= M; i++) {</span>
<span class="nc bnc" id="L1468" title="All 2 branches missed.">      for (int j = 1; j &lt;= N; j++) {</span>
<span class="nc bnc" id="L1469" title="All 2 branches missed.">        if (s.charAt(i - 1) == t.charAt(j - 1)) {</span>
<span class="nc" id="L1470">          d[i][j] = d[i - 1][j - 1] + 1;</span>
        } else {
<span class="nc" id="L1472">          d[i][j] = 0;</span>
        }

<span class="nc bnc" id="L1475" title="All 2 branches missed.">        if (d[i][j] &gt; max) {</span>
<span class="nc" id="L1476">          max = d[i][j];</span>
        }
      }
    }
    // log.info(&quot;LCCS(&quot; + s + &quot;,&quot; + t + &quot;) = &quot; + max);
<span class="nc" id="L1481">    return max;</span>
  }

  /**
   * Computes the Levenshtein (edit) distance of the two given Strings.
   * This method doesn't allow transposition, so one character transposed between two strings has a cost of 2 (one insertion, one deletion).
   * The EditDistance class also implements the Levenshtein distance, but does allow transposition.
   */
  public static int editDistance(String s, String t) {
    // Step 1
<span class="fc" id="L1491">    int n = s.length(); // length of s</span>
<span class="fc" id="L1492">    int m = t.length(); // length of t</span>
<span class="fc bfc" id="L1493" title="All 2 branches covered.">    if (n == 0) {</span>
<span class="fc" id="L1494">      return m;</span>
    }
<span class="fc bfc" id="L1496" title="All 2 branches covered.">    if (m == 0) {</span>
<span class="fc" id="L1497">      return n;</span>
    }
<span class="fc" id="L1499">    int[][] d = new int[n + 1][m + 1]; // matrix</span>
    // Step 2
<span class="fc bfc" id="L1501" title="All 2 branches covered.">    for (int i = 0; i &lt;= n; i++) {</span>
<span class="fc" id="L1502">      d[i][0] = i;</span>
    }
<span class="fc bfc" id="L1504" title="All 2 branches covered.">    for (int j = 0; j &lt;= m; j++) {</span>
<span class="fc" id="L1505">      d[0][j] = j;</span>
    }
    // Step 3
<span class="fc bfc" id="L1508" title="All 2 branches covered.">    for (int i = 1; i &lt;= n; i++) {</span>
<span class="fc" id="L1509">      char s_i = s.charAt(i - 1); // ith character of s</span>
      // Step 4
<span class="fc bfc" id="L1511" title="All 2 branches covered.">      for (int j = 1; j &lt;= m; j++) {</span>
<span class="fc" id="L1512">        char t_j = t.charAt(j - 1); // jth character of t</span>
        // Step 5
        int cost; // cost
<span class="fc bfc" id="L1515" title="All 2 branches covered.">        if (s_i == t_j) {</span>
<span class="fc" id="L1516">          cost = 0;</span>
        } else {
<span class="fc" id="L1518">          cost = 1;</span>
        }
        // Step 6
<span class="fc" id="L1521">        d[i][j] = SloppyMath.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);</span>
      }
    }

    // Step 7
<span class="fc" id="L1526">    return d[n][m];</span>
  }


  /**
   * Computes the WordNet 2.0 POS tag corresponding to the PTB POS tag s.
   *
   * @param s a Penn TreeBank POS tag.
   */
  public static String pennPOSToWordnetPOS(String s) {
<span class="nc bnc" id="L1536" title="All 2 branches missed.">    if (s.matches(&quot;NN|NNP|NNS|NNPS&quot;)) {</span>
<span class="nc" id="L1537">      return &quot;noun&quot;;</span>
    }
<span class="nc bnc" id="L1539" title="All 2 branches missed.">    if (s.matches(&quot;VB|VBD|VBG|VBN|VBZ|VBP|MD&quot;)) {</span>
<span class="nc" id="L1540">      return &quot;verb&quot;;</span>
    }
<span class="nc bnc" id="L1542" title="All 2 branches missed.">    if (s.matches(&quot;JJ|JJR|JJS|CD&quot;)) {</span>
<span class="nc" id="L1543">      return &quot;adjective&quot;;</span>
    }
<span class="nc bnc" id="L1545" title="All 2 branches missed.">    if (s.matches(&quot;RB|RBR|RBS|RP|WRB&quot;)) {</span>
<span class="nc" id="L1546">      return &quot;adverb&quot;;</span>
    }
<span class="nc" id="L1548">    return null;</span>
  }

  /**
   * Returns a short class name for an object.
   * This is the class name stripped of any package name.
   *
   * @return The name of the class minus a package name, for example
   *         &lt;code&gt;ArrayList&lt;/code&gt;
   */
  public static String getShortClassName(Object o) {
<span class="nc bnc" id="L1559" title="All 2 branches missed.">    if (o == null) {</span>
<span class="nc" id="L1560">      return &quot;null&quot;;</span>
    }
<span class="nc" id="L1562">    String name = o.getClass().getName();</span>
<span class="nc" id="L1563">    int index = name.lastIndexOf('.');</span>
<span class="nc bnc" id="L1564" title="All 2 branches missed.">    if (index &gt;= 0) {</span>
<span class="nc" id="L1565">      name = name.substring(index + 1);</span>
    }
<span class="nc" id="L1567">    return name;</span>
  }


  /**
   * Converts a tab delimited string into an object with given fields
   * Requires the object has setXxx functions for the specified fields
   *
   * @param objClass Class of object to be created
   * @param str string to convert
   * @param delimiterRegex delimiter regular expression
   * @param fieldNames fieldnames
   * @param &lt;T&gt; type to return
   * @return Object created from string
   */
  public static &lt;T&gt; T columnStringToObject(Class objClass, String str, String delimiterRegex, String[] fieldNames)
          throws InstantiationException, IllegalAccessException, NoSuchFieldException, NoSuchMethodException, InvocationTargetException {
<span class="nc" id="L1584">    Pattern delimiterPattern = Pattern.compile(delimiterRegex);</span>
<span class="nc" id="L1585">    return StringUtils.columnStringToObject(objClass, str, delimiterPattern, fieldNames);</span>
  }

  /**
   * Converts a tab delimited string into an object with given fields
   * Requires the object has public access for the specified fields
   *
   * @param objClass Class of object to be created
   * @param str string to convert
   * @param delimiterPattern delimiter
   * @param fieldNames fieldnames
   * @param &lt;T&gt; type to return
   * @return Object created from string
   */
  public static &lt;T&gt; T columnStringToObject(Class&lt;?&gt; objClass, String str, Pattern delimiterPattern, String[] fieldNames)
          throws InstantiationException, IllegalAccessException, NoSuchMethodException, NoSuchFieldException, InvocationTargetException {
<span class="nc" id="L1601">    String[] fields = delimiterPattern.split(str);</span>
<span class="nc" id="L1602">    T item = ErasureUtils.uncheckedCast(objClass.newInstance());</span>
<span class="nc bnc" id="L1603" title="All 2 branches missed.">    for (int i = 0; i &lt; fields.length; i++) {</span>
      try {
<span class="nc" id="L1605">        Field field = objClass.getDeclaredField(fieldNames[i]);</span>
<span class="nc" id="L1606">        field.set(item, fields[i]);</span>
<span class="nc" id="L1607">      } catch (IllegalAccessException ex) {</span>
<span class="nc" id="L1608">        Method method = objClass.getDeclaredMethod(&quot;set&quot; + StringUtils.capitalize(fieldNames[i]), String.class);</span>
<span class="nc" id="L1609">        method.invoke(item, fields[i]);</span>
<span class="nc" id="L1610">      }</span>
    }
<span class="nc" id="L1612">    return item;</span>
  }

  /**
   * Converts an object into a tab delimited string with given fields
   * Requires the object has public access for the specified fields
   *
   * @param object Object to convert
   * @param delimiter delimiter
   * @param fieldNames fieldnames
   * @return String representing object
   */
  public static String objectToColumnString(Object object, String delimiter, String[] fieldNames)
          throws IllegalAccessException, NoSuchFieldException, NoSuchMethodException, InvocationTargetException
  {
<span class="nc" id="L1627">    StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L1628" title="All 2 branches missed.">    for (String fieldName : fieldNames) {</span>
<span class="nc bnc" id="L1629" title="All 2 branches missed.">      if (sb.length() &gt; 0) {</span>
<span class="nc" id="L1630">        sb.append(delimiter);</span>
      }
      try {
<span class="nc" id="L1633">        Field field = object.getClass().getDeclaredField(fieldName);</span>
<span class="nc" id="L1634">        sb.append(field.get(object));</span>
<span class="nc" id="L1635">      } catch (IllegalAccessException ex) {</span>
<span class="nc" id="L1636">        Method method = object.getClass().getDeclaredMethod(&quot;get&quot; + StringUtils.capitalize(fieldName));</span>
<span class="nc" id="L1637">        sb.append(method.invoke(object));</span>
<span class="nc" id="L1638">      }</span>
    }
<span class="nc" id="L1640">    return sb.toString();</span>
  }

  /**
   * Uppercases the first character of a string.
   *
   * @param s a string to capitalize
   * @return a capitalized version of the string
   */
  public static String capitalize(String s) {
<span class="nc bnc" id="L1650" title="All 2 branches missed.">    if (Character.isLowerCase(s.charAt(0))) {</span>
<span class="nc" id="L1651">      return Character.toUpperCase(s.charAt(0)) + s.substring(1);</span>
    } else {
<span class="nc" id="L1653">      return s;</span>
    }
  }

  /**
   * Check if a string begins with an uppercase.
   *
   * @param s a string
   * @return true if the string is capitalized
   *         false otherwise
   */
  public static boolean isCapitalized(String s) {
<span class="nc" id="L1665">    return (Character.isUpperCase(s.charAt(0)));</span>
  }

  public static String searchAndReplace(String text, String from, String to) {
<span class="nc" id="L1669">    from = escapeString(from, new char[]{'.', '[', ']', '\\'}, '\\'); // special chars in regex</span>
<span class="nc" id="L1670">    Pattern p = Pattern.compile(from);</span>
<span class="nc" id="L1671">    Matcher m = p.matcher(text);</span>
<span class="nc" id="L1672">    return m.replaceAll(to);</span>
  }

  /**
   * Returns an HTML table containing the matrix of Strings passed in.
   * The first dimension of the matrix should represent the rows, and the
   * second dimension the columns.
   */
  public static String makeHTMLTable(String[][] table, String[] rowLabels, String[] colLabels) {
<span class="nc" id="L1681">    StringBuilder buff = new StringBuilder();</span>
<span class="nc" id="L1682">    buff.append(&quot;&lt;table class=\&quot;auto\&quot; border=\&quot;1\&quot; cellspacing=\&quot;0\&quot;&gt;\n&quot;);</span>
    // top row
<span class="nc" id="L1684">    buff.append(&quot;&lt;tr&gt;\n&quot;);</span>
<span class="nc" id="L1685">    buff.append(&quot;&lt;td&gt;&lt;/td&gt;\n&quot;); // the top left cell</span>
<span class="nc bnc" id="L1686" title="All 2 branches missed.">    for (int j = 0; j &lt; table[0].length; j++) { // assume table is a rectangular matrix</span>
<span class="nc" id="L1687">      buff.append(&quot;&lt;td class=\&quot;label\&quot;&gt;&quot;).append(colLabels[j]).append(&quot;&lt;/td&gt;\n&quot;);</span>
    }
<span class="nc" id="L1689">    buff.append(&quot;&lt;/tr&gt;\n&quot;);</span>
    // all other rows
<span class="nc bnc" id="L1691" title="All 2 branches missed.">    for (int i = 0; i &lt; table.length; i++) {</span>
      // one row
<span class="nc" id="L1693">      buff.append(&quot;&lt;tr&gt;\n&quot;);</span>
<span class="nc" id="L1694">      buff.append(&quot;&lt;td class=\&quot;label\&quot;&gt;&quot;).append(rowLabels[i]).append(&quot;&lt;/td&gt;\n&quot;);</span>
<span class="nc bnc" id="L1695" title="All 2 branches missed.">      for (int j = 0; j &lt; table[i].length; j++) {</span>
<span class="nc" id="L1696">        buff.append(&quot;&lt;td class=\&quot;data\&quot;&gt;&quot;);</span>
<span class="nc bnc" id="L1697" title="All 2 branches missed.">        buff.append(((table[i][j] != null) ? table[i][j] : &quot;&quot;));</span>
<span class="nc" id="L1698">        buff.append(&quot;&lt;/td&gt;\n&quot;);</span>
      }
<span class="nc" id="L1700">      buff.append(&quot;&lt;/tr&gt;\n&quot;);</span>
    }
<span class="nc" id="L1702">    buff.append(&quot;&lt;/table&gt;&quot;);</span>
<span class="nc" id="L1703">    return buff.toString();</span>
  }

  /**
   * Returns a text table containing the matrix of objects passed in.
   * The first dimension of the matrix should represent the rows, and the
   * second dimension the columns. Each object is printed in a cell with toString().
   * The printing may be padded with spaces on the left and then on the right to
   * ensure that the String form is of length at least padLeft or padRight.
   * If tsv is true, a tab is put between columns.
   *
   * @return A String form of the table
   */
  public static String makeTextTable(Object[][] table, Object[] rowLabels, Object[] colLabels, int padLeft, int padRight, boolean tsv) {
<span class="nc" id="L1717">    StringBuilder buff = new StringBuilder();</span>
<span class="nc bnc" id="L1718" title="All 2 branches missed.">    if (colLabels != null) {</span>
      // top row
<span class="nc" id="L1720">      buff.append(makeAsciiTableCell(&quot;&quot;, padLeft, padRight, tsv)); // the top left cell</span>
<span class="nc bnc" id="L1721" title="All 2 branches missed.">      for (int j = 0; j &lt; table[0].length; j++) { // assume table is a rectangular matrix</span>
<span class="nc bnc" id="L1722" title="All 4 branches missed.">        buff.append(makeAsciiTableCell(colLabels[j], padLeft, padRight, (j != table[0].length - 1) &amp;&amp; tsv));</span>
      }
<span class="nc" id="L1724">      buff.append('\n');</span>
    }
    // all other rows
<span class="nc bnc" id="L1727" title="All 2 branches missed.">    for (int i = 0; i &lt; table.length; i++) {</span>
      // one row
<span class="nc bnc" id="L1729" title="All 2 branches missed.">      if (rowLabels != null) {</span>
<span class="nc" id="L1730">        buff.append(makeAsciiTableCell(rowLabels[i], padLeft, padRight, tsv));</span>
      }
<span class="nc bnc" id="L1732" title="All 2 branches missed.">      for (int j = 0; j &lt; table[i].length; j++) {</span>
<span class="nc bnc" id="L1733" title="All 4 branches missed.">        buff.append(makeAsciiTableCell(table[i][j], padLeft, padRight, (j != table[0].length - 1) &amp;&amp; tsv));</span>
      }
<span class="nc" id="L1735">      buff.append('\n');</span>
    }
<span class="nc" id="L1737">    return buff.toString();</span>
  }


  /** The cell String is the string representation of the object.
   *  If padLeft is greater than 0, it is padded. Ditto right
   *
   */
  private static String makeAsciiTableCell(Object obj, int padLeft, int padRight, boolean tsv) {
<span class="nc" id="L1746">    String result = obj.toString();</span>
<span class="nc bnc" id="L1747" title="All 2 branches missed.">    if (padLeft &gt; 0) {</span>
<span class="nc" id="L1748">      result = padLeft(result, padLeft);</span>
    }
<span class="nc bnc" id="L1750" title="All 2 branches missed.">    if (padRight &gt; 0) {</span>
<span class="nc" id="L1751">      result = pad(result, padRight);</span>
    }
<span class="nc bnc" id="L1753" title="All 2 branches missed.">    if (tsv) {</span>
<span class="nc" id="L1754">      result = result + '\t';</span>
    }
<span class="nc" id="L1756">    return result;</span>
  }

  /**
   * Tests the string edit distance function.
   */
  public static void main(String[] args) {

<span class="nc" id="L1764">    String[] s = {&quot;there once was a man&quot;, &quot;this one is a manic&quot;, &quot;hey there&quot;, &quot;there once was a mane&quot;, &quot;once in a manger.&quot;, &quot;where is one match?&quot;, &quot;Jo3seph Smarr!&quot;, &quot;Joseph R Smarr&quot;};</span>
<span class="nc bnc" id="L1765" title="All 2 branches missed.">    for (int i = 0; i &lt; 8; i++) {</span>
<span class="nc bnc" id="L1766" title="All 2 branches missed.">      for (int j = 0; j &lt; 8; j++) {</span>
<span class="nc" id="L1767">        System.out.println(&quot;s1: &quot; + s[i]);</span>
<span class="nc" id="L1768">        System.out.println(&quot;s2: &quot; + s[j]);</span>
<span class="nc" id="L1769">        System.out.println(&quot;edit distance: &quot; + editDistance(s[i], s[j]));</span>
<span class="nc" id="L1770">        System.out.println(&quot;LCS:           &quot; + longestCommonSubstring(s[i], s[j]));</span>
<span class="nc" id="L1771">        System.out.println(&quot;LCCS:          &quot; + longestCommonContiguousSubstring(s[i], s[j]));</span>
<span class="nc" id="L1772">        System.out.println();</span>
      }
    }
<span class="nc" id="L1775">  }</span>

  public static String toAscii(String s) {
<span class="fc" id="L1778">    StringBuilder b = new StringBuilder();</span>
<span class="fc bfc" id="L1779" title="All 2 branches covered.">    for (int i = 0; i &lt; s.length(); i++) {</span>
<span class="fc" id="L1780">      char c = s.charAt(i);</span>
<span class="pc bpc" id="L1781" title="1 of 2 branches missed.">      if (c &gt; 127) {</span>
<span class="nc" id="L1782">        String result = &quot;?&quot;;</span>
<span class="nc bnc" id="L1783" title="All 4 branches missed.">        if (c &gt;= 0x00c0 &amp;&amp; c &lt;= 0x00c5) {</span>
<span class="nc" id="L1784">          result = &quot;A&quot;;</span>
<span class="nc bnc" id="L1785" title="All 2 branches missed.">        } else if (c == 0x00c6) {</span>
<span class="nc" id="L1786">          result = &quot;AE&quot;;</span>
<span class="nc bnc" id="L1787" title="All 2 branches missed.">        } else if (c == 0x00c7) {</span>
<span class="nc" id="L1788">          result = &quot;C&quot;;</span>
<span class="nc bnc" id="L1789" title="All 4 branches missed.">        } else if (c &gt;= 0x00c8 &amp;&amp; c &lt;= 0x00cb) {</span>
<span class="nc" id="L1790">          result = &quot;E&quot;;</span>
<span class="nc bnc" id="L1791" title="All 4 branches missed.">        } else if (c &gt;= 0x00cc &amp;&amp; c &lt;= 0x00cf) {</span>
<span class="nc" id="L1792">          result = &quot;F&quot;;</span>
<span class="nc bnc" id="L1793" title="All 2 branches missed.">        } else if (c == 0x00d0) {</span>
<span class="nc" id="L1794">          result = &quot;D&quot;;</span>
<span class="nc bnc" id="L1795" title="All 2 branches missed.">        } else if (c == 0x00d1) {</span>
<span class="nc" id="L1796">          result = &quot;N&quot;;</span>
<span class="nc bnc" id="L1797" title="All 4 branches missed.">        } else if (c &gt;= 0x00d2 &amp;&amp; c &lt;= 0x00d6) {</span>
<span class="nc" id="L1798">          result = &quot;O&quot;;</span>
<span class="nc bnc" id="L1799" title="All 2 branches missed.">        } else if (c == 0x00d7) {</span>
<span class="nc" id="L1800">          result = &quot;x&quot;;</span>
<span class="nc bnc" id="L1801" title="All 2 branches missed.">        } else if (c == 0x00d8) {</span>
<span class="nc" id="L1802">          result = &quot;O&quot;;</span>
<span class="nc bnc" id="L1803" title="All 4 branches missed.">        } else if (c &gt;= 0x00d9 &amp;&amp; c &lt;= 0x00dc) {</span>
<span class="nc" id="L1804">          result = &quot;U&quot;;</span>
<span class="nc bnc" id="L1805" title="All 2 branches missed.">        } else if (c == 0x00dd) {</span>
<span class="nc" id="L1806">          result = &quot;Y&quot;;</span>
<span class="nc bnc" id="L1807" title="All 4 branches missed.">        } else if (c &gt;= 0x00e0 &amp;&amp; c &lt;= 0x00e5) {</span>
<span class="nc" id="L1808">          result = &quot;a&quot;;</span>
<span class="nc bnc" id="L1809" title="All 2 branches missed.">        } else if (c == 0x00e6) {</span>
<span class="nc" id="L1810">          result = &quot;ae&quot;;</span>
<span class="nc bnc" id="L1811" title="All 2 branches missed.">        } else if (c == 0x00e7) {</span>
<span class="nc" id="L1812">          result = &quot;c&quot;;</span>
<span class="nc bnc" id="L1813" title="All 4 branches missed.">        } else if (c &gt;= 0x00e8 &amp;&amp; c &lt;= 0x00eb) {</span>
<span class="nc" id="L1814">          result = &quot;e&quot;;</span>
<span class="nc bnc" id="L1815" title="All 4 branches missed.">        } else if (c &gt;= 0x00ec &amp;&amp; c &lt;= 0x00ef) {</span>
<span class="nc" id="L1816">          result = &quot;i&quot;;</span>
<span class="nc bnc" id="L1817" title="All 2 branches missed.">        } else if (c == 0x00f1) {</span>
<span class="nc" id="L1818">          result = &quot;n&quot;;</span>
<span class="nc bnc" id="L1819" title="All 4 branches missed.">        } else if (c &gt;= 0x00f2 &amp;&amp; c &lt;= 0x00f8) {</span>
<span class="nc" id="L1820">          result = &quot;o&quot;;</span>
<span class="nc bnc" id="L1821" title="All 4 branches missed.">        } else if (c &gt;= 0x00f9 &amp;&amp; c &lt;= 0x00fc) {</span>
<span class="nc" id="L1822">          result = &quot;u&quot;;</span>
<span class="nc bnc" id="L1823" title="All 4 branches missed.">        } else if (c &gt;= 0x00fd &amp;&amp; c &lt;= 0x00ff) {</span>
<span class="nc" id="L1824">          result = &quot;y&quot;;</span>
<span class="nc bnc" id="L1825" title="All 4 branches missed.">        } else if (c &gt;= 0x2018 &amp;&amp; c &lt;= 0x2019) {</span>
<span class="nc" id="L1826">          result = &quot;\'&quot;;</span>
<span class="nc bnc" id="L1827" title="All 4 branches missed.">        } else if (c &gt;= 0x201c &amp;&amp; c &lt;= 0x201e) {</span>
<span class="nc" id="L1828">          result = &quot;\&quot;&quot;;</span>
<span class="nc bnc" id="L1829" title="All 4 branches missed.">        } else if (c &gt;= 0x0213 &amp;&amp; c &lt;= 0x2014) {</span>
<span class="nc" id="L1830">          result = &quot;-&quot;;</span>
<span class="nc bnc" id="L1831" title="All 4 branches missed.">        } else if (c &gt;= 0x00A2 &amp;&amp; c &lt;= 0x00A5) {</span>
<span class="nc" id="L1832">          result = &quot;$&quot;;</span>
<span class="nc bnc" id="L1833" title="All 2 branches missed.">        } else if (c == 0x2026) {</span>
<span class="nc" id="L1834">          result = &quot;.&quot;;</span>
        }
<span class="nc" id="L1836">        b.append(result);</span>
<span class="nc" id="L1837">      } else {</span>
<span class="fc" id="L1838">        b.append(c);</span>
      }
    }
<span class="fc" id="L1841">    return b.toString();</span>
  }


  public static String toCSVString(String[] fields) {
<span class="nc" id="L1846">    StringBuilder b = new StringBuilder();</span>
<span class="nc bnc" id="L1847" title="All 2 branches missed.">    for (String fld : fields) {</span>
<span class="nc bnc" id="L1848" title="All 2 branches missed.">      if (b.length() &gt; 0) {</span>
<span class="nc" id="L1849">        b.append(',');</span>
      }
<span class="nc" id="L1851">      String field = escapeString(fld, new char[]{'\&quot;'}, '\&quot;'); // escape quotes with double quotes</span>
<span class="nc" id="L1852">      b.append('\&quot;').append(field).append('\&quot;');</span>
    }
<span class="nc" id="L1854">    return b.toString();</span>
  }

  /**
   * Swap any occurrences of any characters in the from String in the input String with
   * the corresponding character from the to String.  As Perl tr, for example,
   * tr(&quot;chris&quot;, &quot;irs&quot;, &quot;mop&quot;).equals(&quot;chomp&quot;), except it does not
   * support regular expression character ranges.
   * &lt;p&gt;
   * &lt;i&gt;Note:&lt;/i&gt; This is now optimized to not allocate any objects if the
   * input is returned unchanged.
   */
  public static String tr(String input, String from, String to) {
<span class="pc bpc" id="L1867" title="2 of 4 branches missed.">    assert from.length() == to.length();</span>
<span class="fc" id="L1868">    StringBuilder sb = null;</span>
<span class="fc" id="L1869">    int len = input.length();</span>
<span class="fc bfc" id="L1870" title="All 2 branches covered.">    for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L1871">      int ind = from.indexOf(input.charAt(i));</span>
<span class="fc bfc" id="L1872" title="All 2 branches covered.">      if (ind &gt;= 0) {</span>
<span class="fc bfc" id="L1873" title="All 2 branches covered.">        if (sb == null) {</span>
<span class="fc" id="L1874">          sb = new StringBuilder(input);</span>
        }
<span class="fc" id="L1876">        sb.setCharAt(i, to.charAt(ind));</span>
      }
    }
<span class="pc bpc" id="L1879" title="1 of 2 branches missed.">    if (sb == null) {</span>
<span class="nc" id="L1880">      return input;</span>
    } else {
<span class="fc" id="L1882">      return sb.toString();</span>
    }
  }

  /**
   * Returns the supplied string with any trailing '\n' or '\r\n' removed.
   */
  public static String chomp(String s) {
<span class="nc bnc" id="L1890" title="All 2 branches missed.">    if (s == null) {</span>
<span class="nc" id="L1891">      return null;</span>
    }
<span class="nc" id="L1893">    int l_1 = s.length() - 1;</span>
<span class="nc bnc" id="L1894" title="All 4 branches missed.">    if (l_1 &gt;= 0 &amp;&amp; s.charAt(l_1) == '\n') {</span>
<span class="nc" id="L1895">      int l_2 = l_1 - 1;</span>
<span class="nc bnc" id="L1896" title="All 4 branches missed.">      if (l_2 &gt;= 0 &amp;&amp; s.charAt(l_2) == '\r') {</span>
<span class="nc" id="L1897">        return s.substring(0, l_2);</span>
      } else {
<span class="nc" id="L1899">        return s.substring(0, l_1);</span>
      }
    } else {
<span class="nc" id="L1902">      return s;</span>
    }
  }

  /**
   * Returns the result of calling toString() on the supplied Object, but with
   * any trailing '\n' or '\r\n' removed.
   */
  public static String chomp(Object o) {
<span class="nc" id="L1911">    return chomp(o.toString());</span>
  }


  /**
   * Strip directory from filename.  Like Unix 'basename'. &lt;p/&gt;
   *
   * Example: {@code getBaseName(&quot;/u/wcmac/foo.txt&quot;) ==&gt; &quot;foo.txt&quot;}
   */
  public static String getBaseName(String fileName) {
<span class="fc" id="L1921">    return getBaseName(fileName, &quot;&quot;);</span>
  }

  /**
   * Strip directory and suffix from filename.  Like Unix 'basename'.
   *
   * Example: {@code getBaseName(&quot;/u/wcmac/foo.txt&quot;, &quot;&quot;) ==&gt; &quot;foo.txt&quot;}&lt;br/&gt;
   * Example: {@code getBaseName(&quot;/u/wcmac/foo.txt&quot;, &quot;.txt&quot;) ==&gt; &quot;foo&quot;}&lt;br/&gt;
   * Example: {@code getBaseName(&quot;/u/wcmac/foo.txt&quot;, &quot;.pdf&quot;) ==&gt; &quot;foo.txt&quot;}&lt;br/&gt;
   */
  public static String getBaseName(String fileName, String suffix) {
<span class="fc" id="L1932">    return getBaseName(fileName, suffix, &quot;/&quot;);</span>
  }

  /**
   * Strip directory and suffix from the given name.  Like Unix 'basename'.
   *
   * Example: {@code getBaseName(&quot;/tmp/foo/bar/foo&quot;, &quot;&quot;, &quot;/&quot;) ==&gt; &quot;foo&quot;}&lt;br/&gt;
   * Example: {@code getBaseName(&quot;edu.stanford.nlp&quot;, &quot;&quot;, &quot;\\.&quot;) ==&gt; &quot;nlp&quot;}&lt;br/&gt;
   */
  public static String getBaseName(String fileName, String suffix, String sep) {
<span class="fc" id="L1942">    String[] elts = fileName.split(sep);</span>
<span class="pc bpc" id="L1943" title="1 of 2 branches missed.">    if (elts.length == 0) return &quot;&quot;;</span>
<span class="fc" id="L1944">    String lastElt = elts[elts.length - 1];</span>
<span class="fc bfc" id="L1945" title="All 2 branches covered.">    if (lastElt.endsWith(suffix)) {</span>
<span class="fc" id="L1946">      lastElt = lastElt.substring(0, lastElt.length() - suffix.length());</span>
    }
<span class="fc" id="L1948">    return lastElt;</span>
  }

  /**
   * Given a String the method uses Regex to check if the String only contains alphabet characters
   *
   * @param s a String to check using regex
   * @return true if the String is valid
   */
  public static boolean isAlpha(String s){
<span class="nc" id="L1958">    Pattern p = Pattern.compile(&quot;^[\\p{Alpha}\\s]+$&quot;);</span>
<span class="nc" id="L1959">    Matcher m = p.matcher(s);</span>
<span class="nc" id="L1960">    return m.matches();</span>
  }

  /**
   * Given a String the method uses Regex to check if the String only contains numeric characters
   *
   * @param s a String to check using regex
   * @return true if the String is valid
   */
  public static boolean isNumeric(String s){
<span class="fc" id="L1970">    Pattern p = Pattern.compile(&quot;^[\\p{Digit}\\s\\.]+$&quot;);</span>
<span class="fc" id="L1971">    Matcher m = p.matcher(s);</span>
<span class="fc" id="L1972">    return m.matches();</span>
  }

  /**
   * Given a String the method uses Regex to check if the String only contains alphanumeric characters
   *
   * @param s a String to check using regex
   * @return true if the String is valid
   */
  public static boolean isAlphanumeric(String s){
<span class="nc" id="L1982">    Pattern p = Pattern.compile(&quot;^[\\p{Alnum}\\s\\.]+$&quot;);</span>
<span class="nc" id="L1983">    Matcher m = p.matcher(s);</span>
<span class="nc" id="L1984">    return m.matches();</span>
  }

  /**
   * Given a String the method uses Regex to check if the String only contains punctuation characters
   *
   * @param s a String to check using regex
   * @return true if the String is valid
   */
  public static boolean isPunct(String s){
<span class="fc" id="L1994">    Pattern p = Pattern.compile(&quot;^[\\p{Punct}]+$&quot;);</span>
<span class="fc" id="L1995">    Matcher m = p.matcher(s);</span>
<span class="fc" id="L1996">    return m.matches();</span>
  }

  /**
   * Given a String the method uses Regex to check if the String looks like an acronym
   *
   * @param s a String to check using regex
   * @return true if the String is valid
   */
  public static boolean isAcronym(String s){
<span class="nc" id="L2006">    Pattern p = Pattern.compile(&quot;^[\\p{Upper}]+$&quot;);</span>
<span class="nc" id="L2007">    Matcher m = p.matcher(s);</span>
<span class="nc" id="L2008">    return m.matches();</span>
  }

  public static String getNotNullString(String s) {
<span class="nc bnc" id="L2012" title="All 2 branches missed.">    if (s == null)</span>
<span class="nc" id="L2013">      return &quot;&quot;;</span>
    else
<span class="nc" id="L2015">      return s;</span>
  }

  /** Returns whether a String is either null or empty.
   *  (Copies the Guava method for this.)
   *
   *  @param str The String to test
   *  @return Whether the String is either null or empty
   */
  public static boolean isNullOrEmpty(String str) {
<span class="fc bfc" id="L2025" title="All 4 branches covered.">    return str == null || str.equals(&quot;&quot;);</span>
  }


  /**
   * Resolve variable. If it is the props file, then substitute that variable with
   * the value mentioned in the props file, otherwise look for the variable in the environment variables.
   * If the variable is not found then substitute it for empty string.
   */
  public static String resolveVars(String str, Map props) {
<span class="nc bnc" id="L2035" title="All 2 branches missed.">    if (str == null)</span>
<span class="nc" id="L2036">      return null;</span>
    // ${VAR_NAME} or $VAR_NAME
<span class="nc" id="L2038">    Pattern p = Pattern.compile(&quot;\\$\\{(\\w+)\\}&quot;);</span>
<span class="nc" id="L2039">    Matcher m = p.matcher(str);</span>
<span class="nc" id="L2040">    StringBuffer sb = new StringBuffer();</span>
<span class="nc bnc" id="L2041" title="All 2 branches missed.">    while (m.find()) {</span>
<span class="nc bnc" id="L2042" title="All 2 branches missed.">      String varName = null == m.group(1) ? m.group(2) : m.group(1);</span>
      String vrValue;
      //either in the props file
<span class="nc bnc" id="L2045" title="All 2 branches missed.">      if (props.containsKey(varName)) {</span>
<span class="nc" id="L2046">        vrValue = ((String) props.get(varName));</span>
      } else {
        //or as the environment variable
<span class="nc" id="L2049">        vrValue = System.getenv(varName);</span>
      }
<span class="nc bnc" id="L2051" title="All 2 branches missed.">      m.appendReplacement(sb, null == vrValue ? &quot;&quot; : vrValue);</span>
<span class="nc" id="L2052">    }</span>
<span class="nc" id="L2053">    m.appendTail(sb);</span>
<span class="nc" id="L2054">    return sb.toString();</span>
  }


  /**
   * convert args to properties with variable names resolved. for each value
   * having a ${VAR} or $VAR, its value is first resolved using the variables
   * listed in the props file, and if not found then using the environment
   * variables. if the variable is not found then substitute it for empty string
   */
  public static Properties argsToPropertiesWithResolve(String[] args) {
<span class="nc" id="L2065">    LinkedHashMap&lt;String, String&gt; result = new LinkedHashMap&lt;&gt;();</span>
<span class="nc" id="L2066">    Map&lt;String, String&gt; existingArgs = new LinkedHashMap&lt;&gt;();</span>

<span class="nc bnc" id="L2068" title="All 2 branches missed.">    for (int i = 0; i &lt; args.length; i++) {</span>
<span class="nc" id="L2069">      String key = args[i];</span>
<span class="nc bnc" id="L2070" title="All 4 branches missed.">      if (key.length() &gt; 0 &amp;&amp; key.charAt(0) == '-') { // found a flag</span>
<span class="nc bnc" id="L2071" title="All 4 branches missed.">        if (key.length() &gt; 1 &amp;&amp; key.charAt(1) == '-')</span>
<span class="nc" id="L2072">          key = key.substring(2); // strip off 2 hyphens</span>
        else
<span class="nc" id="L2074">          key = key.substring(1); // strip off the hyphen</span>

<span class="nc" id="L2076">        int max = 1;</span>
<span class="nc" id="L2077">        int min = 0;</span>
<span class="nc" id="L2078">        List&lt;String&gt; flagArgs = new ArrayList&lt;&gt;();</span>
        // cdm oct 2007: add length check to allow for empty string argument!
<span class="nc bnc" id="L2080" title="All 10 branches missed.">        for (int j = 0; j &lt; max &amp;&amp; i + 1 &lt; args.length &amp;&amp; (j &lt; min || args[i + 1].length() == 0 || args[i + 1].charAt(0) != '-'); i++, j++) {</span>
<span class="nc" id="L2081">          flagArgs.add(args[i + 1]);</span>
        }

<span class="nc bnc" id="L2084" title="All 2 branches missed.">        if (flagArgs.isEmpty()) {</span>
<span class="nc" id="L2085">          existingArgs.put(key, &quot;true&quot;);</span>
        } else {

<span class="nc bnc" id="L2088" title="All 10 branches missed.">          if (key.equalsIgnoreCase(PROP) || key.equalsIgnoreCase(PROPS) || key.equalsIgnoreCase(PROPERTIES) || key.equalsIgnoreCase(ARGUMENTS) || key.equalsIgnoreCase(ARGS)) {</span>
<span class="nc bnc" id="L2089" title="All 2 branches missed.">            for(String flagArg: flagArgs)</span>
<span class="nc" id="L2090">              result.putAll(propFileToLinkedHashMap(flagArg, existingArgs));</span>

<span class="nc" id="L2092">            existingArgs.clear();</span>
          } else
<span class="nc" id="L2094">            existingArgs.put(key, join(flagArgs, &quot; &quot;));</span>
        }
      }
    }
<span class="nc" id="L2098">    result.putAll(existingArgs);</span>

<span class="nc bnc" id="L2100" title="All 2 branches missed.">    for (Entry&lt;String, String&gt; o : result.entrySet()) {</span>
<span class="nc" id="L2101">      String val = resolveVars(o.getValue(), result);</span>
<span class="nc" id="L2102">      result.put(o.getKey(), val);</span>
<span class="nc" id="L2103">    }</span>
<span class="nc" id="L2104">    Properties props = new Properties();</span>
<span class="nc" id="L2105">    props.putAll(result);</span>
<span class="nc" id="L2106">    return props;</span>
  }

  /**
   * This method reads in properties listed in a file in the format prop=value,
   * one property per line. and reads them into a LinkedHashMap (insertion order preserving)
   * Flags not having any arguments is set to &quot;true&quot;.
   *
   * @param filename A properties file to read
   * @return The corresponding LinkedHashMap where the ordering is the same as in the
   *         props file
   */
  public static LinkedHashMap&lt;String, String&gt; propFileToLinkedHashMap(String filename, Map&lt;String, String&gt; existingArgs) {

<span class="nc" id="L2120">    LinkedHashMap&lt;String, String&gt; result = new LinkedHashMap&lt;&gt;(existingArgs);</span>
<span class="nc bnc" id="L2121" title="All 2 branches missed.">    for (String l : IOUtils.readLines(filename)) {</span>
<span class="nc" id="L2122">      l = l.trim();</span>
<span class="nc bnc" id="L2123" title="All 4 branches missed.">      if (l.isEmpty() || l.startsWith(&quot;#&quot;))</span>
<span class="nc" id="L2124">        continue;</span>
<span class="nc" id="L2125">      int index = l.indexOf('=');</span>

<span class="nc bnc" id="L2127" title="All 2 branches missed.">      if (index == -1)</span>
<span class="nc" id="L2128">        result.put(l, &quot;true&quot;);</span>
      else
<span class="nc" id="L2130">        result.put(l.substring(0, index).trim(), l.substring(index + 1).trim());</span>
<span class="nc" id="L2131">    }</span>
<span class="nc" id="L2132">    return result;</span>
  }

  /**
   * n grams for already splitted string. the ngrams are joined with a single space
   */
  public static Collection&lt;String&gt; getNgrams(List&lt;String&gt; words, int minSize, int maxSize){
<span class="nc" id="L2139">    List&lt;List&lt;String&gt;&gt; ng = CollectionUtils.getNGrams(words, minSize, maxSize);</span>
<span class="nc" id="L2140">    Collection&lt;String&gt; ngrams = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L2141" title="All 2 branches missed.">    for(List&lt;String&gt; n: ng)</span>
<span class="nc" id="L2142">      ngrams.add(StringUtils.join(n,&quot; &quot;));</span>

<span class="nc" id="L2144">    return ngrams;</span>
  }

  /**
   * n grams for already splitted string. the ngrams are joined with a single space
   */
  public static Collection&lt;String&gt; getNgramsFromTokens(List&lt;CoreLabel&gt; words, int minSize, int maxSize){
<span class="nc" id="L2151">    List&lt;String&gt; wordsStr = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L2152" title="All 2 branches missed.">    for(CoreLabel l : words)</span>
<span class="nc" id="L2153">      wordsStr.add(l.word());</span>
<span class="nc" id="L2154">    List&lt;List&lt;String&gt;&gt; ng = CollectionUtils.getNGrams(wordsStr, minSize, maxSize);</span>
<span class="nc" id="L2155">    Collection&lt;String&gt; ngrams = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L2156" title="All 2 branches missed.">    for(List&lt;String&gt; n: ng)</span>
<span class="nc" id="L2157">      ngrams.add(StringUtils.join(n,&quot; &quot;));</span>

<span class="nc" id="L2159">    return ngrams;</span>
  }

  /**
   * The string is split on whitespace and the ngrams are joined with a single space
   */
  public static Collection&lt;String&gt; getNgramsString(String s, int minSize, int maxSize){
<span class="nc" id="L2166">    return getNgrams(Arrays.asList(s.split(&quot;\\s+&quot;)), minSize, maxSize);</span>
  }

  /**
   * Build a list of character-based ngrams from the given string.
   */
  public static Collection&lt;String&gt; getCharacterNgrams(String s, int minSize, int maxSize) {
<span class="fc" id="L2173">    Collection&lt;String&gt; ngrams = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L2174">    int len = s.length();</span>

<span class="fc bfc" id="L2176" title="All 2 branches covered.">    for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L2177">      for (int ngramSize = minSize;</span>
<span class="fc bfc" id="L2178" title="All 6 branches covered.">           ngramSize &gt; 0 &amp;&amp; ngramSize &lt;= maxSize &amp;&amp; i + ngramSize &lt;= len;</span>
<span class="fc" id="L2179">           ngramSize++) {</span>
<span class="fc" id="L2180">        ngrams.add(s.substring(i, i + ngramSize));</span>
      }
    }

<span class="fc" id="L2184">    return ngrams;</span>
  }

<span class="fc" id="L2187">  private static Pattern diacriticalMarksPattern = Pattern.compile(&quot;\\p{InCombiningDiacriticalMarks}&quot;);</span>
  public static String normalize(String s) {
    // Normalizes string and strips diacritics (map to ascii) by
    // 1. taking the NFKD (compatibility decomposition -
    //   in compatibility equivalence, formatting such as subscripting is lost -
    //   see http://unicode.org/reports/tr15/)
    // 2. Removing diacriticals
    // 3. Recombining into NFKC form (compatibility composition)
    // This process may be slow.
    //
    // The main purpose of the function is to remove diacritics for asciis,
    //  but it may normalize other stuff as well.
    // A more conservative approach is to do explicit folding just for ascii character
    //   (see RuleBasedNameMatcher.normalize)
<span class="fc" id="L2201">    String d = Normalizer.normalize(s, Normalizer.Form.NFKD);</span>
<span class="fc" id="L2202">    d = diacriticalMarksPattern.matcher(d).replaceAll(&quot;&quot;);</span>
<span class="fc" id="L2203">    return Normalizer.normalize(d, Normalizer.Form.NFKC);</span>
  }

  /**
   * Convert a list of labels into a string, by simply joining them with spaces.
   * @param words The words to join.
   * @return A string representation of the sentence, tokenized by a single space.
   */
  public static String toString(List&lt;CoreLabel&gt; words) {
<span class="nc" id="L2212">    return join(words.stream().map(CoreLabel::word), &quot; &quot;);</span>
  }

  /**
   * Convert a CoreMap representing a sentence into a string, by simply joining them with spaces.
   * @param sentence The sentence to stringify.
   * @return A string representation of the sentence, tokenized by a single space.
   */
  public static String toString(CoreMap sentence) {
<span class="nc" id="L2221">    return toString(sentence.get(CoreAnnotations.TokensAnnotation.class));</span>
  }

  /** I shamefully stole this from: http://rosettacode.org/wiki/Levenshtein_distance#Java --Gabor */
  public static int levenshteinDistance(String s1, String s2) {
<span class="nc" id="L2226">    s1 = s1.toLowerCase();</span>
<span class="nc" id="L2227">    s2 = s2.toLowerCase();</span>

<span class="nc" id="L2229">    int[] costs = new int[s2.length() + 1];</span>
<span class="nc bnc" id="L2230" title="All 2 branches missed.">    for (int i = 0; i &lt;= s1.length(); i++) {</span>
<span class="nc" id="L2231">      int lastValue = i;</span>
<span class="nc bnc" id="L2232" title="All 2 branches missed.">      for (int j = 0; j &lt;= s2.length(); j++) {</span>
<span class="nc bnc" id="L2233" title="All 2 branches missed.">        if (i == 0)</span>
<span class="nc" id="L2234">          costs[j] = j;</span>
        else {
<span class="nc bnc" id="L2236" title="All 2 branches missed.">          if (j &gt; 0) {</span>
<span class="nc" id="L2237">            int newValue = costs[j - 1];</span>
<span class="nc bnc" id="L2238" title="All 2 branches missed.">            if (s1.charAt(i - 1) != s2.charAt(j - 1))</span>
<span class="nc" id="L2239">              newValue = Math.min(Math.min(newValue, lastValue), costs[j]) + 1;</span>
<span class="nc" id="L2240">            costs[j - 1] = lastValue;</span>
<span class="nc" id="L2241">            lastValue = newValue;</span>
          }
        }
      }
<span class="nc bnc" id="L2245" title="All 2 branches missed.">      if (i &gt; 0)</span>
<span class="nc" id="L2246">        costs[s2.length()] = lastValue;</span>
    }
<span class="nc" id="L2248">    return costs[s2.length()];</span>
  }

  /** I shamefully stole this from: http://rosettacode.org/wiki/Levenshtein_distance#Java --Gabor */
  public static &lt;E&gt; int levenshteinDistance(E[] s1, E[] s2) {

<span class="nc" id="L2254">    int[] costs = new int[s2.length + 1];</span>
<span class="nc bnc" id="L2255" title="All 2 branches missed.">    for (int i = 0; i &lt;= s1.length; i++) {</span>
<span class="nc" id="L2256">      int lastValue = i;</span>
<span class="nc bnc" id="L2257" title="All 2 branches missed.">      for (int j = 0; j &lt;= s2.length; j++) {</span>
<span class="nc bnc" id="L2258" title="All 2 branches missed.">        if (i == 0)</span>
<span class="nc" id="L2259">          costs[j] = j;</span>
        else {
<span class="nc bnc" id="L2261" title="All 2 branches missed.">          if (j &gt; 0) {</span>
<span class="nc" id="L2262">            int newValue = costs[j - 1];</span>
<span class="nc bnc" id="L2263" title="All 2 branches missed.">            if (!s1[i - 1].equals(s2[j - 1]))</span>
<span class="nc" id="L2264">              newValue = Math.min(Math.min(newValue, lastValue), costs[j]) + 1;</span>
<span class="nc" id="L2265">            costs[j - 1] = lastValue;</span>
<span class="nc" id="L2266">            lastValue = newValue;</span>
          }
        }
      }
<span class="nc bnc" id="L2270" title="All 2 branches missed.">      if (i &gt; 0)</span>
<span class="nc" id="L2271">        costs[s2.length] = lastValue;</span>
    }
<span class="nc" id="L2273">    return costs[s2.length];</span>
  }

  /**
   * Unescape an HTML string.
   * Taken from: http://stackoverflow.com/questions/994331/java-how-to-decode-html-character-entities-in-java-like-httputility-htmldecode
   * @param input The string to unescape
   * @return The unescaped String
   */
  public static String unescapeHtml3(final String input) {
<span class="nc" id="L2283">        StringWriter writer = null;</span>
<span class="nc" id="L2284">        int len = input.length();</span>
<span class="nc" id="L2285">        int i = 1;</span>
<span class="nc" id="L2286">        int st = 0;</span>
        while (true) {
            // look for '&amp;'
<span class="nc bnc" id="L2289" title="All 4 branches missed.">            while (i &lt; len &amp;&amp; input.charAt(i-1) != '&amp;')</span>
<span class="nc" id="L2290">                i++;</span>
<span class="nc bnc" id="L2291" title="All 2 branches missed.">            if (i &gt;= len)</span>
<span class="nc" id="L2292">                break;</span>

            // found '&amp;', look for ';'
<span class="nc" id="L2295">            int j = i;</span>
<span class="nc bnc" id="L2296" title="All 6 branches missed.">            while (j &lt; len &amp;&amp; j &lt; i + 6 + 1 &amp;&amp; input.charAt(j) != ';')</span>
<span class="nc" id="L2297">                j++;</span>
<span class="nc bnc" id="L2298" title="All 6 branches missed.">            if (j == len || j &lt; i + 2 || j == i + 6 + 1) {</span>
<span class="nc" id="L2299">                i++;</span>
<span class="nc" id="L2300">                continue;</span>
            }

            // found escape
<span class="nc bnc" id="L2304" title="All 2 branches missed.">            if (input.charAt(i) == '#') {</span>
                // numeric escape
<span class="nc" id="L2306">                int k = i + 1;</span>
<span class="nc" id="L2307">                int radix = 10;</span>

<span class="nc" id="L2309">                final char firstChar = input.charAt(k);</span>
<span class="nc bnc" id="L2310" title="All 4 branches missed.">                if (firstChar == 'x' || firstChar == 'X') {</span>
<span class="nc" id="L2311">                    k++;</span>
<span class="nc" id="L2312">                    radix = 16;</span>
                }

                try {
<span class="nc" id="L2316">                    int entityValue = Integer.parseInt(input.substring(k, j), radix);</span>

<span class="nc bnc" id="L2318" title="All 2 branches missed.">                    if (writer == null)</span>
<span class="nc" id="L2319">                        writer = new StringWriter(input.length());</span>
<span class="nc" id="L2320">                    writer.append(input.substring(st, i - 1));</span>

<span class="nc bnc" id="L2322" title="All 2 branches missed.">                    if (entityValue &gt; 0xFFFF) {</span>
<span class="nc" id="L2323">                        final char[] chrs = Character.toChars(entityValue);</span>
<span class="nc" id="L2324">                        writer.write(chrs[0]);</span>
<span class="nc" id="L2325">                        writer.write(chrs[1]);</span>
<span class="nc" id="L2326">                    } else {</span>
<span class="nc" id="L2327">                        writer.write(entityValue);</span>
                    }

<span class="nc" id="L2330">                } catch (NumberFormatException ex) {</span>
<span class="nc" id="L2331">                    i++;</span>
<span class="nc" id="L2332">                    continue;</span>
<span class="nc" id="L2333">                }</span>
<span class="nc" id="L2334">            }</span>
            else {
                // named escape
<span class="nc" id="L2337">                CharSequence value = htmlUnescapeLookupMap.get(input.substring(i, j));</span>
<span class="nc bnc" id="L2338" title="All 2 branches missed.">                if (value == null) {</span>
<span class="nc" id="L2339">                    i++;</span>
<span class="nc" id="L2340">                    continue;</span>
                }

<span class="nc bnc" id="L2343" title="All 2 branches missed.">                if (writer == null)</span>
<span class="nc" id="L2344">                    writer = new StringWriter(input.length());</span>
<span class="nc" id="L2345">                writer.append(input.substring(st, i - 1));</span>

<span class="nc" id="L2347">                writer.append(value);</span>
            }

            // skip escape
<span class="nc" id="L2351">            st = j + 1;</span>
<span class="nc" id="L2352">            i = st;</span>
<span class="nc" id="L2353">        }</span>

<span class="nc bnc" id="L2355" title="All 2 branches missed.">        if (writer != null) {</span>
<span class="nc" id="L2356">            writer.append(input.substring(st, len));</span>
<span class="nc" id="L2357">            return writer.toString();</span>
        }
<span class="nc" id="L2359">        return input;</span>
    }

<span class="fc" id="L2362">    private static final String[][] HTML_ESCAPES = {</span>
        {&quot;\&quot;&quot;,     &quot;quot&quot;}, // &quot; - double-quote
        {&quot;&amp;&quot;,      &quot;amp&quot;}, // &amp; - ampersand
        {&quot;&lt;&quot;,      &quot;lt&quot;}, // &lt; - less-than
        {&quot;&gt;&quot;,      &quot;gt&quot;}, // &gt; - greater-than
        {&quot;-&quot;,      &quot;ndash&quot;}, // - - dash

        // Mapping to escape ISO-8859-1 characters to their named HTML 3.x equivalents.
        {&quot;\u00A0&quot;, &quot;nbsp&quot;}, // non-breaking space
        {&quot;\u00A1&quot;, &quot;iexcl&quot;}, // inverted exclamation mark
        {&quot;\u00A2&quot;, &quot;cent&quot;}, // cent sign
        {&quot;\u00A3&quot;, &quot;pound&quot;}, // pound sign
        {&quot;\u00A4&quot;, &quot;curren&quot;}, // currency sign
        {&quot;\u00A5&quot;, &quot;yen&quot;}, // yen sign = yuan sign
        {&quot;\u00A6&quot;, &quot;brvbar&quot;}, // broken bar = broken vertical bar
        {&quot;\u00A7&quot;, &quot;sect&quot;}, // section sign
        {&quot;\u00A8&quot;, &quot;uml&quot;}, // diaeresis = spacing diaeresis
        {&quot;\u00A9&quot;, &quot;copy&quot;}, // © - copyright sign
        {&quot;\u00AA&quot;, &quot;ordf&quot;}, // feminine ordinal indicator
        {&quot;\u00AB&quot;, &quot;laquo&quot;}, // left-pointing double angle quotation mark = left pointing guillemet
        {&quot;\u00AC&quot;, &quot;not&quot;}, // not sign
        {&quot;\u00AD&quot;, &quot;shy&quot;}, // soft hyphen = discretionary hyphen
        {&quot;\u00AE&quot;, &quot;reg&quot;}, // ® - registered trademark sign
        {&quot;\u00AF&quot;, &quot;macr&quot;}, // macron = spacing macron = overline = APL overbar
        {&quot;\u00B0&quot;, &quot;deg&quot;}, // degree sign
        {&quot;\u00B1&quot;, &quot;plusmn&quot;}, // plus-minus sign = plus-or-minus sign
        {&quot;\u00B2&quot;, &quot;sup2&quot;}, // superscript two = superscript digit two = squared
        {&quot;\u00B3&quot;, &quot;sup3&quot;}, // superscript three = superscript digit three = cubed
        {&quot;\u00B4&quot;, &quot;acute&quot;}, // acute accent = spacing acute
        {&quot;\u00B5&quot;, &quot;micro&quot;}, // micro sign
        {&quot;\u00B6&quot;, &quot;para&quot;}, // pilcrow sign = paragraph sign
        {&quot;\u00B7&quot;, &quot;middot&quot;}, // middle dot = Georgian comma = Greek middle dot
        {&quot;\u00B8&quot;, &quot;cedil&quot;}, // cedilla = spacing cedilla
        {&quot;\u00B9&quot;, &quot;sup1&quot;}, // superscript one = superscript digit one
        {&quot;\u00BA&quot;, &quot;ordm&quot;}, // masculine ordinal indicator
        {&quot;\u00BB&quot;, &quot;raquo&quot;}, // right-pointing double angle quotation mark = right pointing guillemet
        {&quot;\u00BC&quot;, &quot;frac14&quot;}, // vulgar fraction one quarter = fraction one quarter
        {&quot;\u00BD&quot;, &quot;frac12&quot;}, // vulgar fraction one half = fraction one half
        {&quot;\u00BE&quot;, &quot;frac34&quot;}, // vulgar fraction three quarters = fraction three quarters
        {&quot;\u00BF&quot;, &quot;iquest&quot;}, // inverted question mark = turned question mark
        {&quot;\u00C0&quot;, &quot;Agrave&quot;}, // А - uppercase A, grave accent
        {&quot;\u00C1&quot;, &quot;Aacute&quot;}, // Б - uppercase A, acute accent
        {&quot;\u00C2&quot;, &quot;Acirc&quot;}, // В - uppercase A, circumflex accent
        {&quot;\u00C3&quot;, &quot;Atilde&quot;}, // Г - uppercase A, tilde
        {&quot;\u00C4&quot;, &quot;Auml&quot;}, // Д - uppercase A, umlaut
        {&quot;\u00C5&quot;, &quot;Aring&quot;}, // Е - uppercase A, ring
        {&quot;\u00C6&quot;, &quot;AElig&quot;}, // Ж - uppercase AE
        {&quot;\u00C7&quot;, &quot;Ccedil&quot;}, // З - uppercase C, cedilla
        {&quot;\u00C8&quot;, &quot;Egrave&quot;}, // И - uppercase E, grave accent
        {&quot;\u00C9&quot;, &quot;Eacute&quot;}, // Й - uppercase E, acute accent
        {&quot;\u00CA&quot;, &quot;Ecirc&quot;}, // К - uppercase E, circumflex accent
        {&quot;\u00CB&quot;, &quot;Euml&quot;}, // Л - uppercase E, umlaut
        {&quot;\u00CC&quot;, &quot;Igrave&quot;}, // М - uppercase I, grave accent
        {&quot;\u00CD&quot;, &quot;Iacute&quot;}, // Н - uppercase I, acute accent
        {&quot;\u00CE&quot;, &quot;Icirc&quot;}, // О - uppercase I, circumflex accent
        {&quot;\u00CF&quot;, &quot;Iuml&quot;}, // П - uppercase I, umlaut
        {&quot;\u00D0&quot;, &quot;ETH&quot;}, // Р - uppercase Eth, Icelandic
        {&quot;\u00D1&quot;, &quot;Ntilde&quot;}, // С - uppercase N, tilde
        {&quot;\u00D2&quot;, &quot;Ograve&quot;}, // Т - uppercase O, grave accent
        {&quot;\u00D3&quot;, &quot;Oacute&quot;}, // У - uppercase O, acute accent
        {&quot;\u00D4&quot;, &quot;Ocirc&quot;}, // Ф - uppercase O, circumflex accent
        {&quot;\u00D5&quot;, &quot;Otilde&quot;}, // Х - uppercase O, tilde
        {&quot;\u00D6&quot;, &quot;Ouml&quot;}, // Ц - uppercase O, umlaut
        {&quot;\u00D7&quot;, &quot;times&quot;}, // multiplication sign
        {&quot;\u00D8&quot;, &quot;Oslash&quot;}, // Ш - uppercase O, slash
        {&quot;\u00D9&quot;, &quot;Ugrave&quot;}, // Щ - uppercase U, grave accent
        {&quot;\u00DA&quot;, &quot;Uacute&quot;}, // Ъ - uppercase U, acute accent
        {&quot;\u00DB&quot;, &quot;Ucirc&quot;}, // Ы - uppercase U, circumflex accent
        {&quot;\u00DC&quot;, &quot;Uuml&quot;}, // Ь - uppercase U, umlaut
        {&quot;\u00DD&quot;, &quot;Yacute&quot;}, // Э - uppercase Y, acute accent
        {&quot;\u00DE&quot;, &quot;THORN&quot;}, // Ю - uppercase THORN, Icelandic
        {&quot;\u00DF&quot;, &quot;szlig&quot;}, // Я - lowercase sharps, German
        {&quot;\u00E0&quot;, &quot;agrave&quot;}, // а - lowercase a, grave accent
        {&quot;\u00E1&quot;, &quot;aacute&quot;}, // б - lowercase a, acute accent
        {&quot;\u00E2&quot;, &quot;acirc&quot;}, // в - lowercase a, circumflex accent
        {&quot;\u00E3&quot;, &quot;atilde&quot;}, // г - lowercase a, tilde
        {&quot;\u00E4&quot;, &quot;auml&quot;}, // д - lowercase a, umlaut
        {&quot;\u00E5&quot;, &quot;aring&quot;}, // е - lowercase a, ring
        {&quot;\u00E6&quot;, &quot;aelig&quot;}, // ж - lowercase ae
        {&quot;\u00E7&quot;, &quot;ccedil&quot;}, // з - lowercase c, cedilla
        {&quot;\u00E8&quot;, &quot;egrave&quot;}, // и - lowercase e, grave accent
        {&quot;\u00E9&quot;, &quot;eacute&quot;}, // й - lowercase e, acute accent
        {&quot;\u00EA&quot;, &quot;ecirc&quot;}, // к - lowercase e, circumflex accent
        {&quot;\u00EB&quot;, &quot;euml&quot;}, // л - lowercase e, umlaut
        {&quot;\u00EC&quot;, &quot;igrave&quot;}, // м - lowercase i, grave accent
        {&quot;\u00ED&quot;, &quot;iacute&quot;}, // н - lowercase i, acute accent
        {&quot;\u00EE&quot;, &quot;icirc&quot;}, // о - lowercase i, circumflex accent
        {&quot;\u00EF&quot;, &quot;iuml&quot;}, // п - lowercase i, umlaut
        {&quot;\u00F0&quot;, &quot;eth&quot;}, // р - lowercase eth, Icelandic
        {&quot;\u00F1&quot;, &quot;ntilde&quot;}, // с - lowercase n, tilde
        {&quot;\u00F2&quot;, &quot;ograve&quot;}, // т - lowercase o, grave accent
        {&quot;\u00F3&quot;, &quot;oacute&quot;}, // у - lowercase o, acute accent
        {&quot;\u00F4&quot;, &quot;ocirc&quot;}, // ф - lowercase o, circumflex accent
        {&quot;\u00F5&quot;, &quot;otilde&quot;}, // х - lowercase o, tilde
        {&quot;\u00F6&quot;, &quot;ouml&quot;}, // ц - lowercase o, umlaut
        {&quot;\u00F7&quot;, &quot;divide&quot;}, // division sign
        {&quot;\u00F8&quot;, &quot;oslash&quot;}, // ш - lowercase o, slash
        {&quot;\u00F9&quot;, &quot;ugrave&quot;}, // щ - lowercase u, grave accent
        {&quot;\u00FA&quot;, &quot;uacute&quot;}, // ъ - lowercase u, acute accent
        {&quot;\u00FB&quot;, &quot;ucirc&quot;}, // ы - lowercase u, circumflex accent
        {&quot;\u00FC&quot;, &quot;uuml&quot;}, // ь - lowercase u, umlaut
        {&quot;\u00FD&quot;, &quot;yacute&quot;}, // э - lowercase y, acute accent
        {&quot;\u00FE&quot;, &quot;thorn&quot;}, // ю - lowercase thorn, Icelandic
        {&quot;\u00FF&quot;, &quot;yuml&quot;}, // я - lowercase y, umlaut
    };

  private static final HashMap&lt;String, CharSequence&gt; htmlUnescapeLookupMap;
    static {
<span class="fc" id="L2470">        htmlUnescapeLookupMap = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L2471" title="All 2 branches covered.">        for (final CharSequence[] seq : HTML_ESCAPES)</span>
<span class="fc" id="L2472">            htmlUnescapeLookupMap.put(seq[1].toString(), seq[0]);</span>
<span class="fc" id="L2473">    }</span>

  /**
   * Decode an array encoded as a String. This entails a comma separated value enclosed in brackets
   * or parentheses.
   *
   * @param encoded The String encoding an array
   * @return A String array corresponding to the encoded array
   */
  public static String[] decodeArray(String encoded) {
<span class="fc bfc" id="L2483" title="All 2 branches covered.">    if (encoded.isEmpty()) return EMPTY_STRING_ARRAY;</span>
<span class="fc" id="L2484">    char[] chars = encoded.trim().toCharArray();</span>

    //--Parse the String
    // (state)
<span class="fc" id="L2488">    char quoteCloseChar = (char) 0;</span>
<span class="fc" id="L2489">    List&lt;String&gt; terms = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L2490">    StringBuilder current = new StringBuilder();</span>
    //(start/stop overhead)
<span class="fc" id="L2492">    int start = 0; int end = chars.length;</span>
<span class="pc bpc" id="L2493" title="1 of 4 branches missed.">    if(chars[0] == '('){ start += 1; end -= 1; if(chars[end] != ')') throw new IllegalArgumentException(&quot;Unclosed paren in encoded array: &quot; + encoded); }</span>
<span class="pc bpc" id="L2494" title="1 of 4 branches missed.">    if(chars[0] == '['){ start += 1; end -= 1; if(chars[end] != ']') throw new IllegalArgumentException(&quot;Unclosed bracket in encoded array: &quot; + encoded); }</span>
<span class="pc bpc" id="L2495" title="1 of 4 branches missed.">    if(chars[0] == '{'){ start += 1; end -= 1; if(chars[end] != '}') throw new IllegalArgumentException(&quot;Unclosed bracket in encoded array: &quot; + encoded); }</span>
    // (finite state automaton)
<span class="fc bfc" id="L2497" title="All 2 branches covered.">    for (int i=start; i&lt;end; i++) {</span>
<span class="pc bpc" id="L2498" title="1 of 2 branches missed.">      if (chars[i] == '\r') {</span>
        // Ignore funny windows carriage return
<span class="nc" id="L2500">        continue;</span>
<span class="fc bfc" id="L2501" title="All 2 branches covered.">      } else if (quoteCloseChar != 0) {</span>
        //(case: in quotes)
<span class="fc bfc" id="L2503" title="All 2 branches covered.">        if(chars[i] == quoteCloseChar){</span>
<span class="fc" id="L2504">          quoteCloseChar = (char) 0;</span>
        }else{
<span class="fc" id="L2506">          current.append(chars[i]);</span>
        }
<span class="fc bfc" id="L2508" title="All 2 branches covered.">      } else if(chars[i] == '\\'){</span>
        //(case: escaped character)
<span class="pc bpc" id="L2510" title="1 of 2 branches missed.">        if(i == chars.length - 1) throw new IllegalArgumentException(&quot;Last character of encoded array is escape character: &quot; + encoded);</span>
<span class="fc" id="L2511">        current.append(chars[i+1]);</span>
<span class="fc" id="L2512">        i += 1;</span>
      } else {
        //(case: normal)
<span class="fc bfc" id="L2515" title="All 2 branches covered.">        if (chars[i] == '&quot;') {</span>
<span class="fc" id="L2516">          quoteCloseChar = '&quot;';</span>
<span class="fc bfc" id="L2517" title="All 2 branches covered.">        } else if(chars[i] == '\'') {</span>
<span class="fc" id="L2518">          quoteCloseChar = '\'';</span>
<span class="pc bpc" id="L2519" title="2 of 10 branches missed.">        } else if(chars[i] == ',' || chars[i] == ';' || chars[i] == ' ' || chars[i] == '\t' || chars[i] == '\n') {</span>
          //break
<span class="fc bfc" id="L2521" title="All 2 branches covered.">          if (current.length() &gt; 0) {</span>
<span class="fc" id="L2522">            terms.add(current.toString().trim());</span>
          }
<span class="fc" id="L2524">          current = new StringBuilder();</span>
        } else {
<span class="fc" id="L2526">          current.append(chars[i]);</span>
        }
      }
    }

    //--Return
<span class="fc bfc" id="L2532" title="All 2 branches covered.">    if (current.length() &gt; 0) {</span>
<span class="fc" id="L2533">      terms.add(current.toString().trim());</span>
    }
<span class="fc" id="L2535">    return terms.toArray(EMPTY_STRING_ARRAY);</span>
  }

  /**
   * Decode a map encoded as a string.
   *
   * @param encoded The String encoded map
   * @return A String map corresponding to the encoded map
   */
  public static Map&lt;String, String&gt; decodeMap(String encoded){
<span class="pc bpc" id="L2545" title="1 of 2 branches missed.">    if (encoded.isEmpty()) return new HashMap&lt;&gt;();</span>
<span class="fc" id="L2546">    char[] chars = encoded.trim().toCharArray();</span>

    //--Parse the String
    //(state)
<span class="fc" id="L2550">    char quoteCloseChar = (char) 0;</span>
<span class="fc" id="L2551">    Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span>
<span class="fc" id="L2552">    String key = &quot;&quot;;</span>
<span class="fc" id="L2553">    String value = &quot;&quot;;</span>
<span class="fc" id="L2554">    boolean onKey = true;</span>
<span class="fc" id="L2555">    StringBuilder current = new StringBuilder();</span>
    //(start/stop overhead)
<span class="fc" id="L2557">    int start = 0; int end = chars.length;</span>
<span class="pc bpc" id="L2558" title="3 of 4 branches missed.">    if(chars[0] == '('){ start += 1; end -= 1; if(chars[end] != ')') throw new IllegalArgumentException(&quot;Unclosed paren in encoded map: &quot; + encoded); }</span>
<span class="pc bpc" id="L2559" title="1 of 4 branches missed.">    if(chars[0] == '['){ start += 1; end -= 1; if(chars[end] != ']') throw new IllegalArgumentException(&quot;Unclosed bracket in encoded map: &quot; + encoded); }</span>
<span class="pc bpc" id="L2560" title="1 of 4 branches missed.">    if(chars[0] == '{'){ start += 1; end -= 1; if(chars[end] != '}') throw new IllegalArgumentException(&quot;Unclosed bracket in encoded map: &quot; + encoded); }</span>
    //(finite state automata)
<span class="fc bfc" id="L2562" title="All 2 branches covered.">    for(int i=start; i&lt;end; i++){</span>
<span class="pc bpc" id="L2563" title="1 of 2 branches missed.">      if (chars[i] == '\r') {</span>
        // Ignore funny windows carriage return
<span class="nc" id="L2565">        continue;</span>
<span class="pc bpc" id="L2566" title="1 of 2 branches missed.">      } else if(quoteCloseChar != 0){</span>
        //(case: in quotes)
<span class="nc bnc" id="L2568" title="All 2 branches missed.">        if(chars[i] == quoteCloseChar){</span>
<span class="nc" id="L2569">          quoteCloseChar = (char) 0;</span>
        }else{
<span class="nc" id="L2571">          current.append(chars[i]);</span>
        }
<span class="pc bpc" id="L2573" title="1 of 2 branches missed.">      } else if(chars[i] == '\\'){</span>
        //(case: escaped character)
<span class="nc bnc" id="L2575" title="All 2 branches missed.">        if(i == chars.length - 1) {</span>
<span class="nc" id="L2576">          throw new IllegalArgumentException(&quot;Last character of encoded pair is escape character: &quot; + encoded);</span>
        }
<span class="nc" id="L2578">        current.append(chars[i+1]);</span>
<span class="nc" id="L2579">        i += 1;</span>
      }else{
        //(case: normal)
<span class="pc bpc" id="L2582" title="1 of 2 branches missed.">        if(chars[i] == '&quot;'){</span>
<span class="nc" id="L2583">          quoteCloseChar = '&quot;';</span>
<span class="pc bpc" id="L2584" title="1 of 2 branches missed.">        } else if(chars[i] == '\''){</span>
<span class="nc" id="L2585">          quoteCloseChar = '\'';</span>
<span class="fc bfc" id="L2586" title="All 4 branches covered.">        } else if (chars[i] == '\n' &amp;&amp; current.length() == 0) {</span>
<span class="fc" id="L2587">          current.append(&quot;&quot;);  // do nothing</span>
<span class="pc bpc" id="L2588" title="1 of 8 branches missed.">        } else if(chars[i] == ',' || chars[i] == ';' || chars[i] == '\t' || chars[i] == '\n'){</span>
          // case: end a value
<span class="pc bpc" id="L2590" title="1 of 2 branches missed.">          if (onKey) {</span>
<span class="nc" id="L2591">            throw new IllegalArgumentException(&quot;Encountered key without value&quot;);</span>
          }
<span class="pc bpc" id="L2593" title="1 of 2 branches missed.">          if (current.length() &gt; 0) {</span>
<span class="fc" id="L2594">            value = current.toString().trim();</span>
          }
<span class="fc" id="L2596">          current = new StringBuilder();</span>
<span class="fc" id="L2597">          onKey = true;</span>
<span class="fc" id="L2598">          map.put(key, value);  // &lt;- add value</span>
<span class="pc bpc" id="L2599" title="2 of 8 branches missed.">        } else if((chars[i] == '-' || chars[i] == '=') &amp;&amp; (i &lt; chars.length - 1 &amp;&amp; chars[i + 1] == '&gt;')) {</span>
          // case: end a key
<span class="pc bpc" id="L2601" title="1 of 2 branches missed.">          if (!onKey) {</span>
<span class="nc" id="L2602">            throw new IllegalArgumentException(&quot;Encountered a value without a key&quot;);</span>
          }
<span class="pc bpc" id="L2604" title="1 of 2 branches missed.">          if (current.length() &gt; 0) {</span>
<span class="fc" id="L2605">            key = current.toString().trim();</span>
          }
<span class="fc" id="L2607">          current = new StringBuilder();</span>
<span class="fc" id="L2608">          onKey = false;</span>
<span class="fc" id="L2609">          i += 1; // skip '&gt;' character</span>
<span class="pc bpc" id="L2610" title="1 of 2 branches missed.">        } else if (chars[i] == ':') {</span>
          // case: end a key
<span class="nc bnc" id="L2612" title="All 2 branches missed.">          if (!onKey) {</span>
<span class="nc" id="L2613">            throw new IllegalArgumentException(&quot;Encountered a value without a key&quot;);</span>
          }
<span class="nc bnc" id="L2615" title="All 2 branches missed.">          if (current.length() &gt; 0) {</span>
<span class="nc" id="L2616">            key = current.toString().trim();</span>
          }
<span class="nc" id="L2618">          current = new StringBuilder();</span>
<span class="nc" id="L2619">          onKey = false;</span>
        } else {
<span class="fc" id="L2621">          current.append(chars[i]);</span>
        }
      }
    }

    //--Return
<span class="pc bpc" id="L2627" title="2 of 4 branches missed.">    if (current.toString().trim().length() &gt; 0 &amp;&amp; !onKey) {</span>
<span class="fc" id="L2628">      map.put(key.trim(), current.toString().trim());</span>
    }
<span class="fc" id="L2630">    return map;</span>
  }


  /**
   * Takes an input String, and replaces any bash-style variables (e.g., $VAR_NAME)
   * with its actual environment variable from the passed environment specification.
   *
   * @param raw The raw String to replace variables in.
   * @param env The environment specification; e.g., {@link System#getenv()}.
   * @return The input String, but with all variables replaced.
   */
  public static String expandEnvironmentVariables(String raw, Map&lt;String, String&gt; env) {
<span class="fc" id="L2643">    String pattern = &quot;\\$\\{?([a-zA-Z_]+[a-zA-Z0-9_]*)\\}?&quot;;</span>
<span class="fc" id="L2644">    Pattern expr = Pattern.compile(pattern);</span>
<span class="fc" id="L2645">    String text = raw;</span>
<span class="fc" id="L2646">    Matcher matcher = expr.matcher(text);</span>
<span class="fc bfc" id="L2647" title="All 2 branches covered.">    while (matcher.find()) {</span>
<span class="fc" id="L2648">      String envValue = env.get(matcher.group(1));</span>
<span class="fc bfc" id="L2649" title="All 2 branches covered.">      if (envValue == null) {</span>
<span class="fc" id="L2650">        envValue = &quot;&quot;;</span>
      } else {
<span class="fc" id="L2652">        envValue = envValue.replace(&quot;\\&quot;, &quot;\\\\&quot;);</span>
      }
<span class="fc" id="L2654">      Pattern subexpr = Pattern.compile(Pattern.quote(matcher.group(0)));</span>
<span class="fc" id="L2655">      text = subexpr.matcher(text).replaceAll(envValue);</span>
<span class="fc" id="L2656">    }</span>
<span class="fc" id="L2657">    return text;</span>
  }

  /**
   * Takes an input String, and replaces any bash-style variables (e.g., $VAR_NAME)
   * with its actual environment variable from {@link System#getenv()}.
   *
   * @param raw The raw String to replace variables in.
   * @return The input String, but with all variables replaced.
   */
  public static String expandEnvironmentVariables(String raw) {
<span class="nc" id="L2668">    return expandEnvironmentVariables(raw, System.getenv());</span>
  }


  /**
   * Logs the command line arguments to Redwood on the given channels.
   * The logger should be a RedwoodChannels of a single channel: the main class.
   *
   * @param logger The redwood logger to log to.
   * @param args The command-line arguments to log.
   */
  public static void logInvocationString(Redwood.RedwoodChannels logger, String[] args) {
<span class="nc" id="L2680">    StringBuilder sb = new StringBuilder(&quot;Invoked on &quot;);</span>
<span class="nc" id="L2681">    sb.append(new Date());</span>
<span class="nc" id="L2682">    sb.append(&quot; with arguments:&quot;);</span>
<span class="nc bnc" id="L2683" title="All 2 branches missed.">    for (String arg : args) {</span>
<span class="nc" id="L2684">      sb.append(' ').append(arg);</span>
    }
<span class="nc" id="L2686">    logger.info(sb.toString());</span>
<span class="nc" id="L2687">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>