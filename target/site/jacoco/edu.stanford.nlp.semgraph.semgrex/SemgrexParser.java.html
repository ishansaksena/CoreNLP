<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SemgrexParser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.semgraph.semgrex</a> &gt; <span class="el_source">SemgrexParser.java</span></div><h1>SemgrexParser.java</h1><pre class="source lang-java linenums">/* Generated By:JavaCC: Do not edit this line. SemgrexParser.java */
package edu.stanford.nlp.semgraph.semgrex;
// all generated classes are in this package

//imports
import java.util.*;
import edu.stanford.nlp.util.Generics;

class SemgrexParser implements SemgrexParserConstants {

  // this is so we can tell, at any point during the parse
  // whether we are under a negation, which we need to know
  // because labeling nodes under negation is illegal
<span class="pc" id="L14">  private boolean underNegation = false;</span>
<span class="pc" id="L15">  private boolean underNodeNegation = false;</span>
  // keep track of which variables we've already seen
  // lets us make sure we don't name new nodes under a negation
<span class="pc" id="L18">  private Set&lt;String&gt; knownVariables = Generics.newHashSet();</span>

  final public SemgrexPattern Root() throws ParseException {
  SemgrexPattern node;
<span class="fc" id="L22">  Token reverse = null;</span>
<span class="fc" id="L23">  List&lt;SemgrexPattern&gt; children = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L24" title="3 of 5 branches missed.">    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {</span>
    case ALIGNRELN:
<span class="nc" id="L26">      reverse = jj_consume_token(ALIGNRELN);</span>
<span class="nc" id="L27">      node = SubNode(GraphRelation.ALIGNED_ROOT);</span>
<span class="nc" id="L28">      jj_consume_token(11);</span>
<span class="nc" id="L29">      break;</span>
    case 13:
    case 17:
    case 19:
    case 23:
<span class="fc" id="L34">      node = SubNode(GraphRelation.ROOT);</span>
<span class="fc" id="L35">                                           children.add(node);</span>
      label_1:
      while (true) {
<span class="pc bpc" id="L38" title="1 of 4 branches missed.">        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {</span>
        case 12:
          ;
<span class="fc" id="L41">          break;</span>
        default:
<span class="fc" id="L43">          jj_la1[0] = jj_gen;</span>
<span class="fc" id="L44">          break label_1;</span>
        }
<span class="fc" id="L46">        jj_consume_token(12);</span>
<span class="fc" id="L47">        node = SubNode(GraphRelation.ITERATOR);</span>
<span class="fc" id="L48">                                                     children.add(node);</span>
      }
<span class="fc" id="L50">      jj_consume_token(11);</span>
<span class="fc" id="L51">      break;</span>
    default:
<span class="nc" id="L53">      jj_la1[1] = jj_gen;</span>
<span class="nc" id="L54">      jj_consume_token(-1);</span>
<span class="nc" id="L55">      throw new ParseException();</span>
    }
<span class="fc bfc" id="L57" title="All 2 branches covered.">    if (children.size() &lt;= 1)</span>
<span class="fc" id="L58">      {if (true) return node;}</span>
<span class="fc" id="L59">    {if (true) return new CoordinationPattern(true, children, true);}</span>
    throw new Error(&quot;Missing return statement in function&quot;);
  }

  final public SemgrexPattern SubNode(GraphRelation r) throws ParseException {
<span class="fc" id="L64">        SemgrexPattern result =  null;</span>
<span class="fc" id="L65">        SemgrexPattern child = null;</span>
<span class="pc bpc" id="L66" title="1 of 5 branches missed.">    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {</span>
    case 13:
<span class="fc" id="L68">      jj_consume_token(13);</span>
<span class="fc" id="L69">      result = SubNode(r);</span>
<span class="fc" id="L70">      jj_consume_token(14);</span>
<span class="pc bpc" id="L71" title="1 of 4 branches missed.">      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {</span>
      case RELATION:
      case ALIGNRELN:
      case IDENTIFIER:
      case 17:
      case 18:
      case 19:
<span class="fc" id="L78">        child = RelationDisj();</span>
<span class="fc" id="L79">        break;</span>
      default:
<span class="fc" id="L81">        jj_la1[2] = jj_gen;</span>
        ;
      }
<span class="fc bfc" id="L84" title="All 2 branches covered.">                if (child != null) {</span>
<span class="fc" id="L85">                List&lt;SemgrexPattern&gt; newChildren = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L86">                newChildren.addAll(result.getChildren());</span>
<span class="fc" id="L87">                newChildren.add(child);</span>
<span class="fc" id="L88">                result.setChild(new CoordinationPattern(false, newChildren, true));</span>
        }
<span class="fc" id="L90">        {if (true) return result;}</span>
      break;
    case 17:
    case 19:
    case 23:
<span class="fc" id="L95">      result = ModNode(r);</span>
<span class="fc bfc" id="L96" title="All 4 branches covered.">      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {</span>
      case RELATION:
      case ALIGNRELN:
      case IDENTIFIER:
      case 17:
      case 18:
      case 19:
<span class="fc" id="L103">        child = RelationDisj();</span>
<span class="fc" id="L104">        break;</span>
      default:
<span class="fc" id="L106">        jj_la1[3] = jj_gen;</span>
        ;
      }
<span class="fc bfc" id="L109" title="All 2 branches covered.">           if (child != null) result.setChild(child);</span>
<span class="fc" id="L110">                {if (true) return result;}</span>
      break;
    default:
<span class="nc" id="L113">      jj_la1[4] = jj_gen;</span>
<span class="nc" id="L114">      jj_consume_token(-1);</span>
<span class="nc" id="L115">      throw new ParseException();</span>
    }
    throw new Error(&quot;Missing return statement in function&quot;);
  }

  final public SemgrexPattern RelationDisj() throws ParseException {
        SemgrexPattern child;
<span class="fc" id="L122">        List&lt;SemgrexPattern&gt; children = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L123">    child = RelationConj();</span>
<span class="fc" id="L124">                                     children.add(child);</span>
    label_2:
    while (true) {
<span class="pc bpc" id="L127" title="1 of 4 branches missed.">      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {</span>
      case 15:
        ;
<span class="fc" id="L130">        break;</span>
      default:
<span class="fc" id="L132">        jj_la1[5] = jj_gen;</span>
<span class="fc" id="L133">        break label_2;</span>
      }
<span class="fc" id="L135">      jj_consume_token(15);</span>
<span class="fc" id="L136">      child = RelationConj();</span>
<span class="fc" id="L137">                                           children.add(child);</span>
    }
<span class="fc bfc" id="L139" title="All 2 branches covered.">          if (children.size() == 1) {</span>
<span class="fc" id="L140">                {if (true) return child;}</span>
          } else {
<span class="fc" id="L142">                {if (true) return new CoordinationPattern(false, children, false);}</span>
      }
    throw new Error(&quot;Missing return statement in function&quot;);
  }

  final public SemgrexPattern RelationConj() throws ParseException {
        SemgrexPattern child;
<span class="fc" id="L149">        List&lt;SemgrexPattern&gt; children = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L150">    child = ModRelation();</span>
<span class="fc" id="L151">                                     children.add(child);</span>
    label_3:
    while (true) {
<span class="fc bfc" id="L154" title="All 4 branches covered.">      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {</span>
      case RELATION:
      case ALIGNRELN:
      case IDENTIFIER:
      case 16:
      case 17:
      case 18:
      case 19:
        ;
<span class="fc" id="L163">        break;</span>
      default:
<span class="fc" id="L165">        jj_la1[6] = jj_gen;</span>
<span class="fc" id="L166">        break label_3;</span>
      }
<span class="pc bpc" id="L168" title="1 of 4 branches missed.">      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {</span>
      case 16:
<span class="fc" id="L170">        jj_consume_token(16);</span>
<span class="fc" id="L171">        break;</span>
      default:
<span class="fc" id="L173">        jj_la1[7] = jj_gen;</span>
        ;
      }
<span class="fc" id="L176">      child = ModRelation();</span>
<span class="fc" id="L177">                                             children.add(child);</span>
    }
<span class="fc bfc" id="L179" title="All 2 branches covered.">          if (children.size() == 1) {</span>
<span class="fc" id="L180">                {if (true) return child;}</span>
          } else {
<span class="fc" id="L182">                {if (true) return new CoordinationPattern(false, children, true);}</span>
      }
    throw new Error(&quot;Missing return statement in function&quot;);
  }

  final public SemgrexPattern ModRelation() throws ParseException {
  SemgrexPattern child;
  boolean startUnderNeg;
<span class="pc bpc" id="L190" title="1 of 6 branches missed.">    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {</span>
    case RELATION:
    case ALIGNRELN:
    case IDENTIFIER:
    case 19:
<span class="fc" id="L195">      child = RelChild();</span>
<span class="fc" id="L196">      break;</span>
    case 17:
<span class="fc" id="L198">      jj_consume_token(17);</span>
<span class="fc" id="L199">          startUnderNeg = underNegation;</span>
<span class="fc" id="L200">          underNegation = true;</span>
<span class="fc" id="L201">      child = RelChild();</span>
<span class="fc" id="L202">                                                       underNegation = startUnderNeg;</span>
<span class="fc" id="L203">        child.negate();</span>
<span class="fc" id="L204">      break;</span>
    case 18:
<span class="fc" id="L206">      jj_consume_token(18);</span>
<span class="fc" id="L207">      child = RelChild();</span>
<span class="fc" id="L208">                                   child.makeOptional();</span>
<span class="fc" id="L209">      break;</span>
    default:
<span class="nc" id="L211">      jj_la1[8] = jj_gen;</span>
<span class="nc" id="L212">      jj_consume_token(-1);</span>
<span class="nc" id="L213">      throw new ParseException();</span>
    }
<span class="fc" id="L215">    {if (true) return child;}</span>
    throw new Error(&quot;Missing return statement in function&quot;);
  }

  final public SemgrexPattern RelChild() throws ParseException {
  SemgrexPattern child;
<span class="pc bpc" id="L221" title="1 of 5 branches missed.">    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {</span>
    case 19:
<span class="fc" id="L223">      jj_consume_token(19);</span>
<span class="fc" id="L224">      child = RelationDisj();</span>
<span class="fc" id="L225">      jj_consume_token(20);</span>
<span class="fc" id="L226">      break;</span>
    case RELATION:
    case ALIGNRELN:
    case IDENTIFIER:
<span class="fc" id="L230">      child = Relation();</span>
<span class="fc" id="L231">      break;</span>
    default:
<span class="nc" id="L233">      jj_la1[9] = jj_gen;</span>
<span class="nc" id="L234">      jj_consume_token(-1);</span>
<span class="nc" id="L235">      throw new ParseException();</span>
    }
<span class="fc" id="L237">    {if (true) return child;}</span>
    throw new Error(&quot;Missing return statement in function&quot;);
  }

  final public SemgrexPattern Relation() throws ParseException {
        GraphRelation reln;
<span class="fc" id="L243">        Token rel = null;</span>
<span class="fc" id="L244">        Token relnType = null;</span>
<span class="fc" id="L245">        Token numArg = null;</span>
<span class="fc" id="L246">        Token numArg2 = null;</span>
<span class="fc" id="L247">        Token name = null;</span>
        SemgrexPattern node;
<span class="fc" id="L249">        boolean pC = false;</span>
<span class="pc bpc" id="L250" title="2 of 5 branches missed.">    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {</span>
    case RELATION:
    case IDENTIFIER:
<span class="pc bpc" id="L253" title="1 of 4 branches missed.">      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {</span>
      case IDENTIFIER:
<span class="fc" id="L255">        numArg = jj_consume_token(IDENTIFIER);</span>
<span class="pc bpc" id="L256" title="1 of 4 branches missed.">        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {</span>
        case 21:
<span class="fc" id="L258">          jj_consume_token(21);</span>
<span class="fc" id="L259">          numArg2 = jj_consume_token(IDENTIFIER);</span>
<span class="fc" id="L260">          break;</span>
        default:
<span class="fc" id="L262">          jj_la1[10] = jj_gen;</span>
          ;
        }
<span class="fc" id="L265">        break;</span>
      default:
<span class="fc" id="L267">        jj_la1[11] = jj_gen;</span>
        ;
      }
<span class="fc" id="L270">      rel = jj_consume_token(RELATION);</span>
<span class="pc bpc" id="L271" title="1 of 4 branches missed.">      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {</span>
      case IDENTIFIER:
      case REGEX:
<span class="pc bpc" id="L274" title="2 of 5 branches missed.">        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {</span>
        case IDENTIFIER:
<span class="fc" id="L276">          relnType = jj_consume_token(IDENTIFIER);</span>
<span class="fc" id="L277">          break;</span>
        case REGEX:
<span class="fc" id="L279">          relnType = jj_consume_token(REGEX);</span>
<span class="fc" id="L280">          break;</span>
        default:
<span class="nc" id="L282">          jj_la1[12] = jj_gen;</span>
<span class="nc" id="L283">          jj_consume_token(-1);</span>
<span class="nc" id="L284">          throw new ParseException();</span>
        }
        break;
      default:
<span class="fc" id="L288">        jj_la1[13] = jj_gen;</span>
        ;
      }
<span class="fc bfc" id="L291" title="All 4 branches covered.">      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {</span>
      case 22:
<span class="fc" id="L293">        jj_consume_token(22);</span>
<span class="fc" id="L294">        name = jj_consume_token(IDENTIFIER);</span>
<span class="fc" id="L295">        break;</span>
      default:
<span class="fc" id="L297">        jj_la1[14] = jj_gen;</span>
        ;
      }
<span class="fc" id="L300">      break;</span>
    case ALIGNRELN:
<span class="fc" id="L302">      rel = jj_consume_token(ALIGNRELN);</span>
<span class="fc" id="L303">      break;</span>
    default:
<span class="nc" id="L305">      jj_la1[15] = jj_gen;</span>
<span class="nc" id="L306">      jj_consume_token(-1);</span>
<span class="nc" id="L307">      throw new ParseException();</span>
    }
<span class="pc bpc" id="L309" title="1 of 4 branches missed.">          if (numArg == null &amp;&amp; numArg2 == null) {</span>
<span class="pc bpc" id="L310" title="1 of 6 branches missed.">            reln = GraphRelation.getRelation(rel != null ? rel.image : null,</span>
                      relnType != null ? relnType.image : null,
                      name != null ? name.image : null);
<span class="fc bfc" id="L313" title="All 2 branches covered.">          } else if (numArg2 == null) {</span>
<span class="pc bpc" id="L314" title="2 of 4 branches missed.">            reln = GraphRelation.getRelation(rel != null ? rel.image : null,</span>
                      relnType != null ? relnType.image : null,
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">                      Integer.parseInt(numArg.image),</span>
                      name != null ? name.image : null);
          } else {
<span class="pc bpc" id="L319" title="2 of 4 branches missed.">            reln = GraphRelation.getRelation(rel != null ? rel.image : null,</span>
                      relnType != null ? relnType.image : null,
<span class="fc" id="L321">                      Integer.parseInt(numArg.image),</span>
<span class="pc bpc" id="L322" title="1 of 2 branches missed.">                      Integer.parseInt(numArg2.image),</span>
                      name != null ? name.image : null);
          }
<span class="pc bpc" id="L325" title="1 of 5 branches missed.">    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {</span>
    case 17:
    case 19:
    case 23:
<span class="fc" id="L329">      node = ModNode(reln);</span>
<span class="fc" id="L330">      break;</span>
    case 13:
<span class="fc" id="L332">      jj_consume_token(13);</span>
<span class="fc" id="L333">      node = SubNode(reln);</span>
<span class="fc" id="L334">      jj_consume_token(14);</span>
<span class="fc" id="L335">      break;</span>
    default:
<span class="nc" id="L337">      jj_la1[16] = jj_gen;</span>
<span class="nc" id="L338">      jj_consume_token(-1);</span>
<span class="nc" id="L339">      throw new ParseException();</span>
    }
<span class="fc" id="L341">         {if (true) return node;}</span>
    throw new Error(&quot;Missing return statement in function&quot;);
  }

  final public SemgrexPattern NodeDisj(GraphRelation r) throws ParseException {
        SemgrexPattern child;
<span class="nc" id="L347">        List&lt;SemgrexPattern&gt; children = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L348">    jj_consume_token(19);</span>
<span class="nc" id="L349">    child = NodeConj(r);</span>
<span class="nc" id="L350">                                        children.add(child);</span>
    label_4:
    while (true) {
<span class="nc bnc" id="L353" title="All 4 branches missed.">      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {</span>
      case 15:
        ;
<span class="nc" id="L356">        break;</span>
      default:
<span class="nc" id="L358">        jj_la1[17] = jj_gen;</span>
<span class="nc" id="L359">        break label_4;</span>
      }
<span class="nc" id="L361">      jj_consume_token(15);</span>
<span class="nc" id="L362">      child = NodeConj(r);</span>
<span class="nc" id="L363">                                        children.add(child);</span>
    }
<span class="nc" id="L365">    jj_consume_token(20);</span>
<span class="nc bnc" id="L366" title="All 2 branches missed.">          if (children.size() == 1)</span>
<span class="nc" id="L367">                {if (true) return child;}</span>
          else
<span class="nc" id="L369">                {if (true) return new CoordinationPattern(true, children, false);}</span>
    throw new Error(&quot;Missing return statement in function&quot;);
  }

  final public SemgrexPattern NodeConj(GraphRelation r) throws ParseException {
        SemgrexPattern child;
<span class="nc" id="L375">        List&lt;SemgrexPattern&gt; children = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L376">    child = ModNode(r);</span>
<span class="nc" id="L377">                                 children.add(child);</span>
    label_5:
    while (true) {
<span class="nc bnc" id="L380" title="All 4 branches missed.">      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {</span>
      case 16:
      case 17:
      case 19:
      case 23:
        ;
<span class="nc" id="L386">        break;</span>
      default:
<span class="nc" id="L388">        jj_la1[18] = jj_gen;</span>
<span class="nc" id="L389">        break label_5;</span>
      }
<span class="nc bnc" id="L391" title="All 4 branches missed.">      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {</span>
      case 16:
<span class="nc" id="L393">        jj_consume_token(16);</span>
<span class="nc" id="L394">        break;</span>
      default:
<span class="nc" id="L396">        jj_la1[19] = jj_gen;</span>
        ;
      }
<span class="nc" id="L399">      child = ModNode(r);</span>
<span class="nc" id="L400">                                          children.add(child);</span>
    }
<span class="nc bnc" id="L402" title="All 2 branches missed.">          if (children.size() == 1)</span>
<span class="nc" id="L403">                {if (true) return child;}</span>
          else
<span class="nc" id="L405">                {if (true) return new CoordinationPattern(true, children, true);}</span>
    throw new Error(&quot;Missing return statement in function&quot;);
  }

  final public SemgrexPattern ModNode(GraphRelation r) throws ParseException {
        SemgrexPattern child;
        boolean startUnderNeg;
<span class="pc bpc" id="L412" title="2 of 5 branches missed.">    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {</span>
    case 19:
    case 23:
<span class="fc" id="L415">      child = Child(r);</span>
<span class="fc" id="L416">      break;</span>
    case 17:
<span class="fc" id="L418">      jj_consume_token(17);</span>
<span class="fc" id="L419">                    startUnderNeg = underNodeNegation;</span>
<span class="fc" id="L420">                    underNodeNegation = true;</span>
<span class="fc" id="L421">      child = Child(r);</span>
<span class="fc" id="L422">                                                                   underNodeNegation = startUnderNeg;</span>
<span class="fc" id="L423">      break;</span>
    default:
<span class="nc" id="L425">      jj_la1[20] = jj_gen;</span>
<span class="nc" id="L426">      jj_consume_token(-1);</span>
<span class="nc" id="L427">      throw new ParseException();</span>
    }
<span class="fc" id="L429">                {if (true) return child;}</span>
    throw new Error(&quot;Missing return statement in function&quot;);
  }

  final public SemgrexPattern Child(GraphRelation r) throws ParseException {
        SemgrexPattern child;
<span class="pc bpc" id="L435" title="2 of 5 branches missed.">    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {</span>
    case 19:
<span class="nc" id="L437">      child = NodeDisj(r);</span>
<span class="nc" id="L438">      break;</span>
    case 23:
<span class="fc" id="L440">      child = Description(r);</span>
<span class="fc" id="L441">      break;</span>
    default:
<span class="nc" id="L443">      jj_la1[21] = jj_gen;</span>
<span class="nc" id="L444">      jj_consume_token(-1);</span>
<span class="nc" id="L445">      throw new ParseException();</span>
    }
<span class="fc" id="L447">          {if (true) return child;}</span>
    throw new Error(&quot;Missing return statement in function&quot;);
  }

  final public NodePattern Description(GraphRelation r) throws ParseException {
<span class="fc" id="L452">        Token name = null;</span>
<span class="fc" id="L453">        boolean link = false;</span>
<span class="fc" id="L454">        boolean isRoot = false;</span>
<span class="fc" id="L455">        boolean isEmpty = false;</span>
<span class="fc" id="L456">        Token attr = null;</span>
<span class="fc" id="L457">        Token value = null;</span>
<span class="fc" id="L458">        Map&lt;String, String&gt; attributes = Generics.newHashMap();</span>
        NodePattern pat;
<span class="fc" id="L460">    jj_consume_token(23);</span>
<span class="pc bpc" id="L461" title="3 of 7 branches missed.">    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {</span>
    case IDENTIFIER:
<span class="fc" id="L463">      attr = jj_consume_token(IDENTIFIER);</span>
<span class="fc" id="L464">      jj_consume_token(12);</span>
<span class="pc bpc" id="L465" title="2 of 5 branches missed.">      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {</span>
      case IDENTIFIER:
<span class="fc" id="L467">        value = jj_consume_token(IDENTIFIER);</span>
<span class="fc" id="L468">        break;</span>
      case REGEX:
<span class="fc" id="L470">        value = jj_consume_token(REGEX);</span>
<span class="fc" id="L471">        break;</span>
      default:
<span class="nc" id="L473">        jj_la1[22] = jj_gen;</span>
<span class="nc" id="L474">        jj_consume_token(-1);</span>
<span class="nc" id="L475">        throw new ParseException();</span>
      }
<span class="pc bpc" id="L477" title="2 of 4 branches missed.">           if (attr != null &amp;&amp; value != null) attributes.put(attr.image, value.image);</span>
      label_6:
      while (true) {
<span class="pc bpc" id="L480" title="2 of 4 branches missed.">        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {</span>
        case 24:
          ;
<span class="nc" id="L483">          break;</span>
        default:
<span class="fc" id="L485">          jj_la1[23] = jj_gen;</span>
<span class="fc" id="L486">          break label_6;</span>
        }
<span class="nc" id="L488">        jj_consume_token(24);</span>
<span class="nc" id="L489">        attr = jj_consume_token(IDENTIFIER);</span>
<span class="nc" id="L490">        jj_consume_token(12);</span>
<span class="nc bnc" id="L491" title="All 5 branches missed.">        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {</span>
        case IDENTIFIER:
<span class="nc" id="L493">          value = jj_consume_token(IDENTIFIER);</span>
<span class="nc" id="L494">          break;</span>
        case REGEX:
<span class="nc" id="L496">          value = jj_consume_token(REGEX);</span>
<span class="nc" id="L497">          break;</span>
        default:
<span class="nc" id="L499">          jj_la1[24] = jj_gen;</span>
<span class="nc" id="L500">          jj_consume_token(-1);</span>
<span class="nc" id="L501">          throw new ParseException();</span>
        }
<span class="nc bnc" id="L503" title="All 4 branches missed.">                if (attr != null &amp;&amp; value != null) attributes.put(attr.image, value.image);</span>
      }
<span class="fc" id="L505">      jj_consume_token(25);</span>
<span class="fc" id="L506">      break;</span>
    case ROOT:
<span class="fc" id="L508">      attr = jj_consume_token(ROOT);</span>
<span class="fc" id="L509">      jj_consume_token(25);</span>
<span class="fc" id="L510">        isRoot = true;</span>
<span class="fc" id="L511">      break;</span>
    case EMPTY:
<span class="nc" id="L513">      attr = jj_consume_token(EMPTY);</span>
<span class="nc" id="L514">      jj_consume_token(25);</span>
<span class="nc" id="L515">        isEmpty = true;</span>
<span class="nc" id="L516">      break;</span>
    case 25:
<span class="fc" id="L518">      jj_consume_token(25);</span>
<span class="fc" id="L519">      break;</span>
    default:
<span class="nc" id="L521">      jj_la1[25] = jj_gen;</span>
<span class="nc" id="L522">      jj_consume_token(-1);</span>
<span class="nc" id="L523">      throw new ParseException();</span>
    }
<span class="pc bpc" id="L525" title="1 of 4 branches missed.">    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {</span>
    case 22:
<span class="fc" id="L527">      jj_consume_token(22);</span>
<span class="fc" id="L528">                  link = true;</span>
<span class="fc" id="L529">      name = jj_consume_token(IDENTIFIER);</span>
<span class="fc" id="L530">              String nodeName = name.image;</span>
<span class="fc bfc" id="L531" title="All 2 branches covered.">              if (underNegation) {</span>
<span class="pc bpc" id="L532" title="1 of 2 branches missed.">                if (!knownVariables.contains(nodeName)) {</span>
<span class="nc" id="L533">                  {if (true) throw new ParseException(&quot;Cannot add new variable names under negation.  Node '&quot; + nodeName + &quot;' not seen before&quot;);}</span>
                }
              } else {
<span class="fc" id="L536">                knownVariables.add(nodeName);</span>
              }
<span class="fc" id="L538">      break;</span>
    default:
<span class="fc" id="L540">      jj_la1[26] = jj_gen;</span>
      ;
    }
<span class="fc bfc" id="L543" title="All 2 branches covered.">          pat = new NodePattern(r, underNodeNegation, attributes, isRoot, isEmpty, name != null ? name.image : null);</span>
<span class="fc bfc" id="L544" title="All 2 branches covered.">           if (link) pat.makeLink();</span>
<span class="fc" id="L545">          {if (true) return pat;}</span>
    throw new Error(&quot;Missing return statement in function&quot;);
  }

  /** Generated Token Manager. */
  public SemgrexParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
<span class="pc" id="L558">  final private int[] jj_la1 = new int[27];</span>
  static private int[] jj_la1_0;
  static {
<span class="fc" id="L561">      jj_la1_init_0();</span>
<span class="fc" id="L562">   }</span>
   private static void jj_la1_init_0() {
<span class="fc" id="L564">      jj_la1_0 = new int[] {0x1000,0x8a2020,0xe0070,0xe0070,0x8a2000,0x8000,0xf0070,0x10000,0xe0070,0x80070,0x200000,0x40,0x440,0x440,0x400000,0x70,0x8a2000,0x8000,0x8b0000,0x10000,0x8a0000,0x880000,0x440,0x1000000,0x440,0x2000340,0x400000,};</span>
<span class="fc" id="L565">   }</span>

  /** Constructor with InputStream. */
  public SemgrexParser(java.io.InputStream stream) {
<span class="nc" id="L569">     this(stream, null);</span>
<span class="nc" id="L570">  }</span>
  /** Constructor with InputStream and supplied encoding */
<span class="nc" id="L572">  public SemgrexParser(java.io.InputStream stream, String encoding) {</span>
<span class="nc" id="L573">    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }</span>
<span class="nc" id="L574">    token_source = new SemgrexParserTokenManager(jj_input_stream);</span>
<span class="nc" id="L575">    token = new Token();</span>
<span class="nc" id="L576">    jj_ntk = -1;</span>
<span class="nc" id="L577">    jj_gen = 0;</span>
<span class="nc bnc" id="L578" title="All 2 branches missed.">    for (int i = 0; i &lt; 27; i++) jj_la1[i] = -1;</span>
<span class="nc" id="L579">  }</span>

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
<span class="nc" id="L583">     ReInit(stream, null);</span>
<span class="nc" id="L584">  }</span>
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
<span class="nc" id="L587">    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }</span>
<span class="nc" id="L588">    token_source.ReInit(jj_input_stream);</span>
<span class="nc" id="L589">    token = new Token();</span>
<span class="nc" id="L590">    jj_ntk = -1;</span>
<span class="nc" id="L591">    jj_gen = 0;</span>
<span class="nc bnc" id="L592" title="All 2 branches missed.">    for (int i = 0; i &lt; 27; i++) jj_la1[i] = -1;</span>
<span class="nc" id="L593">  }</span>

  /** Constructor. */
<span class="fc" id="L596">  public SemgrexParser(java.io.Reader stream) {</span>
<span class="fc" id="L597">    jj_input_stream = new SimpleCharStream(stream, 1, 1);</span>
<span class="fc" id="L598">    token_source = new SemgrexParserTokenManager(jj_input_stream);</span>
<span class="fc" id="L599">    token = new Token();</span>
<span class="fc" id="L600">    jj_ntk = -1;</span>
<span class="fc" id="L601">    jj_gen = 0;</span>
<span class="fc bfc" id="L602" title="All 2 branches covered.">    for (int i = 0; i &lt; 27; i++) jj_la1[i] = -1;</span>
<span class="fc" id="L603">  }</span>

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
<span class="nc" id="L607">    jj_input_stream.ReInit(stream, 1, 1);</span>
<span class="nc" id="L608">    token_source.ReInit(jj_input_stream);</span>
<span class="nc" id="L609">    token = new Token();</span>
<span class="nc" id="L610">    jj_ntk = -1;</span>
<span class="nc" id="L611">    jj_gen = 0;</span>
<span class="nc bnc" id="L612" title="All 2 branches missed.">    for (int i = 0; i &lt; 27; i++) jj_la1[i] = -1;</span>
<span class="nc" id="L613">  }</span>

  /** Constructor with generated Token Manager. */
<span class="nc" id="L616">  public SemgrexParser(SemgrexParserTokenManager tm) {</span>
<span class="nc" id="L617">    token_source = tm;</span>
<span class="nc" id="L618">    token = new Token();</span>
<span class="nc" id="L619">    jj_ntk = -1;</span>
<span class="nc" id="L620">    jj_gen = 0;</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">    for (int i = 0; i &lt; 27; i++) jj_la1[i] = -1;</span>
<span class="nc" id="L622">  }</span>

  /** Reinitialise. */
  public void ReInit(SemgrexParserTokenManager tm) {
<span class="nc" id="L626">    token_source = tm;</span>
<span class="nc" id="L627">    token = new Token();</span>
<span class="nc" id="L628">    jj_ntk = -1;</span>
<span class="nc" id="L629">    jj_gen = 0;</span>
<span class="nc bnc" id="L630" title="All 2 branches missed.">    for (int i = 0; i &lt; 27; i++) jj_la1[i] = -1;</span>
<span class="nc" id="L631">  }</span>

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
<span class="fc bfc" id="L635" title="All 2 branches covered.">    if ((oldToken = token).next != null) token = token.next;</span>
<span class="fc" id="L636">    else token = token.next = token_source.getNextToken();</span>
<span class="fc" id="L637">    jj_ntk = -1;</span>
<span class="pc bpc" id="L638" title="1 of 2 branches missed.">    if (token.kind == kind) {</span>
<span class="fc" id="L639">      jj_gen++;</span>
<span class="fc" id="L640">      return token;</span>
    }
<span class="nc" id="L642">    token = oldToken;</span>
<span class="nc" id="L643">    jj_kind = kind;</span>
<span class="nc" id="L644">    throw generateParseException();</span>
  }


/** Get the next Token. */
  final public Token getNextToken() {
<span class="nc bnc" id="L650" title="All 2 branches missed.">    if (token.next != null) token = token.next;</span>
<span class="nc" id="L651">    else token = token.next = token_source.getNextToken();</span>
<span class="nc" id="L652">    jj_ntk = -1;</span>
<span class="nc" id="L653">    jj_gen++;</span>
<span class="nc" id="L654">    return token;</span>
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
<span class="nc" id="L659">    Token t = token;</span>
<span class="nc bnc" id="L660" title="All 2 branches missed.">    for (int i = 0; i &lt; index; i++) {</span>
<span class="nc bnc" id="L661" title="All 2 branches missed.">      if (t.next != null) t = t.next;</span>
<span class="nc" id="L662">      else t = t.next = token_source.getNextToken();</span>
    }
<span class="nc" id="L664">    return t;</span>
  }

  private int jj_ntk() {
<span class="pc bpc" id="L668" title="1 of 2 branches missed.">    if ((jj_nt=token.next) == null)</span>
<span class="fc" id="L669">      return (jj_ntk = (token.next=token_source.getNextToken()).kind);</span>
    else
<span class="nc" id="L671">      return (jj_ntk = jj_nt.kind);</span>
  }

<span class="pc" id="L674">  private java.util.List&lt;int[]&gt; jj_expentries = new java.util.ArrayList&lt;&gt;();</span>
  private int[] jj_expentry;
<span class="pc" id="L676">  private int jj_kind = -1;</span>

  /** Generate ParseException. */
  public ParseException generateParseException() {
<span class="nc" id="L680">    jj_expentries.clear();</span>
<span class="nc" id="L681">    boolean[] la1tokens = new boolean[26];</span>
<span class="nc bnc" id="L682" title="All 2 branches missed.">    if (jj_kind &gt;= 0) {</span>
<span class="nc" id="L683">      la1tokens[jj_kind] = true;</span>
<span class="nc" id="L684">      jj_kind = -1;</span>
    }
<span class="nc bnc" id="L686" title="All 2 branches missed.">    for (int i = 0; i &lt; 27; i++) {</span>
<span class="nc bnc" id="L687" title="All 2 branches missed.">      if (jj_la1[i] == jj_gen) {</span>
<span class="nc bnc" id="L688" title="All 2 branches missed.">        for (int j = 0; j &lt; 32; j++) {</span>
<span class="nc bnc" id="L689" title="All 2 branches missed.">          if ((jj_la1_0[i] &amp; (1&lt;&lt;j)) != 0) {</span>
<span class="nc" id="L690">            la1tokens[j] = true;</span>
          }
        }
      }
    }
<span class="nc bnc" id="L695" title="All 2 branches missed.">    for (int i = 0; i &lt; 26; i++) {</span>
<span class="nc bnc" id="L696" title="All 2 branches missed.">      if (la1tokens[i]) {</span>
<span class="nc" id="L697">        jj_expentry = new int[1];</span>
<span class="nc" id="L698">        jj_expentry[0] = i;</span>
<span class="nc" id="L699">        jj_expentries.add(jj_expentry);</span>
      }
    }
<span class="nc" id="L702">    int[][] exptokseq = new int[jj_expentries.size()][];</span>
<span class="nc bnc" id="L703" title="All 2 branches missed.">    for (int i = 0; i &lt; jj_expentries.size(); i++) {</span>
<span class="nc" id="L704">      exptokseq[i] = jj_expentries.get(i);</span>
    }
<span class="nc" id="L706">    return new ParseException(token, exptokseq, tokenImage);</span>
  }

  /** Enable tracing. */
  final public void enable_tracing() {
<span class="nc" id="L711">  }</span>

  /** Disable tracing. */
  final public void disable_tracing() {
<span class="nc" id="L715">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>