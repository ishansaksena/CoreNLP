<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GraphRelation.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.semgraph.semgrex</a> &gt; <span class="el_source">GraphRelation.java</span></div><h1>GraphRelation.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.semgraph.semgrex; 
import edu.stanford.nlp.util.logging.Redwood;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Stack;

import edu.stanford.nlp.ling.IndexedWord;
import edu.stanford.nlp.trees.GrammaticalRelation;
import edu.stanford.nlp.semgraph.SemanticGraph;
import edu.stanford.nlp.semgraph.SemanticGraphEdge;
import edu.stanford.nlp.util.*;
import java.util.function.Predicate;

/**
 * An abstract base class for relations between graph nodes in semgrex. There
 * are two types of subclasses: static anonymous singleton instantiations for
 * relations that do not require arguments, and private subclasses for those
 * with arguments. All invocations should be made through the static factory
 * methods.
 * &lt;p/&gt;
 * If you want to add a new relation, you just have to fill in the definition of
 * &lt;code&gt;satisfies()&lt;/code&gt; and &lt;code&gt;searchNodeIterator()&lt;/code&gt;. Also be
 * careful to make the appropriate adjustments to
 * &lt;code&gt;getRelation()&lt;/code&gt;. Finally, if you are using the SemgrexParser, you
 * need to add the new relation symbol to the list of tokens. &lt;p/&gt;
 *
 * @author Chloe Kiddon
 */
abstract class GraphRelation implements Serializable {
  final String symbol;
  final Predicate&lt;String&gt; type;
  final String rawType;

  final String name;

  //&quot;&lt;&quot; | &quot;&gt;&quot; | &quot;&gt;&gt;&quot; | &quot;&lt;&lt;&quot; | &quot;&lt;#&quot; | &quot;&gt;#&quot; | &quot;:&quot; | &quot;@&quot;&gt;


  /**
   * Returns &lt;code&gt;true&lt;/code&gt; iff this &lt;code&gt;GraphRelation&lt;/code&gt; holds between
   * the given pair of nodes in the given semantic graph.
   */
  abstract boolean satisfies(IndexedWord n1, IndexedWord n2, SemanticGraph sg);

  /**
   * For a given node and its root, returns an {@link Iterator} over the nodes
   * of the semantic graph that satisfy the relation.
   */
  abstract Iterator&lt;IndexedWord&gt; searchNodeIterator(IndexedWord node, SemanticGraph sg);

<span class="fc" id="L56">  private GraphRelation(String symbol, String type, String name) {</span>
<span class="fc" id="L57">    this.symbol = symbol;</span>
<span class="fc" id="L58">    this.type   = getPattern(type);</span>
<span class="fc" id="L59">    this.rawType = type;</span>
<span class="fc" id="L60">    this.name = name;</span>
<span class="fc" id="L61">  }</span>

  private GraphRelation(String symbol, String type) {
<span class="fc" id="L64">    this(symbol, type, null);</span>
<span class="fc" id="L65">  }</span>

  private GraphRelation(String symbol) {
<span class="nc" id="L68">    this(symbol, null);</span>
<span class="nc" id="L69">  }</span>

  @Override
  public String toString() {
<span class="fc bfc" id="L73" title="All 4 branches covered.">    return symbol + ((rawType != null) ? rawType : &quot;&quot;) + ((name != null) ? &quot;=&quot; + name : &quot;&quot;);</span>
  }

  public Predicate&lt;String&gt; getPattern(String relnType)
  {
<span class="fc bfc" id="L78" title="All 4 branches covered.">    if ((relnType == null) || (relnType.equals(&quot;&quot;))) {</span>
<span class="fc" id="L79">      return Filters.acceptFilter();</span>
<span class="fc bfc" id="L80" title="All 2 branches covered.">    } else if (relnType.matches(&quot;/.*/&quot;)) {</span>
<span class="fc" id="L81">      return new RegexStringFilter(relnType.substring(1, relnType.length() - 1));</span>
    } else { // raw description
<span class="fc" id="L83">      return new ArrayStringFilter(ArrayStringFilter.Mode.EXACT, relnType);</span>
    }
  }

  public String getName() {
<span class="pc bpc" id="L88" title="1 of 4 branches missed.">    if (name == null || name == &quot;&quot;) return null;</span>
<span class="fc" id="L89">    return name;</span>
  }


  // ALIGNMENT graph relation: &quot;@&quot; ==============================================

  static class ALIGNMENT extends GraphRelation {

    private Alignment alignment;
    private boolean hypToText;

    ALIGNMENT() {
<span class="fc" id="L101">      super(&quot;@&quot;, &quot;&quot;);</span>
<span class="fc" id="L102">      hypToText = true;</span>
<span class="fc" id="L103">    }</span>

    void setAlignment(Alignment alignment, boolean hypToText, SearchNodeIterator itr) {
<span class="fc" id="L106">      this.alignment = alignment;</span>
<span class="fc" id="L107">      this.hypToText = hypToText;</span>
      //log.info(&quot;setting alignment&quot;);
<span class="fc" id="L109">      itr.advance();</span>
<span class="fc" id="L110">    }</span>

    @Override
    boolean satisfies(IndexedWord l1, IndexedWord l2, SemanticGraph sg) {
<span class="nc bnc" id="L114" title="All 2 branches missed.">      if (alignment == null) return false;</span>
<span class="nc bnc" id="L115" title="All 2 branches missed.">      if (hypToText)</span>
<span class="nc" id="L116">        return (alignment.getMap().get(l1)).equals(l2);</span>
      else {
<span class="nc" id="L118">        return (alignment.getMap().get(l2)).equals(l1);</span>
      }
    }

    @Override
    Iterator&lt;IndexedWord&gt; searchNodeIterator(final IndexedWord node, final SemanticGraph sg) {
<span class="fc" id="L124">      return new SearchNodeIterator() {</span>

<span class="fc" id="L126">          boolean foundOnce = false;</span>
          int nextNum;

          // not really initialized until alignment is set
          @Override
          public void initialize() {

<span class="fc" id="L133">          }</span>

          @Override
          public void advance() {
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">            if (alignment == null) return;</span>
<span class="pc bpc" id="L138" title="1 of 2 branches missed.">            if (node.equals(IndexedWord.NO_WORD)) next = null;</span>
            //log.info(&quot;node: &quot; + node.word());
<span class="pc bpc" id="L140" title="1 of 2 branches missed.">            if (hypToText) {</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">              if (!foundOnce) {</span>
<span class="fc" id="L142">                next = alignment.getMap().get(node);</span>
<span class="fc" id="L143">                foundOnce = true;</span>
              //  if (next == null) log.info(&quot;no alignment&quot;); else
               // log.info(&quot;other graph: &quot; + next.word());
              }
              else {
<span class="fc" id="L148">                next = null;</span>
                //log.info(&quot;next: null&quot;);
              }
            } else {

<span class="nc" id="L153">              int num = 0;</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">              for (Map.Entry&lt;IndexedWord, IndexedWord&gt; pair : alignment.getMap().entrySet()) {</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">                if (pair.getValue().equals(node)) {</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">                  if (nextNum == num) {</span>
<span class="nc" id="L157">                    next = pair.getKey();</span>
<span class="nc" id="L158">                    nextNum++;</span>
                    //log.info(&quot;next: &quot; + next.word());
<span class="nc" id="L160">                    return;</span>
                  }
<span class="nc" id="L162">                  num++;</span>
                }
<span class="nc" id="L164">              }</span>
              //log.info(&quot;backwards, next: null&quot;);
<span class="nc" id="L166">              next = null;</span>
            }
<span class="fc" id="L168">          }</span>

        };
    }

    // Generated automatically by Eclipse
    private static final long serialVersionUID = -2936526066368043778L;
  };


  // ROOT graph relation: &quot;Root&quot; ================================================

<span class="fc" id="L180">  static final GraphRelation ROOT = new GraphRelation(&quot;&quot;, &quot;&quot;) {</span>
      @Override
      boolean satisfies(IndexedWord l1, IndexedWord l2, SemanticGraph sg) {
<span class="nc bnc" id="L183" title="All 2 branches missed.">        return l1 == l2;</span>
      }

      @Override
      Iterator&lt;IndexedWord&gt; searchNodeIterator(final IndexedWord node, final SemanticGraph sg) {
<span class="fc" id="L188">        return new SearchNodeIterator() {</span>
            @Override
            void initialize() {
<span class="fc" id="L191">              next = node;</span>
<span class="fc" id="L192">            }</span>
          };
      }
      // automatically generated by Eclipse
      private static final long serialVersionUID = 4710135995247390313L;
  };

<span class="fc" id="L199">  static final GraphRelation ITERATOR = new GraphRelation(&quot;:&quot;, &quot;&quot;) {</span>
      @Override
      boolean satisfies(IndexedWord l1, IndexedWord l2, SemanticGraph sg) {
<span class="nc" id="L202">        return true;</span>
      }

      Iterator&lt;IndexedWord&gt; searchNodeIterator(final IndexedWord node,
                                               final SemanticGraph sg) {
<span class="fc" id="L207">        return sg.vertexSet().iterator();</span>
      }
      // automatically generated by Eclipse
      private static final long serialVersionUID = 5259713498453659251L;
    };


  // ALIGNED_ROOT graph relation: &quot;AlignRoot&quot; ===================================

<span class="fc" id="L216">  static final GraphRelation ALIGNED_ROOT = new GraphRelation(&quot;AlignRoot&quot;, &quot;&quot;) {</span>
      @Override
      boolean satisfies(IndexedWord l1, IndexedWord l2, SemanticGraph sg) {
<span class="nc bnc" id="L219" title="All 2 branches missed.">        return l1 == l2;</span>
      }

      @Override
      Iterator&lt;IndexedWord&gt; searchNodeIterator(final IndexedWord node, final SemanticGraph sg) {
<span class="nc" id="L224">        return new SearchNodeIterator() {</span>
            @Override
            void initialize() {
<span class="nc" id="L227">              next = node;</span>
<span class="nc" id="L228">            }</span>
          };
      }

      // automatically generated by Eclipse
      private static final long serialVersionUID = -3088857488269777611L;
  };


  // GOVERNOR graph relation: &quot;&gt;&quot; ===============================================

  static private class GOVERNER extends GraphRelation {
    GOVERNER(String reln, String name) {
<span class="fc" id="L241">      super(&quot;&gt;&quot;, reln, name);</span>
<span class="fc" id="L242">    }</span>

    @Override
    boolean satisfies(IndexedWord l1, IndexedWord l2, SemanticGraph sg) {
<span class="nc" id="L246">      List&lt;Pair&lt;GrammaticalRelation, IndexedWord&gt;&gt; deps = sg.childPairs(l1);</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">      for (Pair&lt;GrammaticalRelation, IndexedWord&gt; dep : deps) {</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">        if (this.type.test(dep.first().toString()) &amp;&amp;</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">            dep.second().equals(l2)) {</span>
<span class="nc" id="L250">          return true;</span>
        }
<span class="nc" id="L252">      }</span>
<span class="nc" id="L253">      return false;</span>
    }

    @Override
    Iterator&lt;IndexedWord&gt; searchNodeIterator(final IndexedWord node, final SemanticGraph sg) {
<span class="fc" id="L258">      return new SearchNodeIterator() {</span>
          Iterator&lt;SemanticGraphEdge&gt; iterator;

          @Override
          public void advance() {
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">            if (node.equals(IndexedWord.NO_WORD)) {</span>
<span class="nc" id="L264">              next = null;</span>
<span class="nc" id="L265">              return;</span>
            }
<span class="fc bfc" id="L267" title="All 2 branches covered.">            if (iterator == null) {</span>
<span class="fc" id="L268">              iterator = sg.outgoingEdgeIterator(node);</span>
            }
<span class="fc bfc" id="L270" title="All 2 branches covered.">            while (iterator.hasNext()) {</span>
<span class="fc" id="L271">              SemanticGraphEdge edge = iterator.next();</span>
<span class="fc" id="L272">              relation = edge.getRelation().toString();</span>
<span class="fc bfc" id="L273" title="All 2 branches covered.">              if (!type.test(relation)) {</span>
<span class="fc" id="L274">                continue;</span>
              }
<span class="fc" id="L276">              this.next = edge.getTarget();</span>
<span class="fc" id="L277">              return;</span>
            }
<span class="fc" id="L279">            this.next = null;</span>
<span class="fc" id="L280">          }</span>
        };
    }

    // automatically generated by Eclipse
    private static final long serialVersionUID = -7003148918274183951L;
  };


  // DEPENDENT graph relation: &quot;&lt;&quot; ===============================================

  static private class DEPENDENT extends GraphRelation {
    DEPENDENT(String reln, String name) {
<span class="fc" id="L293">      super(&quot;&lt;&quot;, reln, name);</span>
<span class="fc" id="L294">    }</span>

    @Override
    boolean satisfies(IndexedWord l1, IndexedWord l2, SemanticGraph sg) {
<span class="nc bnc" id="L298" title="All 4 branches missed.">      if (l1.equals(IndexedWord.NO_WORD) || l2.equals(IndexedWord.NO_WORD) )</span>
<span class="nc" id="L299">        return false;</span>
<span class="nc" id="L300">      List&lt;Pair&lt;GrammaticalRelation, IndexedWord&gt;&gt; govs = sg.parentPairs(l1);</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">      for (Pair&lt;GrammaticalRelation, IndexedWord&gt; gov : govs) {</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">        if (this.type.test(gov.first().toString()) &amp;&amp;</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">            gov.second().equals(l2)) return true;</span>
<span class="nc" id="L304">      }</span>
<span class="nc" id="L305">      return false;</span>
    }

    @Override
    Iterator&lt;IndexedWord&gt; searchNodeIterator(final IndexedWord node, final SemanticGraph sg) {
<span class="fc" id="L310">      return new SearchNodeIterator() {</span>
          int nextNum; // subtle bug warning here: if we use int nextNum=0;

          // instead,

          // we get the first daughter twice because the assignment occurs after
          // advance() has already been
          // called once by the constructor of SearchNodeIterator.

          @Override
          public void advance() {
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">            if (node.equals(IndexedWord.NO_WORD)) {</span>
<span class="nc" id="L322">              next = null;</span>
<span class="nc" id="L323">              return;</span>
            }
<span class="fc" id="L325">            List&lt;Pair&lt;GrammaticalRelation, IndexedWord&gt;&gt; govs = sg.parentPairs(node);</span>
<span class="fc bfc" id="L326" title="All 4 branches covered.">            while (nextNum &lt; govs.size() &amp;&amp; !type.test(govs.get(nextNum).first().toString())) {</span>
<span class="fc" id="L327">              nextNum++;</span>
            }
<span class="fc bfc" id="L329" title="All 2 branches covered.">            if (nextNum &lt; govs.size()) {</span>
<span class="fc" id="L330">              next = govs.get(nextNum).second();</span>
<span class="fc" id="L331">              relation = govs.get(nextNum).first().toString();</span>
<span class="fc" id="L332">              nextNum++;</span>
            } else {
<span class="fc" id="L334">              next = null;</span>
            }
<span class="fc" id="L336">          }</span>
        };
    }

    // automatically generated by Eclipse
    private static final long serialVersionUID = -5115389883698108694L;
  };


  static private class LIMITED_GRANDPARENT extends GraphRelation {
    final int startDepth, endDepth;

    LIMITED_GRANDPARENT(String reln, String name,
                        int startDepth, int endDepth) {
<span class="fc" id="L350">      super(startDepth + &quot;,&quot; + endDepth + &quot;&gt;&gt;&quot;, reln, name);</span>
<span class="fc" id="L351">      this.startDepth = startDepth;</span>
<span class="fc" id="L352">      this.endDepth = endDepth;</span>
<span class="fc" id="L353">    }</span>

    @Override
    boolean satisfies(IndexedWord l1, IndexedWord l2, SemanticGraph sg) {
<span class="nc bnc" id="L357" title="All 4 branches missed.">      if (l1.equals(IndexedWord.NO_WORD) || l2.equals(IndexedWord.NO_WORD) )</span>
<span class="nc" id="L358">        return false;</span>
<span class="nc" id="L359">      List&lt;Set&lt;IndexedWord&gt;&gt; usedNodes = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L360" title="All 2 branches missed.">      for (int i = 0; i &lt;= endDepth; ++i) {</span>
<span class="nc" id="L361">        usedNodes.add(Generics.&lt;IndexedWord&gt;newIdentityHashSet());</span>
      }
<span class="nc bnc" id="L363" title="All 4 branches missed.">      return l1 != l2 &amp;&amp; satisfyHelper(l1, l2, sg, 0, usedNodes);</span>
    }

    private boolean satisfyHelper(IndexedWord parent,
                                  IndexedWord l2,
                                  SemanticGraph sg,
                                  int depth,
				  List&lt;Set&lt;IndexedWord&gt;&gt; usedNodes) {
<span class="nc" id="L371">      List&lt;Pair&lt;GrammaticalRelation, IndexedWord&gt;&gt; deps = sg.childPairs(parent);</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">      if (depth + 1 &gt; endDepth) {</span>
<span class="nc" id="L373">        return false;</span>
      }
<span class="nc bnc" id="L375" title="All 2 branches missed.">      if (depth + 1 &gt;= startDepth) {</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">        for (Pair&lt;GrammaticalRelation, IndexedWord&gt; dep : deps) {</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">          if (this.type.test(dep.first().toString()) &amp;&amp;</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">              dep.second().equals(l2)) return true;</span>
<span class="nc" id="L379">        }</span>
      }

<span class="nc" id="L382">      usedNodes.get(depth).add(parent);</span>

<span class="nc bnc" id="L384" title="All 2 branches missed.">      for (Pair&lt;GrammaticalRelation, IndexedWord&gt; dep : deps) {</span>
<span class="nc bnc" id="L385" title="All 2 branches missed.">        if ((usedNodes.size() &lt; depth + 1 ||</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">             !usedNodes.get(depth + 1).contains(dep.second())) &amp;&amp;</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">            satisfyHelper(dep.second(), l2, sg, depth + 1, usedNodes))</span>
<span class="nc" id="L388">          return true;</span>
<span class="nc" id="L389">      }</span>
<span class="nc" id="L390">      return false;</span>
    }

    @Override
    Iterator&lt;IndexedWord&gt; searchNodeIterator(final IndexedWord node, final SemanticGraph sg) {
<span class="fc" id="L395">      return new SearchNodeIterator() {</span>
          List&lt;Stack&lt;Pair&lt;GrammaticalRelation, IndexedWord&gt;&gt;&gt; searchStack;
          List&lt;Set&lt;IndexedWord&gt;&gt; seenNodes;
          Set&lt;IndexedWord&gt; returnedNodes;
          int currentDepth;

          @Override
          public void initialize() {
<span class="pc bpc" id="L403" title="1 of 2 branches missed.">            if (node.equals(IndexedWord.NO_WORD)) {</span>
<span class="nc" id="L404">              next = null;</span>
<span class="nc" id="L405">              return;</span>
            }
<span class="fc" id="L407">            searchStack = Generics.newArrayList();</span>
<span class="fc bfc" id="L408" title="All 2 branches covered.">            for (int i = 0; i &lt;= endDepth; ++i) {</span>
<span class="fc" id="L409">              searchStack.add(new Stack&lt;&gt;());</span>
            }
<span class="fc" id="L411">            seenNodes = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L412" title="All 2 branches covered.">            for (int i = 0; i &lt;= endDepth; ++i) {</span>
<span class="fc" id="L413">              seenNodes.add(Generics.&lt;IndexedWord&gt;newIdentityHashSet());</span>
            }
<span class="fc" id="L415">            returnedNodes = Generics.newIdentityHashSet();</span>
<span class="fc" id="L416">            currentDepth = 1;</span>
<span class="fc" id="L417">            List&lt;Pair&lt;GrammaticalRelation, IndexedWord&gt;&gt; children = sg.childPairs(node);</span>
<span class="fc bfc" id="L418" title="All 2 branches covered.">            for (int i = children.size() - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L419">              searchStack.get(1).push(children.get(i));</span>
            }
<span class="fc bfc" id="L421" title="All 2 branches covered.">            if (!searchStack.get(1).isEmpty()) {</span>
<span class="fc" id="L422">              advance();</span>
            }
<span class="fc" id="L424">          }</span>

          @Override
          void advance() {
<span class="pc bpc" id="L428" title="1 of 2 branches missed.">            if (node.equals(IndexedWord.NO_WORD)) {</span>
<span class="nc" id="L429">              next = null;</span>
<span class="nc" id="L430">              return;</span>
            }
            Pair&lt;GrammaticalRelation, IndexedWord&gt; nextPair;
<span class="fc bfc" id="L433" title="All 2 branches covered.">            while (currentDepth &lt;= endDepth) {</span>
<span class="fc" id="L434">              Stack&lt;Pair&lt;GrammaticalRelation, IndexedWord&gt;&gt; thisStack = searchStack.get(currentDepth);</span>
<span class="fc" id="L435">              Set&lt;IndexedWord&gt; thisSeen = seenNodes.get(currentDepth);</span>
              Stack&lt;Pair&lt;GrammaticalRelation, IndexedWord&gt;&gt; nextStack;
              Set&lt;IndexedWord&gt; nextSeen;
<span class="fc bfc" id="L438" title="All 2 branches covered.">              if (currentDepth &lt; endDepth) {</span>
<span class="fc" id="L439">                nextStack = searchStack.get(currentDepth + 1);</span>
<span class="fc" id="L440">                nextSeen = seenNodes.get(currentDepth + 1);</span>
              } else {
<span class="fc" id="L442">                nextStack = null;</span>
<span class="fc" id="L443">                nextSeen = null;</span>
              }

<span class="fc bfc" id="L446" title="All 2 branches covered.">              while (!thisStack.isEmpty()) {</span>
<span class="fc" id="L447">                nextPair = thisStack.pop();</span>
<span class="fc bfc" id="L448" title="All 2 branches covered.">                if (thisSeen.contains(nextPair.second())) {</span>
<span class="fc" id="L449">                  continue;</span>
                }

<span class="fc" id="L452">                thisSeen.add(nextPair.second());</span>
<span class="fc" id="L453">                List&lt;Pair&lt;GrammaticalRelation, IndexedWord&gt;&gt; children =</span>
<span class="fc" id="L454">                  sg.childPairs(nextPair.second());</span>
<span class="fc bfc" id="L455" title="All 2 branches covered.">                for (int i = children.size() - 1; i &gt;= 0; i--) {</span>
<span class="fc bfc" id="L456" title="All 2 branches covered.">                  if (nextSeen != null &amp;&amp;</span>
<span class="pc bpc" id="L457" title="1 of 2 branches missed.">                      !nextSeen.contains(children.get(i).second()))</span>
<span class="fc" id="L458">                    nextStack.push(children.get(i));</span>
                }
<span class="fc bfc" id="L460" title="All 2 branches covered.">                if (currentDepth &gt;= startDepth &amp;&amp;</span>
<span class="pc bpc" id="L461" title="1 of 2 branches missed.">                    type.test(nextPair.first().toString()) &amp;&amp;</span>
<span class="fc bfc" id="L462" title="All 2 branches covered.">                    !returnedNodes.contains(nextPair.second())) {</span>
<span class="fc" id="L463">                  next = nextPair.second();</span>
<span class="fc" id="L464">                  relation = nextPair.first().toString();</span>
<span class="fc" id="L465">                  returnedNodes.add(nextPair.second());</span>
<span class="fc" id="L466">                  return;</span>
                }
<span class="fc" id="L468">              }</span>
              // didn't see anything at this depth, move to the next depth
<span class="fc" id="L470">              ++currentDepth;</span>
<span class="fc" id="L471">            }</span>
            // oh well, fell through with no results
<span class="fc" id="L473">            next = null;</span>
<span class="fc" id="L474">          }</span>
        };
    }

    // automatically generated by Eclipse
    private static final long serialVersionUID = 1L;
  };


  /**
   * Factored out the common code from GRANDKID and GRANDPARENT
   * &lt;br&gt;
   * In general, the only differences are which ways to go on edges,
   * so that is gotten through abstract methods
   */
  static private abstract class GRANDSOMETHING extends GraphRelation {
    GRANDSOMETHING(String symbol, String reln, String name) {
<span class="fc" id="L491">      super(symbol, reln, name);</span>
<span class="fc" id="L492">    }</span>

    abstract List&lt;Pair&lt;GrammaticalRelation, IndexedWord&gt;&gt; getNeighborPairs(SemanticGraph sg, IndexedWord node);

    abstract Iterator&lt;SemanticGraphEdge&gt; neighborIterator(SemanticGraph sg, IndexedWord search);

    abstract IndexedWord followEdge(SemanticGraphEdge edge);

    @Override
    boolean satisfies(IndexedWord l1, IndexedWord l2, SemanticGraph sg) {
<span class="nc bnc" id="L502" title="All 4 branches missed.">      return l1 != l2 &amp;&amp; satisfyHelper(l1, l2, sg, Generics.&lt;IndexedWord&gt;newIdentityHashSet());</span>
    }

    private boolean satisfyHelper(IndexedWord node, IndexedWord l2, SemanticGraph sg,
                                  Set&lt;IndexedWord&gt; usedNodes) {
<span class="nc" id="L507">      List&lt;Pair&lt;GrammaticalRelation, IndexedWord&gt;&gt; govs = getNeighborPairs(sg, node);</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">      for (Pair&lt;GrammaticalRelation, IndexedWord&gt; gov : govs) {</span>
<span class="nc bnc" id="L509" title="All 2 branches missed.">        if (this.type.test(gov.first().toString()) &amp;&amp;</span>
<span class="nc bnc" id="L510" title="All 2 branches missed.">            gov.second().equals(l2)) return true;</span>
<span class="nc" id="L511">      }</span>

<span class="nc" id="L513">      usedNodes.add(node);</span>

<span class="nc bnc" id="L515" title="All 2 branches missed.">      for (Pair&lt;GrammaticalRelation, IndexedWord&gt; gov : govs) {</span>
<span class="nc bnc" id="L516" title="All 4 branches missed.">        if (!usedNodes.contains(gov.second()) &amp;&amp; satisfyHelper(gov.second(), l2, sg, usedNodes))</span>
<span class="nc" id="L517">          return true;</span>
<span class="nc" id="L518">      }</span>
<span class="nc" id="L519">      return false;</span>
    }

    @Override
    Iterator&lt;IndexedWord&gt; searchNodeIterator(final IndexedWord node, final SemanticGraph sg) {
<span class="fc" id="L524">      return new SearchNodeIterator() {</span>
          Stack&lt;IndexedWord&gt; searchStack;
          Set&lt;IndexedWord&gt; searchedNodes;
          Set&lt;IndexedWord&gt; matchedNodes;

          Iterator&lt;SemanticGraphEdge&gt; neighborIterator;

          @Override
          public void initialize() {
<span class="pc bpc" id="L533" title="1 of 2 branches missed.">            if (node.equals(IndexedWord.NO_WORD)) {</span>
<span class="nc" id="L534">              next = null;</span>
<span class="nc" id="L535">              return;</span>
            }
<span class="fc" id="L537">            neighborIterator = null;</span>
<span class="fc" id="L538">            searchedNodes = Generics.newIdentityHashSet();</span>
<span class="fc" id="L539">            matchedNodes = Generics.newIdentityHashSet();</span>
<span class="fc" id="L540">            searchStack = Generics.newStack();</span>
<span class="fc" id="L541">            searchStack.push(node);</span>
<span class="fc" id="L542">            advance();</span>
<span class="fc" id="L543">          }</span>

          @Override
          void advance() {
<span class="pc bpc" id="L547" title="1 of 2 branches missed.">            if (node.equals(IndexedWord.NO_WORD)) {</span>
<span class="nc" id="L548">              next = null;</span>
<span class="nc" id="L549">              return;</span>
            }

<span class="fc bfc" id="L552" title="All 2 branches covered.">            while (!searchStack.isEmpty()) {</span>
<span class="fc bfc" id="L553" title="All 4 branches covered.">              if (neighborIterator == null || !neighborIterator.hasNext()) {</span>
<span class="fc" id="L554">                IndexedWord search = searchStack.pop();</span>
<span class="fc" id="L555">                neighborIterator = neighborIterator(sg, search);</span>
              }

<span class="fc bfc" id="L558" title="All 2 branches covered.">              while (neighborIterator.hasNext()) {</span>
<span class="fc" id="L559">                SemanticGraphEdge edge = neighborIterator.next();</span>
<span class="fc" id="L560">                IndexedWord otherEnd = followEdge(edge);</span>
<span class="fc bfc" id="L561" title="All 2 branches covered.">                if (!searchedNodes.contains(otherEnd)) {</span>
<span class="fc" id="L562">                  searchStack.push(otherEnd);</span>
<span class="fc" id="L563">                  searchedNodes.add(otherEnd);</span>
                }
<span class="fc bfc" id="L565" title="All 4 branches covered.">                if (type.test(edge.getRelation().toString()) &amp;&amp; !matchedNodes.contains(otherEnd)) {</span>
<span class="fc" id="L566">                  matchedNodes.add(otherEnd);</span>
<span class="fc" id="L567">                  next = otherEnd;</span>
<span class="fc" id="L568">                  relation = edge.getRelation().toString();</span>
<span class="fc" id="L569">                  return;</span>
                }
<span class="fc" id="L571">              }</span>
            }
            // oh well, fell through with no results
<span class="fc" id="L574">            next = null;</span>
<span class="fc" id="L575">          }</span>
        };
    }

    // automatically generated by Eclipse
    private static final long serialVersionUID = 1L;
  };

  // GRANDPARENT graph relation: &quot;&gt;&gt;&quot; ===========================================

  static private class GRANDPARENT extends GRANDSOMETHING {
    GRANDPARENT(String reln, String name) {
<span class="fc" id="L587">      super(&quot;&gt;&gt;&quot;, reln, name);</span>
<span class="fc" id="L588">    }</span>

    @Override
    List&lt;Pair&lt;GrammaticalRelation, IndexedWord&gt;&gt; getNeighborPairs(SemanticGraph sg, IndexedWord node) {
<span class="nc" id="L592">      return sg.childPairs(node);</span>
    }

    @Override
    Iterator&lt;SemanticGraphEdge&gt; neighborIterator(SemanticGraph sg, IndexedWord search) {
<span class="fc" id="L597">      return sg.outgoingEdgeIterator(search);</span>
    }

    @Override
    IndexedWord followEdge(SemanticGraphEdge edge) {
<span class="fc" id="L602">      return edge.getTarget();</span>
    }

    // automatically generated by Eclipse
    private static final long serialVersionUID = 1L;
  }

  // GRANDKID graph relation: &quot;&lt;&lt;&quot; ==============================================

  static private class GRANDKID extends GRANDSOMETHING {
    GRANDKID(String reln, String name) {
<span class="fc" id="L613">      super(&quot;&lt;&lt;&quot;, reln, name);</span>
<span class="fc" id="L614">    }</span>

    @Override
    List&lt;Pair&lt;GrammaticalRelation, IndexedWord&gt;&gt; getNeighborPairs(SemanticGraph sg, IndexedWord node) {
<span class="nc" id="L618">      return sg.parentPairs(node);</span>
    }

    @Override
    Iterator&lt;SemanticGraphEdge&gt; neighborIterator(SemanticGraph sg, IndexedWord search) {
<span class="fc" id="L623">      return sg.incomingEdgeIterator(search);</span>
    }

    @Override
    IndexedWord followEdge(SemanticGraphEdge edge) {
<span class="fc" id="L628">      return edge.getSource();</span>
    }

    // automatically generated by copying some other serialVersionUID
    private static final long serialVersionUID = 1L;
  }


  static private class LIMITED_GRANDKID extends GraphRelation {
    final int startDepth, endDepth;

    LIMITED_GRANDKID(String reln, String name,
                        int startDepth, int endDepth) {
<span class="fc" id="L641">      super(startDepth + &quot;,&quot; + endDepth + &quot;&lt;&lt;&quot;, reln, name);</span>
<span class="fc" id="L642">      this.startDepth = startDepth;</span>
<span class="fc" id="L643">      this.endDepth = endDepth;</span>
<span class="fc" id="L644">    }</span>

    @Override
    boolean satisfies(IndexedWord l1, IndexedWord l2, SemanticGraph sg) {
<span class="nc bnc" id="L648" title="All 4 branches missed.">      if (l1.equals(IndexedWord.NO_WORD) || l2.equals(IndexedWord.NO_WORD) )</span>
<span class="nc" id="L649">        return false;</span>
<span class="nc" id="L650">      List&lt;Set&lt;IndexedWord&gt;&gt; usedNodes = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L651" title="All 2 branches missed.">      for (int i = 0; i &lt;= endDepth; ++i) {</span>
<span class="nc" id="L652">        usedNodes.add(Generics.&lt;IndexedWord&gt;newIdentityHashSet());</span>
      }
<span class="nc bnc" id="L654" title="All 4 branches missed.">      return l1 != l2 &amp;&amp; satisfyHelper(l1, l2, sg, 0, usedNodes);</span>
    }

    private boolean satisfyHelper(IndexedWord child,
                                  IndexedWord l2,
                                  SemanticGraph sg,
                                  int depth,
				  List&lt;Set&lt;IndexedWord&gt;&gt; usedNodes) {
<span class="nc" id="L662">      List&lt;Pair&lt;GrammaticalRelation, IndexedWord&gt;&gt; deps = sg.parentPairs(child);</span>
<span class="nc bnc" id="L663" title="All 2 branches missed.">      if (depth + 1 &gt; endDepth) {</span>
<span class="nc" id="L664">        return false;</span>
      }
<span class="nc bnc" id="L666" title="All 2 branches missed.">      if (depth + 1 &gt;= startDepth) {</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">        for (Pair&lt;GrammaticalRelation, IndexedWord&gt; dep : deps) {</span>
<span class="nc bnc" id="L668" title="All 2 branches missed.">          if (this.type.test(dep.first().toString()) &amp;&amp;</span>
<span class="nc bnc" id="L669" title="All 2 branches missed.">              dep.second().equals(l2)) return true;</span>
<span class="nc" id="L670">        }</span>
      }

<span class="nc" id="L673">      usedNodes.get(depth).add(child);</span>

<span class="nc bnc" id="L675" title="All 2 branches missed.">      for (Pair&lt;GrammaticalRelation, IndexedWord&gt; dep : deps) {</span>
<span class="nc bnc" id="L676" title="All 2 branches missed.">        if ((usedNodes.size() &lt; depth + 1 ||</span>
<span class="nc bnc" id="L677" title="All 2 branches missed.">             !usedNodes.get(depth + 1).contains(dep.second())) &amp;&amp;</span>
<span class="nc bnc" id="L678" title="All 2 branches missed.">            satisfyHelper(dep.second(), l2, sg, depth + 1, usedNodes))</span>
<span class="nc" id="L679">          return true;</span>
<span class="nc" id="L680">      }</span>
<span class="nc" id="L681">      return false;</span>
    }

    @Override
    Iterator&lt;IndexedWord&gt; searchNodeIterator(final IndexedWord node, final SemanticGraph sg) {
<span class="fc" id="L686">      return new SearchNodeIterator() {</span>
          List&lt;Stack&lt;Pair&lt;GrammaticalRelation, IndexedWord&gt;&gt;&gt; searchStack;
          List&lt;Set&lt;IndexedWord&gt;&gt; seenNodes;
          Set&lt;IndexedWord&gt; returnedNodes;
          int currentDepth;

          @Override
          public void initialize() {
<span class="pc bpc" id="L694" title="1 of 2 branches missed.">            if (node.equals(IndexedWord.NO_WORD)) {</span>
<span class="nc" id="L695">              next = null;</span>
<span class="nc" id="L696">              return;</span>
            }
<span class="fc" id="L698">            searchStack = Generics.newArrayList();</span>
<span class="fc bfc" id="L699" title="All 2 branches covered.">            for (int i = 0; i &lt;= endDepth; ++i) {</span>
<span class="fc" id="L700">              searchStack.add(new Stack&lt;&gt;());</span>
            }
<span class="fc" id="L702">            seenNodes = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L703" title="All 2 branches covered.">            for (int i = 0; i &lt;= endDepth; ++i) {</span>
<span class="fc" id="L704">              seenNodes.add(Generics.&lt;IndexedWord&gt;newIdentityHashSet());</span>
            }
<span class="fc" id="L706">            returnedNodes = Generics.newIdentityHashSet();</span>
<span class="fc" id="L707">            currentDepth = 1;</span>
<span class="fc" id="L708">            List&lt;Pair&lt;GrammaticalRelation, IndexedWord&gt;&gt; parents = sg.parentPairs(node);</span>
<span class="fc bfc" id="L709" title="All 2 branches covered.">            for (int i = parents.size() - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L710">              searchStack.get(1).push(parents.get(i));</span>
            }
<span class="fc bfc" id="L712" title="All 2 branches covered.">            if (!searchStack.get(1).isEmpty()) {</span>
<span class="fc" id="L713">              advance();</span>
            }
<span class="fc" id="L715">          }</span>

          @Override
          void advance() {
<span class="pc bpc" id="L719" title="1 of 2 branches missed.">            if (node.equals(IndexedWord.NO_WORD)) {</span>
<span class="nc" id="L720">              next = null;</span>
<span class="nc" id="L721">              return;</span>
            }
            Pair&lt;GrammaticalRelation, IndexedWord&gt; nextPair;
<span class="fc bfc" id="L724" title="All 2 branches covered.">            while (currentDepth &lt;= endDepth) {</span>
<span class="fc" id="L725">              Stack&lt;Pair&lt;GrammaticalRelation, IndexedWord&gt;&gt; thisStack = searchStack.get(currentDepth);</span>
<span class="fc" id="L726">              Set&lt;IndexedWord&gt; thisSeen = seenNodes.get(currentDepth);</span>
              Stack&lt;Pair&lt;GrammaticalRelation, IndexedWord&gt;&gt; nextStack;
              Set&lt;IndexedWord&gt; nextSeen;
<span class="fc bfc" id="L729" title="All 2 branches covered.">              if (currentDepth &lt; endDepth) {</span>
<span class="fc" id="L730">                nextStack = searchStack.get(currentDepth + 1);</span>
<span class="fc" id="L731">                nextSeen = seenNodes.get(currentDepth + 1);</span>
              } else {
<span class="fc" id="L733">                nextStack = null;</span>
<span class="fc" id="L734">                nextSeen = null;</span>
              }

<span class="fc bfc" id="L737" title="All 2 branches covered.">              while (!thisStack.isEmpty()) {</span>
<span class="fc" id="L738">                nextPair = thisStack.pop();</span>
<span class="fc bfc" id="L739" title="All 2 branches covered.">                if (thisSeen.contains(nextPair.second())) {</span>
<span class="fc" id="L740">                  continue;</span>
                }

<span class="fc" id="L743">                thisSeen.add(nextPair.second());</span>
<span class="fc" id="L744">                List&lt;Pair&lt;GrammaticalRelation, IndexedWord&gt;&gt; parents =</span>
<span class="fc" id="L745">                  sg.parentPairs(nextPair.second());</span>
<span class="fc bfc" id="L746" title="All 2 branches covered.">                for (int i = parents.size() - 1; i &gt;= 0; i--) {</span>
<span class="fc bfc" id="L747" title="All 2 branches covered.">                  if (nextSeen != null &amp;&amp;</span>
<span class="pc bpc" id="L748" title="1 of 2 branches missed.">                      !nextSeen.contains(parents.get(i).second()))</span>
<span class="fc" id="L749">                    nextStack.push(parents.get(i));</span>
                }
<span class="fc bfc" id="L751" title="All 2 branches covered.">                if (currentDepth &gt;= startDepth &amp;&amp;</span>
<span class="pc bpc" id="L752" title="1 of 2 branches missed.">                    type.test(nextPair.first().toString()) &amp;&amp;</span>
<span class="fc bfc" id="L753" title="All 2 branches covered.">                    !returnedNodes.contains(nextPair.second())) {</span>
<span class="fc" id="L754">                  returnedNodes.add(nextPair.second());</span>
<span class="fc" id="L755">                  next = nextPair.second();</span>
<span class="fc" id="L756">                  relation = nextPair.first().toString();</span>
<span class="fc" id="L757">                  return;</span>
                }
<span class="fc" id="L759">              }</span>
              // didn't see anything at this depth, move to the next depth
<span class="fc" id="L761">              ++currentDepth;</span>
<span class="fc" id="L762">            }</span>
            // oh well, fell through with no results
<span class="fc" id="L764">            next = null;</span>
<span class="fc" id="L765">          }</span>
        };
    }

    // automatically generated by Eclipse
    private static final long serialVersionUID = 1L;
  };

  static private class EQUALS extends GraphRelation {
    EQUALS(String reln, String name) {
<span class="fc" id="L775">      super(&quot;==&quot;, reln, name);</span>
<span class="fc" id="L776">    }</span>

    @Override
    boolean satisfies(IndexedWord l1, IndexedWord l2, SemanticGraph sg) {
<span class="nc bnc" id="L780" title="All 2 branches missed.">      if (l1 == l2) {</span>
<span class="nc" id="L781">        return true;</span>
      }
<span class="nc" id="L783">      return false;</span>
    }

    @Override
    Iterator&lt;IndexedWord&gt; searchNodeIterator(final IndexedWord node, final SemanticGraph sg) {
<span class="fc" id="L788">      return new SearchNodeIterator() {</span>
        boolean alreadyIterated;

        @Override
        public void advance() {
<span class="pc bpc" id="L793" title="1 of 2 branches missed.">          if (node.equals(IndexedWord.NO_WORD)) {</span>
<span class="nc" id="L794">            next = null;</span>
<span class="nc" id="L795">            return;</span>
          }
<span class="fc bfc" id="L797" title="All 2 branches covered.">          if (alreadyIterated) {</span>
<span class="fc" id="L798">            next = null;</span>
<span class="fc" id="L799">            return;</span>
          }
<span class="fc" id="L801">          alreadyIterated = true;</span>
<span class="fc" id="L802">          next = node;</span>
<span class="fc" id="L803">          return;</span>
        }
      };
    }
  }

  static private abstract class SIBLING_RELATION extends GraphRelation {

    private static final long serialVersionUID = 1L;

    SIBLING_RELATION(String symbol, String reln, String name) {
<span class="fc" id="L814">      super(symbol, reln, name);</span>
<span class="fc" id="L815">    }</span>

    abstract boolean satisfiesOrder(IndexedWord l1, IndexedWord l2);

    @Override
    boolean satisfies(IndexedWord l1, IndexedWord l2, SemanticGraph sg) {
<span class="nc" id="L821">      IndexedWord parent = sg.getCommonAncestor(l1, l2);</span>
<span class="nc" id="L822">      Set&lt;IndexedWord&gt; l1Parents = sg.getParents(l1);</span>
<span class="nc bnc" id="L823" title="All 2 branches missed.">      if (parent != null</span>
<span class="nc bnc" id="L824" title="All 2 branches missed.">          &amp;&amp; l1Parents.contains(parent)</span>
<span class="nc bnc" id="L825" title="All 2 branches missed.">          &amp;&amp; satisfiesOrder(l1, l2)) {</span>
<span class="nc" id="L826">        return true;</span>
      }
<span class="nc" id="L828">      return false;</span>
    }

    @Override
    Iterator&lt;IndexedWord&gt; searchNodeIterator(final IndexedWord node, final SemanticGraph sg) {
<span class="fc" id="L833">      return new SearchNodeIterator() {</span>
        Iterator&lt;IndexedWord&gt; iterator;

        @Override
        public void advance() {
<span class="pc bpc" id="L838" title="1 of 2 branches missed.">          if (node.equals(IndexedWord.NO_WORD)) {</span>
<span class="nc" id="L839">            next = null;</span>
<span class="nc" id="L840">            return;</span>
          }

<span class="fc bfc" id="L843" title="All 2 branches covered.">          if (iterator == null) {</span>
<span class="fc" id="L844">            Set&lt;IndexedWord&gt; parents = sg.getParents(node);</span>
<span class="fc" id="L845">            Set&lt;IndexedWord&gt; neighbors = Generics.newIdentityHashSet();</span>
<span class="fc bfc" id="L846" title="All 2 branches covered.">            for (IndexedWord parent : parents) {</span>
<span class="fc" id="L847">              neighbors.addAll(sg.getChildren(parent));</span>
<span class="fc" id="L848">            }</span>
<span class="fc" id="L849">            iterator = neighbors.iterator();</span>
          }

<span class="fc bfc" id="L852" title="All 2 branches covered.">          while (iterator.hasNext()) {</span>
<span class="fc" id="L853">            IndexedWord word = iterator.next();</span>
<span class="fc bfc" id="L854" title="All 2 branches covered.">            if ( ! satisfiesOrder(node, word)) {</span>
<span class="fc" id="L855">              continue;</span>
            }
<span class="fc" id="L857">            this.next = word;</span>
<span class="fc" id="L858">            return;</span>
          }
<span class="fc" id="L860">          this.next = null;</span>
<span class="fc" id="L861">        }</span>
      };
    }

  }


  static private class RIGHT_IMMEDIATE_SIBLING extends SIBLING_RELATION {

    RIGHT_IMMEDIATE_SIBLING(String reln, String name) {
<span class="fc" id="L871">      super(&quot;$+&quot;, reln, name);</span>
<span class="fc" id="L872">    }</span>

    private static final long serialVersionUID = 1L;

    boolean satisfiesOrder(IndexedWord l1, IndexedWord l2) {
<span class="fc bfc" id="L877" title="All 2 branches covered.">      return (l1.index() == (l2.index() - 1));</span>
    }
  }

  static private class LEFT_IMMEDIATE_SIBLING extends SIBLING_RELATION {

    LEFT_IMMEDIATE_SIBLING(String reln, String name) {
<span class="fc" id="L884">      super(&quot;$-&quot;, reln, name);</span>
<span class="fc" id="L885">    }</span>

    private static final long serialVersionUID = 1L;

    boolean satisfiesOrder(IndexedWord l1, IndexedWord l2) {
<span class="fc bfc" id="L890" title="All 2 branches covered.">      return (l1.index() == (l2.index() + 1));</span>
    }
  }

  static private class RIGHT_SIBLING extends SIBLING_RELATION {

    RIGHT_SIBLING(String reln, String name) {
<span class="fc" id="L897">      super(&quot;$++&quot;, reln, name);</span>
<span class="fc" id="L898">    }</span>

    private static final long serialVersionUID = 1L;

    boolean satisfiesOrder(IndexedWord l1, IndexedWord l2) {
<span class="fc bfc" id="L903" title="All 2 branches covered.">      return (l1.index() &lt; l2.index());</span>
    }
  }

  static private class LEFT_SIBLING extends SIBLING_RELATION {

    LEFT_SIBLING(String reln, String name) {
<span class="fc" id="L910">      super(&quot;$--&quot;, reln, name);</span>
<span class="fc" id="L911">    }</span>

    private static final long serialVersionUID = 1L;

    boolean satisfiesOrder(IndexedWord l1, IndexedWord l2) {
<span class="fc bfc" id="L916" title="All 2 branches covered.">      return (l1.index() &gt; l2.index());</span>
    }
  }

  static private class ADJACENT_NODE extends GraphRelation {

    private static final long serialVersionUID = 1L;

    ADJACENT_NODE(String reln, String name) {
<span class="fc" id="L925">      super(&quot;.&quot;, reln, name);</span>
<span class="fc" id="L926">    }</span>


    @Override
    boolean satisfies(IndexedWord l1, IndexedWord l2, SemanticGraph sg) {
<span class="nc bnc" id="L931" title="All 2 branches missed.">      if (l1.index() == (l2.index() - 1)) {</span>
<span class="nc" id="L932">        return true;</span>
      }
<span class="nc" id="L934">      return false;</span>
    }

    @Override
    Iterator&lt;IndexedWord&gt; searchNodeIterator(final IndexedWord node, final SemanticGraph sg) {
<span class="fc" id="L939">      return new SearchNodeIterator() {</span>
        Iterator&lt;IndexedWord&gt; iterator;

        @Override
        public void advance() {
<span class="pc bpc" id="L944" title="1 of 2 branches missed.">          if (node.equals(IndexedWord.NO_WORD)) {</span>
<span class="nc" id="L945">            next = null;</span>
<span class="nc" id="L946">            return;</span>
          }

<span class="fc bfc" id="L949" title="All 2 branches covered.">          if (iterator == null) {</span>
<span class="fc" id="L950">            iterator = sg.vertexSet().iterator();</span>
          }

<span class="fc bfc" id="L953" title="All 2 branches covered.">          while (iterator.hasNext()) {</span>
<span class="fc" id="L954">            IndexedWord word = iterator.next();</span>
<span class="fc bfc" id="L955" title="All 2 branches covered.">            if (node.index() != (word.index() - 1)) {</span>
<span class="fc" id="L956">              continue;</span>
            }
<span class="fc" id="L958">            this.next = word;</span>
<span class="fc" id="L959">            return;</span>
          }
<span class="fc" id="L961">          this.next = null;</span>
<span class="fc" id="L962">        }</span>
      };
    }

  }


  // ============================================================================

  public static boolean isKnownRelation(String reln) {
<span class="fc bfc" id="L972" title="All 4 branches covered.">    return (reln.equals(&quot;&gt;&quot;) || reln.equals(&quot;&lt;&quot;) ||</span>
<span class="fc bfc" id="L973" title="All 4 branches covered.">            reln.equals(&quot;&gt;&gt;&quot;) || reln.equals(&quot;&lt;&lt;&quot;) ||</span>
<span class="fc bfc" id="L974" title="All 4 branches covered.">            reln.equals(&quot;@&quot;) || reln.equals(&quot;==&quot;) ||</span>
<span class="fc bfc" id="L975" title="All 4 branches covered.">            reln.equals(&quot;$+&quot;) || reln.equals(&quot;$++&quot;) ||</span>
<span class="fc bfc" id="L976" title="All 4 branches covered.">            reln.equals(&quot;$-&quot;) || reln.equals(&quot;$--&quot;) ||</span>
<span class="pc bpc" id="L977" title="1 of 2 branches missed.">            reln.equals(&quot;.&quot;));</span>
  }

  public static GraphRelation getRelation(String reln,
                                          String type,
                                          String name) throws ParseException {
<span class="pc bpc" id="L983" title="3 of 4 branches missed.">    if (reln == null &amp;&amp; type == null)</span>
<span class="nc" id="L984">      return null;</span>
<span class="pc bpc" id="L985" title="1 of 2 branches missed.">    if (!isKnownRelation(reln)) {</span>
<span class="nc" id="L986">      throw new ParseException(&quot;Unknown relation &quot; + reln);</span>
    }
<span class="pc bpc" id="L988" title="13 of 46 branches missed.">    switch (reln) {</span>
      case &quot;&gt;&quot;:
<span class="fc" id="L990">        return new GOVERNER(type, name);</span>
      case &quot;&lt;&quot;:
<span class="fc" id="L992">        return new DEPENDENT(type, name);</span>
      case &quot;&gt;&gt;&quot;:
<span class="fc" id="L994">        return new GRANDPARENT(type, name);</span>
      case &quot;&lt;&lt;&quot;:
<span class="fc" id="L996">        return new GRANDKID(type, name);</span>
      case &quot;==&quot;:
<span class="fc" id="L998">        return new EQUALS(type, name);</span>
      case &quot;$+&quot;:
<span class="fc" id="L1000">        return new RIGHT_IMMEDIATE_SIBLING(type, name);</span>
      case &quot;$-&quot;:
<span class="fc" id="L1002">        return new LEFT_IMMEDIATE_SIBLING(type, name);</span>
      case &quot;$++&quot;:
<span class="fc" id="L1004">        return new RIGHT_SIBLING(type, name);</span>
      case &quot;$--&quot;:
<span class="fc" id="L1006">        return new LEFT_SIBLING(type, name);</span>
      case &quot;.&quot;:
<span class="fc" id="L1008">        return new ADJACENT_NODE(type, name);</span>
      case &quot;@&quot;:
<span class="fc" id="L1010">        return new ALIGNMENT();</span>
      default:
//error
<span class="nc" id="L1013">        throw new ParseException(&quot;Relation &quot; + reln +</span>
            &quot; not handled by getRelation&quot;);
    }
  }

  public static GraphRelation getRelation(String reln,
                                          String type,
                                          int num,
                                          String name) throws ParseException {
<span class="pc bpc" id="L1022" title="3 of 4 branches missed.">    if (reln == null &amp;&amp; type == null)</span>
<span class="nc" id="L1023">      return null;</span>
<span class="pc bpc" id="L1024" title="1 of 2 branches missed.">    if (reln.equals(&quot;&gt;&gt;&quot;))</span>
<span class="fc" id="L1025">      return new LIMITED_GRANDPARENT(type, name, num, num);</span>
<span class="nc bnc" id="L1026" title="All 2 branches missed.">    else if (reln.equals(&quot;&lt;&lt;&quot;))</span>
<span class="nc" id="L1027">      return new LIMITED_GRANDKID(type, name, num, num);</span>
<span class="nc bnc" id="L1028" title="All 2 branches missed.">    else if (isKnownRelation(reln))</span>
<span class="nc" id="L1029">      throw new ParseException(&quot;Relation &quot; + reln +</span>
                               &quot; does not use numeric arguments&quot;);
    else //error
<span class="nc" id="L1032">      throw new ParseException(&quot;Unrecognized compound relation &quot; + reln + &quot; &quot;</span>
                               + type);
  }

  public static GraphRelation getRelation(String reln,
                                          String type,
                                          int num, int num2,
                                          String name) throws ParseException {
<span class="pc bpc" id="L1040" title="3 of 4 branches missed.">    if (reln == null &amp;&amp; type == null)</span>
<span class="nc" id="L1041">      return null;</span>
<span class="fc bfc" id="L1042" title="All 2 branches covered.">    if (reln.equals(&quot;&gt;&gt;&quot;))</span>
<span class="fc" id="L1043">      return new LIMITED_GRANDPARENT(type, name, num, num2);</span>
<span class="pc bpc" id="L1044" title="1 of 2 branches missed.">    else if (reln.equals(&quot;&lt;&lt;&quot;))</span>
<span class="fc" id="L1045">      return new LIMITED_GRANDKID(type, name, num, num2);</span>
<span class="nc bnc" id="L1046" title="All 2 branches missed.">    else if (isKnownRelation(reln))</span>
<span class="nc" id="L1047">      throw new ParseException(&quot;Relation &quot; + reln +</span>
                               &quot; does not use numeric arguments&quot;);
    else //error
<span class="nc" id="L1050">      throw new ParseException(&quot;Unrecognized compound relation &quot; + reln + &quot; &quot;</span>
                               + type);
  }

  @Override
  public int hashCode() {
<span class="nc" id="L1056">    return symbol.hashCode();</span>
  }

  @Override
  public boolean equals(Object o) {
<span class="pc bpc" id="L1061" title="1 of 2 branches missed.">    if (this == o) {</span>
<span class="nc" id="L1062">      return true;</span>
    }
<span class="pc bpc" id="L1064" title="1 of 2 branches missed.">    if (!(o instanceof GraphRelation)) {</span>
<span class="nc" id="L1065">      return false;</span>
    }

<span class="fc" id="L1068">    final GraphRelation relation = (GraphRelation) o;</span>

<span class="pc bpc" id="L1070" title="1 of 2 branches missed.">    if (!symbol.equals(relation.symbol) ||</span>
<span class="nc bnc" id="L1071" title="All 2 branches missed.">        !type.equals(relation.type)) {</span>
<span class="fc" id="L1072">      return false;</span>
    }

<span class="nc" id="L1075">    return true;</span>
  }

  /**
   * This abstract Iterator implements a NULL iterator, but by subclassing and
   * overriding advance and/or initialize, it is an efficient implementation.
   */
  static abstract class SearchNodeIterator implements Iterator&lt;IndexedWord&gt; {
<span class="fc" id="L1083">    public SearchNodeIterator() {</span>
<span class="fc" id="L1084">      initialize();</span>
<span class="fc" id="L1085">    }</span>

    /**
     * This is the next node to be returned by the iterator, or null if there
     * are no more items.
     */
<span class="fc" id="L1091">    IndexedWord next = null;</span>

    /**
     * Current relation string for next;
     */
<span class="fc" id="L1096">    String relation = null;</span>

    /**
     * This method must insure that next points to first item, or null if there
     * are no items.
     */
    void initialize() {
<span class="fc" id="L1103">      advance();</span>
<span class="fc" id="L1104">    }</span>

    /**
     * This method must insure that next points to next item, or null if there
     * are no more items.
     */
    void advance() {
<span class="fc" id="L1111">      next = null;</span>
<span class="fc" id="L1112">    }</span>

    public boolean hasNext() {
<span class="fc bfc" id="L1115" title="All 2 branches covered.">      return next != null;</span>
    }

    public IndexedWord next() {
<span class="pc bpc" id="L1119" title="1 of 2 branches missed.">      if (next == null) {</span>
<span class="nc" id="L1120">        return null;</span>
      }
<span class="fc" id="L1122">      IndexedWord ret = next;</span>
<span class="fc" id="L1123">      advance();</span>
<span class="fc" id="L1124">      return ret;</span>
    }

<span class="fc" id="L1127">    String getReln() {return relation;}</span>

    public void remove() {
<span class="nc" id="L1130">      throw new UnsupportedOperationException(&quot;SearchNodeIterator does not support remove().&quot;);</span>
    }
  }

  // Automatically generated by Eclipse
  private static final long serialVersionUID = -9128973950911993056L;
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>