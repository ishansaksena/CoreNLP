<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LinearClassifier.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.classify</a> &gt; <span class="el_source">LinearClassifier.java</span></div><h1>LinearClassifier.java</h1><pre class="source lang-java linenums">// Stanford Classifier - a multiclass maxent classifier
// LinearClassifier
// Copyright (c) 2003-2007 The Board of Trustees of
// The Leland Stanford Junior University. All Rights Reserved.
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
//
// For more information, bug reports, fixes, contact:
//    Christopher Manning
//    Dept of Computer Science, Gates 1A
//    Stanford CA 94305-9010
//    USA
//    Support/Questions: java-nlp-user@lists.stanford.edu
//    Licensing: java-nlp-support@lists.stanford.edu
//    http://www-nlp.stanford.edu/software/classifier.shtml

package edu.stanford.nlp.classify;

import edu.stanford.nlp.io.IOUtils;
import edu.stanford.nlp.ling.BasicDatum;
import edu.stanford.nlp.ling.Datum;
import edu.stanford.nlp.ling.RVFDatum;
import edu.stanford.nlp.util.*;
import edu.stanford.nlp.stats.ClassicCounter;
import edu.stanford.nlp.stats.Counter;
import edu.stanford.nlp.stats.Distribution;
import edu.stanford.nlp.stats.Counters;

import java.io.*;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.util.*;
import java.util.function.Function;

import edu.stanford.nlp.util.logging.Redwood;


/**
 * Implements a multiclass linear classifier. At classification time this
 * can be any generalized linear model classifier (such as a perceptron,
 * a maxent classifier (softmax logistic regression), or an SVM).
 *
 * @author Dan Klein
 * @author Jenny Finkel
 * @author Galen Andrew (converted to arrays and indices)
 * @author Christopher Manning (most of the printing options)
 * @author Eric Yeh (save to text file, new constructor w/thresholds)
 * @author Sarah Spikes (sdspikes@cs.stanford.edu) (Templatization)
 * @author {@literal nmramesh@cs.stanford.edu} {@link #weightsAsMapOfCounters()}
 * @author Angel Chang (Add functions to get top features, and number of features with weights above a certain threshold)
 *
 * @param &lt;L&gt; The type of the labels in the Classifier
 * @param &lt;F&gt; The type of the features in the Classifier
 */
<span class="pc bpc" id="L67" title="1 of 2 branches missed.">public class LinearClassifier&lt;L, F&gt; implements ProbabilisticClassifier&lt;L, F&gt;, RVFClassifier&lt;L, F&gt;  {</span>

  /** A logger for this class */
<span class="fc" id="L70">  private static final Redwood.RedwoodChannels logger = Redwood.channels(LinearClassifier.class);</span>

  /** Classifier weights. First index is the featureIndex value and second index is the labelIndex value. */
  private double[][] weights;
  private Index&lt;L&gt; labelIndex;
  private Index&lt;F&gt; featureIndex;
<span class="pc" id="L76">  public boolean intern = false;   // variable should be deleted when breaking serialization anyway....</span>
  private double[] thresholds; // = null;

  private static final long serialVersionUID = 8499574525453275255L;

  private static final int MAX_FEATURE_ALIGN_WIDTH = 50;

  public static final String TEXT_SERIALIZATION_DELIMITER = &quot;\t&quot;;


  @Override
  public Collection&lt;L&gt; labels() {
<span class="fc" id="L88">    return labelIndex.objectsList();</span>
  }

  public Collection&lt;F&gt; features() {
<span class="nc" id="L92">    return featureIndex.objectsList();</span>
  }

  public Index&lt;L&gt; labelIndex() {
<span class="nc" id="L96">    return labelIndex;</span>
  }

  public Index&lt;F&gt; featureIndex() {
<span class="nc" id="L100">    return featureIndex;</span>
  }

  private double weight(int iFeature, int iLabel) {
<span class="pc bpc" id="L104" title="1 of 2 branches missed.">    if (iFeature &lt; 0) {</span>
      //logger.info(&quot;feature not seen &quot;);
<span class="nc" id="L106">      return 0.0;</span>
    }
<span class="pc bpc" id="L108" title="2 of 4 branches missed.">    assert iFeature &lt; weights.length;</span>
<span class="pc bpc" id="L109" title="2 of 4 branches missed.">    assert iLabel &lt; weights[iFeature].length;</span>
<span class="fc" id="L110">    return weights[iFeature][iLabel];</span>
  }

  private double weight(F feature, int iLabel) {
<span class="nc" id="L114">    int f = featureIndex.indexOf(feature);</span>
<span class="nc" id="L115">    return weight(f, iLabel);</span>
  }

  public double weight(F feature, L label) {
<span class="nc" id="L119">    int f = featureIndex.indexOf(feature);</span>
<span class="nc" id="L120">    int iLabel = labelIndex.indexOf(label);</span>
<span class="nc" id="L121">    return weight(f, iLabel);</span>
  }

  /* --- obsolete method from before this class was rewritten using arrays
  public Counter scoresOf(Datum example) {
    Counter scores = new Counter();
    for (L l : labels()) {
      scores.setCount(l, scoreOf(example, l));
    }
    return scores;
  }
  --- */

  /** Construct a counter with keys the labels of the classifier and
   *  values the score (unnormalized log probability) of each class.
   */
  @Override
  public Counter&lt;L&gt; scoresOf(Datum&lt;L, F&gt; example) {
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">    if(example instanceof RVFDatum&lt;?, ?&gt;)return scoresOfRVFDatum((RVFDatum&lt;L,F&gt;)example);</span>
<span class="fc" id="L140">    Collection&lt;F&gt; feats = example.asFeatures();</span>
<span class="fc" id="L141">    int[] features = new int[feats.size()];</span>
<span class="fc" id="L142">    int i = 0;</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">    for (F f : feats) {</span>
<span class="fc" id="L144">      int index = featureIndex.indexOf(f);</span>
<span class="pc bpc" id="L145" title="1 of 2 branches missed.">      if (index &gt;= 0) {</span>
<span class="fc" id="L146">        features[i++] = index;</span>
      // } else {
        //logger.info(&quot;FEATURE LESS THAN ZERO: &quot; + f);
      }
<span class="fc" id="L150">    }</span>
<span class="fc" id="L151">    int[] activeFeatures = new int[i];</span>
<span class="fc" id="L152">    synchronized (System.class) {</span>
<span class="fc" id="L153">      System.arraycopy(features, 0, activeFeatures, 0, i);</span>
<span class="pc" id="L154">    }</span>
<span class="fc" id="L155">    Counter&lt;L&gt; scores = new ClassicCounter&lt;&gt;();</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">    for (L lab : labels()) {</span>
<span class="fc" id="L157">      scores.setCount(lab, scoreOf(activeFeatures, lab));</span>
<span class="fc" id="L158">    }</span>
<span class="fc" id="L159">    return scores;</span>
  }

  /** Given a datum's features, construct a counter with keys
   *  the labels and values the score (unnormalized log probability)
   *  for each class.
   */
  public Counter&lt;L&gt; scoresOf(int[] features) {
<span class="nc" id="L167">    Counter&lt;L&gt; scores = new ClassicCounter&lt;&gt;();</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">    for (L label : labels())</span>
<span class="nc" id="L169">      scores.setCount(label, scoreOf(features, label));</span>
<span class="nc" id="L170">    return scores;</span>
  }

  /** Returns of the score of the Datum for the specified label.
   *  Ignores the true label of the Datum.
   */
  public double scoreOf(Datum&lt;L, F&gt; example, L label) {
<span class="nc bnc" id="L177" title="All 2 branches missed.">    if (example instanceof RVFDatum&lt;?, ?&gt;) {</span>
<span class="nc" id="L178">      return scoreOfRVFDatum((RVFDatum&lt;L,F&gt;)example, label);</span>
    }
<span class="nc" id="L180">    int iLabel = labelIndex.indexOf(label);</span>
<span class="nc" id="L181">    double score = 0.0;</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">    for (F f : example.asFeatures()) {</span>
<span class="nc" id="L183">      score += weight(f, iLabel);</span>
<span class="nc" id="L184">    }</span>
<span class="nc" id="L185">    return score + thresholds[iLabel];</span>
  }

  /** Construct a counter with keys the labels of the classifier and
   *  values the score (unnormalized log probability) of each class
   *  for an RVFDatum.
   */
  @Override
  @Deprecated
  public Counter&lt;L&gt; scoresOf(RVFDatum&lt;L, F&gt; example) {
<span class="nc" id="L195">    Counter&lt;L&gt; scores = new ClassicCounter&lt;&gt;();</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">    for (L l : labels()) {</span>
<span class="nc" id="L197">      scores.setCount(l, scoreOfRVFDatum(example, l));</span>
<span class="nc" id="L198">    }</span>
    //System.out.println(&quot;Scores are: &quot; + scores + &quot;   (gold: &quot; + example.label() + &quot;)&quot;);
<span class="nc" id="L200">    return scores;</span>
  }

  /** Construct a counter with keys the labels of the classifier and
   *  values the score (unnormalized log probability) of each class
   *  for an RVFDatum.
   */
  private Counter&lt;L&gt; scoresOfRVFDatum(RVFDatum&lt;L, F&gt; example) {
<span class="nc" id="L208">    Counter&lt;L&gt; scores = new ClassicCounter&lt;&gt;();</span>
    // Index the features in the datum
<span class="nc" id="L210">    Counter&lt;F&gt; asCounter = example.asFeaturesCounter();</span>
<span class="nc" id="L211">    Counter&lt;Integer&gt; asIndexedCounter = new ClassicCounter&lt;&gt;(asCounter.size());</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">    for (Map.Entry&lt;F, Double&gt; entry : asCounter.entrySet()) {</span>
<span class="nc" id="L213">      asIndexedCounter.setCount(featureIndex.indexOf(entry.getKey()), entry.getValue());</span>
<span class="nc" id="L214">    }</span>
    // Set the scores appropriately
<span class="nc bnc" id="L216" title="All 2 branches missed.">    for (L l : labels()) {</span>
<span class="nc" id="L217">      scores.setCount(l, scoreOfRVFDatum(asIndexedCounter, l));</span>
<span class="nc" id="L218">    }</span>
    //System.out.println(&quot;Scores are: &quot; + scores + &quot;   (gold: &quot; + example.label() + &quot;)&quot;);
<span class="nc" id="L220">    return scores;</span>
  }

  /** Returns the score of the RVFDatum for the specified label.
   *  Ignores the true label of the RVFDatum.
   *
   *  @param example Used to get the observed x value. Its label is ignored.
   *  @param label The label y that the observed value is scored with.
   *  @return A linear classifier score
   */
  private double scoreOfRVFDatum(RVFDatum&lt;L, F&gt; example, L label) {
<span class="nc" id="L231">    int iLabel = labelIndex.indexOf(label);</span>
<span class="nc" id="L232">    double score = 0.0;</span>
<span class="nc" id="L233">    Counter&lt;F&gt; features = example.asFeaturesCounter();</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">    for (Map.Entry&lt;F, Double&gt; entry : features.entrySet()) {</span>
<span class="nc" id="L235">      score += weight(entry.getKey(), iLabel) * entry.getValue();</span>
<span class="nc" id="L236">    }</span>
<span class="nc" id="L237">    return score + thresholds[iLabel];</span>
  }

  /** Returns the score of the RVFDatum for the specified label.
   *  Ignores the true label of the RVFDatum.
   */
  private double scoreOfRVFDatum(Counter&lt;Integer&gt; features, L label) {
<span class="nc" id="L244">    int iLabel = labelIndex.indexOf(label);</span>
<span class="nc" id="L245">    double score = 0.0;</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">    for (Map.Entry&lt;Integer, Double&gt; entry : features.entrySet()) {</span>
<span class="nc" id="L247">      score += weight(entry.getKey(), iLabel) * entry.getValue();</span>
<span class="nc" id="L248">    }</span>
<span class="nc" id="L249">    return score + thresholds[iLabel];</span>
  }


  /** Returns of the score of the Datum as internalized features for the
   *  specified label. Ignores the true label of the Datum.
   *  Doesn't consider a value for each feature.
   */
  private double scoreOf(int[] feats, L label) {
<span class="fc" id="L258">    int iLabel = labelIndex.indexOf(label);</span>
<span class="pc bpc" id="L259" title="2 of 4 branches missed.">    assert iLabel &gt;= 0;</span>
<span class="fc" id="L260">    double score = 0.0;</span>
<span class="fc bfc" id="L261" title="All 2 branches covered.">    for (int feat : feats) {</span>
<span class="fc" id="L262">      score += weight(feat, iLabel);</span>
    }
<span class="fc" id="L264">    return score + thresholds[iLabel];</span>
  }


  /**
   * Returns a counter mapping from each class name to the probability of
   * that class for a certain example.
   * Looking at the the sum of each count v, should be 1.0.
   */
  @Override
  public Counter&lt;L&gt; probabilityOf(Datum&lt;L, F&gt; example) {
<span class="pc bpc" id="L275" title="1 of 2 branches missed.">    if(example instanceof RVFDatum&lt;?, ?&gt;)return probabilityOfRVFDatum((RVFDatum&lt;L,F&gt;)example);</span>
<span class="fc" id="L276">    Counter&lt;L&gt; scores = logProbabilityOf(example);</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">    for (L label : scores.keySet()) {</span>
<span class="fc" id="L278">      scores.setCount(label, Math.exp(scores.getCount(label)));</span>
<span class="fc" id="L279">    }</span>
<span class="fc" id="L280">    return scores;</span>
  }

  /**
   * Returns a counter mapping from each class name to the probability of
   * that class for a certain example.
   * Looking at the the sum of each count v, should be 1.0.
   */
  private Counter&lt;L&gt; probabilityOfRVFDatum(RVFDatum&lt;L, F&gt; example) {
    // NB: this duplicate method is needed so it calls the scoresOf method
    // with a RVFDatum signature
<span class="nc" id="L291">    Counter&lt;L&gt; scores = logProbabilityOfRVFDatum(example);</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">    for (L label : scores.keySet()) {</span>
<span class="nc" id="L293">      scores.setCount(label, Math.exp(scores.getCount(label)));</span>
<span class="nc" id="L294">    }</span>
<span class="nc" id="L295">    return scores;</span>
  }

  /**
   * Returns a counter mapping from each class name to the probability of
   * that class for a certain example.
   * Looking at the the sum of each count v, should be 1.0.
   */
  @Deprecated
  public Counter&lt;L&gt; probabilityOf(RVFDatum&lt;L, F&gt; example) {
    // NB: this duplicate method is needed so it calls the scoresOf method
    // with a RVFDatum signature
<span class="nc" id="L307">    Counter&lt;L&gt; scores = logProbabilityOf(example);</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">    for (L label : scores.keySet()) {</span>
<span class="nc" id="L309">      scores.setCount(label, Math.exp(scores.getCount(label)));</span>
<span class="nc" id="L310">    }</span>
<span class="nc" id="L311">    return scores;</span>
  }

  /**
   * Returns a counter mapping from each class name to the log probability of
   * that class for a certain example.
   * Looking at the the sum of e^v for each count v, should be 1.0.
   */
  @Override
  public Counter&lt;L&gt; logProbabilityOf(Datum&lt;L, F&gt; example) {
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">    if(example instanceof RVFDatum&lt;?, ?&gt;)return logProbabilityOfRVFDatum((RVFDatum&lt;L,F&gt;)example);</span>
<span class="fc" id="L322">    Counter&lt;L&gt; scores = scoresOf(example);</span>
<span class="fc" id="L323">    Counters.logNormalizeInPlace(scores);</span>
<span class="fc" id="L324">    return scores;</span>
  }

  /**
   * Given a datum's features, returns a counter mapping from each
   * class name to the log probability of that class.
   * Looking at the the sum of e^v for each count v, should be 1.
   */
  public Counter&lt;L&gt; logProbabilityOf(int[] features) {
<span class="nc" id="L333">    Counter&lt;L&gt; scores = scoresOf(features);</span>
<span class="nc" id="L334">    Counters.logNormalizeInPlace(scores);</span>
<span class="nc" id="L335">    return scores;</span>
  }

  public Counter&lt;L&gt; probabilityOf(int [] features) {
<span class="nc" id="L339">    Counter&lt;L&gt; scores = logProbabilityOf(features);</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">    for (L label : scores.keySet()) {</span>
<span class="nc" id="L341">      scores.setCount(label, Math.exp(scores.getCount(label)));</span>
<span class="nc" id="L342">    }</span>
<span class="nc" id="L343">    return scores;</span>
  }

  /**
   * Returns a counter for the log probability of each of the classes
   * looking at the the sum of e^v for each count v, should be 1
   */
  private Counter&lt;L&gt; logProbabilityOfRVFDatum(RVFDatum&lt;L, F&gt; example) {
    // NB: this duplicate method is needed so it calls the scoresOf method
    // with an RVFDatum signature!!  Don't remove it!
    // JLS: type resolution of method parameters is static
<span class="nc" id="L354">    Counter&lt;L&gt; scores = scoresOfRVFDatum(example);</span>
<span class="nc" id="L355">    Counters.logNormalizeInPlace(scores);</span>
<span class="nc" id="L356">    return scores;</span>
  }

  /**
   * Returns a counter for the log probability of each of the classes.
   * Looking at the the sum of e^v for each count v, should give 1.
   */
  @Deprecated
  public Counter&lt;L&gt; logProbabilityOf(RVFDatum&lt;L, F&gt; example) {
    // NB: this duplicate method is needed so it calls the scoresOf method
    // with an RVFDatum signature!!  Don't remove it!
    // JLS: type resolution of method parameters is static
<span class="nc" id="L368">    Counter&lt;L&gt; scores = scoresOf(example);</span>
<span class="nc" id="L369">    Counters.logNormalizeInPlace(scores);</span>
<span class="nc" id="L370">    return scores;</span>
  }

  /**
   * Returns indices of labels
   * @param labels - Set of labels to get indices
   * @return Set of indices
   */
  protected Set&lt;Integer&gt; getLabelIndices(Set&lt;L&gt; labels) {
<span class="nc" id="L379">    Set&lt;Integer&gt; iLabels = Generics.newHashSet();</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">    for (L label:labels) {</span>
<span class="nc" id="L381">      int iLabel = labelIndex.indexOf(label);</span>
<span class="nc" id="L382">      iLabels.add(iLabel);</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">      if (iLabel &lt; 0) throw new IllegalArgumentException(&quot;Unknown label &quot; + label);</span>
<span class="nc" id="L384">    }</span>
<span class="nc" id="L385">    return iLabels;</span>
  }

  /**
   * Returns number of features with weight above a certain threshold
   * (across all labels).
   *
   * @param threshold  Threshold above which we will count the feature
   * @param useMagnitude Whether the notion of &quot;large&quot; should ignore
   *                     the sign of the feature weight.
   * @return number of features satisfying the specified conditions
   */
  public int getFeatureCount(double threshold, boolean useMagnitude)
  {
<span class="nc" id="L399">    int n = 0;</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">    for (double[] weightArray : weights) {</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">      for (double weight : weightArray) {</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">        double thisWeight = (useMagnitude) ? Math.abs(weight) : weight;</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">        if (thisWeight &gt; threshold) {</span>
<span class="nc" id="L404">          n++;</span>
        }
      }
    }
<span class="nc" id="L408">    return n;</span>
  }

  /**
   * Returns number of features with weight above a certain threshold.
   *
   * @param labels Set of labels we care about when counting features
   *               Use null to get counts across all labels
   * @param threshold  Threshold above which we will count the feature
   * @param useMagnitude Whether the notion of &quot;large&quot; should ignore
   *                     the sign of the feature weight.
   * @return number of features satisfying the specified conditions
   */
  public int getFeatureCount(Set&lt;L&gt; labels, double threshold, boolean useMagnitude) {
<span class="nc bnc" id="L422" title="All 2 branches missed.">    if (labels != null) {</span>
<span class="nc" id="L423">      Set&lt;Integer&gt; iLabels = getLabelIndices(labels);</span>
<span class="nc" id="L424">      return getFeatureCountLabelIndices(iLabels, threshold, useMagnitude);</span>
    } else {
<span class="nc" id="L426">      return getFeatureCount(threshold, useMagnitude);</span>
    }
  }

  /**
   * Returns number of features with weight above a certain threshold.
   *
   * @param iLabels Set of label indices we care about when counting features
   *                Use null to get counts across all labels
   * @param threshold  Threshold above which we will count the feature
   * @param useMagnitude Whether the notion of &quot;large&quot; should ignore
   *                     the sign of the feature weight.
   * @return number of features satisfying the specified conditions
   */
  protected int getFeatureCountLabelIndices(Set&lt;Integer&gt; iLabels, double threshold, boolean useMagnitude)
  {
<span class="nc" id="L442">    int n = 0;</span>
<span class="nc bnc" id="L443" title="All 2 branches missed.">    for (double[] weightArray : weights) {</span>
<span class="nc bnc" id="L444" title="All 2 branches missed.">      for (int labIndex : iLabels) {</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">        double thisWeight = (useMagnitude) ? Math.abs(weightArray[labIndex]) : weightArray[labIndex];</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">        if (thisWeight &gt; threshold) {</span>
<span class="nc" id="L447">          n++;</span>
        }
<span class="nc" id="L449">      }</span>
    }
<span class="nc" id="L451">    return n;</span>
  }

  /**
   * Returns list of top features with weight above a certain threshold
   * (list is descending and across all labels).
   *
   * @param threshold  Threshold above which we will count the feature
   * @param useMagnitude Whether the notion of &quot;large&quot; should ignore
   *                     the sign of the feature weight.
   * @param numFeatures  How many top features to return (-1 for unlimited)
   * @return List of triples indicating feature, label, weight
   */
  public List&lt;Triple&lt;F,L,Double&gt;&gt; getTopFeatures(double threshold, boolean useMagnitude, int numFeatures) {
<span class="nc" id="L465">    return getTopFeatures(null, threshold, useMagnitude, numFeatures, true);</span>
  }

  /**
   * Returns list of top features with weight above a certain threshold
   * @param labels Set of labels we care about when getting features
   *               Use null to get features across all labels
   * @param threshold  Threshold above which we will count the feature
   * @param useMagnitude Whether the notion of &quot;large&quot; should ignore
   *                     the sign of the feature weight.
   * @param numFeatures  How many top features to return (-1 for unlimited)
   * @param descending Return weights in descending order
   * @return List of triples indicating feature, label, weight
   */
  public List&lt;Triple&lt;F,L,Double&gt;&gt; getTopFeatures(Set&lt;L&gt; labels,
                                                 double threshold, boolean useMagnitude, int numFeatures,
                                                 boolean descending) {
<span class="nc bnc" id="L482" title="All 2 branches missed.">    if (labels != null) {</span>
<span class="nc" id="L483">      Set&lt;Integer&gt; iLabels = getLabelIndices(labels);</span>
<span class="nc" id="L484">      return getTopFeaturesLabelIndices(iLabels, threshold, useMagnitude, numFeatures, descending);</span>
    } else {
<span class="nc" id="L486">      return getTopFeaturesLabelIndices(null, threshold, useMagnitude, numFeatures, descending);</span>
    }
  }

  /**
   * Returns list of top features with weight above a certain threshold
   * @param iLabels Set of label indices we care about when getting features
   *                Use null to get features across all labels
   * @param threshold  Threshold above which we will count the feature
   * @param useMagnitude Whether the notion of &quot;large&quot; should ignore
   *                     the sign of the feature weight.
   * @param numFeatures  How many top features to return (-1 for unlimited)
   * @param descending Return weights in descending order
   * @return List of triples indicating feature, label, weight
   */
  protected List&lt;Triple&lt;F,L,Double&gt;&gt; getTopFeaturesLabelIndices(Set&lt;Integer&gt; iLabels,
                                                 double threshold, boolean useMagnitude, int numFeatures,
                                                 boolean descending) {
<span class="nc" id="L504">    edu.stanford.nlp.util.PriorityQueue&lt;Pair&lt;Integer,Integer&gt;&gt; biggestKeys =</span>
            new FixedPrioritiesPriorityQueue&lt;&gt;();

    // locate biggest keys
<span class="nc bnc" id="L508" title="All 2 branches missed.">    for (int feat = 0; feat &lt; weights.length; feat++) {</span>
<span class="nc bnc" id="L509" title="All 2 branches missed.">      for (int lab = 0; lab &lt; weights[feat].length; lab++) {</span>
<span class="nc bnc" id="L510" title="All 4 branches missed.">        if (iLabels != null &amp;&amp; !iLabels.contains(lab)) {</span>
<span class="nc" id="L511">          continue;</span>
        }
        double thisWeight;
<span class="nc bnc" id="L514" title="All 2 branches missed.">        if (useMagnitude) {</span>
<span class="nc" id="L515">          thisWeight = Math.abs(weights[feat][lab]);</span>
        } else {
<span class="nc" id="L517">          thisWeight = weights[feat][lab];</span>
        }

<span class="nc bnc" id="L520" title="All 2 branches missed.">        if (thisWeight &gt; threshold) {</span>
          // reverse the weight, so get smallest first
<span class="nc" id="L522">          thisWeight = -thisWeight;</span>
<span class="nc bnc" id="L523" title="All 2 branches missed.">          if (biggestKeys.size() == numFeatures) {</span>
            // have enough features, add only if bigger
<span class="nc" id="L525">            double lowest = biggestKeys.getPriority();</span>
<span class="nc bnc" id="L526" title="All 2 branches missed.">            if (thisWeight &lt; lowest) {</span>
              // remove smallest
<span class="nc" id="L528">              biggestKeys.removeFirst();</span>
<span class="nc" id="L529">              biggestKeys.add(new Pair&lt;&gt;(feat, lab), thisWeight);</span>
            }
<span class="nc" id="L531">          } else {</span>
            // always add it if don't have enough features yet
<span class="nc" id="L533">            biggestKeys.add(new Pair&lt;&gt;(feat, lab), thisWeight);</span>
          }
        }
      }
    }

<span class="nc" id="L539">    List&lt;Triple&lt;F,L,Double&gt;&gt; topFeatures = new ArrayList&lt;&gt;(biggestKeys.size());</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">    while (!biggestKeys.isEmpty()) {</span>
<span class="nc" id="L541">      Pair&lt;Integer,Integer&gt; p = biggestKeys.removeFirst();</span>
<span class="nc" id="L542">      double weight = weights[p.first()][p.second()];</span>
<span class="nc" id="L543">      F feat = featureIndex.get(p.first());</span>
<span class="nc" id="L544">      L label = labelIndex.get(p.second());</span>
<span class="nc" id="L545">      topFeatures.add(new Triple&lt;&gt;(feat, label, weight));</span>
<span class="nc" id="L546">    }</span>
<span class="nc bnc" id="L547" title="All 2 branches missed.">    if (descending) {</span>
<span class="nc" id="L548">      Collections.reverse(topFeatures);</span>
    }
<span class="nc" id="L550">    return topFeatures;</span>
  }

  /**
   * Returns string representation of a list of top features
   * @param topFeatures List of triples indicating feature, label, weight
   * @return String representation of the list of features
   */
  public String topFeaturesToString(List&lt;Triple&lt;F,L,Double&gt;&gt; topFeatures)
  {
    // find longest key length (for pretty printing) with a limit
<span class="nc" id="L561">    int maxLeng = 0;</span>
<span class="nc bnc" id="L562" title="All 2 branches missed.">    for (Triple&lt;F,L,Double&gt; t : topFeatures) {</span>
<span class="nc" id="L563">      String key = &quot;(&quot; + t.first + &quot;,&quot; + t.second + &quot;)&quot;;</span>
<span class="nc" id="L564">      int leng = key.length();</span>
<span class="nc bnc" id="L565" title="All 2 branches missed.">      if (leng &gt; maxLeng) {</span>
<span class="nc" id="L566">        maxLeng = leng;</span>
      }
<span class="nc" id="L568">    }</span>
<span class="nc" id="L569">    maxLeng = Math.min(64, maxLeng);</span>

    // set up pretty printing of weights
<span class="nc" id="L572">    NumberFormat nf = NumberFormat.getNumberInstance();</span>
<span class="nc" id="L573">    nf.setMinimumFractionDigits(4);</span>
<span class="nc" id="L574">    nf.setMaximumFractionDigits(4);</span>
<span class="nc bnc" id="L575" title="All 2 branches missed.">    if (nf instanceof DecimalFormat) {</span>
<span class="nc" id="L576">      ((DecimalFormat) nf).setPositivePrefix(&quot; &quot;);</span>
    }

    //print high weight features to a String
<span class="nc" id="L580">    StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L581" title="All 2 branches missed.">    for (Triple&lt;F,L,Double&gt; t : topFeatures) {</span>
<span class="nc" id="L582">      String key = &quot;(&quot; + t.first + &quot;,&quot; + t.second + &quot;)&quot;;</span>
<span class="nc" id="L583">      sb.append(StringUtils.pad(key, maxLeng));</span>
<span class="nc" id="L584">      sb.append(&quot; &quot;);</span>
<span class="nc" id="L585">      double cnt = t.third();</span>
<span class="nc bnc" id="L586" title="All 2 branches missed.">      if (Double.isInfinite(cnt)) {</span>
<span class="nc" id="L587">        sb.append(cnt);</span>
      } else {
<span class="nc" id="L589">        sb.append(nf.format(cnt));</span>
      }
<span class="nc" id="L591">      sb.append(&quot;\n&quot;);</span>
<span class="nc" id="L592">    }</span>
<span class="nc" id="L593">    return sb.toString();</span>
  }

  /** Return a String that prints features with large weights.
   *
   * @param useMagnitude Whether the notion of &quot;large&quot; should ignore
   *                     the sign of the feature weight.
   * @param numFeatures  How many top features to print
   * @param printDescending Print weights in descending order
   * @return The String representation of features with large weights
   */
  public String toBiggestWeightFeaturesString(boolean useMagnitude,
      int numFeatures,
      boolean printDescending) {
    // this used to try to use a TreeSet, but that was WRONG....
<span class="nc" id="L608">    edu.stanford.nlp.util.PriorityQueue&lt;Pair&lt;Integer,Integer&gt;&gt; biggestKeys =</span>
            new FixedPrioritiesPriorityQueue&lt;&gt;();

    // locate biggest keys
<span class="nc bnc" id="L612" title="All 2 branches missed.">    for (int feat = 0; feat &lt; weights.length; feat++) {</span>
<span class="nc bnc" id="L613" title="All 2 branches missed.">      for (int lab = 0; lab &lt; weights[feat].length; lab++) {</span>
        double thisWeight;
        // reverse the weight, so get smallest first
<span class="nc bnc" id="L616" title="All 2 branches missed.">        if (useMagnitude) {</span>
<span class="nc" id="L617">          thisWeight = -Math.abs(weights[feat][lab]);</span>
        } else {
<span class="nc" id="L619">          thisWeight = -weights[feat][lab];</span>
        }
<span class="nc bnc" id="L621" title="All 2 branches missed.">        if (biggestKeys.size() == numFeatures) {</span>
          // have enough features, add only if bigger
<span class="nc" id="L623">          double lowest = biggestKeys.getPriority();</span>
<span class="nc bnc" id="L624" title="All 2 branches missed.">          if (thisWeight &lt; lowest) {</span>
            // remove smallest
<span class="nc" id="L626">            biggestKeys.removeFirst();</span>
<span class="nc" id="L627">            biggestKeys.add(new Pair&lt;&gt;(feat, lab), thisWeight);</span>
          }
<span class="nc" id="L629">        } else {</span>
          // always add it if don't have enough features yet
<span class="nc" id="L631">          biggestKeys.add(new Pair&lt;&gt;(feat, lab), thisWeight);</span>
        }
      }
    }

    // Put in List either reversed or not
    // (Note: can't repeatedly iterate over PriorityQueue.)
<span class="nc" id="L638">    int actualSize = biggestKeys.size();</span>
<span class="nc" id="L639">    Pair&lt;Integer, Integer&gt;[] bigArray = ErasureUtils.mkTArray(Pair.class, actualSize);</span>
    // logger.info(&quot;biggestKeys is &quot; + biggestKeys);
<span class="nc bnc" id="L641" title="All 2 branches missed.">    if (printDescending) {</span>
<span class="nc bnc" id="L642" title="All 2 branches missed.">      for (int j = actualSize - 1; j &gt;= 0; j--) {</span>
<span class="nc" id="L643">        bigArray[j] = biggestKeys.removeFirst();</span>
      }
    } else {
<span class="nc bnc" id="L646" title="All 2 branches missed.">      for (int j = 0; j &lt; actualSize; j--) {</span>
<span class="nc" id="L647">        bigArray[j] = biggestKeys.removeFirst();</span>
      }
    }
<span class="nc" id="L650">    List&lt;Pair&lt;Integer, Integer&gt;&gt; bigColl = Arrays.asList(bigArray);</span>
    // logger.info(&quot;bigColl is &quot; + bigColl);

    // find longest key length (for pretty printing) with a limit
<span class="nc" id="L654">    int maxLeng = 0;</span>
<span class="nc bnc" id="L655" title="All 2 branches missed.">    for (Pair&lt;Integer,Integer&gt; p : bigColl) {</span>
<span class="nc" id="L656">      String key = &quot;(&quot; + featureIndex.get(p.first) + &quot;,&quot; + labelIndex.get(p.second) + &quot;)&quot;;</span>
<span class="nc" id="L657">      int leng = key.length();</span>
<span class="nc bnc" id="L658" title="All 2 branches missed.">      if (leng &gt; maxLeng) {</span>
<span class="nc" id="L659">        maxLeng = leng;</span>
      }
<span class="nc" id="L661">    }</span>
<span class="nc" id="L662">    maxLeng = Math.min(64, maxLeng);</span>

    // set up pretty printing of weights
<span class="nc" id="L665">    NumberFormat nf = NumberFormat.getNumberInstance();</span>
<span class="nc" id="L666">    nf.setMinimumFractionDigits(4);</span>
<span class="nc" id="L667">    nf.setMaximumFractionDigits(4);</span>
<span class="nc bnc" id="L668" title="All 2 branches missed.">    if (nf instanceof DecimalFormat) {</span>
<span class="nc" id="L669">      ((DecimalFormat) nf).setPositivePrefix(&quot; &quot;);</span>
    }

    //print high weight features to a String
<span class="nc" id="L673">    StringBuilder sb = new StringBuilder(&quot;LinearClassifier [printing top &quot; + numFeatures + &quot; features]\n&quot;);</span>
<span class="nc bnc" id="L674" title="All 2 branches missed.">    for (Pair&lt;Integer, Integer&gt; p : bigColl) {</span>
<span class="nc" id="L675">      String key = &quot;(&quot; + featureIndex.get(p.first) + &quot;,&quot; + labelIndex.get(p.second) + &quot;)&quot;;</span>
<span class="nc" id="L676">      sb.append(StringUtils.pad(key, maxLeng));</span>
<span class="nc" id="L677">      sb.append(&quot; &quot;);</span>
<span class="nc" id="L678">      double cnt = weights[p.first][p.second];</span>
<span class="nc bnc" id="L679" title="All 2 branches missed.">      if (Double.isInfinite(cnt)) {</span>
<span class="nc" id="L680">        sb.append(cnt);</span>
      } else {
<span class="nc" id="L682">        sb.append(nf.format(cnt));</span>
      }
<span class="nc" id="L684">      sb.append(&quot;\n&quot;);</span>
<span class="nc" id="L685">    }</span>
<span class="nc" id="L686">    return sb.toString();</span>
  }

  /**
   * Similar to histogram but exact values of the weights
   * to see whether there are many equal weights.
   *
   * @return A human readable string about the classifier distribution.
   */
  public String toDistributionString(int threshold) {
<span class="nc" id="L696">    Counter&lt;Double&gt; weightCounts = new ClassicCounter&lt;&gt;();</span>
<span class="nc" id="L697">    StringBuilder s = new StringBuilder();</span>
<span class="nc" id="L698">    s.append(&quot;Total number of weights: &quot;).append(totalSize());</span>
<span class="nc bnc" id="L699" title="All 2 branches missed.">    for (double[] weightArray : weights) {</span>
<span class="nc bnc" id="L700" title="All 2 branches missed.">      for (double weight : weightArray) {</span>
<span class="nc" id="L701">        weightCounts.incrementCount(weight);</span>
      }
    }

<span class="nc" id="L705">    s.append(&quot;Counts of weights\n&quot;);</span>
<span class="nc" id="L706">    Set&lt;Double&gt; keys = Counters.keysAbove(weightCounts, threshold);</span>
<span class="nc" id="L707">    s.append(keys.size()).append(&quot; keys occur more than &quot;).append(threshold).append(&quot; times &quot;);</span>
<span class="nc" id="L708">    return s.toString();</span>
  }

  public int totalSize() {
<span class="nc" id="L712">    return labelIndex.size() * featureIndex.size();</span>
  }

  public String toHistogramString() {
    // big classifiers
<span class="nc" id="L717">    double[][] hist = new double[3][202];</span>
<span class="nc" id="L718">    Object[][] histEg = new Object[3][202];</span>
<span class="nc" id="L719">    int num = 0;</span>
<span class="nc" id="L720">    int pos = 0;</span>
<span class="nc" id="L721">    int neg = 0;</span>
<span class="nc" id="L722">    int zero = 0;</span>
<span class="nc" id="L723">    double total = 0.0;</span>
<span class="nc" id="L724">    double x2total = 0.0;</span>
<span class="nc" id="L725">    double max = 0.0, min = 0.0;</span>
<span class="nc bnc" id="L726" title="All 2 branches missed.">    for (int f = 0; f &lt; weights.length; f++) {</span>
<span class="nc bnc" id="L727" title="All 2 branches missed.">      for (int l = 0; l &lt; weights[f].length; l++) {</span>
<span class="nc" id="L728">        Pair&lt;F, L&gt; feat = new Pair&lt;&gt;(featureIndex.get(f), labelIndex.get(l));</span>
<span class="nc" id="L729">        num++;</span>
<span class="nc" id="L730">        double wt = weights[f][l];</span>
<span class="nc" id="L731">        total += wt;</span>
<span class="nc" id="L732">        x2total += wt * wt;</span>
<span class="nc bnc" id="L733" title="All 2 branches missed.">        if (wt &gt; max) {</span>
<span class="nc" id="L734">          max = wt;</span>
        }
<span class="nc bnc" id="L736" title="All 2 branches missed.">        if (wt &lt; min) {</span>
<span class="nc" id="L737">          min = wt;</span>
        }
<span class="nc bnc" id="L739" title="All 2 branches missed.">        if (wt &lt; 0.0) {</span>
<span class="nc" id="L740">          neg++;</span>
<span class="nc bnc" id="L741" title="All 2 branches missed.">        } else if (wt &gt; 0.0) {</span>
<span class="nc" id="L742">          pos++;</span>
        } else {
<span class="nc" id="L744">          zero++;</span>
        }
        int index;
<span class="nc" id="L747">        index = bucketizeValue(wt);</span>
<span class="nc" id="L748">        hist[0][index]++;</span>
<span class="nc bnc" id="L749" title="All 2 branches missed.">        if (histEg[0][index] == null) {</span>
<span class="nc" id="L750">          histEg[0][index] = feat;</span>
        }
<span class="nc bnc" id="L752" title="All 4 branches missed.">        if (wt &lt; 0.1 &amp;&amp; wt &gt;= -0.1) {</span>
<span class="nc" id="L753">          index = bucketizeValue(wt * 100.0);</span>
<span class="nc" id="L754">          hist[1][index]++;</span>
<span class="nc bnc" id="L755" title="All 2 branches missed.">          if (histEg[1][index] == null) {</span>
<span class="nc" id="L756">            histEg[1][index] = feat;</span>
          }
<span class="nc bnc" id="L758" title="All 4 branches missed.">          if (wt &lt; 0.001 &amp;&amp; wt &gt;= -0.001) {</span>
<span class="nc" id="L759">            index = bucketizeValue(wt * 10000.0);</span>
<span class="nc" id="L760">            hist[2][index]++;</span>
<span class="nc bnc" id="L761" title="All 2 branches missed.">            if (histEg[2][index] == null) {</span>
<span class="nc" id="L762">              histEg[2][index] = feat;</span>
            }
          }
        }
      }
    }
<span class="nc" id="L768">    double ave = total / num;</span>
<span class="nc" id="L769">    double stddev = (x2total / num) - ave * ave;</span>
<span class="nc" id="L770">    StringWriter sw = new StringWriter();</span>
<span class="nc" id="L771">    PrintWriter pw = new PrintWriter(sw);</span>

<span class="nc" id="L773">    pw.println(&quot;Linear classifier with &quot; + num + &quot; f(x,y) features&quot;);</span>
<span class="nc" id="L774">    pw.println(&quot;Average weight: &quot; + ave + &quot;; std dev: &quot; + stddev);</span>
<span class="nc" id="L775">    pw.println(&quot;Max weight: &quot; + max + &quot; min weight: &quot; + min);</span>
<span class="nc" id="L776">    pw.println(&quot;Weights: &quot; + neg + &quot; negative; &quot; + pos + &quot; positive; &quot; + zero + &quot; zero.&quot;);</span>

<span class="nc" id="L778">    printHistCounts(0, &quot;Counts of lambda parameters between [-10, 10)&quot;, pw, hist, histEg);</span>
<span class="nc" id="L779">    printHistCounts(1, &quot;Closeup view of [-0.1, 0.1) depicted * 10^2&quot;, pw, hist, histEg);</span>
<span class="nc" id="L780">    printHistCounts(2, &quot;Closeup view of [-0.001, 0.001) depicted * 10^4&quot;, pw, hist, histEg);</span>
<span class="nc" id="L781">    pw.close();</span>
<span class="nc" id="L782">    return sw.toString();</span>
  }

  /** Print out a partial representation of a linear classifier.
   *  This just calls toString(&quot;WeightHistogram&quot;, 0)
   */
  @Override
  public String toString() {
<span class="nc" id="L790">    return toString(&quot;WeightHistogram&quot;, 0);</span>
  }


  /**
   * Print out a partial representation of a linear classifier in one of
   * several ways.
   *
   * @param style Options are:
   *              HighWeight: print out the param parameters with largest weights;
   *              HighMagnitude: print out the param parameters for which the absolute
   *              value of their weight is largest;
   *              AllWeights: print out the weights of all features;
   *              WeightHistogram: print out a particular hard-coded textual histogram
   *              representation of a classifier;
   *              WeightDistribution;
   *
   * @param param Determines the number of things printed in certain styles
   * @throws IllegalArgumentException if the style name is unrecognized
   */
  public String toString(String style, int param) {
<span class="nc bnc" id="L811" title="All 4 branches missed.">    if (style == null || style.isEmpty()) {</span>
<span class="nc" id="L812">      return &quot;LinearClassifier with &quot; + featureIndex.size() + &quot; features, &quot; +</span>
<span class="nc" id="L813">              labelIndex.size() + &quot; classes, and &quot; +</span>
<span class="nc" id="L814">              labelIndex.size() * featureIndex.size() + &quot; parameters.\n&quot;;</span>
<span class="nc bnc" id="L815" title="All 2 branches missed.">    } else if (style.equalsIgnoreCase(&quot;HighWeight&quot;)) {</span>
<span class="nc" id="L816">      return toBiggestWeightFeaturesString(false, param, true);</span>
<span class="nc bnc" id="L817" title="All 2 branches missed.">    } else if (style.equalsIgnoreCase(&quot;HighMagnitude&quot;)) {</span>
<span class="nc" id="L818">      return toBiggestWeightFeaturesString(true, param, true);</span>
<span class="nc bnc" id="L819" title="All 2 branches missed.">    } else if (style.equalsIgnoreCase(&quot;AllWeights&quot;)) {</span>
<span class="nc" id="L820">      return toAllWeightsString();</span>
<span class="nc bnc" id="L821" title="All 2 branches missed.">    } else if (style.equalsIgnoreCase(&quot;WeightHistogram&quot;)) {</span>
<span class="nc" id="L822">      return toHistogramString();</span>
<span class="nc bnc" id="L823" title="All 2 branches missed.">    } else if (style.equalsIgnoreCase(&quot;WeightDistribution&quot;)) {</span>
<span class="nc" id="L824">      return toDistributionString(param);</span>
    } else {
<span class="nc" id="L826">      throw new IllegalArgumentException(&quot;Unknown style: &quot; + style);</span>
    }
  }


  /**
   * Convert parameter value into number between 0 and 201
   */
  private static int bucketizeValue(double wt) {
    int index;
<span class="nc bnc" id="L836" title="All 2 branches missed.">    if (wt &gt;= 0.0) {</span>
<span class="nc" id="L837">      index = ((int) (wt * 10.0)) + 100;</span>
    } else {
<span class="nc" id="L839">      index = ((int) (Math.floor(wt * 10.0))) + 100;</span>
    }
<span class="nc bnc" id="L841" title="All 2 branches missed.">    if (index &lt; 0) {</span>
<span class="nc" id="L842">      index = 201;</span>
<span class="nc bnc" id="L843" title="All 2 branches missed.">    } else if (index &gt; 200) {</span>
<span class="nc" id="L844">      index = 200;</span>
    }
<span class="nc" id="L846">    return index;</span>
  }

  /**
   * Print histogram counts from hist and examples over a certain range
   */
  private static void printHistCounts(int ind, String title, PrintWriter pw, double[][] hist, Object[][] histEg) {
<span class="nc" id="L853">    pw.println(title);</span>
<span class="nc bnc" id="L854" title="All 2 branches missed.">    for (int i = 0; i &lt; 200; i++) {</span>
      int intPart, fracPart;
<span class="nc bnc" id="L856" title="All 2 branches missed.">      if (i &lt; 100) {</span>
<span class="nc" id="L857">        intPart = 10 - ((i + 9) / 10);</span>
<span class="nc" id="L858">        fracPart = (10 - (i % 10)) % 10;</span>
      } else {
<span class="nc" id="L860">        intPart = (i / 10) - 10;</span>
<span class="nc" id="L861">        fracPart = i % 10;</span>
      }
<span class="nc bnc" id="L863" title="All 4 branches missed.">      pw.print(&quot;[&quot; + ((i &lt; 100) ? &quot;-&quot; : &quot;&quot;) + intPart + &quot;.&quot; + fracPart + &quot;, &quot; + ((i &lt; 100) ? &quot;-&quot; : &quot;&quot;) + intPart + &quot;.&quot; + fracPart + &quot;+0.1): &quot; + hist[ind][i]);</span>
<span class="nc bnc" id="L864" title="All 2 branches missed.">      if (histEg[ind][i] != null) {</span>
<span class="nc bnc" id="L865" title="All 2 branches missed.">        pw.print(&quot;  [&quot; + histEg[ind][i] + ((hist[ind][i] &gt; 1) ? &quot;, ...&quot; : &quot;&quot;) + &quot;]&quot;);</span>
      }
<span class="nc" id="L867">      pw.println();</span>
    }
<span class="nc" id="L869">  }</span>


  //TODO: Sort of assumes that Labels are Strings...
  public String toAllWeightsString() {
<span class="nc" id="L874">    StringWriter sw = new StringWriter();</span>
<span class="nc" id="L875">    PrintWriter pw = new PrintWriter(sw);</span>
<span class="nc" id="L876">    pw.println(&quot;Linear classifier with the following weights&quot;);</span>
<span class="nc" id="L877">    Datum&lt;L, F&gt; allFeatures = new BasicDatum&lt;&gt;(features(), (L) null);</span>
<span class="nc" id="L878">    justificationOf(allFeatures, pw);</span>
<span class="nc" id="L879">    return sw.toString();</span>
  }


  /**
   * Print all features in the classifier and the weight that they assign
   * to each class. Print to stderr.
   */
  public void dump() {
<span class="nc" id="L888">    Datum&lt;L, F&gt; allFeatures = new BasicDatum&lt;&gt;(features(), (L) null);</span>
<span class="nc" id="L889">    justificationOf(allFeatures);</span>
<span class="nc" id="L890">  }</span>

  /**
   * Print all features in the classifier and the weight that they assign
   * to each class. Print to the given PrintWriter.
   */
  public void dump(PrintWriter pw) {
<span class="nc" id="L897">    Datum&lt;L, F&gt; allFeatures = new BasicDatum&lt;&gt;(features(), (L) null);</span>
<span class="nc" id="L898">    justificationOf(allFeatures, pw);</span>
<span class="nc" id="L899">  }</span>

  /**
   * Print all features in the classifier and the weight that they assign
   * to each class. The feature names are printed in sorted order.
   */
  public void dumpSorted() {
<span class="nc" id="L906">    Datum&lt;L, F&gt; allFeatures = new BasicDatum&lt;&gt;(features(), (L) null);</span>
<span class="nc" id="L907">    justificationOf(allFeatures, new PrintWriter(System.err, true), true);</span>
<span class="nc" id="L908">  }</span>


  /**
   * Print all features active for a particular datum and the weight that
   * the classifier assigns to each class for those features.
   */
  private void justificationOfRVFDatum(RVFDatum&lt;L, F&gt; example, PrintWriter pw) {
<span class="nc" id="L916">    int featureLength = 0;</span>
<span class="nc" id="L917">    int labelLength = 6;</span>
<span class="nc" id="L918">    NumberFormat nf = NumberFormat.getNumberInstance();</span>
<span class="nc" id="L919">    nf.setMinimumFractionDigits(2);</span>
<span class="nc" id="L920">    nf.setMaximumFractionDigits(2);</span>
<span class="nc bnc" id="L921" title="All 2 branches missed.">    if (nf instanceof DecimalFormat) {</span>
<span class="nc" id="L922">      ((DecimalFormat) nf).setPositivePrefix(&quot; &quot;);</span>
    }
<span class="nc" id="L924">    Counter&lt;F&gt; features = example.asFeaturesCounter();</span>
<span class="nc bnc" id="L925" title="All 2 branches missed.">    for (F f : features.keySet()) {</span>
<span class="nc" id="L926">      featureLength = Math.max(featureLength, f.toString().length() + 2 +</span>
<span class="nc" id="L927">          nf.format(features.getCount(f)).length());</span>
<span class="nc" id="L928">    }</span>
    // make as wide as total printout
<span class="nc" id="L930">    featureLength = Math.max(featureLength, &quot;Total:&quot;.length());</span>
    // don't make it ridiculously wide
<span class="nc" id="L932">    featureLength = Math.min(featureLength, MAX_FEATURE_ALIGN_WIDTH);</span>

<span class="nc bnc" id="L934" title="All 2 branches missed.">    for (L l : labels()) {</span>
<span class="nc" id="L935">      labelLength = Math.max(labelLength, l.toString().length());</span>
<span class="nc" id="L936">    }</span>

<span class="nc" id="L938">    StringBuilder header = new StringBuilder();</span>
<span class="nc bnc" id="L939" title="All 2 branches missed.">    for (int s = 0; s &lt; featureLength; s++) {</span>
<span class="nc" id="L940">      header.append(' ');</span>
    }
<span class="nc bnc" id="L942" title="All 2 branches missed.">    for (L l : labels()) {</span>
<span class="nc" id="L943">      header.append(' ');</span>
<span class="nc" id="L944">      header.append(StringUtils.pad(l, labelLength));</span>
<span class="nc" id="L945">    }</span>
<span class="nc" id="L946">    pw.println(header);</span>
<span class="nc bnc" id="L947" title="All 2 branches missed.">    for (F f : features.keySet()) {</span>
<span class="nc" id="L948">      String fStr = f.toString();</span>
<span class="nc" id="L949">      StringBuilder line = new StringBuilder(fStr);</span>
<span class="nc" id="L950">      line.append('[').append(nf.format(features.getCount(f))).append(']');</span>
<span class="nc" id="L951">      fStr = line.toString();</span>
<span class="nc bnc" id="L952" title="All 2 branches missed.">      for (int s = fStr.length(); s &lt; featureLength; s++) {</span>
<span class="nc" id="L953">        line.append(' ');</span>
      }
<span class="nc bnc" id="L955" title="All 2 branches missed.">      for (L l : labels()) {</span>
<span class="nc" id="L956">        String lStr = nf.format(weight(f, l));</span>
<span class="nc" id="L957">        line.append(' ');</span>
<span class="nc" id="L958">        line.append(lStr);</span>
<span class="nc bnc" id="L959" title="All 2 branches missed.">        for (int s = lStr.length(); s &lt; labelLength; s++) {</span>
<span class="nc" id="L960">          line.append(' ');</span>
        }
<span class="nc" id="L962">      }</span>
<span class="nc" id="L963">      pw.println(line);</span>
<span class="nc" id="L964">    }</span>
<span class="nc" id="L965">    Counter&lt;L&gt; scores = scoresOfRVFDatum(example);</span>
<span class="nc" id="L966">    StringBuilder footer = new StringBuilder(&quot;Total:&quot;);</span>
<span class="nc bnc" id="L967" title="All 2 branches missed.">    for (int s = footer.length(); s &lt; featureLength; s++) {</span>
<span class="nc" id="L968">      footer.append(' ');</span>
    }
<span class="nc bnc" id="L970" title="All 2 branches missed.">    for (L l : labels()) {</span>
<span class="nc" id="L971">      footer.append(' ');</span>
<span class="nc" id="L972">      String str = nf.format(scores.getCount(l));</span>
<span class="nc" id="L973">      footer.append(str);</span>
<span class="nc bnc" id="L974" title="All 2 branches missed.">      for (int s = str.length(); s &lt; labelLength; s++) {</span>
<span class="nc" id="L975">        footer.append(' ');</span>
      }
<span class="nc" id="L977">    }</span>
<span class="nc" id="L978">    pw.println(footer);</span>
<span class="nc" id="L979">    Distribution&lt;L&gt; distr = Distribution.distributionFromLogisticCounter(scores);</span>
<span class="nc" id="L980">    footer = new StringBuilder(&quot;Prob:&quot;);</span>
<span class="nc bnc" id="L981" title="All 2 branches missed.">    for (int s = footer.length(); s &lt; featureLength; s++) {</span>
<span class="nc" id="L982">      footer.append(' ');</span>
    }
<span class="nc bnc" id="L984" title="All 2 branches missed.">    for (L l : labels()) {</span>
<span class="nc" id="L985">      footer.append(' ');</span>
<span class="nc" id="L986">      String str = nf.format(distr.getCount(l));</span>
<span class="nc" id="L987">      footer.append(str);</span>
<span class="nc bnc" id="L988" title="All 2 branches missed.">      for (int s = str.length(); s &lt; labelLength; s++) {</span>
<span class="nc" id="L989">        footer.append(' ');</span>
      }
<span class="nc" id="L991">    }</span>
<span class="nc" id="L992">    pw.println(footer);</span>
<span class="nc" id="L993">  }</span>


  public void justificationOf(Datum&lt;L, F&gt; example) {
<span class="nc" id="L997">    PrintWriter pw = new PrintWriter(System.err, true);</span>
<span class="nc" id="L998">    justificationOf(example, pw);</span>
<span class="nc" id="L999">  }</span>

  /**
   * Print all features active for a particular datum and the weight that
   * the classifier assigns to each class for those features.
   */
  public void justificationOf(Datum&lt;L, F&gt; example, PrintWriter pw) {
<span class="nc" id="L1006">    justificationOf(example, pw, null);</span>
<span class="nc" id="L1007">  }</span>

  /**
   * Print all features active for a particular datum and the weight that
   * the classifier assigns to each class for those features. Sorts by feature
   * name if 'sorted' is true.
   */
  public void justificationOf(Datum&lt;L, F&gt; example, PrintWriter pw, boolean sorted) {
<span class="nc bnc" id="L1015" title="All 2 branches missed.">    if(example instanceof RVFDatum&lt;?, ?&gt;)</span>
<span class="nc" id="L1016">    justificationOf(example, pw, null, sorted);</span>
<span class="nc" id="L1017">  }</span>


  public &lt;T&gt; void justificationOf(Datum&lt;L, F&gt; example, PrintWriter pw, Function&lt;F, T&gt; printer) {
<span class="nc" id="L1021">    justificationOf(example, pw, printer, false);</span>
<span class="nc" id="L1022">  }</span>

  /** Print all features active for a particular datum and the weight that
   *  the classifier assigns to each class for those features.
   *
   *  @param example The datum for which features are to be printed
   *  @param pw Where to print it to
   *  @param printer If this is non-null, then it is applied to each
   *        feature to convert it to a more readable form
   *  @param sortedByFeature Whether to sort by feature names
   */
  public &lt;T&gt; void justificationOf(Datum&lt;L, F&gt; example, PrintWriter pw,
      Function&lt;F, T&gt; printer, boolean sortedByFeature) {

<span class="nc bnc" id="L1036" title="All 2 branches missed.">    if(example instanceof RVFDatum&lt;?, ?&gt;) {</span>
<span class="nc" id="L1037">      justificationOfRVFDatum((RVFDatum&lt;L,F&gt;)example,pw);</span>
<span class="nc" id="L1038">      return;</span>
    }

<span class="nc" id="L1041">    NumberFormat nf = NumberFormat.getNumberInstance();</span>
<span class="nc" id="L1042">    nf.setMinimumFractionDigits(2);</span>
<span class="nc" id="L1043">    nf.setMaximumFractionDigits(2);</span>
<span class="nc bnc" id="L1044" title="All 2 branches missed.">    if (nf instanceof DecimalFormat) {</span>
<span class="nc" id="L1045">      ((DecimalFormat) nf).setPositivePrefix(&quot; &quot;);</span>
    }

    // determine width for features, making it at least total's width
<span class="nc" id="L1049">    int featureLength = 0;</span>
    //TODO: not really sure what this Printer is supposed to spit out...
<span class="nc bnc" id="L1051" title="All 2 branches missed.">    for (F f : example.asFeatures()) {</span>
<span class="nc" id="L1052">      int length = f.toString().length();</span>
<span class="nc bnc" id="L1053" title="All 2 branches missed.">      if (printer != null) {</span>
<span class="nc" id="L1054">        length = printer.apply(f).toString().length();</span>
      }
<span class="nc" id="L1056">      featureLength = Math.max(featureLength, length);</span>
<span class="nc" id="L1057">    }</span>
    // make as wide as total printout
<span class="nc" id="L1059">    featureLength = Math.max(featureLength, &quot;Total:&quot;.length());</span>
    // don't make it ridiculously wide
<span class="nc" id="L1061">    featureLength = Math.min(featureLength, MAX_FEATURE_ALIGN_WIDTH);</span>

    // determine width for labels
<span class="nc" id="L1064">    int labelLength = 6;</span>
<span class="nc bnc" id="L1065" title="All 2 branches missed.">    for (L l : labels()) {</span>
<span class="nc" id="L1066">      labelLength = Math.max(labelLength, l.toString().length());</span>
<span class="nc" id="L1067">    }</span>

    // print header row of output listing classes
<span class="nc" id="L1070">    StringBuilder header = new StringBuilder(&quot;&quot;);</span>
<span class="nc bnc" id="L1071" title="All 2 branches missed.">    for (int s = 0; s &lt; featureLength; s++) {</span>
<span class="nc" id="L1072">      header.append(' ');</span>
    }
<span class="nc bnc" id="L1074" title="All 2 branches missed.">    for (L l : labels()) {</span>
<span class="nc" id="L1075">      header.append(' ');</span>
<span class="nc" id="L1076">      header.append(StringUtils.pad(l, labelLength));</span>
<span class="nc" id="L1077">    }</span>
<span class="nc" id="L1078">    pw.println(header);</span>

    // print active features and weights per class
<span class="nc" id="L1081">    Collection&lt;F&gt; featColl = example.asFeatures();</span>
<span class="nc bnc" id="L1082" title="All 2 branches missed.">    if (sortedByFeature){</span>
<span class="nc" id="L1083">      featColl = ErasureUtils.sortedIfPossible(featColl);</span>
    }
<span class="nc bnc" id="L1085" title="All 2 branches missed.">    for (F f : featColl) {</span>
      String fStr;
<span class="nc bnc" id="L1087" title="All 2 branches missed.">      if (printer != null) {</span>
<span class="nc" id="L1088">        fStr = printer.apply(f).toString();</span>
      } else {
<span class="nc" id="L1090">        fStr = f.toString();</span>
      }
<span class="nc" id="L1092">      StringBuilder line = new StringBuilder(fStr);</span>
<span class="nc bnc" id="L1093" title="All 2 branches missed.">      for (int s = fStr.length(); s &lt; featureLength; s++) {</span>
<span class="nc" id="L1094">        line.append(' ');</span>
      }
<span class="nc bnc" id="L1096" title="All 2 branches missed.">      for (L l : labels()) {</span>
<span class="nc" id="L1097">        String lStr = nf.format(weight(f, l));</span>
<span class="nc" id="L1098">        line.append(' ');</span>
<span class="nc" id="L1099">        line.append(lStr);</span>
<span class="nc bnc" id="L1100" title="All 2 branches missed.">        for (int s = lStr.length(); s &lt; labelLength; s++) {</span>
<span class="nc" id="L1101">          line.append(' ');</span>
        }
<span class="nc" id="L1103">      }</span>
<span class="nc" id="L1104">      pw.println(line);</span>
<span class="nc" id="L1105">    }</span>

    // Print totals, probs, etc.
<span class="nc" id="L1108">    Counter&lt;L&gt; scores = scoresOf(example);</span>
<span class="nc" id="L1109">    StringBuilder footer = new StringBuilder(&quot;Total:&quot;);</span>
<span class="nc bnc" id="L1110" title="All 2 branches missed.">    for (int s = footer.length(); s &lt; featureLength; s++) {</span>
<span class="nc" id="L1111">      footer.append(' ');</span>
    }
<span class="nc bnc" id="L1113" title="All 2 branches missed.">    for (L l : labels()) {</span>
<span class="nc" id="L1114">      footer.append(' ');</span>
<span class="nc" id="L1115">      String str = nf.format(scores.getCount(l));</span>
<span class="nc" id="L1116">      footer.append(str);</span>
<span class="nc bnc" id="L1117" title="All 2 branches missed.">      for (int s = str.length(); s &lt; labelLength; s++) {</span>
<span class="nc" id="L1118">        footer.append(' ');</span>
      }
<span class="nc" id="L1120">    }</span>
<span class="nc" id="L1121">    pw.println(footer);</span>
<span class="nc" id="L1122">    Distribution&lt;L&gt; distr = Distribution.distributionFromLogisticCounter(scores);</span>
<span class="nc" id="L1123">    footer = new StringBuilder(&quot;Prob:&quot;);</span>
<span class="nc bnc" id="L1124" title="All 2 branches missed.">    for (int s = footer.length(); s &lt; featureLength; s++) {</span>
<span class="nc" id="L1125">      footer.append(' ');</span>
    }
<span class="nc bnc" id="L1127" title="All 2 branches missed.">    for (L l : labels()) {</span>
<span class="nc" id="L1128">      footer.append(' ');</span>
<span class="nc" id="L1129">      String str = nf.format(distr.getCount(l));</span>
<span class="nc" id="L1130">      footer.append(str);</span>
<span class="nc bnc" id="L1131" title="All 2 branches missed.">      for (int s = str.length(); s &lt; labelLength; s++) {</span>
<span class="nc" id="L1132">        footer.append(' ');</span>
      }
<span class="nc" id="L1134">    }</span>
<span class="nc" id="L1135">    pw.println(footer);</span>
<span class="nc" id="L1136">  }</span>

/**
 * This method returns a map from each label to a counter of feature weights for that label.
 * Useful for feature analysis.
 *
 * @return a map of counters
 */
  public Map&lt;L,Counter&lt;F&gt;&gt; weightsAsMapOfCounters() {
<span class="nc" id="L1145">    Map&lt;L,Counter&lt;F&gt;&gt; mapOfCounters = Generics.newHashMap();</span>
<span class="nc bnc" id="L1146" title="All 2 branches missed.">    for(L label : labelIndex){</span>
<span class="nc" id="L1147">      int labelID = labelIndex.indexOf(label);</span>
<span class="nc" id="L1148">      Counter&lt;F&gt; c = new ClassicCounter&lt;&gt;();</span>
<span class="nc" id="L1149">      mapOfCounters.put(label, c);</span>
<span class="nc bnc" id="L1150" title="All 2 branches missed.">      for (F f : featureIndex) {</span>
<span class="nc" id="L1151">        c.incrementCount(f, weights[featureIndex.indexOf(f)][labelID]);</span>
<span class="nc" id="L1152">      }</span>
<span class="nc" id="L1153">    }</span>
<span class="nc" id="L1154">    return mapOfCounters;</span>
  }


  public Counter&lt;L&gt; scoresOf(Datum&lt;L, F&gt; example, Collection&lt;L&gt; possibleLabels) {
<span class="nc" id="L1159">    Counter&lt;L&gt; scores = new ClassicCounter&lt;&gt;();</span>
<span class="nc bnc" id="L1160" title="All 2 branches missed.">    for (L l : possibleLabels) {</span>
<span class="nc bnc" id="L1161" title="All 2 branches missed.">      if (labelIndex.indexOf(l) == -1) {</span>
<span class="nc" id="L1162">        continue;</span>
      }
<span class="nc" id="L1164">      double score = scoreOf(example, l);</span>
<span class="nc" id="L1165">      scores.setCount(l, score);</span>
<span class="nc" id="L1166">    }</span>
<span class="nc" id="L1167">    return scores;</span>
  }

  /* -- looks like a failed attempt at micro-optimization --

  public L experimentalClassOf(Datum&lt;L,F&gt; example) {
    if(example instanceof RVFDatum&lt;?, ?&gt;) {
      throw new UnsupportedOperationException();
    }

    int labelCount = weights[0].length;
    //System.out.printf(&quot;labelCount: %d\n&quot;, labelCount);
    Collection&lt;F&gt; features = example.asFeatures();

    int[] featureInts = new int[features.size()];
    int fI = 0;
    for (F feature : features) {
      featureInts[fI++] = featureIndex.indexOf(feature);
    }
    //System.out.println(&quot;Features: &quot;+features);
    double bestScore = Double.NEGATIVE_INFINITY;
    int bestI = 0;
    for (int i = 0; i &lt; labelCount; i++) {
      double score = 0;
      for (int j = 0; j &lt; featureInts.length; j++) {
        if (featureInts[j] &lt; 0) continue;
        score += weights[featureInts[j]][i];
      }
      if (score &gt; bestScore) {
        bestI = i;
        bestScore = score;
      }
      //System.out.printf(&quot;Score: %s(%d): %e\n&quot;, labelIndex.get(i), i, score);
    }
    //System.out.printf(&quot;label(%d): %s\n&quot;, bestI, labelIndex.get(bestI));;
    return labelIndex.get(bestI);
  }
  -- */

  @Override
  public L classOf(Datum&lt;L, F&gt; example) {
<span class="pc bpc" id="L1208" title="1 of 2 branches missed.">    if(example instanceof RVFDatum&lt;?, ?&gt;)return classOfRVFDatum((RVFDatum&lt;L,F&gt;)example);</span>
<span class="fc" id="L1209">    Counter&lt;L&gt; scores = scoresOf(example);</span>
<span class="fc" id="L1210">    return Counters.argmax(scores);</span>
  }


  private L classOfRVFDatum(RVFDatum&lt;L, F&gt; example) {
<span class="nc" id="L1215">    Counter&lt;L&gt; scores = scoresOfRVFDatum(example);</span>
<span class="nc" id="L1216">    return Counters.argmax(scores);</span>
  }

  @Override
  @Deprecated
  public L classOf(RVFDatum&lt;L, F&gt; example) {
<span class="nc" id="L1222">    Counter&lt;L&gt; scores = scoresOf(example);</span>
<span class="nc" id="L1223">    return Counters.argmax(scores);</span>
  }

  /** For Kryo -- can be private */
<span class="nc" id="L1227">  private LinearClassifier() { }</span>

  /** Make a linear classifier from the parameters. The parameters are used, not copied.
   *
   *  @param weights The parameters of the classifier. The first index is the
   *                 featureIndex value and second index is the labelIndex value.
   *  @param featureIndex An index from F to integers used to index the features in the weights array
   *  @param labelIndex An index from L to integers used to index the labels in the weights array
   */
<span class="fc" id="L1236">  public LinearClassifier(double[][] weights, Index&lt;F&gt; featureIndex, Index&lt;L&gt; labelIndex) {</span>
<span class="fc" id="L1237">    this.featureIndex = featureIndex;</span>
<span class="fc" id="L1238">    this.labelIndex = labelIndex;</span>
<span class="fc" id="L1239">    this.weights = weights;</span>
<span class="fc" id="L1240">    thresholds = new double[labelIndex.size()];</span>
    // Arrays.fill(thresholds, 0.0); // not needed; Java arrays zero initialized
<span class="fc" id="L1242">  }</span>

  // todo: This is unused and seems broken (ignores passed in thresholds)
  public LinearClassifier(double[][] weights, Index&lt;F&gt; featureIndex, Index&lt;L&gt; labelIndex,
<span class="nc" id="L1246">      double[] thresholds) throws Exception {</span>
<span class="nc" id="L1247">    this.featureIndex = featureIndex;</span>
<span class="nc" id="L1248">    this.labelIndex = labelIndex;</span>
<span class="nc" id="L1249">    this.weights = weights;</span>
<span class="nc bnc" id="L1250" title="All 2 branches missed.">    if (thresholds.length != labelIndex.size())</span>
<span class="nc" id="L1251">      throw new Exception(&quot;Number of thresholds and number of labels do not match.&quot;);</span>
<span class="nc" id="L1252">    thresholds = new double[thresholds.length];</span>
<span class="nc" id="L1253">    int curr = 0;</span>
<span class="nc bnc" id="L1254" title="All 2 branches missed.">    for (double tval : thresholds) {</span>
<span class="nc" id="L1255">      thresholds[curr++] = tval;</span>
    }
<span class="nc" id="L1257">    Arrays.fill(thresholds, 0.0);</span>
<span class="nc" id="L1258">  }</span>

  private static &lt;F, L&gt; Counter&lt;Pair&lt;F, L&gt;&gt; makeWeightCounter(double[] weights, Index&lt;Pair&lt;F, L&gt;&gt; weightIndex) {
<span class="nc" id="L1261">    Counter&lt;Pair&lt;F,L&gt;&gt; weightCounter = new ClassicCounter&lt;&gt;();</span>
<span class="nc bnc" id="L1262" title="All 2 branches missed.">    for (int i = 0; i &lt; weightIndex.size(); i++) {</span>
<span class="nc bnc" id="L1263" title="All 2 branches missed.">      if (weights[i] == 0) {</span>
<span class="nc" id="L1264">        continue; // no need to save 0 weights</span>
      }
<span class="nc" id="L1266">      weightCounter.setCount(weightIndex.get(i), weights[i]);</span>
    }
<span class="nc" id="L1268">    return weightCounter;</span>
  }

  public LinearClassifier(double[] weights, Index&lt;Pair&lt;F, L&gt;&gt; weightIndex) {
<span class="nc" id="L1272">    this(makeWeightCounter(weights, weightIndex));</span>
<span class="nc" id="L1273">  }</span>

  public LinearClassifier(Counter&lt;? extends Pair&lt;F, L&gt;&gt; weightCounter) {
<span class="fc" id="L1276">    this(weightCounter, new ClassicCounter&lt;&gt;());</span>
<span class="fc" id="L1277">  }</span>

<span class="fc" id="L1279">  public LinearClassifier(Counter&lt;? extends Pair&lt;F, L&gt;&gt; weightCounter, Counter&lt;L&gt; thresholdsC) {</span>
<span class="fc" id="L1280">    Collection&lt;? extends Pair&lt;F, L&gt;&gt; keys = weightCounter.keySet();</span>
<span class="fc" id="L1281">    featureIndex = new HashIndex&lt;&gt;();</span>
<span class="fc" id="L1282">    labelIndex = new HashIndex&lt;&gt;();</span>
<span class="pc bpc" id="L1283" title="1 of 2 branches missed.">    for (Pair&lt;F, L&gt; p : keys) {</span>
<span class="nc" id="L1284">      featureIndex.add(p.first());</span>
<span class="nc" id="L1285">      labelIndex.add(p.second());</span>
<span class="nc" id="L1286">    }</span>
<span class="fc" id="L1287">    thresholds = new double[labelIndex.size()];</span>
<span class="pc bpc" id="L1288" title="1 of 2 branches missed.">    for (L label : labelIndex) {</span>
<span class="nc" id="L1289">      thresholds[labelIndex.indexOf(label)] = thresholdsC.getCount(label);</span>
<span class="nc" id="L1290">    }</span>
<span class="fc" id="L1291">    weights = new double[featureIndex.size()][labelIndex.size()];</span>
<span class="fc" id="L1292">    Pair&lt;F, L&gt; tempPair = new Pair&lt;&gt;();</span>
<span class="pc bpc" id="L1293" title="1 of 2 branches missed.">    for (int f = 0; f &lt; weights.length; f++) {</span>
<span class="nc bnc" id="L1294" title="All 2 branches missed.">      for (int l = 0; l &lt; weights[f].length; l++) {</span>
<span class="nc" id="L1295">        tempPair.first = featureIndex.get(f);</span>
<span class="nc" id="L1296">        tempPair.second = labelIndex.get(l);</span>
<span class="nc" id="L1297">        weights[f][l] = weightCounter.getCount(tempPair);</span>
      }
    }
<span class="fc" id="L1300">  }</span>


  public void adaptWeights(Dataset&lt;L, F&gt; adapt,LinearClassifierFactory&lt;L, F&gt; lcf) {
<span class="nc" id="L1304">    logger.info(&quot;before adapting, weights size=&quot;+weights.length);</span>
<span class="nc" id="L1305">    weights = lcf.adaptWeights(weights,adapt);</span>
<span class="nc" id="L1306">    logger.info(&quot;after adapting, weights size=&quot; + weights.length);</span>
<span class="nc" id="L1307">  }</span>

  public double[][] weights() {
<span class="nc" id="L1310">    return weights;</span>
  }

  public void setWeights(double[][] newWeights) {
<span class="nc" id="L1314">    weights = newWeights;</span>
<span class="nc" id="L1315">  }</span>

  /**
   * Loads a classifier from a file.
   * Simple convenience wrapper for IOUtils.readFromString.
   */
  public static &lt;L, F&gt; LinearClassifier&lt;L, F&gt; readClassifier(String loadPath) {
<span class="nc" id="L1322">    logger.info(&quot;Deserializing classifier from &quot; + loadPath + &quot;...&quot;);</span>

    try {
<span class="nc" id="L1325">      ObjectInputStream ois = IOUtils.readStreamFromString(loadPath);</span>
<span class="nc" id="L1326">      LinearClassifier&lt;L, F&gt; classifier = ErasureUtils.&lt;LinearClassifier&lt;L, F&gt;&gt;uncheckedCast(ois.readObject());</span>
<span class="nc" id="L1327">      ois.close();</span>
<span class="nc" id="L1328">      return classifier;</span>
<span class="nc" id="L1329">    } catch (Exception e) {</span>
<span class="nc" id="L1330">      throw new RuntimeException(&quot;Deserialization failed: &quot;+e.getMessage(), e);</span>
    }
  }

  /**
   * Convenience wrapper for IOUtils.writeObjectToFile
   */
  public static void writeClassifier(LinearClassifier&lt;?, ?&gt; classifier, String writePath) {
    try {
<span class="nc" id="L1339">      IOUtils.writeObjectToFile(classifier, writePath);</span>
<span class="nc" id="L1340">    } catch (Exception e) {</span>
<span class="nc" id="L1341">      throw new RuntimeException(&quot;Serialization failed: &quot;+e.getMessage(), e);</span>
<span class="nc" id="L1342">    }</span>
<span class="nc" id="L1343">  }</span>

  /**
   * Saves this out to a standard text file, instead of as a serialized Java object.
   * NOTE: this currently assumes feature and weights are represented as Strings.
   * @param file String filepath to write out to.
   */
  public void saveToFilename(String file) {
    try {
<span class="nc" id="L1352">      File tgtFile = new File(file);</span>
<span class="nc" id="L1353">      BufferedWriter out = new BufferedWriter(new FileWriter(tgtFile));</span>
      // output index first, blank delimiter, outline feature index, then weights
<span class="nc" id="L1355">      labelIndex.saveToWriter(out);</span>
<span class="nc" id="L1356">      featureIndex.saveToWriter(out);</span>
<span class="nc" id="L1357">      int numLabels = labelIndex.size();</span>
<span class="nc" id="L1358">      int numFeatures = featureIndex.size();</span>
<span class="nc bnc" id="L1359" title="All 2 branches missed.">      for (int featIndex=0; featIndex&lt;numFeatures; featIndex++) {</span>
<span class="nc bnc" id="L1360" title="All 2 branches missed.">        for (int labelIndex=0;labelIndex&lt;numLabels;labelIndex++) {</span>
<span class="nc" id="L1361">          out.write(String.valueOf(featIndex));</span>
<span class="nc" id="L1362">          out.write(TEXT_SERIALIZATION_DELIMITER);</span>
<span class="nc" id="L1363">          out.write(String.valueOf(labelIndex));</span>
<span class="nc" id="L1364">          out.write(TEXT_SERIALIZATION_DELIMITER);</span>
<span class="nc" id="L1365">          out.write(String.valueOf(weight(featIndex, labelIndex)));</span>
<span class="nc" id="L1366">          out.write(&quot;\n&quot;);</span>
        }
      }

      // write out thresholds: first item after blank is the number of thresholds, after is the threshold array values.
<span class="nc" id="L1371">      out.write(&quot;\n&quot;);</span>
<span class="nc" id="L1372">      out.write(String.valueOf(thresholds.length));</span>
<span class="nc" id="L1373">      out.write(&quot;\n&quot;);</span>
<span class="nc bnc" id="L1374" title="All 2 branches missed.">      for (double val : thresholds) {</span>
<span class="nc" id="L1375">        out.write(String.valueOf(val));</span>
<span class="nc" id="L1376">        out.write(&quot;\n&quot;);</span>
      }
<span class="nc" id="L1378">      out.close();</span>
<span class="nc" id="L1379">    } catch (Exception e) {</span>
<span class="nc" id="L1380">      logger.info(&quot;Error attempting to save classifier to file=&quot; + file);</span>
<span class="nc" id="L1381">      logger.info(e);</span>
<span class="nc" id="L1382">    }</span>
<span class="nc" id="L1383">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>