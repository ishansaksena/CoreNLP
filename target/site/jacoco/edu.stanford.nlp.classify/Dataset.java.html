<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Dataset.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.classify</a> &gt; <span class="el_source">Dataset.java</span></div><h1>Dataset.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.classify;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Random;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import edu.stanford.nlp.ling.BasicDatum;
import edu.stanford.nlp.ling.Datum;
import edu.stanford.nlp.ling.RVFDatum;
import edu.stanford.nlp.stats.ClassicCounter;
import edu.stanford.nlp.stats.Counter;
import edu.stanford.nlp.stats.TwoDimensionalCounter;
import edu.stanford.nlp.objectbank.ObjectBank;
import edu.stanford.nlp.util.Generics;
import edu.stanford.nlp.util.Index;
import edu.stanford.nlp.util.HashIndex;
import edu.stanford.nlp.util.Pair;
import edu.stanford.nlp.util.ScoredComparator;
import edu.stanford.nlp.util.ScoredObject;


import edu.stanford.nlp.util.logging.Redwood;


/**
 * An interfacing class for {@link ClassifierFactory} that incrementally
 * builds a more memory-efficient representation of a {@link List} of
 * {@link Datum} objects for the purposes of training a {@link Classifier}
 * with a {@link ClassifierFactory}.
 *
 * @author Roger Levy (rog@stanford.edu)
 * @author Anna Rafferty (various refactoring with GeneralDataset/RVFDataset)
 * @author Sarah Spikes (sdspikes@cs.stanford.edu) (templatization)
 * @author nmramesh@cs.stanford.edu {@link #getL1NormalizedTFIDFDatum(Datum, Counter) and #getL1NormalizedTFIDFDataset()}
 *
 * @param &lt;L&gt; Label type
 * @param &lt;F&gt; Feature type
 */
public class Dataset&lt;L, F&gt; extends GeneralDataset&lt;L, F&gt; {

  private static final long serialVersionUID = -3883164942879961091L;

<span class="fc" id="L53">  final static Redwood.RedwoodChannels logger = Redwood.channels(Dataset.class);</span>

  public Dataset() {
<span class="fc" id="L56">    this(10);</span>
<span class="fc" id="L57">  }</span>

<span class="fc" id="L59">  public Dataset(int numDatums) {</span>
<span class="fc" id="L60">    initialize(numDatums);</span>
<span class="fc" id="L61">  }</span>

<span class="nc" id="L63">  public Dataset(int numDatums, Index&lt;F&gt; featureIndex, Index&lt;L&gt; labelIndex) {</span>
<span class="nc" id="L64">    initialize(numDatums);</span>
<span class="nc" id="L65">    this.featureIndex = featureIndex;</span>
<span class="nc" id="L66">    this.labelIndex = labelIndex;</span>
<span class="nc" id="L67">  }</span>

  public Dataset(Index&lt;F&gt; featureIndex, Index&lt;L&gt; labelIndex) {
<span class="nc" id="L70">    this(10, featureIndex, labelIndex);</span>
<span class="nc" id="L71">  }</span>


  /**
   * Constructor that fully specifies a Dataset.  Needed this for MulticlassDataset.
   */
  public Dataset(Index&lt;L&gt; labelIndex, int[] labels, Index&lt;F&gt; featureIndex, int[][] data) {
<span class="nc" id="L78">    this (labelIndex, labels, featureIndex, data, data.length);</span>
<span class="nc" id="L79">  }</span>

  /**
   * Constructor that fully specifies a Dataset.  Needed this for MulticlassDataset.
   */
<span class="fc" id="L84">  public Dataset(Index&lt;L&gt; labelIndex, int[] labels, Index&lt;F&gt; featureIndex, int[][] data, int size) {</span>
<span class="fc" id="L85">    this.labelIndex = labelIndex;</span>
<span class="fc" id="L86">    this.labels = labels;</span>
<span class="fc" id="L87">    this.featureIndex = featureIndex;</span>
<span class="fc" id="L88">    this.data = data;</span>
<span class="fc" id="L89">    this.size = size;</span>
<span class="fc" id="L90">  }</span>

  /** {@inheritDoc} */
  @Override
  public Pair&lt;GeneralDataset&lt;L, F&gt;, GeneralDataset&lt;L, F&gt;&gt; split(double percentDev) {
<span class="fc" id="L95">    return split(0, (int)(percentDev * size()));</span>
  }

  /** {@inheritDoc} */
  @Override
  public Pair&lt;GeneralDataset&lt;L, F&gt;,GeneralDataset&lt;L, F&gt;&gt; split(int start, int end) {
<span class="fc" id="L101">    int devSize = end - start;</span>
<span class="fc" id="L102">    int trainSize = size() - devSize;</span>

<span class="fc" id="L104">    int[][] devData = new int[devSize][];</span>
<span class="fc" id="L105">    int[] devLabels = new int[devSize];</span>

<span class="fc" id="L107">    int[][] trainData = new int[trainSize][];</span>
<span class="fc" id="L108">    int[] trainLabels = new int[trainSize];</span>

<span class="fc" id="L110">    synchronized (System.class) {</span>
<span class="fc" id="L111">      System.arraycopy(data, start, devData, 0, devSize);</span>
<span class="fc" id="L112">      System.arraycopy(labels, start, devLabels, 0, devSize);</span>

<span class="fc" id="L114">      System.arraycopy(data, 0, trainData, 0, start);</span>
<span class="fc" id="L115">      System.arraycopy(data, end, trainData, start, size() - end);</span>
<span class="fc" id="L116">      System.arraycopy(labels, 0, trainLabels, 0, start);</span>
<span class="fc" id="L117">      System.arraycopy(labels, end, trainLabels, start, size() - end);</span>
<span class="pc" id="L118">    }</span>

<span class="pc bpc" id="L120" title="1 of 2 branches missed.">    if (this instanceof WeightedDataset&lt;?,?&gt;) {</span>
<span class="nc" id="L121">      float[] trainWeights = new float[trainSize];</span>
<span class="nc" id="L122">      float[] devWeights = new float[devSize];</span>

<span class="nc" id="L124">      WeightedDataset&lt;L, F&gt; w = (WeightedDataset&lt;L, F&gt;)this;</span>

<span class="nc" id="L126">      synchronized (System.class) {</span>
<span class="nc" id="L127">        System.arraycopy(w.weights, start, devWeights, 0, devSize);</span>
<span class="nc" id="L128">        System.arraycopy(w.weights, 0, trainWeights, 0, start);</span>
<span class="nc" id="L129">        System.arraycopy(w.weights, end, trainWeights, start, size() - end);</span>
<span class="nc" id="L130">      }</span>

<span class="nc" id="L132">      WeightedDataset&lt;L, F&gt; dev = new WeightedDataset&lt;&gt;(labelIndex, devLabels, featureIndex, devData, devSize, devWeights);</span>
<span class="nc" id="L133">      WeightedDataset&lt;L, F&gt; train = new WeightedDataset&lt;&gt;(labelIndex, trainLabels, featureIndex, trainData, trainSize, trainWeights);</span>

<span class="nc" id="L135">      return new Pair&lt;&gt;(train, dev);</span>
    }
<span class="fc" id="L137">    Dataset&lt;L, F&gt; dev = new Dataset&lt;&gt;(labelIndex, devLabels, featureIndex, devData, devSize);</span>
<span class="fc" id="L138">    Dataset&lt;L, F&gt; train = new Dataset&lt;&gt;(labelIndex, trainLabels, featureIndex, trainData, trainSize);</span>

<span class="fc" id="L140">    return new Pair&lt;&gt;(train, dev);</span>
  }


  public Dataset&lt;L, F&gt; getRandomSubDataset(double p, int seed) {
<span class="nc" id="L145">    int newSize = (int)(p * size());</span>
<span class="nc" id="L146">    Set&lt;Integer&gt; indicesToKeep = Generics.newHashSet();</span>
<span class="nc" id="L147">    Random r = new Random(seed);</span>
<span class="nc" id="L148">    int s = size();</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">    while (indicesToKeep.size() &lt; newSize) {</span>
<span class="nc" id="L150">      indicesToKeep.add(r.nextInt(s));</span>
    }

<span class="nc" id="L153">    int[][] newData = new int[newSize][];</span>
<span class="nc" id="L154">    int[] newLabels = new int[newSize];</span>

<span class="nc" id="L156">    int i = 0;</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">    for (int j : indicesToKeep) {</span>
<span class="nc" id="L158">      newData[i] = data[j];</span>
<span class="nc" id="L159">      newLabels[i] = labels[j];</span>
<span class="nc" id="L160">      i++;</span>
<span class="nc" id="L161">    }</span>

<span class="nc" id="L163">    return new Dataset&lt;&gt;(labelIndex, newLabels, featureIndex, newData);</span>
  }

  @Override
  public double[][] getValuesArray() {
<span class="fc" id="L168">    return null;</span>
  }

  /**
   * Constructs a Dataset by reading in a file in SVM light format.
   */
  public static Dataset&lt;String, String&gt; readSVMLightFormat(String filename) {
<span class="nc" id="L175">    return readSVMLightFormat(filename, new HashIndex&lt;&gt;(), new HashIndex&lt;&gt;());</span>
  }

  /**
   * Constructs a Dataset by reading in a file in SVM light format.
   * The lines parameter is filled with the lines of the file for further processing
   * (if lines is null, it is assumed no line information is desired)
   */
  public static Dataset&lt;String, String&gt; readSVMLightFormat(String filename, List&lt;String&gt; lines) {
<span class="nc" id="L184">    return readSVMLightFormat(filename, new HashIndex&lt;&gt;(), new HashIndex&lt;&gt;(), lines);</span>
  }

  /**
   * Constructs a Dataset by reading in a file in SVM light format.
   * the created dataset has the same feature and label index as given
   */
  public static Dataset&lt;String, String&gt; readSVMLightFormat(String filename, Index&lt;String&gt; featureIndex, Index&lt;String&gt; labelIndex) {
<span class="nc" id="L192">    return readSVMLightFormat(filename, featureIndex, labelIndex, null);</span>
  }
  /**
   * Constructs a Dataset by reading in a file in SVM light format.
   * the created dataset has the same feature and label index as given
   */
  public static Dataset&lt;String, String&gt; readSVMLightFormat(String filename, Index&lt;String&gt; featureIndex, Index&lt;String&gt; labelIndex, List&lt;String&gt; lines) {
    Dataset&lt;String, String&gt; dataset;
    try {
<span class="nc" id="L201">      dataset = new Dataset&lt;&gt;(10, featureIndex, labelIndex);</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">      for (String line : ObjectBank.getLineIterator(new File(filename))) {</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">        if(lines != null)</span>
<span class="nc" id="L204">          lines.add(line);</span>
<span class="nc" id="L205">        dataset.add(svmLightLineToDatum(line));</span>
<span class="nc" id="L206">      }</span>

<span class="nc" id="L208">    } catch (Exception e) {</span>
<span class="nc" id="L209">      throw new RuntimeException(e);</span>
<span class="nc" id="L210">    }</span>
<span class="nc" id="L211">    return dataset;</span>
  }

<span class="fc" id="L214">  private static int line1 = 0;</span>

  public static Datum&lt;String, String&gt; svmLightLineToDatum(String l) {
<span class="nc" id="L217">    line1++;</span>
<span class="nc" id="L218">    l = l.replaceAll(&quot;#.*&quot;, &quot;&quot;); // remove any trailing comments</span>
<span class="nc" id="L219">    String[] line = l.split(&quot;\\s+&quot;);</span>
<span class="nc" id="L220">    Collection&lt;String&gt; features = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">    for (int i = 1; i &lt; line.length; i++) {</span>
<span class="nc" id="L222">      String[] f = line[i].split(&quot;:&quot;);</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">      if (f.length != 2) {</span>
<span class="nc" id="L224">        logger.info(&quot;Dataset error: line &quot; + line1);</span>
      }
<span class="nc" id="L226">      int val = (int) Double.parseDouble(f[1]);</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">      for (int j = 0; j &lt; val; j++) {</span>
<span class="nc" id="L228">        features.add(f[0]);</span>
      }
    }
<span class="nc" id="L231">    features.add(String.valueOf(Integer.MAX_VALUE));  // a constant feature for a class</span>
<span class="nc" id="L232">    Datum&lt;String, String&gt; d = new BasicDatum&lt;&gt;(features, line[0]);</span>
<span class="nc" id="L233">    return d;</span>
  }

  /**
   *  Get Number of datums a given feature appears in.
   */
  public Counter&lt;F&gt; getFeatureCounter()
  {
<span class="nc" id="L241">    Counter&lt;F&gt; featureCounts = new ClassicCounter&lt;&gt;();</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">    for (int i=0; i &lt; this.size(); i++)</span>
    {
<span class="nc" id="L244">      BasicDatum&lt;L, F&gt; datum = (BasicDatum&lt;L, F&gt;) getDatum(i);</span>
<span class="nc" id="L245">      Set&lt;F&gt; featureSet   = Generics.newHashSet(datum.asFeatures());</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">      for (F key : featureSet) {</span>
<span class="nc" id="L247">        featureCounts.incrementCount(key, 1.0);</span>
<span class="nc" id="L248">      }</span>
    }
<span class="nc" id="L250">    return featureCounts;</span>
  }

  /**
   * Method to convert features from counts to L1-normalized TFIDF based features
   * @param datum with a collection of features.
   * @param featureDocCounts a counter of doc-count for each feature.
   * @return RVFDatum with l1-normalized tf-idf features.
   */
  public RVFDatum&lt;L,F&gt; getL1NormalizedTFIDFDatum(Datum&lt;L,F&gt; datum,Counter&lt;F&gt; featureDocCounts){
<span class="nc" id="L260">      Counter&lt;F&gt; tfidfFeatures = new ClassicCounter&lt;&gt;();</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">      for(F feature : datum.asFeatures()){</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">        if(featureDocCounts.containsKey(feature))</span>
<span class="nc" id="L263">          tfidfFeatures.incrementCount(feature,1.0);</span>
<span class="nc" id="L264">      }</span>
<span class="nc" id="L265">      double l1norm = 0;</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">      for(F feature: tfidfFeatures.keySet()){</span>
<span class="nc" id="L267">        double idf = Math.log(((double)(this.size()+1))/(featureDocCounts.getCount(feature)+0.5));</span>
<span class="nc" id="L268">        double tf = tfidfFeatures.getCount(feature);</span>
<span class="nc" id="L269">        tfidfFeatures.setCount(feature, tf*idf);</span>
<span class="nc" id="L270">        l1norm += tf*idf;</span>
<span class="nc" id="L271">      }</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">      for(F feature: tfidfFeatures.keySet()){</span>
<span class="nc" id="L273">        double tfidf = tfidfFeatures.getCount(feature);</span>
<span class="nc" id="L274">        tfidfFeatures.setCount(feature, tfidf/l1norm);</span>
<span class="nc" id="L275">      }</span>
<span class="nc" id="L276">      RVFDatum&lt;L,F&gt; rvfDatum = new RVFDatum&lt;&gt;(tfidfFeatures, datum.label());</span>
<span class="nc" id="L277">      return rvfDatum;</span>
  }

  /**
   * Method to convert this dataset to RVFDataset using L1-normalized TF-IDF features
   * @return RVFDataset
   */
  public RVFDataset&lt;L,F&gt; getL1NormalizedTFIDFDataset(){
<span class="nc" id="L285">    RVFDataset&lt;L,F&gt; rvfDataset = new RVFDataset&lt;&gt;(this.size(), this.featureIndex, this.labelIndex);</span>
<span class="nc" id="L286">    Counter&lt;F&gt; featureDocCounts = getFeatureCounter();</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">    for(int i = 0; i &lt; this.size(); i++){</span>
<span class="nc" id="L288">      Datum&lt;L,F&gt; datum = this.getDatum(i);</span>
<span class="nc" id="L289">      RVFDatum&lt;L,F&gt; rvfDatum = getL1NormalizedTFIDFDatum(datum,featureDocCounts);</span>
<span class="nc" id="L290">      rvfDataset.add(rvfDatum);</span>
    }
<span class="nc" id="L292">    return rvfDataset;</span>
  }

  @Override
  public void add(Datum&lt;L, F&gt; d) {
<span class="fc" id="L297">    add(d.asFeatures(), d.label());</span>
<span class="fc" id="L298">  }</span>

  public void add(Collection&lt;F&gt; features, L label) {
<span class="fc" id="L301">    add(features, label, true);</span>
<span class="fc" id="L302">  }</span>

  public void add(Collection&lt;F&gt; features, L label, boolean addNewFeatures) {
<span class="fc" id="L305">    ensureSize();</span>
<span class="fc" id="L306">    addLabel(label);</span>
<span class="fc" id="L307">    addFeatures(features, addNewFeatures);</span>
<span class="fc" id="L308">    size++;</span>
<span class="fc" id="L309">  }</span>

  /**
   * Adds a datums defined by feature indices and label index
   * Careful with this one! Make sure that all indices are valid!
   * @param features
   * @param label
   */
  public void add(int [] features, int label) {
<span class="nc" id="L318">    ensureSize();</span>
<span class="nc" id="L319">    addLabelIndex(label);</span>
<span class="nc" id="L320">    addFeatureIndices(features);</span>
<span class="nc" id="L321">    size++;</span>
<span class="nc" id="L322">  }</span>

  protected void ensureSize() {
<span class="pc bpc" id="L325" title="1 of 2 branches missed.">    if (labels.length == size) {</span>
<span class="nc" id="L326">      int[] newLabels = new int[size * 2];</span>
<span class="nc" id="L327">      int[][] newData = new int[size * 2][];</span>
<span class="nc" id="L328">      synchronized (System.class) {</span>
<span class="nc" id="L329">        System.arraycopy(labels, 0, newLabels, 0, size);</span>
<span class="nc" id="L330">        System.arraycopy(data, 0, newData, 0, size);</span>
<span class="nc" id="L331">      }</span>
<span class="nc" id="L332">      labels = newLabels;</span>
<span class="nc" id="L333">      data = newData;</span>
    }
<span class="fc" id="L335">  }</span>

  protected void addLabel(L label) {
<span class="fc" id="L338">    labelIndex.add(label);</span>
<span class="fc" id="L339">    labels[size] = labelIndex.indexOf(label);</span>
<span class="fc" id="L340">  }</span>

  protected void addLabelIndex(int label) {
<span class="nc" id="L343">    labels[size] = label;</span>
<span class="nc" id="L344">  }</span>

  protected void addFeatures(Collection&lt;F&gt; features) {
<span class="nc" id="L347">    addFeatures(features, true);</span>
<span class="nc" id="L348">  }</span>

  protected void addFeatures(Collection&lt;F&gt; features, boolean addNewFeatures) {
<span class="fc" id="L351">    int[] intFeatures = new int[features.size()];</span>
<span class="fc" id="L352">    int j = 0;</span>
<span class="fc bfc" id="L353" title="All 2 branches covered.">    for (F feature : features) {</span>
<span class="pc bpc" id="L354" title="1 of 2 branches missed.">      if(addNewFeatures) featureIndex.add(feature);</span>
<span class="fc" id="L355">      int index = featureIndex.indexOf(feature);</span>
<span class="pc bpc" id="L356" title="1 of 2 branches missed.">      if (index &gt;= 0) {</span>
<span class="fc" id="L357">        intFeatures[j] = featureIndex.indexOf(feature);</span>
<span class="fc" id="L358">        j++;</span>
      }
<span class="fc" id="L360">    }</span>
<span class="fc" id="L361">    data[size] = new int[j];</span>
<span class="fc" id="L362">    synchronized (System.class) {</span>
<span class="fc" id="L363">      System.arraycopy(intFeatures, 0, data[size], 0, j);</span>
<span class="pc" id="L364">    }</span>
<span class="fc" id="L365">  }</span>

  protected void addFeatureIndices(int [] features) {
<span class="nc" id="L368">    data[size] = features;</span>
<span class="nc" id="L369">  }</span>

  @Override
  protected final void initialize(int numDatums) {
<span class="fc" id="L373">    labelIndex = new HashIndex&lt;&gt;();</span>
<span class="fc" id="L374">    featureIndex = new HashIndex&lt;&gt;();</span>
<span class="fc" id="L375">    labels = new int[numDatums];</span>
<span class="fc" id="L376">    data = new int[numDatums][];</span>
<span class="fc" id="L377">    size = 0;</span>
<span class="fc" id="L378">  }</span>

  /**
   * @return the index-ed datum
   */
  @Override
  public Datum&lt;L, F&gt; getDatum(int index) {
<span class="fc" id="L385">    return new BasicDatum&lt;&gt;(featureIndex.objects(data[index]), labelIndex.get(labels[index]));</span>
  }

  /**
   * @return the index-ed datum
   */
  @Override
  public RVFDatum&lt;L, F&gt; getRVFDatum(int index) {
<span class="nc" id="L393">     ClassicCounter&lt;F&gt; c = new ClassicCounter&lt;&gt;();</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">    for (F key : featureIndex.objects(data[index])) {</span>
<span class="nc" id="L395">      c.incrementCount(key);</span>
<span class="nc" id="L396">    }</span>
<span class="nc" id="L397">    return new RVFDatum&lt;&gt;(c, labelIndex.get(labels[index]));</span>
  }

  /**
   * Prints some summary statistics to stderr for the Dataset.
   */
  @Override
  public void summaryStatistics() {
<span class="nc" id="L405">    logger.info(toSummaryStatistics());</span>
<span class="nc" id="L406">  }</span>

  /** A String that is multiple lines of text giving summary statistics.
   *  (It does not end with a newline, though.)
   *
   *  @return A textual summary of the Dataset
   */
  public String toSummaryStatistics() {
<span class="nc" id="L414">    StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L415">    sb.append(&quot;numDatums: &quot;).append(size).append('\n');</span>
<span class="nc" id="L416">    sb.append(&quot;numDatumsPerLabel: &quot;).append(this.numDatumsPerLabel()).append('\n');</span>
<span class="nc" id="L417">    sb.append(&quot;numLabels: &quot;).append(labelIndex.size()).append(&quot; [&quot;);</span>
<span class="nc" id="L418">    Iterator&lt;L&gt; iter = labelIndex.iterator();</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">    while (iter.hasNext()) {</span>
<span class="nc" id="L420">      sb.append(iter.next());</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">      if (iter.hasNext()) {</span>
<span class="nc" id="L422">        sb.append(&quot;, &quot;);</span>
      }
    }
<span class="nc" id="L425">    sb.append(&quot;]\n&quot;);</span>
<span class="nc" id="L426">    sb.append(&quot;numFeatures (Phi(X) types): &quot;).append(featureIndex.size()).append(&quot; [&quot;);</span>
<span class="nc" id="L427">    int sz = Math.min(5, featureIndex.size());</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">    for (int i = 0; i &lt; sz; i++) {</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">      if (i &gt; 0) {</span>
<span class="nc" id="L430">        sb.append(&quot;, &quot;);</span>
      }
<span class="nc" id="L432">      sb.append(featureIndex.get(i));</span>
    }
<span class="nc bnc" id="L434" title="All 2 branches missed.">    if (sz &lt; featureIndex.size()) {</span>
<span class="nc" id="L435">      sb.append(&quot;, ...&quot;);</span>
    }
<span class="nc" id="L437">    sb.append(']');</span>
<span class="nc" id="L438">    return sb.toString();</span>
  }


  /**
   * Applies feature count thresholds to the Dataset.
   * Only features that match pattern_i and occur at
   * least threshold_i times (for some i) are kept.
   *
   * @param thresholds a list of pattern, threshold pairs
   */
  public void applyFeatureCountThreshold(List&lt;Pair&lt;Pattern, Integer&gt;&gt; thresholds) {

    // get feature counts
<span class="nc" id="L452">    float[] counts = getFeatureCounts();</span>

    // build a new featureIndex
<span class="nc" id="L455">    Index&lt;F&gt; newFeatureIndex = new HashIndex&lt;&gt;();</span>
    LOOP:
<span class="nc bnc" id="L457" title="All 2 branches missed.">    for (F f : featureIndex) {</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">      for (Pair&lt;Pattern, Integer&gt; threshold : thresholds) {</span>
<span class="nc" id="L459">        Pattern p = threshold.first();</span>
<span class="nc" id="L460">        Matcher m = p.matcher(f.toString());</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">        if (m.matches()) {</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">          if (counts[featureIndex.indexOf(f)] &gt;= threshold.second) {</span>
<span class="nc" id="L463">            newFeatureIndex.add(f);</span>
          }
          continue LOOP;
        }
<span class="nc" id="L467">      }</span>
      // we only get here if it didn't match anything on the list
<span class="nc" id="L469">      newFeatureIndex.add(f);</span>
<span class="nc" id="L470">    }</span>

<span class="nc" id="L472">    counts = null;</span>

<span class="nc" id="L474">    int[] featMap = new int[featureIndex.size()];</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">    for (int i = 0; i &lt; featMap.length; i++) {</span>
<span class="nc" id="L476">      featMap[i] = newFeatureIndex.indexOf(featureIndex.get(i));</span>
    }

<span class="nc" id="L479">    featureIndex = null;</span>

<span class="nc bnc" id="L481" title="All 2 branches missed.">    for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L482">      List&lt;Integer&gt; featList = new ArrayList&lt;&gt;(data[i].length);</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">      for (int j = 0; j &lt; data[i].length; j++) {</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">        if (featMap[data[i][j]] &gt;= 0) {</span>
<span class="nc" id="L485">          featList.add(featMap[data[i][j]]);</span>
        }
      }
<span class="nc" id="L488">      data[i] = new int[featList.size()];</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">      for (int j = 0; j &lt; data[i].length; j++) {</span>
<span class="nc" id="L490">        data[i][j] = featList.get(j);</span>
      }
    }

<span class="nc" id="L494">    featureIndex = newFeatureIndex;</span>
<span class="nc" id="L495">  }</span>


  /**
   * prints the full feature matrix in tab-delimited form.  These can be BIG
   * matrices, so be careful!
   */
  public void printFullFeatureMatrix(PrintWriter pw) {
<span class="nc" id="L503">    String sep = &quot;\t&quot;;</span>
<span class="nc bnc" id="L504" title="All 2 branches missed.">    for (int i = 0; i &lt; featureIndex.size(); i++) {</span>
<span class="nc" id="L505">      pw.print(sep + featureIndex.get(i));</span>
    }
<span class="nc" id="L507">    pw.println();</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">    for (int i = 0; i &lt; labels.length; i++) {</span>
<span class="nc" id="L509">      pw.print(labelIndex.get(i));</span>
<span class="nc" id="L510">      Set&lt;Integer&gt; feats = Generics.newHashSet();</span>
<span class="nc bnc" id="L511" title="All 2 branches missed.">      for (int j = 0; j &lt; data[i].length; j++) {</span>
<span class="nc" id="L512">        int feature = data[i][j];</span>
<span class="nc" id="L513">        feats.add(Integer.valueOf(feature));</span>
      }
<span class="nc bnc" id="L515" title="All 2 branches missed.">      for (int j = 0; j &lt; featureIndex.size(); j++) {</span>
<span class="nc bnc" id="L516" title="All 2 branches missed.">        if (feats.contains(Integer.valueOf(j))) {</span>
<span class="nc" id="L517">          pw.print(sep + '1');</span>
        } else {
<span class="nc" id="L519">          pw.print(sep + '0');</span>
        }
      }
    }
<span class="nc" id="L523">  }</span>

  /** {@inheritDoc} */
  @Override
  public void printSparseFeatureMatrix() {
<span class="nc" id="L528">    printSparseFeatureMatrix(new PrintWriter(System.out, true));</span>
<span class="nc" id="L529">  }</span>

  /** {@inheritDoc} */
  @Override
  public void printSparseFeatureMatrix(PrintWriter pw) {
<span class="nc" id="L534">    String sep = &quot;\t&quot;;</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">    for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L536">      pw.print(labelIndex.get(labels[i]));</span>
<span class="nc" id="L537">      int[] datum = data[i];</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">      for (int j : datum) {</span>
<span class="nc" id="L539">        pw.print(sep + featureIndex.get(j));</span>
      }
<span class="nc" id="L541">      pw.println();</span>
    }
<span class="nc" id="L543">  }</span>


  public void changeLabelIndex(Index&lt;L&gt; newLabelIndex) {

<span class="nc" id="L548">    labels = trimToSize(labels);</span>

<span class="nc bnc" id="L550" title="All 2 branches missed.">    for (int i = 0; i &lt; labels.length; i++) {</span>
<span class="nc" id="L551">      labels[i] = newLabelIndex.indexOf(labelIndex.get(labels[i]));</span>
    }
<span class="nc" id="L553">    labelIndex = newLabelIndex;</span>
<span class="nc" id="L554">  }</span>

  public void changeFeatureIndex(Index&lt;F&gt; newFeatureIndex) {

<span class="nc" id="L558">    data = trimToSize(data);</span>
<span class="nc" id="L559">    labels = trimToSize(labels);</span>

<span class="nc" id="L561">    int[][] newData = new int[data.length][];</span>
<span class="nc bnc" id="L562" title="All 2 branches missed.">    for (int i = 0; i &lt; data.length; i++) {</span>
<span class="nc" id="L563">      int[] newD = new int[data[i].length];</span>
<span class="nc" id="L564">      int k = 0;</span>
<span class="nc bnc" id="L565" title="All 2 branches missed.">      for (int j = 0; j &lt; data[i].length; j++) {</span>
<span class="nc" id="L566">        int newIndex = newFeatureIndex.indexOf(featureIndex.get(data[i][j]));</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">        if (newIndex &gt;= 0) {</span>
<span class="nc" id="L568">          newD[k++] = newIndex;</span>
        }
      }
<span class="nc" id="L571">      newData[i] = new int[k];</span>
<span class="nc" id="L572">      synchronized (System.class) {</span>
<span class="nc" id="L573">        System.arraycopy(newD, 0, newData[i], 0, k);</span>
<span class="nc" id="L574">      }</span>
    }
<span class="nc" id="L576">    data = newData;</span>
<span class="nc" id="L577">    featureIndex = newFeatureIndex;</span>
<span class="nc" id="L578">  }</span>

  public void selectFeaturesBinaryInformationGain(int numFeatures) {
<span class="nc" id="L581">    double[] scores = getInformationGains();</span>
<span class="nc" id="L582">    selectFeatures(numFeatures,scores);</span>
<span class="nc" id="L583">  }</span>

  /**
   * Generic method to select features based on the feature scores vector provided as an argument.
   * @param numFeatures number of features to be selected.
   * @param scores a vector of size total number of features in the data.
   */
  public void selectFeatures(int numFeatures, double[] scores) {

<span class="nc" id="L592">    List&lt;ScoredObject&lt;F&gt;&gt; scoredFeatures = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L594" title="All 2 branches missed.">    for (int i = 0; i &lt; scores.length; i++) {</span>
<span class="nc" id="L595">      scoredFeatures.add(new ScoredObject&lt;&gt;(featureIndex.get(i), scores[i]));</span>
    }

<span class="nc" id="L598">    Collections.sort(scoredFeatures, ScoredComparator.DESCENDING_COMPARATOR);</span>
<span class="nc" id="L599">    Index&lt;F&gt; newFeatureIndex = new HashIndex&lt;&gt;();</span>
<span class="nc bnc" id="L600" title="All 4 branches missed.">    for (int i = 0; i &lt; scoredFeatures.size() &amp;&amp; i &lt; numFeatures; i++) {</span>
<span class="nc" id="L601">      newFeatureIndex.add(scoredFeatures.get(i).object());</span>
      //logger.info(scoredFeatures.get(i));
    }

<span class="nc bnc" id="L605" title="All 2 branches missed.">    for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L606">      int[] newData = new int[data[i].length];</span>
<span class="nc" id="L607">      int curIndex = 0;</span>
<span class="nc bnc" id="L608" title="All 2 branches missed.">      for (int j = 0; j &lt; data[i].length; j++) {</span>
        int index;
<span class="nc bnc" id="L610" title="All 2 branches missed.">        if ((index = newFeatureIndex.indexOf(featureIndex.get(data[i][j]))) != -1) {</span>
<span class="nc" id="L611">          newData[curIndex++] = index;</span>
        }
      }
<span class="nc" id="L614">      int[] newDataTrimmed = new int[curIndex];</span>
<span class="nc" id="L615">      synchronized (System.class) {</span>
<span class="nc" id="L616">        System.arraycopy(newData, 0, newDataTrimmed, 0, curIndex);</span>
<span class="nc" id="L617">      }</span>
<span class="nc" id="L618">      data[i] = newDataTrimmed;</span>
    }
<span class="nc" id="L620">    featureIndex = newFeatureIndex;</span>
<span class="nc" id="L621">  }</span>


  public double[] getInformationGains() {

//    assert size &gt; 0;
//    data = trimToSize(data);  // Don't need to trim to size, and trimming is dangerous the dataset is empty (you can't add to it thereafter)
<span class="nc" id="L628">    labels = trimToSize(labels);</span>

    // counts the number of times word X is present
<span class="nc" id="L631">    ClassicCounter&lt;F&gt; featureCounter = new ClassicCounter&lt;&gt;();</span>

    // counts the number of time a document has label Y
<span class="nc" id="L634">    ClassicCounter&lt;L&gt; labelCounter = new ClassicCounter&lt;&gt;();</span>

    // counts the number of times the document has label Y given word X is present
<span class="nc" id="L637">    TwoDimensionalCounter&lt;F,L&gt; condCounter = new TwoDimensionalCounter&lt;&gt;();</span>

<span class="nc bnc" id="L639" title="All 2 branches missed.">    for (int i = 0; i &lt; labels.length; i++) {</span>
<span class="nc" id="L640">      labelCounter.incrementCount(labelIndex.get(labels[i]));</span>

      // convert the document to binary feature representation
<span class="nc" id="L643">      boolean[] doc = new boolean[featureIndex.size()];</span>
      //logger.info(i);
<span class="nc bnc" id="L645" title="All 2 branches missed.">      for (int j = 0; j &lt; data[i].length; j++) {</span>
<span class="nc" id="L646">        doc[data[i][j]] = true;</span>
      }

<span class="nc bnc" id="L649" title="All 2 branches missed.">      for (int j = 0; j &lt; doc.length; j++) {</span>
<span class="nc bnc" id="L650" title="All 2 branches missed.">        if (doc[j]) {</span>
<span class="nc" id="L651">          featureCounter.incrementCount(featureIndex.get(j));</span>
<span class="nc" id="L652">          condCounter.incrementCount(featureIndex.get(j), labelIndex.get(labels[i]), 1.0);</span>
        }
      }
    }

<span class="nc" id="L657">    double entropy = 0.0;</span>
<span class="nc bnc" id="L658" title="All 2 branches missed.">    for (int i = 0; i &lt; labelIndex.size(); i++) {</span>
<span class="nc" id="L659">      double labelCount = labelCounter.getCount(labelIndex.get(i));</span>
<span class="nc" id="L660">      double p = labelCount / size();</span>
<span class="nc" id="L661">      entropy -= p * (Math.log(p) / Math.log(2));</span>
    }

<span class="nc" id="L664">    double[] ig = new double[featureIndex.size()];</span>
<span class="nc" id="L665">    Arrays.fill(ig, entropy);</span>

<span class="nc bnc" id="L667" title="All 2 branches missed.">    for (int i = 0; i &lt; featureIndex.size(); i++) {</span>
<span class="nc" id="L668">      F feature = featureIndex.get(i);</span>

<span class="nc" id="L670">      double featureCount = featureCounter.getCount(feature);</span>
<span class="nc" id="L671">      double notFeatureCount = size() - featureCount;</span>

<span class="nc" id="L673">      double pFeature =  featureCount / size();</span>
<span class="nc" id="L674">      double pNotFeature = (1.0 - pFeature);</span>

<span class="nc bnc" id="L676" title="All 2 branches missed.">      if (featureCount == 0) { ig[i] = 0; continue; }</span>
<span class="nc bnc" id="L677" title="All 2 branches missed.">      if (notFeatureCount == 0) { ig[i] = 0; continue; }</span>

<span class="nc" id="L679">      double sumFeature = 0.0;</span>
<span class="nc" id="L680">      double sumNotFeature = 0.0;</span>

<span class="nc bnc" id="L682" title="All 2 branches missed.">      for (int j = 0; j &lt; labelIndex.size(); j++) {</span>
<span class="nc" id="L683">        L label = labelIndex.get(j);</span>

<span class="nc" id="L685">        double featureLabelCount = condCounter.getCount(feature, label);</span>
<span class="nc" id="L686">        double notFeatureLabelCount = size() - featureLabelCount;</span>

        // yes, these dont sum to 1.  that is correct.
        // one is the prob of the label, given that the
        // feature is present, and the other is the prob
        // of the label given that the feature is absent
<span class="nc" id="L692">        double p = featureLabelCount / featureCount;</span>
<span class="nc" id="L693">        double pNot = notFeatureLabelCount / notFeatureCount;</span>

<span class="nc bnc" id="L695" title="All 2 branches missed.">        if (featureLabelCount != 0) {</span>
<span class="nc" id="L696">          sumFeature += p * (Math.log(p) / Math.log(2));</span>
        }

<span class="nc bnc" id="L699" title="All 2 branches missed.">        if (notFeatureLabelCount != 0) {</span>
<span class="nc" id="L700">          sumNotFeature += pNot * (Math.log(pNot) / Math.log(2));</span>
        }
        //System.out.println(pNot+&quot; &quot;+(Math.log(pNot)/Math.log(2)));

      }

        //logger.info(pFeature+&quot; * &quot;+sumFeature+&quot; = +&quot;+);
        //logger.info(&quot;^ &quot;+pNotFeature+&quot; &quot;+sumNotFeature);

<span class="nc" id="L709">      ig[i] += pFeature*sumFeature + pNotFeature*sumNotFeature;</span>
      /* earlier the line above used to be: ig[i] = pFeature*sumFeature + pNotFeature*sumNotFeature;
       * This completely ignored the entropy term computed above. So added the &quot;+=&quot; to take that into account.
       * -Ramesh (nmramesh@cs.stanford.edu)
       */
    }
<span class="nc" id="L715">    return ig;</span>
  }

  public void updateLabels(int[] labels) {
<span class="nc bnc" id="L719" title="All 2 branches missed.">    if (labels.length != size())</span>
<span class="nc" id="L720">      throw new IllegalArgumentException(</span>
          &quot;size of labels array does not match dataset size&quot;);

<span class="nc" id="L723">    this.labels = labels;</span>
<span class="nc" id="L724">  }</span>

  @Override
  public String toString() {
<span class="nc" id="L728">    return &quot;Dataset of size &quot; + size;</span>
  }

  public String toSummaryString() {
<span class="nc" id="L732">    StringWriter sw = new StringWriter();</span>
<span class="nc" id="L733">    PrintWriter pw = new PrintWriter(sw);</span>
<span class="nc" id="L734">    pw.println(&quot;Number of data points: &quot; + size());</span>
<span class="nc" id="L735">    pw.println(&quot;Number of active feature tokens: &quot; + numFeatureTokens());</span>
<span class="nc" id="L736">    pw.println(&quot;Number of active feature types:&quot; + numFeatureTypes());</span>
<span class="nc" id="L737">    return pw.toString();</span>
  }

  /**
   * Need to sort the counter by feature keys and dump it
   *
   */
  public static void printSVMLightFormat(PrintWriter pw, ClassicCounter&lt;Integer&gt; c, int classNo) {
<span class="nc" id="L745">    Integer[] features = c.keySet().toArray(new Integer[c.keySet().size()]);</span>
<span class="nc" id="L746">    Arrays.sort(features);</span>
<span class="nc" id="L747">    StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L748">    sb.append(classNo);</span>
<span class="nc" id="L749">    sb.append(' ');</span>
<span class="nc bnc" id="L750" title="All 2 branches missed.">    for (int f: features) {</span>
<span class="nc" id="L751">      sb.append(f + 1).append(':').append(c.getCount(f)).append(' ');</span>
    }
<span class="nc" id="L753">    pw.println(sb.toString());</span>
<span class="nc" id="L754">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>