<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DocumentPreprocessor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.coref.data</a> &gt; <span class="el_source">DocumentPreprocessor.java</span></div><h1>DocumentPreprocessor.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.coref.data;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

import edu.stanford.nlp.classify.LogisticClassifier;
import edu.stanford.nlp.coref.CorefRules;
import edu.stanford.nlp.coref.CorefUtils;
import edu.stanford.nlp.coref.data.Document.DocType;
import edu.stanford.nlp.coref.data.Dictionaries.Number;
import edu.stanford.nlp.ling.CoreAnnotations;
import edu.stanford.nlp.ling.CoreAnnotations.SentencesAnnotation;
import edu.stanford.nlp.ling.CoreAnnotations.SpeakerAnnotation;
import edu.stanford.nlp.ling.CoreAnnotations.TokensAnnotation;
import edu.stanford.nlp.ling.CoreAnnotations.UtteranceAnnotation;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.ling.IndexedWord;
import edu.stanford.nlp.math.NumberMatchingRegex;
import edu.stanford.nlp.semgraph.SemanticGraph;
import edu.stanford.nlp.semgraph.SemanticGraphCoreAnnotations;
import edu.stanford.nlp.semgraph.SemanticGraphCoreAnnotations.BasicDependenciesAnnotation;
import edu.stanford.nlp.semgraph.SemanticGraphEdge;
import edu.stanford.nlp.trees.GrammaticalRelation;
import edu.stanford.nlp.trees.HeadFinder;
import edu.stanford.nlp.trees.Tree;
import edu.stanford.nlp.trees.TreeCoreAnnotations.TreeAnnotation;
import edu.stanford.nlp.trees.UniversalEnglishGrammaticalRelations;
import edu.stanford.nlp.util.CollectionValuedMap;
import edu.stanford.nlp.util.CoreMap;
import edu.stanford.nlp.util.Generics;
import edu.stanford.nlp.util.IntPair;
import edu.stanford.nlp.util.IntTuple;
import edu.stanford.nlp.util.Pair;
import edu.stanford.nlp.util.logging.Redwood;

/**
 * Coref document preprocessor.
 * @author Heeyoung Lee
 * @author Kevin Clark
 */
public class DocumentPreprocessor  {

  /** A logger for this class */
<span class="nc" id="L51">  private static Redwood.RedwoodChannels log = Redwood.channels(DocumentPreprocessor.class);</span>

<span class="nc" id="L53">  private DocumentPreprocessor() {}</span>

  /**
   * Fill missing information in document including mention ID, mention attributes, syntactic relation, etc.
   *
   * @throws Exception
   */
  public static void preprocess(Document doc, Dictionaries dict, LogisticClassifier&lt;String, String&gt; singletonPredictor, HeadFinder headFinder) throws Exception {
    // assign mention IDs, find twin mentions, fill mention positions, sentNum, headpositions
<span class="nc" id="L62">    initializeMentions(doc, dict, singletonPredictor, headFinder);</span>

    // mention reordering
<span class="nc" id="L65">    mentionReordering(doc, headFinder);</span>

    // find syntactic information
<span class="nc" id="L68">    fillSyntacticInfo(doc);</span>

    // process discourse (speaker info etc)
<span class="nc" id="L71">    setParagraphAnnotation(doc);</span>
<span class="nc" id="L72">    processDiscourse(doc, dict);</span>

    // initialize cluster info
<span class="nc" id="L75">    initializeClusters(doc);</span>

    // extract gold clusters if we have
<span class="nc bnc" id="L78" title="All 2 branches missed.">    if(doc.goldMentions!=null) {</span>
<span class="nc" id="L79">      extractGoldClusters(doc);</span>
<span class="nc" id="L80">      int foundGoldCount = 0;</span>
<span class="nc bnc" id="L81" title="All 2 branches missed.">      for(Mention g : doc.goldMentionsByID.values()) {</span>
<span class="nc bnc" id="L82" title="All 2 branches missed.">        if(g.hasTwin) foundGoldCount++;</span>
<span class="nc" id="L83">      }</span>
<span class="nc" id="L84">      Redwood.log(&quot;debug-md&quot;, &quot;# of found gold mentions: &quot;+ foundGoldCount +</span>
<span class="nc" id="L85">          &quot; / # of gold mentions: &quot;+ doc.goldMentionsByID.size());</span>

    }

    // assign mention numbers
<span class="nc" id="L90">    assignMentionNumbers(doc);</span>
<span class="nc" id="L91">  }</span>

  /** Extract gold coref cluster information. */
  public static void extractGoldClusters(Document doc){
<span class="nc" id="L95">    doc.goldCorefClusters = Generics.newHashMap();</span>
<span class="nc bnc" id="L96" title="All 2 branches missed.">    for (List&lt;Mention&gt; mentions : doc.goldMentions) {</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">      for (Mention m : mentions) {</span>
<span class="nc" id="L98">        int id = m.goldCorefClusterID;</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">        if (id == -1) {</span>
<span class="nc" id="L100">          throw new RuntimeException(&quot;No gold info&quot;);</span>
        }
<span class="nc" id="L102">        CorefCluster c = doc.goldCorefClusters.get(id);</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L104">          c = new CorefCluster(id);</span>
<span class="nc" id="L105">          doc.goldCorefClusters.put(id, c);</span>
        }
<span class="nc" id="L107">        c.corefMentions.add(m);</span>
<span class="nc" id="L108">      }</span>
<span class="nc" id="L109">    }</span>
<span class="nc" id="L110">  }</span>

  private static void assignMentionNumbers(Document document) {
<span class="nc" id="L113">    List&lt;Mention&gt; mentionsList = CorefUtils.getSortedMentions(document);</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">    for (int i = 0; i &lt; mentionsList.size(); i++) {</span>
<span class="nc" id="L115">      mentionsList.get(i).mentionNum = i;</span>
    }
<span class="nc" id="L117">  }</span>


  private static void mentionReordering(Document doc, HeadFinder headFinder) throws Exception {
<span class="nc" id="L121">    List&lt;List&lt;Mention&gt;&gt; mentions = doc.predictedMentions;</span>
<span class="nc" id="L122">    List&lt;CoreMap&gt; sentences = doc.annotation.get(SentencesAnnotation.class);</span>

<span class="nc bnc" id="L124" title="All 2 branches missed.">    for (int i=0 ; i&lt;sentences.size() ; i++) {</span>
<span class="nc" id="L125">      List&lt;Mention&gt; mentionsInSent = mentions.get(i);</span>
<span class="nc" id="L126">      mentions.set(i, mentionReorderingBySpan(mentionsInSent));</span>
    }
<span class="nc" id="L128">  }</span>

  protected static int getHeadIndex(Tree t, HeadFinder headFinder) {
    // The trees passed in do not have the CoordinationTransformer
    // applied, but that just means the SemanticHeadFinder results are
    // slightly worse.
<span class="nc" id="L134">    Tree ht = t.headTerminal(headFinder);</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">    if(ht==null) return -1;  // temporary: a key which is matched to nothing</span>
<span class="nc" id="L136">    CoreLabel l = (CoreLabel) ht.label();</span>
<span class="nc" id="L137">    return l.get(CoreAnnotations.IndexAnnotation.class);</span>
  }

  private static List&lt;Mention&gt; mentionReorderingBySpan(List&lt;Mention&gt; mentionsInSent) {
<span class="nc" id="L141">    TreeSet&lt;Mention&gt; ordering = new TreeSet&lt;&gt;(new Comparator&lt;Mention&gt;() {</span>
      @Override
      public int compare(Mention m1, Mention m2) {
<span class="nc bnc" id="L144" title="All 4 branches missed.">        return (m1.appearEarlierThan(m2)) ? -1 : (m2.appearEarlierThan(m1)) ? 1 : 0;</span>
      }
    });
<span class="nc" id="L147">    ordering.addAll(mentionsInSent);</span>
<span class="nc" id="L148">    List&lt;Mention&gt; orderedMentions = Generics.newArrayList(ordering);</span>
<span class="nc" id="L149">    return orderedMentions;</span>
  }

  private static void fillSyntacticInfo(Document doc) {

<span class="nc" id="L154">    List&lt;List&lt;Mention&gt;&gt; mentions = doc.predictedMentions;</span>
<span class="nc" id="L155">    List&lt;CoreMap&gt; sentences = doc.annotation.get(SentencesAnnotation.class);</span>

<span class="nc bnc" id="L157" title="All 2 branches missed.">    for (int i=0 ; i&lt;sentences.size() ; i++) {</span>
<span class="nc" id="L158">      List&lt;Mention&gt; mentionsInSent = mentions.get(i);</span>
<span class="nc" id="L159">      findSyntacticRelationsFromDependency(mentionsInSent);</span>
    }
<span class="nc" id="L161">  }</span>

  /** assign mention IDs, find twin mentions, fill mention positions, initialize coref clusters, etc
   * @throws Exception */
  private static void initializeMentions(Document doc, Dictionaries dict, LogisticClassifier&lt;String, String&gt; singletonPredictor, HeadFinder headFinder) throws Exception {
<span class="nc bnc" id="L166" title="All 2 branches missed.">    boolean hasGold = (doc.goldMentions != null);</span>
<span class="nc" id="L167">    assignMentionIDs(doc);</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">    if(hasGold) findTwinMentions(doc, true);</span>
<span class="nc" id="L169">    fillMentionInfo(doc, dict, singletonPredictor, headFinder);</span>
<span class="nc" id="L170">    doc.allPositions = Generics.newHashMap(doc.positions);    // allPositions retain all mentions even after postprocessing</span>
<span class="nc" id="L171">  }</span>

  private static void assignMentionIDs(Document doc) {
<span class="nc bnc" id="L174" title="All 2 branches missed.">    boolean hasGold = (doc.goldMentions != null);</span>
<span class="nc" id="L175">    int maxID = 0;</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">    if(hasGold) {</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">      for (List&lt;Mention&gt; golds : doc.goldMentions) {</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">        for (Mention g : golds) {</span>
<span class="nc" id="L179">          g.mentionID = maxID++;</span>
<span class="nc" id="L180">        }</span>
<span class="nc" id="L181">      }</span>
    }
<span class="nc bnc" id="L183" title="All 2 branches missed.">    for (List&lt;Mention&gt; predicted : doc.predictedMentions) {</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">      for (Mention p : predicted) {</span>
<span class="nc" id="L185">        p.mentionID = maxID++;</span>
<span class="nc" id="L186">      }</span>
<span class="nc" id="L187">    }</span>
<span class="nc" id="L188">  }</span>

  /** Mark twin mentions in gold and predicted mentions */
  protected static void findTwinMentions(Document doc, boolean strict){
<span class="nc bnc" id="L192" title="All 2 branches missed.">    if(strict) findTwinMentionsStrict(doc);</span>
<span class="nc" id="L193">    else findTwinMentionsRelaxed(doc);</span>
<span class="nc" id="L194">  }</span>

  /** Mark twin mentions: All mention boundaries should be matched */
  private static void findTwinMentionsStrict(Document doc){
<span class="nc bnc" id="L198" title="All 2 branches missed.">    for(int sentNum = 0; sentNum &lt; doc.goldMentions.size(); sentNum++) {</span>
<span class="nc" id="L199">      List&lt;Mention&gt; golds = doc.goldMentions.get(sentNum);</span>
<span class="nc" id="L200">      List&lt;Mention&gt; predicts = doc.predictedMentions.get(sentNum);</span>

      // For CoNLL training there are some documents with gold mentions with the same position offsets
      // See /scr/nlp/data/conll-2011/v2/data/train/data/english/annotations/nw/wsj/09/wsj_0990.v2_auto_conll
      //  (Packwood - Roth)
<span class="nc" id="L205">      CollectionValuedMap&lt;IntPair, Mention&gt; goldMentionPositions = new CollectionValuedMap&lt;&gt;();</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">      for(Mention g : golds) {</span>
<span class="nc" id="L207">        IntPair ip = new IntPair(g.startIndex, g.endIndex);</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">        if (goldMentionPositions.containsKey(ip)) {</span>
<span class="nc" id="L209">          StringBuilder existingMentions = new StringBuilder();</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">          for (Mention eg: goldMentionPositions.get(ip)) {</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">            if (existingMentions.length() &gt; 0) {</span>
<span class="nc" id="L212">              existingMentions.append(&quot;,&quot;);</span>
            }
<span class="nc" id="L214">            existingMentions.append(eg.mentionID);</span>
<span class="nc" id="L215">          }</span>
<span class="nc" id="L216">          Redwood.log(&quot;debug-preprocessor&quot;, &quot;WARNING: gold mentions with the same offsets: &quot; + ip</span>
<span class="nc" id="L217">                  + &quot; mentions=&quot; + g.mentionID + &quot;,&quot; + existingMentions + &quot;, &quot; + g.spanToString());</span>
        }
        //assert(!goldMentionPositions.containsKey(ip));
<span class="nc" id="L220">        goldMentionPositions.add(new IntPair(g.startIndex, g.endIndex), g);</span>
<span class="nc" id="L221">      }</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">      for(Mention p : predicts) {</span>
<span class="nc" id="L223">        IntPair pos = new IntPair(p.startIndex, p.endIndex);</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">        if(goldMentionPositions.containsKey(pos)) {</span>
<span class="nc" id="L225">          Collection&lt;Mention&gt; cm = goldMentionPositions.get(pos);</span>
<span class="nc" id="L226">          int minId = Integer.MAX_VALUE;</span>
<span class="nc" id="L227">          Mention g = null;</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">          for (Mention m : cm) {</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">            if (m.mentionID &lt; minId) {</span>
<span class="nc" id="L230">              g = m;</span>
<span class="nc" id="L231">              minId = m.mentionID;</span>
            }
<span class="nc" id="L233">          }</span>
<span class="nc" id="L234">          cm.remove(g);</span>
<span class="nc" id="L235">          p.mentionID = g.mentionID;</span>
<span class="nc" id="L236">          p.hasTwin = true;</span>
<span class="nc" id="L237">          g.hasTwin = true;</span>
        }
<span class="nc" id="L239">      }</span>
    }
<span class="nc" id="L241">  }</span>

  /** Mark twin mentions: heads of the mentions are matched */
  private static void findTwinMentionsRelaxed(Document doc) {
<span class="nc bnc" id="L245" title="All 2 branches missed.">    for(int sentNum = 0; sentNum &lt; doc.goldMentions.size(); sentNum++) {</span>
<span class="nc" id="L246">      List&lt;Mention&gt; golds = doc.goldMentions.get(sentNum);</span>
<span class="nc" id="L247">      List&lt;Mention&gt; predicts = doc.predictedMentions.get(sentNum);</span>

<span class="nc" id="L249">      Map&lt;IntPair, Mention&gt; goldMentionPositions = Generics.newHashMap();</span>
<span class="nc" id="L250">      Map&lt;Integer, LinkedList&lt;Mention&gt;&gt; goldMentionHeadPositions = Generics.newHashMap();</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">      for(Mention g : golds) {</span>
<span class="nc" id="L252">        goldMentionPositions.put(new IntPair(g.startIndex, g.endIndex), g);</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">        if(!goldMentionHeadPositions.containsKey(g.headIndex)) {</span>
<span class="nc" id="L254">          goldMentionHeadPositions.put(g.headIndex, new LinkedList&lt;&gt;());</span>
        }
<span class="nc" id="L256">        goldMentionHeadPositions.get(g.headIndex).add(g);</span>
<span class="nc" id="L257">      }</span>

<span class="nc" id="L259">      List&lt;Mention&gt; remains = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">      for (Mention p : predicts) {</span>
<span class="nc" id="L261">        IntPair pos = new IntPair(p.startIndex, p.endIndex);</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">        if(goldMentionPositions.containsKey(pos)) {</span>
<span class="nc" id="L263">          Mention g = goldMentionPositions.get(pos);</span>
<span class="nc" id="L264">          p.mentionID = g.mentionID;</span>
<span class="nc" id="L265">          p.hasTwin = true;</span>
<span class="nc" id="L266">          g.hasTwin = true;</span>
<span class="nc" id="L267">          goldMentionHeadPositions.get(g.headIndex).remove(g);</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">          if(goldMentionHeadPositions.get(g.headIndex).isEmpty()) {</span>
<span class="nc" id="L269">            goldMentionHeadPositions.remove(g.headIndex);</span>
          }
<span class="nc" id="L271">        }</span>
<span class="nc" id="L272">        else remains.add(p);</span>
<span class="nc" id="L273">      }</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">      for (Mention r : remains){</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">        if(goldMentionHeadPositions.containsKey(r.headIndex)) {</span>
<span class="nc" id="L276">          Mention g = goldMentionHeadPositions.get(r.headIndex).poll();</span>
<span class="nc" id="L277">          r.mentionID = g.mentionID;</span>
<span class="nc" id="L278">          r.hasTwin = true;</span>
<span class="nc" id="L279">          g.hasTwin = true;</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">          if(goldMentionHeadPositions.get(g.headIndex).isEmpty()) {</span>
<span class="nc" id="L281">            goldMentionHeadPositions.remove(g.headIndex);</span>
          }
        }
<span class="nc" id="L284">      }</span>
    }
<span class="nc" id="L286">  }</span>

  /** initialize several variables for mentions
   * @throws Exception
   */
  private static void fillMentionInfo(Document doc, Dictionaries dict,
      LogisticClassifier&lt;String, String&gt; singletonPredictor, HeadFinder headFinder) throws Exception {
<span class="nc" id="L293">    List&lt;CoreMap&gt; sentences = doc.annotation.get(SentencesAnnotation.class);</span>

<span class="nc bnc" id="L295" title="All 2 branches missed.">    for(int i = 0; i &lt; doc.predictedMentions.size(); i ++){</span>
<span class="nc" id="L296">      CoreMap sentence = sentences.get(i);</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">      for(int j = 0; j &lt; doc.predictedMentions.get(i).size(); j ++){</span>
<span class="nc" id="L298">        Mention m = doc.predictedMentions.get(i).get(j);</span>
<span class="nc" id="L299">        doc.predictedMentionsByID.put(m.mentionID, m);      // mentionsByID</span>

<span class="nc" id="L301">        IntTuple pos = new IntTuple(2);</span>
<span class="nc" id="L302">        pos.set(0, i);</span>
<span class="nc" id="L303">        pos.set(1, j);</span>
<span class="nc" id="L304">        doc.positions.put(m, pos);        // positions</span>
<span class="nc" id="L305">        m.sentNum = i;                    // sentNum</span>

<span class="nc" id="L307">        IntTuple headPosition = new IntTuple(2);</span>
<span class="nc" id="L308">        headPosition.set(0, i);</span>
<span class="nc" id="L309">        headPosition.set(1, m.headIndex);</span>
<span class="nc" id="L310">        doc.mentionheadPositions.put(headPosition, m);    // headPositions</span>

<span class="nc" id="L312">        m.contextParseTree = sentence.get(TreeAnnotation.class);</span>
//        m.sentenceWords = sentence.get(TokensAnnotation.class);
<span class="nc" id="L314">        m.basicDependency = sentence.get(BasicDependenciesAnnotation.class);</span>
<span class="nc" id="L315">        m.enhancedDependency = sentence.get(SemanticGraphCoreAnnotations.EnhancedDependenciesAnnotation.class);</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">        if (m.enhancedDependency == null) {</span>
<span class="nc" id="L317">          m.enhancedDependency = sentence.get(SemanticGraphCoreAnnotations.BasicDependenciesAnnotation.class);</span>
        }

        // mentionSubTree (highest NP that has the same head) if constituency tree available
<span class="nc bnc" id="L321" title="All 2 branches missed.">        if (m.contextParseTree != null) {</span>
<span class="nc" id="L322">          Tree headTree = m.contextParseTree.getLeaves().get(m.headIndex);</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">          if (headTree == null) { throw new RuntimeException(&quot;Missing head tree for a mention!&quot;); }</span>
<span class="nc" id="L324">          Tree t = headTree;</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">          while ((t = t.parent(m.contextParseTree)) != null) {</span>
<span class="nc bnc" id="L326" title="All 4 branches missed.">            if (t.headTerminal(headFinder) == headTree &amp;&amp; t.value().equals(&quot;NP&quot;)) {</span>
<span class="nc" id="L327">              m.mentionSubTree = t;</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">            } else if(m.mentionSubTree != null){</span>
<span class="nc" id="L329">              break;</span>
            }
          }
<span class="nc bnc" id="L332" title="All 2 branches missed.">          if (m.mentionSubTree == null) {</span>
<span class="nc" id="L333">            m.mentionSubTree = headTree;</span>
          }
        }

<span class="nc" id="L337">        m.process(dict, null, singletonPredictor);</span>
      }
    }


<span class="nc bnc" id="L342" title="All 2 branches missed.">    boolean hasGold = (doc.goldMentions != null);</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">    if(hasGold) {</span>
<span class="nc" id="L344">      doc.goldMentionsByID = Generics.newHashMap();</span>
<span class="nc" id="L345">      int sentNum = 0;</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">      for(List&lt;Mention&gt; golds : doc.goldMentions) {</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">        for(Mention g : golds) {</span>
<span class="nc" id="L348">          doc.goldMentionsByID.put(g.mentionID, g);</span>
<span class="nc" id="L349">          g.sentNum = sentNum;</span>
<span class="nc" id="L350">        }</span>
<span class="nc" id="L351">        sentNum++;</span>
<span class="nc" id="L352">      }</span>
    }
<span class="nc" id="L354">  }</span>

  private static void findSyntacticRelationsFromDependency(List&lt;Mention&gt; orderedMentions) {
<span class="nc bnc" id="L357" title="All 2 branches missed.">    if(orderedMentions.size()==0) return;</span>
<span class="nc" id="L358">    markListMemberRelation(orderedMentions);</span>
<span class="nc" id="L359">    SemanticGraph dependency = orderedMentions.get(0).enhancedDependency;</span>

    // apposition
<span class="nc" id="L362">    Set&lt;Pair&lt;Integer, Integer&gt;&gt; appos = Generics.newHashSet();</span>
<span class="nc" id="L363">    List&lt;SemanticGraphEdge&gt; appositions = dependency.findAllRelns(UniversalEnglishGrammaticalRelations.APPOSITIONAL_MODIFIER);</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">    for(SemanticGraphEdge edge : appositions) {</span>
<span class="nc" id="L365">      int sIdx = edge.getSource().index()-1;</span>
<span class="nc" id="L366">      int tIdx = edge.getTarget().index()-1;</span>
<span class="nc" id="L367">      appos.add(Pair.makePair(sIdx, tIdx));</span>
<span class="nc" id="L368">    }</span>
<span class="nc" id="L369">    markMentionRelation(orderedMentions, appos, &quot;APPOSITION&quot;);</span>

    // predicate nominatives
<span class="nc" id="L372">    Set&lt;Pair&lt;Integer, Integer&gt;&gt; preNomi = Generics.newHashSet();</span>
<span class="nc" id="L373">    List&lt;SemanticGraphEdge&gt; copula = dependency.findAllRelns(UniversalEnglishGrammaticalRelations.COPULA);</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">    for(SemanticGraphEdge edge : copula) {</span>
<span class="nc" id="L375">      IndexedWord source = edge.getSource();</span>
<span class="nc" id="L376">      IndexedWord target = dependency.getChildWithReln(source, UniversalEnglishGrammaticalRelations.NOMINAL_SUBJECT);</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">      if(target==null) target = dependency.getChildWithReln(source, UniversalEnglishGrammaticalRelations.CLAUSAL_SUBJECT);</span>
      // TODO
<span class="nc bnc" id="L379" title="All 2 branches missed.">      if(target == null) continue;</span>

      // to handle relative clause: e.g., Tim who is a student,
<span class="nc bnc" id="L382" title="All 2 branches missed.">      if(target.tag().startsWith(&quot;W&quot;)) {</span>
<span class="nc" id="L383">        IndexedWord parent = dependency.getParent(source);</span>
<span class="nc bnc" id="L384" title="All 4 branches missed.">        if(parent!=null &amp;&amp; dependency.reln(parent, source).equals(UniversalEnglishGrammaticalRelations.RELATIVE_CLAUSE_MODIFIER)) {</span>
<span class="nc" id="L385">          target = parent;</span>
        }
      }
<span class="nc" id="L388">      int sIdx = source.index()-1;</span>
<span class="nc" id="L389">      int tIdx = target.index()-1;</span>
<span class="nc" id="L390">      preNomi.add(Pair.makePair(tIdx, sIdx));</span>
<span class="nc" id="L391">    }</span>
<span class="nc" id="L392">    markMentionRelation(orderedMentions, preNomi, &quot;PREDICATE_NOMINATIVE&quot;);</span>


    // relative pronouns  TODO
<span class="nc" id="L396">    Set&lt;Pair&lt;Integer, Integer&gt;&gt; relativePronounPairs = Generics.newHashSet();</span>
<span class="nc" id="L397">    markMentionRelation(orderedMentions, relativePronounPairs, &quot;RELATIVE_PRONOUN&quot;);</span>
<span class="nc" id="L398">  }</span>

  private static void initializeClusters(Document doc) {
<span class="nc bnc" id="L401" title="All 2 branches missed.">    for (List&lt;Mention&gt; predicted : doc.predictedMentions) {</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">      for (Mention p : predicted) {</span>
<span class="nc" id="L403">        doc.corefClusters.put(p.mentionID, new CorefCluster(p.mentionID, Generics.newHashSet(Arrays.asList(p))));</span>
<span class="nc" id="L404">        p.corefClusterID = p.mentionID;</span>
<span class="nc" id="L405">      }</span>
<span class="nc" id="L406">    }</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">    boolean hasGold = (doc.goldMentions != null);</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">    if(hasGold) {</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">      for(List&lt;Mention&gt; golds : doc.goldMentions) {</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">        for(Mention g : golds) {</span>
<span class="nc" id="L411">          doc.goldMentionsByID.put(g.mentionID, g);</span>
<span class="nc" id="L412">        }</span>
<span class="nc" id="L413">      }</span>
    }
<span class="nc" id="L415">  }</span>

  /** Find document type: Conversation or article  */
  private static DocType findDocType(Document doc) {
<span class="nc" id="L419">    boolean speakerChange = false;</span>

<span class="nc bnc" id="L421" title="All 2 branches missed.">    for(CoreMap sent : doc.annotation.get(CoreAnnotations.SentencesAnnotation.class)) {</span>
<span class="nc bnc" id="L422" title="All 2 branches missed.">      for(CoreLabel w : sent.get(CoreAnnotations.TokensAnnotation.class)) {</span>
<span class="nc" id="L423">        int utterIndex = w.get(CoreAnnotations.UtteranceAnnotation.class);</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">        if(utterIndex!=0) speakerChange = true;</span>
<span class="nc bnc" id="L425" title="All 4 branches missed.">        if(speakerChange &amp;&amp; utterIndex==0) return DocType.ARTICLE;</span>
<span class="nc bnc" id="L426" title="All 2 branches missed.">        if(doc.maxUtter &lt; utterIndex) doc.maxUtter = utterIndex;</span>
<span class="nc" id="L427">      }</span>
<span class="nc" id="L428">    }</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">    if(!speakerChange) return DocType.ARTICLE;</span>
<span class="nc" id="L430">    return DocType.CONVERSATION;  // in conversation, utter index keep increasing.</span>
  }

  /** Set paragraph index */
  private static void setParagraphAnnotation(Document doc) {
<span class="nc" id="L435">    int paragraphIndex = 0;</span>
<span class="nc" id="L436">    int previousOffset = -10;</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">    for(CoreMap sent : doc.annotation.get(CoreAnnotations.SentencesAnnotation.class)) {</span>
<span class="nc bnc" id="L438" title="All 2 branches missed.">      for(CoreLabel w : sent.get(CoreAnnotations.TokensAnnotation.class)) {</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">        if(w.containsKey(CoreAnnotations.CharacterOffsetBeginAnnotation.class)) {</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">          if(w.get(CoreAnnotations.CharacterOffsetBeginAnnotation.class) &gt; previousOffset+2) paragraphIndex++;</span>
<span class="nc" id="L441">          w.set(CoreAnnotations.ParagraphAnnotation.class, paragraphIndex);</span>
<span class="nc" id="L442">          previousOffset = w.get(CoreAnnotations.CharacterOffsetEndAnnotation.class);</span>
        } else {
<span class="nc" id="L444">          w.set(CoreAnnotations.ParagraphAnnotation.class, -1);</span>
        }
<span class="nc" id="L446">      }</span>
<span class="nc" id="L447">    }</span>
<span class="nc bnc" id="L448" title="All 2 branches missed.">    for(List&lt;Mention&gt; l : doc.predictedMentions) {</span>
<span class="nc bnc" id="L449" title="All 2 branches missed.">      for(Mention m : l){</span>
<span class="nc" id="L450">        m.paragraph = m.headWord.get(CoreAnnotations.ParagraphAnnotation.class);</span>
<span class="nc" id="L451">      }</span>
<span class="nc" id="L452">    }</span>
<span class="nc" id="L453">    doc.numParagraph = paragraphIndex;</span>
<span class="nc" id="L454">  }</span>

  /** Process discourse information */
  protected static void processDiscourse(Document doc, Dictionaries dict) {
<span class="nc" id="L458">    Boolean useMarkedDiscourse =</span>
<span class="nc" id="L459">        doc.annotation.get(CoreAnnotations.UseMarkedDiscourseAnnotation.class);</span>
<span class="nc bnc" id="L460" title="All 4 branches missed.">    if (useMarkedDiscourse == null || !useMarkedDiscourse) {</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">      for (CoreLabel l : doc.annotation.get(CoreAnnotations.TokensAnnotation.class)) {</span>
<span class="nc" id="L462">        l.remove(CoreAnnotations.SpeakerAnnotation.class);</span>
<span class="nc" id="L463">        l.remove(CoreAnnotations.UtteranceAnnotation.class);</span>
<span class="nc" id="L464">      }</span>
    }

<span class="nc" id="L467">    setUtteranceAndSpeakerAnnotation(doc);</span>
//    markQuotations(this.annotation.get(CoreAnnotations.SentencesAnnotation.class), false);

    // mention utter setting
<span class="nc bnc" id="L471" title="All 2 branches missed.">    for(Mention m : doc.predictedMentionsByID.values()) {</span>
<span class="nc" id="L472">      m.utter = m.headWord.get(CoreAnnotations.UtteranceAnnotation.class);</span>
<span class="nc" id="L473">    }</span>

<span class="nc" id="L475">    doc.docType = findDocType(doc);</span>
<span class="nc" id="L476">    findSpeakers(doc, dict);</span>

<span class="nc" id="L478">    boolean debug = false;</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">    if(debug) {</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">      for(CoreMap sent : doc.annotation.get(CoreAnnotations.SentencesAnnotation.class)) {</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">        for(CoreLabel cl : sent.get(TokensAnnotation.class)) {</span>
<span class="nc" id="L482">          log.info(&quot;   &quot;+cl.word()+&quot;-&quot;+cl.get(UtteranceAnnotation.class)+&quot;-&quot;+cl.get(SpeakerAnnotation.class));</span>
<span class="nc" id="L483">        }</span>
<span class="nc" id="L484">      }</span>


<span class="nc bnc" id="L487" title="All 2 branches missed.">      for(Integer utter : doc.speakers.keySet()) {</span>
<span class="nc" id="L488">        String speakerID = doc.speakers.get(utter);</span>
<span class="nc" id="L489">        log.info(&quot;utterance: &quot;+utter);</span>
<span class="nc" id="L490">        log.info(&quot;speakers value: &quot; + speakerID);</span>
<span class="nc" id="L491">        log.info(&quot;mention for it: &quot;+</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">            ( (NumberMatchingRegex.isDecimalInteger(speakerID))?</span>
<span class="nc" id="L493">                doc.predictedMentionsByID.get(Integer.parseInt(doc.speakers.get(utter)))</span>
                : &quot;no mention for this speaker yet&quot;) );
<span class="nc" id="L495">      }</span>
<span class="nc" id="L496">      log.info(&quot;AA SPEAKERS: &quot;+ doc.speakers);</span>
    }

    // build 'speakerInfo' from 'speakers'
<span class="nc bnc" id="L500" title="All 2 branches missed.">    for(Integer utter : doc.speakers.keySet()) {</span>
<span class="nc" id="L501">      String speaker = doc.speakers.get(utter);</span>
<span class="nc" id="L502">      SpeakerInfo speakerInfo = doc.speakerInfoMap.get(speaker);</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">      if (speakerInfo == null) {</span>
<span class="nc" id="L504">        doc.speakerInfoMap.put(speaker, speakerInfo = new SpeakerInfo(speaker));</span>
      }
<span class="nc" id="L506">    }</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">    if(debug){</span>
<span class="nc" id="L508">      log.info(&quot;BB SPEAKER INFO MAP: &quot;+doc.speakerInfoMap);</span>
    }

    // mention -&gt; to its speakerID: m.headWord.get(SpeakerAnnotation.class)
    // speakerID -&gt; more info: speakerInfoMap.get(speakerID)
    // if exists, set(mentionID, its speakerID pair): speakerPairs

    // for speakerInfo with real speaker name, find corresponding mention by strict/loose matching
<span class="nc" id="L516">    Map&lt;String, Integer&gt; speakerConversion = Generics.newHashMap();</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">    for(String speaker : doc.speakerInfoMap.keySet()) {</span>
<span class="nc" id="L518">      SpeakerInfo speakerInfo = doc.speakerInfoMap.get(speaker);</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">      if (speakerInfo.hasRealSpeakerName()) {   // do only for real name speaker, not mention ID</span>
<span class="nc" id="L520">        boolean found = false;</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">        for(Mention m : doc.predictedMentionsByID.values()) {</span>
<span class="nc bnc" id="L522" title="All 2 branches missed.">          if (CorefRules.mentionMatchesSpeaker(m, speakerInfo, true)) {</span>
<span class="nc" id="L523">            speakerConversion.put(speaker, m.mentionID);</span>
<span class="nc" id="L524">            found = true;</span>
<span class="nc" id="L525">            break;</span>
          }
<span class="nc" id="L527">        }</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">        if(!found) {</span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">          for(Mention m : doc.predictedMentionsByID.values()) {</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">            if (CorefRules.mentionMatchesSpeaker(m, speakerInfo, false)) {</span>
<span class="nc" id="L531">              speakerConversion.put(speaker, m.mentionID);</span>
<span class="nc" id="L532">              break;</span>
            }
<span class="nc" id="L534">          }</span>
        }
      }
<span class="nc" id="L537">    }</span>

<span class="nc bnc" id="L539" title="All 2 branches missed.">    if(debug) log.info(&quot;CC speaker conversion: &quot; + speakerConversion);</span>

    // convert real name speaker to speaker mention id
<span class="nc bnc" id="L542" title="All 2 branches missed.">    for(Integer utter : doc.speakers.keySet()) {</span>
<span class="nc" id="L543">      String speaker = doc.speakers.get(utter);</span>
<span class="nc bnc" id="L544" title="All 2 branches missed.">      if(speakerConversion.containsKey(speaker)) {</span>
<span class="nc" id="L545">        int speakerID = speakerConversion.get(speaker);</span>
<span class="nc" id="L546">        doc.speakers.put(utter, Integer.toString(speakerID));</span>
      }
<span class="nc" id="L548">    }</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">    for(String speaker : speakerConversion.keySet()) {</span>
<span class="nc" id="L550">      doc.speakerInfoMap.put( Integer.toString(speakerConversion.get(speaker)), doc.speakerInfoMap.get(speaker));</span>
<span class="nc" id="L551">      doc.speakerInfoMap.remove(speaker);</span>
<span class="nc" id="L552">    }</span>

    // fix SpeakerAnnotation
<span class="nc bnc" id="L555" title="All 2 branches missed.">    for(CoreLabel cl : doc.annotation.get(TokensAnnotation.class)) {</span>
<span class="nc" id="L556">      int utter = cl.get(UtteranceAnnotation.class);</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">      if(doc.speakers.containsKey(utter)) {</span>
<span class="nc" id="L558">        cl.set(CoreAnnotations.SpeakerAnnotation.class, doc.speakers.get(utter));</span>
      }
<span class="nc" id="L560">    }</span>

    // find speakerPairs
<span class="nc bnc" id="L563" title="All 2 branches missed.">    for(Mention m : doc.predictedMentionsByID.values()) {</span>
<span class="nc" id="L564">      String speaker = m.headWord.get(CoreAnnotations.SpeakerAnnotation.class);</span>
<span class="nc bnc" id="L565" title="All 2 branches missed.">      if(debug) log.info(&quot;DD: &quot;+speaker);</span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">      if (NumberMatchingRegex.isDecimalInteger(speaker)) {</span>
<span class="nc" id="L567">        int speakerMentionID = Integer.parseInt(speaker);</span>
<span class="nc" id="L568">        doc.speakerPairs.add(new Pair&lt;&gt;(m.mentionID, speakerMentionID));</span>
      }
<span class="nc" id="L570">    }</span>

<span class="nc bnc" id="L572" title="All 2 branches missed.">    if(debug) {</span>
<span class="nc" id="L573">      log.info(&quot;==========================================================================&quot;);</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">      for(Integer utter : doc.speakers.keySet()) {</span>
<span class="nc" id="L575">        String speakerID = doc.speakers.get(utter);</span>
<span class="nc" id="L576">        log.info(&quot;utterance: &quot;+utter);</span>
<span class="nc" id="L577">        log.info(&quot;speakers value: &quot; + speakerID);</span>
<span class="nc" id="L578">        log.info(&quot;mention for it: &quot;+</span>
<span class="nc bnc" id="L579" title="All 2 branches missed.">            ( (NumberMatchingRegex.isDecimalInteger(speakerID))?</span>
<span class="nc" id="L580">                doc.predictedMentionsByID.get(Integer.parseInt(doc.speakers.get(utter)))</span>
                : &quot;no mention for this speaker yet&quot;) );
<span class="nc" id="L582">      }</span>
<span class="nc" id="L583">      log.info(doc.speakers);</span>
    }
<span class="nc" id="L585">  }</span>

  private static void setUtteranceAndSpeakerAnnotation(Document doc) {
<span class="nc" id="L588">    doc.speakerInfoGiven = false;</span>
<span class="nc" id="L589">    int utterance = 0;</span>
<span class="nc" id="L590">    int outsideQuoteUtterance = 0;   // the utterance of outside of quotation</span>
<span class="nc" id="L591">    boolean insideQuotation = false;</span>
<span class="nc" id="L592">    List&lt;CoreLabel&gt; tokens = doc.annotation.get(CoreAnnotations.TokensAnnotation.class);</span>
<span class="nc bnc" id="L593" title="All 2 branches missed.">    String preSpeaker = (tokens.size() &gt; 0)? tokens.get(0).get(CoreAnnotations.SpeakerAnnotation.class) : null;</span>

<span class="nc bnc" id="L595" title="All 2 branches missed.">    for (CoreLabel l : tokens) {</span>
<span class="nc" id="L596">      String curSpeaker = l.get(CoreAnnotations.SpeakerAnnotation.class);</span>
<span class="nc" id="L597">      String w = l.get(CoreAnnotations.TextAnnotation.class);</span>

<span class="nc bnc" id="L599" title="All 4 branches missed.">      if (curSpeaker!=null &amp;&amp; !curSpeaker.equals(&quot;-&quot;)) doc.speakerInfoGiven = true;</span>

<span class="nc bnc" id="L601" title="All 6 branches missed.">      boolean speakerChange = doc.speakerInfoGiven &amp;&amp; curSpeaker!=null &amp;&amp; !curSpeaker.equals(preSpeaker);</span>
<span class="nc bnc" id="L602" title="All 6 branches missed.">      boolean quoteStart = w.equals(&quot;``&quot;) || (!insideQuotation &amp;&amp; w.equals(&quot;\&quot;&quot;));</span>
<span class="nc bnc" id="L603" title="All 6 branches missed.">      boolean quoteEnd = w.equals(&quot;''&quot;) || (insideQuotation &amp;&amp; w.equals(&quot;\&quot;&quot;));</span>

<span class="nc bnc" id="L605" title="All 2 branches missed.">      if(speakerChange) {</span>
<span class="nc bnc" id="L606" title="All 2 branches missed.">        if(quoteStart) {</span>
<span class="nc" id="L607">          utterance = doc.maxUtter + 1;</span>
<span class="nc" id="L608">          outsideQuoteUtterance = utterance+1;</span>
        } else {
<span class="nc" id="L610">          utterance = doc.maxUtter + 1;</span>
<span class="nc" id="L611">          outsideQuoteUtterance = utterance;</span>
        }
<span class="nc" id="L613">        preSpeaker = curSpeaker;</span>
      } else {
<span class="nc bnc" id="L615" title="All 2 branches missed.">        if(quoteStart) {</span>
<span class="nc" id="L616">          utterance = doc.maxUtter + 1;</span>
        }
      }
<span class="nc bnc" id="L619" title="All 2 branches missed.">      if(quoteEnd) {</span>
<span class="nc" id="L620">        utterance = outsideQuoteUtterance;</span>
<span class="nc" id="L621">        insideQuotation = false;</span>
      }
<span class="nc bnc" id="L623" title="All 2 branches missed.">      if(doc.maxUtter &lt; utterance) doc.maxUtter = utterance;</span>

<span class="nc" id="L625">      l.set(CoreAnnotations.UtteranceAnnotation.class, utterance);</span>
<span class="nc bnc" id="L626" title="All 2 branches missed.">      if(quoteStart) l.set(CoreAnnotations.UtteranceAnnotation.class, outsideQuoteUtterance);   // quote start got outside utterance idx</span>

<span class="nc bnc" id="L628" title="All 2 branches missed.">      boolean noSpeakerInfo = !l.containsKey(CoreAnnotations.SpeakerAnnotation.class)</span>
<span class="nc bnc" id="L629" title="All 2 branches missed.">      || l.get(CoreAnnotations.SpeakerAnnotation.class).equals(&quot;&quot;)</span>
<span class="nc bnc" id="L630" title="All 2 branches missed.">      || l.get(CoreAnnotations.SpeakerAnnotation.class).startsWith(&quot;PER&quot;);</span>

<span class="nc bnc" id="L632" title="All 4 branches missed.">      if(noSpeakerInfo || insideQuotation){</span>
<span class="nc" id="L633">        l.set(CoreAnnotations.SpeakerAnnotation.class, &quot;PER&quot;+utterance);</span>
      }
<span class="nc bnc" id="L635" title="All 2 branches missed.">      if(quoteStart) insideQuotation = true;</span>
<span class="nc" id="L636">    }</span>
<span class="nc" id="L637">  }</span>

  /** Speaker extraction */
  private static void findSpeakers(Document doc, Dictionaries dict) {
<span class="nc" id="L641">    Boolean useMarkedDiscourseBoolean = doc.annotation.get(CoreAnnotations.UseMarkedDiscourseAnnotation.class);</span>
<span class="nc bnc" id="L642" title="All 2 branches missed.">    boolean useMarkedDiscourse = (useMarkedDiscourseBoolean != null)? useMarkedDiscourseBoolean: false;</span>

<span class="nc bnc" id="L644" title="All 2 branches missed.">    if(!useMarkedDiscourse) {</span>
<span class="nc bnc" id="L645" title="All 2 branches missed.">      if(doc.docType==DocType.CONVERSATION) findSpeakersInConversation(doc, dict);</span>
<span class="nc bnc" id="L646" title="All 2 branches missed.">      else if (doc.docType==DocType.ARTICLE) findSpeakersInArticle(doc, dict);</span>
    }

<span class="nc bnc" id="L649" title="All 2 branches missed.">    for(CoreMap sent : doc.annotation.get(CoreAnnotations.SentencesAnnotation.class)) {</span>
<span class="nc bnc" id="L650" title="All 2 branches missed.">      for(CoreLabel w : sent.get(CoreAnnotations.TokensAnnotation.class)) {</span>
<span class="nc" id="L651">        int utterIndex = w.get(CoreAnnotations.UtteranceAnnotation.class);</span>
<span class="nc bnc" id="L652" title="All 2 branches missed.">        if(!doc.speakers.containsKey(utterIndex)) {</span>
<span class="nc" id="L653">          doc.speakers.put(utterIndex, w.get(CoreAnnotations.SpeakerAnnotation.class));</span>
        }
<span class="nc" id="L655">      }</span>
<span class="nc" id="L656">    }</span>
<span class="nc" id="L657">  }</span>

  private static void findSpeakersInArticle(Document doc, Dictionaries dict) {
<span class="nc" id="L660">    List&lt;CoreMap&gt; sentences = doc.annotation.get(CoreAnnotations.SentencesAnnotation.class);</span>
<span class="nc" id="L661">    IntPair beginQuotation = null;</span>
<span class="nc" id="L662">    IntPair endQuotation = null;</span>
<span class="nc" id="L663">    boolean insideQuotation = false;</span>
<span class="nc" id="L664">    int utterNum = -1;</span>

<span class="nc bnc" id="L666" title="All 2 branches missed.">    for (int i = 0 ; i &lt; sentences.size(); i++) {</span>
<span class="nc" id="L667">      List&lt;CoreLabel&gt; sent = sentences.get(i).get(CoreAnnotations.TokensAnnotation.class);</span>
<span class="nc bnc" id="L668" title="All 2 branches missed.">      for(int j = 0 ; j &lt; sent.size() ; j++) {</span>
<span class="nc" id="L669">        int utterIndex = sent.get(j).get(CoreAnnotations.UtteranceAnnotation.class);</span>

<span class="nc bnc" id="L671" title="All 4 branches missed.">        if(utterIndex != 0 &amp;&amp; !insideQuotation) {</span>
<span class="nc" id="L672">          utterNum = utterIndex;</span>
<span class="nc" id="L673">          insideQuotation = true;</span>
<span class="nc" id="L674">          beginQuotation = new IntPair(i,j);</span>
<span class="nc bnc" id="L675" title="All 4 branches missed.">        } else if (utterIndex == 0 &amp;&amp; insideQuotation) {</span>
<span class="nc" id="L676">          insideQuotation = false;</span>
<span class="nc" id="L677">          endQuotation = new IntPair(i,j);</span>
<span class="nc" id="L678">          findQuotationSpeaker(doc, utterNum, sentences, beginQuotation, endQuotation, dict);</span>
        }
      }
    }
<span class="nc bnc" id="L682" title="All 2 branches missed.">    if(insideQuotation) {</span>
<span class="nc" id="L683">      endQuotation = new IntPair(sentences.size()-1, sentences.get(sentences.size()-1).get(CoreAnnotations.TokensAnnotation.class).size()-1);</span>
<span class="nc" id="L684">      findQuotationSpeaker(doc, utterNum, sentences, beginQuotation, endQuotation, dict);</span>
    }
<span class="nc" id="L686">  }</span>

  private static void findQuotationSpeaker(Document doc, int utterNum, List&lt;CoreMap&gt; sentences,
      IntPair beginQuotation, IntPair endQuotation, Dictionaries dict) {

<span class="nc bnc" id="L691" title="All 2 branches missed.">    if(findSpeaker(doc, utterNum, beginQuotation.get(0), sentences, 0, beginQuotation.get(1), dict))</span>
<span class="nc" id="L692">      return ;</span>

<span class="nc bnc" id="L694" title="All 2 branches missed.">    if(findSpeaker(doc, utterNum, endQuotation.get(0), sentences, endQuotation.get(1),</span>
<span class="nc" id="L695">        sentences.get(endQuotation.get(0)).get(CoreAnnotations.TokensAnnotation.class).size(), dict))</span>
<span class="nc" id="L696">      return;</span>

<span class="nc bnc" id="L698" title="All 4 branches missed.">    if(beginQuotation.get(1) &lt;= 1 &amp;&amp; beginQuotation.get(0) &gt; 0) {</span>
<span class="nc bnc" id="L699" title="All 2 branches missed.">      if(findSpeaker(doc, utterNum, beginQuotation.get(0)-1, sentences, 0,</span>
<span class="nc" id="L700">          sentences.get(beginQuotation.get(0)-1).get(CoreAnnotations.TokensAnnotation.class).size(), dict))</span>
<span class="nc" id="L701">        return;</span>
    }

<span class="nc bnc" id="L704" title="All 2 branches missed.">    if(endQuotation.get(1) &gt;= sentences.get(endQuotation.get(0)).size()-2</span>
<span class="nc bnc" id="L705" title="All 2 branches missed.">        &amp;&amp; sentences.size() &gt; endQuotation.get(0)+1) {</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">      if(findSpeaker(doc, utterNum, endQuotation.get(0)+1, sentences, 0,</span>
<span class="nc" id="L707">          sentences.get(endQuotation.get(0)+1).get(CoreAnnotations.TokensAnnotation.class).size(), dict))</span>
<span class="nc" id="L708">        return;</span>
    }
<span class="nc" id="L710">  }</span>

  private static boolean findSpeaker(Document doc, int utterNum, int sentNum, List&lt;CoreMap&gt; sentences,
      int startIndex, int endIndex, Dictionaries dict) {
<span class="nc" id="L714">    List&lt;CoreLabel&gt; sent = sentences.get(sentNum).get(CoreAnnotations.TokensAnnotation.class);</span>
<span class="nc bnc" id="L715" title="All 2 branches missed.">    for(int i = startIndex ; i &lt; endIndex ; i++) {</span>
<span class="nc" id="L716">      CoreLabel cl = sent.get(i);</span>
<span class="nc bnc" id="L717" title="All 2 branches missed.">      if(cl.get(CoreAnnotations.UtteranceAnnotation.class)!=0) continue;</span>
<span class="nc" id="L718">      String lemma = cl.lemma();</span>
<span class="nc" id="L719">      String word = cl.word();</span>
<span class="nc bnc" id="L720" title="All 4 branches missed.">      if(dict.reportVerb.contains(lemma) &amp;&amp; cl.tag().startsWith(&quot;V&quot;)) {</span>
        // find subject
<span class="nc" id="L722">        SemanticGraph dependency = sentences.get(sentNum).get(SemanticGraphCoreAnnotations.EnhancedDependenciesAnnotation.class);</span>
<span class="nc bnc" id="L723" title="All 2 branches missed.">        if (dependency == null) {</span>
<span class="nc" id="L724">          dependency = sentences.get(sentNum).get(SemanticGraphCoreAnnotations.BasicDependenciesAnnotation.class);</span>
        }
<span class="nc" id="L726">        IndexedWord w = dependency.getNodeByWordPattern(word);</span>

<span class="nc bnc" id="L728" title="All 2 branches missed.">        if (w != null) {</span>
<span class="nc bnc" id="L729" title="All 2 branches missed.">          if(findSubject(doc, dependency, w, sentNum, utterNum)) return true;</span>
<span class="nc bnc" id="L730" title="All 2 branches missed.">          for(IndexedWord p : dependency.getPathToRoot(w)) {</span>
<span class="nc bnc" id="L731" title="All 4 branches missed.">            if(!p.tag().startsWith(&quot;V&quot;) &amp;&amp; !p.tag().startsWith(&quot;MD&quot;)) break;</span>
<span class="nc bnc" id="L732" title="All 2 branches missed.">            if(findSubject(doc, dependency, p, sentNum, utterNum)) return true;    // handling something like &quot;was talking&quot;, &quot;can tell&quot;</span>
<span class="nc" id="L733">          }</span>
        } else {
<span class="nc" id="L735">          Redwood.log(&quot;debug-preprocessor&quot;, &quot;Cannot find node in dependency for word &quot; + word);</span>
        }
      }
    }
<span class="nc" id="L739">    return false;</span>
  }

  private static boolean findSubject(Document doc, SemanticGraph dependency, IndexedWord w, int sentNum, int utterNum) {
<span class="nc bnc" id="L743" title="All 2 branches missed.">    for(Pair&lt;GrammaticalRelation,IndexedWord&gt; child : dependency.childPairs(w)){</span>
<span class="nc bnc" id="L744" title="All 2 branches missed.">      if(child.first().getShortName().equals(&quot;nsubj&quot;)) {</span>
<span class="nc" id="L745">        String subjectString = child.second().word();</span>
<span class="nc" id="L746">        int subjectIndex = child.second().index();  // start from 1</span>
<span class="nc" id="L747">        IntTuple headPosition = new IntTuple(2);</span>
<span class="nc" id="L748">        headPosition.set(0, sentNum);</span>
<span class="nc" id="L749">        headPosition.set(1, subjectIndex-1);</span>
        String speaker;
<span class="nc bnc" id="L751" title="All 2 branches missed.">        if(doc.mentionheadPositions.containsKey(headPosition)) {</span>
<span class="nc" id="L752">          speaker = Integer.toString(doc.mentionheadPositions.get(headPosition).mentionID);</span>
        } else {
<span class="nc" id="L754">          speaker = subjectString;</span>
        }
<span class="nc" id="L756">        doc.speakers.put(utterNum, speaker);</span>
<span class="nc" id="L757">        return true;</span>
      }
<span class="nc" id="L759">    }</span>
<span class="nc" id="L760">    return false;</span>
  }

  private static void findSpeakersInConversation(Document doc, Dictionaries dict) {
<span class="nc bnc" id="L764" title="All 2 branches missed.">    for(List&lt;Mention&gt; l : doc.predictedMentions) {</span>
<span class="nc bnc" id="L765" title="All 2 branches missed.">      for(Mention m : l){</span>
<span class="nc bnc" id="L766" title="All 2 branches missed.">        if(m.predicateNominatives == null) continue;</span>
<span class="nc bnc" id="L767" title="All 2 branches missed.">        for (Mention a : m.predicateNominatives){</span>
<span class="nc bnc" id="L768" title="All 2 branches missed.">          if(a.spanToString().toLowerCase().equals(&quot;i&quot;)) {</span>
<span class="nc" id="L769">            doc.speakers.put(m.headWord.get(CoreAnnotations.UtteranceAnnotation.class), Integer.toString(m.mentionID));</span>
          }
<span class="nc" id="L771">        }</span>
<span class="nc" id="L772">      }</span>
<span class="nc" id="L773">    }</span>
<span class="nc" id="L774">    List&lt;CoreMap&gt; paragraph = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L775">    int paragraphUtterIndex = 0;</span>
<span class="nc" id="L776">    String nextParagraphSpeaker = &quot;&quot;;</span>
<span class="nc" id="L777">    int paragraphOffset = 0;</span>
<span class="nc bnc" id="L778" title="All 2 branches missed.">    for(CoreMap sent : doc.annotation.get(CoreAnnotations.SentencesAnnotation.class)) {</span>
<span class="nc" id="L779">      paragraph.add(sent);</span>
<span class="nc" id="L780">      int currentUtter = sent.get(CoreAnnotations.TokensAnnotation.class).get(0).get(CoreAnnotations.UtteranceAnnotation.class);</span>
<span class="nc bnc" id="L781" title="All 2 branches missed.">      if(paragraphUtterIndex!=currentUtter) {</span>
<span class="nc" id="L782">        nextParagraphSpeaker = findParagraphSpeaker(doc, paragraph, paragraphUtterIndex, nextParagraphSpeaker, paragraphOffset, dict);</span>
<span class="nc" id="L783">        paragraphUtterIndex = currentUtter;</span>
<span class="nc" id="L784">        paragraphOffset += paragraph.size();</span>
<span class="nc" id="L785">        paragraph = new ArrayList&lt;&gt;();</span>
      }
<span class="nc" id="L787">    }</span>
<span class="nc" id="L788">    findParagraphSpeaker(doc, paragraph, paragraphUtterIndex, nextParagraphSpeaker, paragraphOffset, dict);</span>
<span class="nc" id="L789">  }</span>

  private static String findParagraphSpeaker(Document doc, List&lt;CoreMap&gt; paragraph,
            int paragraphUtterIndex, String nextParagraphSpeaker, int paragraphOffset, Dictionaries dict) {
<span class="nc bnc" id="L793" title="All 2 branches missed.">    if ( ! doc.speakers.containsKey(paragraphUtterIndex)) {</span>
<span class="nc bnc" id="L794" title="All 2 branches missed.">      if ( ! nextParagraphSpeaker.isEmpty()) {</span>
<span class="nc" id="L795">        doc.speakers.put(paragraphUtterIndex, nextParagraphSpeaker);</span>
      } else {  // find the speaker of this paragraph (John, nbc news)
        // cdm [Sept 2015] added this check to try to avoid crash
<span class="nc bnc" id="L798" title="All 2 branches missed.">        if (paragraph.isEmpty()) {</span>
<span class="nc" id="L799">          Redwood.log(&quot;debug-preprocessor&quot;, &quot;Empty paragraph; skipping findParagraphSpeaker&quot;);</span>
<span class="nc" id="L800">          return &quot;&quot;;</span>
        }
<span class="nc" id="L802">        CoreMap lastSent = paragraph.get(paragraph.size()-1);</span>
<span class="nc" id="L803">        String speaker = &quot;&quot;;</span>
<span class="nc" id="L804">        boolean hasVerb = false;</span>
<span class="nc bnc" id="L805" title="All 2 branches missed.">        for(int i = 0 ; i &lt; lastSent.get(CoreAnnotations.TokensAnnotation.class).size() ; i++){</span>
<span class="nc" id="L806">          CoreLabel w = lastSent.get(CoreAnnotations.TokensAnnotation.class).get(i);</span>
<span class="nc" id="L807">          String pos = w.get(CoreAnnotations.PartOfSpeechAnnotation.class);</span>
<span class="nc" id="L808">          String ner = w.get(CoreAnnotations.NamedEntityTagAnnotation.class);</span>
<span class="nc bnc" id="L809" title="All 2 branches missed.">          if(pos.startsWith(&quot;V&quot;)) {</span>
<span class="nc" id="L810">            hasVerb = true;</span>
<span class="nc" id="L811">            break;</span>
          }
<span class="nc bnc" id="L813" title="All 2 branches missed.">          if(ner.startsWith(&quot;PER&quot;)) {</span>
<span class="nc" id="L814">            IntTuple headPosition = new IntTuple(2);</span>
<span class="nc" id="L815">            headPosition.set(0, paragraph.size()-1 + paragraphOffset);</span>
<span class="nc" id="L816">            headPosition.set(1, i);</span>
<span class="nc bnc" id="L817" title="All 2 branches missed.">            if(doc.mentionheadPositions.containsKey(headPosition)) {</span>
<span class="nc" id="L818">              speaker = Integer.toString(doc.mentionheadPositions.get(headPosition).mentionID);</span>
            }
          }
        }
<span class="nc bnc" id="L822" title="All 4 branches missed.">        if(!hasVerb &amp;&amp; !speaker.equals(&quot;&quot;)) {</span>
<span class="nc" id="L823">          doc.speakers.put(paragraphUtterIndex, speaker);</span>
        }
      }
    }
<span class="nc" id="L827">    return findNextParagraphSpeaker(doc, paragraph, paragraphOffset, dict);</span>
  }

  private static String findNextParagraphSpeaker(Document doc, List&lt;CoreMap&gt; paragraph, int paragraphOffset, Dictionaries dict) {
<span class="nc bnc" id="L831" title="All 2 branches missed.">    if (paragraph.isEmpty()) {</span>
<span class="nc" id="L832">      return &quot;&quot;;</span>
    }
<span class="nc" id="L834">    CoreMap lastSent = paragraph.get(paragraph.size()-1);</span>
<span class="nc" id="L835">    String speaker = &quot;&quot;;</span>
<span class="nc bnc" id="L836" title="All 2 branches missed.">    for(CoreLabel w : lastSent.get(CoreAnnotations.TokensAnnotation.class)) {</span>
<span class="nc bnc" id="L837" title="All 4 branches missed.">      if(w.get(CoreAnnotations.LemmaAnnotation.class).equals(&quot;report&quot;) || w.get(CoreAnnotations.LemmaAnnotation.class).equals(&quot;say&quot;)) {</span>
<span class="nc" id="L838">        String word = w.get(CoreAnnotations.TextAnnotation.class);</span>
<span class="nc" id="L839">        SemanticGraph dependency = lastSent.get(SemanticGraphCoreAnnotations.EnhancedDependenciesAnnotation.class);</span>
<span class="nc bnc" id="L840" title="All 2 branches missed.">        if (dependency == null) {</span>
<span class="nc" id="L841">          dependency = lastSent.get(SemanticGraphCoreAnnotations.BasicDependenciesAnnotation.class);</span>
        }
<span class="nc" id="L843">        IndexedWord t = dependency.getNodeByWordPattern(word);</span>

<span class="nc bnc" id="L845" title="All 2 branches missed.">        for(Pair&lt;GrammaticalRelation,IndexedWord&gt; child : dependency.childPairs(t)){</span>
<span class="nc bnc" id="L846" title="All 2 branches missed.">          if(child.first().getShortName().equals(&quot;nsubj&quot;)) {</span>
<span class="nc" id="L847">            int subjectIndex = child.second().index();  // start from 1</span>
<span class="nc" id="L848">            IntTuple headPosition = new IntTuple(2);</span>
<span class="nc" id="L849">            headPosition.set(0, paragraph.size()-1 + paragraphOffset);</span>
<span class="nc" id="L850">            headPosition.set(1, subjectIndex-1);</span>
<span class="nc bnc" id="L851" title="All 2 branches missed.">            if(doc.mentionheadPositions.containsKey(headPosition)</span>
<span class="nc bnc" id="L852" title="All 2 branches missed.">                &amp;&amp; doc.mentionheadPositions.get(headPosition).nerString.startsWith(&quot;PER&quot;)) {</span>
<span class="nc" id="L853">              speaker = Integer.toString(doc.mentionheadPositions.get(headPosition).mentionID);</span>
            }
          }
<span class="nc" id="L856">        }</span>
      }
<span class="nc" id="L858">    }</span>
<span class="nc" id="L859">    return speaker;</span>
  }

  /** Check one mention is the speaker of the other mention */
  public static boolean isSpeaker(Mention m, Mention ant, Dictionaries dict) {

<span class="nc bnc" id="L865" title="All 6 branches missed.">    if(!dict.firstPersonPronouns.contains(ant.spanToString().toLowerCase())</span>
<span class="nc" id="L866">        || ant.number==Number.PLURAL || ant.sentNum!=m.sentNum) return false;</span>

<span class="nc" id="L868">    int countQuotationMark = 0;</span>
<span class="nc bnc" id="L869" title="All 2 branches missed.">    for(int i = Math.min(m.headIndex, ant.headIndex)+1 ; i &lt; Math.max(m.headIndex, ant.headIndex) ; i++) {</span>
<span class="nc" id="L870">      String word = m.sentenceWords.get(i).get(CoreAnnotations.TextAnnotation.class);</span>
<span class="nc bnc" id="L871" title="All 4 branches missed.">      if(word.equals(&quot;``&quot;) || word.equals(&quot;''&quot;)) countQuotationMark++;</span>
    }
<span class="nc bnc" id="L873" title="All 2 branches missed.">    if(countQuotationMark!=1) return false;</span>

<span class="nc" id="L875">    IndexedWord w = m.enhancedDependency.getNodeByWordPattern(m.sentenceWords.get(m.headIndex).get(CoreAnnotations.TextAnnotation.class));</span>
<span class="nc bnc" id="L876" title="All 2 branches missed.">    if(w== null) return false;</span>

<span class="nc bnc" id="L878" title="All 2 branches missed.">    for(Pair&lt;GrammaticalRelation,IndexedWord&gt; parent : m.enhancedDependency.parentPairs(w)){</span>
<span class="nc bnc" id="L879" title="All 2 branches missed.">      if(parent.first().getShortName().equals(&quot;nsubj&quot;)</span>
<span class="nc bnc" id="L880" title="All 2 branches missed.">          &amp;&amp; dict.reportVerb.contains(parent.second().get(CoreAnnotations.LemmaAnnotation.class))) {</span>
<span class="nc" id="L881">        return true;</span>
      }
<span class="nc" id="L883">    }</span>
<span class="nc" id="L884">    return false;</span>
  }

  private static void markListMemberRelation(List&lt;Mention&gt; orderedMentions) {
<span class="nc bnc" id="L888" title="All 2 branches missed.">    for(Mention m1 : orderedMentions){</span>
<span class="nc bnc" id="L889" title="All 2 branches missed.">      for(Mention m2 : orderedMentions){</span>
        // Mark if m2 and m1 are in list relationship
<span class="nc bnc" id="L891" title="All 2 branches missed.">        if (m1.isListMemberOf(m2)) {</span>
<span class="nc" id="L892">          m2.addListMember(m1);</span>
<span class="nc" id="L893">          m1.addBelongsToList(m2);</span>
<span class="nc bnc" id="L894" title="All 2 branches missed.">        } else if (m2.isListMemberOf(m1)) {</span>
<span class="nc" id="L895">          m1.addListMember(m2);</span>
<span class="nc" id="L896">          m2.addBelongsToList(m1);</span>
        }
<span class="nc" id="L898">      }</span>
<span class="nc" id="L899">    }</span>
<span class="nc" id="L900">  }</span>
  private static void markMentionRelation(List&lt;Mention&gt; orderedMentions, Set&lt;Pair&lt;Integer, Integer&gt;&gt; foundPairs, String flag) {
<span class="nc bnc" id="L902" title="All 2 branches missed.">    for(Mention m1 : orderedMentions){</span>
<span class="nc bnc" id="L903" title="All 2 branches missed.">      for(Mention m2 : orderedMentions){</span>
<span class="nc bnc" id="L904" title="All 2 branches missed.">        if(m1==m2) continue;</span>
        // Ignore if m2 and m1 are in list relationship
<span class="nc bnc" id="L906" title="All 6 branches missed.">        if (m1.isListMemberOf(m2) || m2.isListMemberOf(m1) || m1.isMemberOfSameList(m2)) {</span>
          //Redwood.log(&quot;debug-preprocessor&quot;, &quot;Not checking '&quot; + m1 + &quot;' and '&quot; + m2 + &quot;' for &quot; + flag + &quot;: in list relationship&quot;);
<span class="nc" id="L908">          continue;</span>
        }
<span class="nc bnc" id="L910" title="All 2 branches missed.">        for(Pair&lt;Integer, Integer&gt; foundPair: foundPairs){</span>
<span class="nc bnc" id="L911" title="All 4 branches missed.">          if (foundPair.first() == m1.headIndex &amp;&amp; foundPair.second() == m2.headIndex) {</span>
<span class="nc bnc" id="L912" title="All 2 branches missed.">            if(flag.equals(&quot;APPOSITION&quot;)) {</span>
<span class="nc bnc" id="L913" title="All 4 branches missed.">              if ( ! foundPair.first().equals(foundPair.second()) || m2.insideIn(m1)) {</span>
<span class="nc" id="L914">                m2.addApposition(m1);</span>
              }
            }
<span class="nc bnc" id="L917" title="All 2 branches missed.">            else if(flag.equals(&quot;PREDICATE_NOMINATIVE&quot;)) {</span>
<span class="nc" id="L918">              m2.addPredicateNominatives(m1);</span>
            }
<span class="nc bnc" id="L920" title="All 2 branches missed.">            else if(flag.equals(&quot;RELATIVE_PRONOUN&quot;)) m2.addRelativePronoun(m1);</span>
<span class="nc" id="L921">            else throw new RuntimeException(&quot;check flag in markMentionRelation (dcoref/MentionExtractor.java)&quot;);</span>
          }
<span class="nc" id="L923">        }</span>
<span class="nc" id="L924">      }</span>
<span class="nc" id="L925">    }</span>
<span class="nc" id="L926">  }</span>

//  private static final TregexPattern relativePronounPattern = TregexPattern.compile(&quot;NP &lt; (NP=m1 $.. (SBAR &lt; (WHNP &lt; WP|WDT=m2)))&quot;);
//  private static void findRelativePronouns(Tree tree, Set&lt;Pair&lt;Integer, Integer&gt;&gt; relativePronounPairs) {
//    findTreePattern(tree, relativePronounPattern, relativePronounPairs);
//  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>