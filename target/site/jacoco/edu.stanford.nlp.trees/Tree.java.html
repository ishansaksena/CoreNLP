<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Tree.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.trees</a> &gt; <span class="el_source">Tree.java</span></div><h1>Tree.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.trees;
import edu.stanford.nlp.util.logging.Redwood;

import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.io.Serializable;
import java.io.StringReader;
import java.io.StringWriter;
import java.util.*;
import java.util.function.Predicate;

import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.ling.HasIndex;
import edu.stanford.nlp.ling.HasTag;
import edu.stanford.nlp.ling.HasWord;
import edu.stanford.nlp.ling.Label;
import edu.stanford.nlp.ling.LabelFactory;
import edu.stanford.nlp.ling.LabeledWord;
import edu.stanford.nlp.ling.SentenceUtils;
import edu.stanford.nlp.ling.TaggedWord;
import edu.stanford.nlp.ling.Word;
import edu.stanford.nlp.ling.CoreAnnotations;
import edu.stanford.nlp.util.*;

/**
 * The abstract class &lt;code&gt;Tree&lt;/code&gt; is used to collect all of the
 * tree types, and acts as a generic extensible type.  This is the
 * standard implementation of inheritance-based polymorphism.
 * All &lt;code&gt;Tree&lt;/code&gt; objects support accessors for their children (a
 * &lt;code&gt;Tree[]&lt;/code&gt;), their label (a &lt;code&gt;Label&lt;/code&gt;), and their
 * score (a &lt;code&gt;double&lt;/code&gt;).  However, different concrete
 * implementations may or may not include the latter two, in which
 * case a default value is returned.  The class Tree defines no data
 * fields.  The two abstract methods that must be implemented are:
 * &lt;code&gt;children()&lt;/code&gt;, and &lt;code&gt;treeFactory()&lt;/code&gt;.  Notes
 * that &lt;code&gt;setChildren(Tree[])&lt;/code&gt; is now an optional
 * operation, whereas it was previously required to be
 * implemented. There is now support for finding the parent of a
 * tree.  This may be done by search from a tree root, or via a
 * directly stored parent.  The &lt;code&gt;Tree&lt;/code&gt; class now
 * implements the &lt;code&gt;Collection&lt;/code&gt; interface: in terms of
 * this, each &lt;i&gt;node&lt;/i&gt; of the tree is an element of the
 * collection; hence one can explore the tree by using the methods of
 * this interface.  A &lt;code&gt;Tree&lt;/code&gt; is regarded as a read-only
 * &lt;code&gt;Collection&lt;/code&gt; (even though the &lt;code&gt;Tree&lt;/code&gt; class
 * has various methods that modify trees).  Moreover, the
 * implementation is &lt;i&gt;not&lt;/i&gt; thread-safe: no attempt is made to
 * detect and report concurrent modifications.
 *
 * @author Christopher Manning
 * @author Dan Klein
 * @author Sarah Spikes (sdspikes@cs.stanford.edu) - filled in types
 */
public abstract class Tree extends AbstractCollection&lt;Tree&gt; implements Label, Labeled, Scored, Serializable  {

  /** A logger for this class */
<span class="fc" id="L59">  private static Redwood.RedwoodChannels log = Redwood.channels(Tree.class);</span>

  private static final long serialVersionUID = 5441849457648722744L;

  /**
   * A leaf node should have a zero-length array for its
   * children. For efficiency, classes can use this array as a
   * return value for children() for leaf nodes if desired.
   * This can also be used elsewhere when you want an empty Tree array.
   */
<span class="fc" id="L69">  public static final Tree[] EMPTY_TREE_ARRAY = new Tree[0];</span>

<span class="fc" id="L71">  public Tree() {</span>
<span class="fc" id="L72">  }</span>

  /**
   * Says whether a node is a leaf.  Can be used on an arbitrary
   * &lt;code&gt;Tree&lt;/code&gt;.  Being a leaf is defined as having no
   * children.  This must be implemented as returning a zero-length
   * Tree[] array for children().
   *
   * @return true if this object is a leaf
   */
  public boolean isLeaf() {
<span class="fc bfc" id="L83" title="All 2 branches covered.">    return numChildren() == 0;</span>
  }


  /**
   * Says how many children a tree node has in its local tree.
   * Can be used on an arbitrary &lt;code&gt;Tree&lt;/code&gt;.  Being a leaf is defined
   * as having no children.
   *
   * @return The number of direct children of the tree node
   */
  public int numChildren() {
<span class="fc" id="L95">    return children().length;</span>
  }


  /**
   * Says whether the current node has only one child.
   * Can be used on an arbitrary &lt;code&gt;Tree&lt;/code&gt;.
   *
   * @return Whether the node heads a unary rewrite
   */
  public boolean isUnaryRewrite() {
<span class="nc bnc" id="L106" title="All 2 branches missed.">    return numChildren() == 1;</span>
  }


  /**
   * Return whether this node is a preterminal or not.  A preterminal is
   * defined to be a node with one child which is itself a leaf.
   *
   * @return true if the node is a preterminal; false otherwise
   */
  public boolean isPreTerminal() {
<span class="fc" id="L117">    Tree[] kids = children();</span>
<span class="fc bfc" id="L118" title="All 4 branches covered.">    return (kids.length == 1) &amp;&amp; (kids[0].isLeaf());</span>
  }


  /**
   * Return whether all the children of this node are preterminals or not.
   * A preterminal is
   * defined to be a node with one child which is itself a leaf.
   * Considered false if the node has no children
   *
   * @return true if the node is a prepreterminal; false otherwise
   */
  public boolean isPrePreTerminal() {
<span class="nc" id="L131">    Tree[] kids = children();</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">    if (kids.length == 0) {</span>
<span class="nc" id="L133">      return false;</span>
    }
<span class="nc bnc" id="L135" title="All 2 branches missed.">    for (Tree kid : kids) {</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">      if ( ! kid.isPreTerminal()) {</span>
<span class="nc" id="L137">        return false;</span>
      }
    }
<span class="nc" id="L140">    return true;</span>
  }


  /**
   * Return whether this node is a phrasal node or not.  A phrasal node
   * is defined to be a node which is not a leaf or a preterminal.
   * Worded positively, this means that it must have two or more children,
   * or one child that is not a leaf.
   *
   * @return &lt;code&gt;true&lt;/code&gt; if the node is phrasal;
   *         &lt;code&gt;false&lt;/code&gt; otherwise
   */
  public boolean isPhrasal() {
<span class="fc" id="L154">    Tree[] kids = children();</span>
<span class="pc bpc" id="L155" title="1 of 8 branches missed.">    return !(kids == null || kids.length == 0 || (kids.length == 1 &amp;&amp; kids[0].isLeaf()));</span>
  }


  /**
   * Implements equality for Tree's.  Two Tree objects are equal if they
   * have equal {@link #value}s, the same number of children, and their children
   * are pairwise equal.
   *
   * @param o The object to compare with
   * @return Whether two things are equal
   */
  @Override
  public boolean equals(Object o) {
<span class="fc bfc" id="L169" title="All 2 branches covered.">    if (o == this) {</span>
<span class="fc" id="L170">      return true;</span>
    }
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">    if (!(o instanceof Tree)) {</span>
<span class="nc" id="L173">      return false;</span>
    }
<span class="fc" id="L175">    Tree t = (Tree) o;</span>
<span class="fc" id="L176">    String value1 = this.value();</span>
<span class="fc" id="L177">    String value2 = t.value();</span>
<span class="pc bpc" id="L178" title="3 of 4 branches missed.">    if (value1 != null || value2 != null) {</span>
<span class="pc bpc" id="L179" title="2 of 6 branches missed.">    	if (value1 == null || value2 == null || !value1.equals(value2)) {</span>
<span class="fc" id="L180">    		return false;</span>
    	}
    }
<span class="fc" id="L183">    Tree[] myKids = children();</span>
<span class="fc" id="L184">    Tree[] theirKids = t.children();</span>
    //if((myKids == null &amp;&amp; (theirKids == null || theirKids.length != 0)) || (theirKids == null &amp;&amp; myKids.length != 0) || (myKids.length != theirKids.length)){
<span class="pc bpc" id="L186" title="1 of 2 branches missed.">    if (myKids.length != theirKids.length) {</span>
<span class="nc" id="L187">      return false;</span>
    }
<span class="fc bfc" id="L189" title="All 2 branches covered.">    for (int i = 0; i &lt; myKids.length; i++) {</span>
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">      if (!myKids[i].equals(theirKids[i])) {</span>
<span class="nc" id="L191">        return false;</span>
      }
    }
<span class="fc" id="L194">    return true;</span>
  }


  /**
   * Implements a hashCode for Tree's.  Two trees should have the same
   * hashcode if they are equal, so we hash on the label value and
   * the children's label values.
   *
   * @return The hash code
   */
  @Override
  public int hashCode() {
<span class="fc" id="L207">    String v = this.value();</span>
<span class="pc bpc" id="L208" title="1 of 2 branches missed.">    int hc = (v == null) ? 1 : v.hashCode();</span>
<span class="fc" id="L209">    Tree[] kids = children();</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">    for (int i = 0; i &lt; kids.length; i++) {</span>
<span class="fc" id="L211">      v = kids[i].value();</span>
<span class="pc bpc" id="L212" title="1 of 2 branches missed.">      int hc2 = (v == null) ? i : v.hashCode();</span>
<span class="fc" id="L213">      hc ^= (hc2 &lt;&lt; i);</span>
    }
<span class="fc" id="L215">    return hc;</span>
  }


  /**
   * Returns the position of a Tree in the children list, if present,
   * or -1 if it is not present.  Trees are checked for presence with
   * object equality, ==.  Note that there are very few cases where an
   * indexOf that used .equals() instead of == would be useful and
   * correct.  In most cases, you want to figure out which child of
   * the parent a known tree is, so looking for object equality will
   * be faster and will avoid cases where you happen to have two
   * subtrees that are exactly the same.
   *
   * @param tree The tree to look for in children list
   * @return Its index in the list or -1
   */
  public int objectIndexOf(Tree tree) {
<span class="fc" id="L233">    Tree[] kids = children();</span>
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">    for (int i = 0; i &lt; kids.length; i++) {</span>
<span class="fc bfc" id="L235" title="All 2 branches covered.">      if (kids[i] == tree) {</span>
<span class="fc" id="L236">        return i;</span>
      }
    }
<span class="nc" id="L239">    return -1;</span>
  }


  /**
   * Returns an array of children for the current node.  If there
   * are no children (if the node is a leaf), this must return a
   * Tree[] array of length 0.  A null children() value for tree
   * leaves was previously supported, but no longer is.
   * A caller may assume that either &lt;code&gt;isLeaf()&lt;/code&gt; returns
   * true, or this node has a nonzero number of children.
   *
   * @return The children of the node
   * @see #getChildrenAsList()
   */
  public abstract Tree[] children();


  /**
   * Returns a List of children for the current node.  If there are no
   * children, then a (non-null) &lt;code&gt;List&amp;lt;Tree&amp;gt;&lt;/code&gt; of size 0 will
   * be returned.  The list has new list structure but pointers to,
   * not copies of the children.  That is, the returned list is mutable,
   * and simply adding to or deleting items from it is safe, but beware
   * changing the contents of the children.
   *
   * @return The children of the node
   */
  public List&lt;Tree&gt; getChildrenAsList() {
<span class="fc" id="L268">    return new ArrayList&lt;&gt;(Arrays.asList(children()));</span>
  }


  /**
   * Set the children of this node to be the children given in the
   * array.  This is an &lt;b&gt;optional&lt;/b&gt; operation; by default it is
   * unsupported.  Note for subclasses that if there are no
   * children, the children() method must return a Tree[] array of
   * length 0.  This class provides a
   * {@code EMPTY_TREE_ARRAY} canonical zero-length Tree[] array
   * to represent zero children, but it is &lt;i&gt;not&lt;/i&gt; required that
   * leaf nodes use this particular zero-length array to represent
   * a leaf node.
   *
   * @param children The array of children, each a &lt;code&gt;Tree&lt;/code&gt;
   * @see #setChildren(List)
   */
  public void setChildren(Tree[] children) {
<span class="nc" id="L287">    throw new UnsupportedOperationException();</span>
  }


  /**
   * Set the children of this tree node to the given list.  This
   * method is implemented in the &lt;code&gt;Tree&lt;/code&gt; class by
   * converting the &lt;code&gt;List&lt;/code&gt; into a tree array and calling
   * the array-based method.  Subclasses which use a
   * &lt;code&gt;List&lt;/code&gt;-based representation of tree children should
   * override this method.  This implementation allows the case
   * that the &lt;code&gt;List&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;: it yields a
   * node with no children (represented by a canonical zero-length
   * children() array).
   *
   * @param childTreesList A list of trees to become children of the node.
   *          This method does not retain the List that you pass it (copying
   *          is done), but it will retain the individual children (they are
   *          not copied).
   * @see #setChildren(Tree[])
   */
  public void setChildren(List&lt;? extends Tree&gt; childTreesList) {
<span class="fc bfc" id="L309" title="All 4 branches covered.">    if (childTreesList == null || childTreesList.isEmpty()) {</span>
<span class="fc" id="L310">      setChildren(EMPTY_TREE_ARRAY);</span>
    } else {
<span class="fc" id="L312">      Tree[] childTrees = new Tree[childTreesList.size()];</span>
<span class="fc" id="L313">      childTreesList.toArray(childTrees);</span>
<span class="fc" id="L314">      setChildren(childTrees);</span>
    }
<span class="fc" id="L316">  }</span>


  /**
   * Returns the label associated with the current node, or null
   * if there is no label.  The default implementation always
   * returns {@code null}.
   *
   * @return The label of the node
   */
  @Override
  public Label label() {
<span class="nc" id="L328">    return null;</span>
  }


  /**
   * Sets the label associated with the current node, if there is one.
   * The default implementation ignores the label.
   *
   * @param label The label
   */
  @Override
  public void setLabel(Label label) {
    // a noop
<span class="nc" id="L341">  }</span>


  /**
   * Returns the score associated with the current node, or NaN
   * if there is no score.  The default implementation returns NaN.
   *
   * @return The score
   */
  @Override
  public double score() {
<span class="nc" id="L352">    return Double.NaN;</span>
  }


  /**
   * Sets the score associated with the current node, if there is one.
   *
   * @param score The score
   */
  public void setScore(double score) {
<span class="nc" id="L362">    throw new UnsupportedOperationException(&quot;You must use a tree type that implements scoring in order call setScore()&quot;);</span>
  }


  /**
   * Returns the first child of a tree, or &lt;code&gt;null&lt;/code&gt; if none.
   *
   * @return The first child
   */
  public Tree firstChild() {
<span class="fc" id="L372">    Tree[] kids = children();</span>
<span class="pc bpc" id="L373" title="1 of 2 branches missed.">    if (kids.length == 0) {</span>
<span class="nc" id="L374">      return null;</span>
    }
<span class="fc" id="L376">    return kids[0];</span>
  }


  /**
   * Returns the last child of a tree, or &lt;code&gt;null&lt;/code&gt; if none.
   *
   * @return The last child
   */
  public Tree lastChild() {
<span class="fc" id="L386">    Tree[] kids = children();</span>
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">    if (kids.length == 0) {</span>
<span class="nc" id="L388">      return null;</span>
    }
<span class="fc" id="L390">    return kids[kids.length - 1];</span>
  }

  /** Return the highest node of the (perhaps trivial) unary chain that
   *  this node is part of.
   *  In case this node is the only child of its parent, trace up the chain of
   *  unaries, and return the uppermost node of the chain (the node whose
   *  parent has multiple children, or the node that is the root of the tree).
   *
   *  @param root The root of the tree that contains this subtree
   *  @return The uppermost node of the unary chain, if this node is in a unary
   *         chain, or else the current node
   */
  public Tree upperMostUnary(Tree root) {
<span class="nc" id="L404">    Tree parent = parent(root);</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">    if (parent == null) {</span>
<span class="nc" id="L406">      return this;</span>
    }
<span class="nc bnc" id="L408" title="All 2 branches missed.">    if (parent.numChildren() &gt; 1) {</span>
<span class="nc" id="L409">      return this;</span>
    }
<span class="nc" id="L411">    return parent.upperMostUnary(root);</span>
  }

  /**
   * Assign a SpanAnnotation on each node of this tree.
   *  The index starts at zero.
   */
  public void setSpans() {
<span class="nc" id="L419">    constituentsNodes(0);</span>
<span class="nc" id="L420">  }</span>

  /**
   * Returns SpanAnnotation of this node, or null if annotation is not assigned.
   * Use &lt;code&gt;setSpans()&lt;/code&gt; to assign SpanAnnotations to a tree.
   *
   * @return an IntPair: the SpanAnnotation of this node.
   */
  public IntPair getSpan() {
<span class="nc bnc" id="L429" title="All 4 branches missed.">    if(label() instanceof CoreMap &amp;&amp; ((CoreMap) label()).containsKey(CoreAnnotations.SpanAnnotation.class))</span>
<span class="nc" id="L430">      return ((CoreMap) label()).get(CoreAnnotations.SpanAnnotation.class);</span>
<span class="nc" id="L431">    return null;</span>
  }

  /**
   * Returns the Constituents generated by the parse tree. Constituents
   * are computed with respect to whitespace (e.g., at the word level).
   *
   * @return a Set of the constituents as constituents of
   *         type &lt;code&gt;Constituent&lt;/code&gt;
   */
  public Set&lt;Constituent&gt; constituents() {
<span class="nc" id="L442">    return constituents(new SimpleConstituentFactory());</span>
  }


  /**
   * Returns the Constituents generated by the parse tree.
   * The Constituents of a sentence include the preterminal categories
   * but not the leaves.
   *
   * @param cf ConstituentFactory used to build the Constituent objects
   * @return a Set of the constituents as SimpleConstituent type
   *         (in the current implementation, a &lt;code&gt;HashSet&lt;/code&gt;
   */
  public Set&lt;Constituent&gt; constituents(ConstituentFactory cf) {
<span class="fc" id="L456">    return constituents(cf,false);</span>
  }

  /**
   * Returns the Constituents generated by the parse tree.
   * The Constituents of a sentence include the preterminal categories
   * but not the leaves.
   *
   * @param cf ConstituentFactory used to build the Constituent objects
   * @param maxDepth The maximum depth at which to add constituents,
   *                 where 0 is the root level.  Negative maxDepth
   *                 indicates no maximum.
   * @return a Set of the constituents as SimpleConstituent type
   *         (in the current implementation, a &lt;code&gt;HashSet&lt;/code&gt;
   */
  public Set&lt;Constituent&gt; constituents(ConstituentFactory cf, int maxDepth) {
<span class="nc" id="L472">    Set&lt;Constituent&gt; constituentsSet = Generics.newHashSet();</span>
<span class="nc" id="L473">    constituents(constituentsSet, 0, cf, false, null, maxDepth, 0);</span>
<span class="nc" id="L474">    return constituentsSet;</span>
  }

  /**
   * Returns the Constituents generated by the parse tree.
   * The Constituents of a sentence include the preterminal categories
   * but not the leaves.
   *
   * @param cf ConstituentFactory used to build the Constituent objects
   * @param charLevel If true, compute bracketings irrespective of whitespace boundaries.
   * @return a Set of the constituents as SimpleConstituent type
   *         (in the current implementation, a &lt;code&gt;HashSet&lt;/code&gt;
   */
  public Set&lt;Constituent&gt; constituents(ConstituentFactory cf, boolean charLevel) {
<span class="fc" id="L488">    Set&lt;Constituent&gt; constituentsSet = Generics.newHashSet();</span>
<span class="fc" id="L489">    constituents(constituentsSet, 0, cf, charLevel, null, -1, 0);</span>
<span class="fc" id="L490">    return constituentsSet;</span>
  }

  public Set&lt;Constituent&gt; constituents(ConstituentFactory cf, boolean charLevel, Predicate&lt;Tree&gt; filter) {
<span class="nc" id="L494">    Set&lt;Constituent&gt; constituentsSet = Generics.newHashSet();</span>
<span class="nc" id="L495">    constituents(constituentsSet, 0, cf, charLevel, filter, -1, 0);</span>
<span class="nc" id="L496">    return constituentsSet;</span>
  }

  /**
   * Same as int constituents but just puts the span as an IntPair
   * in the CoreLabel of the nodes.
   *
   * @param left The left position to begin labeling from
   * @return The index of the right frontier of the constituent
   */
  private int constituentsNodes(int left) {
<span class="nc bnc" id="L507" title="All 2 branches missed.">    if (isLeaf()) {</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">      if (label() instanceof CoreLabel) {</span>
<span class="nc" id="L509">        ((CoreLabel) label()).set(CoreAnnotations.SpanAnnotation.class, new IntPair(left, left));</span>
      } else {
<span class="nc" id="L511">        throw new UnsupportedOperationException(&quot;Can only set spans on trees which use CoreLabel&quot;);</span>
      }
<span class="nc" id="L513">      return (left + 1);</span>
    }
<span class="nc" id="L515">    int position = left;</span>

    // enumerate through daughter trees
<span class="nc" id="L518">    Tree[] kids = children();</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">    for (Tree kid : kids)</span>
<span class="nc" id="L520">      position = kid.constituentsNodes(position);</span>

    //Parent span
<span class="nc bnc" id="L523" title="All 2 branches missed.">    if (label() instanceof CoreLabel) {</span>
<span class="nc" id="L524">      ((CoreLabel) label()).set(CoreAnnotations.SpanAnnotation.class, new IntPair(left, position - 1));</span>
    } else {
<span class="nc" id="L526">      throw new UnsupportedOperationException(&quot;Can only set spans on trees which use CoreLabel&quot;);</span>
    }

<span class="nc" id="L529">    return position;</span>
  }

  /**
   * Adds the constituents derived from &lt;code&gt;this&lt;/code&gt; tree to
   * the ordered &lt;code&gt;Constituent&lt;/code&gt; &lt;code&gt;Set&lt;/code&gt;, beginning
   * numbering from the second argument and returning the number of
   * the right edge.  The reason for the return of the right frontier
   * is in order to produce bracketings recursively by threading through
   * the daughters of a given tree.
   *
   * @param constituentsSet set of constituents to add results of bracketing
   *                        this tree to
   * @param left            left position to begin labeling the bracketings with
   * @param cf              ConstituentFactory used to build the Constituent objects
   * @param charLevel       If true, compute constituents without respect to whitespace. Otherwise, preserve whitespace boundaries.
   * @param filter          A filter to use to decide whether or not to add a tree as a constituent.
   * @param maxDepth        The maximum depth at which to allow constituents.  Set to negative to indicate all depths allowed.
   * @param depth           The current depth
   * @return Index of right frontier of Constituent
   */
  private int constituents(Set&lt;Constituent&gt; constituentsSet, int left, ConstituentFactory cf, boolean charLevel, Predicate&lt;Tree&gt; filter, int maxDepth, int depth) {

<span class="fc bfc" id="L552" title="All 2 branches covered.">    if(isPreTerminal())</span>
<span class="pc bpc" id="L553" title="1 of 2 branches missed.">      return left + ((charLevel) ? firstChild().value().length() : 1);</span>

<span class="fc" id="L555">    int position = left;</span>

    // log.info(&quot;In bracketing trees left is &quot; + left);
    // log.info(&quot;  label is &quot; + label() +
    //                       &quot;; num daughters: &quot; + children().length);
<span class="fc" id="L560">    Tree[] kids = children();</span>
<span class="fc bfc" id="L561" title="All 2 branches covered.">    for (Tree kid : kids) {</span>
<span class="fc" id="L562">      position = kid.constituents(constituentsSet, position, cf, charLevel, filter, maxDepth, depth + 1);</span>
      // log.info(&quot;  position went to &quot; + position);
    }

<span class="pc bpc" id="L566" title="6 of 8 branches missed.">    if ((filter == null || filter.test(this)) &amp;&amp;</span>
        (maxDepth &lt; 0 || depth &lt;= maxDepth)) {
      //Compute span of entire tree at the end of recursion
<span class="fc" id="L569">      constituentsSet.add(cf.newConstituent(left, position - 1, label(), score()));</span>
    }
    // log.info(&quot;  added &quot; + label());
<span class="fc" id="L572">    return position;</span>
  }


  /**
   * Returns a new Tree that represents the local Tree at a certain node.
   * That is, it builds a new tree that copies the mother and daughter
   * nodes (but not their Labels), as non-Leaf nodes,
   * but zeroes out their children.
   *
   * @return A local tree
   */
  public Tree localTree() {
<span class="nc" id="L585">    Tree[] kids = children();</span>
<span class="nc" id="L586">    Tree[] newKids = new Tree[kids.length];</span>
<span class="nc" id="L587">    TreeFactory tf = treeFactory();</span>
<span class="nc bnc" id="L588" title="All 2 branches missed.">    for (int i = 0, n = kids.length; i &lt; n; i++) {</span>
<span class="nc" id="L589">      newKids[i] = tf.newTreeNode(kids[i].label(), Arrays.asList(EMPTY_TREE_ARRAY));</span>
    }
<span class="nc" id="L591">    return tf.newTreeNode(label(), Arrays.asList(newKids));</span>
  }


  /**
   * Returns a set of one level &lt;code&gt;Tree&lt;/code&gt;s that ares the local trees
   * of the tree.
   * That is, it builds a new tree that copies the mother and daughter
   * nodes (but not their Labels), for each phrasal node,
   * but zeroes out their children.
   *
   * @return A set of local tree
   */
  public Set&lt;Tree&gt; localTrees() {
<span class="nc" id="L605">    Set&lt;Tree&gt; set = Generics.newHashSet();</span>
<span class="nc bnc" id="L606" title="All 2 branches missed.">    for (Tree st : this) {</span>
<span class="nc bnc" id="L607" title="All 2 branches missed.">      if (st.isPhrasal()) {</span>
<span class="nc" id="L608">        set.add(st.localTree());</span>
      }
<span class="nc" id="L610">    }</span>
<span class="nc" id="L611">    return set;</span>
  }


  /**
   * Most instances of &lt;code&gt;Tree&lt;/code&gt; will take a lot more than
   * than the default &lt;code&gt;StringBuffer&lt;/code&gt; size of 16 to print
   * as an indented list of the whole tree, so we enlarge the default.
   */
  private static final int initialPrintStringBuilderSize = 500;

  /**
   * Appends the printed form of a parse tree (as a bracketed String)
   * to a {@code StringBuilder}.
   * The implementation of this may be more efficient than for
   * {@code toString()} on complex trees.
   *
   * @param sb The {@code StringBuilder} to which the tree will be appended
   * @return Returns the {@code StringBuilder} passed in with extra stuff in it
   */
  public StringBuilder toStringBuilder(StringBuilder sb) {
<span class="fc" id="L632">    return toStringBuilder(sb, true);</span>
  }

  /**
   * Appends the printed form of a parse tree (as a bracketed String)
   * to a {@code StringBuilder}.
   * The implementation of this may be more efficient than for
   * {@code toString()} on complex trees.
   *
   * @param sb The {@code StringBuilder} to which the tree will be appended
   * @param printOnlyLabelValue If true, print only the value() of each node's label
   * @return Returns the {@code StringBuilder} passed in with extra stuff in it
   */
  public StringBuilder toStringBuilder(StringBuilder sb, boolean printOnlyLabelValue) {
<span class="fc bfc" id="L646" title="All 2 branches covered.">    if (isLeaf()) {</span>
<span class="pc bpc" id="L647" title="1 of 2 branches missed.">      if (label() != null) {</span>
<span class="pc bpc" id="L648" title="1 of 2 branches missed.">        if(printOnlyLabelValue) {</span>
<span class="fc" id="L649">          sb.append(label().value());</span>
        } else {
<span class="nc" id="L651">          sb.append(label());</span>
        }
      }
<span class="fc" id="L654">      return sb;</span>
    } else {
<span class="fc" id="L656">      sb.append('(');</span>
<span class="pc bpc" id="L657" title="1 of 2 branches missed.">      if (label() != null) {</span>
<span class="pc bpc" id="L658" title="1 of 2 branches missed.">        if (printOnlyLabelValue) {</span>
<span class="fc bfc" id="L659" title="All 2 branches covered.">          if (value() != null) {</span>
<span class="fc" id="L660">            sb.append(label().value());</span>
          }
          // don't print a null, just nothing!
        } else {
<span class="nc" id="L664">          sb.append(label());</span>
        }
      }
<span class="fc" id="L667">      Tree[] kids = children();</span>
<span class="pc bpc" id="L668" title="1 of 2 branches missed.">      if (kids != null) {</span>
<span class="fc bfc" id="L669" title="All 2 branches covered.">        for (Tree kid : kids) {</span>
<span class="fc" id="L670">          sb.append(' ');</span>
<span class="fc" id="L671">          kid.toStringBuilder(sb, printOnlyLabelValue);</span>
        }
      }
<span class="fc" id="L674">      return sb.append(')');</span>
    }
  }


  /**
   * Converts parse tree to string in Penn Treebank format.
   * &lt;p&gt;
   * Implementation note: Internally, the method gains
   * efficiency by chaining use of a single &lt;code&gt;StringBuilder&lt;/code&gt;
   * through all the printing.
   *
   * @return the tree as a bracketed list on one line
   */
  @Override
  public String toString() {
<span class="fc" id="L690">    return toStringBuilder(new StringBuilder(Tree.initialPrintStringBuilderSize)).toString();</span>
  }


  private static final int indentIncr = 2;


  private static String makeIndentString(int indent) {
<span class="nc" id="L698">    StringBuilder sb = new StringBuilder(indent);</span>
<span class="nc bnc" id="L699" title="All 2 branches missed.">    for (int i = 0; i &lt; indentIncr; i++) {</span>
<span class="nc" id="L700">      sb.append(' ');</span>
    }
<span class="nc" id="L702">    return sb.toString();</span>
  }


  public void printLocalTree() {
<span class="nc" id="L707">    printLocalTree(new PrintWriter(System.out, true));</span>
<span class="nc" id="L708">  }</span>

  /**
   * Only prints the local tree structure, does not recurse
   */
  public void printLocalTree(PrintWriter pw) {
<span class="nc" id="L714">    pw.print(&quot;(&quot; + label() + ' ');</span>
<span class="nc bnc" id="L715" title="All 2 branches missed.">    for (Tree kid : children()) {</span>
<span class="nc" id="L716">      pw.print(&quot;(&quot;);</span>
<span class="nc" id="L717">      pw.print(kid.label());</span>
<span class="nc" id="L718">      pw.print(&quot;) &quot;);</span>
    }
<span class="nc" id="L720">    pw.println(&quot;)&quot;);</span>
<span class="nc" id="L721">  }</span>


  /**
   * Indented list printing of a tree.  The tree is printed in an
   * indented list notation, with node labels followed by node scores.
   */
  public void indentedListPrint() {
<span class="nc" id="L729">    indentedListPrint(new PrintWriter(System.out, true), false);</span>
<span class="nc" id="L730">  }</span>


  /**
   * Indented list printing of a tree.  The tree is printed in an
   * indented list notation, with node labels followed by node scores.
   *
   * @param pw The PrintWriter to print the tree to
   * @param printScores Whether to print the scores (log probs) of tree nodes
   */
  public void indentedListPrint(PrintWriter pw, boolean printScores) {
<span class="nc" id="L741">    indentedListPrint(&quot;&quot;, makeIndentString(indentIncr), pw, printScores);</span>
<span class="nc" id="L742">  }</span>


  /**
   * Indented list printing of a tree.  The tree is printed in an
   * indented list notation, with node labels followed by node scores.
   * String parameters are used rather than integer levels for efficiency.
   *
   * @param indent The base &lt;code&gt;String&lt;/code&gt; (normally just spaces)
   *               to print before each line of tree
   * @param pad    The additional &lt;code&gt;String&lt;/code&gt; (normally just more
   *               spaces) to add when going to a deeper level of &lt;code&gt;Tree&lt;/code&gt;.
   * @param pw     The PrintWriter to print the tree to
   * @param printScores Whether to print the scores (log probs) of tree nodes
   */
  private void indentedListPrint(String indent, String pad, PrintWriter pw, boolean printScores) {
<span class="nc" id="L758">    StringBuilder sb = new StringBuilder(indent);</span>
<span class="nc" id="L759">    Label label = label();</span>
<span class="nc bnc" id="L760" title="All 2 branches missed.">    if (label != null) {</span>
<span class="nc" id="L761">      sb.append(label.toString());</span>
    }
<span class="nc bnc" id="L763" title="All 2 branches missed.">    if (printScores) {</span>
<span class="nc" id="L764">      sb.append(&quot;  &quot;);</span>
<span class="nc" id="L765">      sb.append(score());</span>
    }
<span class="nc" id="L767">    pw.println(sb.toString());</span>
<span class="nc" id="L768">    Tree[] children = children();</span>
<span class="nc" id="L769">    String newIndent = indent + pad;</span>
<span class="nc bnc" id="L770" title="All 2 branches missed.">    for (Tree child : children) {</span>
<span class="nc" id="L771">      child.indentedListPrint(newIndent, pad, pw, printScores);</span>
    }
<span class="nc" id="L773">  }</span>

  /**
   * Indented xml printing of a tree.  The tree is printed in an
   * indented xml notation.
   */
  public void indentedXMLPrint() {
<span class="nc" id="L780">    indentedXMLPrint(new PrintWriter(System.out, true), false);</span>
<span class="nc" id="L781">  }</span>


  /**
   * Indented xml printing of a tree.  The tree is printed in an
   * indented xml notation, with node labels followed by node scores.
   *
   * @param pw The PrintWriter to print the tree to
   * @param printScores Whether to print the scores (log probs) of tree nodes
   */
  public void indentedXMLPrint(PrintWriter pw, boolean printScores) {
<span class="nc" id="L792">    indentedXMLPrint(&quot;&quot;, makeIndentString(indentIncr), pw, printScores);</span>
<span class="nc" id="L793">  }</span>


  /**
   * Indented xml printing of a tree.  The tree is printed in an
   * indented xml notation, with node labels followed by node scores.
   * String parameters are used rather than integer levels for efficiency.
   *
   * @param indent The base &lt;code&gt;String&lt;/code&gt; (normally just spaces)
   *               to print before each line of tree
   * @param pad    The additional &lt;code&gt;String&lt;/code&gt; (normally just more
   *               spaces) to add when going to a deeper level of
   *               &lt;code&gt;Tree&lt;/code&gt;.
   * @param pw     The PrintWriter to print the tree to
   * @param printScores Whether to print the scores (log probs) of tree nodes
   */
  private void indentedXMLPrint(String indent, String pad,
                                PrintWriter pw, boolean printScores) {
<span class="nc" id="L811">    StringBuilder sb = new StringBuilder(indent);</span>
<span class="nc" id="L812">    Tree[] children = children();</span>
<span class="nc" id="L813">    Label label = label();</span>
<span class="nc bnc" id="L814" title="All 2 branches missed.">    if (label != null) {</span>
<span class="nc" id="L815">      sb.append(&quot;&lt;&quot;);</span>
<span class="nc bnc" id="L816" title="All 2 branches missed.">      if (children.length &gt; 0) {</span>
<span class="nc" id="L817">        sb.append(&quot;node value=\&quot;&quot;);</span>
      } else {
<span class="nc" id="L819">        sb.append(&quot;leaf value=\&quot;&quot;);</span>
      }
<span class="nc" id="L821">      sb.append(XMLUtils.escapeXML(SentenceUtils.wordToString(label, true)));</span>
<span class="nc" id="L822">      sb.append(&quot;\&quot;&quot;);</span>
<span class="nc bnc" id="L823" title="All 2 branches missed.">      if (printScores) {</span>
<span class="nc" id="L824">        sb.append(&quot; score=&quot;);</span>
<span class="nc" id="L825">        sb.append(score());</span>
      }
<span class="nc bnc" id="L827" title="All 2 branches missed.">      if (children.length &gt; 0) {</span>
<span class="nc" id="L828">        sb.append(&quot;&gt;&quot;);</span>
      } else {
<span class="nc" id="L830">        sb.append(&quot;/&gt;&quot;);</span>
      }
    } else {
<span class="nc bnc" id="L833" title="All 2 branches missed.">      if (children.length &gt; 0) {</span>
<span class="nc" id="L834">        sb.append(&quot;&lt;node&gt;&quot;);</span>
      } else {
<span class="nc" id="L836">        sb.append(&quot;&lt;leaf/&gt;&quot;);</span>
      }
    }
<span class="nc" id="L839">    pw.println(sb.toString());</span>
<span class="nc bnc" id="L840" title="All 2 branches missed.">    if (children.length &gt; 0) {</span>
<span class="nc" id="L841">      String newIndent = indent + pad;</span>
<span class="nc bnc" id="L842" title="All 2 branches missed.">      for (Tree child : children) {</span>
<span class="nc" id="L843">        child.indentedXMLPrint(newIndent, pad, pw, printScores);</span>
      }
<span class="nc" id="L845">      pw.println(indent + &quot;&lt;/node&gt;&quot;);</span>
    }
<span class="nc" id="L847">  }</span>


  private static void displayChildren(Tree[] trChildren, int indent, boolean parentLabelNull, boolean onlyLabelValue, PrintWriter pw) {
<span class="fc" id="L851">    boolean firstSibling = true;</span>
<span class="fc" id="L852">    boolean leftSibIsPreTerm = true;  // counts as true at beginning</span>
<span class="fc bfc" id="L853" title="All 2 branches covered.">    for (Tree currentTree : trChildren) {</span>
<span class="fc" id="L854">      currentTree.display(indent, parentLabelNull, firstSibling, leftSibIsPreTerm, false, onlyLabelValue, pw);</span>
<span class="fc" id="L855">      leftSibIsPreTerm = currentTree.isPreTerminal();</span>
      // CC is a special case for English, but leave it in so we can exactly match PTB3 tree formatting
<span class="pc bpc" id="L857" title="2 of 4 branches missed.">      if (currentTree.value() != null &amp;&amp; currentTree.value().startsWith(&quot;CC&quot;)) {</span>
<span class="nc" id="L858">        leftSibIsPreTerm = false;</span>
      }
<span class="fc" id="L860">      firstSibling = false;</span>
    }
<span class="fc" id="L862">  }</span>

  /**
   *  Returns the value of the nodes label as a String.  This is done by
   *  calling &lt;code&gt;toString()&lt;/code&gt; on the value, if it exists. Otherwise,
   *  an empty string is returned.
   *
   *  @return The label of a tree node as a String
   */
  public String nodeString() {
<span class="nc bnc" id="L872" title="All 2 branches missed.">    return (value() == null) ? &quot;&quot; : value();</span>
  }

  /**
   * Display a node, implementing Penn Treebank style layout
   */
  private void display(int indent, boolean parentLabelNull, boolean firstSibling, boolean leftSiblingPreTerminal, boolean topLevel, boolean onlyLabelValue, PrintWriter pw) {
    // the condition for staying on the same line in Penn Treebank
<span class="pc bpc" id="L880" title="2 of 14 branches missed.">    boolean suppressIndent = (parentLabelNull || (firstSibling &amp;&amp; isPreTerminal()) || (leftSiblingPreTerminal &amp;&amp; isPreTerminal() &amp;&amp; (label() == null || !label().value().startsWith(&quot;CC&quot;))));</span>
<span class="fc bfc" id="L881" title="All 2 branches covered.">    if (suppressIndent) {</span>
<span class="fc" id="L882">      pw.print(&quot; &quot;);</span>
      // pw.flush();
    } else {
<span class="fc bfc" id="L885" title="All 2 branches covered.">      if (!topLevel) {</span>
<span class="fc" id="L886">        pw.println();</span>
      }
<span class="fc bfc" id="L888" title="All 2 branches covered.">      for (int i = 0; i &lt; indent; i++) {</span>
<span class="fc" id="L889">        pw.print(&quot;  &quot;);</span>
        // pw.flush();
      }
    }
<span class="pc bpc" id="L893" title="1 of 4 branches missed.">    if (isLeaf() || isPreTerminal()) {</span>
<span class="fc" id="L894">      String terminalString = toStringBuilder(new StringBuilder(), onlyLabelValue).toString();</span>
<span class="fc" id="L895">      pw.print(terminalString);</span>
<span class="fc" id="L896">      pw.flush();</span>
<span class="fc" id="L897">      return;</span>
    }
<span class="fc" id="L899">    pw.print(&quot;(&quot;);</span>
    String nodeString;
<span class="pc bpc" id="L901" title="1 of 2 branches missed.">    if (onlyLabelValue) {</span>
<span class="fc" id="L902">      String value = value();</span>
<span class="fc bfc" id="L903" title="All 2 branches covered.">      nodeString = (value == null) ? &quot;&quot; : value;</span>
<span class="fc" id="L904">    } else {</span>
<span class="nc" id="L905">      nodeString = nodeString();</span>
    }
<span class="fc" id="L907">    pw.print(nodeString);</span>
    // pw.flush();
<span class="pc bpc" id="L909" title="1 of 4 branches missed.">    boolean parentIsNull = label() == null || label().value() == null;</span>
<span class="fc" id="L910">    displayChildren(children(), indent + 1, parentIsNull, true, pw);</span>
<span class="fc" id="L911">    pw.print(&quot;)&quot;);</span>
<span class="fc" id="L912">    pw.flush();</span>
<span class="fc" id="L913">  }</span>


  /**
   * Print the tree as done in Penn Treebank merged files.
   * The formatting should be exactly the same, but we don't print the
   * trailing whitespace found in Penn Treebank trees.
   * The basic deviation from a bracketed indented tree is to in general
   * collapse the printing of adjacent preterminals onto one line of
   * tags and words.  Additional complexities are that conjunctions
   * (tag CC) are not collapsed in this way, and that the unlabeled
   * outer brackets are collapsed onto the same line as the next
   * bracket down.
   *
   * @param pw The tree is printed to this &lt;code&gt;PrintWriter&lt;/code&gt;
   */
  public void pennPrint(PrintWriter pw) {
<span class="fc" id="L930">    pennPrint(pw, true);</span>
<span class="fc" id="L931">  }</span>

  public void pennPrint(PrintWriter pw, boolean printOnlyLabelValue) {
<span class="fc" id="L934">    display(0, false, false, false, true, printOnlyLabelValue, pw);</span>
<span class="fc" id="L935">    pw.println();</span>
<span class="fc" id="L936">    pw.flush();</span>
<span class="fc" id="L937">  }</span>


  /**
   * Print the tree as done in Penn Treebank merged files.
   * The formatting should be exactly the same, but we don't print the
   * trailing whitespace found in Penn Treebank trees.
   * The basic deviation from a bracketed indented tree is to in general
   * collapse the printing of adjacent preterminals onto one line of
   * tags and words.  Additional complexities are that conjunctions
   * (tag CC) are not collapsed in this way, and that the unlabeled
   * outer brackets are collapsed onto the same line as the next
   * bracket down.
   *
   * @param ps The tree is printed to this &lt;code&gt;PrintStream&lt;/code&gt;
   */
  public void pennPrint(PrintStream ps) {
<span class="nc" id="L954">    pennPrint(new PrintWriter(new OutputStreamWriter(ps), true));</span>
<span class="nc" id="L955">  }</span>

  public void pennPrint(PrintStream ps, boolean printOnlyLabelValue) {
<span class="nc" id="L958">    pennPrint(new PrintWriter(new OutputStreamWriter(ps), true), printOnlyLabelValue);</span>
<span class="nc" id="L959">  }</span>

  /**
   * Calls &lt;code&gt;pennPrint()&lt;/code&gt; and saves output to a String
   *
   * @return The indent S-expression representation of a Tree
   */
  public String pennString() {
<span class="fc" id="L967">    StringWriter sw = new StringWriter();</span>
<span class="fc" id="L968">    pennPrint(new PrintWriter(sw));</span>
<span class="fc" id="L969">    return sw.toString();</span>
  }

  /**
   * Print the tree as done in Penn Treebank merged files.
   * The formatting should be exactly the same, but we don't print the
   * trailing whitespace found in Penn Treebank trees.
   * The tree is printed to &lt;code&gt;System.out&lt;/code&gt;. The basic deviation
   * from a bracketed indented tree is to in general
   * collapse the printing of adjacent preterminals onto one line of
   * tags and words.  Additional complexities are that conjunctions
   * (tag CC) are not collapsed in this way, and that the unlabeled
   * outer brackets are collapsed onto the same line as the next
   * bracket down.
   */
  public void pennPrint() {
<span class="nc" id="L985">    pennPrint(System.out);</span>
<span class="nc" id="L986">  }</span>


  /**
   * Finds the depth of the tree.  The depth is defined as the length
   * of the longest path from this node to a leaf node.  Leaf nodes
   * have depth zero.  POS tags have depth 1. Phrasal nodes have
   * depth &amp;gt;= 2.
   *
   * @return the depth
   */
  public int depth() {
<span class="nc bnc" id="L998" title="All 2 branches missed.">    if (isLeaf()) {</span>
<span class="nc" id="L999">      return 0;</span>
    }
<span class="nc" id="L1001">    int maxDepth = 0;</span>
<span class="nc" id="L1002">    Tree[] kids = children();</span>
<span class="nc bnc" id="L1003" title="All 2 branches missed.">    for (Tree kid : kids) {</span>
<span class="nc" id="L1004">      int curDepth = kid.depth();</span>
<span class="nc bnc" id="L1005" title="All 2 branches missed.">      if (curDepth &gt; maxDepth) {</span>
<span class="nc" id="L1006">        maxDepth = curDepth;</span>
      }
    }
<span class="nc" id="L1009">    return maxDepth + 1;</span>
  }

  /**
   * Finds the distance from this node to the specified node.
   * return -1 if this is not an ancestor of node.
   *
   * @param node A subtree contained in this tree
   * @return the depth
   */
  public int depth(Tree node) {
<span class="nc" id="L1020">    Tree p = node.parent(this);</span>
<span class="nc bnc" id="L1021" title="All 2 branches missed.">    if (this == node) { return 0; }</span>
<span class="nc bnc" id="L1022" title="All 2 branches missed.">    if (p == null) { return -1; }</span>
<span class="nc" id="L1023">    int depth = 1;</span>
<span class="nc bnc" id="L1024" title="All 2 branches missed.">    while (this != p) {</span>
<span class="nc" id="L1025">      p = p.parent(this);</span>
<span class="nc" id="L1026">      depth++;</span>
    }
<span class="nc" id="L1028">    return depth;</span>
  }


  /**
   * Returns the tree leaf that is the head of the tree.
   *
   * @param hf The head-finding algorithm to use
   * @param parent  The parent of this tree
   * @return The head tree leaf if any, else &lt;code&gt;null&lt;/code&gt;
   */
  public Tree headTerminal(HeadFinder hf, Tree parent) {
<span class="nc bnc" id="L1040" title="All 2 branches missed.">    if (isLeaf()) {</span>
<span class="nc" id="L1041">      return this;</span>
    }
<span class="nc" id="L1043">    Tree head = hf.determineHead(this, parent);</span>
<span class="nc bnc" id="L1044" title="All 2 branches missed.">    if (head != null) {</span>
<span class="nc" id="L1045">      return head.headTerminal(hf, parent);</span>
    }
<span class="nc" id="L1047">    log.info(&quot;Head is null: &quot; + this);</span>
<span class="nc" id="L1048">    return null;</span>
  }

  /**
   * Returns the tree leaf that is the head of the tree.
   *
   * @param hf The headfinding algorithm to use
   * @return The head tree leaf if any, else &lt;code&gt;null&lt;/code&gt;
   */
  public Tree headTerminal(HeadFinder hf) {
<span class="nc" id="L1058">    return headTerminal(hf, null);</span>
  }


  /**
   * Returns the preterminal tree that is the head of the tree.
   * See {@link #isPreTerminal()} for
   * the definition of a preterminal node. Beware that some tree nodes may
   * have no preterminal head.
   *
   * @param hf The headfinding algorithm to use
   * @return The head preterminal tree, if any, else &lt;code&gt;null&lt;/code&gt;
   * @throws IllegalArgumentException if called on a leaf node
   */
  public Tree headPreTerminal(HeadFinder hf) {
<span class="nc bnc" id="L1073" title="All 2 branches missed.">    if (isPreTerminal()) {</span>
<span class="nc" id="L1074">      return this;</span>
<span class="nc bnc" id="L1075" title="All 2 branches missed.">    } else if (isLeaf()) {</span>
<span class="nc" id="L1076">      throw new IllegalArgumentException(&quot;Called headPreTerminal on a leaf: &quot; + this);</span>
    } else {
<span class="nc" id="L1078">      Tree head = hf.determineHead(this);</span>
<span class="nc bnc" id="L1079" title="All 2 branches missed.">      if (head != null) {</span>
<span class="nc" id="L1080">        return head.headPreTerminal(hf);</span>
      }
<span class="nc" id="L1082">      log.info(&quot;Head preterminal is null: &quot; + this);</span>
<span class="nc" id="L1083">      return null;</span>
    }
  }

  /**
   * Finds the head words of each tree and assigns
   * HeadWordLabelAnnotation on each node pointing to the correct
   * CoreLabel.  This relies on the nodes being CoreLabels, so it
   * throws an IllegalArgumentException if this is ever not true.
   */
  public void percolateHeadAnnotations(HeadFinder hf) {
<span class="pc bpc" id="L1094" title="1 of 2 branches missed.">    if (!(label() instanceof CoreLabel)) {</span>
<span class="nc" id="L1095">      throw new IllegalArgumentException(&quot;Expected CoreLabels in the trees&quot;);</span>
    }
<span class="fc" id="L1097">    CoreLabel nodeLabel = (CoreLabel) label();</span>

<span class="pc bpc" id="L1099" title="1 of 2 branches missed.">    if (isLeaf()) {</span>
<span class="nc" id="L1100">      return;</span>
    }

<span class="fc bfc" id="L1103" title="All 2 branches covered.">    if (isPreTerminal()) {</span>
<span class="fc" id="L1104">      nodeLabel.set(TreeCoreAnnotations.HeadWordLabelAnnotation.class, (CoreLabel) children()[0].label());</span>
<span class="fc" id="L1105">      nodeLabel.set(TreeCoreAnnotations.HeadTagLabelAnnotation.class, nodeLabel);</span>
<span class="fc" id="L1106">      return;</span>
    }

<span class="fc bfc" id="L1109" title="All 2 branches covered.">    for (Tree kid : children()) {</span>
<span class="fc" id="L1110">      kid.percolateHeadAnnotations(hf);</span>
    }

<span class="fc" id="L1113">    final Tree head = hf.determineHead(this);</span>
<span class="pc bpc" id="L1114" title="1 of 2 branches missed.">    if (head == null) {</span>
<span class="nc" id="L1115">      throw new NullPointerException(&quot;HeadFinder &quot; + hf + &quot; returned null for &quot; + this);</span>
<span class="pc bpc" id="L1116" title="1 of 2 branches missed.">    } else if (head.isLeaf()) {</span>
<span class="nc" id="L1117">      nodeLabel.set(TreeCoreAnnotations.HeadWordLabelAnnotation.class, (CoreLabel) head.label());</span>
<span class="nc" id="L1118">      nodeLabel.set(TreeCoreAnnotations.HeadTagLabelAnnotation.class, (CoreLabel) head.parent(this).label());</span>
<span class="fc bfc" id="L1119" title="All 2 branches covered.">    } else if (head.isPreTerminal()) {</span>
<span class="fc" id="L1120">      nodeLabel.set(TreeCoreAnnotations.HeadWordLabelAnnotation.class, (CoreLabel) head.children()[0].label());</span>
<span class="fc" id="L1121">      nodeLabel.set(TreeCoreAnnotations.HeadTagLabelAnnotation.class, (CoreLabel) head.label());</span>
    } else {
<span class="pc bpc" id="L1123" title="1 of 2 branches missed.">      if (!(head.label() instanceof CoreLabel)) {</span>
<span class="nc" id="L1124">        throw new AssertionError(&quot;Horrible bug&quot;);</span>
      }
<span class="fc" id="L1126">      CoreLabel headLabel = (CoreLabel) head.label();</span>
<span class="fc" id="L1127">      nodeLabel.set(TreeCoreAnnotations.HeadWordLabelAnnotation.class, headLabel.get(TreeCoreAnnotations.HeadWordLabelAnnotation.class));</span>
<span class="fc" id="L1128">      nodeLabel.set(TreeCoreAnnotations.HeadTagLabelAnnotation.class, headLabel.get(TreeCoreAnnotations.HeadTagLabelAnnotation.class));</span>
    }
<span class="fc" id="L1130">  }</span>


  /**
   * Finds the heads of the tree.  This code assumes that the label
   * does store and return sensible values for the category, word, and tag.
   * It will be a no-op otherwise.  The tree is modified.  The routine
   * assumes the Tree has word leaves and tag preterminals, and copies
   * their category to word and tag respectively, if they have a null
   * value.
   *
   * @param hf The headfinding algorithm to use
   */
  public void percolateHeads(HeadFinder hf) {
<span class="nc" id="L1144">    Label nodeLabel = label();</span>
<span class="nc bnc" id="L1145" title="All 2 branches missed.">    if (isLeaf()) {</span>
      // Sanity check: word() is usually set by the TreeReader.
<span class="nc bnc" id="L1147" title="All 2 branches missed.">      if (nodeLabel instanceof HasWord) {</span>
<span class="nc" id="L1148">        HasWord w = (HasWord) nodeLabel;</span>
<span class="nc bnc" id="L1149" title="All 2 branches missed.">        if (w.word() == null) {</span>
<span class="nc" id="L1150">          w.setWord(nodeLabel.value());</span>
        }
<span class="nc" id="L1152">      }</span>

    } else {
<span class="nc bnc" id="L1155" title="All 2 branches missed.">      for (Tree kid : children()) {</span>
<span class="nc" id="L1156">        kid.percolateHeads(hf);</span>
      }

<span class="nc" id="L1159">      final Tree head = hf.determineHead(this);</span>
<span class="nc bnc" id="L1160" title="All 2 branches missed.">      if (head != null) {</span>
<span class="nc" id="L1161">        final Label headLabel = head.label();</span>

        // Set the head tag.
<span class="nc bnc" id="L1164" title="All 2 branches missed.">        String headTag = (headLabel instanceof HasTag) ? ((HasTag) headLabel).tag() : null;</span>
<span class="nc bnc" id="L1165" title="All 4 branches missed.">        if (headTag == null &amp;&amp; head.isLeaf()) {</span>
          // below us is a leaf
<span class="nc" id="L1167">          headTag = nodeLabel.value();</span>
        }

        // Set the head word
<span class="nc bnc" id="L1171" title="All 2 branches missed.">        String headWord = (headLabel instanceof HasWord) ? ((HasWord) headLabel).word() : null;</span>
<span class="nc bnc" id="L1172" title="All 4 branches missed.">        if (headWord == null &amp;&amp; head.isLeaf()) {</span>
          // below us is a leaf
          // this might be useful despite case for leaf above in
          // case the leaf label type doesn't support word()
<span class="nc" id="L1176">          headWord = headLabel.value();</span>
        }

        // Set the head index
<span class="nc bnc" id="L1180" title="All 2 branches missed.">        int headIndex = (headLabel instanceof HasIndex) ? ((HasIndex) headLabel).index() : -1;</span>

<span class="nc bnc" id="L1182" title="All 2 branches missed.">        if (nodeLabel instanceof HasWord) {</span>
<span class="nc" id="L1183">          ((HasWord) nodeLabel).setWord(headWord);</span>
        }
<span class="nc bnc" id="L1185" title="All 2 branches missed.">        if (nodeLabel instanceof HasTag) {</span>
<span class="nc" id="L1186">          ((HasTag) nodeLabel).setTag(headTag);</span>
        }
<span class="nc bnc" id="L1188" title="All 4 branches missed.">        if (nodeLabel instanceof HasIndex &amp;&amp; headIndex &gt;= 0) {</span>
<span class="nc" id="L1189">          ((HasIndex) nodeLabel).setIndex(headIndex);</span>
        }

<span class="nc" id="L1192">      } else {</span>
<span class="nc" id="L1193">        log.info(&quot;Head is null: &quot; + this);</span>
      }
    }
<span class="nc" id="L1196">  }</span>

  /**
   * Return a Set of TaggedWord-TaggedWord dependencies, represented as
   * Dependency objects, for the Tree.  This will only give
   * useful results if the internal tree node labels support HasWord and
   * HasTag, and head percolation has already been done (see
   * percolateHeads()).
   *
   * @return Set of dependencies (each a Dependency)
   */
  public Set&lt;Dependency&lt;Label, Label, Object&gt;&gt; dependencies() {
<span class="nc" id="L1208">    return dependencies(Filters.&lt;Dependency&lt;Label, Label, Object&gt;&gt;acceptFilter());</span>
  }

  public Set&lt;Dependency&lt;Label, Label, Object&gt;&gt; dependencies(Predicate&lt;Dependency&lt;Label, Label, Object&gt;&gt; f) {
<span class="nc" id="L1212">    return dependencies(f, true, true, false);</span>
  }

  /**
   * Convert a constituency label to a dependency label. Options are provided for selecting annotations
   * to copy.
   *
   * @param oldLabel
   * @param copyLabel
   * @param copyIndex
   * @param copyPosTag
   */
  private static Label makeDependencyLabel(Label oldLabel, boolean copyLabel, boolean copyIndex, boolean copyPosTag) {
<span class="nc bnc" id="L1225" title="All 2 branches missed.">    if ( ! copyLabel)</span>
<span class="nc" id="L1226">      return oldLabel;</span>

<span class="nc bnc" id="L1228" title="All 2 branches missed.">    String wordForm = (oldLabel instanceof HasWord) ? ((HasWord) oldLabel).word() : oldLabel.value();</span>
<span class="nc" id="L1229">    Label newLabel = oldLabel.labelFactory().newLabel(wordForm);</span>
<span class="nc bnc" id="L1230" title="All 2 branches missed.">    if (newLabel instanceof HasWord) ((HasWord) newLabel).setWord(wordForm);</span>
<span class="nc bnc" id="L1231" title="All 6 branches missed.">    if (copyPosTag &amp;&amp; newLabel instanceof HasTag &amp;&amp; oldLabel instanceof HasTag) {</span>
<span class="nc" id="L1232">      String tag = ((HasTag) oldLabel).tag();</span>
<span class="nc" id="L1233">      ((HasTag) newLabel).setTag(tag);</span>
    }
<span class="nc bnc" id="L1235" title="All 6 branches missed.">    if (copyIndex &amp;&amp; newLabel instanceof HasIndex &amp;&amp; oldLabel instanceof HasIndex) {</span>
<span class="nc" id="L1236">      int index = ((HasIndex) oldLabel).index();</span>
<span class="nc" id="L1237">      ((HasIndex) newLabel).setIndex(index);</span>
    }

<span class="nc" id="L1240">    return newLabel;</span>
  }

  /**
   * Return a set of TaggedWord-TaggedWord dependencies, represented as
   * Dependency objects, for the Tree.  This will only give
   * useful results if the internal tree node labels support HasWord and
   * head percolation has already been done (see percolateHeads()).
   *
   * @param f Dependencies are excluded for which the Dependency is not
   *          accepted by the Filter
   * @return Set of dependencies (each a Dependency)
   */
  public Set&lt;Dependency&lt;Label, Label, Object&gt;&gt; dependencies(Predicate&lt;Dependency&lt;Label, Label, Object&gt;&gt; f, boolean isConcrete, boolean copyLabel, boolean copyPosTag) {
<span class="nc" id="L1254">    Set&lt;Dependency&lt;Label, Label, Object&gt;&gt; deps = Generics.newHashSet();</span>
<span class="nc bnc" id="L1255" title="All 2 branches missed.">    for (Tree node : this) {</span>
      // Skip leaves and unary re-writes
<span class="nc bnc" id="L1257" title="All 4 branches missed.">      if (node.isLeaf() || node.children().length &lt; 2) {</span>
<span class="nc" id="L1258">        continue;</span>
      }
      // Create the head label (percolateHeads has already been executed)
<span class="nc" id="L1261">      Label headLabel = makeDependencyLabel(node.label(), copyLabel, isConcrete, copyPosTag);</span>
<span class="nc" id="L1262">      String headWord = ((HasWord) headLabel).word();</span>
<span class="nc bnc" id="L1263" title="All 2 branches missed.">      if (headWord == null) {</span>
<span class="nc" id="L1264">        headWord = headLabel.value();</span>
      }
<span class="nc bnc" id="L1266" title="All 4 branches missed.">      int headIndex = (isConcrete &amp;&amp; (headLabel instanceof HasIndex)) ? ((HasIndex) headLabel).index() : -1;</span>

      // every child with a different (or repeated) head is an argument
<span class="nc" id="L1269">      boolean seenHead = false;</span>
<span class="nc bnc" id="L1270" title="All 2 branches missed.">      for (Tree child : node.children()) {</span>
<span class="nc" id="L1271">        Label depLabel = makeDependencyLabel(child.label(), copyLabel, isConcrete, copyPosTag);</span>
<span class="nc" id="L1272">        String depWord = ((HasWord) depLabel).word();</span>
<span class="nc bnc" id="L1273" title="All 2 branches missed.">        if (depWord == null) {</span>
<span class="nc" id="L1274">          depWord = depLabel.value();</span>
        }
<span class="nc bnc" id="L1276" title="All 4 branches missed.">        int depIndex = (isConcrete &amp;&amp; (depLabel instanceof HasIndex)) ? ((HasIndex) depLabel).index() : -1;</span>

<span class="nc bnc" id="L1278" title="All 6 branches missed.">        if (!seenHead &amp;&amp; headIndex == depIndex &amp;&amp; headWord.equals(depWord)) {</span>
<span class="nc" id="L1279">          seenHead = true;</span>
        } else {
<span class="nc bnc" id="L1281" title="All 4 branches missed.">          Dependency&lt;Label, Label, Object&gt; dependency = (isConcrete &amp;&amp; depIndex != headIndex) ?</span>
              new UnnamedConcreteDependency(headLabel, depLabel) :
              new UnnamedDependency(headLabel, depLabel);

<span class="nc bnc" id="L1285" title="All 2 branches missed.">          if (f.test(dependency)) {</span>
<span class="nc" id="L1286">            deps.add(dependency);</span>
          }
        }
      }
<span class="nc" id="L1290">    }</span>
<span class="nc" id="L1291">    return deps;</span>
  }

  /**
   * Return a set of Label-Label dependencies, represented as
   * Dependency objects, for the Tree.  The Labels are the ones of the leaf
   * nodes of the tree, without mucking with them.
   *
   * @param f  Dependencies are excluded for which the Dependency is not
   *           accepted by the Filter
   * @param hf The HeadFinder to use to identify the head of constituents.
   *           The code assumes
   *           that it can use &lt;code&gt;headPreTerminal(hf)&lt;/code&gt; to find a
   *           tag and word to make a CoreLabel.
   * @return Set of dependencies (each a &lt;code&gt;Dependency&lt;/code&gt; between two
   *           &lt;code&gt;CoreLabel&lt;/code&gt;s, which each contain a tag(), word(),
   *           and value(), the last two of which are identical).
   */
  public Set&lt;Dependency&lt;Label, Label, Object&gt;&gt; mapDependencies(Predicate&lt;Dependency&lt;Label, Label, Object&gt;&gt; f, HeadFinder hf) {
<span class="nc bnc" id="L1310" title="All 2 branches missed.">    if (hf == null) {</span>
<span class="nc" id="L1311">      throw new IllegalArgumentException(&quot;mapDependencies: need HeadFinder&quot;);</span>
    }
<span class="nc" id="L1313">    Set&lt;Dependency&lt;Label, Label, Object&gt;&gt; deps = Generics.newHashSet();</span>
<span class="nc bnc" id="L1314" title="All 2 branches missed.">    for (Tree node : this) {</span>
<span class="nc bnc" id="L1315" title="All 4 branches missed.">      if (node.isLeaf() || node.children().length &lt; 2) {</span>
<span class="nc" id="L1316">        continue;</span>
      }
      // Label l = node.label();
      // log.info(&quot;doing kids of label: &quot; + l);
      //Tree hwt = node.headPreTerminal(hf);
<span class="nc" id="L1321">      Tree hwt = node.headTerminal(hf);</span>
      // log.info(&quot;have hf, found head preterm: &quot; + hwt);
<span class="nc bnc" id="L1323" title="All 2 branches missed.">      if (hwt == null) {</span>
<span class="nc" id="L1324">        throw new IllegalStateException(&quot;mapDependencies: HeadFinder failed!&quot;);</span>
      }

<span class="nc bnc" id="L1327" title="All 2 branches missed.">      for (Tree child : node.children()) {</span>
        // Label dl = child.label();
        // Tree dwt = child.headPreTerminal(hf);
<span class="nc" id="L1330">        Tree dwt = child.headTerminal(hf);</span>
<span class="nc bnc" id="L1331" title="All 2 branches missed.">        if (dwt == null) {</span>
<span class="nc" id="L1332">          throw new IllegalStateException(&quot;mapDependencies: HeadFinder failed!&quot;);</span>
        }
        //log.info(&quot;kid is &quot; + dl);
         //log.info(&quot;transformed to &quot; + dml.toString(&quot;value{map}&quot;));
<span class="nc bnc" id="L1336" title="All 2 branches missed.">        if (dwt != hwt) {</span>
<span class="nc" id="L1337">          Dependency&lt;Label, Label, Object&gt; p = new UnnamedDependency(hwt.label(), dwt.label());</span>
<span class="nc bnc" id="L1338" title="All 2 branches missed.">          if (f.test(p)) {</span>
<span class="nc" id="L1339">            deps.add(p);</span>
          }
        }
      }
<span class="nc" id="L1343">    }</span>
<span class="nc" id="L1344">    return deps;</span>
  }

  /**
   * Return a set of Label-Label dependencies, represented as
   * Dependency objects, for the Tree.  The Labels are the ones of the leaf
   * nodes of the tree, without mucking with them. The head of the sentence is a
   * dependent of a synthetic &quot;root&quot; label.
   *
   * @param f  Dependencies are excluded for which the Dependency is not
   *           accepted by the Filter
   * @param hf The HeadFinder to use to identify the head of constituents.
   *           The code assumes
   *           that it can use &lt;code&gt;headPreTerminal(hf)&lt;/code&gt; to find a
   *           tag and word to make a CoreLabel.
   * @param    rootName Name of the root node.
   * @return   Set of dependencies (each a &lt;code&gt;Dependency&lt;/code&gt; between two
   *           &lt;code&gt;CoreLabel&lt;/code&gt;s, which each contain a tag(), word(),
   *           and value(), the last two of which are identical).
   */
  public Set&lt;Dependency&lt;Label, Label, Object&gt;&gt; mapDependencies(Predicate&lt;Dependency&lt;Label, Label, Object&gt;&gt; f, HeadFinder hf, String rootName) {
<span class="nc" id="L1365">    Set&lt;Dependency&lt;Label, Label, Object&gt;&gt; deps = mapDependencies(f, hf);</span>
<span class="nc bnc" id="L1366" title="All 2 branches missed.">    if(rootName != null) {</span>
<span class="nc" id="L1367">      Label hl = headTerminal(hf).label();</span>
<span class="nc" id="L1368">      CoreLabel rl = new CoreLabel();</span>
<span class="nc" id="L1369">      rl.set(CoreAnnotations.TextAnnotation.class, rootName);</span>
<span class="nc" id="L1370">      rl.set(CoreAnnotations.IndexAnnotation.class, 0);</span>
<span class="nc" id="L1371">      deps.add(new NamedDependency(rl, hl, rootName));</span>
    }
<span class="nc" id="L1373">    return deps;</span>
  }

  /**
   * Gets the yield of the tree.  The &lt;code&gt;Label&lt;/code&gt; of all leaf nodes
   * is returned
   * as a list ordered by the natural left to right order of the
   * leaves.  Null values, if any, are inserted into the list like any
   * other value.
   *
   * @return a &lt;code&gt;List&lt;/code&gt; of the data in the tree's leaves.
   */
  public ArrayList&lt;Label&gt; yield() {
<span class="fc" id="L1386">    return yield(new ArrayList&lt;Label&gt;());</span>
  }

  /**
   * Gets the yield of the tree.  The &lt;code&gt;Label&lt;/code&gt; of all leaf nodes
   * is returned
   * as a list ordered by the natural left to right order of the
   * leaves.  Null values, if any, are inserted into the list like any
   * other value.
   * &lt;p&gt;&lt;i&gt;Implementation notes:&lt;/i&gt; c. 2003: This has been rewritten to thread, so only one List
   * is used. 2007: This method was duplicated to start to give type safety to Sentence.
   * This method will now make a Word for any Leaf which does not itself implement HasWord, and
   * put the Word into the Sentence, so the Sentence elements MUST implement HasWord.
   *
   * @param y The list in which the yield of the tree will be placed.
   *          Normally, this will be empty when the routine is called, but
   *          if not, the new yield is added to the end of the list.
   * @return a &lt;code&gt;List&lt;/code&gt; of the data in the tree's leaves.
   */
  public ArrayList&lt;Label&gt; yield(ArrayList&lt;Label&gt; y) {
<span class="fc bfc" id="L1406" title="All 2 branches covered.">    if (isLeaf()) {</span>
<span class="fc" id="L1407">      y.add(label());</span>

    } else {
<span class="fc" id="L1410">      Tree[] kids = children();</span>
<span class="fc bfc" id="L1411" title="All 2 branches covered.">      for (Tree kid : kids) {</span>
<span class="fc" id="L1412">        kid.yield(y);</span>
      }
    }
<span class="fc" id="L1415">    return y;</span>
  }

  public ArrayList&lt;Word&gt; yieldWords() {
<span class="nc" id="L1419">    return yieldWords(new ArrayList&lt;&gt;());</span>
  }

  public ArrayList&lt;Word&gt; yieldWords(ArrayList&lt;Word&gt; y) {
<span class="nc bnc" id="L1423" title="All 2 branches missed.">    if (isLeaf()) {</span>
<span class="nc" id="L1424">      y.add(new Word(label()));</span>
    } else {
<span class="nc bnc" id="L1426" title="All 2 branches missed.">      for (Tree kid : children()) {</span>
<span class="nc" id="L1427">        kid.yieldWords(y);</span>
      }
    }
<span class="nc" id="L1430">    return y;</span>
  }

  public &lt;X extends HasWord&gt; ArrayList&lt;X&gt; yieldHasWord() {
<span class="nc" id="L1434">    return yieldHasWord(new ArrayList&lt;&gt;());</span>
  }

  @SuppressWarnings(&quot;unchecked&quot;)
  public &lt;X extends HasWord&gt; ArrayList&lt;X&gt; yieldHasWord(ArrayList&lt;X&gt; y) {
<span class="nc bnc" id="L1439" title="All 2 branches missed.">    if (isLeaf()) {</span>
<span class="nc" id="L1440">      Label lab = label();</span>
      // cdm: this is new hacked in stuff in Mar 2007 so we can now have a
      // well-typed version of a Sentence, whose objects MUST implement HasWord
      //
      // wsg (Feb. 2010) - More hacks for trees with CoreLabels in which the type implements
      // HasWord but only the value field is populated. This can happen if legacy code uses
      // LabeledScoredTreeFactory but passes in a StringLabel to e.g. newLeaf().
<span class="nc bnc" id="L1447" title="All 2 branches missed.">      if (lab instanceof HasWord) {</span>
<span class="nc bnc" id="L1448" title="All 2 branches missed.">        if(lab instanceof CoreLabel) {</span>
<span class="nc" id="L1449">          CoreLabel cl = (CoreLabel) lab;</span>
<span class="nc bnc" id="L1450" title="All 2 branches missed.">          if(cl.word() == null)</span>
<span class="nc" id="L1451">            cl.setWord(cl.value());</span>
<span class="nc" id="L1452">          y.add((X) cl);</span>
<span class="nc" id="L1453">        } else {</span>
<span class="nc" id="L1454">          y.add((X) lab);</span>
        }

      } else {
<span class="nc" id="L1458">        y.add((X) new Word(lab));</span>
      }

<span class="nc" id="L1461">    } else {</span>
<span class="nc" id="L1462">      Tree[] kids = children();</span>
<span class="nc bnc" id="L1463" title="All 2 branches missed.">      for (Tree kid : kids) {</span>
<span class="nc" id="L1464">        kid.yield(y);</span>
      }
    }
<span class="nc" id="L1467">    return y;</span>
  }


  /**
   * Gets the yield of the tree.  The &lt;code&gt;Label&lt;/code&gt; of all leaf nodes
   * is returned
   * as a list ordered by the natural left to right order of the
   * leaves.  Null values, if any, are inserted into the list like any
   * other value.  This has been rewritten to thread, so only one List
   * is used.
   *
   * @param y The list in which the yield of the tree will be placed.
   *          Normally, this will be empty when the routine is called, but
   *          if not, the new yield is added to the end of the list.
   * @return a &lt;code&gt;List&lt;/code&gt; of the data in the tree's leaves.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public &lt;T&gt; List&lt;T&gt; yield(List&lt;T&gt; y) {
<span class="nc bnc" id="L1486" title="All 2 branches missed.">    if (isLeaf()) {</span>
<span class="nc bnc" id="L1487" title="All 2 branches missed.">      if(label() instanceof HasWord) {</span>
<span class="nc" id="L1488">        HasWord hw = (HasWord) label();</span>
<span class="nc" id="L1489">        hw.setWord(label().value());</span>
      }
<span class="nc" id="L1491">      y.add((T) label());</span>

    } else {
<span class="nc" id="L1494">      Tree[] kids = children();</span>
<span class="nc bnc" id="L1495" title="All 2 branches missed.">      for (Tree kid : kids) {</span>
<span class="nc" id="L1496">        kid.yield(y);</span>
      }
    }
<span class="nc" id="L1499">    return y;</span>
  }

  /**
   * Gets the tagged yield of the tree.
   * The &lt;code&gt;Label&lt;/code&gt; of all leaf nodes is returned
   * as a list ordered by the natural left to right order of the
   * leaves.  Null values, if any, are inserted into the list like any
   * other value.
   *
   * @return a &lt;code&gt;List&lt;/code&gt; of the data in the tree's leaves.
   */
  public ArrayList&lt;TaggedWord&gt; taggedYield() {
<span class="fc" id="L1512">    return taggedYield(new ArrayList&lt;&gt;());</span>
  }

  public List&lt;LabeledWord&gt; labeledYield() {
<span class="nc" id="L1516">    return labeledYield(new ArrayList&lt;&gt;());</span>
  }

  /**
   * Gets the tagged yield of the tree -- that is, get the preterminals
   * as well as the terminals.  The &lt;code&gt;Label&lt;/code&gt; of all leaf nodes
   * is returned
   * as a list ordered by the natural left to right order of the
   * leaves.  Null values, if any, are inserted into the list like any
   * other value.  This has been rewritten to thread, so only one List
   * is used.
   * &lt;p/&gt;
   * &lt;i&gt;Implementation note:&lt;/i&gt; when we summon up enough courage, this
   * method will be changed to take and return a {@code List&lt;W extends TaggedWord&gt;}.
   *
   * @param ty The list in which the tagged yield of the tree will be
   *           placed. Normally, this will be empty when the routine is called,
   *           but if not, the new yield is added to the end of the list.
   * @return a &lt;code&gt;List&lt;/code&gt; of the data in the tree's leaves.
   */
  public &lt;X extends List&lt;TaggedWord&gt;&gt; X taggedYield(X ty) {
<span class="fc bfc" id="L1537" title="All 2 branches covered.">    if (isPreTerminal()) {</span>
<span class="fc" id="L1538">      ty.add(new TaggedWord(firstChild().label(), label()));</span>
    } else {
<span class="fc bfc" id="L1540" title="All 2 branches covered.">      for (Tree kid : children()) {</span>
<span class="fc" id="L1541">        kid.taggedYield(ty);</span>
      }
    }
<span class="fc" id="L1544">    return ty;</span>
  }

  public List&lt;LabeledWord&gt; labeledYield(List&lt;LabeledWord&gt; ty) {
<span class="nc bnc" id="L1548" title="All 2 branches missed.">    if (isPreTerminal()) {</span>
<span class="nc" id="L1549">      ty.add(new LabeledWord(firstChild().label(), label()));</span>
    } else {
<span class="nc bnc" id="L1551" title="All 2 branches missed.">      for (Tree kid : children()) {</span>
<span class="nc" id="L1552">        kid.labeledYield(ty);</span>
      }
    }
<span class="nc" id="L1555">    return ty;</span>
  }

  /** Returns a {@code List&lt;CoreLabel&gt;} from the tree.
   *  These are a copy of the complete token representation
   *  that adds the tag as the tag and value.
   *
   *  @return A tagged, labeled yield.
   */
  public List&lt;CoreLabel&gt; taggedLabeledYield() {
<span class="fc" id="L1565">    List&lt;CoreLabel&gt; ty = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1566">    taggedLabeledYield(ty, 0);</span>
<span class="fc" id="L1567">    return ty;</span>
  }

  private int taggedLabeledYield(List&lt;CoreLabel&gt; ty, int termIdx) {
<span class="fc bfc" id="L1571" title="All 2 branches covered.">    if (isPreTerminal()) {</span>
      // usually this will fill in all the usual keys for a token
<span class="fc" id="L1573">      CoreLabel taggedWord = new CoreLabel(firstChild().label());</span>
      // but in case this just came from reading a tree that just has a value for words
<span class="pc bpc" id="L1575" title="1 of 2 branches missed.">      if (taggedWord.word() == null) {</span>
<span class="fc" id="L1576">        taggedWord.setWord(firstChild().value());</span>
      }
<span class="pc bpc" id="L1578" title="1 of 2 branches missed.">      final String tag = (value() == null) ? &quot;&quot; : value();</span>
      // set value and tag to the tag
<span class="fc" id="L1580">      taggedWord.setValue(tag);</span>
<span class="fc" id="L1581">      taggedWord.setTag(tag);</span>
<span class="fc" id="L1582">      taggedWord.setIndex(termIdx);</span>
<span class="fc" id="L1583">      ty.add(taggedWord);</span>

<span class="fc" id="L1585">      return termIdx + 1;</span>

    } else {
<span class="fc bfc" id="L1588" title="All 2 branches covered.">      for (Tree kid : getChildrenAsList())</span>
<span class="fc" id="L1589">        termIdx = kid.taggedLabeledYield(ty, termIdx);</span>
    }

<span class="fc" id="L1592">    return termIdx;</span>
  }

  /**
   * Gets the preterminal yield (i.e., tags) of the tree.  All data in
   * preterminal nodes is returned as a list ordered by the natural left to
   * right order of the tree.  Null values, if any, are inserted into the
   * list like any other value.  Pre-leaves are nodes of height 1.
   *
   * @return a {@code List} of the data in the tree's pre-leaves.
   */
  public List&lt;Label&gt; preTerminalYield() {
<span class="fc" id="L1604">    return preTerminalYield(new ArrayList&lt;&gt;());</span>
  }


  /**
   * Gets the preterminal yield (i.e., tags) of the tree.  All data in
   * preleaf nodes is returned as a list ordered by the natural left to
   * right order of the tree.  Null values, if any, are inserted into the
   * list like any other value.  Pre-leaves are nodes of height 1.
   *
   * @param y The list in which the preterminals of the tree will be
   *          placed. Normally, this will be empty when the routine is called,
   *          but if not, the new yield is added to the end of the list.
   * @return a &lt;code&gt;List&lt;/code&gt; of the data in the tree's pre-leaves.
   */
  public List&lt;Label&gt; preTerminalYield(List&lt;Label&gt; y) {
<span class="fc bfc" id="L1620" title="All 2 branches covered.">    if (isPreTerminal()) {</span>
<span class="fc" id="L1621">      y.add(label());</span>
    } else {
<span class="fc" id="L1623">      Tree[] kids = children();</span>
<span class="fc bfc" id="L1624" title="All 2 branches covered.">      for (Tree kid : kids) {</span>
<span class="fc" id="L1625">        kid.preTerminalYield(y);</span>
      }
    }
<span class="fc" id="L1628">    return y;</span>
  }

  /**
   * Gets the leaves of the tree.  All leaves nodes are returned as a list
   * ordered by the natural left to right order of the tree.  Null values,
   * if any, are inserted into the list like any other value.
   *
   * @return a &lt;code&gt;List&lt;/code&gt; of the leaves.
   */
  public &lt;T extends Tree&gt; List&lt;T&gt; getLeaves() {
<span class="fc" id="L1639">    return getLeaves(new ArrayList&lt;&gt;());</span>
  }

  /**
   * Gets the leaves of the tree.
   *
   * @param list The list in which the leaves of the tree will be
   *             placed. Normally, this will be empty when the routine is called,
   *             but if not, the new yield is added to the end of the list.
   * @return a &lt;code&gt;List&lt;/code&gt; of the leaves.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public &lt;T extends Tree&gt; List&lt;T&gt; getLeaves(List&lt;T&gt; list) {
<span class="fc bfc" id="L1652" title="All 2 branches covered.">    if (isLeaf()) {</span>
<span class="fc" id="L1653">      list.add((T)this);</span>
    } else {
<span class="fc bfc" id="L1655" title="All 2 branches covered.">      for (Tree kid : children()) {</span>
<span class="fc" id="L1656">        kid.getLeaves(list);</span>
      }
    }
<span class="fc" id="L1659">    return list;</span>
  }


  /**
   * Get the set of all node and leaf {@code Label}s,
   * null or otherwise, contained in the tree.
   *
   * @return the {@code Collection} (actually, Set) of all values
   *         in the tree.
   */
  @Override
  public Collection&lt;Label&gt; labels() {
<span class="nc" id="L1672">    Set&lt;Label&gt; n = Generics.newHashSet();</span>
<span class="nc" id="L1673">    n.add(label());</span>
<span class="nc" id="L1674">    Tree[] kids = children();</span>
<span class="nc bnc" id="L1675" title="All 2 branches missed.">    for (Tree kid : kids) {</span>
<span class="nc" id="L1676">      n.addAll(kid.labels());</span>
    }
<span class="nc" id="L1678">    return n;</span>
  }


  @Override
  public void setLabels(Collection&lt;Label&gt; c) {
<span class="nc" id="L1684">    throw new UnsupportedOperationException(&quot;Can't set Tree labels&quot;);</span>
  }


  /**
   * Return a flattened version of a tree.  In many circumstances, this
   * will just return the tree, but if the tree is something like a
   * binarized version of a dependency grammar tree, then it will be
   * flattened back to a dependency grammar tree representation.  Formally,
   * a node will be removed from the tree when: it is not a terminal or
   * preterminal, and its &lt;code&gt;label()&lt;/code is &lt;code&gt;equal()&lt;/code&gt; to
   * the &lt;code&gt;label()&lt;/code&gt; of its parent, and all its children will
   * then be promoted to become children of the parent (in the same
   * position in the sequence of daughters.
   *
   * @return A flattened version of this tree.
   */
  public Tree flatten() {
<span class="nc" id="L1702">    return flatten(treeFactory());</span>
  }

  /**
   * Return a flattened version of a tree.  In many circumstances, this
   * will just return the tree, but if the tree is something like a
   * binarized version of a dependency grammar tree, then it will be
   * flattened back to a dependency grammar tree representation.  Formally,
   * a node will be removed from the tree when: it is not a terminal or
   * preterminal, and its &lt;code&gt;label()&lt;/code is &lt;code&gt;equal()&lt;/code&gt; to
   * the &lt;code&gt;label()&lt;/code&gt; of its parent, and all its children will
   * then be promoted to become children of the parent (in the same
   * position in the sequence of daughters. &lt;p&gt;
   * Note: In the current implementation, the tree structure is mainly
   * duplicated, but the links between preterminals and terminals aren't.
   *
   * @param tf TreeFactory used to create tree structure for flattened tree
   * @return A flattened version of this tree.
   */
  public Tree flatten(TreeFactory tf) {
<span class="nc bnc" id="L1722" title="All 4 branches missed.">    if (isLeaf() || isPreTerminal()) {</span>
<span class="nc" id="L1723">      return this;</span>
    }
<span class="nc" id="L1725">    Tree[] kids = children();</span>
<span class="nc" id="L1726">    List&lt;Tree&gt; newChildren = new ArrayList&lt;&gt;(kids.length);</span>
<span class="nc bnc" id="L1727" title="All 2 branches missed.">    for (Tree child : kids) {</span>
<span class="nc bnc" id="L1728" title="All 4 branches missed.">      if (child.isLeaf() || child.isPreTerminal()) {</span>
<span class="nc" id="L1729">        newChildren.add(child);</span>
      } else {
<span class="nc" id="L1731">        Tree newChild = child.flatten(tf);</span>
<span class="nc bnc" id="L1732" title="All 2 branches missed.">        if (label().equals(newChild.label())) {</span>
<span class="nc" id="L1733">          newChildren.addAll(newChild.getChildrenAsList());</span>
        } else {
<span class="nc" id="L1735">          newChildren.add(newChild);</span>
        }
      }
    }
<span class="nc" id="L1739">    return tf.newTreeNode(label(), newChildren);</span>
  }


  /**
   * Get the set of all subtrees inside the tree by returning a tree
   * rooted at each node.  These are &lt;i&gt;not&lt;/i&gt; copies, but all share
   * structure.  The tree is regarded as a subtree of itself.
   * &lt;p/&gt;
   * &lt;i&gt;Note:&lt;/i&gt; If you only want to form this Set so that you can
   * iterate over it, it is more efficient to simply use the Tree class's
   * own &lt;code&gt;iterator() method. This will iterate over the exact same
   * elements (but perhaps/probably in a different order).
   *
   * @return the &lt;code&gt;Set&lt;/code&gt; of all subtrees in the tree.
   */
  public Set&lt;Tree&gt; subTrees() {
<span class="fc" id="L1756">    return subTrees(Generics.&lt;Tree&gt;newHashSet());</span>
  }

  /**
   * Get the list of all subtrees inside the tree by returning a tree
   * rooted at each node.  These are &lt;i&gt;not&lt;/i&gt; copies, but all share
   * structure.  The tree is regarded as a subtree of itself.
   * &lt;p/&gt;
   * &lt;i&gt;Note:&lt;/i&gt; If you only want to form this Collection so that you can
   * iterate over it, it is more efficient to simply use the Tree class's
   * own &lt;code&gt;iterator() method. This will iterate over the exact same
   * elements (but perhaps/probably in a different order).
   *
   * @return the &lt;code&gt;List&lt;/code&gt; of all subtrees in the tree.
   */
  public List&lt;Tree&gt; subTreeList() {
<span class="fc" id="L1772">    return subTrees(new ArrayList&lt;&gt;());</span>
  }


  /**
   * Add the set of all subtrees inside a tree (including the tree itself)
   * to the given &lt;code&gt;Collection&lt;/code&gt;.
   * &lt;p/&gt;
   * &lt;i&gt;Note:&lt;/i&gt; If you only want to form this Collection so that you can
   * iterate over it, it is more efficient to simply use the Tree class's
   * own &lt;code&gt;iterator() method. This will iterate over the exact same
   * elements (but perhaps/probably in a different order).
   *
   * @param n A collection of nodes to which the subtrees will be added.
   * @return The collection parameter with the subtrees added.
   */
  public &lt;T extends Collection&lt;Tree&gt;&gt; T subTrees(T n) {
<span class="fc" id="L1789">    n.add(this);</span>
<span class="fc" id="L1790">    Tree[] kids = children();</span>
<span class="fc bfc" id="L1791" title="All 2 branches covered.">    for (Tree kid : kids) {</span>
<span class="fc" id="L1792">      kid.subTrees(n);</span>
    }
<span class="fc" id="L1794">    return n;</span>
  }

  /**
   * Makes a deep copy of not only the Tree structure but of the labels as well.
   * Uses the TreeFactory of the root node given by treeFactory().
   * Assumes that your labels give a non-null labelFactory().
   * (Added by Aria Haghighi.)
   *
   * @return A deep copy of the tree structure and its labels
   */
  public Tree deepCopy() {
<span class="fc" id="L1806">    return deepCopy(treeFactory());</span>
  }


  /**
   * Makes a deep copy of not only the Tree structure but of the labels as well.
   * The new tree will have nodes made by the given TreeFactory.
   * Each Label is copied using the labelFactory() returned
   * by the corresponding node's label.
   * It assumes that your labels give non-null labelFactory.
   * (Added by Aria Haghighi.)
   *
   * @param tf The TreeFactory used to make all nodes in the copied
   *           tree structure
   * @return A Tree that is a deep copy of the tree structure and
   *         Labels of the original tree.
   */
  public Tree deepCopy(TreeFactory tf) {
<span class="fc" id="L1824">    return deepCopy(tf, label().labelFactory());</span>
  }


  /**
   * Makes a deep copy of not only the Tree structure but of the labels as well.
   * Each tree is copied with the given TreeFactory.
   * Each Label is copied using the given LabelFactory.
   * That is, the tree and label factories can transform the nature of the
   * data representation.
   *
   * @param tf The TreeFactory used to make all nodes in the copied
   *           tree structure
   * @param lf The LabelFactory used to make all nodes in the copied
   *           tree structure
   * @return A Tree that is a deep copy of the tree structure and
   *         Labels of the original tree.
   */

  @SuppressWarnings({&quot;unchecked&quot;})
  public Tree deepCopy(TreeFactory tf, LabelFactory lf) {
<span class="fc" id="L1845">    Label label = lf.newLabel(label());</span>
<span class="fc bfc" id="L1846" title="All 2 branches covered.">    if (isLeaf()) {</span>
<span class="fc" id="L1847">      return tf.newLeaf(label);</span>
    }
<span class="fc" id="L1849">    Tree[] kids = children();</span>
    // NB: The below list may not be of type Tree but TreeGraphNode, so we leave it untyped
<span class="fc" id="L1851">    List newKids = new ArrayList(kids.length);</span>
<span class="fc bfc" id="L1852" title="All 2 branches covered.">    for (Tree kid : kids) {</span>
<span class="fc" id="L1853">      newKids.add(kid.deepCopy(tf, lf));</span>
    }
<span class="fc" id="L1855">    return tf.newTreeNode(label, newKids);</span>
  }


  /**
   * Create a deep copy of the tree structure.  The entire structure is
   * recursively copied, but label data themselves are not cloned.
   * The copy is built using a &lt;code&gt;TreeFactory&lt;/code&gt; that will
   * produce a &lt;code&gt;Tree&lt;/code&gt; like the input one.
   *
   * @return A deep copy of the tree structure (but not its labels).
   */
  public Tree treeSkeletonCopy() {
<span class="nc" id="L1868">    return treeSkeletonCopy(treeFactory());</span>
  }


  /**
   * Create a deep copy of the tree structure.  The entire structure is
   * recursively copied, but label data themselves are not cloned.
   * By specifying an appropriate &lt;code&gt;TreeFactory&lt;/code&gt;, this
   * method can be used to change the type of a &lt;code&gt;Tree&lt;/code&gt;.
   *
   * @param tf The &lt;code&gt;TreeFactory&lt;/code&gt; to be used for creating
   *           the returned &lt;code&gt;Tree&lt;/code&gt;
   * @return A deep copy of the tree structure (but not its labels).
   */
  public Tree treeSkeletonCopy(TreeFactory tf) {
    Tree t;
<span class="nc bnc" id="L1884" title="All 2 branches missed.">    if (isLeaf()) {</span>
<span class="nc" id="L1885">      t = tf.newLeaf(label());</span>
    } else {
<span class="nc" id="L1887">      Tree[] kids = children();</span>
<span class="nc" id="L1888">      List&lt;Tree&gt; newKids = new ArrayList&lt;&gt;(kids.length);</span>
<span class="nc bnc" id="L1889" title="All 2 branches missed.">      for (Tree kid : kids) {</span>
<span class="nc" id="L1890">        newKids.add(kid.treeSkeletonCopy(tf));</span>
      }
<span class="nc" id="L1892">      t = tf.newTreeNode(label(), newKids);</span>
    }
<span class="nc" id="L1894">    return t;</span>
  }

  /**
   * Returns a deep copy of everything but the leaf labels.  The leaf
   * labels are reused from the original tree.  This is useful for
   * cases such as the dependency converter, which wants to finish
   * with the same labels in the dependencies as the parse tree.
   */
  public Tree treeSkeletonConstituentCopy() {
<span class="nc" id="L1904">    return treeSkeletonConstituentCopy(treeFactory(), label().labelFactory());</span>
  }

  public Tree treeSkeletonConstituentCopy(TreeFactory tf, LabelFactory lf) {
<span class="nc bnc" id="L1908" title="All 2 branches missed.">    if (isLeaf()) {</span>
      // Reuse the current label for a leaf.  This way, trees which
      // are based on tokens in a sentence can have the same tokens
      // even after a &quot;deep copy&quot;.
      // TODO: the LabeledScoredTreeFactory copies the label for a new
      // leaf.  Perhaps we could add a newLeafNoCopy or something like
      // that for efficiency.
<span class="nc" id="L1915">      Tree newLeaf = tf.newLeaf(label());</span>
<span class="nc" id="L1916">      newLeaf.setLabel(label());</span>
<span class="nc" id="L1917">      return newLeaf;</span>
    }
<span class="nc" id="L1919">    Label label = lf.newLabel(label());</span>
<span class="nc" id="L1920">    Tree[] kids = children();</span>
<span class="nc" id="L1921">    List&lt;Tree&gt; newKids = new ArrayList&lt;&gt;(kids.length);</span>
<span class="nc bnc" id="L1922" title="All 2 branches missed.">    for (Tree kid : kids) {</span>
<span class="nc" id="L1923">      newKids.add(kid.treeSkeletonConstituentCopy(tf, lf));</span>
    }
<span class="nc" id="L1925">    return tf.newTreeNode(label, newKids);</span>
  }

  /**
   * Create a transformed Tree.  The tree is traversed in a depth-first,
   * left-to-right order, and the &lt;code&gt;TreeTransformer&lt;/code&gt; is called
   * on each node.  It returns some &lt;code&gt;Tree&lt;/code&gt;.  The transformed
   * tree has a new tree structure (i.e., a &quot;deep copy&quot; is done), but it
   * will usually share its labels with the original tree.
   *
   * @param transformer The function that transforms tree nodes or subtrees
   * @return a transformation of this &lt;code&gt;Tree&lt;/code&gt;
   */
  public Tree transform(final TreeTransformer transformer) {
<span class="fc" id="L1939">    return transform(transformer, treeFactory());</span>
  }


  /**
   * Create a transformed Tree.  The tree is traversed in a depth-first,
   * left-to-right order, and the &lt;code&gt;TreeTransformer&lt;/code&gt; is called
   * on each node.  It returns some &lt;code&gt;Tree&lt;/code&gt;.  The transformed
   * tree has a new tree structure (i.e., a deep copy of the structure of the tree is done), but it
   * will usually share its labels with the original tree.
   *
   * @param transformer The function that transforms tree nodes or subtrees
   * @param tf          The &lt;code&gt;TreeFactory&lt;/code&gt; which will be used for creating
   *                    new nodes for the returned &lt;code&gt;Tree&lt;/code&gt;
   * @return a transformation of this &lt;code&gt;Tree&lt;/code&gt;
   */
  public Tree transform(final TreeTransformer transformer, final TreeFactory tf) {
    Tree t;
<span class="fc bfc" id="L1957" title="All 2 branches covered.">    if (isLeaf()) {</span>
<span class="fc" id="L1958">      t = tf.newLeaf(label());</span>
    } else {
<span class="fc" id="L1960">      Tree[] kids = children();</span>
<span class="fc" id="L1961">      List&lt;Tree&gt; newKids = new ArrayList&lt;&gt;(kids.length);</span>
<span class="fc bfc" id="L1962" title="All 2 branches covered.">      for (Tree kid : kids) {</span>
<span class="fc" id="L1963">        newKids.add(kid.transform(transformer, tf));</span>
      }
<span class="fc" id="L1965">      t = tf.newTreeNode(label(), newKids);</span>
    }
<span class="fc" id="L1967">    return transformer.transformTree(t);</span>
  }


  /**
   * Creates a (partial) deep copy of the tree, where all nodes that the
   * filter does not accept are spliced out.  If the result is not a tree
   * (that is, it's a forest), an empty root node is generated.
   *
   * @param nodeFilter a Filter method which returns true to mean
   *                   keep this node, false to mean delete it
   * @return a filtered copy of the tree
   */
  public Tree spliceOut(final Predicate&lt;Tree&gt; nodeFilter) {
<span class="fc" id="L1981">    return spliceOut(nodeFilter, treeFactory());</span>
  }


  /**
   * Creates a (partial) deep copy of the tree, where all nodes that the
   * filter does not accept are spliced out.  That is, the particular
   * modes for which the &lt;code&gt;Filter&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;
   * are removed from the &lt;code&gt;Tree&lt;/code&gt;, but those nodes' children
   * are kept (assuming they pass the &lt;code&gt;Filter&lt;/code&gt;, and they are
   * added in the appropriate left-to-right ordering as new children of
   * the parent node.  If the root node is deleted, so that the result
   * would not be a tree (that is, it's a forest), an empty root node is
   * generated.  If nothing is accepted, &lt;code&gt;null&lt;/code&gt; is returned.
   *
   * @param nodeFilter a Filter method which returns true to mean
   *                   keep this node, false to mean delete it
   * @param tf         A &lt;code&gt;TreeFactory&lt;/code&gt; for making new trees. Used if
   *                   the root node is deleted.
   * @return a filtered copy of the tree.
   */
  public Tree spliceOut(final Predicate&lt;Tree&gt; nodeFilter, final TreeFactory tf) {
<span class="fc" id="L2003">    List&lt;Tree&gt; l = spliceOutHelper(nodeFilter, tf);</span>
<span class="pc bpc" id="L2004" title="1 of 2 branches missed.">    if (l.isEmpty()) {</span>
<span class="nc" id="L2005">      return null;</span>
<span class="pc bpc" id="L2006" title="1 of 2 branches missed.">    } else if (l.size() == 1) {</span>
<span class="fc" id="L2007">      return l.get(0);</span>
    }
    // for a forest, make a new root
<span class="nc" id="L2010">    return tf.newTreeNode((Label) null, l);</span>
  }


  private List&lt;Tree&gt; spliceOutHelper(Predicate&lt;Tree&gt; nodeFilter, TreeFactory tf) {
    // recurse over all children first
<span class="fc" id="L2016">    Tree[] kids = children();</span>
<span class="fc" id="L2017">    List&lt;Tree&gt; l = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L2018" title="All 2 branches covered.">    for (Tree kid : kids) {</span>
<span class="fc" id="L2019">      l.addAll(kid.spliceOutHelper(nodeFilter, tf));</span>
    }
    // check if this node is being spliced out
<span class="fc bfc" id="L2022" title="All 2 branches covered.">    if (nodeFilter.test(this)) {</span>
      // no, so add our children and return
      Tree t;
<span class="fc bfc" id="L2025" title="All 2 branches covered.">      if ( ! l.isEmpty()) {</span>
<span class="fc" id="L2026">        t = tf.newTreeNode(label(), l);</span>
      } else {
<span class="fc" id="L2028">        t = tf.newLeaf(label());</span>
      }
<span class="fc" id="L2030">      l = new ArrayList&lt;&gt;(1);</span>
<span class="fc" id="L2031">      l.add(t);</span>
<span class="fc" id="L2032">      return l;</span>
    }
    // we're out, so return our children
<span class="fc" id="L2035">    return l;</span>
  }


  /**
   * Creates a deep copy of the tree, where all nodes that the filter
   * does not accept and all children of such nodes are pruned.  If all
   * of a node's children are pruned, that node is cut as well.
   * A &lt;code&gt;Filter&lt;/code&gt; can assume
   * that it will not be called with a &lt;code&gt;null&lt;/code&gt; argument.
   * &lt;p/&gt;
   * For example, the following code excises all PP nodes from a Tree: &lt;br&gt;
   * &lt;tt&gt;
   * Filter&lt;Tree&gt; f = new Filter&lt;Tree&gt; { &lt;br&gt;
   * public boolean accept(Tree t) { &lt;br&gt;
   * return ! t.label().value().equals(&quot;PP&quot;); &lt;br&gt;
   * } &lt;br&gt;
   * }; &lt;br&gt;
   * tree.prune(f);
   * &lt;/tt&gt; &lt;br&gt;
   *
   * If the root of the tree is pruned, null will be returned.
   *
   * @param filter the filter to be applied
   * @return a filtered copy of the tree, including the possibility of
   *         &lt;code&gt;null&lt;/code&gt; if the root node of the tree is filtered
   */
  public Tree prune(final Predicate&lt;Tree&gt; filter) {
<span class="fc" id="L2063">    return prune(filter, treeFactory());</span>
  }


  /**
   * Creates a deep copy of the tree, where all nodes that the filter
   * does not accept and all children of such nodes are pruned.  If all
   * of a node's children are pruned, that node is cut as well.
   * A &lt;code&gt;Filter&lt;/code&gt; can assume
   * that it will not be called with a &lt;code&gt;null&lt;/code&gt; argument.
   *
   * @param filter the filter to be applied
   * @param tf     the TreeFactory to be used to make new Tree nodes if needed
   * @return a filtered copy of the tree, including the possibility of
   *         &lt;code&gt;null&lt;/code&gt; if the root node of the tree is filtered
   */
  public Tree prune(Predicate&lt;Tree&gt; filter, TreeFactory tf) {
    // is the current node to be pruned?
<span class="fc bfc" id="L2081" title="All 2 branches covered.">    if ( ! filter.test(this)) {</span>
<span class="fc" id="L2082">      return null;</span>
    }
    // if not, recurse over all children
<span class="fc" id="L2085">    List&lt;Tree&gt; l = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L2086">    Tree[] kids = children();</span>
<span class="fc bfc" id="L2087" title="All 2 branches covered.">    for (Tree kid : kids) {</span>
<span class="fc" id="L2088">      Tree prunedChild = kid.prune(filter, tf);</span>
<span class="fc bfc" id="L2089" title="All 2 branches covered.">      if (prunedChild != null) {</span>
<span class="fc" id="L2090">        l.add(prunedChild);</span>
      }
    }
    // and check if this node has lost all its children
<span class="fc bfc" id="L2094" title="All 4 branches covered.">    if (l.isEmpty() &amp;&amp; !(kids.length == 0)) {</span>
<span class="fc" id="L2095">      return null;</span>
    }
    // if we're still ok, copy the node
<span class="fc bfc" id="L2098" title="All 2 branches covered.">    if (isLeaf()) {</span>
<span class="fc" id="L2099">      return tf.newLeaf(label());</span>
    }
<span class="fc" id="L2101">    return tf.newTreeNode(label(), l);</span>
  }

  /**
   * Returns first child if this is unary and if the label at the current
   * node is either &quot;ROOT&quot; or empty.
   *
   * @return The first child if this is unary and if the label at the current
   * node is either &quot;ROOT&quot; or empty, else this
   */
  public Tree skipRoot() {
<span class="nc bnc" id="L2112" title="All 2 branches missed.">    if(!isUnaryRewrite())</span>
<span class="nc" id="L2113">      return this;</span>
<span class="nc" id="L2114">    String lab = label().value();</span>
<span class="nc bnc" id="L2115" title="All 6 branches missed.">    return (lab == null || lab.isEmpty() || &quot;ROOT&quot;.equals(lab)) ? firstChild() : this;</span>
  }

  /**
   * Return a &lt;code&gt;TreeFactory&lt;/code&gt; that produces trees of the
   * appropriate type.
   *
   * @return A factory to produce Trees
   */
  public abstract TreeFactory treeFactory();


  /**
   * Return the parent of the tree node.  This routine may return
   * &lt;code&gt;null&lt;/code&gt; meaning simply that the implementation doesn't
   * know how to determine the parent node, rather than there is no
   * such node.
   *
   * @return The parent &lt;code&gt;Tree&lt;/code&gt; node or &lt;code&gt;null&lt;/code&gt;
   * @see Tree#parent(Tree)
   */
  public Tree parent() {
<span class="nc" id="L2137">    throw new UnsupportedOperationException();</span>
  }


  /**
   * Return the parent of the tree node.  This routine will traverse
   * a tree (depth first) from the given &lt;code&gt;root&lt;/code&gt;, and will
   * correctly find the parent, regardless of whether the concrete
   * class stores parents.  It will only return &lt;code&gt;null&lt;/code&gt; if this
   * node is the &lt;code&gt;root&lt;/code&gt; node, or if this node is not
   * contained within the tree rooted at &lt;code&gt;root&lt;/code&gt;.
   *
   * @param root The root node of the whole Tree
   * @return the parent &lt;code&gt;Tree&lt;/code&gt; node if any;
   *         else &lt;code&gt;null&lt;/code&gt;
   */
  public Tree parent(Tree root) {
<span class="fc" id="L2154">    Tree[] kids = root.children();</span>
<span class="fc" id="L2155">    return parentHelper(root, kids, this);</span>
  }


  private static Tree parentHelper(Tree parent, Tree[] kids, Tree node) {
<span class="fc bfc" id="L2160" title="All 2 branches covered.">    for (Tree kid : kids) {</span>
<span class="fc bfc" id="L2161" title="All 2 branches covered.">      if (kid == node) {</span>
<span class="fc" id="L2162">        return parent;</span>
      }
<span class="fc" id="L2164">      Tree ret = node.parent(kid);</span>
<span class="fc bfc" id="L2165" title="All 2 branches covered.">      if (ret != null) {</span>
<span class="fc" id="L2166">        return ret;</span>
      }
    }
<span class="fc" id="L2169">    return null;</span>
  }


  /**
   * Returns the number of nodes the tree contains.  This method
   * implements the &lt;code&gt;size()&lt;/code&gt; function required by the
   * &lt;code&gt;Collections&lt;/code&gt; interface.  The size of the tree is the
   * number of nodes it contains (of all types, including the leaf nodes
   * and the root).
   *
   * @return The size of the tree
   * @see #depth()
   */
  @Override
  public int size() {
<span class="fc" id="L2185">    int size = 1;</span>
<span class="fc" id="L2186">    Tree[] kids = children();</span>
<span class="fc bfc" id="L2187" title="All 2 branches covered.">    for (Tree kid : kids) {</span>
<span class="fc" id="L2188">      size += kid.size();</span>
    }
<span class="fc" id="L2190">    return size;</span>
  }

  /**
   * Return the ancestor tree node &lt;code&gt;height&lt;/code&gt; nodes up from the current node.
   *
   * @param height How many nodes up to go. A parameter of 0 means return
   *               this node, 1 means to return the parent node and so on.
   * @param root The root node that this Tree is embedded under
   * @return The ancestor at height &lt;code&gt;height&lt;/code&gt;.  It returns null
   *         if it does not exist or the tree implementation does not keep track
   *         of parents
   */
  public Tree ancestor(int height, Tree root) {
<span class="nc bnc" id="L2204" title="All 2 branches missed.">    if (height &lt; 0) {</span>
<span class="nc" id="L2205">      throw new IllegalArgumentException(&quot;ancestor: height cannot be negative&quot;);</span>
    }
<span class="nc bnc" id="L2207" title="All 2 branches missed.">    if (height == 0) {</span>
<span class="nc" id="L2208">      return this;</span>
    }
<span class="nc" id="L2210">    Tree par = parent(root);</span>
<span class="nc bnc" id="L2211" title="All 2 branches missed.">    if (par == null) {</span>
<span class="nc" id="L2212">      return null;</span>
    }
<span class="nc" id="L2214">    return par.ancestor(height - 1, root);</span>
  }


  private static class TreeIterator implements Iterator&lt;Tree&gt; {

    private final List&lt;Tree&gt; treeStack;

<span class="fc" id="L2222">    protected TreeIterator(Tree t) {</span>
<span class="fc" id="L2223">      treeStack = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L2224">      treeStack.add(t);</span>
<span class="fc" id="L2225">    }</span>

    @Override
    public boolean hasNext() {
<span class="fc bfc" id="L2229" title="All 2 branches covered.">      return (!treeStack.isEmpty());</span>
    }

    @Override
    public Tree next() {
<span class="fc" id="L2234">      int lastIndex = treeStack.size() - 1;</span>
<span class="pc bpc" id="L2235" title="1 of 2 branches missed.">      if (lastIndex &lt; 0) {</span>
<span class="nc" id="L2236">        throw new NoSuchElementException(&quot;TreeIterator exhausted&quot;);</span>
      }
<span class="fc" id="L2238">      Tree tr = treeStack.remove(lastIndex);</span>
<span class="fc" id="L2239">      Tree[] kids = tr.children();</span>
      // so that we can efficiently use one List, we reverse them
<span class="fc bfc" id="L2241" title="All 2 branches covered.">      for (int i = kids.length - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L2242">        treeStack.add(kids[i]);</span>
      }
<span class="fc" id="L2244">      return tr;</span>
    }

    /**
     * Not supported
     */
    @Override
    public void remove() {
<span class="fc" id="L2252">      throw new UnsupportedOperationException();</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L2257">      return &quot;TreeIterator&quot;;</span>
    }

  }


  /**
   * Returns an iterator over all the nodes of the tree.  This method
   * implements the &lt;code&gt;iterator()&lt;/code&gt; method required by the
   * &lt;code&gt;Collections&lt;/code&gt; interface.  It does a preorder
   * (children after node) traversal of the tree.  (A possible
   * extension to the class at some point would be to allow different
   * traversal orderings via variant iterators.)
   *
   * @return An iterator over the nodes of the tree
   */
  @Override
  public Iterator&lt;Tree&gt; iterator() {
<span class="fc" id="L2275">    return new TreeIterator(this);</span>
  }

  public List&lt;Tree&gt; postOrderNodeList() {
<span class="nc" id="L2279">    List&lt;Tree&gt; nodes = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L2280">    postOrderRecurse(this, nodes);</span>
<span class="nc" id="L2281">    return nodes;</span>
  }
  private static void postOrderRecurse(Tree t, List&lt;Tree&gt; nodes) {
<span class="nc bnc" id="L2284" title="All 2 branches missed.">    for (Tree c : t.children()) {</span>
<span class="nc" id="L2285">      postOrderRecurse(c, nodes);</span>
    }
<span class="nc" id="L2287">    nodes.add(t);</span>
<span class="nc" id="L2288">  }</span>

  public List&lt;Tree&gt; preOrderNodeList() {
<span class="nc" id="L2291">    List&lt;Tree&gt; nodes = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L2292">    preOrderRecurse(this, nodes);</span>
<span class="nc" id="L2293">    return nodes;</span>
  }
  private static void preOrderRecurse(Tree t, List&lt;Tree&gt; nodes) {
<span class="nc" id="L2296">    nodes.add(t);</span>
<span class="nc bnc" id="L2297" title="All 2 branches missed.">    for (Tree c : t.children()) {</span>
<span class="nc" id="L2298">      preOrderRecurse(c, nodes);</span>
    }
<span class="nc" id="L2300">  }</span>

  /**
   * This gives you a tree from a String representation (as a
   * bracketed Tree, of the kind produced by &lt;code&gt;toString()&lt;/code&gt;,
   * &lt;code&gt;pennPrint()&lt;/code&gt;, or as in the Penn Treebank).
   * It's not the most efficient thing to do for heavy duty usage.
   * The Tree returned is created by a
   * LabeledScoredTreeReaderFactory. This means that &quot;standard&quot;
   * normalizations (stripping functional categories, indices,
   * empty nodes, and A-over-A nodes) will be done on it.
   *
   * @param str The tree as a bracketed list in a String.
   * @return The Tree
   * @throws RuntimeException If Tree format is not valid
   */
  public static Tree valueOf(String str) {
<span class="fc" id="L2317">      return valueOf(str, new LabeledScoredTreeReaderFactory());</span>
  }

  /**
   * This gives you a tree from a String representation (as a
   * bracketed Tree, of the kind produced by &lt;code&gt;toString()&lt;/code&gt;,
   * &lt;code&gt;pennPrint()&lt;/code&gt;, or as in the Penn Treebank.
   * It's not the most efficient thing to do for heavy duty usage.
   *
   * @param str The tree as a bracketed list in a String.
   * @param trf The TreeFactory used to make the new Tree
   * @return The Tree
   * @throws RuntimeException If the Tree format is not valid
   */
  public static Tree valueOf(String str, TreeReaderFactory trf) {
    try {
<span class="fc" id="L2333">      return trf.newTreeReader(new StringReader(str)).readTree();</span>
<span class="nc" id="L2334">    } catch (IOException ioe) {</span>
<span class="nc" id="L2335">      throw new RuntimeException(&quot;Tree.valueOf() tree construction failed&quot;, ioe);</span>
    }
  }


  /**
   * Return the child at some daughter index.  The children are numbered
   * starting with an index of 0.
   *
   * @param i The daughter index
   * @return The tree at that daughter index
   */
  public Tree getChild(int i) {
<span class="fc" id="L2348">    Tree[] kids = children();</span>
<span class="fc" id="L2349">    return kids[i];</span>
  }

  /**
   * Destructively removes the child at some daughter index and returns it.
   * Note
   * that this method will throw an {@link ArrayIndexOutOfBoundsException} if
   * the daughter index is too big for the list of daughters.
   *
   * @param i The daughter index
   * @return The tree at that daughter index
   */
  public Tree removeChild(int i) {
<span class="fc" id="L2362">    Tree[] kids = children();</span>
<span class="fc" id="L2363">    Tree kid = kids[i];</span>
<span class="fc" id="L2364">    Tree[] newKids = new Tree[kids.length - 1];</span>
<span class="fc bfc" id="L2365" title="All 2 branches covered.">    for (int j = 0; j &lt; newKids.length; j++) {</span>
<span class="fc bfc" id="L2366" title="All 2 branches covered.">      if (j &lt; i) {</span>
<span class="fc" id="L2367">        newKids[j] = kids[j];</span>
      } else {
<span class="fc" id="L2369">        newKids[j] = kids[j + 1];</span>
      }
    }
<span class="fc" id="L2372">    setChildren(newKids);</span>
<span class="fc" id="L2373">    return kid;</span>
  }

  /**
   * Adds the tree t at the index position among the daughters.  Note
   * that this method will throw an {@link ArrayIndexOutOfBoundsException} if
   * the daughter index is too big for the list of daughters.
   *
   * @param i the index position at which to add the new daughter
   * @param t the new daughter
   */
  public void addChild(int i, Tree t) {
<span class="fc" id="L2385">    Tree[] kids = children();</span>
<span class="fc" id="L2386">    Tree[] newKids = new Tree[kids.length + 1];</span>
<span class="fc bfc" id="L2387" title="All 2 branches covered.">    if (i != 0) {</span>
<span class="fc" id="L2388">      System.arraycopy(kids, 0, newKids, 0, i);</span>
    }
<span class="fc" id="L2390">    newKids[i] = t;</span>
<span class="fc bfc" id="L2391" title="All 2 branches covered.">    if (i != kids.length) {</span>
<span class="fc" id="L2392">      System.arraycopy(kids, i, newKids, i + 1, kids.length - i);</span>
    }
<span class="fc" id="L2394">    setChildren(newKids);</span>
<span class="fc" id="L2395">  }</span>

  /**
   * Adds the tree t at the last index position among the daughters.
   *
   * @param t the new daughter
   */
  public void addChild(Tree t) {
<span class="fc" id="L2403">    addChild(children().length, t);</span>
<span class="fc" id="L2404">  }</span>

  /**
   * Replaces the &lt;code&gt;i&lt;/code&gt;th child of &lt;code&gt;this&lt;/code&gt; with the tree t.
   * Note
   * that this method will throw an {@link ArrayIndexOutOfBoundsException} if
   * the child index is too big for the list of children.
   *
   * @param i The index position at which to replace the child
   * @param t The new child
   * @return The tree that was previously the ith d
   */
  public Tree setChild(int i, Tree t) {
<span class="fc" id="L2417">    Tree[] kids = children();</span>
<span class="fc" id="L2418">    Tree old = kids[i];</span>
<span class="fc" id="L2419">    kids[i] = t;</span>
<span class="fc" id="L2420">    return old;</span>
  }

  /**
   * Returns true if &lt;code&gt;this&lt;/code&gt; dominates the Tree passed in
   * as an argument.  Object equality (==) rather than .equals() is used
   * to determine domination.
   * t.dominates(t) returns false.
   */
  public boolean dominates(Tree t) {
<span class="fc" id="L2430">    List&lt;Tree&gt; dominationPath = dominationPath(t);</span>
<span class="fc bfc" id="L2431" title="All 4 branches covered.">    return dominationPath != null &amp;&amp; dominationPath.size() &gt; 1;</span>
  }

  /**
   * Returns the path of nodes leading down to a dominated node,
   * including &lt;code&gt;this&lt;/code&gt; and the dominated node itself.
   * Returns null if t is not dominated by &lt;code&gt;this&lt;/code&gt;.  Object
   * equality (==) is the relevant criterion.
   * t.dominationPath(t) returns null.
   */
  public List&lt;Tree&gt; dominationPath(Tree t) {
    //Tree[] result = dominationPathHelper(t, 0);
<span class="fc" id="L2443">    Tree[] result = dominationPath(t, 0);</span>
<span class="fc bfc" id="L2444" title="All 2 branches covered.">    if (result == null) {</span>
<span class="fc" id="L2445">      return null;</span>
    }
<span class="fc" id="L2447">    return Arrays.asList(result);</span>
  }

  private Tree[] dominationPathHelper(Tree t, int depth) {
<span class="fc" id="L2451">    Tree[] kids = children();</span>
<span class="fc bfc" id="L2452" title="All 2 branches covered.">    for (int i = kids.length - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L2453">      Tree t1 = kids[i];</span>
<span class="pc bpc" id="L2454" title="1 of 2 branches missed.">      if (t1 == null) {</span>
<span class="nc" id="L2455">        return null;</span>
      }
      Tree[] result;
<span class="fc bfc" id="L2458" title="All 2 branches covered.">      if ((result = t1.dominationPath(t, depth + 1)) != null) {</span>
<span class="fc" id="L2459">        result[depth] = this;</span>
<span class="fc" id="L2460">        return result;</span>
      }
    }
<span class="fc" id="L2463">    return null;</span>
  }

  private Tree[] dominationPath(Tree t, int depth) {
<span class="fc bfc" id="L2467" title="All 2 branches covered.">    if (this == t) {</span>
<span class="fc" id="L2468">      Tree[] result = new Tree[depth + 1];</span>
<span class="fc" id="L2469">      result[depth] = this;</span>
<span class="fc" id="L2470">      return result;</span>
    }
<span class="fc" id="L2472">    return dominationPathHelper(t, depth);</span>
  }

  /**
   * Given nodes &lt;code&gt;t1&lt;/code&gt; and &lt;code&gt;t2&lt;/code&gt; which are
   * dominated by this node, returns a list of all the nodes on the
   * path from t1 to t2, inclusive, or null if none found.
   */
  public List&lt;Tree&gt; pathNodeToNode(Tree t1, Tree t2) {
<span class="nc bnc" id="L2481" title="All 4 branches missed.">    if (!contains(t1) || !contains(t2)) {</span>
<span class="nc" id="L2482">      return null;</span>
    }
<span class="nc bnc" id="L2484" title="All 2 branches missed.">    if (t1 == t2) {</span>
<span class="nc" id="L2485">      return Collections.singletonList(t1);</span>
    }
<span class="nc bnc" id="L2487" title="All 2 branches missed.">    if (t1.dominates(t2)) {</span>
<span class="nc" id="L2488">      return t1.dominationPath(t2);</span>
    }
<span class="nc bnc" id="L2490" title="All 2 branches missed.">    if (t2.dominates(t1)) {</span>
<span class="nc" id="L2491">      List&lt;Tree&gt; path = t2.dominationPath(t1);</span>
<span class="nc" id="L2492">      Collections.reverse(path);</span>
<span class="nc" id="L2493">      return path;</span>
    }
<span class="nc" id="L2495">    Tree joinNode = joinNode(t1, t2);</span>
<span class="nc bnc" id="L2496" title="All 2 branches missed.">    if (joinNode == null) {</span>
<span class="nc" id="L2497">      return null;</span>
    }
<span class="nc" id="L2499">    List&lt;Tree&gt; t1DomPath = joinNode.dominationPath(t1);</span>
<span class="nc" id="L2500">    List&lt;Tree&gt; t2DomPath = joinNode.dominationPath(t2);</span>
<span class="nc bnc" id="L2501" title="All 4 branches missed.">    if (t1DomPath == null || t2DomPath == null) {</span>
<span class="nc" id="L2502">      return null;</span>
    }
<span class="nc" id="L2504">    ArrayList&lt;Tree&gt; path = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L2505">    path.addAll(t1DomPath);</span>
<span class="nc" id="L2506">    Collections.reverse(path);</span>
<span class="nc" id="L2507">    path.remove(joinNode);</span>
<span class="nc" id="L2508">    path.addAll(t2DomPath);</span>
<span class="nc" id="L2509">    return path;</span>
  }

  /**
   * Given nodes &lt;code&gt;t1&lt;/code&gt; and &lt;code&gt;t2&lt;/code&gt; which are
   * dominated by this node, returns their &quot;join node&quot;: the node
   * &lt;code&gt;j&lt;/code&gt; such that &lt;code&gt;j&lt;/code&gt; dominates both
   * &lt;code&gt;t1&lt;/code&gt; and &lt;code&gt;t2&lt;/code&gt;, and every other node which
   * dominates both &lt;code&gt;t1&lt;/code&gt; and &lt;code&gt;t2&lt;/code&gt;
   * dominates &lt;code&gt;j&lt;/code&gt;.
   * In the special case that t1 dominates t2, return t1, and vice versa.
   * Return &lt;code&gt;null&lt;/code&gt; if no such node can be found.
   */
  public Tree joinNode(Tree t1, Tree t2) {
<span class="nc bnc" id="L2523" title="All 4 branches missed.">    if (!contains(t1) || !contains(t2)) {</span>
<span class="nc" id="L2524">      return null;</span>
    }
<span class="nc bnc" id="L2526" title="All 4 branches missed.">    if (this == t1 || this == t2) {</span>
<span class="nc" id="L2527">      return this;</span>
    }
<span class="nc" id="L2529">    Tree joinNode = null;</span>
<span class="nc" id="L2530">    List&lt;Tree&gt; t1DomPath = dominationPath(t1);</span>
<span class="nc" id="L2531">    List&lt;Tree&gt; t2DomPath = dominationPath(t2);</span>
<span class="nc bnc" id="L2532" title="All 4 branches missed.">    if (t1DomPath == null || t2DomPath == null) {</span>
<span class="nc" id="L2533">      return null;</span>
    }
<span class="nc" id="L2535">    Iterator&lt;Tree&gt; it1 = t1DomPath.iterator();</span>
<span class="nc" id="L2536">    Iterator&lt;Tree&gt; it2 = t2DomPath.iterator();</span>
<span class="nc bnc" id="L2537" title="All 4 branches missed.">    while (it1.hasNext() &amp;&amp; it2.hasNext()) {</span>
<span class="nc" id="L2538">      Tree n1 = it1.next();</span>
<span class="nc" id="L2539">      Tree n2 = it2.next();</span>
<span class="nc bnc" id="L2540" title="All 2 branches missed.">      if (n1 != n2) {</span>
<span class="nc" id="L2541">        break;</span>
      }
<span class="nc" id="L2543">      joinNode = n1;</span>
<span class="nc" id="L2544">    }</span>
<span class="nc" id="L2545">    return joinNode;</span>
  }

  /**
   * Given nodes {@code t1} and {@code t2} which are
   * dominated by this node, returns {@code true} iff
   * {@code t1} c-commands {@code t2}.  (A node c-commands
   * its sister(s) and any nodes below its sister(s).)
   */
  public boolean cCommands(Tree t1, Tree t2) {
<span class="nc" id="L2555">    List&lt;Tree&gt; sibs = t1.siblings(this);</span>
<span class="nc bnc" id="L2556" title="All 2 branches missed.">    if (sibs == null) {</span>
<span class="nc" id="L2557">      return false;</span>
    }
<span class="nc bnc" id="L2559" title="All 2 branches missed.">    for (Tree sib : sibs) {</span>
<span class="nc bnc" id="L2560" title="All 4 branches missed.">      if (sib == t2 || sib.contains(t2)) {</span>
<span class="nc" id="L2561">        return true;</span>
      }
<span class="nc" id="L2563">    }</span>
<span class="nc" id="L2564">    return false;</span>
  }

  /**
   * Returns the siblings of this Tree node.  The siblings are all
   * children of the parent of this node except this node.
   *
   * @param root The root within which this tree node is contained
   * @return The siblings as a list, an empty list if there are no siblings.
   *   The returned list is a modifiable new list structure, but contains
   *   the actual children.
   */
  public List&lt;Tree&gt; siblings(Tree root) {
<span class="nc" id="L2577">    Tree parent = parent(root);</span>
<span class="nc bnc" id="L2578" title="All 2 branches missed.">    if (parent == null) {</span>
<span class="nc" id="L2579">      return null;</span>
    }
<span class="nc" id="L2581">    List&lt;Tree&gt; siblings = parent.getChildrenAsList();</span>
<span class="nc" id="L2582">    siblings.remove(this);</span>
<span class="nc" id="L2583">    return siblings;</span>
  }

  /**
   * insert &lt;code&gt;dtr&lt;/code&gt; after &lt;code&gt;position&lt;/code&gt; existing
   * daughters in &lt;code&gt;this&lt;/code&gt;.
   */
  public void insertDtr(Tree dtr, int position) {
<span class="fc" id="L2591">    Tree[] kids = children();</span>
<span class="pc bpc" id="L2592" title="1 of 2 branches missed.">    if (position &gt; kids.length) {</span>
<span class="nc" id="L2593">      throw new IllegalArgumentException(&quot;Can't insert tree after the &quot; + position + &quot;th daughter in &quot; + this + &quot;; only &quot; + kids.length + &quot; daughters exist!&quot;);</span>
    }
<span class="fc" id="L2595">    Tree[] newKids = new Tree[kids.length + 1];</span>
<span class="fc" id="L2596">    int i = 0;</span>
<span class="fc bfc" id="L2597" title="All 2 branches covered.">    for (; i &lt; position; i++) {</span>
<span class="fc" id="L2598">      newKids[i] = kids[i];</span>
    }
<span class="fc" id="L2600">    newKids[i] = dtr;</span>
<span class="fc bfc" id="L2601" title="All 2 branches covered.">    for (; i &lt; kids.length; i++) {</span>
<span class="fc" id="L2602">      newKids[i + 1] = kids[i];</span>
    }
<span class="fc" id="L2604">    setChildren(newKids);</span>
<span class="fc" id="L2605">  }</span>

  // --- composition methods to implement Label interface

  @Override
  public String value() {
<span class="fc" id="L2611">    Label lab = label();</span>
<span class="pc bpc" id="L2612" title="1 of 2 branches missed.">    if (lab == null) {</span>
<span class="nc" id="L2613">      return null;</span>
    }
<span class="fc" id="L2615">    return lab.value();</span>
  }


  @Override
  public void setValue(String value) {
<span class="fc" id="L2621">    Label lab = label();</span>
<span class="pc bpc" id="L2622" title="1 of 2 branches missed.">    if (lab != null) {</span>
<span class="fc" id="L2623">      lab.setValue(value);</span>
    }
<span class="fc" id="L2625">  }</span>


  @Override
  public void setFromString(String labelStr) {
<span class="nc" id="L2630">    Label lab = label();</span>
<span class="nc bnc" id="L2631" title="All 2 branches missed.">    if (lab != null) {</span>
<span class="nc" id="L2632">      lab.setFromString(labelStr);</span>
    }
<span class="nc" id="L2634">  }</span>

  /**
   * Returns a factory that makes labels of the same type as this one.
   * May return &lt;code&gt;null&lt;/code&gt; if no appropriate factory is known.
   *
   * @return the LabelFactory for this kind of label
   */
  @Override
  public LabelFactory labelFactory() {
<span class="fc" id="L2644">    Label lab = label();</span>
<span class="pc bpc" id="L2645" title="1 of 2 branches missed.">    if (lab == null) {</span>
<span class="nc" id="L2646">      return null;</span>
    }
<span class="fc" id="L2648">    return lab.labelFactory();</span>
  }

  /**
   * Returns the positional index of the left edge of  &lt;i&gt;node&lt;/i&gt; within the tree,
   * as measured by characters.  Returns -1 if &lt;i&gt;node is not found.&lt;/i&gt;
   * Note: These methods were written for internal evaluation routines. They are
   * not the right methods to relate tree nodes to textual offsets. For these,
   * look at the appropriate annotations on a CoreLabel (CharacterOffsetBeginAnnotation, etc.).
   */
  public int leftCharEdge(Tree node) {
<span class="nc" id="L2659">    MutableInteger i = new MutableInteger(0);</span>
<span class="nc bnc" id="L2660" title="All 2 branches missed.">    if (leftCharEdge(node, i)) {</span>
<span class="nc" id="L2661">      return i.intValue();</span>
    }
<span class="nc" id="L2663">    return -1;</span>
  }

  private boolean leftCharEdge(Tree node, MutableInteger i) {
<span class="nc bnc" id="L2667" title="All 2 branches missed.">    if (this == node) {</span>
<span class="nc" id="L2668">      return true;</span>
<span class="nc bnc" id="L2669" title="All 2 branches missed.">    } else if (isLeaf()) {</span>
<span class="nc" id="L2670">      i.set(i.intValue() + value().length());</span>
<span class="nc" id="L2671">      return false;</span>
    } else {
<span class="nc bnc" id="L2673" title="All 2 branches missed.">      for (Tree child : children()) {</span>
<span class="nc bnc" id="L2674" title="All 2 branches missed.">        if (child.leftCharEdge(node, i)) {</span>
<span class="nc" id="L2675">          return true;</span>
        }
      }
<span class="nc" id="L2678">      return false;</span>
    }
  }

  /**
   * Returns the positional index of the right edge of  &lt;i&gt;node&lt;/i&gt; within the tree,
   * as measured by characters. Returns -1 if &lt;i&gt;node is not found.&lt;/i&gt;
   *
   * rightCharEdge returns the index of the rightmost character + 1, so that
   * rightCharEdge(getLeaves().get(i)) == leftCharEdge(getLeaves().get(i+1))
   *
   * Note: These methods were written for internal evaluation routines. They are
   * not the right methods to relate tree nodes to textual offsets. For these,
   * look at the appropriate annotations on a CoreLabel (CharacterOffsetBeginAnnotation, etc.).
   *
   * @param node The subtree to look for in this Tree
   * @return The positional index of the right edge of node
   */
  public int rightCharEdge(Tree node) {
<span class="nc" id="L2697">    List&lt;Tree&gt; s = getLeaves();</span>
<span class="nc" id="L2698">    int length = 0;</span>
<span class="nc bnc" id="L2699" title="All 2 branches missed.">    for (Tree leaf : s) {</span>
<span class="nc" id="L2700">      length += leaf.label().value().length();</span>
<span class="nc" id="L2701">    }</span>
<span class="nc" id="L2702">    MutableInteger i = new MutableInteger(length);</span>
<span class="nc bnc" id="L2703" title="All 2 branches missed.">    if (rightCharEdge(node, i)) {</span>
<span class="nc" id="L2704">      return i.intValue();</span>
    }
<span class="nc" id="L2706">    return -1;</span>
  }

  private boolean rightCharEdge(Tree node, MutableInteger i) {
<span class="nc bnc" id="L2710" title="All 2 branches missed.">    if (this == node) {</span>
<span class="nc" id="L2711">      return true;</span>
<span class="nc bnc" id="L2712" title="All 2 branches missed.">    } else if (isLeaf()) {</span>
<span class="nc" id="L2713">      i.set(i.intValue() - label().value().length());</span>
<span class="nc" id="L2714">      return false;</span>
    } else {
<span class="nc bnc" id="L2716" title="All 2 branches missed.">      for (int j = children().length - 1; j &gt;= 0; j--) {</span>
<span class="nc bnc" id="L2717" title="All 2 branches missed.">        if (children()[j].rightCharEdge(node, i)) {</span>
<span class="nc" id="L2718">          return true;</span>
        }
      }
<span class="nc" id="L2721">      return false;</span>
    }
  }

  /**
   * Calculates the node's &lt;i&gt;number&lt;/i&gt;, defined as the number of nodes traversed in a left-to-right, depth-first search of the
   * tree starting at &lt;code&gt;root&lt;/code&gt; and ending at &lt;code&gt;this&lt;/code&gt;.  Returns -1 if &lt;code&gt;root&lt;/code&gt; does not contain &lt;code&gt;this&lt;/code&gt;.
   * @param root the root node of the relevant tree
   * @return the number of the current node, or -1 if &lt;code&gt;root&lt;/code&gt; does not contain &lt;code&gt;this&lt;/code&gt;.
   */
  public int nodeNumber(Tree root) {
<span class="nc" id="L2732">    MutableInteger i = new MutableInteger(1);</span>
<span class="nc bnc" id="L2733" title="All 2 branches missed.">    if(nodeNumberHelper(root,i))</span>
<span class="nc" id="L2734">      return i.intValue();</span>
<span class="nc" id="L2735">    return -1;</span>
  }

  private boolean nodeNumberHelper(Tree t, MutableInteger i) {
<span class="nc bnc" id="L2739" title="All 2 branches missed.">    if(this==t)</span>
<span class="nc" id="L2740">      return true;</span>
<span class="nc" id="L2741">    i.incValue(1);</span>
<span class="nc bnc" id="L2742" title="All 2 branches missed.">    for (int j = 0; j &lt; t.children().length; j++) {</span>
<span class="nc bnc" id="L2743" title="All 2 branches missed.">      if (nodeNumberHelper(t.children()[j],i))</span>
<span class="nc" id="L2744">        return true;</span>
    }
<span class="nc" id="L2746">    return false;</span>
  }

  /**
   * Fetches the &lt;code&gt;i&lt;/code&gt;th node in the tree, with node numbers defined
   * as in {@link #nodeNumber(Tree)}.
   *
   * @param i the node number to fetch
   * @return the &lt;code&gt;i&lt;/code&gt;th node in the tree
   * @throws IndexOutOfBoundsException if &lt;code&gt;i&lt;/code&gt; is not between 1 and
   *    the number of nodes (inclusive) contained in &lt;code&gt;this&lt;/code&gt;.
   */
  public Tree getNodeNumber(int i) {
<span class="nc" id="L2759">    return getNodeNumberHelper(new MutableInteger(1),i);</span>
  }

  private Tree getNodeNumberHelper(MutableInteger i, int target) {
<span class="nc" id="L2763">    int i1 = i.intValue();</span>
<span class="nc bnc" id="L2764" title="All 2 branches missed.">    if(i1 == target)</span>
<span class="nc" id="L2765">      return this;</span>
<span class="nc bnc" id="L2766" title="All 2 branches missed.">    if(i1 &gt; target)</span>
<span class="nc" id="L2767">      throw new IndexOutOfBoundsException(&quot;Error -- tree does not contain &quot; + i + &quot; nodes.&quot;);</span>
<span class="nc" id="L2768">    i.incValue(1);</span>
<span class="nc bnc" id="L2769" title="All 2 branches missed.">    for(int j = 0; j &lt; children().length; j++) {</span>
<span class="nc" id="L2770">      Tree temp = children()[j].getNodeNumberHelper(i, target);</span>
<span class="nc bnc" id="L2771" title="All 2 branches missed.">      if(temp != null)</span>
<span class="nc" id="L2772">        return temp;</span>
    }
<span class="nc" id="L2774">    return null;</span>
  }

  /**
   * Assign sequential integer indices to the leaves of the tree
   * rooted at this &lt;code&gt;Tree&lt;/code&gt;, starting with 1.
   * The leaves are traversed from left
   * to right. If the node is already indexed, then it uses the existing index.
   * This will only work if the leaves extend CoreMap.
   */
  public void indexLeaves() {
<span class="fc" id="L2785">    indexLeaves(1, false);</span>
<span class="fc" id="L2786">  }</span>

  /**
   * Index the leaves, and optionally overwrite existing IndexAnnotations if they exist.
   *
   * @param overWrite Whether to replace an existing index for a leaf.
   */
  public void indexLeaves(boolean overWrite) {
<span class="fc" id="L2794">    indexLeaves(1, overWrite);</span>
<span class="fc" id="L2795">  }</span>

  /**
   * Assign sequential integer indices to the leaves of the subtree
   * rooted at this &lt;code&gt;Tree&lt;/code&gt;, beginning with
   * &lt;code&gt;startIndex&lt;/code&gt;, and traversing the leaves from left
   * to right. If node is already indexed, then it uses the existing index.
   * This method only works if the labels of the tree implement
   * CoreLabel!
   *
   * @param startIndex index for this node
   * @param overWrite Whether to replace an existing index for a leaf.
   * @return the next index still unassigned
   */
  public int indexLeaves(int startIndex, boolean overWrite) {
<span class="fc bfc" id="L2810" title="All 2 branches covered.">    if (isLeaf()) {</span>

      /*CoreLabel afl = (CoreLabel) label();
      Integer oldIndex = afl.get(CoreAnnotations.IndexAnnotation.class);
      if (!overWrite &amp;&amp; oldIndex != null &amp;&amp; oldIndex &gt;= 0) {
        startIndex = oldIndex;
      } else {
        afl.set(CoreAnnotations.IndexAnnotation.class, startIndex);
      }*/

<span class="pc bpc" id="L2820" title="1 of 2 branches missed.">      if(label() instanceof HasIndex) {</span>
<span class="fc" id="L2821">        HasIndex hi = (HasIndex) label();</span>
<span class="fc" id="L2822">        int oldIndex = hi.index();</span>
<span class="pc bpc" id="L2823" title="1 of 4 branches missed.">        if (!overWrite &amp;&amp; oldIndex &gt;= 0) {</span>
<span class="nc" id="L2824">          startIndex = oldIndex;</span>
        } else {
<span class="fc" id="L2826">          hi.setIndex(startIndex);</span>
        }
<span class="fc" id="L2828">        startIndex++;</span>
<span class="fc" id="L2829">      }</span>
    } else {
<span class="fc bfc" id="L2831" title="All 2 branches covered.">      for (Tree kid : children()) {</span>
<span class="fc" id="L2832">        startIndex = kid.indexLeaves(startIndex, overWrite);</span>
      }
    }
<span class="fc" id="L2835">    return startIndex;</span>
  }

  /**
   * Percolates terminal indices through a dependency tree. The terminals should be indexed, e.g.,
   * by calling indexLeaves() on the tree.
   * &lt;p&gt;
   * This method assumes CoreLabels!
   */
  public void percolateHeadIndices() {
<span class="nc bnc" id="L2845" title="All 2 branches missed.">    if (isPreTerminal()) {</span>
<span class="nc" id="L2846">      int nodeIndex = ((HasIndex) firstChild().label()).index();</span>
<span class="nc" id="L2847">      ((HasIndex) label()).setIndex(nodeIndex);</span>
<span class="nc" id="L2848">      return;</span>
    }

    // Assign the head index to the first child that we encounter with a matching
    // surface form. Obviously a head can have the same surface form as its dependent,
    // and in this case the head index is ambiguous.
<span class="nc" id="L2854">    String wordAnnotation = ((HasWord) label()).word();</span>
<span class="nc bnc" id="L2855" title="All 2 branches missed.">    if (wordAnnotation == null) {</span>
<span class="nc" id="L2856">      wordAnnotation = value();</span>
    }
<span class="nc" id="L2858">    boolean seenHead = false;</span>
<span class="nc bnc" id="L2859" title="All 2 branches missed.">    for (Tree child : children()) {</span>
<span class="nc" id="L2860">      child.percolateHeadIndices();</span>
<span class="nc" id="L2861">      String childWordAnnotation = ((HasWord) child.label()).word();</span>
<span class="nc bnc" id="L2862" title="All 2 branches missed.">      if (childWordAnnotation == null) {</span>
<span class="nc" id="L2863">        childWordAnnotation = child.value();</span>
      }
<span class="nc bnc" id="L2865" title="All 4 branches missed.">      if ( !seenHead &amp;&amp; wordAnnotation.equals(childWordAnnotation)) {</span>
<span class="nc" id="L2866">        seenHead = true;</span>
<span class="nc" id="L2867">        int nodeIndex = ((HasIndex) child.label()).index();</span>
<span class="nc" id="L2868">        ((HasIndex) label()).setIndex(nodeIndex);</span>
      }
    }
<span class="nc" id="L2871">  }</span>

  /** Index all spans (constituents) in the tree.
   *  For this, spans uses 0-based indexing and the span records the fencepost
   *  to the left of the first word and after the last word of the span.
   *  The spans are only recorded if the Tree has labels of a class which
   *  extends CoreMap.
   */
  public void indexSpans() {
<span class="fc" id="L2880">    indexSpans(0);</span>
<span class="fc" id="L2881">  }</span>

  public void indexSpans(int startIndex) {
<span class="fc" id="L2884">    indexSpans(new MutableInteger(startIndex));</span>
<span class="fc" id="L2885">  }</span>

  /**
   * Assigns span indices (BeginIndexAnnotation and EndIndexAnnotation) to all nodes in a tree.
   * The beginning index is equivalent to the IndexAnnotation of the first leaf in the constituent.
   * The end index is equivalent to the first integer after the IndexAnnotation of the last leaf in the constituent.
   *
   * @param startIndex Begin indexing at this value
   */
  public Pair&lt;Integer, Integer&gt; indexSpans(MutableInteger startIndex) {
<span class="fc" id="L2895">    int start = Integer.MAX_VALUE;</span>
<span class="fc" id="L2896">    int end = Integer.MIN_VALUE;</span>

<span class="fc bfc" id="L2898" title="All 2 branches covered.">    if(isLeaf()){</span>
<span class="fc" id="L2899">      start = startIndex.intValue();</span>
<span class="fc" id="L2900">      end = startIndex.intValue() + 1;</span>
<span class="fc" id="L2901">      startIndex.incValue(1);</span>
    } else {
<span class="fc bfc" id="L2903" title="All 2 branches covered.">      for (Tree kid : children()) {</span>
<span class="fc" id="L2904">        Pair&lt;Integer, Integer&gt;  span = kid.indexSpans(startIndex);</span>
<span class="fc bfc" id="L2905" title="All 2 branches covered.">        if(span.first &lt; start) start = span.first;</span>
<span class="pc bpc" id="L2906" title="1 of 2 branches missed.">        if(span.second &gt; end) end = span.second;</span>
      }
    }

<span class="fc" id="L2910">    Label label = label();</span>
<span class="pc bpc" id="L2911" title="1 of 2 branches missed.">    if (label instanceof CoreMap) {</span>
<span class="fc" id="L2912">    CoreMap afl = (CoreMap) label();</span>
<span class="fc" id="L2913">      afl.set(CoreAnnotations.BeginIndexAnnotation.class, start);</span>
<span class="fc" id="L2914">      afl.set(CoreAnnotations.EndIndexAnnotation.class, end);</span>
    }
<span class="fc" id="L2916">    return new Pair&lt;&gt;(start, end);</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>