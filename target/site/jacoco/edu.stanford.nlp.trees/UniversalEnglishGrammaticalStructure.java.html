<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UniversalEnglishGrammaticalStructure.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.trees</a> &gt; <span class="el_source">UniversalEnglishGrammaticalStructure.java</span></div><h1>UniversalEnglishGrammaticalStructure.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.trees;

import java.io.IOException;
import java.io.Serializable;
import java.util.*;
import java.util.function.Predicate;

import edu.stanford.nlp.graph.DirectedMultiGraph;
import edu.stanford.nlp.ling.CoreAnnotations;
import edu.stanford.nlp.ling.IndexedWord;
import edu.stanford.nlp.process.Morphology;
import edu.stanford.nlp.semgraph.SemanticGraph;
import edu.stanford.nlp.semgraph.SemanticGraphEdge;
import edu.stanford.nlp.semgraph.semgrex.SemgrexMatcher;
import edu.stanford.nlp.semgraph.semgrex.SemgrexPattern;
import edu.stanford.nlp.trees.ud.EnhancementOptions;
import edu.stanford.nlp.util.Filters;
import edu.stanford.nlp.util.Generics;
import edu.stanford.nlp.util.logging.Redwood;

import static edu.stanford.nlp.trees.UniversalEnglishGrammaticalRelations.*;
import static edu.stanford.nlp.trees.GrammaticalRelation.*;

/**
 * A GrammaticalStructure for Universal Dependencies English.
 * &lt;p/&gt;
 * For feeding Stanford parser trees into this class, the Stanford parser should be run with the
 * &quot;-retainNPTmpSubcategories&quot; option for best results!
 *
 * @author Bill MacCartney
 * @author Marie-Catherine de Marneffe
 * @author Christopher Manning
 * @author Daniel Cer (CoNLLX format and alternative user selected dependency
 *         printer/reader interface)
 * @author John Bauer
 * @author Sebastian Schuster
 */
public class UniversalEnglishGrammaticalStructure extends GrammaticalStructure  {

  /** A logger for this class */
<span class="fc" id="L41">  private static final Redwood.RedwoodChannels log = Redwood.channels(UniversalEnglishGrammaticalStructure.class);</span>

  private static final long serialVersionUID = 1L;

<span class="pc bpc" id="L45" title="1 of 2 branches missed.">  private static final boolean DEBUG = System.getProperty(&quot;UniversalEnglishGrammaticalStructure&quot;, null) != null;</span>

<span class="pc bpc" id="L47" title="1 of 2 branches missed.">  private static final boolean USE_NAME = System.getProperty(&quot;UDUseNameRelation&quot;) != null;</span>

  /*
   * Options for &quot;Enhanced&quot; representation:
   *
   * - Process multi-word prepositions: No
   * - Add prepositions to relation labels: Yes
   * - Add prepositions only to nmod relations: No
   * - Add coordinating conjunctions to relation labels: Yes
   * - Propagate dependents: Yes
   * - Add &quot;referent&quot; relations: Yes
   * - Add copy nodes for conjoined Ps and PPs: No
   * - Turn quantificational modifiers into flat MWEs: No
   * - Add relations between controlling subject and controlled verbs: Yes
   *
   */
<span class="fc" id="L63">  public static final EnhancementOptions ENHANCED_OPTIONS = new EnhancementOptions(false, true, false, true, true, true,</span>
      false, false, true);

  /*
   * Options for &quot;Enhanced++&quot; representation:
   *
   * - Process multi-word prepositions: Yes
   * - Add prepositions to relation labels: Yes
   * - Add prepositions only to nmod relations: No
   * - Add coordinating conjunctions to relation labels: Yes
   * - Propagate dependents: Yes
   * - Add &quot;referent&quot; relations: Yes
   * - Add copy nodes for conjoined Ps and PPs: Yes
   * - Turn quantificational modifiers into flat MWEs: Yes
   * - Add relations between controlling subject and controlled verbs: Yes
   *
   */
<span class="fc" id="L80">  public static final EnhancementOptions ENHANCED_PLUS_PLUS_OPTIONS = new EnhancementOptions(true, true, false, true, true, true,</span>
      true, true, true);

  /*
   * Options for &quot;Collapsed&quot; representation.
   * This represenation is similar to the &quot;collapsed&quot; SD representation
   * without any &quot;Extra&quot; relations.
   *
   * - Process multi-word prepositions: Yes
   * - Add prepositions to relation labels: Yes
   * - Add prepositions only to nmod relations: Yes
   * - Add coordinating conjunctions to relation labels: Yes
   * - Propagate dependents: No
   * - Add &quot;referent&quot; relations: No
   * - Add copy nodes for conjoined Ps and PPs: Yes
   * - Turn quantificational modifiers into flat MWEs: No
   * - Add relations between controlling subject and controlled verbs: No
   *
   */
  @Deprecated
<span class="fc" id="L100">  public static final EnhancementOptions COLLAPSED_OPTIONS = new EnhancementOptions(true, true, true, true, false, false,</span>
      true, false, false);


  /**
   * Construct a new {@code EnglishGrammaticalStructure} from an existing parse
   * tree. The new {@code GrammaticalStructure} has the same tree structure
   * and label values as the given tree (but no shared storage). As part of
   * construction, the parse tree is analyzed using definitions from
   * {@link GrammaticalRelation {@code GrammaticalRelation}} to populate
   * the new {@code GrammaticalStructure} with as many labeled grammatical
   * relations as it can.
   *
   * @param t Parse tree to make grammatical structure from
   */
  public UniversalEnglishGrammaticalStructure(Tree t) {
<span class="fc" id="L116">    this(t, new PennTreebankLanguagePack().punctuationWordRejectFilter());</span>
<span class="fc" id="L117">  }</span>

  /**
   * This gets used by GrammaticalStructureFactory (by reflection). DON'T DELETE.
   *
   * @param t Parse tree to make grammatical structure from
   * @param tagFilter Filter to remove punctuation dependencies
   */
  public UniversalEnglishGrammaticalStructure(Tree t, Predicate&lt;String&gt; tagFilter) {
<span class="fc" id="L126">    this(t, tagFilter, new UniversalSemanticHeadFinder(true));</span>
<span class="fc" id="L127">  }</span>

  /**
   * Construct a new {@code GrammaticalStructure} from an existing parse
   * tree. The new {@code GrammaticalStructure} has the same tree structure
   * and label values as the given tree (but no shared storage). As part of
   * construction, the parse tree is analyzed using definitions from
   * {@link GrammaticalRelation {@code GrammaticalRelation}} to populate
   * the new {@code GrammaticalStructure} with as many labeled grammatical
   * relations as it can.
   *
   * This gets used by GrammaticalStructureFactory (by reflection). DON'T DELETE.
   *
   * @param t Parse tree to make grammatical structure from
   * @param tagFilter Filter for punctuation tags
   * @param hf HeadFinder to use when building it
   */
  public UniversalEnglishGrammaticalStructure(Tree t, Predicate&lt;String&gt; tagFilter, HeadFinder hf) {

    // the tree is normalized (for index and functional tag stripping) inside CoordinationTransformer
<span class="fc" id="L147">    super(t, UniversalEnglishGrammaticalRelations.values(), UniversalEnglishGrammaticalRelations.valuesLock(),</span>
<span class="fc" id="L148">            new CoordinationTransformer(hf, true), hf, Filters.acceptFilter(), tagFilter);</span>
<span class="fc" id="L149">  }</span>

  /** Used for postprocessing CoNLL X dependencies */
  public UniversalEnglishGrammaticalStructure(List&lt;TypedDependency&gt; projectiveDependencies, TreeGraphNode root) {
<span class="nc" id="L153">    super(projectiveDependencies, root);</span>
<span class="nc" id="L154">  }</span>


  /**
   * Returns a Filter which checks dependencies for usefulness as
   * extra tree-based dependencies.  By default, everything is
   * accepted.  One example of how this can be useful is in the
   * English dependencies, where the REL dependency is used as an
   * intermediate and we do not want this to be added when we make a
   * second pass over the trees for missing dependencies.
   */
  @Override
  protected Predicate&lt;TypedDependency&gt; extraTreeDepFilter() {
<span class="fc" id="L167">    return extraTreeDepFilter;</span>
  }

<span class="fc" id="L170">  private static class ExtraTreeDepFilter implements Predicate&lt;TypedDependency&gt;, Serializable {</span>
    @Override
    public boolean test(TypedDependency d) {
<span class="nc bnc" id="L173" title="All 6 branches missed.">      return d != null &amp;&amp; d.reln() != RELATIVE &amp;&amp; d.reln() != PREPOSITION;</span>
    }

    private static final long serialVersionUID = 1L;
  }

<span class="fc" id="L179">  private static final Predicate&lt;TypedDependency&gt; extraTreeDepFilter = new ExtraTreeDepFilter();</span>


  @Override
  protected void getTreeDeps(List&lt;TypedDependency&gt; deps,
      DirectedMultiGraph&lt;TreeGraphNode, GrammaticalRelation&gt; completeGraph,
      Predicate&lt;TypedDependency&gt; puncTypedDepFilter,
      Predicate&lt;TypedDependency&gt; extraTreeDepFilter) {
  //Do nothing
<span class="fc" id="L188">  }</span>

  @Override
  protected void correctDependencies(List&lt;TypedDependency&gt; list) {
<span class="fc" id="L192">    SemanticGraph sg = new SemanticGraph(list);</span>
<span class="fc" id="L193">    correctDependencies(sg);</span>
<span class="fc" id="L194">    list.clear();</span>
<span class="fc" id="L195">    list.addAll(sg.typedDependencies());</span>
<span class="fc" id="L196">    Collections.sort(list);</span>
<span class="fc" id="L197">  }</span>

  protected static void correctDependencies(SemanticGraph sg) {
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">    if (DEBUG) {</span>
<span class="nc" id="L201">      printListSorted(&quot;At correctDependencies:&quot;, sg.typedDependencies());</span>
    }
<span class="fc" id="L203">    correctSubjPass(sg);</span>
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">    if (DEBUG) {</span>
<span class="nc" id="L205">      printListSorted(&quot;After correctSubjPass:&quot;, sg.typedDependencies());</span>
    }
<span class="fc" id="L207">    processNames(sg);</span>
<span class="pc bpc" id="L208" title="1 of 2 branches missed.">    if (DEBUG) {</span>
<span class="nc" id="L209">      printListSorted(&quot;After processNames:&quot;, sg.typedDependencies());</span>
    }
<span class="fc" id="L211">    removeExactDuplicates(sg);</span>
<span class="pc bpc" id="L212" title="1 of 2 branches missed.">    if (DEBUG) {</span>
<span class="nc" id="L213">      printListSorted(&quot;After removeExactDuplicates:&quot;, sg.typedDependencies());</span>
    }
<span class="fc" id="L215">  }</span>

  private static void printListSorted(String title, Collection&lt;TypedDependency&gt; list) {
<span class="nc" id="L218">    List&lt;TypedDependency&gt; lis = new ArrayList&lt;&gt;(list);</span>
<span class="nc" id="L219">    Collections.sort(lis);</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">    if (title != null) {</span>
<span class="nc" id="L221">      log.info(title);</span>
    }
<span class="nc" id="L223">    log.info(lis);</span>
<span class="nc" id="L224">  }</span>

  @Override
  protected void postProcessDependencies(List&lt;TypedDependency&gt; list) {
<span class="fc" id="L228">    SemanticGraph sg = new SemanticGraph(list);</span>
<span class="fc" id="L229">    postProcessDependencies(sg);</span>
<span class="fc" id="L230">    list.clear();</span>
<span class="fc" id="L231">    list.addAll(sg.typedDependencies());</span>
<span class="fc" id="L232">  }</span>

  protected static void postProcessDependencies(SemanticGraph sg) {
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">    if (DEBUG) {</span>
<span class="nc" id="L236">      printListSorted(&quot;At postProcessDependencies:&quot;, sg.typedDependencies());</span>
    }
<span class="fc" id="L238">    correctWHAttachment(sg);</span>
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">    if (DEBUG) {</span>
<span class="nc" id="L240">      printListSorted(&quot;After corrrecting WH attachment:&quot;, sg.typedDependencies());</span>
    }
<span class="fc" id="L242">    convertRel(sg);</span>
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">    if (DEBUG) {</span>
<span class="nc" id="L244">      printListSorted(&quot;After converting rel:&quot;, sg.typedDependencies());</span>
    }
<span class="fc" id="L246">  }</span>

  @Override
  protected void getExtras(List&lt;TypedDependency&gt; list) {
<span class="fc" id="L250">    SemanticGraph sg = new SemanticGraph(list);</span>
<span class="fc" id="L251">    addRef(sg);</span>
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">    if (DEBUG) {</span>
<span class="nc" id="L253">      printListSorted(&quot;After adding ref:&quot;, sg.typedDependencies());</span>
    }

<span class="fc" id="L256">    addExtraNSubj(sg);</span>
<span class="pc bpc" id="L257" title="1 of 2 branches missed.">    if (DEBUG) {</span>
<span class="nc" id="L258">      printListSorted(&quot;After adding extra nsubj:&quot;, sg.typedDependencies());</span>
    }

<span class="fc" id="L261">    list.clear();</span>
<span class="fc" id="L262">    list.addAll(sg.typedDependencies());</span>
<span class="fc" id="L263">  }</span>


  /* Semgrex patterns for prepositional phrases. */
<span class="fc" id="L267">  private static SemgrexPattern PASSIVE_AGENT_PATTERN = SemgrexPattern.compile(&quot;{}=gov &gt;nmod=reln ({}=mod &gt;case {word:/^(?i:by)$/}=c1) &gt;auxpass {}&quot;);</span>
<span class="fc" id="L268">  private static SemgrexPattern[] PREP_MW3_PATTERNS = {</span>
<span class="fc" id="L269">      SemgrexPattern.compile(&quot;{}=gov   [&gt;/^nmod$/=reln ({}=mod &gt;case ({}=c1 &gt;mwe {}=c2 &gt;mwe ({}=c3 !== {}=c2) ))]&quot;),</span>
<span class="fc" id="L270">      SemgrexPattern.compile(&quot;{}=gov   [&gt;/^(advcl|acl)$/=reln ({}=mod &gt;/^(mark|case)$/ ({}=c1 &gt;mwe {}=c2 &gt;mwe ({}=c3 !== {}=c2) ))]&quot;)</span>

  };
<span class="fc" id="L273">  private static SemgrexPattern[] PREP_MW2_PATTERNS = {</span>
<span class="fc" id="L274">      SemgrexPattern.compile(&quot;{}=gov &gt;/^nmod$/=reln ({}=mod &gt;case ({}=c1 &gt;mwe {}=c2))&quot;),</span>
<span class="fc" id="L275">    SemgrexPattern.compile(&quot;{}=gov &gt;/^(advcl|acl)$/=reln ({}=mod &gt;/^(mark|case)$/ ({}=c1 &gt;mwe {}=c2))&quot;)</span>

  };
<span class="fc" id="L278">  private static SemgrexPattern[] PREP_PATTERNS = {</span>
<span class="fc" id="L279">      SemgrexPattern.compile(&quot;{}=gov   &gt;/^nmod$/=reln ({}=mod &gt;case {}=c1)&quot;),</span>
<span class="fc" id="L280">      SemgrexPattern.compile(&quot;{}=gov   &gt;/^(advcl|acl)$/=reln ({}=mod &gt;/^(mark|case)$/ {}=c1)&quot;)</span>
  };

  /**
   * Adds the case marker(s) to all nmod, acl and advcl relations that are
   * modified by one or more case markers(s).
   *
   * @param enhanceOnlyNmods If this is set to true, then prepositons will only be appended to nmod
   *                         relations (and not to acl or advcl) relations.
   *
   * @see UniversalEnglishGrammaticalStructure#addCaseMarkersToReln
   */
  private static void addCaseMarkerInformation(SemanticGraph sg, boolean enhanceOnlyNmods) {

    /* Semgrexes require a graph with a root. */
<span class="pc bpc" id="L295" title="1 of 2 branches missed.">    if (sg.getRoots().isEmpty())</span>
<span class="nc" id="L296">      return;</span>

    /* passive agent */
<span class="fc" id="L299">    SemanticGraph sgCopy = sg.makeSoftCopy();</span>
<span class="fc" id="L300">    SemgrexMatcher matcher = PASSIVE_AGENT_PATTERN.matcher(sgCopy);</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">    while (matcher.find()) {</span>
<span class="fc" id="L302">      IndexedWord caseMarker = matcher.getNode(&quot;c1&quot;);</span>
<span class="fc" id="L303">      IndexedWord gov = matcher.getNode(&quot;gov&quot;);</span>
<span class="fc" id="L304">      IndexedWord mod = matcher.getNode(&quot;mod&quot;);</span>
<span class="fc" id="L305">      addPassiveAgentToReln(sg, gov, mod, caseMarker);</span>
<span class="fc" id="L306">    }</span>

<span class="fc" id="L308">    List&lt;IndexedWord&gt; oldCaseMarkers = Generics.newArrayList();</span>


    /* 3-word prepositions */
<span class="fc bfc" id="L312" title="All 2 branches covered.">    for (SemgrexPattern p: PREP_MW3_PATTERNS) {</span>
<span class="fc" id="L313">      sgCopy = sg.makeSoftCopy();</span>
<span class="fc" id="L314">      matcher = p.matcher(sgCopy);</span>
<span class="pc bpc" id="L315" title="1 of 2 branches missed.">      while (matcher.find()) {</span>
<span class="nc bnc" id="L316" title="All 4 branches missed.">        if (enhanceOnlyNmods &amp;&amp; ! matcher.getRelnString(&quot;reln&quot;).equals(&quot;nmod&quot;)) {</span>
<span class="nc" id="L317">          continue;</span>
        }

<span class="nc" id="L320">        List&lt;IndexedWord&gt; caseMarkers = Generics.newArrayList(3);</span>
<span class="nc" id="L321">        caseMarkers.add(matcher.getNode(&quot;c1&quot;));</span>
<span class="nc" id="L322">        caseMarkers.add(matcher.getNode(&quot;c2&quot;));</span>
<span class="nc" id="L323">        caseMarkers.add(matcher.getNode(&quot;c3&quot;));</span>

<span class="nc" id="L325">        Collections.sort(caseMarkers);</span>

      /* We only want to match every case marker once. */
<span class="nc bnc" id="L328" title="All 2 branches missed.">        if (caseMarkers.equals(oldCaseMarkers))</span>
<span class="nc" id="L329">          continue;</span>


<span class="nc" id="L332">        IndexedWord gov = matcher.getNode(&quot;gov&quot;);</span>
<span class="nc" id="L333">        IndexedWord mod = matcher.getNode(&quot;mod&quot;);</span>

<span class="nc" id="L335">        addCaseMarkersToReln(sg, gov, mod, caseMarkers);</span>

<span class="nc" id="L337">        oldCaseMarkers = caseMarkers;</span>
<span class="nc" id="L338">      }</span>
    }


    /* 2-word prepositions */
<span class="fc bfc" id="L343" title="All 2 branches covered.">    for (SemgrexPattern p: PREP_MW2_PATTERNS) {</span>
<span class="fc" id="L344">      sgCopy = sg.makeSoftCopy();</span>
<span class="fc" id="L345">      matcher = p.matcher(sgCopy);</span>
<span class="fc bfc" id="L346" title="All 2 branches covered.">      while (matcher.find()) {</span>
<span class="pc bpc" id="L347" title="1 of 4 branches missed.">        if (enhanceOnlyNmods &amp;&amp; ! matcher.getRelnString(&quot;reln&quot;).equals(&quot;nmod&quot;)) {</span>
<span class="fc" id="L348">          continue;</span>
        }

<span class="fc" id="L351">        List&lt;IndexedWord&gt; caseMarkers = Generics.newArrayList(2);</span>
<span class="fc" id="L352">        caseMarkers.add(matcher.getNode(&quot;c1&quot;));</span>
<span class="fc" id="L353">        caseMarkers.add(matcher.getNode(&quot;c2&quot;));</span>
<span class="fc" id="L354">        Collections.sort(caseMarkers);</span>

      /* We only want to match every case marker once. */
<span class="pc bpc" id="L357" title="1 of 2 branches missed.">        if (caseMarkers.equals(oldCaseMarkers))</span>
<span class="nc" id="L358">          continue;</span>

<span class="fc" id="L360">        IndexedWord gov = matcher.getNode(&quot;gov&quot;);</span>
<span class="fc" id="L361">        IndexedWord mod = matcher.getNode(&quot;mod&quot;);</span>
<span class="fc" id="L362">        addCaseMarkersToReln(sg, gov, mod, caseMarkers);</span>

<span class="fc" id="L364">        oldCaseMarkers = caseMarkers;</span>
<span class="fc" id="L365">      }</span>
    }

    /* Single-word prepositions */
<span class="fc bfc" id="L369" title="All 2 branches covered.">    for (SemgrexPattern p: PREP_PATTERNS) {</span>
<span class="fc" id="L370">      sgCopy = sg.makeSoftCopy();</span>
<span class="fc" id="L371">      matcher = p.matcher(sgCopy);</span>
<span class="fc bfc" id="L372" title="All 2 branches covered.">      while (matcher.find()) {</span>
<span class="pc bpc" id="L373" title="1 of 4 branches missed.">        if (enhanceOnlyNmods &amp;&amp; ! matcher.getRelnString(&quot;reln&quot;).equals(&quot;nmod&quot;)) {</span>
<span class="fc" id="L374">          continue;</span>
        }

<span class="fc" id="L377">        List&lt;IndexedWord&gt; caseMarkers = Generics.newArrayList(1);</span>
<span class="fc" id="L378">        caseMarkers.add(matcher.getNode(&quot;c1&quot;));</span>

<span class="pc bpc" id="L380" title="1 of 2 branches missed.">        if (caseMarkers.equals(oldCaseMarkers))</span>
<span class="nc" id="L381">          continue;</span>

<span class="fc" id="L383">        IndexedWord gov = matcher.getNode(&quot;gov&quot;);</span>
<span class="fc" id="L384">        IndexedWord mod = matcher.getNode(&quot;mod&quot;);</span>
<span class="fc" id="L385">        addCaseMarkersToReln(sg, gov, mod, caseMarkers);</span>

<span class="fc" id="L387">        oldCaseMarkers = caseMarkers;</span>
<span class="fc" id="L388">      }</span>
    }

<span class="fc" id="L391">  }</span>


  private static void addPassiveAgentToReln(SemanticGraph sg,
      IndexedWord gov, IndexedWord mod, IndexedWord caseMarker) {

<span class="fc" id="L397">    SemanticGraphEdge edge = sg.getEdge(gov, mod);</span>
<span class="fc" id="L398">    GrammaticalRelation reln = UniversalEnglishGrammaticalRelations.getNmod(&quot;agent&quot;);</span>
<span class="fc" id="L399">    edge.setRelation(reln);</span>
<span class="fc" id="L400">  }</span>


  /**
   * Appends case marker information to nmod/acl/advcl relations.
   * &lt;p/&gt;
   * E.g. if there is a relation {@code nmod(gov, dep)} and {@code case(dep, prep)}, then
   * the {@code nmod} relation is renamed to {@code nmod:prep}.
   *
   *
   * @param sg semantic graph
   * @param gov governor of the nmod/acl/advcl relation
   * @param mod modifier of the nmod/acl/advcl relation
   * @param caseMarkers {@code List&lt;IndexedWord&gt;} of all the case markers that depend on mod
   */
  private static void addCaseMarkersToReln(SemanticGraph sg, IndexedWord gov, IndexedWord mod, List&lt;IndexedWord&gt; caseMarkers) {

<span class="fc" id="L417">    SemanticGraphEdge edge = sg.getEdge(gov, mod);</span>
<span class="fc" id="L418">    int lastCaseMarkerIndex = 0;</span>
<span class="fc" id="L419">    StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L420">    boolean firstWord = true;</span>
<span class="fc bfc" id="L421" title="All 2 branches covered.">    for (IndexedWord cm : caseMarkers) {</span>
      /* check for adjacency */
<span class="pc bpc" id="L423" title="1 of 4 branches missed.">      if (lastCaseMarkerIndex == 0 || cm.index() == (lastCaseMarkerIndex + 1)) {</span>
<span class="fc bfc" id="L424" title="All 2 branches covered.">        if ( ! firstWord) {</span>
<span class="fc" id="L425">          sb.append('_');</span>
        }
<span class="fc" id="L427">        sb.append(cm.value());</span>
<span class="fc" id="L428">        firstWord = false;</span>
      } else {
        /* Should never happen as there should be never two non-adjacent case markers.
         * If it does happen nevertheless create an additional relation.
         */
<span class="nc" id="L433">        GrammaticalRelation reln = getCaseMarkedRelation(edge.getRelation(), sb.toString().toLowerCase());</span>
<span class="nc" id="L434">        sg.addEdge(gov, mod, reln, Double.NEGATIVE_INFINITY, true);</span>
<span class="nc" id="L435">        sb = new StringBuilder(cm.value());</span>
<span class="nc" id="L436">        firstWord = true;</span>
      }
<span class="fc" id="L438">      lastCaseMarkerIndex = cm.index();</span>
<span class="fc" id="L439">    }</span>
<span class="fc" id="L440">    GrammaticalRelation reln = getCaseMarkedRelation(edge.getRelation(), sb.toString().toLowerCase());</span>
<span class="fc" id="L441">    edge.setRelation(reln);</span>
<span class="fc" id="L442">  }</span>

<span class="fc" id="L444">  private static final SemgrexPattern PREP_CONJP_PATTERN = SemgrexPattern.compile(&quot;{} &gt;case ({}=gov &gt;cc {}=cc &gt;conj {}=conj)&quot;);</span>

  /**
   * Expands prepositions with conjunctions such as in the sentence
   * &quot;Bill flies to and from Serbia.&quot; by copying the verb resulting
   * in the following relations:
   * &lt;p/&gt;
   * {@code conj:and(flies, flies')}&lt;br/&gt;
   * {@code case(Serbia, to)}&lt;br/&gt;
   * {@code cc(to, and)}&lt;br/&gt;
   * {@code conj(to, from)}&lt;br/&gt;
   * {@code nmod(flies, Serbia)}&lt;br/&gt;
   * {@code nmod(flies', Serbia)}&lt;br/&gt;
   * &lt;p/&gt;
   * The label of the conjunct relation includes the conjunction type
   * because if the verb has multiple cc relations then it can be impossible
   * to infer which coordination marker belongs to which conjuncts.
   *
   * @param sg A SemanticGraph for a sentence
   */
  private static void expandPrepConjunctions(SemanticGraph sg) {

    /* Semgrexes require a graph with a root. */
<span class="pc bpc" id="L467" title="1 of 2 branches missed.">    if (sg.getRoots().isEmpty())</span>
<span class="nc" id="L468">      return;</span>


<span class="fc" id="L471">    SemanticGraph sgCopy = sg.makeSoftCopy();</span>
<span class="fc" id="L472">    SemgrexMatcher matcher = PREP_CONJP_PATTERN.matcher(sgCopy);</span>

<span class="fc" id="L474">    IndexedWord oldGov = null;</span>
<span class="fc" id="L475">    IndexedWord oldCcDep = null;</span>
<span class="fc" id="L476">    List&lt;IndexedWord&gt; conjDeps = Generics.newLinkedList();</span>

<span class="fc bfc" id="L478" title="All 2 branches covered.">    while (matcher.find()) {</span>
<span class="fc" id="L479">      IndexedWord ccDep = matcher.getNode(&quot;cc&quot;);</span>
<span class="fc" id="L480">      IndexedWord conjDep = matcher.getNode(&quot;conj&quot;);</span>
<span class="fc" id="L481">      IndexedWord gov = matcher.getNode(&quot;gov&quot;);</span>
<span class="pc bpc" id="L482" title="5 of 6 branches missed.">      if (oldGov != null &amp;&amp;  (! gov.equals(oldGov) || ! ccDep.equals(oldCcDep))) {</span>
<span class="nc" id="L483">        expandPrepConjunction(sg, oldGov, conjDeps, oldCcDep);</span>
<span class="nc" id="L484">        conjDeps = Generics.newLinkedList();</span>
      }
<span class="fc" id="L486">      oldCcDep = ccDep;</span>
<span class="fc" id="L487">      oldGov = gov;</span>
<span class="fc" id="L488">      conjDeps.add(conjDep);</span>
<span class="fc" id="L489">    }</span>

<span class="fc bfc" id="L491" title="All 2 branches covered.">    if (oldGov != null) {</span>
<span class="fc" id="L492">      expandPrepConjunction(sg, oldGov, conjDeps, oldCcDep);</span>
    }

<span class="fc" id="L495">  }</span>

  /*
   * Used by expandPrepConjunctions.
   */
  private static void expandPrepConjunction(SemanticGraph sg, IndexedWord gov,
      List&lt;IndexedWord&gt; conjDeps, IndexedWord ccDep)  {

<span class="fc" id="L503">    IndexedWord caseGov = sg.getParent(gov);</span>

<span class="pc bpc" id="L505" title="1 of 2 branches missed.">    if (caseGov == null)</span>
<span class="nc" id="L506">      return;</span>

<span class="fc" id="L508">    IndexedWord caseGovGov = sg.getParent(caseGov);</span>

<span class="pc bpc" id="L510" title="1 of 2 branches missed.">    if (caseGovGov == null)</span>
<span class="nc" id="L511">      return;</span>

<span class="pc bpc" id="L513" title="1 of 2 branches missed.">    IndexedWord conjGov = caseGovGov.getOriginal() != null ? caseGovGov.getOriginal() : caseGovGov;</span>
<span class="fc" id="L514">    GrammaticalRelation rel = sg.reln(caseGovGov, caseGov);</span>
<span class="fc" id="L515">    List&lt;IndexedWord&gt; newConjDeps = Generics.newLinkedList();</span>
<span class="fc bfc" id="L516" title="All 2 branches covered.">    for (IndexedWord conjDep : conjDeps) {</span>
      //IndexedWord caseGovCopy = caseGov.makeSoftCopy();
<span class="fc" id="L518">      IndexedWord caseGovGovCopy = caseGovGov.makeSoftCopy();</span>

      /* Change conj(prep-1, prep-2) to case(prep-1-gov-copy, prep-2) */
      //SemanticGraphEdge edge = sg.getEdge(gov, conjDep);
      //sg.removeEdge(edge);
      //sg.addEdge(caseGovCopy, conjDep, CASE_MARKER, Double.NEGATIVE_INFINITY, false);

      /* Add relation to copy node. */
      //sg.addEdge(caseGovGovCopy, caseGovCopy, rel, Double.NEGATIVE_INFINITY, false);

<span class="fc" id="L528">      sg.addEdge(conjGov, caseGovGovCopy, CONJUNCT, Double.NEGATIVE_INFINITY, false);</span>
<span class="fc" id="L529">      newConjDeps.add(caseGovGovCopy);</span>

<span class="fc" id="L531">      sg.addEdge(caseGovGovCopy, caseGov, rel, Double.NEGATIVE_INFINITY, true);</span>

<span class="fc" id="L533">      List&lt;IndexedWord&gt; caseMarkers = Generics.newArrayList();</span>
<span class="fc" id="L534">      caseMarkers.add(conjDep);</span>

<span class="fc" id="L536">      addCaseMarkersToReln(sg, caseGovGovCopy, caseGov, caseMarkers);</span>
      /* Attach all children except case markers of caseGov to caseGovCopy. */
      //for (SemanticGraphEdge e : sg.outgoingEdgeList(caseGov)) {
      //  if (e.getRelation() != CASE_MARKER &amp;&amp; ! e.getDependent().equals(ccDep)) {
      //    sg.addEdge(caseGovCopy, e.getDependent(), e.getRelation(), Double.NEGATIVE_INFINITY, false);
      //  }
     // }
<span class="fc" id="L543">    }</span>

    /* Attach CC node to caseGov */
    //SemanticGraphEdge edge = sg.getEdge(gov, ccDep);
    //sg.removeEdge(edge);
    //sg.addEdge(conjGov, ccDep, COORDINATION, Double.NEGATIVE_INFINITY, false);

    /* Add conjunction information for these relations already at this point.
     * It could be that we add several coordinating conjunctions while collapsing
     * and we might not know which conjunction belongs to which conjunct at a later
     * point.
     */
<span class="fc" id="L555">    addConjToReln(sg, conjGov, newConjDeps, ccDep);</span>
<span class="fc" id="L556">  }</span>


<span class="fc" id="L559">  private static SemgrexPattern PP_CONJP_PATTERN = SemgrexPattern.compile(&quot;{} &gt;/^(nmod|acl|advcl)$/ (({}=gov &gt;case {}) &gt;cc {}=cc &gt;conj ({}=conj &gt;case {}))&quot;);</span>


  /**
   * Expands PPs with conjunctions such as in the sentence
   * &quot;Bill flies to France and from Serbia.&quot; by copying the verb
   * that governs the prepositinal phrase resulting in the following
   * relations:
   * &lt;p/&gt;
   * {@code conj:and(flies, flies')}&lt;br/&gt;
   * {@code case(France, to)}&lt;br/&gt;
   * {@code cc(flies, and)}&lt;br/&gt;
   * {@code case(Serbia, from)}&lt;br/&gt;
   * {@code nmod(flies, France)}&lt;br/&gt;
   * {@code nmod(flies', Serbia)}&lt;br/&gt;
   * &lt;p/&gt;
   * The label of the conjunct relation includes the conjunction type
   * because if the verb has multiple cc relations then it can be impossible
   * to infer which coordination marker belongs to which conjuncts.
   *
   * @param sg SemanticGraph to operate on.
   */
  private static void expandPPConjunctions(SemanticGraph sg) {

    /* Semgrexes require a graph with a root. */
<span class="pc bpc" id="L584" title="1 of 2 branches missed.">    if (sg.getRoots().isEmpty())</span>
<span class="nc" id="L585">      return;</span>


<span class="fc" id="L588">    SemanticGraph sgCopy = sg.makeSoftCopy();</span>
<span class="fc" id="L589">    SemgrexMatcher matcher = PP_CONJP_PATTERN.matcher(sgCopy);</span>

<span class="fc" id="L591">    IndexedWord oldGov = null;</span>
<span class="fc" id="L592">    IndexedWord oldCcDep = null;</span>
<span class="fc" id="L593">    List&lt;IndexedWord&gt; conjDeps = Generics.newLinkedList();</span>

<span class="fc bfc" id="L595" title="All 2 branches covered.">    while (matcher.find()) {</span>
<span class="fc" id="L596">      IndexedWord conjDep = matcher.getNode(&quot;conj&quot;);</span>
<span class="fc" id="L597">      IndexedWord gov = matcher.getNode(&quot;gov&quot;);</span>
<span class="fc" id="L598">      IndexedWord ccDep = matcher.getNode(&quot;cc&quot;);</span>

<span class="pc bpc" id="L600" title="2 of 6 branches missed.">      if (oldGov != null &amp;&amp;  (! gov.equals(oldGov) || ! ccDep.equals(oldCcDep))) {</span>
<span class="nc" id="L601">        expandPPConjunction(sg, oldGov, conjDeps, oldCcDep);</span>
<span class="nc" id="L602">        conjDeps = Generics.newLinkedList();</span>
      }
<span class="fc" id="L604">      oldCcDep = ccDep;</span>
<span class="fc" id="L605">      oldGov = gov;</span>
<span class="fc" id="L606">      conjDeps.add(conjDep);</span>
<span class="fc" id="L607">    }</span>

<span class="fc bfc" id="L609" title="All 2 branches covered.">    if (oldGov != null) {</span>
<span class="fc" id="L610">      expandPPConjunction(sg, oldGov, conjDeps, oldCcDep);</span>
    }

<span class="fc" id="L613">  }</span>

  /*
   * Used by expandPPConjunction.
   */
  private static void expandPPConjunction(SemanticGraph sg, IndexedWord gov,
      List&lt;IndexedWord&gt; conjDeps, IndexedWord ccDep) {

<span class="fc" id="L621">    IndexedWord nmodGov = sg.getParent(gov);</span>

<span class="pc bpc" id="L623" title="1 of 2 branches missed.">    if (nmodGov == null)</span>
<span class="nc" id="L624">      return;</span>

<span class="pc bpc" id="L626" title="1 of 2 branches missed.">    IndexedWord conjGov = nmodGov.getOriginal() != null ? nmodGov.getOriginal() : nmodGov;</span>
<span class="fc" id="L627">    GrammaticalRelation rel = sg.reln(nmodGov, gov);</span>
<span class="fc" id="L628">    List&lt;IndexedWord&gt; newConjDeps = Generics.newLinkedList();</span>
<span class="fc bfc" id="L629" title="All 2 branches covered.">    for (IndexedWord conjDep : conjDeps) {</span>
<span class="fc" id="L630">      IndexedWord nmodGovCopy = nmodGov.makeSoftCopy();</span>

      /* Change conj(nmod-1, nmod-2) to nmod(nmod-1-gov, nmod-2) */
<span class="fc" id="L633">      SemanticGraphEdge edge = sg.getEdge(gov, conjDep);</span>
<span class="pc bpc" id="L634" title="1 of 2 branches missed.">      if (edge != null) {</span>
<span class="fc" id="L635">        sg.removeEdge(edge);</span>
<span class="fc" id="L636">        sg.addEdge(nmodGovCopy, conjDep, rel, Double.NEGATIVE_INFINITY, false);</span>
      }

      /* Add relation to copy node. */
<span class="fc" id="L640">      sg.addEdge(conjGov, nmodGovCopy, CONJUNCT, Double.NEGATIVE_INFINITY, false);</span>
<span class="fc" id="L641">      newConjDeps.add(nmodGovCopy);</span>
<span class="fc" id="L642">    }</span>

    /* Attach CC node to conjGov */
<span class="fc" id="L645">    SemanticGraphEdge edge = sg.getEdge(gov, ccDep);</span>
<span class="pc bpc" id="L646" title="1 of 2 branches missed.">    if (edge != null) {</span>
<span class="fc" id="L647">      sg.removeEdge(edge);</span>
<span class="fc" id="L648">      sg.addEdge(conjGov, ccDep, COORDINATION, Double.NEGATIVE_INFINITY, false);</span>
    }

    /* Add conjunction information for these relations already at this point.
     * It could be that we add several coordinating conjunctions while collapsing
     * and we might not know which conjunction belongs to which conjunct at a later
     * point.
     */
<span class="fc" id="L656">    addConjToReln(sg, conjGov, newConjDeps, ccDep);</span>
<span class="fc" id="L657">  }</span>


  /**
   *
   * Returns a GrammaticalRelation which combines the original relation and
   * the preposition.
   *
   */
  private static GrammaticalRelation getCaseMarkedRelation(GrammaticalRelation reln, String relationName) {
<span class="fc" id="L667">    GrammaticalRelation newReln = reln;</span>

<span class="pc bpc" id="L669" title="1 of 2 branches missed.">    if (reln.getSpecific() != null) {</span>
<span class="nc" id="L670">      reln = reln.getParent();</span>
    }
<span class="pc bpc" id="L672" title="1 of 2 branches missed.">    if (reln == NOMINAL_MODIFIER) {</span>
<span class="fc" id="L673">      newReln = UniversalEnglishGrammaticalRelations.getNmod(relationName);</span>
<span class="nc bnc" id="L674" title="All 2 branches missed.">    } else if (reln == ADV_CLAUSE_MODIFIER) {</span>
<span class="nc" id="L675">      newReln = UniversalEnglishGrammaticalRelations.getAdvcl(relationName);</span>
<span class="nc bnc" id="L676" title="All 2 branches missed.">    } else if (reln == CLAUSAL_MODIFIER) {</span>
<span class="nc" id="L677">      newReln = UniversalEnglishGrammaticalRelations.getAcl(relationName);</span>
    }
<span class="fc" id="L679">    return newReln;</span>
  }


<span class="fc" id="L683">  private static final SemgrexPattern CONJUNCTION_PATTERN = SemgrexPattern.compile(&quot;{}=gov &gt;cc {}=cc &gt;conj {}=conj&quot;);</span>


  /**
   * Adds the type of conjunction to all conjunct relations.
   * &lt;p/&gt;
   * {@code cc(Marie, and)}, {@code conj(Marie, Chris)} and {@code conj(Marie, John)}
   * become {@code cc(Marie, and)}, {@code conj:and(Marie, Chris)} and {@code conj:and(Marie, John)}.
   * &lt;p/&gt;
   * In case multiple coordination marker depend on the same governor
   * the one that precedes the conjunct is appended to the conjunction relation or the
   * first one if no preceding marker exists.
   * &lt;p/&gt;
   * Some multi-word coordination markers are collapsed to {@code conj:and} or {@code conj:negcc}.
   * See {@link #conjValue(IndexedWord, SemanticGraph)}.
   *
   * @param sg A SemanticGraph from a sentence
   */
  private static void addConjInformation(SemanticGraph sg) {

    /* Semgrexes require a graph with a root. */
<span class="pc bpc" id="L704" title="1 of 2 branches missed.">    if (sg.getRoots().isEmpty())</span>
<span class="nc" id="L705">      return;</span>

<span class="fc" id="L707">    SemanticGraph sgCopy = sg.makeSoftCopy();</span>
<span class="fc" id="L708">    SemgrexMatcher matcher = CONJUNCTION_PATTERN.matcher(sgCopy);</span>

<span class="fc" id="L710">    IndexedWord oldGov = null;</span>
<span class="fc" id="L711">    IndexedWord oldCcDep = null;</span>
<span class="fc" id="L712">    List&lt;IndexedWord&gt; conjDeps = Generics.newLinkedList();</span>

<span class="fc bfc" id="L714" title="All 2 branches covered.">    while (matcher.find()) {</span>
<span class="fc" id="L715">      IndexedWord conjDep = matcher.getNode(&quot;conj&quot;);</span>
<span class="fc" id="L716">      IndexedWord gov = matcher.getNode(&quot;gov&quot;);</span>
<span class="fc" id="L717">      IndexedWord ccDep = matcher.getNode(&quot;cc&quot;);</span>
<span class="fc bfc" id="L718" title="All 6 branches covered.">      if (oldGov != null &amp;&amp;  (! gov.equals(oldGov) || ! ccDep.equals(oldCcDep))) {</span>
<span class="fc" id="L719">        addConjToReln(sg, oldGov, conjDeps, oldCcDep);</span>
<span class="fc" id="L720">        conjDeps = Generics.newLinkedList();</span>
      }
<span class="fc" id="L722">      oldCcDep = ccDep;</span>
<span class="fc" id="L723">      conjDeps.add(conjDep);</span>
<span class="fc" id="L724">      oldGov = gov;</span>
<span class="fc" id="L725">    }</span>

<span class="fc bfc" id="L727" title="All 2 branches covered.">    if (oldGov != null) {</span>
<span class="fc" id="L728">      addConjToReln(sg, oldGov, conjDeps, oldCcDep);</span>
    }

<span class="fc" id="L731">  }</span>

  /*
   * Used by addConjInformation.
   */
  private static void addConjToReln(SemanticGraph sg,
      IndexedWord gov, List&lt;IndexedWord&gt; conjDeps, IndexedWord ccDep) {

<span class="fc bfc" id="L739" title="All 2 branches covered.">    for (IndexedWord conjDep : conjDeps) {</span>
<span class="fc" id="L740">      SemanticGraphEdge edge = sg.getEdge(gov, conjDep);</span>
<span class="fc bfc" id="L741" title="All 4 branches covered.">      if (edge.getRelation() == CONJUNCT || conjDep.index() &gt; ccDep.index()) {</span>
<span class="fc" id="L742">        edge.setRelation(conjValue(ccDep, sg));</span>
      }
<span class="fc" id="L744">    }</span>
<span class="fc" id="L745">  }</span>

  /* Used by correctWHAttachment */
<span class="fc" id="L748">  private static final SemgrexPattern XCOMP_PATTERN = SemgrexPattern.compile(&quot;{}=root &gt;xcomp {}=embedded &gt;/^(dep|dobj)$/ {}=wh ?&gt;/([di]obj)/ {}=obj&quot;);</span>

  /**
   * Tries to correct complicated cases of WH-movement in
   * sentences such as &quot;What does Mary seem to have?&quot; in
   * which &quot;What&quot; should attach to &quot;have&quot; instead of the
   * control verb.
   *
   * @param sg The Semantic graph to operate on.
   */
  private static void correctWHAttachment(SemanticGraph sg) {

    /* Semgrexes require a graph with a root. */
<span class="pc bpc" id="L761" title="1 of 2 branches missed.">    if (sg.getRoots().isEmpty())</span>
<span class="nc" id="L762">      return;</span>

<span class="fc" id="L764">    SemanticGraph sgCopy = sg.makeSoftCopy();</span>
<span class="fc" id="L765">    SemgrexMatcher matcher = XCOMP_PATTERN.matcher(sgCopy);</span>
<span class="pc bpc" id="L766" title="1 of 2 branches missed.">    while (matcher.findNextMatchingNode()) {</span>
<span class="nc" id="L767">      IndexedWord root = matcher.getNode(&quot;root&quot;);</span>
<span class="nc" id="L768">      IndexedWord embeddedVerb = matcher.getNode(&quot;embedded&quot;);</span>
<span class="nc" id="L769">      IndexedWord wh = matcher.getNode(&quot;wh&quot;);</span>
<span class="nc" id="L770">      IndexedWord dobj = matcher.getNode(&quot;obj&quot;);</span>

      /* Check if the object is a WH-word. */
<span class="nc bnc" id="L773" title="All 2 branches missed.">      if (wh.tag().startsWith(&quot;W&quot;)) {</span>
<span class="nc" id="L774">        boolean reattach = false;</span>
        /* If the control verb already has an object, then
           we have to reattach the WH-word to the verb in the embedded clause. */
<span class="nc bnc" id="L777" title="All 2 branches missed.">        if (dobj != null) {</span>
<span class="nc" id="L778">          reattach = true;</span>
        } else {
          /* If the control verb can't have an object, we also have to reattach. */
<span class="nc" id="L781">          String lemma = Morphology.lemmaStatic(root.value(), root.tag());</span>
<span class="nc bnc" id="L782" title="All 2 branches missed.">          if (lemma.matches(EnglishPatterns.NP_V_S_INF_VERBS_REGEX)) {</span>
<span class="nc" id="L783">            reattach = true;</span>
          }
        }

<span class="nc bnc" id="L787" title="All 2 branches missed.">        if (reattach) {</span>
<span class="nc" id="L788">          SemanticGraphEdge edge = sg.getEdge(root, wh);</span>
<span class="nc bnc" id="L789" title="All 2 branches missed.">          if (edge != null) {</span>
<span class="nc" id="L790">            sg.removeEdge(edge);</span>
<span class="nc" id="L791">            sg.addEdge(embeddedVerb, wh, DIRECT_OBJECT, Double.NEGATIVE_INFINITY, false);</span>
          }
        }
      }
<span class="nc" id="L795">    }</span>
<span class="fc" id="L796">  }</span>


  /**
   * What we do in this method is look for temporary dependencies of
   * the type &quot;rel&quot; and &quot;prep&quot;.  These occur in sentences such as &quot;I saw the man
   * who you love&quot;.  In that case, we should produce dobj(love, who).
   * On the other hand, in the sentence &quot;... which Mr. Bush was
   * fighting for&quot;, we should have case(which, for).
   */
   private static void convertRel(SemanticGraph sg) {

<span class="fc bfc" id="L808" title="All 2 branches covered.">    for (SemanticGraphEdge prep : sg.findAllRelns(PREPOSITION)) {</span>

<span class="fc" id="L810">      boolean changedPrep = false;</span>

<span class="pc bpc" id="L812" title="1 of 2 branches missed.">      for (SemanticGraphEdge nmod : sg.outgoingEdgeIterable(prep.getGovernor())) {</span>

        // todo: It would also be good to add a rule here to prefer ccomp nsubj over dobj if there is a ccomp with no subj
        // then we could get right: Which eco-friendly options do you think there will be on the new Lexus?
<span class="pc bpc" id="L816" title="1 of 4 branches missed.">        if (nmod.getRelation() != NOMINAL_MODIFIER &amp;&amp; nmod.getRelation() != RELATIVE) {</span>
<span class="nc" id="L817">          continue;</span>
        }

<span class="pc bpc" id="L820" title="1 of 2 branches missed.">        if (prep.getDependent().index() &lt; nmod.getDependent().index()) {</span>
<span class="nc" id="L821">          continue;</span>
        }

<span class="fc" id="L824">        sg.removeEdge(prep);</span>
<span class="fc" id="L825">        sg.addEdge(nmod.getDependent(), prep.getDependent(), CASE_MARKER, Double.NEGATIVE_INFINITY, false);</span>

<span class="fc" id="L827">        changedPrep = true;</span>

<span class="fc bfc" id="L829" title="All 2 branches covered.">        if (nmod.getRelation() == RELATIVE) {</span>
<span class="fc" id="L830">          nmod.setRelation(NOMINAL_MODIFIER);</span>
        }

        break;
      }

<span class="pc bpc" id="L836" title="1 of 2 branches missed.">      if ( ! changedPrep) {</span>
<span class="nc" id="L837">        prep.setRelation(NOMINAL_MODIFIER);</span>
      }
<span class="fc" id="L839">    }</span>

    /* Rename remaining &quot;rel&quot; relations. */
<span class="pc bpc" id="L842" title="1 of 2 branches missed.">    for (SemanticGraphEdge edge : sg.findAllRelns(RELATIVE)) {</span>
<span class="nc" id="L843">      edge.setRelation(DIRECT_OBJECT);</span>
<span class="nc" id="L844">    }</span>
<span class="fc" id="L845">  }</span>

  @Override
  protected void addEnhancements(List&lt;TypedDependency&gt; list, EnhancementOptions options) {

<span class="fc" id="L850">    SemanticGraph sg = new SemanticGraph(list);</span>

<span class="pc bpc" id="L852" title="1 of 2 branches missed.">    if (DEBUG) {</span>
<span class="nc" id="L853">      printListSorted(&quot;addEnhancements: before correctDependencies()&quot;, sg.typedDependencies());</span>
    }

<span class="fc" id="L856">    correctDependencies(sg);</span>

<span class="pc bpc" id="L858" title="1 of 2 branches missed.">    if (DEBUG) {</span>
<span class="nc" id="L859">      printListSorted(&quot;addEnhancements: after correctDependencies()&quot;, sg.typedDependencies());</span>
    }

    /* Turn multi-word prepositions into flat mwe. */
<span class="pc bpc" id="L863" title="1 of 2 branches missed.">    if (options.processMultiWordPrepositions) {</span>
<span class="fc" id="L864">      processMultiwordPreps(sg);</span>
<span class="pc bpc" id="L865" title="1 of 2 branches missed.">      if (DEBUG) {</span>
<span class="nc" id="L866">        printListSorted(&quot;addEnhancements: after processMultiwordPreps()&quot;, sg.typedDependencies());</span>
      }
    }
    /* Turn quantificational modifiers into flat mwe. */
<span class="pc bpc" id="L870" title="1 of 2 branches missed.">    if (options.demoteQuantMod) {</span>
<span class="nc" id="L871">      demoteQuantificationalModifiers(sg);</span>
<span class="nc bnc" id="L872" title="All 2 branches missed.">      if (DEBUG) {</span>
<span class="nc" id="L873">        printListSorted(&quot;addEnhancements: after demoteQuantificationalModifiers()&quot;, sg.typedDependencies());</span>
      }
    }
    /* Add copy nodes for conjoined Ps and PPs. */
<span class="pc bpc" id="L877" title="1 of 2 branches missed.">    if (options.addCopyNodes) {</span>
<span class="fc" id="L878">      expandPPConjunctions(sg);</span>
<span class="pc bpc" id="L879" title="1 of 2 branches missed.">      if (DEBUG) {</span>
<span class="nc" id="L880">        printListSorted(&quot;addEnhancements: after expandPPConjunctions()&quot;, sg.typedDependencies());</span>
      }
<span class="fc" id="L882">      expandPrepConjunctions(sg);</span>
<span class="pc bpc" id="L883" title="1 of 2 branches missed.">      if (DEBUG) {</span>
<span class="nc" id="L884">        printListSorted(&quot;addEnhancements: after expandPrepConjunctions()&quot;, sg.typedDependencies());</span>
      }
    }
    /* Add propositions to relation names. */
<span class="pc bpc" id="L888" title="1 of 2 branches missed.">    if (options.enhancePrepositionalModifiers) {</span>
<span class="fc" id="L889">      addCaseMarkerInformation(sg, options.enhanceOnlyNmods);</span>
<span class="pc bpc" id="L890" title="1 of 2 branches missed.">      if (DEBUG) {</span>
<span class="nc" id="L891">        printListSorted(&quot;addEnhancements: after addCaseMarkerInformation()&quot;, sg.typedDependencies());</span>
      }
    }
    /* Add coordinating conjunctions to relation names. */
<span class="pc bpc" id="L895" title="1 of 2 branches missed.">    if (options.enhanceConjuncts) {</span>
<span class="fc" id="L896">      addConjInformation(sg);</span>
<span class="pc bpc" id="L897" title="1 of 2 branches missed.">      if (DEBUG) {</span>
<span class="nc" id="L898">        printListSorted(&quot;addEnhancements: after addConjInformation()&quot;, sg.typedDependencies());</span>
      }
    }
    /* Add &quot;referent&quot; relations. */
<span class="fc bfc" id="L902" title="All 2 branches covered.">    if (options.addReferent) {</span>
<span class="fc" id="L903">      addRef(sg);</span>
<span class="pc bpc" id="L904" title="1 of 2 branches missed.">      if (DEBUG) {</span>
<span class="nc" id="L905">        printListSorted(&quot;addEnhancements: after addRef()&quot;, sg.typedDependencies());</span>
      }
<span class="fc" id="L907">      collapseReferent(sg);</span>
<span class="pc bpc" id="L908" title="1 of 2 branches missed.">      if (DEBUG) {</span>
<span class="nc" id="L909">        printListSorted(&quot;addEnhancements: after collapseReferent()&quot;, sg.typedDependencies());</span>
      }
    }
    /* Propagate dependents. */
<span class="fc bfc" id="L913" title="All 2 branches covered.">    if (options.propagateDependents) {</span>
<span class="fc" id="L914">      treatCC(sg);</span>
<span class="pc bpc" id="L915" title="1 of 2 branches missed.">      if (DEBUG) {</span>
<span class="nc" id="L916">        printListSorted(&quot;addEnhancements: after treatCC()&quot;, sg.typedDependencies());</span>
      }
    }
    /* Add relations between controlling subjects and controlled verbs. */
<span class="fc bfc" id="L920" title="All 2 branches covered.">    if (options.addXSubj) {</span>
<span class="fc" id="L921">      addExtraNSubj(sg);</span>
<span class="pc bpc" id="L922" title="1 of 2 branches missed.">      if (DEBUG) {</span>
<span class="nc" id="L923">        printListSorted(&quot;addEnhancements: after addExtraNSubj()&quot;, sg.typedDependencies());</span>
      }
    }

<span class="fc" id="L927">    correctSubjPass(sg);</span>
<span class="fc" id="L928">    list.clear();</span>
<span class="fc" id="L929">    list.addAll(sg.typedDependencies());</span>

<span class="fc" id="L931">    Collections.sort(list);</span>
<span class="fc" id="L932">  }</span>


  /**
   * Destructively modifies this {@code Collection&lt;TypedDependency&gt;}
   * by collapsing several types of transitive pairs of dependencies or
   * by adding additional information from the dependents to the relation
   * of the governor.
   * If called with a tree of dependencies and both CCprocess and
   * includeExtras set to false, then the tree structure is preserved.
   * &lt;p/&gt;
   *
   * &lt;dl&gt;
   * &lt;dt&gt;nominal modifier dependencies: nmod&lt;/dt&gt;
   * &lt;dd&gt;
   * If there exist the relations {@code case(hat, in)} and {@code nmod(in, hat)} then
   * the {@code nmod} relation is enhanced to {@code nmod:in(cat, hat)}.
   * The {@code case(hat, in)} relation is preserved.&lt;/dd&gt;
   * &lt;dt&gt;clausal modifier of noun/adverbial clause modifier with case markers: acs/advcl&lt;/dt&gt;
   * &lt;dd&gt;
   * If there exist the relations {@code case(attacking, of)} and {@code advcl(heard, attacking)} then
   * the {@code nmod} relation is enhanced to {@code nmod:of(heard, attacking)}.
   * The {@code case(attacking, of)} relation is preserved.&lt;/dd&gt;
   * &lt;dt&gt;conjunct dependencies&lt;/dt&gt;
   * &lt;dd&gt;
   * If there exist the relations
   * {@code cc(investors, and)} and
   * {@code conj(investors, regulators)}, then the {@code conj} relation is
   * enhanced to
   * {@code conj:and(investors, regulators)}&lt;/dd&gt;
   * &lt;dt&gt;For relative clauses, it will collapse referent&lt;/dt&gt;
   * &lt;dd&gt;
   * {@code ref(man, that)} and {@code dobj(love, that)} are collapsed
   * to {@code dobj(love, man)}&lt;/dd&gt;
   * &lt;/dl&gt;
   */
  @Override
  protected void collapseDependencies(List&lt;TypedDependency&gt; list, boolean CCprocess, Extras includeExtras) {
<span class="fc" id="L970">    EnhancementOptions options = new EnhancementOptions(COLLAPSED_OPTIONS);</span>
<span class="fc bfc" id="L971" title="All 2 branches covered.">    if (includeExtras.doRef) {</span>
<span class="fc" id="L972">      options.addReferent = true;</span>
    }

<span class="fc bfc" id="L975" title="All 2 branches covered.">    if (includeExtras.doSubj) {</span>
<span class="fc" id="L976">      options.addXSubj = true;</span>
    }

<span class="fc bfc" id="L979" title="All 2 branches covered.">    if (CCprocess) {</span>
<span class="fc" id="L980">      options.propagateDependents = true;</span>
    }
<span class="fc" id="L982">    addEnhancements(list, options);</span>
<span class="fc" id="L983">  }</span>

  @Override
  protected void collapseDependenciesTree(List&lt;TypedDependency&gt; list) {
<span class="nc" id="L987">    collapseDependencies(list, false, Extras.NONE);</span>
<span class="nc" id="L988">  }</span>

  /**
   * Does some hard coding to deal with relation in CONJP. For now we deal with:
   * but not, if not, instead of, rather than, but rather GO TO negcc &lt;br/&gt;
   * as well as, not to mention, but also, &amp; GO TO and.
   *
   * @param cc The head dependency of the conjunction marker
   * @param sg The complete current semantic graph
   * @return A GrammaticalRelation made from a normalized form of that
   *         conjunction.
   */
  private static GrammaticalRelation conjValue(IndexedWord cc, SemanticGraph sg) {

<span class="fc" id="L1002">    int pos = cc.index();</span>
<span class="fc" id="L1003">    String newConj = cc.value().toLowerCase();</span>

<span class="fc bfc" id="L1005" title="All 2 branches covered.">    if (newConj.equals(&quot;not&quot;)) {</span>
<span class="fc" id="L1006">      IndexedWord prevWord = sg.getNodeByIndexSafe(pos - 1);</span>
<span class="pc bpc" id="L1007" title="1 of 4 branches missed.">      if (prevWord != null &amp;&amp; prevWord.value().toLowerCase().equals(&quot;but&quot;)) {</span>
<span class="fc" id="L1008">        return UniversalEnglishGrammaticalRelations.getConj(&quot;negcc&quot;);</span>
      }
    }

<span class="fc" id="L1012">    IndexedWord secondIWord = sg.getNodeByIndexSafe(pos + 1);</span>

<span class="pc bpc" id="L1014" title="1 of 2 branches missed.">    if (secondIWord == null) {</span>
<span class="nc" id="L1015">      return UniversalEnglishGrammaticalRelations.getConj(cc.value());</span>
    }
<span class="fc" id="L1017">    String secondWord = secondIWord.value().toLowerCase();</span>
<span class="fc bfc" id="L1018" title="All 2 branches covered.">    if (newConj.equals(&quot;but&quot;)) {</span>
<span class="pc bpc" id="L1019" title="1 of 2 branches missed.">      if (secondWord.equals(&quot;rather&quot;)) {</span>
<span class="nc" id="L1020">        newConj = &quot;negcc&quot;;</span>
<span class="pc bpc" id="L1021" title="1 of 2 branches missed.">      } else if (secondWord.equals(&quot;also&quot;)) {</span>
<span class="fc" id="L1022">        newConj = &quot;and&quot;;</span>
      }
<span class="pc bpc" id="L1024" title="3 of 4 branches missed.">    } else if (newConj.equals(&quot;if&quot;) &amp;&amp; secondWord.equals(&quot;not&quot;)) {</span>
<span class="nc" id="L1025">      newConj = &quot;negcc&quot;;</span>
<span class="pc bpc" id="L1026" title="3 of 4 branches missed.">    } else if (newConj.equals(&quot;instead&quot;) &amp;&amp; secondWord.equals(&quot;of&quot;)) {</span>
<span class="nc" id="L1027">      newConj = &quot;negcc&quot;;</span>
<span class="pc bpc" id="L1028" title="1 of 4 branches missed.">    } else if (newConj.equals(&quot;rather&quot;) &amp;&amp; secondWord.equals(&quot;than&quot;)) {</span>
<span class="fc" id="L1029">      newConj = &quot;negcc&quot;;</span>
<span class="pc bpc" id="L1030" title="1 of 4 branches missed.">    } else if (newConj.equals(&quot;as&quot;) &amp;&amp; secondWord.equals(&quot;well&quot;)) {</span>
<span class="fc" id="L1031">      newConj = &quot;and&quot;;</span>
<span class="pc bpc" id="L1032" title="1 of 4 branches missed.">    } else if (newConj.equals(&quot;not&quot;) &amp;&amp; secondWord.equals(&quot;to&quot;)) {</span>
<span class="fc" id="L1033">      IndexedWord thirdIWord = sg.getNodeByIndexSafe(pos + 2);</span>
<span class="pc bpc" id="L1034" title="1 of 2 branches missed.">      String thirdWord = thirdIWord != null ? thirdIWord.value().toLowerCase() : null;</span>
<span class="pc bpc" id="L1035" title="2 of 4 branches missed.">      if (thirdWord != null &amp;&amp; thirdWord.equals(&quot;mention&quot;)) {</span>
<span class="fc" id="L1036">        newConj = &quot;and&quot;;</span>
      }
    }
<span class="fc" id="L1039">    return UniversalEnglishGrammaticalRelations.getConj(newConj);</span>
  }


  private static void treatCC(SemanticGraph sg) {

    // Construct a map from tree nodes to the set of typed
    // dependencies in which the node appears as dependent.
<span class="fc" id="L1047">    Map&lt;IndexedWord, Set&lt;SemanticGraphEdge&gt;&gt; map = Generics.newHashMap();</span>
    // Construct a map of tree nodes being governor of a subject grammatical
    // relation to that relation
<span class="fc" id="L1050">    Map&lt;IndexedWord, SemanticGraphEdge&gt; subjectMap = Generics.newHashMap();</span>
    // Construct a set of TreeGraphNodes with a passive auxiliary on them
<span class="fc" id="L1052">    Set&lt;IndexedWord&gt; withPassiveAuxiliary = Generics.newHashSet();</span>
    // Construct a map of tree nodes being governor of an object grammatical
    // relation to that relation
    // Map&lt;TreeGraphNode, TypedDependency&gt; objectMap = new
    // HashMap&lt;TreeGraphNode, TypedDependency&gt;();

<span class="fc" id="L1058">    List&lt;IndexedWord&gt; rcmodHeads = Generics.newArrayList();</span>
<span class="fc" id="L1059">    List&lt;IndexedWord&gt; prepcDep = Generics.newArrayList();</span>


<span class="fc bfc" id="L1062" title="All 2 branches covered.">    for (SemanticGraphEdge edge : sg.edgeIterable()) {</span>
<span class="fc bfc" id="L1063" title="All 2 branches covered.">      if (!map.containsKey(edge.getDependent())) {</span>
        // NB: Here and in other places below, we use a TreeSet (which extends
        // SortedSet) to guarantee that results are deterministic)
<span class="fc" id="L1066">        map.put(edge.getDependent(), new TreeSet&lt;&gt;());</span>
      }
<span class="fc" id="L1068">      map.get(edge.getDependent()).add(edge);</span>

<span class="fc bfc" id="L1070" title="All 2 branches covered.">      if (edge.getRelation().equals(AUX_PASSIVE_MODIFIER)) {</span>
<span class="fc" id="L1071">        withPassiveAuxiliary.add(edge.getGovernor());</span>
      }

      // look for subjects
<span class="fc bfc" id="L1075" title="All 2 branches covered.">      if (edge.getRelation().getParent() == NOMINAL_SUBJECT</span>
<span class="fc bfc" id="L1076" title="All 2 branches covered.">          || edge.getRelation().getParent() == SUBJECT</span>
<span class="pc bpc" id="L1077" title="1 of 2 branches missed.">          || edge.getRelation().getParent() == CLAUSAL_SUBJECT) {</span>
<span class="pc bpc" id="L1078" title="1 of 2 branches missed.">        if (!subjectMap.containsKey(edge.getGovernor())) {</span>
<span class="fc" id="L1079">          subjectMap.put(edge.getGovernor(), edge);</span>
        }
      }

      // look for objects
      // this map was only required by the code commented out below, so comment
      // it out too
      // if (typedDep.reln() == DIRECT_OBJECT) {
      // if (!objectMap.containsKey(typedDep.gov())) {
      // objectMap.put(typedDep.gov(), typedDep);
      // }
      // }

      // look for rcmod relations
<span class="pc bpc" id="L1093" title="1 of 2 branches missed.">      if (edge.getRelation() == RELATIVE_CLAUSE_MODIFIER) {</span>
<span class="nc" id="L1094">        rcmodHeads.add(edge.getGovernor());</span>
      }
      // look for prepc relations: put the dependent of such a relation in the
      // list
      // to avoid wrong propagation of dobj
<span class="pc bpc" id="L1099" title="2 of 4 branches missed.">      if (edge.getRelation().toString().startsWith(&quot;acl:&quot;) || edge.getRelation().toString().startsWith(&quot;advcl:&quot;)) {</span>
<span class="nc" id="L1100">        prepcDep.add(edge.getDependent());</span>
      }
<span class="fc" id="L1102">    }</span>

    // log.info(map);
    // if (DEBUG) log.info(&quot;Subject map: &quot; + subjectMap);
    // if (DEBUG) log.info(&quot;Object map: &quot; + objectMap);
    // log.info(rcmodHeads);

    // create a new list of typed dependencies
    //Collection&lt;TypedDependency&gt; newTypedDeps = new ArrayList&lt;TypedDependency&gt;(list);

<span class="fc" id="L1112">    SemanticGraph sgCopy = sg.makeSoftCopy();</span>

    // find typed deps of form conj(gov,dep)
<span class="fc bfc" id="L1115" title="All 2 branches covered.">    for (SemanticGraphEdge edge: sgCopy.edgeIterable()) {</span>
<span class="fc bfc" id="L1116" title="All 2 branches covered.">      if (UniversalEnglishGrammaticalRelations.getConjs().contains(edge.getRelation())) {</span>
<span class="fc" id="L1117">        IndexedWord gov = edge.getGovernor();</span>
<span class="fc" id="L1118">        IndexedWord dep = edge.getDependent();</span>

        // look at the dep in the conjunct
<span class="fc" id="L1121">        Set&lt;SemanticGraphEdge&gt; gov_relations = map.get(gov);</span>
        // log.info(&quot;gov &quot; + gov);
<span class="fc bfc" id="L1123" title="All 2 branches covered.">        if (gov_relations != null) {</span>
<span class="fc bfc" id="L1124" title="All 2 branches covered.">          for (SemanticGraphEdge edge1 : gov_relations) {</span>
            // log.info(&quot;gov rel &quot; + td1);
<span class="fc" id="L1126">            IndexedWord newGov = edge1.getGovernor();</span>
            // in the case of errors in the basic dependencies, it
            // is possible to have overlapping newGov &amp; dep
<span class="pc bpc" id="L1129" title="1 of 2 branches missed.">            if (newGov.equals(dep)) {</span>
<span class="nc" id="L1130">              continue;</span>
            }

<span class="fc" id="L1133">            GrammaticalRelation newRel = edge1.getRelation();</span>
            //TODO: Do we want to copy case markers here?
<span class="pc bpc" id="L1135" title="1 of 4 branches missed.">            if (newRel != ROOT &amp;&amp; newRel != CASE_MARKER) {</span>
<span class="pc bpc" id="L1136" title="3 of 4 branches missed.">              if (rcmodHeads.contains(gov) &amp;&amp; rcmodHeads.contains(dep)) {</span>
                // to prevent wrong propagation in the case of long dependencies in relative clauses
<span class="nc bnc" id="L1138" title="All 4 branches missed.">                if (newRel != DIRECT_OBJECT &amp;&amp; newRel != NOMINAL_SUBJECT) {</span>
<span class="nc bnc" id="L1139" title="All 2 branches missed.">                  if (DEBUG) {</span>
<span class="nc" id="L1140">                    log.info(&quot;Adding new &quot; + newRel + &quot; dependency from &quot; + newGov + &quot; to &quot; + dep + &quot; (subj/obj case)&quot;);</span>
                  }
<span class="nc" id="L1142">                  sg.addEdge(newGov, dep, newRel, Double.NEGATIVE_INFINITY, true);</span>
                }
              } else {
<span class="pc bpc" id="L1145" title="1 of 2 branches missed.">                if (DEBUG) {</span>
<span class="nc" id="L1146">                  log.info(&quot;Adding new &quot; + newRel + &quot; dependency from &quot; + newGov + &quot; to &quot; + dep);</span>
                }
<span class="fc" id="L1148">                sg.addEdge(newGov, dep, newRel, Double.NEGATIVE_INFINITY, true);</span>
              }
            }
<span class="fc" id="L1151">          }</span>
        }

        // propagate subjects
        // look at the gov in the conjunct: if it is has a subject relation,
        // the dep is a verb and the dep doesn't have a subject relation
        // then we want to add a subject relation for the dep.
        // (By testing for the dep to be a verb, we are going to miss subject of
        // copular verbs! but
        // is it safe to relax this assumption?? i.e., just test for the subject
        // part)
        // CDM 2008: I also added in JJ, since participial verbs are often
        // tagged JJ
<span class="fc" id="L1164">        String tag = dep.tag();</span>
<span class="pc bpc" id="L1165" title="1 of 8 branches missed.">        if (subjectMap.containsKey(gov) &amp;&amp; (tag.startsWith(&quot;VB&quot;) || tag.startsWith(&quot;JJ&quot;)) &amp;&amp; ! subjectMap.containsKey(dep)) {</span>
<span class="fc" id="L1166">          SemanticGraphEdge tdsubj = subjectMap.get(gov);</span>
          // check for wrong nsubjpass: if the new verb is VB or VBZ or VBP or JJ, then
          // add nsubj (if it is tagged correctly, should do this for VBD too, but we don't)
<span class="fc" id="L1169">          GrammaticalRelation relation = tdsubj.getRelation();</span>
<span class="fc bfc" id="L1170" title="All 2 branches covered.">          if (relation == NOMINAL_PASSIVE_SUBJECT) {</span>
<span class="pc bpc" id="L1171" title="1 of 2 branches missed.">            if (isDefinitelyActive(tag)) {</span>
<span class="fc" id="L1172">              relation = NOMINAL_SUBJECT;</span>
            }
<span class="pc bpc" id="L1174" title="1 of 2 branches missed.">          } else if (relation == CLAUSAL_PASSIVE_SUBJECT) {</span>
<span class="nc bnc" id="L1175" title="All 2 branches missed.">            if (isDefinitelyActive(tag)) {</span>
<span class="nc" id="L1176">              relation = CLAUSAL_SUBJECT;</span>
            }
<span class="pc bpc" id="L1178" title="1 of 2 branches missed.">          } else if (relation == NOMINAL_SUBJECT) {</span>
<span class="fc bfc" id="L1179" title="All 2 branches covered.">            if (withPassiveAuxiliary.contains(dep)) {</span>
<span class="fc" id="L1180">              relation = NOMINAL_PASSIVE_SUBJECT;</span>
            }
<span class="nc bnc" id="L1182" title="All 2 branches missed.">          } else if (relation == CLAUSAL_SUBJECT) {</span>
<span class="nc bnc" id="L1183" title="All 2 branches missed.">            if (withPassiveAuxiliary.contains(dep)) {</span>
<span class="nc" id="L1184">              relation = CLAUSAL_PASSIVE_SUBJECT;</span>
            }
          }
<span class="pc bpc" id="L1187" title="1 of 2 branches missed.">          if (DEBUG) {</span>
<span class="nc" id="L1188">            log.info(&quot;Adding new &quot; + relation + &quot; dependency from &quot; + dep + &quot; to &quot; + tdsubj.getDependent() + &quot; (subj propagation case)&quot;);</span>
          }
<span class="fc" id="L1190">          sg.addEdge(dep, tdsubj.getDependent(), relation, Double.NEGATIVE_INFINITY, true);</span>
        }

        // propagate objects
        // cdm july 2010: This bit of code would copy a dobj from the first
        // clause to a later conjoined clause if it didn't
        // contain its own dobj or prepc. But this is too aggressive and wrong
        // if the later clause is intransitive
        // (including passivized cases) and so I think we have to not have this
        // done always, and see no good &quot;sometimes&quot; heuristic.
        // IF WE WERE TO REINSTATE, SHOULD ALSO NOT ADD OBJ IF THERE IS A ccomp
        // (SBAR).
        // if (objectMap.containsKey(gov) &amp;&amp;
        // dep.tag().startsWith(&quot;VB&quot;) &amp;&amp; ! objectMap.containsKey(dep)
        // &amp;&amp; ! prepcDep.contains(gov)) {
        // TypedDependency tdobj = objectMap.get(gov);
        // if (DEBUG) {
        // log.info(&quot;Adding new &quot; + tdobj.reln() + &quot; dependency from &quot;
        // + dep + &quot; to &quot; + tdobj.dep() + &quot; (obj propagation case)&quot;);
        // }
        // newTypedDeps.add(new TypedDependency(tdobj.reln(), dep,
        // tdobj.dep()));
        // }
      }
<span class="fc" id="L1214">    }</span>
<span class="fc" id="L1215">  }</span>

  private static boolean isDefinitelyActive(String tag) {
    // we should include VBD, but don't as it is often a tagging mistake.
<span class="pc bpc" id="L1219" title="7 of 8 branches missed.">    return tag.equals(&quot;VB&quot;) || tag.equals(&quot;VBZ&quot;) || tag.equals(&quot;VBP&quot;) || tag.startsWith(&quot;JJ&quot;);</span>
  }


  /**
   * This method will collapse a referent relation such as follows. e.g.:
   * &quot;The man that I love ... &quot; ref(man, that) dobj(love, that) -&gt; ref(man, that) dobj(love,
   * man)
   */
  private static void collapseReferent(SemanticGraph sg) {
    // find typed deps of form ref(gov, dep)
    // put them in a List for processing
<span class="fc" id="L1231">    List&lt;SemanticGraphEdge&gt; refs = new ArrayList&lt;&gt;(sg.findAllRelns(REFERENT));</span>

<span class="fc" id="L1233">    SemanticGraph sgCopy = sg.makeSoftCopy();</span>

    // now substitute target of referent where possible
<span class="fc bfc" id="L1236" title="All 2 branches covered.">    for (SemanticGraphEdge ref : refs) {</span>
<span class="fc" id="L1237">      IndexedWord dep = ref.getDependent();// take the relative word</span>
<span class="fc" id="L1238">      IndexedWord ant = ref.getGovernor();// take the antecedent</span>

<span class="fc bfc" id="L1240" title="All 2 branches covered.">      for (Iterator&lt;SemanticGraphEdge&gt; iter = sgCopy.incomingEdgeIterator(dep); iter.hasNext(); ) {</span>
<span class="fc" id="L1241">        SemanticGraphEdge edge = iter.next();</span>

        // the last condition below maybe shouldn't be necessary, but it has
        // helped stop things going haywire a couple of times (it stops the
        // creation of a unit cycle that probably leaves something else
        // disconnected) [cdm Jan 2010]
<span class="pc bpc" id="L1247" title="1 of 4 branches missed.">        if (edge.getRelation() != REFERENT &amp;&amp; ! edge.getGovernor().equals(ant)) {</span>
<span class="fc" id="L1248">          sg.removeEdge(edge);</span>
<span class="fc" id="L1249">          sg.addEdge(edge.getGovernor(), ant, edge.getRelation(), Double.NEGATIVE_INFINITY, true);</span>
        }
<span class="fc" id="L1251">      }</span>
<span class="fc" id="L1252">    }</span>
<span class="fc" id="L1253">  }</span>

  /**
   * Look for ref rules for a given word.  We look through the
   * children and grandchildren of the acl:relcl dependency, and if any
   * children or grandchildren depend on a that/what/which/etc word,
   * we take the leftmost that/what/which/etc word as the dependent
   * for the ref TypedDependency.
   */
  private static void addRef(SemanticGraph sg) {
<span class="fc bfc" id="L1263" title="All 2 branches covered.">    for (SemanticGraphEdge edge : sg.findAllRelns(RELATIVE_CLAUSE_MODIFIER)) {</span>
<span class="fc" id="L1264">      IndexedWord head = edge.getGovernor();</span>
<span class="fc" id="L1265">      IndexedWord modifier = edge.getDependent();</span>

<span class="fc" id="L1267">      SemanticGraphEdge leftChildEdge = null;</span>
<span class="fc bfc" id="L1268" title="All 2 branches covered.">      for (SemanticGraphEdge childEdge : sg.outgoingEdgeIterable(modifier)) {</span>
<span class="pc bpc" id="L1269" title="1 of 4 branches missed.">        if (EnglishPatterns.RELATIVIZING_WORD_PATTERN.matcher(childEdge.getDependent().value()).matches() &amp;&amp;</span>
<span class="nc bnc" id="L1270" title="All 2 branches missed.">            (leftChildEdge == null || childEdge.getDependent().index() &lt; leftChildEdge.getDependent().index())) {</span>
<span class="fc" id="L1271">          leftChildEdge = childEdge;</span>
        }
<span class="fc" id="L1273">      }</span>

<span class="fc" id="L1275">      SemanticGraphEdge leftGrandchildEdge = null;</span>
<span class="fc bfc" id="L1276" title="All 2 branches covered.">      for (SemanticGraphEdge childEdge : sg.outgoingEdgeIterable(modifier)) {</span>
<span class="fc bfc" id="L1277" title="All 2 branches covered.">        for (SemanticGraphEdge grandchildEdge : sg.outgoingEdgeIterable(childEdge.getDependent())) {</span>
<span class="pc bpc" id="L1278" title="1 of 4 branches missed.">          if (EnglishPatterns.RELATIVIZING_WORD_PATTERN.matcher(grandchildEdge.getDependent().value()).matches() &amp;&amp;</span>
<span class="nc bnc" id="L1279" title="All 2 branches missed.">              (leftGrandchildEdge == null || grandchildEdge.getDependent().index() &lt; leftGrandchildEdge.getDependent().index())) {</span>
<span class="fc" id="L1280">            leftGrandchildEdge = grandchildEdge;</span>
          }
<span class="fc" id="L1282">        }</span>
<span class="fc" id="L1283">      }</span>

<span class="fc" id="L1285">      IndexedWord newDep = null;</span>
<span class="pc bpc" id="L1286" title="1 of 4 branches missed.">      if (leftGrandchildEdge != null</span>
<span class="nc bnc" id="L1287" title="All 2 branches missed.">          &amp;&amp; (leftChildEdge == null || leftGrandchildEdge.getDependent().index() &lt; leftChildEdge.getDependent().index())) {</span>
<span class="fc" id="L1288">        newDep = leftGrandchildEdge.getDependent();</span>
<span class="fc bfc" id="L1289" title="All 2 branches covered.">      } else if (leftChildEdge != null) {</span>
<span class="fc" id="L1290">        newDep = leftChildEdge.getDependent();</span>
      }
<span class="fc bfc" id="L1292" title="All 4 branches covered.">      if (newDep != null &amp;&amp; ! sg.containsEdge(head, newDep)) {</span>
<span class="fc" id="L1293">        sg.addEdge(head, newDep, REFERENT, Double.NEGATIVE_INFINITY, false);</span>
      }
<span class="fc" id="L1295">    }</span>
<span class="fc" id="L1296">  }</span>

  /**
   * Add extra nsubj dependencies when collapsing basic dependencies.
   * &lt;br/&gt;
   * In the general case, we look for an aux modifier under an xcomp
   * modifier, and assuming there aren't already associated nsubj
   * dependencies as daughters of the original xcomp dependency, we
   * add nsubj dependencies for each nsubj daughter of the aux.
   * &lt;br/&gt;
   * There is also a special case for &quot;to&quot; words, in which case we add
   * a dependency if and only if there is no nsubj associated with the
   * xcomp and there is no other aux dependency.  This accounts for
   * sentences such as &quot;he decided not to&quot; with no following verb.
   */
  private static void addExtraNSubj(SemanticGraph sg) {

<span class="fc bfc" id="L1313" title="All 2 branches covered.">    for (SemanticGraphEdge xcomp : sg.findAllRelns(XCLAUSAL_COMPLEMENT)) {</span>
<span class="fc" id="L1314">      IndexedWord modifier = xcomp.getDependent();</span>
<span class="fc" id="L1315">      IndexedWord head = xcomp.getGovernor();</span>

<span class="fc" id="L1317">      boolean hasSubjectDaughter = false;</span>
<span class="fc" id="L1318">      boolean hasAux = false;</span>
<span class="fc" id="L1319">      List&lt;IndexedWord&gt; subjects = Generics.newArrayList();</span>
<span class="fc" id="L1320">      List&lt;IndexedWord&gt; objects = Generics.newArrayList();</span>
<span class="fc bfc" id="L1321" title="All 2 branches covered.">      for (SemanticGraphEdge dep : sg.edgeIterable()) {</span>
        // already have a subject dependency
<span class="pc bpc" id="L1323" title="2 of 6 branches missed.">        if ((dep.getRelation() == NOMINAL_SUBJECT || dep.getRelation() == NOMINAL_PASSIVE_SUBJECT) &amp;&amp; dep.getGovernor().equals(modifier)) {</span>
<span class="nc" id="L1324">          hasSubjectDaughter = true;</span>
<span class="nc" id="L1325">          break;</span>
        }

<span class="fc bfc" id="L1328" title="All 6 branches covered.">        if ((dep.getRelation() == AUX_MODIFIER || dep.getRelation() == MARKER) &amp;&amp; dep.getGovernor().equals(modifier)) {</span>
<span class="fc" id="L1329">          hasAux = true;</span>
        }

<span class="pc bpc" id="L1332" title="1 of 6 branches missed.">        if ((dep.getRelation() == NOMINAL_SUBJECT || dep.getRelation() == NOMINAL_PASSIVE_SUBJECT) &amp;&amp; dep.getGovernor().equals(head)) {</span>
<span class="fc" id="L1333">          subjects.add(dep.getDependent());</span>
        }

<span class="pc bpc" id="L1336" title="1 of 4 branches missed.">        if (dep.getRelation() == DIRECT_OBJECT &amp;&amp; dep.getGovernor().equals(head)) {</span>
<span class="nc" id="L1337">          objects.add(dep.getDependent());</span>
        }
<span class="fc" id="L1339">      }</span>

      // if we already have an nsubj dependency, no need to add an extra nsubj
<span class="pc bpc" id="L1342" title="1 of 2 branches missed.">      if (hasSubjectDaughter) {</span>
<span class="nc" id="L1343">        continue;</span>
      }

<span class="pc bpc" id="L1346" title="3 of 4 branches missed.">      if ((modifier.value().equalsIgnoreCase(&quot;to&quot;) &amp;&amp; hasAux) ||</span>
<span class="pc bpc" id="L1347" title="1 of 4 branches missed.">          (!modifier.value().equalsIgnoreCase(&quot;to&quot;) &amp;&amp; !hasAux)) {</span>
<span class="fc" id="L1348">        continue;</span>
      }

      // In general, we find that the objects of the verb are better
      // for extra nsubj than the original nsubj of the verb.  For example,
      // &quot;Many investors wrote asking the SEC to require ...&quot;
      // There is no nsubj of asking, but the dobj, SEC, is the extra nsubj of require.
      // Similarly, &quot;The law tells them when to do so&quot;
      // Instead of nsubj(do, law) we want nsubj(do, them)
<span class="pc bpc" id="L1357" title="1 of 2 branches missed.">      if ( ! objects.isEmpty()) {</span>
<span class="nc bnc" id="L1358" title="All 2 branches missed.">        for (IndexedWord object : objects) {</span>
<span class="nc bnc" id="L1359" title="All 2 branches missed.">          if ( ! sg.containsEdge(modifier, object))</span>
<span class="nc" id="L1360">            sg.addEdge(modifier, object, CONTROLLING_NOMINAL_SUBJECT, Double.NEGATIVE_INFINITY, true);</span>
<span class="nc" id="L1361">        }</span>
      } else {
<span class="fc bfc" id="L1363" title="All 2 branches covered.">        for (IndexedWord subject : subjects) {</span>
<span class="fc bfc" id="L1364" title="All 2 branches covered.">          if ( ! sg.containsEdge(modifier, subject))</span>
<span class="fc" id="L1365">            sg.addEdge(modifier, subject, CONTROLLING_NOMINAL_SUBJECT, Double.NEGATIVE_INFINITY, true);</span>
<span class="fc" id="L1366">        }</span>
      }
<span class="fc" id="L1368">    }</span>
<span class="fc" id="L1369">  }</span>

<span class="fc" id="L1371">  private static SemgrexPattern CORRECT_SUBJPASS_PATTERN = SemgrexPattern.compile(&quot;{}=gov &gt;auxpass {} &gt;/^(nsubj|csubj).*$/ {}=subj&quot;);</span>

  /**
   * This method corrects subjects of verbs for which we identified an auxpass,
   * but didn't identify the subject as passive.
   *
   * @param sg SemanticGraph to work on
   */
  private static void correctSubjPass(SemanticGraph sg) {

    /* If the graph doesn't have a root (most likely because
     * a parsing error, we can't match Semgrexes, so do
     * nothing. */
<span class="pc bpc" id="L1384" title="1 of 2 branches missed.">    if (sg.getRoots().isEmpty())</span>
<span class="nc" id="L1385">      return;</span>

<span class="fc" id="L1387">    SemanticGraph sgCopy = sg.makeSoftCopy();</span>
<span class="fc" id="L1388">    SemgrexMatcher matcher = CORRECT_SUBJPASS_PATTERN.matcher(sgCopy);</span>

<span class="fc bfc" id="L1390" title="All 2 branches covered.">    while (matcher.find()) {</span>
<span class="fc" id="L1391">      IndexedWord gov = matcher.getNode(&quot;gov&quot;);</span>
<span class="fc" id="L1392">      IndexedWord subj = matcher.getNode(&quot;subj&quot;);</span>
<span class="fc" id="L1393">      SemanticGraphEdge edge = sg.getEdge(gov, subj);</span>

<span class="fc" id="L1395">      GrammaticalRelation reln = null;</span>
<span class="fc bfc" id="L1396" title="All 2 branches covered.">      if (edge.getRelation() == NOMINAL_SUBJECT) {</span>
<span class="fc" id="L1397">        reln = NOMINAL_PASSIVE_SUBJECT;</span>
<span class="pc bpc" id="L1398" title="1 of 2 branches missed.">      } else if (edge.getRelation() == CLAUSAL_SUBJECT) {</span>
<span class="nc" id="L1399">        reln = CLAUSAL_PASSIVE_SUBJECT;</span>
<span class="pc bpc" id="L1400" title="1 of 2 branches missed.">      } else if (edge.getRelation() == CONTROLLING_NOMINAL_SUBJECT) {</span>
<span class="nc" id="L1401">        reln = CONTROLLING_NOMINAL_PASSIVE_SUBJECT;</span>
<span class="pc bpc" id="L1402" title="1 of 2 branches missed.">      } else if (edge.getRelation() == CONTROLLING_CLAUSAL_SUBJECT) {</span>
<span class="nc" id="L1403">        reln = CONTROLLING_CLAUSAL_PASSIVE_SUBJECT;</span>
      }

<span class="fc bfc" id="L1406" title="All 2 branches covered.">      if (reln != null) {</span>
<span class="fc" id="L1407">        sg.removeEdge(edge);</span>
<span class="fc" id="L1408">        sg.addEdge(gov, subj, reln, Double.NEGATIVE_INFINITY, false);</span>
      }
<span class="fc" id="L1410">    }</span>
<span class="fc" id="L1411">  }</span>

  /* These multi-word prepositions typically have a
   *   case/advmod(gov, w1)
   *   case(gov, w2)
   * structure in the basic represenation.
   *
   * Kept in alphabetical order.
   */
<span class="fc" id="L1420">  private static final String[] TWO_WORD_PREPS_REGULAR = {&quot;across_from&quot;, &quot;along_with&quot;, &quot;alongside_of&quot;, &quot;apart_from&quot;, &quot;as_for&quot;, &quot;as_from&quot;, &quot;as_of&quot;, &quot;as_per&quot;, &quot;as_to&quot;, &quot;aside_from&quot;, &quot;based_on&quot;, &quot;close_by&quot;, &quot;close_to&quot;, &quot;contrary_to&quot;, &quot;compared_to&quot;, &quot;compared_with&quot;, &quot; depending_on&quot;, &quot;except_for&quot;, &quot;exclusive_of&quot;, &quot;far_from&quot;, &quot;followed_by&quot;, &quot;inside_of&quot;, &quot;irrespective_of&quot;, &quot;next_to&quot;, &quot;near_to&quot;, &quot;off_of&quot;, &quot;out_of&quot;, &quot;outside_of&quot;, &quot;owing_to&quot;, &quot;preliminary_to&quot;, &quot;preparatory_to&quot;, &quot;previous_to&quot;, &quot; prior_to&quot;, &quot;pursuant_to&quot;, &quot;regardless_of&quot;, &quot;subsequent_to&quot;, &quot;thanks_to&quot;, &quot;together_with&quot;};</span>

  /* These multi-word prepositions can have a
   *   advmod(gov1, w1)
   *   nmod(w1, gov2)
   *   case(gov2, w2)
   * structure in the basic represenation.
   *
   * Kept in alphabetical order.
   */
<span class="fc" id="L1430">  private static final String[] TWO_WORD_PREPS_COMPLEX = {&quot;apart_from&quot;, &quot;as_from&quot;, &quot;aside_from&quot;, &quot;away_from&quot;, &quot;close_by&quot;, &quot;close_to&quot;, &quot;contrary_to&quot;, &quot;far_from&quot;, &quot;next_to&quot;, &quot;near_to&quot;, &quot;out_of&quot;, &quot;outside_of&quot;, &quot;pursuant_to&quot;, &quot;regardless_of&quot;, &quot;together_with&quot;};</span>

  /*
   * Multi-word prepositions with the structure
   *   case(w2, w1)
   *   nmod(gov, w2)
   *   case(gov2, w3)
   *   nmod(w2, gov2)
   * in the basic representations.
   */
<span class="fc" id="L1440">  private static final String[] THREE_WORD_PREPS = { &quot;by_means_of&quot;, &quot;in_accordance_with&quot;, &quot;in_addition_to&quot;, &quot;in_case_of&quot;, &quot;in_front_of&quot;, &quot;in_lieu_of&quot;, &quot;in_place_of&quot;, &quot;in_spite_of&quot;, &quot;on_account_of&quot;, &quot;on_behalf_of&quot;, &quot;on_top_of&quot;, &quot;with_regard_to&quot;, &quot;with_respect_to&quot; };</span>


<span class="fc" id="L1443">  private static final SemgrexPattern TWO_WORD_PREPS_REGULAR_PATTERN = SemgrexPattern.compile(&quot;{}=gov &gt;/(case|advmod)/ ({}=w1 !&gt; {}) &gt;case ({}=w2 !== {}=w1 !&gt; {})&quot;);</span>
<span class="fc" id="L1444">  private static final SemgrexPattern TWO_WORD_PREPS_COMPLEX_PATTERN = SemgrexPattern.compile(&quot;({}=w1 &gt;nmod ({}=gov2 &gt;case ({}=w2 !&gt; {}))) [ == {$} | &lt; {}=gov ]&quot;);</span>
<span class="fc" id="L1445">  private static final SemgrexPattern THREE_WORD_PREPS_PATTERN = SemgrexPattern.compile(&quot;({}=w2 &gt;/(nmod|acl|advcl)/ ({}=gov2 &gt;/(case|mark)/ ({}=w3 !&gt; {}))) &gt;case ({}=w1 !&gt; {}) [ &lt; {}=gov | == {$} ]&quot;);</span>


  /**
   * Process multi-word prepositions.
   */
  private static void processMultiwordPreps(SemanticGraph sg) {
    /* Semgrexes require a graph with a root. */
<span class="pc bpc" id="L1453" title="1 of 2 branches missed.">    if (sg.getRoots().isEmpty())</span>
<span class="nc" id="L1454">      return;</span>

<span class="fc" id="L1456">    HashMap&lt;String, HashSet&lt;Integer&gt;&gt; bigrams = new HashMap&lt;&gt;();</span>
<span class="fc" id="L1457">    HashMap&lt;String, HashSet&lt;Integer&gt;&gt; trigrams = new HashMap&lt;&gt;();</span>


<span class="fc" id="L1460">    List&lt;IndexedWord&gt; vertexList = sg.vertexListSorted();</span>
<span class="fc" id="L1461">    int numWords = vertexList.size();</span>

<span class="fc bfc" id="L1463" title="All 2 branches covered.">    for (int i = 1; i &lt; numWords; i++) {</span>
<span class="fc" id="L1464">      String bigram = vertexList.get(i-1).value().toLowerCase() + '_' + vertexList.get(i).value().toLowerCase();</span>

<span class="fc" id="L1466">      bigrams.putIfAbsent(bigram, new HashSet&lt;&gt;());</span>

<span class="fc" id="L1468">      bigrams.get(bigram).add(vertexList.get(i-1).index());</span>

<span class="fc bfc" id="L1470" title="All 2 branches covered.">      if (i &gt; 1) {</span>
<span class="fc" id="L1471">        String trigram = vertexList.get(i-2).value().toLowerCase() + '_' + bigram;</span>
<span class="fc" id="L1472">        trigrams.putIfAbsent(trigram, new HashSet&lt;&gt;());</span>
<span class="fc" id="L1473">        trigrams.get(trigram).add(vertexList.get(i-2).index());</span>
      }
    }

    /* Simple two-word prepositions. */
<span class="fc" id="L1478">    processSimple2WP(sg, bigrams);</span>

    /* More complex two-word prepositions in which the first
     * preposition is the head of the prepositional phrase. */
<span class="fc" id="L1482">    processComplex2WP(sg, bigrams);</span>

    /* Process three-word prepositions. */
<span class="fc" id="L1485">    process3WP(sg, trigrams);</span>
<span class="fc" id="L1486">  }</span>


  /**
   * Processes all the two-word prepositions in TWO_WORD_PREPS_REGULAR.
   */
  private static void processSimple2WP(SemanticGraph sg, HashMap&lt;String, HashSet&lt;Integer&gt;&gt; bigrams) {
<span class="fc bfc" id="L1493" title="All 2 branches covered.">    for (String bigram : TWO_WORD_PREPS_REGULAR) {</span>
<span class="fc bfc" id="L1494" title="All 2 branches covered.">      if (bigrams.get(bigram) == null) {</span>
<span class="fc" id="L1495">        continue;</span>
      }

<span class="fc bfc" id="L1498" title="All 2 branches covered.">      for (Integer i : bigrams.get(bigram)) {</span>
<span class="fc" id="L1499">        IndexedWord w1 = sg.getNodeByIndexSafe(i);</span>
<span class="fc" id="L1500">        IndexedWord w2 = sg.getNodeByIndexSafe(i + 1);</span>

<span class="pc bpc" id="L1502" title="2 of 4 branches missed.">        if (w1 == null || w2 == null) {</span>
<span class="nc" id="L1503">          continue;</span>
        }

<span class="fc" id="L1506">        SemgrexMatcher matcher = TWO_WORD_PREPS_REGULAR_PATTERN.matcher(sg);</span>
<span class="fc" id="L1507">        IndexedWord gov = null;</span>
<span class="fc bfc" id="L1508" title="All 2 branches covered.">        while (matcher.find()) {</span>
<span class="pc bpc" id="L1509" title="2 of 4 branches missed.">          if (w1.equals(matcher.getNode(&quot;w1&quot;)) &amp;&amp; w2.equals(matcher.getNode(&quot;w2&quot;))) {</span>
<span class="fc" id="L1510">            gov = matcher.getNode(&quot;gov&quot;);</span>
<span class="fc" id="L1511">            break;</span>
          }
        }

<span class="fc bfc" id="L1515" title="All 2 branches covered.">        if (gov == null) {</span>
<span class="fc" id="L1516">          continue;</span>
        }

<span class="fc" id="L1519">        createMultiWordExpression(sg, gov, CASE_MARKER, w1, w2);</span>
<span class="fc" id="L1520">      }</span>
    }
<span class="fc" id="L1522">  }</span>


  /**
   * Processes all the two-word prepositions in TWO_WORD_PREPS_COMPLEX.
   */
  private static void processComplex2WP(SemanticGraph sg, HashMap&lt;String, HashSet&lt;Integer&gt;&gt; bigrams) {
<span class="fc bfc" id="L1529" title="All 2 branches covered.">    for (String bigram : TWO_WORD_PREPS_COMPLEX) {</span>
<span class="fc bfc" id="L1530" title="All 2 branches covered.">      if (bigrams.get(bigram) == null) {</span>
<span class="fc" id="L1531">        continue;</span>
      }

<span class="fc bfc" id="L1534" title="All 2 branches covered.">      for (Integer i : bigrams.get(bigram)) {</span>
<span class="fc" id="L1535">        IndexedWord w1 = sg.getNodeByIndexSafe(i);</span>
<span class="fc" id="L1536">        IndexedWord w2 = sg.getNodeByIndexSafe(i + 1);</span>

<span class="pc bpc" id="L1538" title="2 of 4 branches missed.">        if (w1 == null || w2 == null) {</span>
<span class="nc" id="L1539">          continue;</span>
        }

<span class="fc" id="L1542">        SemgrexMatcher matcher = TWO_WORD_PREPS_COMPLEX_PATTERN.matcher(sg);</span>
<span class="fc" id="L1543">        IndexedWord gov = null;</span>
<span class="fc" id="L1544">        IndexedWord gov2 = null;</span>
<span class="fc bfc" id="L1545" title="All 2 branches covered.">        while (matcher.find()) {</span>
<span class="pc bpc" id="L1546" title="2 of 4 branches missed.">          if (w1.equals(matcher.getNode(&quot;w1&quot;)) &amp;&amp; w2.equals(matcher.getNode(&quot;w2&quot;))) {</span>
<span class="fc" id="L1547">            gov = matcher.getNode(&quot;gov&quot;);</span>
<span class="fc" id="L1548">            gov2 = matcher.getNode(&quot;gov2&quot;);</span>
<span class="fc" id="L1549">            break;</span>
          }
        }

<span class="fc bfc" id="L1553" title="All 2 branches covered.">        if (gov2 == null) {</span>
<span class="fc" id="L1554">          continue;</span>
        }

        /* Attach the head of the prepositional phrase to
         * the head of w1. */
<span class="pc bpc" id="L1559" title="1 of 2 branches missed.">        if (sg.getRoots().contains(w1)) {</span>
<span class="fc" id="L1560">          SemanticGraphEdge edge = sg.getEdge(w1, gov2);</span>
<span class="pc bpc" id="L1561" title="1 of 2 branches missed.">          if (edge == null) {</span>
<span class="nc" id="L1562">            continue;</span>
          }

<span class="fc" id="L1565">          sg.removeEdge(edge);</span>
<span class="fc" id="L1566">          sg.getRoots().remove(w1);</span>
<span class="fc" id="L1567">          sg.addRoot(gov2);</span>
<span class="fc" id="L1568">        } else {</span>
<span class="nc" id="L1569">          SemanticGraphEdge edge = sg.getEdge(w1, gov2);</span>
<span class="nc bnc" id="L1570" title="All 2 branches missed.">          if (edge == null) {</span>
<span class="nc" id="L1571">            continue;</span>
          }
<span class="nc" id="L1573">          sg.removeEdge(edge);</span>

<span class="nc bnc" id="L1575" title="All 2 branches missed.">          gov = gov == null ? sg.getParent(w1) : gov;</span>
<span class="nc bnc" id="L1576" title="All 2 branches missed.">          if (gov == null) {</span>
<span class="nc" id="L1577">            continue;</span>
          }

          /* Determine the relation to use. If it is a relation that can
           * join two clauses and w1 is the head of a copular construction, then
           * use the relation of w1 and its parent. Otherwise use the relation of edge. */
<span class="nc" id="L1583">          GrammaticalRelation reln = edge.getRelation();</span>
<span class="nc bnc" id="L1584" title="All 2 branches missed.">          if (sg.hasChildWithReln(w1, COPULA)) {</span>
<span class="nc" id="L1585">            GrammaticalRelation reln2 = sg.getEdge(gov, w1).getRelation();</span>
<span class="nc bnc" id="L1586" title="All 2 branches missed.">            if (clauseRelations.contains(reln2)) {</span>
<span class="nc" id="L1587">              reln = reln2;</span>
            }
          }
<span class="nc" id="L1590">         sg.addEdge(gov, gov2, reln, Double.NEGATIVE_INFINITY, false);</span>
        }

        /* Make children of w1 dependents of gov2. */
<span class="fc bfc" id="L1594" title="All 2 branches covered.">        for (SemanticGraphEdge edge2 : sg.getOutEdgesSorted(w1)) {</span>
<span class="fc" id="L1595">          sg.removeEdge(edge2);</span>
<span class="fc" id="L1596">          sg.addEdge(gov2, edge2.getDependent(), edge2.getRelation(), edge2.getWeight(), edge2.isExtra());</span>
<span class="fc" id="L1597">        }</span>

<span class="fc" id="L1599">        createMultiWordExpression(sg, gov2, CASE_MARKER, w1, w2);</span>
<span class="fc" id="L1600">      }</span>
    }
<span class="fc" id="L1602">  }</span>


  /**
   * Processes all the three-word prepositions in THREE_WORD_PREPS.
   */
  private static void process3WP(SemanticGraph sg, HashMap&lt;String, HashSet&lt;Integer&gt;&gt; trigrams) {

<span class="fc bfc" id="L1610" title="All 2 branches covered.">    for (String trigram : THREE_WORD_PREPS) {</span>
<span class="pc bpc" id="L1611" title="1 of 2 branches missed.">      if (trigrams.get(trigram) == null) {</span>
<span class="fc" id="L1612">        continue;</span>
      }

<span class="nc bnc" id="L1615" title="All 2 branches missed.">      for (Integer i : trigrams.get(trigram)) {</span>
<span class="nc" id="L1616">        IndexedWord w1 = sg.getNodeByIndexSafe(i);</span>
<span class="nc" id="L1617">        IndexedWord w2 = sg.getNodeByIndexSafe(i + 1);</span>
<span class="nc" id="L1618">        IndexedWord w3 = sg.getNodeByIndexSafe(i + 2);</span>

<span class="nc bnc" id="L1620" title="All 6 branches missed.">        if (w1 == null || w2 == null || w3 == null) {</span>
<span class="nc" id="L1621">          continue;</span>
        }

<span class="nc" id="L1624">        SemgrexMatcher matcher = THREE_WORD_PREPS_PATTERN.matcher(sg);</span>
<span class="nc" id="L1625">        IndexedWord gov = null;</span>
<span class="nc" id="L1626">        IndexedWord gov2 = null;</span>
<span class="nc bnc" id="L1627" title="All 2 branches missed.">        while (matcher.find()) {</span>
<span class="nc bnc" id="L1628" title="All 6 branches missed.">          if (w1.equals(matcher.getNode(&quot;w1&quot;)) &amp;&amp; w2.equals(matcher.getNode(&quot;w2&quot;)) &amp;&amp; w3.equals(matcher.getNode(&quot;w3&quot;))) {</span>
<span class="nc" id="L1629">            gov = matcher.getNode(&quot;gov&quot;);</span>
<span class="nc" id="L1630">            gov2 = matcher.getNode(&quot;gov2&quot;);</span>
<span class="nc" id="L1631">            break;</span>
          }
        }

<span class="nc bnc" id="L1635" title="All 2 branches missed.">        if (gov2 == null) {</span>
<span class="nc" id="L1636">          continue;</span>
        }

<span class="nc" id="L1639">        GrammaticalRelation markerReln = CASE_MARKER;</span>

<span class="nc bnc" id="L1641" title="All 2 branches missed.">        if (sg.getRoots().contains(w2)) {</span>
<span class="nc" id="L1642">          SemanticGraphEdge edge = sg.getEdge(w2, gov2);</span>
<span class="nc bnc" id="L1643" title="All 2 branches missed.">          if (edge == null) {</span>
<span class="nc" id="L1644">            continue;</span>
          }

<span class="nc" id="L1647">          sg.removeEdge(edge);</span>
<span class="nc" id="L1648">          sg.getRoots().remove(w2);</span>
<span class="nc" id="L1649">          sg.addRoot(gov2);</span>
<span class="nc" id="L1650">        } else {</span>
<span class="nc" id="L1651">          SemanticGraphEdge edge = sg.getEdge(w2, gov2);</span>
<span class="nc bnc" id="L1652" title="All 2 branches missed.">          if (edge == null) {</span>
<span class="nc" id="L1653">            continue;</span>
          }
<span class="nc" id="L1655">          sg.removeEdge(edge);</span>

<span class="nc bnc" id="L1657" title="All 2 branches missed.">          gov = gov == null ? sg.getParent(w2) : gov;</span>
<span class="nc bnc" id="L1658" title="All 2 branches missed.">          if (gov == null) {</span>
<span class="nc" id="L1659">            continue;</span>
          }

<span class="nc" id="L1662">          GrammaticalRelation reln = sg.getEdge(gov, w2).getRelation();</span>
<span class="nc bnc" id="L1663" title="All 2 branches missed.">          if (reln == NOMINAL_MODIFIER</span>
<span class="nc bnc" id="L1664" title="All 2 branches missed.">              &amp;&amp; (edge.getRelation() == CLAUSAL_MODIFIER ||</span>
<span class="nc bnc" id="L1665" title="All 2 branches missed.">                  edge.getRelation() == ADV_CLAUSE_MODIFIER)) {</span>
<span class="nc" id="L1666">            reln = edge.getRelation();</span>
<span class="nc" id="L1667">            markerReln = MARKER;</span>
          }
<span class="nc" id="L1669">          sg.addEdge(gov, gov2, reln, Double.NEGATIVE_INFINITY, false);</span>
        }

        /* Make children of w2 dependents of gov2. */
<span class="nc bnc" id="L1673" title="All 2 branches missed.">        for (SemanticGraphEdge edge2 : sg.getOutEdgesSorted(w2)) {</span>
<span class="nc" id="L1674">          sg.removeEdge(edge2);</span>
<span class="nc" id="L1675">          sg.addEdge(gov2, edge2.getDependent(), edge2.getRelation(), edge2.getWeight(), edge2.isExtra());</span>
<span class="nc" id="L1676">        }</span>

<span class="nc" id="L1678">        createMultiWordExpression(sg, gov2, markerReln, w1, w2, w3);</span>
<span class="nc" id="L1679">      }</span>
    }
<span class="fc" id="L1681">  }</span>

  private static void createMultiWordExpression(SemanticGraph sg, IndexedWord gov, GrammaticalRelation reln, IndexedWord... words) {
<span class="pc bpc" id="L1684" title="3 of 6 branches missed.">    if (sg.getRoots().isEmpty() || gov == null || words.length &lt; 1) {</span>
<span class="nc" id="L1685">      return;</span>
    }

<span class="fc" id="L1688">    boolean first = true;</span>
<span class="fc" id="L1689">    IndexedWord mweHead = null;</span>
<span class="fc bfc" id="L1690" title="All 2 branches covered.">    for (IndexedWord word : words) {</span>
<span class="fc" id="L1691">      IndexedWord wordGov = sg.getParent(word);</span>
<span class="fc bfc" id="L1692" title="All 2 branches covered.">      if (wordGov != null) {</span>
<span class="fc" id="L1693">        SemanticGraphEdge edge = sg.getEdge(wordGov, word);</span>
<span class="pc bpc" id="L1694" title="1 of 2 branches missed.">        if (edge != null) {</span>
<span class="fc" id="L1695">          sg.removeEdge(edge);</span>
        }
      }

<span class="fc bfc" id="L1699" title="All 2 branches covered.">      if (first) {</span>
<span class="fc" id="L1700">        sg.addEdge(gov, word, reln, Double.NEGATIVE_INFINITY, false);</span>
<span class="fc" id="L1701">        mweHead = word;</span>
<span class="fc" id="L1702">        first = false;</span>
      } else {
<span class="fc" id="L1704">        sg.addEdge(mweHead, word, MULTI_WORD_EXPRESSION, Double.NEGATIVE_INFINITY, false);</span>
      }
    }
<span class="fc" id="L1707">  }</span>


  /** A lot of, an assortment of, ... */
<span class="fc" id="L1711">  private static final SemgrexPattern QUANT_MOD_3W_PATTERN = SemgrexPattern.compile(&quot;{word:/(?i:lot|assortment|number|couple|bunch|handful|litany|sheaf|slew|dozen|series|variety|multitude|wad|clutch|wave|mountain|array|spate|string|ton|range|plethora|heap|sort|form|kind|type|version|bit|pair|triple|total)/}=w2 &gt;det {word:/(?i:an?)/}=w1 !&gt;amod {} &gt;nmod ({tag:/(NN.*|PRP.*)/}=gov &gt;case {word:/(?i:of)/}=w3) . {}=w3&quot;);</span>

<span class="fc" id="L1713">  private static final SemgrexPattern[] QUANT_MOD_2W_PATTERNS = {</span>
      /* Lots of, dozens of, heaps of ... */
<span class="fc" id="L1715">      SemgrexPattern.compile(&quot;{word:/(?i:lots|many|several|plenty|tons|dozens|multitudes|mountains|loads|pairs|tens|hundreds|thousands|millions|billions|trillions|[0-9]+s)/}=w1 &gt;nmod ({tag:/(NN.*|PRP.*)/}=gov &gt;case {word:/(?i:of)/}=w2) . {}=w2&quot;),</span>

      /* Some of the ..., all of them, ... */
<span class="fc" id="L1718">      SemgrexPattern.compile(&quot;{word:/(?i:some|all|both|neither|everyone|nobody|one|two|three|four|five|six|seven|eight|nine|ten|hundred|thousand|million|billion|trillion|[0-9]+)/}=w1 [&gt;nmod ({tag:/(NN.*)/}=gov &gt;case ({word:/(?i:of)/}=w2 $+ {}=det) &gt;det {}=det) |  &gt;nmod ({tag:/(PRP.*)/}=gov &gt;case {word:/(?i:of)/}=w2)] . {}=w2&quot;)</span>
  };


  private static void demoteQuantificationalModifiers(SemanticGraph sg) {
<span class="nc" id="L1723">    SemanticGraph sgCopy = sg.makeSoftCopy();</span>
<span class="nc" id="L1724">    SemgrexMatcher matcher = QUANT_MOD_3W_PATTERN.matcher(sgCopy);</span>

<span class="nc bnc" id="L1726" title="All 2 branches missed.">    while (matcher.findNextMatchingNode()) {</span>
<span class="nc" id="L1727">      IndexedWord w1 = matcher.getNode(&quot;w1&quot;);</span>
<span class="nc" id="L1728">      IndexedWord w2 = matcher.getNode(&quot;w2&quot;);</span>
<span class="nc" id="L1729">      IndexedWord w3 = matcher.getNode(&quot;w3&quot;);</span>
<span class="nc" id="L1730">      IndexedWord gov = matcher.getNode(&quot;gov&quot;);</span>

<span class="nc" id="L1732">      demoteQmodParentHelper(sg, gov, w2);</span>

<span class="nc" id="L1734">      List&lt;IndexedWord&gt; otherDeps = Generics.newLinkedList();</span>

<span class="nc" id="L1736">      otherDeps.add(w1);</span>
<span class="nc" id="L1737">      otherDeps.add(w2);</span>
<span class="nc" id="L1738">      otherDeps.add(w3);</span>

<span class="nc" id="L1740">      demoteQmodMWEHelper(sg, otherDeps, gov, w2);</span>
<span class="nc" id="L1741">    }</span>

<span class="nc bnc" id="L1743" title="All 2 branches missed.">    for (SemgrexPattern p : QUANT_MOD_2W_PATTERNS) {</span>
<span class="nc" id="L1744">      sgCopy = sg.makeSoftCopy();</span>
<span class="nc" id="L1745">      matcher = p.matcher(sgCopy);</span>
<span class="nc bnc" id="L1746" title="All 2 branches missed.">      while (matcher.findNextMatchingNode()) {</span>
<span class="nc" id="L1747">        IndexedWord w1 = matcher.getNode(&quot;w1&quot;);</span>
<span class="nc" id="L1748">        IndexedWord w2 = matcher.getNode(&quot;w2&quot;);</span>
<span class="nc" id="L1749">        IndexedWord gov = matcher.getNode(&quot;gov&quot;);</span>

<span class="nc" id="L1751">        demoteQmodParentHelper(sg, gov, w1);</span>

<span class="nc" id="L1753">        List&lt;IndexedWord&gt; otherDeps = Generics.newLinkedList();</span>
<span class="nc" id="L1754">        otherDeps.add(w1);</span>
<span class="nc" id="L1755">        otherDeps.add(w2);</span>

<span class="nc" id="L1757">        demoteQmodMWEHelper(sg, otherDeps, gov, w1);</span>
<span class="nc" id="L1758">      }</span>
    }


<span class="nc" id="L1762">  }</span>

  private static void demoteQmodMWEHelper(SemanticGraph sg, List&lt;IndexedWord&gt; otherDeps, IndexedWord gov, IndexedWord oldHead) {
<span class="nc" id="L1765">    createMultiWordExpression(sg, gov, QMOD, otherDeps.toArray(new IndexedWord[otherDeps.size()]));</span>
<span class="nc" id="L1766">  }</span>


  private static void demoteQmodParentHelper(SemanticGraph sg, IndexedWord gov, IndexedWord oldHead) {
<span class="nc bnc" id="L1770" title="All 2 branches missed.">    if (!sg.getRoots().contains(oldHead)) {</span>
<span class="nc" id="L1771">      IndexedWord parent = sg.getParent(oldHead);</span>
<span class="nc bnc" id="L1772" title="All 2 branches missed.">      if (parent == null) {</span>
<span class="nc" id="L1773">        return;</span>
      }
<span class="nc" id="L1775">      SemanticGraphEdge edge = sg.getEdge(parent, oldHead);</span>
<span class="nc" id="L1776">      sg.addEdge(parent, gov, edge.getRelation(), edge.getWeight(), edge.isExtra());</span>
<span class="nc" id="L1777">      sg.removeEdge(edge);</span>
<span class="nc" id="L1778">    } else {</span>
<span class="nc" id="L1779">      sg.getRoots().remove(oldHead);</span>
<span class="nc" id="L1780">      sg.addRoot(gov);</span>
    }

    //temporary relation to keep the graph connected
<span class="nc" id="L1784">    sg.addEdge(gov, oldHead, DEPENDENT, Double.NEGATIVE_INFINITY, false);</span>
<span class="nc" id="L1785">    sg.removeEdge(sg.getEdge(oldHead, gov));</span>
<span class="nc" id="L1786">  }</span>


<span class="fc" id="L1789">  private static final SemgrexPattern[] NAME_PATTERNS = {</span>
<span class="fc" id="L1790">    SemgrexPattern.compile(&quot;{ner:PERSON}=w1 &gt;compound {}=w2&quot;),</span>
<span class="fc" id="L1791">    SemgrexPattern.compile(&quot;{ner:LOCATION}=w1 &gt;compound {}=w2&quot;)</span>
  };
<span class="fc" id="L1793">  private static final Predicate&lt;String&gt; PUNCT_TAG_FILTER = new PennTreebankLanguagePack().punctuationWordRejectFilter();</span>


  /**
   *
   * Looks for NPs that should have the {@code name} relation and
   * a) changes the structure such that the leftmost token becomes the head
   * b) changes the relation from {@code compound} to {@code name}.
   *
   * Requires NER tags.
   *
   * @param sg A semantic graph.
   */
  private static void processNames(SemanticGraph sg) {

<span class="pc bpc" id="L1808" title="1 of 2 branches missed.">    if ( ! USE_NAME) {</span>
<span class="fc" id="L1809">      return;</span>
    }

    // check whether NER tags are available
<span class="nc" id="L1813">    IndexedWord rootToken = sg.getFirstRoot();</span>
<span class="nc bnc" id="L1814" title="All 4 branches missed.">    if (rootToken == null || !rootToken.containsKey(CoreAnnotations.NamedEntityTagAnnotation.class)) {</span>
<span class="nc" id="L1815">      return;</span>
    }

<span class="nc" id="L1818">    SemanticGraph sgCopy = sg.makeSoftCopy();</span>
<span class="nc bnc" id="L1819" title="All 2 branches missed.">    for (SemgrexPattern pattern : NAME_PATTERNS) {</span>
<span class="nc" id="L1820">      SemgrexMatcher matcher = pattern.matcher(sgCopy);</span>
<span class="nc" id="L1821">      List&lt;IndexedWord&gt; nameParts = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1822">      IndexedWord head = null;</span>
<span class="nc bnc" id="L1823" title="All 2 branches missed.">      while (matcher.find()) {</span>
<span class="nc" id="L1824">        IndexedWord w1 = matcher.getNode(&quot;w1&quot;);</span>
<span class="nc" id="L1825">        IndexedWord w2 = matcher.getNode(&quot;w2&quot;);</span>
<span class="nc bnc" id="L1826" title="All 2 branches missed.">        if (head != w1) {</span>
<span class="nc bnc" id="L1827" title="All 2 branches missed.">          if (head != null) {</span>
<span class="nc" id="L1828">            processNamesHelper(sg, head, nameParts);</span>
<span class="nc" id="L1829">            nameParts = new ArrayList&lt;&gt;();</span>
          }
<span class="nc" id="L1831">          head = w1;</span>
        }
<span class="nc bnc" id="L1833" title="All 2 branches missed.">        if (w2.ner().equals(w1.ner())) {</span>
<span class="nc" id="L1834">          nameParts.add(w2);</span>
        }
<span class="nc" id="L1836">      }</span>
<span class="nc bnc" id="L1837" title="All 2 branches missed.">      if (head != null) {</span>
<span class="nc" id="L1838">        processNamesHelper(sg, head, nameParts);</span>
<span class="nc" id="L1839">        sgCopy = sg.makeSoftCopy();</span>
      }
    }
<span class="nc" id="L1842">  }</span>


  private static void processNamesHelper(SemanticGraph sg, IndexedWord oldHead, List&lt;IndexedWord&gt; nameParts) {

<span class="nc bnc" id="L1847" title="All 2 branches missed.">    if (nameParts.size() &lt; 1) {</span>
      // if the named entity only spans one token, change compound relations
      // to nmod relations to get the right structure for NPs with additional modifiers
      // such as &quot;Mrs. Clinton&quot;.
<span class="nc" id="L1851">      Set&lt;IndexedWord&gt; children = new HashSet&lt;&gt;(sg.getChildren(oldHead));</span>
<span class="nc bnc" id="L1852" title="All 2 branches missed.">      for (IndexedWord child : children) {</span>
<span class="nc" id="L1853">        SemanticGraphEdge oldEdge = sg.getEdge(oldHead, child);</span>
<span class="nc bnc" id="L1854" title="All 2 branches missed.">        if (oldEdge.getRelation() == UniversalEnglishGrammaticalRelations.COMPOUND_MODIFIER) {</span>
<span class="nc" id="L1855">          sg.addEdge(oldHead, child, UniversalEnglishGrammaticalRelations.NOMINAL_MODIFIER,</span>
<span class="nc" id="L1856">              oldEdge.getWeight(), oldEdge.isExtra());</span>
<span class="nc" id="L1857">          sg.removeEdge(oldEdge);</span>
        }
<span class="nc" id="L1859">      }</span>
<span class="nc" id="L1860">      return;</span>
    }

    // sort nameParts
<span class="nc" id="L1864">    Collections.sort(nameParts);</span>

    // check whether {nameParts[0], ..., nameParts[n], oldHead} are a contiguous NP
<span class="nc bnc" id="L1867" title="All 2 branches missed.">    for (int i = nameParts.get(0).index(), end = oldHead.index(); i &lt; end; i++) {</span>
<span class="nc" id="L1868">      IndexedWord node = sg.getNodeByIndexSafe(i);</span>
<span class="nc bnc" id="L1869" title="All 2 branches missed.">      if (node == null) {</span>
<span class="nc" id="L1870">        return;</span>
      }
<span class="nc bnc" id="L1872" title="All 4 branches missed.">      if ( ! nameParts.contains(node) &amp;&amp; PUNCT_TAG_FILTER.test(node.tag())) {</span>
        // not in nameParts and not a punctuation mark =&gt; not a contiguous NP
<span class="nc" id="L1874">        return;</span>
      }
    }


<span class="nc" id="L1879">    IndexedWord gov = sg.getParent(oldHead);</span>
<span class="nc bnc" id="L1880" title="All 4 branches missed.">    if (gov == null &amp;&amp; ! sg.getRoots().contains(oldHead)) {</span>
<span class="nc" id="L1881">      return;</span>
    }
<span class="nc" id="L1883">    IndexedWord newHead = nameParts.get(0);</span>
<span class="nc" id="L1884">    Set&lt;IndexedWord&gt; children = new HashSet&lt;&gt;(sg.getChildren(oldHead));</span>

    //change structure and relations
<span class="nc bnc" id="L1887" title="All 2 branches missed.">    for (IndexedWord child : children) {</span>
<span class="nc bnc" id="L1888" title="All 2 branches missed.">      if (child == newHead) {</span>
        // make the leftmost word the new head
<span class="nc bnc" id="L1890" title="All 2 branches missed.">        if (gov == null) {</span>
<span class="nc" id="L1891">          sg.getRoots().add(newHead);</span>
<span class="nc" id="L1892">          sg.getRoots().remove(oldHead);</span>
        } else {
<span class="nc" id="L1894">          SemanticGraphEdge oldEdge = sg.getEdge(gov, oldHead);</span>
<span class="nc" id="L1895">          sg.addEdge(gov, newHead, oldEdge.getRelation(), oldEdge.getWeight(), oldEdge.isExtra());</span>
<span class="nc" id="L1896">          sg.removeEdge(oldEdge);</span>
        }
        // swap direction of relation between old head and new head and change it to name relation.
<span class="nc" id="L1899">        SemanticGraphEdge oldEdge = sg.getEdge(oldHead, newHead);</span>
<span class="nc" id="L1900">        sg.addEdge(newHead, oldHead, UniversalEnglishGrammaticalRelations.NAME_MODIFIER, oldEdge.getWeight(), oldEdge.isExtra());</span>
<span class="nc" id="L1901">        sg.removeEdge(oldEdge);</span>
<span class="nc bnc" id="L1902" title="All 2 branches missed.">      } else  if (nameParts.contains(child)) {</span>
        // remove relation between the old head and part of the name
        // and introduce new relation between new head and part of the name
<span class="nc" id="L1905">        SemanticGraphEdge oldEdge = sg.getEdge(oldHead, child);</span>
<span class="nc" id="L1906">        sg.addEdge(newHead, child, UniversalEnglishGrammaticalRelations.NAME_MODIFIER, oldEdge.getWeight(), oldEdge.isExtra());</span>
<span class="nc" id="L1907">        sg.removeEdge(oldEdge);</span>
<span class="nc" id="L1908">      } else {</span>
        // attach word to new head
<span class="nc" id="L1910">        SemanticGraphEdge oldEdge = sg.getEdge(oldHead, child);</span>
        //if not the entire compound is part of a named entity, attach the other tokens via an nmod relation
<span class="nc bnc" id="L1912" title="All 2 branches missed.">        GrammaticalRelation reln = oldEdge.getRelation() == UniversalEnglishGrammaticalRelations.COMPOUND_MODIFIER ?</span>
<span class="nc" id="L1913">            UniversalEnglishGrammaticalRelations.NOMINAL_MODIFIER : oldEdge.getRelation();</span>
<span class="nc" id="L1914">        sg.addEdge(newHead, child, reln, oldEdge.getWeight(), oldEdge.isExtra());</span>
<span class="nc" id="L1915">        sg.removeEdge(oldEdge);</span>
      }
<span class="nc" id="L1917">    }</span>
<span class="nc" id="L1918">  }</span>

  /**
   * Find and remove any exact duplicates from a dependency list.
   * For example, the method that &quot;corrects&quot; nsubj dependencies can
   * turn them into nsubjpass dependencies.  If there is some other
   * source of nsubjpass dependencies, there may now be multiple
   * copies of the nsubjpass dependency.  If the containing data type
   * is a List, they may both now be in the List.
   */
  private static void removeExactDuplicates(SemanticGraph sg) {
<span class="fc" id="L1929">    sg.deleteDuplicateEdges();</span>
<span class="fc" id="L1930">  }</span>


  public static List&lt;GrammaticalStructure&gt; readCoNLLXGrammaticalStructureCollection(String fileName) throws IOException {
<span class="nc" id="L1934">    return readCoNLLXGrammaticalStructureCollection(fileName, UniversalEnglishGrammaticalRelations.shortNameToGRel, new FromDependenciesFactory());</span>
  }

  public static UniversalEnglishGrammaticalStructure buildCoNLLXGrammaticalStructure(List&lt;List&lt;String&gt;&gt; tokenFields) {
<span class="nc" id="L1938">    return (UniversalEnglishGrammaticalStructure) buildCoNLLXGrammaticalStructure(tokenFields, UniversalEnglishGrammaticalRelations.shortNameToGRel, new FromDependenciesFactory());</span>
  }

<span class="nc" id="L1941">  public static class FromDependenciesFactory</span>
    implements GrammaticalStructureFromDependenciesFactory {
    @Override
    public UniversalEnglishGrammaticalStructure build(List&lt;TypedDependency&gt; tdeps, TreeGraphNode root) {
<span class="nc" id="L1945">      return new UniversalEnglishGrammaticalStructure(tdeps, root);</span>
    }
  }

} // end class UniversalEnglishGrammaticalStructure
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>