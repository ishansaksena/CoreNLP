<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UniversalEnglishGrammaticalRelations.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.trees</a> &gt; <span class="el_source">UniversalEnglishGrammaticalRelations.java</span></div><h1>UniversalEnglishGrammaticalRelations.java</h1><pre class="source lang-java linenums">// Universal Stanford Dependencies - Code for producing and using Universal Stanford dependencies.
// Copyright Â© 2005-2014 The Board of Trustees of
// The Leland Stanford Junior University. All Rights Reserved.
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
//
// For more information, bug reports, fixes, contact:
//    Christopher Manning
//    Dept of Computer Science, Gates 2A
//    Stanford CA 94305-9020
//    USA
//    parser-support@lists.stanford.edu
//    http://nlp.stanford.edu/software/stanford-dependencies.shtml

package edu.stanford.nlp.trees;

import static edu.stanford.nlp.trees.EnglishPatterns.*;
import edu.stanford.nlp.trees.tregex.TregexPatternCompiler;
import edu.stanford.nlp.util.CollectionUtils;
import edu.stanford.nlp.util.Generics;
import edu.stanford.nlp.international.Language;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

import static edu.stanford.nlp.trees.GrammaticalRelation.*;


/**
 * {@code UniversalEnglishGrammaticalRelations} is a
 * set of {@link GrammaticalRelation} objects according to the Universal
 * Dependencies standard.
 * &lt;p/&gt;
 * Grammatical relations can either be shown in their basic form, where each
 * input token receives a relation, or &quot;collapsed&quot; which does certain normalizations
 * which group words or turns them into relations. See
 * {@link UniversalEnglishGrammaticalStructure}.  What is presented here mainly
 * shows the basic form, though there is some mixture. The &quot;collapsed&quot; grammatical
 * relations primarily differ as follows:
 * &lt;ul&gt;
 * &lt;li&gt;Some multiword conjunctions and prepositions are treated as single
 * words, and then processed as below.&lt;/li&gt;
 * &lt;li&gt;Prepositions are appended to nmod/acl/advcl
 * grammatical relations..&lt;/li&gt;
 * &lt;li&gt;Coordination markers are appended to &quot;conj&quot;
 * grammatical relations.&lt;/li&gt;
 * &lt;li&gt;Agents of passive sentences are recognized and marked as nmod:agent and not as nmod:by.&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p/&gt;
 * This set of English grammatical relations is not intended to be
 * exhaustive or immutable.  It's just where we're at now.
 * &lt;p/&gt;
 * &lt;p/&gt;
 * See {@link GrammaticalRelation} for details of fields and matching.
 * &lt;p/&gt;
 * &lt;p/&gt;
 * If using LexicalizedParser, it should be run with the
 * {@code -retainTmpSubcategories} option and one of the
 * {@code -splitTMP} options (e.g., {@code -splitTMP 1}) in order to
 * get the temporal NP dependencies maximally right!
 * &lt;p/&gt;
 * &lt;i&gt;Implementation notes: &lt;/i&gt; Don't change the set of GRs without discussing it
 * with people first.  If a change is needed, to add a new grammatical relation:
 * &lt;ul&gt;
 * &lt;li&gt; Governor nodes of the grammatical relations should be the lowest ones.&lt;/li&gt;
 * &lt;li&gt; Check the semantic head rules in UniversalSemanticHeadFinder and
 * ModCollinsHeadFinder, both in the trees package. That's what will be used to
 * match here.&lt;/li&gt;
 * &lt;li&gt; Create and define the GrammaticalRelation similarly to the others.&lt;/li&gt;
 * &lt;li&gt; Add it to the {@code values} array at the end of the file.&lt;/li&gt;
 * &lt;/ul&gt;
 * The patterns in this code assume that an NP may be followed by either a
 * -ADV or -TMP functional tag but there are no other functional tags represented.
 * This corresponds to what we currently get from NPTmpRetainingTreeNormalizer or
 * DependencyTreeTransformer.
 *
 * @author Bill MacCartney
 * @author Marie-Catherine de Marneffe
 * @author Christopher Manning
 * @author Galen Andrew (refactoring English-specific stuff)
 * @author Sebastian Schuster
 * @see GrammaticalStructure
 * @see GrammaticalRelation
 * @see EnglishGrammaticalStructure
 * @see &lt;a href=&quot;http://universaldependencies.github.io/docs/en/dep/&quot;&gt;English grammatical relations documentation&lt;/a&gt;
 */

public class UniversalEnglishGrammaticalRelations {

  //todo: Things still to fix: comparatives, in order to clauses, automatic Vadas-like NP structure

  /** This class is just a holder for static classes
   *  that act a bit like an enum.
   */
<span class="nc" id="L110">  private UniversalEnglishGrammaticalRelations() {}</span>

  // By setting the HeadFinder to null, we find out right away at
  // runtime if we have incorrectly set the HeadFinder for the
  // dependency tregexes
<span class="fc" id="L115">  private static final TregexPatternCompiler tregexCompiler = new TregexPatternCompiler((HeadFinder) null);</span>

  /**
   * The &quot;predicate&quot; grammatical relation.  The predicate of a
   * clause is the main VP of that clause; the predicate of a
   * subject is the predicate of the clause to which the subject
   * belongs.
   *
   * Example: &lt;br/&gt;
   * &quot;Reagan died&quot; &amp;rarr; {@code pred}(Reagan, died)
   */
<span class="fc" id="L126">  public static final GrammaticalRelation PREDICATE =</span>
    new GrammaticalRelation(Language.UniversalEnglish, &quot;pred&quot;, &quot;predicate&quot;,
        DEPENDENT, &quot;S|SINV&quot;, tregexCompiler,
        &quot;S|SINV &lt;# VP=target&quot;);


  /**
   * An auxiliary of a clause is a non-main verb of the clause,
   * e.g., a modal auxiliary, or a form of be, do or have in a
   * periphrastic tense.
   *
   * Contrary to the older SD and arguments of Pullum (1982) and
   * following, infinitive to is not analyzed as an auxiliary.
   * Instead, it is analyzed as a mark.
   *
   * Example: &lt;br/&gt;
   * &quot;Reagan has died&quot; &amp;rarr; {@code aux}(died, has)
   */
<span class="fc" id="L144">  public static final GrammaticalRelation AUX_MODIFIER =</span>
    new GrammaticalRelation(Language.UniversalEnglish, &quot;aux&quot;, &quot;auxiliary&quot;,
        DEPENDENT, &quot;VP|SQ|SINV|CONJP&quot;, tregexCompiler,
        &quot;VP &lt; VP &lt; (/^(?:MD|VB.*|AUXG?|POS)$/=target)&quot;,
        &quot;SQ|SINV &lt; (/^(?:VB|MD|AUX)/=target $++ /^(?:VP|ADJP)/)&quot;,
        // add handling of tricky VP fronting cases...
        &quot;SINV &lt; (VP=target &lt; (/^(?:VB|AUX|POS)/ &lt; &quot; + beAuxiliaryRegex + &quot;) $-- (VP &lt; VBG))&quot;);


  /**
    * The &quot;passive auxiliary&quot; grammatical relation. A passive auxiliary of a
    * clause is a
    * non-main verb of the clause which contains the passive information.
    *
    * Example: &lt;br/&gt;
    * &quot;Kennedy has been killed&quot; &amp;rarr; {@code auxpass}(killed, been)
    */
<span class="fc" id="L161">  public static final GrammaticalRelation AUX_PASSIVE_MODIFIER =</span>
     new GrammaticalRelation(Language.UniversalEnglish, &quot;auxpass&quot;, &quot;passive auxiliary&quot;,
         AUX_MODIFIER, &quot;VP|SQ|SINV&quot;, tregexCompiler,
         &quot;VP &lt; (/^(?:VB|AUX|POS)/=target &lt; &quot; + passiveAuxWordRegex + &quot; ) &lt; (VP|ADJP [ &lt; VBN|VBD | &lt; (VP|ADJP &lt; VBN|VBD) &lt; CC ] )&quot;,
         &quot;SQ|SINV &lt; (/^(?:VB|AUX|POS)/=target &lt; &quot; + beAuxiliaryRegex + &quot; $++ (VP &lt; VBD|VBN))&quot;,
         // add handling of tricky VP fronting cases...
         &quot;SINV &lt; (VP=target &lt; (/^(?:VB|AUX|POS)/ &lt; &quot; + beAuxiliaryRegex + &quot;) $-- (VP &lt; VBD|VBN))&quot;,
         &quot;SINV &lt; (VP=target &lt; (VP &lt; (/^(?:VB|AUX|POS)/ &lt; &quot; + beAuxiliaryRegex + &quot;)) $-- (VP &lt; VBD|VBN))&quot;);

  /**
   * The &quot;copula&quot; grammatical relation.  A copula is the relation between
   * the complement of a copular verb and the copular verb.&lt;p&gt;
   * &lt;p/&gt;
   * Examples: &lt;br/&gt;
   * &quot;Bill is big&quot; &amp;rarr; {@code cop}(big, is) &lt;br/&gt;
   * &quot;Bill is an honest man&quot; &amp;rarr; {@code cop}(man, is)
   */
<span class="fc" id="L178">  public static final GrammaticalRelation COPULA =</span>
    new GrammaticalRelation(Language.UniversalEnglish, &quot;cop&quot;, &quot;copula&quot;,
        AUX_MODIFIER, &quot;VP|SQ|SINV|SBARQ&quot;, tregexCompiler,
        &quot;VP &lt; (/^(?:VB|AUX)/=target &lt; &quot; + copularWordRegex + &quot; [ $++ (/^(?:ADJP|NP$|WHNP$|PP|UCP)/ !&lt; (VBN|VBD !$++ /^N/)) | $++ (S &lt;: (ADJP &lt; JJ)) ] )&quot;,
        &quot;SQ|SINV &lt; (/^(?:VB|AUX)/=target &lt; &quot; + copularWordRegex + &quot; [ $++ (ADJP !&lt; VBN|VBD) | $++ (NP $++ NP) | $++ (S &lt;: (ADJP &lt; JJ)) ] )&quot;,
        // matches (what, is) in &quot;what is that&quot; after the SQ has been flattened out of the tree
        &quot;SBARQ &lt; (/^(?:VB|AUX)/=target &lt; &quot; + copularWordRegex + &quot;) &lt; (WHNP &lt; WP)&quot;,
        // &quot;Such a great idea this was&quot;
        &quot;SINV &lt;# (NP $++ (NP $++ (VP=target &lt; (/^(?:VB|AUX)/ &lt; &quot; + copularWordRegex + &quot;))))&quot;);

  // ect seems to be a common misspelling for etc in the PTB
  private static final String ETC_PAT = &quot;(FW &lt; /^(?i:(etc|ect))$/)&quot;;
  private static final String ETC_PAT_target = &quot;(FW=target &lt; /^(?i:(etc|ect))$/)&quot;;

  private static final String FW_ETC_PAT = &quot;(ADVP|NP &lt;1 (FW &lt; /^(?i:(etc|ect))$/))&quot;;
  private static final String FW_ETC_PAT_target = &quot;(ADVP|NP=target &lt;1 (FW &lt; /^(?i:(etc|ect))$/))&quot;;

  // match &quot;not&quot;, &quot;n't&quot;, &quot;nt&quot; (for informal writing), or &quot;never&quot; as _complete_ string
  private static final String NOT_PAT = &quot;/^(?i:n[o']?t|never)$/&quot;;

  private static final String WESTERN_SMILEY = &quot;/^(?:[&lt;&gt;]?[:;=8][\\-o\\*']?(?:-RRB-|-LRB-|[DPdpO\\/\\\\\\:}{@\\|\\[\\]])|(?:-RRB-|-LRB-|[DPdpO\\/\\\\\\:}{@\\|\\[\\]])[\\-o\\*']?[:;=8][&lt;&gt;]?)$/&quot;;

  private static final String ASIAN_SMILEY = &quot;/(?!^--$)^(?:-LRB-)?[\\-\\^x=~&lt;&gt;'][_.]?[\\-\\^x=~&lt;&gt;'](?:-RRB-)?$/&quot;;

  /**
   * The &quot;conjunct&quot; grammatical relation.  A conjunct is the relation between
   * two elements connected by a conjunction word.  We treat conjunctions
   * asymmetrically: The head of the relation is the first conjunct and other
   * conjunctions depend on it via the &lt;i&gt;conj&lt;/i&gt; relation.&lt;p&gt;
   * &lt;p/&gt;
   * Example: &lt;br/&gt;
   * &quot;Bill is big and honest&quot; &amp;rarr; {@code conj}(big, honest)
   * &lt;p/&gt;
   * &lt;i&gt;Note:&lt;/i&gt;Modified in 2010 to exclude the case of a CC/CONJP first in its phrase: it has to conjoin things.
   */
<span class="fc" id="L213">  public static final GrammaticalRelation CONJUNCT =</span>
    new GrammaticalRelation(Language.UniversalEnglish, &quot;conj&quot;, &quot;conjunct&quot;,
        DEPENDENT, &quot;VP|(?:WH)?NP(?:-TMP|-ADV)?|ADJP|PP|QP|ADVP|UCP(?:-TMP|-ADV)?|S|NX|SBAR|SBARQ|SINV|SQ|JJP|NML|RRC|PCONJP&quot;, tregexCompiler,
            &quot;VP|S|SBAR|SBARQ|SINV|SQ|RRC &lt; (CC|CONJP $-- !/^(?:``|-LRB-|PRN|PP|ADVP|RB|MWE)/ $+ !/^(?:SBAR|PRN|``|''|-[LR]RB-|,|:|\\.)$/=target)&quot;,
            // This case is separated out from the previous case to
            // avoid conflicts with advcl when you have phrases such as
            // &quot;but only because ...&quot;
            &quot;SBAR &lt; (CC|CONJP $-- @SBAR $+ @SBAR=target)&quot;,
            // non-parenthetical or comma in suitable phrase with conj then adverb to left
            &quot;VP|S|SBAR|SBARQ|SINV|SQ|RRC &lt; (CC|CONJP $-- !/^(?:``|-LRB-|PRN|PP|ADVP|RB)/ $+ (ADVP $+ !/^(?:PRN|``|''|-[LR]RB-|,|:|\\.)$/=target))&quot;,
            // content phrase to the right of a comma or a parenthetical
            // The test at the end is to make sure that a conjunction or
            // comma etc actually show up between the target of the conj
            // dependency and the head of the phrase.  Otherwise, a
            // different relationship is probably more appropriate.
            // Note that this test looks for one of two things: a
            // cc/conjp which does not have a , between it and the
            // target or a , which does not appear to the right of a
            // cc/conjp.  This test eliminates things such as
            // parenthetics which come after a list, such as in the
            // sentence &quot;to see the market go down and dump everything,
            // which ...&quot; where &quot;go down and dump everything, which...&quot;
            // is all in one VP node.
            &quot;VP|S|SBAR|SBARQ|SINV|SQ=root &lt; (CC|CONJP $-- !/^(?:``|-LRB-|PRN|PP|ADVP|RB)/) &lt; (/^(?:PRN|``|''|-[LR]RB-|,|:|\\.)$/ $+ (/^S|SINV$|^(?:A|N|V|PP|PRP|J|W|R)/=target [$-- (CC|CONJP $-- (__ &gt;# =root) !$++ (/^:|,$/ $++ =target)) | $-- (/^:|,$/ $-- (__ &gt;# =root) [!$-- /^CC|CONJP$/ | $++ (=target &lt; (/^,$/ $++ (__ &gt;# =target)))])] ) )&quot;,

            // non-parenthetical or comma in suitable phrase with conjunction to left
            &quot;/^(?:ADJP|JJP|PP|QP|(?:WH)?NP(?:-TMP|-ADV)?|ADVP|UCP(?:-TMP|-ADV)?|NX|NML)$/ [ &lt; (CC|CONJP $-- !/^(?:``|-LRB-|PRN)$/ $+ !/^(?:PRN|``|''|-[LR]RB-|,|:|\\.)$/=target) | &lt; &quot; + ETC_PAT_target + &quot; | &lt; &quot; + FW_ETC_PAT_target + &quot;]&quot;,
            // non-parenthetical or comma in suitable phrase with conj then adverb to left
            &quot;/^(?:ADJP|PP|(?:WH)?NP(?:-TMP|-ADV)?|ADVP|UCP(?:-TMP|-ADV)?|NX|NML)$/ &lt; (CC|CONJP $-- !/^(?:``|-LRB-|PRN)$/ $+ (ADVP $+ !/^(?:PRN|``|''|-[LR]RB-|,|:|\\.)$/=target))&quot;,
            // content phrase to the right of a comma or a parenthetical
            &quot;/^(?:ADJP|PP|(?:WH)?NP(?:-TMP|-ADV)?|ADVP|UCP(?:-TMP|-ADV)?|NX|NML)$/ [ &lt; (CC|CONJP $-- !/^(?:``|-LRB-|PRN)$/) | &lt; &quot; + ETC_PAT + &quot; | &lt; &quot; + FW_ETC_PAT + &quot;] &lt; (/^(?:PRN|``|''|-[LR]RB-|,|:|\\.)$/ [ $+ /^S|SINV$|^(?:A|N|V|PP|PRP|J|W|R)/=target | $+ &quot; + ETC_PAT_target + &quot; ] )&quot;,

            // content phrase to the left of a comma for at least NX
            &quot;NX|NML [ &lt; (CC|CONJP $- __) | &lt; &quot; + ETC_PAT + &quot;] &lt; (/^,$/ $- /^(?:A|N|V|PP|PRP|J|W|R|S)/=target)&quot;,
            // to take the conjunct in a preconjunct structure &quot;either X or Y&quot;
            // also catches some missing examples of etc as conj
            &quot;/^(?:VP|S|SBAR|SBARQ|SINV|ADJP|PP|QP|(?:WH)?NP(?:-TMP|-ADV)?|ADVP|UCP(?:-TMP|-ADV)?|NX|NML)$/ [ &lt; (CC $++ (CC|CONJP $+ !/^(?:PRN|``|''|-[LR]RB-|,|:|\\.)$/=target)) | &lt;- &quot; + ETC_PAT_target + &quot; | &lt;- &quot; + FW_ETC_PAT_target + &quot; ]&quot;,
            // transformed prepositional conjunction phrase in sentence such as
            // &quot;Lufthansa flies from and to Serbia.&quot;
            &quot;PCONJP &lt; (CC $+ IN|TO=target)&quot;,
            //to get conjunctions in phrases such as &quot;big / main&quot; or &quot;man / woman&quot;
            &quot;/.*/ &lt; (/^(.*)$/#1%x $+ (/,/ &lt; /\\// $+ /^(.*)$/#1%x=target))&quot;);


  /**
   * The &quot;coordination&quot; grammatical relation.  A coordination is the relation
   * between an element and a conjunction.
   * &lt;p/&gt;
   * Example: &lt;br/&gt;
   * &quot;Bill is big and honest.&quot; &amp;rarr; {@code cc}(big, and)
   */
<span class="fc" id="L264">  public static final GrammaticalRelation COORDINATION =</span>
    new GrammaticalRelation(Language.UniversalEnglish, &quot;cc&quot;, &quot;coordination&quot;,
        DEPENDENT, &quot;.*&quot;, tregexCompiler,
            &quot;__ ([ &lt; (CC=target !&lt; /^(?i:either|neither|both)$/ ) | &lt; (CONJP=target !&lt; (RB &lt; /^(?i:not)$/ $+ (RB|JJ &lt; /^(?i:only|just|merely)$/))) ] [!&gt; /PP/ | !&gt;2 NP])&quot;);


  /**
   * The &quot;punctuation&quot; grammatical relation.  This is used for any piece of
   * punctuation in a clause, if punctuation is being retained in the
   * typed dependencies.
   * &lt;p/&gt;
   * Example: &lt;br/&gt;
   * &quot;Go home!&quot; &amp;rarr; {@code punct}(Go, !)
   * &lt;p/&gt;
   * The condition for NFP to appear hear is that it does not match the emoticon patterns under discourse.
   */
<span class="fc" id="L280">  public static final GrammaticalRelation PUNCTUATION =</span>
    new GrammaticalRelation(Language.UniversalEnglish, &quot;punct&quot;, &quot;punctuation&quot;,
        DEPENDENT, &quot;.*&quot;, tregexCompiler,
            &quot;__ &lt; /^(?:\\.|:|,|''|``|\\*|-LRB-|-RRB-|HYPH)$/=target&quot;,
            &quot;__ &lt; (NFP=target !&lt; &quot; + WESTERN_SMILEY + &quot; !&lt; &quot; + ASIAN_SMILEY + &quot;)&quot;);


  /**
   * The &quot;argument&quot; grammatical relation.  An argument of a VP is a
   * subject or complement of that VP; an argument of a clause is
   * an argument of the VP which is the predicate of that
   * clause.&lt;p&gt;
   * &lt;p/&gt;
   * Example: &lt;br/&gt;
   * &quot;Clinton defeated Dole&quot; &amp;rarr; &lt;code&gt;arg&lt;/code&gt;(defeated, Clinton), {@code arg}(defeated, Dole)
   */
<span class="fc" id="L296">  public static final GrammaticalRelation ARGUMENT =</span>
    new GrammaticalRelation(Language.UniversalEnglish, &quot;arg&quot;, &quot;argument&quot;, DEPENDENT);


  /**
   * The &quot;subject&quot; grammatical relation.  The subject of a VP is
   * the noun or clause that performs or experiences the VP; the
   * subject of a clause is the subject of the VP which is the
   * predicate of that clause.&lt;p&gt;
   * &lt;p/&gt;
   * Examples: &lt;br/&gt;
   * &quot;Clinton defeated Dole&quot; &amp;rarr; {@code subj}(defeated, Clinton) &lt;br/&gt;
   * &quot;What she said is untrue&quot; &amp;rarr; {@code subj}(is, What she said)
   */
<span class="fc" id="L310">  public static final GrammaticalRelation SUBJECT =</span>
    new GrammaticalRelation(Language.UniversalEnglish, &quot;subj&quot;, &quot;subject&quot;, ARGUMENT);


  /**
   * The &quot;nominal subject&quot; grammatical relation.  A nominal subject is
   * a subject which is an noun phrase.&lt;p&gt;
   * &lt;p/&gt;
   * Example: &lt;br/&gt;
   * &quot;Clinton defeated Dole&quot; &amp;rarr; {@code nsubj}(defeated, Clinton)
   */
<span class="fc" id="L321">  public static final GrammaticalRelation NOMINAL_SUBJECT =</span>
    new GrammaticalRelation(Language.UniversalEnglish, &quot;nsubj&quot;, &quot;nominal subject&quot;,
        SUBJECT, &quot;S|SQ|SBARQ|SINV|SBAR|PRN&quot;, tregexCompiler,
            &quot;S=subj &lt; ((NP|WHNP=target !&lt; EX !&lt;# (/^NN/ &lt; (&quot; + timeWordRegex + &quot;))) $++ VP=verb) : (=subj !&gt; VP | !&lt;&lt; (=verb &lt; TO))&quot;,
            &quot;S &lt; ( NP=target &lt;# (/^NN/ &lt; &quot; + timeWordRegex + &quot;) !$++ NP $++VP)&quot;,
            &quot;SQ|PRN &lt; (NP=target !&lt; EX $++ VP)&quot;,
            &quot;SQ &lt; (NP=target !&lt; EX $- (/^(?:VB|AUX)/ &lt; &quot; + copularWordRegex + &quot;) !$++ VP)&quot;,
            // Allows us to match &quot;Does it?&quot; without matching &quot;Who does it?&quot;
            &quot;SQ &lt; (NP=target !&lt; EX $- /^(?:VB|AUX)/ !$++ VP) !$-- NP|WHNP&quot;,
            &quot;SQ &lt; ((NP=target !&lt; EX) $- (RB $- /^(?:VB|AUX)/) ![$++ VP])&quot;,
            &quot;SBARQ &lt; WHNP=target &lt; (SQ &lt; (VP !$-- NP))&quot;,
            // This will capture incorrectly parsed trees in sentences
            // such as &quot;What disease causes cancer&quot; without capturing
            // correctly parsed trees such as &quot;What do elephants eat?&quot;
            &quot;SBARQ &lt; WHNP=target &lt; (SQ &lt; ((/^(?:VB)/ !&lt; &quot; + copularWordRegex + &quot;) !$-- NP !$++ VP))&quot;,
            &quot;SBARQ &lt; (SQ=target &lt; (/^(?:VB|AUX)/ &lt; &quot; + copularWordRegex + &quot;) !&lt; VP)&quot;,
            // matches subj in SINV
            &quot;SINV &lt; (NP|WHNP=target [ $- VP|VBZ|VBD|VBP|VB|MD|AUX | $- (@RB|ADVP $- VP|VBZ|VBD|VBP|VB|MD|AUX) | !$- __ !$ @NP] )&quot;,
            // Another SINV subj, such as &quot;Such a great idea this was&quot;
            &quot;SINV &lt; (NP $++ (NP=target $++ (VP &lt; (/^(?:VB|AUX)/ &lt; &quot; + copularWordRegex + &quot;))))&quot;,
            //matches subj in xcomp like &quot;He considered him a friend&quot;
            &quot;S &lt; (NP=target $+ NP|ADJP) &gt; VP&quot;,
            // matches subj in relative clauses
            &quot;SBAR &lt; WHNP=target [ &lt; (S &lt; (VP !$-- NP) !&lt; SBAR) | &lt; (VP !$-- NP) !&lt; S ]&quot;,  // second disjunct matches errors where there is no S under SBAR and otherwise does no harm
            // matches subj in relative clauses
            &quot;SBAR !&lt; WHNP &lt; (S !&lt; (NP $++ VP)) &gt; (VP &gt; (S $- WHNP=target))&quot;,
            // matches subj in existential &quot;there&quot; SQ
            &quot;SQ &lt; ((NP &lt; EX) $++ NP=target)&quot;,
            // matches subj in existential &quot;there&quot; S
            &quot;S &lt; (NP &lt; EX) &lt;+(VP) (VP &lt; NP=target)&quot;,
            // matches (what, that) in &quot;what is that&quot; after the SQ has been flattened out of the tree
            &quot;SBARQ &lt; (/^(?:VB|AUX)/ &lt; &quot; + copularWordRegex + &quot;) &lt; (WHNP &lt; WP) &lt; NP=target&quot;,
            // matches (what, wrong) in &quot;what is wrong with ...&quot; after the SQ has been flattened out of the tree
            // note that in that case &quot;wrong&quot; is taken as the head thanks to UniversalSemanticHeadFinder hackery
            // The !$++ matches against (what, worth) in What is UAL stock worth?
            &quot;SBARQ &lt; (WHNP=target $++ ((/^(?:VB|AUX)/ &lt; &quot; + copularWordRegex + &quot;) $++ ADJP=adj !$++ (NP $++ =adj)))&quot;,
            // the (NP &lt; EX) matches (is, WHNP) in &quot;what dignity is there in ...&quot;
            // the PP matches (is, WHNP) in &quot;what is on the test&quot;
            &quot;SBARQ &lt;1 WHNP=target &lt; (SQ &lt; (/^(?:VB|AUX)/ &lt; &quot; + copularWordRegex + &quot;) [&lt; (NP &lt; EX) | &lt; PP])&quot;);


  /**
   * The &quot;nominal passive subject&quot; grammatical relation.  A nominal passive
   * subject is a subject of a passive which is an noun phrase.&lt;p&gt;
   * &lt;p/&gt;
   * Example: &lt;br/&gt;
   * &quot;Dole was defeated by Clinton&quot; &amp;rarr; {@code nsubjpass}(defeated, Dole)
   * &lt;p&gt;
   * This pattern recognizes basic (non-coordinated) examples.  The coordinated
   * examples are currently handled by correctDependencies() in
   * EnglishGrammaticalStructure.  This seemed more accurate than any tregex
   * expression we could come up with.
   */
<span class="fc" id="L374">  public static final GrammaticalRelation NOMINAL_PASSIVE_SUBJECT =</span>
    new GrammaticalRelation(Language.UniversalEnglish, &quot;nsubjpass&quot;, &quot;nominal passive subject&quot;,
        NOMINAL_SUBJECT, &quot;S|SQ&quot;, tregexCompiler,
            &quot;S|SQ &lt; (WHNP|NP=target !&lt; EX) &lt; (VP &lt; (/^(?:VB|AUX)/ &lt; &quot; + passiveAuxWordRegex + &quot;)  &lt; (VP &lt; VBN|VBD))&quot;);


  /**
   * The &quot;clausal subject&quot; grammatical relation.  A clausal subject is
   * a subject which is a clause.&lt;p&gt;
   * &lt;p/&gt;
   * Examples: (subject is &quot;what she said&quot; in both examples) &lt;br/&gt;
   * &quot;What she said makes sense&quot; &amp;rarr; {@code csubj}(makes, said) &lt;br/&gt;
   * &quot;What she said is untrue&quot; &amp;rarr; {@code csubj}(untrue, said)
   */
<span class="fc" id="L388">  public static final GrammaticalRelation CLAUSAL_SUBJECT =</span>
    new GrammaticalRelation(Language.UniversalEnglish, &quot;csubj&quot;, &quot;clausal subject&quot;,
        SUBJECT, &quot;S&quot;, tregexCompiler,
            &quot;S &lt; (SBAR|S=target !$+ /^,$/ $++ (VP !$-- NP))&quot;);



  /**
   * The &quot;clausal passive subject&quot; grammatical relation.  A clausal passive subject is
   * a subject of a passive verb which is a clause.&lt;p&gt;
   * &lt;p/&gt;
   * Example: (subject is &quot;that she lied&quot;) &lt;br/&gt;
   * &quot;That she lied was suspected by everyone&quot; &amp;rarr; {@code csubjpass}(suspected, lied)
   */
<span class="fc" id="L402">  public static final GrammaticalRelation CLAUSAL_PASSIVE_SUBJECT =</span>
    new GrammaticalRelation(Language.UniversalEnglish, &quot;csubjpass&quot;, &quot;clausal passive subject&quot;,
        CLAUSAL_SUBJECT, &quot;S&quot;, tregexCompiler,
            &quot;S &lt; (SBAR|S=target !$+ /^,$/ $++ (VP &lt; (VP &lt; VBN|VBD) &lt; (/^(?:VB|AUXG?)/ &lt; &quot; + passiveAuxWordRegex + &quot;) !$-- NP))&quot;,
            &quot;S &lt; (SBAR|S=target !$+ /^,$/ $++ (VP &lt;+(VP) (VP &lt; VBN|VBD &gt; (VP &lt; (/^(?:VB|AUX)/ &lt; &quot; + passiveAuxWordRegex + &quot;))) !$-- NP))&quot;);



  /**
   * The &quot;complement&quot; grammatical relation.  A complement of a VP
   * is any object (direct or indirect) of that VP, or a clause or
   * adjectival phrase which functions like an object; a complement
   * of a clause is an complement of the VP which is the predicate
   * of that clause.&lt;p&gt;
   * &lt;p/&gt;
   * Examples: &lt;br/&gt;
   * &quot;She gave me a raise&quot; &amp;rarr;
   * {@code comp}(gave, me),
   * {@code comp}(gave, a raise) &lt;br/&gt;
   * &quot;I like to swim&quot; &amp;rarr;
   * {@code comp}(like, to swim)
   */
<span class="fc" id="L424">  public static final GrammaticalRelation COMPLEMENT =</span>
    new GrammaticalRelation(Language.UniversalEnglish, &quot;comp&quot;, &quot;complement&quot;, ARGUMENT);


  /**
   * The &quot;object&quot; grammatical relation.  An object of a VP
   * is any direct object or indirect object of that VP; an object
   * of a clause is an object of the VP which is the predicate
   * of that clause.&lt;p&gt;
   * &lt;p/&gt;
   * Examples: &lt;br/&gt;
   * &quot;She gave me a raise&quot; &amp;rarr;
   * {@code obj}(gave, me),
   * {@code obj}(gave, raise)
   */
<span class="fc" id="L439">  public static final GrammaticalRelation OBJECT =</span>
    new GrammaticalRelation(Language.UniversalEnglish, &quot;obj&quot;, &quot;object&quot;, COMPLEMENT);


  /**
   * The &quot;direct object&quot; grammatical relation.  The direct object
   * of a verb is the noun phrase which is the (accusative) object of
   * the verb; the direct object of a clause or VP is the direct object of
   * the head predicate of that clause.&lt;p&gt;
   * &lt;p/&gt;
   * Example: &lt;br/&gt;
   * &quot;She gave me a raise&quot; &amp;rarr;
   * {@code dobj}(gave, raise) &lt;p/&gt;
   * Note that dobj can also be assigned by the conversion of rel in the postprocessing.
   */
<span class="fc" id="L454">  public static final GrammaticalRelation DIRECT_OBJECT =</span>
    new GrammaticalRelation(Language.UniversalEnglish, &quot;dobj&quot;, &quot;direct object&quot;,
        OBJECT, &quot;VP|SQ|SBARQ?&quot;, tregexCompiler,
            &quot;VP !&lt; (/^(?:VB|AUX)/ [ &lt; &quot; + copularWordRegex + &quot; | &lt; &quot; + clausalComplementRegex + &quot; ]) &lt; (NP|WHNP=target [ [ !&lt;# (/^NN/ &lt; &quot; + timeWordRegex + &quot;) !$+ NP ] | $+ NP-TMP | $+ (NP &lt;# (/^NN/ &lt; &quot; + timeWordRegex + &quot;)) ] ) &quot; +
                // The next qualification eliminates parentheticals that
                // come after the actual dobj
                &quot; &lt;# (__ !$++ (NP $++ (/^[:]$/ $++ =target))) &quot;,

            // Examples such as &quot;Rolls-Royce expects sales to remain steady&quot;
            &quot;VP &lt; (S &lt; (NP|WHNP=target $++ (VP &lt; TO)))&quot;,

            // This matches rare cases of misparses, such as &quot;What
            // disease causes cancer?&quot; where the &quot;causes&quot; does not get a
            // surrounding VP.  Hopefully it does so without overlapping
            // any other dependencies.
            &quot;SQ &lt; (/^(?:VB)/=verb !&lt; &quot; + copularWordRegex + &quot;) $-- WHNP !&lt; VP !&lt; (/^(?:VB)/ ! == =verb) &lt; (NP|WHNP=target [ [ !&lt;# (/^NN/ &lt; &quot; + timeWordRegex + &quot;) !$+ NP ] | $+ NP-TMP | $+ (NP &lt;# (/^NN/ &lt; &quot; + timeWordRegex + &quot;)) ] )&quot;,

            // The rule for Wh-questions
            // cdm Jul 2010: No longer require WHNP as first child of SBARQ below: often not because of adverbials, quotes, etc., and removing restriction does no harm
            // this next pattern used to assume no empty NPs. Corrected.
            // One could require the VP at the end of the &lt;+ to also be !&lt; (/^(?:VB|AUX)/ $. SBAR) . This would be right for complement SBAR, but often avoids good matches for adverbial SBAR.  Adding it kills 4 good matches for avoiding 2 wrong matches on sum of TB3-train and EWT
            &quot;SBARQ &lt; (WHNP=target !&lt; WRB !&lt;# (/^NN/ &lt; &quot; + timeWordRegex + &quot;)) &lt;+(SQ|SINV|S|VP) (VP !&lt; NP|TO !&lt; (S &lt; (VP &lt; TO)) !&lt; (/^(?:VB|AUX)/ &lt; &quot; + copularWordRegex + &quot; $++ (VP &lt; VBN|VBD)) !&lt; (PP &lt;: IN|TO) $-- (NP !&lt; /^-NONE-$/))&quot;,

            // matches direct object in relative clauses with relative pronoun &quot;I saw the book that you bought&quot;. Seems okay. If this is changed, also change the pattern for &quot;rel&quot;
            // TODO: this can occasionally produce incorrect dependencies, such as the sentence
            // &quot;with the way which his split-fingered fastball is behaving&quot;
            // eg take a tree where the verb doesn't have an object
            &quot;SBAR &lt; (WHNP=target !&lt; WRB) &lt; (S &lt; NP &lt; (VP !&lt; SBAR !&lt;+(VP) (PP &lt;- IN|TO) !&lt; (S &lt; (VP &lt; TO))))&quot;,

            // // matches direct object for long dependencies in relative clause without explicit relative pronouns
            // &quot;SBAR !&lt; (WHPP|WHNP|WHADVP) &lt; (S &lt; (@NP $++ (VP !&lt; (/^(?:VB|AUX)/ &lt; &quot; + copularWordRegex + &quot; !$+ VP)  !&lt;+(VP) (/^(?:VB|AUX)/ &lt; &quot; + copularWordRegex + &quot; $+ (VP &lt; VBN|VBD)) !&lt;+(VP) NP !&lt; SBAR !&lt;+(VP) (PP &lt;- IN|TO)))) !$-- CC $-- NP &gt; NP=target &quot; +
            //   // avoid conflicts with rcmod.  TODO: we could look for
            //   // empty nodes in this kind of structure and use that to
            //   // find dobj, tmod, advmod, etc.  won't help the parser,
            //   // of course, but will help when converting a treebank
            //   // which contains empties
            //   // Example: &quot;with the way his split-fingered fastball is behaving&quot;
            //   &quot;!($-- @NP|WHNP|NML &gt; @NP|WHNP &lt;: (S !&lt; (VP &lt; TO)))&quot;,

            // If there was an NP between the WHNP and the ADJP, we want
            // that NP to have the nsubj relation, and the WHNP is either
            // a dobj or a pobj instead.  For example, dobj(What, worth)
            // in &quot;What is UAL stock worth?&quot;
            &quot;SBARQ &lt; (WHNP=target $++ ((/^(?:VB|AUX)/ &lt; &quot; + copularWordRegex + &quot;) $++ (ADJP=adj !&lt; (PP !&lt; NP)) $++ (NP $++ =adj)))&quot;

            // Now allow $++ in main pattern above so don't need this.
            // &quot;SBAR !&lt; (WHPP|WHNP|WHADVP) &lt; (S &lt; (@NP $+ (ADVP $+ (VP !&lt; (/^(?:VB|AUX)/ &lt; &quot; + copularWordRegex + &quot; !$+ VP) !&lt;+(VP) (/^(?:VB|AUX)/ &lt; &quot; + copularWordRegex + &quot; $+ (VP &lt; VBN|VBD)) !&lt;+(VP) NP !&lt; SBAR !&lt;+(VP) (PP &lt;- IN|TO))))) !$-- CC $-- NP &gt; NP=target&quot;

            // Excluding BE doesn't allow cases of NP-PRD followed by NP-TMP or NP-LOC like &quot;These are Europeans next door.&quot;
            // Doc said: case with an iobj before dobj as two regular NPs. (This won't match if second one is explicitly NP-TMP.) But basic case covers this case. Does nothing.
            // &quot;VP &lt; (NP $+ (NP|WHNP=target !&lt; (/^NN/ &lt; &quot; + timeWordLotRegex + &quot;))) !&lt;(/^(?:VB|AUX)/ &lt; &quot; + copularWordRegex + &quot;)&quot;,  // this time one also included &quot;lot&quot;
            // Doc said: match &quot;give it next week&quot;.  CDM 2013: I think this was put in to handle parse errors where the 2 NPs of a ditransitive were grouped into 1. But it is in principle wrong, and including it seems to be a no-op on TB3 WSJ. So exclude for now.
            // &quot;VP &lt; (NP &lt; (NP $+ (/^(NP|WHNP)$/=target !&lt; (/^NN/ &lt; &quot; + timeWordLotRegex + &quot;))))!&lt; (/^(?:VB|AUX)/ &lt; &quot; + copularWordRegex + &quot;)&quot;,  // this time one also included &quot;lot&quot;

            // Doc said: matches direct object in relative clauses &quot;I saw the book that you said you bought&quot;. But it didn't seem to determine anything.
            // This was various attempts at handling a long distance dependency, but that doesn't work; now handled through rel mechanism.
            // &quot;SBAR !&lt; WHNP|WHADVP &lt; (S &lt; (@NP $++ (VP !$++ NP))) &gt; (VP &gt; (S &lt; NP $- WHNP=target))&quot;,
            // &quot;SBAR !&lt; WHNP|WHADVP|IN &lt; (S &lt; @NP &lt; (VP !&lt; (NP !&lt;&lt;# &quot; + timeWordRegex + &quot;))) &gt; (VP &gt; (S &lt; NP $- WHNP=target))&quot;,
            // &quot;S &lt; (@NP !&lt; /^-NONE-$/) &lt;+(VP) (VP !&lt; (@NP !&lt; /^-NONE-$/ &lt; (/^VB/ !&lt; &quot; + copularWordRegex + &quot;)) !&lt; CONJP|CC|SBAR) &gt; (@SBAR !&lt; @WHNP|WHADVP $- /^VB/ &gt;+(VP|S|SBAR) (S &lt; (@NP !&lt; /^-NONE-$/ !&lt;&lt;# &quot; + timeWordRegex + &quot;) $- (@WHNP=target !&lt; /^-NONE-$/ !&lt;# WRB)))&quot;,

            // we now don't match &quot;VBG &gt; PP $+ NP=target&quot;, since it seems better to CM to regard these quasi preposition uses (like &quot;including soya&quot;) as prepositions rather than verbs with objects -- that's certainly what the phrase structure at least suggests in the PTB.  They're now matched as pobj
    );


  /**
   * The &quot;indirect object&quot; grammatical relation.  The indirect
   * object of a VP is the noun phrase which is the (dative) object
   * of the verb; the indirect object of a clause is the indirect
   * object of the VP which is the predicate of that clause.
   * &lt;p/&gt;
   * Example:  &lt;br/&gt;
   * &quot;She gave me a raise&quot; &amp;rarr;
   * {@code iobj}(gave, me)
   */
<span class="fc" id="L528">  public static final GrammaticalRelation INDIRECT_OBJECT =</span>
    new GrammaticalRelation(Language.UniversalEnglish, &quot;iobj&quot;, &quot;indirect object&quot;,
        OBJECT, &quot;VP&quot;, tregexCompiler,
            &quot;VP &lt; (NP=target !&lt; /\\$/ !&lt;# (/^NN/ &lt; &quot; + timeWordRegex + &quot;) $+ (NP !&lt;# (/^NN/ &lt; &quot; + timeWordRegex + &quot;)))&quot;,
            // this next one was meant to fix common mistakes of our parser, but is perhaps too dangerous to keep
            // excluding selfRegex leaves out phrases such as &quot;I cooked dinner myself&quot;
            // excluding DT leaves out phrases such as &quot;My dog ate it all&quot;&quot;
            &quot;VP &lt; (NP=target &lt; (NP !&lt; /\\$/ $++ (NP !&lt;: (PRP &lt; &quot; + selfRegex + &quot;) !&lt;: DT !&lt; (/^NN/ &lt; &quot; + timeWordLotRegex + &quot;)) !$ CC|CONJP !$ /^,$/ !$++ /^:$/))&quot;);


  /**
   * The &quot;clausal complement&quot; grammatical relation.  A clausal complement of
   * a verb or adjective is a dependent clause with an internal subject which
   * functions like an object of the verb, or adjective.  Clausal complements
   * for nouns are limited to complement clauses with a subset of nouns
   * like &quot;fact&quot; or &quot;report&quot;.  We analyze them the same (parallel to the
   * analysis of this class as &quot;content clauses&quot; in Huddleston and Pullum 2002).
   * Clausal complements are usually finite (though there
   * are occasional exceptions including remnant English subjunctives, and we
   * also classify the complement of causative &quot;have&quot; (She had him arrested)
   * in this category.&lt;p&gt;
   * &lt;p/&gt;
   * Example: &lt;br/&gt;
   * &quot;He says that you like to swim&quot; &amp;rarr;
   * {@code ccomp}(says, like) &lt;br/&gt;
   * &quot;I am certain that he did it&quot; &amp;rarr;
   * {@code ccomp}(certain, did) &lt;br/&gt;
   * &quot;I admire the fact that you are honest&quot; &amp;rarr;
   * {@code ccomp}(fact, honest)
   */
<span class="fc" id="L558">  public static final GrammaticalRelation CLAUSAL_COMPLEMENT =</span>
    new GrammaticalRelation(Language.UniversalEnglish, &quot;ccomp&quot;, &quot;clausal complement&quot;,
        COMPLEMENT, &quot;VP|SINV|S|ADJP|ADVP|NP(?:-.*)?&quot;, tregexCompiler,
            // Weird case of verbs with direct S complement that is not an infinitive or participle
            // (&quot;I saw [him take the cake].&quot;, &quot;making [him go crazy]&quot;)
            &quot;VP &lt; (S=target &lt; (VP !&lt;, TO|VBG|VBN) !$-- NP)&quot;,
            // the canonical case of a SBAR[that] with an overt &quot;that&quot; or &quot;whether&quot;
            &quot;VP &lt; (SBAR=target &lt; (S &lt;+(S) VP) &lt;, (IN|DT &lt; /^(?i:that|whether)$/))&quot;,
            // Conjoined SBAR otherwise in the canonical case
            &quot;VP &lt; (SBAR=target &lt; (SBAR &lt; (S &lt;+(S) VP) &lt;, (IN|DT &lt; /^(?i:that|whether)$/)) &lt; CC|CONJP)&quot;,
            // This finds most ccomp SBAR[that] with omission of that, but only ones without dobj
            &quot;VP &lt; (SBAR=target &lt; (S &lt; VP) !$-- NP !&lt;, (IN|WHADVP) !&lt;2 (IN|WHADVP $- ADVP|RB))&quot;,
            // Find ccomp SBAR[that] after dobj for clear marker verbs
            &quot;VP &lt; (/^V/ &lt; &quot; + ccompObjVerbRegex + &quot;) &lt; (SBAR=target &lt; (S &lt; VP) $-- NP !&lt;, (IN|WHADVP) !&lt;2 (IN|WHADVP $- ADVP|RB))&quot;,
            &quot;VP &lt; (SBAR=target &lt; (S &lt; VP) !$-- NP &lt;, (WHADVP &lt; (WRB &lt; /^(?i:how)$/)))&quot;,
            &quot;VP &lt; @SBARQ=target&quot;,  // Direct question: She asked &quot;Who is in trouble&quot;
            &quot;VP &lt; (/^VB/ &lt; &quot; + haveRegex + &quot;) &lt; (S=target &lt; @NP &lt; VP)&quot;,
            // !$-- @SBAR|S handles cases where the answer to the question
            //   &quot;What do they ccompVerb?&quot;
            //   is already answered by a different node
            // the ccompObjVerbRegex/NP test distinguishes &quot;He told me why ...&quot;
            //   vs &quot;They know my order when ...&quot;
            &quot;VP &lt; (@SBAR=target !$-- @SBAR|S !$-- /^:$/ [ == @SBAR=sbar | &lt;# @SBAR=sbar ] ) &lt; (/^V/ &lt; &quot; + ccompVerbRegex + &quot;) [ &lt; (/^V/ &lt; &quot; + ccompObjVerbRegex + &quot;) | &lt; (=target !$-- NP) ] : (=sbar &lt; (WHADVP|WHNP &lt; (WRB !&lt; /^(?i:how)$/) !$-- /^(?!RB|ADVP).*$/) !&lt; (S &lt; (VP &lt; TO)))&quot;,
            // to find &quot;...&quot;, he said or &quot;...?&quot; he asked.
            // We eliminate conflicts with conj by looking for CC
            // Matching against &quot;!&lt; (VP &lt; TO|VBG|VBN)&quot; matches against vmod
            // &quot;!&lt; (VP &lt;1 (VP [ &lt;1 VBG|VBN | &lt;2 (VBG|VBN $-- ADVP) ])))&quot; also matches against vmod
            &quot;@S|SINV &lt; (@S|SBARQ=target $+ /^(,|\\.|'')$/ !$- /^(?:CC|CONJP|:)$/ !$- (/^(?:,)$/ $- CC|CONJP) !&lt; (VP &lt; TO|VBG|VBN) !&lt; (VP &lt;1 (VP [ &lt;1 VBG|VBN | &lt;2 (VBG|VBN $-- ADVP) ]))) !&lt; (@S !== =target $++ =target !$++ @CC|CONJP)&quot;,
            // ADVP is things like &quot;As long as they spend ...&quot;
            // &lt; WHNP captures phrases such as &quot;no matter what&quot;, &quot;no matter how&quot;, etc
            &quot;ADVP &lt; (SBAR=target [ &lt; WHNP | ( &lt; (IN &lt; /^(?i:as|that)/) &lt; (S &lt; (VP !&lt; TO))) ])&quot;,
            &quot;ADJP &lt; (SBAR=target !&lt; (IN &lt; as) &lt; S)&quot;, // ADJP is things like &quot;sure (that) he'll lose&quot; or for/to ones or object of comparison with than &quot;than we were led to expect&quot;; Leave aside as in &quot;as clever as we thought.
            // That ... he know
            &quot;S &lt;, (SBAR=target &lt;, (IN &lt; /^(?i:that|whether)$/) !$+ VP)&quot;,
            // JJ catches a couple of funny NPs with heads like &quot;enough&quot;
            // Note that we eliminate SBAR which also match an vmod pattern
            &quot;@NP &lt; JJ|NN|NNS &lt; (SBAR=target [ !&lt;(S &lt; (VP &lt; TO )) | !$-- NP|NN|NNP|NNS ] )&quot;);


  /**
   * An open clausal complement (&lt;i&gt;xcomp&lt;/i&gt;) of a VP or an ADJP is a clausal
   * complement without its own subject, whose reference is determined by an
   * external subject.  These complements are always non-finite.
   * The name &lt;i&gt;xcomp&lt;/i&gt; is borrowed from Lexical-Functional Grammar.
   * (Mainly &quot;TO-clause&quot; are recognized, but also some VBG like &quot;stop eating&quot;)
   * &lt;p/&gt;
   * &lt;p/&gt;
   * Examples: &lt;br/&gt;
   * &quot;I like to swim&quot; &amp;rarr;
   * {@code xcomp}(like, swim) &lt;br/&gt;
   * &quot;I am ready to leave&quot; &amp;rarr;
   * {@code xcomp}(ready, leave)
   */
<span class="fc" id="L611">  public static final GrammaticalRelation XCLAUSAL_COMPLEMENT =</span>
    new GrammaticalRelation(Language.UniversalEnglish, &quot;xcomp&quot;, &quot;xclausal complement&quot;,
        COMPLEMENT, &quot;VP|ADJP|SINV&quot;, tregexCompiler,
            //&quot;VP &lt; (S=target [ !$-- NP $-- (/^V/ &lt; &quot; + xcompNoObjVerbRegex + &quot;) | $-- (/^V/ &lt; &quot; + xcompVerbRegex + &quot;) ] !$- (NN &lt; order) &lt; (VP &lt; TO))&quot;,    // used to have !&gt; (VP &lt; (VB|AUX &lt; be))
            &quot;VP &lt; (S=target [ !$-- NP | $-- (/^V/ &lt; &quot; + xcompVerbRegex + &quot;) ] !$- (NN &lt; order) &lt; (VP &lt; TO))&quot;,    // used to have !&gt; (VP &lt; (VB|AUX &lt; be))
            &quot;ADJP &lt; (S=target &lt;, (VP &lt;, TO))&quot;,
            &quot;VP &lt; (S=target !$- (NN &lt; order) &lt; (NP $+ NP|ADJP))&quot;,
            // to find &quot;help sustain ...
            &quot;VP &lt;# (/^(?:VB|AUX)/ $+ (VP=target &lt; VB|VBG))&quot;,
            &quot;VP &lt; (SBAR=target &lt; (S !$- (NN &lt; order) &lt; (VP &lt; TO))) !&gt; (VP &lt; (VB|AUX &lt; be)) &quot;,
            &quot;VP &lt; (S=target !$- (NN &lt; order) &lt;: NP) &gt; VP&quot;,
            &quot;VP &lt; (S=target !&lt; VP)&quot;,
            &quot;VP &lt; (/^VB/ $+ (@S=target &lt; (@ADJP &lt; /^JJ/ ! $-- @NP|S))) $-- (/^VB/ &lt; &quot; + copularWordRegex + &quot; )&quot;,
            // stop eating
            // note that we eliminate parentheticals and clauses that could match a vmod
            // the clause !$-- VBG eliminates matches such as &quot;What are you wearing dancing tonight&quot;
            &quot;(VP &lt; (S=target &lt; (VP &lt; VBG ) !&lt; NP !$- (/^,$/ [$- @NP|VP | $- (@PP $-- @NP ) |$- (@ADVP $-- @NP)]) !$-- /^:$/ !$-- VBG))&quot;,
            // Detects xcomp(becoming, requirement) in &quot;Hand-holding is becoming an investment banking job requirement&quot;
            // Also, xcomp(becoming, problem) in &quot;Why is Dave becoming a problem?&quot;
            &quot;(VP $-- (/^(?:VB|AUX)/ &lt; &quot; + copularWordRegex + &quot;) &lt; (/^VB/ &lt; &quot; + clausalComplementRegex + &quot;) &lt; NP=target)&quot;,
            &quot;VP &lt; (/^(?:VB|AUX)/ &lt; &quot; + clausalComplementRegex + &quot;) &lt; (NP|WHNP=target [ [ !&lt;# (/^NN/ &lt; &quot; + timeWordRegex + &quot;) !$+ NP ] | $+ NP-TMP | $+ (NP &lt;# (/^NN/ &lt; &quot; + timeWordRegex + &quot;)) ] ) &quot; +
                // The next qualification eliminates parentheticals that
                // come after the actual dobj
                &quot; &lt;# (__ !$++ (NP $++ (/^[:]$/ $++ =target))) &quot;,
            // The old attr relation, used here to recover xcomp relations instead.
            &quot;VP=vp &lt; NP=target &lt;(/^(?:VB|AUX)/ &lt; &quot; + copularWordRegex + &quot; &gt;&gt;# =vp) !$ (NP &lt; EX)&quot;,
            // &quot;Such a great idea this was&quot; if &quot;was&quot; is the root, eg -makeCopulaHead
            &quot;SINV &lt;# (VP &lt; (/^(?:VB|AUX)/ &lt; &quot; + copularWordRegex + &quot;) $-- (NP $-- NP=target))&quot;,

            //Former acomp expression
            &quot;VP [ &lt; ADJP=target | ( &lt; (/^VB/ [ ( &lt; &quot; + clausalComplementRegex + &quot; $++ VP=target ) | $+ (@S=target &lt; (@ADJP &lt; /^JJ/ ! $-- @NP|S)) ] ) !$-- (/^VB/ &lt; &quot; + copularWordRegex + &quot; )) ]&quot;
        );


  /**
   * The RELATIVE grammatical relation is only here as a temporary
   * relation.  This tregex triggering indicates either a dobj or a
   * pobj should be here.  We figure this out in a post-processing
   * step by looking at the surrounding dependencies.
   */
<span class="fc" id="L651">  public static final GrammaticalRelation RELATIVE =</span>
    new GrammaticalRelation(Language.UniversalEnglish, &quot;rel&quot;, &quot;relative&quot;,
        COMPLEMENT, &quot;SBAR|SBARQ&quot;, tregexCompiler,
            &quot;SBAR &lt; (WHNP=target !&lt; WRB) &lt; (S &lt; NP &lt; (VP [ &lt; SBAR | &lt;+(VP) (PP &lt;- IN|TO) | &lt; (S &lt; (VP &lt; TO)) ] ))&quot;,

            // Rule for copular Wh-questions, e.g. &quot;What am I good at?&quot;
            &quot;SBARQ &lt; (WHNP=target !&lt; WRB !&lt;# (/^NN/ &lt; &quot; + timeWordRegex + &quot;)) &lt;+(SQ|SINV) (/^(?:VB|AUX)/ &lt; &quot; + copularWordRegex + &quot; !$++ VP)&quot;);


  /**
   * The PREPOSITION grammatical relation is only here as a temporary
   * relation. It matches prepositions in sentences such as
   * &quot;What is the esophagus used for?&quot; which are attached to the
   * nominal modifier in a post-processing step.
   */

<span class="fc" id="L667">  public static final GrammaticalRelation PREPOSITION =</span>
      new GrammaticalRelation(Language.UniversalEnglish, &quot;prep&quot;, &quot;preposition&quot;,
          COMPLEMENT, &quot;VP|ADJP&quot;, tregexCompiler,
              &quot;VP|ADJP &lt; (PP=target &lt;: IN|TO)&quot;);



  /**
   * The &quot;referent&quot; grammatical relation.  A
   * referent of the Wh-word of a NP is  the relative word introducing the relative clause modifying the NP.
   * &lt;p/&gt;
   * Example: &lt;br/&gt;
   * &quot;I saw the book which you bought&quot; &amp;rarr;
   * {@code ref}(book, which) &lt;br/&gt;
   * &quot;I saw the book the cover of which you designed&quot; &amp;rarr;
   * {@code ref}(book, which)
   */
<span class="fc" id="L684">  public static final GrammaticalRelation REFERENT =</span>
    new GrammaticalRelation(Language.UniversalEnglish, &quot;ref&quot;, &quot;referent&quot;, DEPENDENT);



  /**
   * The &quot;expletive&quot; grammatical relation.
   * This relation captures an existential there.
   * &lt;p/&gt;
   * &lt;p/&gt;
   * Example: &lt;br/&gt;
   * &quot;There is a statue in the corner&quot; &amp;rarr;
   * {@code expl}(is, there)
   */
<span class="fc" id="L698">  public static final GrammaticalRelation EXPLETIVE =</span>
    new GrammaticalRelation(Language.UniversalEnglish, &quot;expl&quot;, &quot;expletive&quot;,
        DEPENDENT, &quot;S|SQ|SINV&quot;, tregexCompiler,
            &quot;S|SQ|SINV &lt; (NP=target &lt;+(NP) EX)&quot;);


  /**
   * The &quot;modifier&quot; grammatical relation.  A modifier of a VP is
   * any constituent that serves to modify the meaning of the VP
   * (but is not an {@code ARGUMENT} of that
   * VP); a modifier of a clause is an modifier of the VP which is
   * the predicate of that clause.&lt;p&gt;
   * &lt;p/&gt;
   * Examples: &lt;br/&gt;
   * &quot;Last night, I swam in the pool&quot; &amp;rarr;
   * {@code mod}(swam, in the pool),
   * {@code mod}(swam, last night)
   */
<span class="fc" id="L716">  public static final GrammaticalRelation MODIFIER =</span>
    new GrammaticalRelation(Language.UniversalEnglish, &quot;mod&quot;, &quot;modifier&quot;, DEPENDENT);


  /**
   * The &quot;nominal modifier&quot; grammatical relation.  The nmod relation is
   * used for nominal modifiers of nouns or clausal predicates. {@code nmod}
   * is a noun functioning as a non-core (oblique) argument or adjunct.
   * In English, nmod is used for prepositional complements.
   * &lt;p/&gt;
   * (The preposition in turn may be modifying a noun, verb, etc.)
   * We here define cases of VBG quasi-prepositions like &quot;including&quot;,
   * &quot;concerning&quot;, etc. as instances of pobj (unlike the Penn Treebank).
   * &lt;p/&gt;
   * Example: &lt;br/&gt;
   * &quot;I sat on the chair&quot; &amp;rarr;
   * {@code nmod}(sat, chair)
   * &lt;p/&gt;
   * (The preposition can be called a FW for pace, versus, etc.  It can also
   * be called a CC - but we don't currently handle that and would need to
   * distinguish from conjoined PPs. Jan 2010 update: We now insist that the
   * NP must follow the preposition. This prevents a preceding NP measure
   * phrase being matched as a nmod.  We do allow a preposition tagged RB
   * followed by an NP pobj, as happens in the Penn Treebank for adverbial uses
   * of PP like &quot;up 19%&quot;)
   */
<span class="fc" id="L742">  public static final GrammaticalRelation NOMINAL_MODIFIER =</span>
    new GrammaticalRelation(Language.UniversalEnglish, &quot;nmod&quot;, &quot;nominal modifier&quot;,
        MODIFIER, &quot;.*&quot;, tregexCompiler,
            &quot;/^(?:(?:WH)?(?:NP|ADJP|ADVP|NX|NML)(?:-TMP|-ADV)?|VP|NAC|SQ|FRAG|PRN|X|RRC)$/ &lt; (WHPP|WHPP-TMP|PP|PP-TMP=target [&lt; @NP|WHNP|NML | &lt; (PP &lt; @NP|WHNP|NML)]) !&lt;- &quot; + ETC_PAT + &quot; !&lt;- &quot; + FW_ETC_PAT,
            &quot;/^(?:(?:WH)?(?:NP|ADJP|ADVP|NX|NML)(?:-TMP|-ADV)?|VP|NAC|SQ|FRAG|PRN|X|RRC)$/ &lt; (S=target &lt;: WHPP|WHPP-TMP|PP|PP-TMP)&quot;,
            // only allow a PP &lt; PP one if there is not a verb, or other pattern that matches acl/advcl under it.  Else acl/advcl
            &quot;WHPP|WHPP-TMP|WHPP-ADV|PP|PP-TMP|PP-ADV &lt; (WHPP|WHPP-TMP|WHPP-ADV|PP|PP-TMP|PP-ADV=target !$- IN|VBG|VBN|TO)&quot;,
            &quot;S|SINV &lt; (PP|PP-TMP=target !&lt; SBAR|S) &lt; VP|S&quot;,
            &quot;SBAR|SBARQ &lt; /^(?:WH)?PP/=target &lt; S|SQ&quot;,
            &quot;@NP &lt; (@UCP|PRN=target &lt;# @PP)&quot;,
            // to handle &quot;What weapon is Apollo most proficient with?&quot;
            &quot;SBARQ &lt; (WHNP=target $++ ((/^(?:VB|AUX)/ &lt; &quot; + copularWordRegex + &quot;) $++ (ADJP=adj &lt; (PP &lt;: IN)) $++ (NP $++ =adj)))&quot;,
            //to handle &quot;What is the esophagus used for&quot;? or &quot;What radio station did Paul Harvey work for?&quot;
            &quot;SBARQ &lt; (WHNP=target [$++ (VP &lt; (PP &lt;: IN)) | $++ (SQ &lt; (VP &lt; (PP &lt;: IN)))])&quot;);





  /**
   * The &quot;adverbial clause modifier&quot; grammatical relation. An adverbial
   * clause modifier is a clause which modifies a verb or other predicate
   * (adjective, etc.), as a modifier not as a core complement. This includes
   * things such as a temporal clause, consequence, conditional clause,
   * purpose clause, etc. The dependent must be clausal (or else it is an
   * {@code advmod}) and the dependent is the main predicate of the clause.
   * &lt;p/&gt;
   * Examples: &lt;br/&gt;
   * &quot;The accident happened as the night was falling&quot; &amp;rarr;
   * {@code advcl}(happened, falling) &lt;br/&gt;
   * &quot;If you know who did it, you should tell the teacher&quot; &amp;rarr;
   * {@code advcl}(tell, know)
   */
<span class="fc" id="L775">  public static final GrammaticalRelation ADV_CLAUSE_MODIFIER =</span>
    new GrammaticalRelation(Language.UniversalEnglish, &quot;advcl&quot;, &quot;adverbial clause modifier&quot;,
        MODIFIER, &quot;VP|S|SQ|SINV|SBARQ|NP|ADVP|ADJP&quot;, tregexCompiler,
            &quot;VP &lt; (@SBAR=target &lt;= (@SBAR [ &lt; (IN|MWE !&lt; /^(?i:that|whether)$/) | &lt;: (SINV &lt;1 /^(?:VB|MD|AUX)/) | &lt; (RB|IN &lt; so|now) &lt; (IN &lt; that) | &lt;1 (ADVP &lt; (RB &lt; now)) &lt;2 (IN &lt; that) ] ))&quot;,
            &quot;S|SQ|SINV &lt; (SBAR|SBAR-TMP=target &lt;, (IN|MWE !&lt; /^(?i:that|whether)$/ !$+ (NN &lt; order)) !$-- /^(?!CC|CONJP|``|,|INTJ|PP(-.*)?).*$/ !$+ VP)&quot;,
            // to get &quot;rather than&quot;
            //&quot;S|SQ|SINV &lt; (SBAR|SBAR-TMP=target &lt;2 (IN|MWE !&lt; /^(?i:that|whether)$/ !$+ (NN &lt; order)) !$-- /^(?!CC|CONJP|``|,|INTJ|PP(-.*)?$).*$/)&quot;,
            // this one might just be better, but at any rate license one with quotation marks or a conjunction beforehand
            &quot;S|SQ|SINV &lt; (SBAR|SBAR-TMP=target &lt;, (IN|MWE !&lt; /^(?i:that|whether)$/ !$+ (NN &lt; order)) !$+ @VP $+ /^,$/ $++ @NP)&quot;,
            // the last part should probably only be @SQ, but this captures some strays at no cost
            &quot;SBARQ &lt; (SBAR|SBAR-TMP|SBAR-ADV=target &lt;, (IN|MWE !&lt; /^(?i:that|whether)$/ !$+ (NN &lt; order)) $+ /^,$/ $++ @SQ|S|SBARQ)&quot;,
            // added the (S &lt; (VP &lt;TO)) part so that &quot;I tell them how to do so&quot; doesn't get a wrong advcl
            // note that we allow adverb phrases to come before the WHADVP, which allows for phrases such as &quot;even when&quot;
            // &quot;:&quot; indicates something that should be a parataxis
            // in cases where there are two SBARs conjoined, we're happy
            // to use the head SBAR as a candidate for this relation
            &quot;S|SQ &lt; (@SBAR=target [ == @SBAR=sbar | &lt;# @SBAR=sbar ] ): (=sbar &lt; (WHADVP|WHNP &lt; (WRB !&lt; /^(?i:how)$/) !$-- /^(?!RB|ADVP).*$/) !&lt; (S &lt; (VP &lt; TO)) !$-- /^:$/)&quot;,
            &quot;VP &lt; (@SBAR=target !$-- /^:$/ [ == @SBAR=sbar | &lt;# @SBAR=sbar ] ) [ !&lt; (/^V/ &lt; &quot; + ccompVerbRegex + &quot;) | &lt; (=target $-- @SBAR|S) | ( !&lt; (/^V/ &lt; &quot; + ccompObjVerbRegex + &quot;) &lt; (=target $-- NP)) ] : (=sbar &lt; (WHADVP|WHNP &lt; (WRB !&lt; /^(?i:how)$/) !$-- /^(?!RB|ADVP).*$/) !&lt; (S &lt; (VP &lt; TO)))&quot;,
            // &quot;S|SQ &lt; (PP=target &lt;, RB &lt; @S)&quot;, // caught as prep and pcomp.
            &quot;@S &lt; (@SBAR=target $++ @NP $++ @VP)&quot;,  // fronted adverbial clause
            &quot;@S &lt; (@S=target &lt; (VP &lt; TO) $+ (/^,$/ $++ @NP))&quot;, // part of former purpcl: This is fronted infinitives: &quot;To find out why, we went to ...&quot;
            // &quot;VP &gt; (VP &lt; (VB|AUX &lt; be)) &lt; (S=target !$- /^,$/ &lt; (VP &lt; TO|VBG) !$-- NP)&quot;, // part of former purpcl [cdm 2010: this pattern was added by me in 2006, but it is just bad!]

            // // matches direct object for long dependencies in relative clause without explicit relative pronouns
            // &quot;SBAR !&lt; (WHPP|WHNP|WHADVP) &lt; (S &lt; (@NP $++ (VP !&lt; (/^(?:VB|AUX)/ &lt; &quot; + copularWordRegex + &quot; !$+ VP)  !&lt;+(VP) (/^(?:VB|AUX)/ &lt; &quot; + copularWordRegex + &quot; $+ (VP &lt; VBN|VBD)) !&lt;+(VP) NP !&lt; SBAR !&lt;+(VP) (PP &lt;- IN|TO)))) !$-- CC $-- NP &gt; NP=target &quot; +
            //   // avoid conflicts with rcmod.  TODO: we could look for
            //   // empty nodes in this kind of structure and use that to
            //   // find dobj, tmod, advmod, etc.  won't help the parser,
            //   // of course, but will help when converting a treebank
            //   // which contains empties
            //   // Example: &quot;with the way his split-fingered fastball is behaving&quot;
            //   &quot;!($-- @NP|WHNP|NML &gt; @NP|WHNP &lt;: (S !&lt; (VP &lt; TO)))&quot;,
            &quot;NP &lt; (NP $++ (SBAR=target &lt; (IN|MWE &lt; /^(?i:than)$/) !&lt; (WHPP|WHNP|WHADVP) &lt; (S &lt; (@NP $++ (VP !&lt; (/^(?:VB|AUX)/ &lt; &quot; + copularWordRegex + &quot; !$+ VP)  !&lt;+(VP) (/^(?:VB|AUX)/ &lt; &quot; + copularWordRegex + &quot; $+ (VP &lt; VBN|VBD)) !&lt;+(VP) NP !&lt; SBAR !&lt;+(VP) (PP &lt;- IN|TO|MWE)))) !&lt;: (S !&lt; (VP &lt; TO))) !$++ (CC $++ =target))&quot;,
            // this is for comparative or as ... as complements: sold more quickly [than they had expected]
            // available as long [as they install a crash barrier]
            &quot;ADVP &lt; ADVP &lt; SBAR=target&quot;,

            //moved from vmod

            // to get &quot;John, knowing ..., announced &quot;
            // allowing both VP=verb and VP &lt;1 VP=verb catches
            // conjunctions of two VP clauses
            &quot;S|SINV &lt; (S=target (&lt; VP=verb | &lt; (VP &lt;1 VP=verb)) [ $- (/^,$/ [ $- @NP | $- (@PP $ @NP) ] ) | $+ (/^,$/ $+ @NP) ] ) : (=verb [ &lt;1 VBG|VBN | &lt;2 (VBG|VBN $-- ADVP) ])&quot;,
            &quot;(VP &lt; (@S=target &lt; (VP [ &lt;1 VBG|VBN | &lt;2 (VBG|VBN $-- ADVP) ]) $- (/^,$/ [$- @NP|VP | $- (@PP $-- @NP ) |$- (@ADVP $-- @NP)])))&quot;,
            // What are you wearing dancing tonight?
            &quot;(VP &lt; (S=target &lt; (VP &lt; VBG) $-- VBG=ing !$-- (/^[:]$/ $-- =ing)))&quot;,
            // We could use something like this keying off -ADV annotation, but not yet operational, as we don't keep S-ADV, only NP-ADV
            // &quot;VP &lt; (/^S-ADV$/=target &lt; (VP &lt;, VBG|VBN) )&quot;,
            // they wrote asking the SEC to ...
            &quot;VP &lt; (S=target $-- NP &lt; (VP &lt; TO) !$-- (/^V/ &lt; &quot; + xcompVerbRegex + &quot;) )&quot;,
            //&quot;VP &lt; (S=target &lt; (VP &lt; TO) !$-- (/^V/ &lt; &quot; + xcompNoObjVerbRegex + &quot;) )&quot;,

            &quot;SBARQ &lt; WHNP &lt; (S=target &lt; (VP &lt;1 TO))&quot;,

            //former pcomp
            &quot;/^(?:(?:WH)?(?:ADJP|ADVP)(?:-TMP|-ADV)?|VP|SQ|FRAG|PRN|X|RRC|S)$/ &lt; (WHPP|WHPP-TMP|PP|PP-TMP=target !&lt; @NP|WHNP|NML !$- (@CC|CONJP $- __) !&lt;: IN|TO !&lt; @CC|CONJP &lt; /^((?!(PP|IN)).)*$/) !&lt;- &quot; + ETC_PAT + &quot; !&lt;- &quot; + FW_ETC_PAT,
            &quot;VP|ADJP &lt; /^PP(?:-TMP|-ADV)?$/=target &lt; (@PP &lt; @SBAR|S $++ CONJP|CC)&quot;);


  /**
   * The &quot;marker&quot; grammatical relation.  A marker is the word introducing a finite clause subordinate to another clause.
   * For a complement clause, this will typically be &quot;that&quot; or &quot;whether&quot;.
   * For an adverbial clause, the marker is typically a preposition like &quot;while&quot; or &quot;although&quot;.
   * &lt;p/&gt;
   * Example: &lt;br/&gt;
   * &quot;U.S. forces have been engaged in intense fighting after insurgents launched simultaneous attacks&quot; &amp;rarr;
   * {@code mark}(launched, after)
   */
<span class="fc" id="L843">  public static final GrammaticalRelation MARKER =</span>
    new GrammaticalRelation(Language.UniversalEnglish, &quot;mark&quot;, &quot;marker&quot;,
        MODIFIER, &quot;SBAR(?:-TMP)?|VP|PP(?:-TMP|-ADV)?&quot;, tregexCompiler,
            //infinitival to
            &quot;VP &lt; VP &lt; (TO=target)&quot;,
            &quot;SBAR|SBAR-TMP &lt; (IN|DT|MWE=target $++ S|FRAG)&quot;,
            &quot;SBAR &lt; (IN|DT=target &lt; that|whether) [ $-- /^(?:VB|AUX)/ | $- NP|NN|NNS | &gt; ADJP|PP | &gt; (@NP|UCP|SBAR &lt; CC|CONJP $-- /^(?:VB|AUX)/) ]&quot;,
            &quot;/^PP(?:-TMP|-ADV)?$/ &lt; (IN|TO|MWE|PCONJP|VBN|JJ=target $+ @SBAR|S)&quot;);


  /**
   * The &quot;adjectival modifier&quot; grammatical relation.  An adjectival
   * modifier of an NP is any adjectival phrase that serves to modify
   * the meaning of the NP.&lt;p&gt;
   * &lt;p/&gt;
   * Example: &lt;br/&gt;
   * &quot;Sam eats red meat&quot; &amp;rarr;
   * {@code amod}(meat, red) &lt;p/&gt;
   * The relation amod is also used for multiword country adjectives, despite their
   * questionable treebank representation.
   * &lt;p/&gt;
   * Example: &lt;br/&gt;
   * &quot;the West German economy&quot; &amp;rarr;
   * {@code amod}(German, West),
   * {@code amod}(economy, German)
   */
<span class="fc" id="L869">  public static final GrammaticalRelation ADJECTIVAL_MODIFIER =</span>
    new GrammaticalRelation(Language.UniversalEnglish, &quot;amod&quot;, &quot;adjectival modifier&quot;,
        MODIFIER, &quot;NP(?:-TMP|-ADV)?|NX|NML|NAC|WHNP|ADJP|INTJ&quot;, tregexCompiler,
            &quot;/^(?:NP(?:-TMP|-ADV)?|NX|NML|NAC|WHNP|INTJ)$/ &lt; (ADJP|WHADJP|JJ|JJR|JJS|JJP|VBN|VBG|VBD|IN=target !&lt; (QP !&lt; /^[$]$/) !$- CC)&quot;,
            // IN above is needed for &quot;next&quot; in &quot;next week&quot; etc., which is often tagged IN.
            &quot;ADJP !&lt; CC|CONJP &lt; (JJ|NNP $ JJ|NNP=target)&quot;,
            // Cover the case of &quot;John, 34, works at Stanford&quot; - similar to an expression for appos
            &quot;WHNP|WHNP-TMP|WHNP-ADV|NP|NP-TMP|NP-ADV &lt; (NP=target &lt;: CD $- /^,$/ $-- /^(?:WH)?NP/ !$ CC|CONJP)&quot;);


  /**
   * The &quot;numeric modifier&quot; grammatical relation.  A numeric
   * modifier of an NP is any number phrase that serves to modify
   * the meaning of the NP.&lt;p&gt;
   * &lt;p/&gt;
   * Example: &lt;br/&gt;
   * &quot;Sam eats 3 sheep&quot; &amp;rarr;
   * {@code nummod}(sheep, 3)
   */
<span class="fc" id="L888">  public static final GrammaticalRelation NUMERIC_MODIFIER =</span>
    new GrammaticalRelation(Language.UniversalEnglish, &quot;nummod&quot;, &quot;numeric modifier&quot;,
        MODIFIER, &quot;(?:WH)?NP(?:-TMP|-ADV)?|NML|NX|ADJP|WHADJP|QP&quot;, tregexCompiler,
            &quot;/^(?:WH)?(?:NP|NX|NML)(?:-TMP|-ADV)?$/ &lt; (CD|QP=target !$- CC)&quot;,
            // $ is so phrases such as &quot;$ 100 million buyout&quot; get amod(buyout, $)
            &quot;/^(?:WH)?(?:NP|NX|NML)(?:-TMP|-ADV)?$/ &lt; (ADJP=target &lt;: (QP !&lt; /^[$]$/))&quot;,
            // Phrases such as $ 100 million get converted from (QP ($ $) (CD 100) (CD million)) to
            // (QP ($ $) (QP (CD 100) (CD million))).  This next tregex covers those phrases.
            // Note that the earlier tregexes are usually enough to cover those phrases, such as when
            // the QP is by itself in an ADJP or NP, but sometimes it can have other siblings such
            // as in the phrase &quot;$ 100 million or more&quot;.  In that case, this next expression is needed.
            &quot;QP &lt; QP=target &lt; /^[$]$/&quot;);



  /**
   * The &quot;compound modifier&quot; grammatical relation.  A compound
   * modifier of an NP is any noun that serves to modify the head noun.
   * Note that this has all nouns modify the rightmost a la Penn headship
   * rules.  There is no intelligent noun compound analysis.
   * &lt;p/&gt;
   * We eliminate nouns that are detected as part of a POS, since that
   * will turn into the dependencies denoting possession instead.
   * Note we have to include (VBZ &amp;lt; /^\'s$/) as part of the POS
   * elimination, since quite a lot of text such as
   * &quot;yesterday's widely published sequester&quot; was misannotated as a
   * VBZ instead of a POS.  TODO: remove that if a revised PTB is ever
   * released.
   * &lt;p/&gt;
   * Example: &lt;br/&gt;
   * &quot;Oil price futures&quot; &amp;rarr;
   * {@code compound}(futures, oil),
   * {@code compound}(futures, price) &lt;p/&gt;
   *
   * Numbers consisting of multiple words are also treated as compounds.
   * &lt;p/&gt;
   * Example: &lt;br/&gt;
   * &quot;I have four thousand sheep&quot; &amp;rarr;
   * {@code compound}(thousand, four) &lt;p/&gt;
   *
   */
<span class="fc" id="L929">  public static final GrammaticalRelation COMPOUND_MODIFIER =</span>
    new GrammaticalRelation(Language.UniversalEnglish, &quot;compound&quot;, &quot;compound modifier&quot;,
        MODIFIER, &quot;(?:WH)?(?:NP|NX|NAC|NML|ADVP|ADJP|QP)(?:-TMP|-ADV)?&quot;, tregexCompiler,
            &quot;/^(?:WH)?(?:NP|NX|NAC|NML)(?:-TMP|-ADV)?$/ &lt; (NP|NML|NN|NNS|NNP|NNPS|FW|AFX=target $++ NN|NNS|NNP|NNPS|FW|CD=sister !&lt;&lt;- POS !&lt;&lt;- (VBZ &lt; /^\'s$/) !$- /^,$/ !$++ (POS $++ =sister))&quot;,
            &quot;/^(?:WH)?(?:NP|NX|NAC|NML)(?:-TMP|-ADV)?$/ &lt; JJ|JJR|JJS=sister &lt; (NP|NML|NN|NNS|NNP|NNPS|FW=target !&lt;&lt;- POS !&lt;&lt;- (VBZ &lt; /^\'s$/) $+ =sister) &lt;# NN|NNS|NNP|NNPS !&lt;&lt;- POS !&lt;&lt;- (VBZ &lt; /^\'s$/) &quot;,
            &quot;QP|ADJP &lt; (/^(?:CD|$|#)$/=target !$- CC)&quot;, //number relation in original SD
            // in vitro, in vivo, etc., in Genia
            // matches against &quot;etc etc&quot;
            &quot;ADJP|ADVP &lt; (FW [ $- (FW=target !&lt; /^(?i:etc)$/) | $- (IN=target &lt; in|In) ] )&quot;);


  /**
   * The &quot;name&quot; relation. This relation is used for proper
   * nouns constituted of multiple nominal elements.  Words joined by name should all be part of a
   * minimal noun phrase; otherwise regular syntactic relations should be used.
   * In general, names are annotated in a flat, head-initial structure, in which all words in the name
   * modify the first one using the {@code name} label.
   * &lt;p/&gt;
   *
   * The distinction between {@code compound} and {@code name} can only be made on the basis of NER tags.
   * For this reason, we use the {@code compound} relation for all flat NPs and replace it with the {@code name}
   * relation during post-processing.
   * &lt;p/&gt;
   * See also {@link UniversalEnglishGrammaticalStructure#processNames(SemanticGraph)}.
   * &lt;p/&gt;
   * Example: &lt;br/&gt;
   * &quot;Hillary Rodham Clinton&quot; &amp;rarr;
   * {@code name}(Hillary, Rodham),
   * {@code name}(Hillary, Clinton)&lt;p/&gt;
   */
<span class="fc" id="L959">  public static final GrammaticalRelation NAME_MODIFIER =</span>
      new GrammaticalRelation(Language.UniversalEnglish, &quot;name&quot;, &quot;name&quot;, MODIFIER);

  /*
   * There used to be a relation &quot;abbrev&quot; for when abbreviations were defined in brackets after a noun
   * phrase, like &quot;the Australian Broadcasting Corporation (ABC)&quot;, but it has now been disbanded, and
   * subsumed under appos.
   */

  /**
   * The &quot;appositional modifier&quot; grammatical relation.  An appositional
   * modifier of an NP is an NP that serves to modify
   * the meaning of the NP.  It includes parenthesized examples, as well as defining abbreviations.
   * &lt;p/&gt;
   * Examples: &lt;br/&gt;
   * &quot;Sam, my brother, eats red meat&quot; &amp;rarr;
   * {@code appos}(Sam, brother) &lt;br/&gt;
   * &quot;Bill (John's cousin)&quot; &amp;rarr; {@code appos}(Bill, cousin).
   *
   * &quot;The Australian Broadcasting Corporation (ABC)&quot; &amp;rarr;
   *  {@code appos}(Corporation, ABC)
   */
<span class="fc" id="L981">  public static final GrammaticalRelation APPOSITIONAL_MODIFIER =</span>
    new GrammaticalRelation(Language.UniversalEnglish, &quot;appos&quot;, &quot;appositional modifier&quot;,
        MODIFIER, &quot;(?:WH)?NP(?:-TMP|-ADV)?|FRAG&quot;, tregexCompiler,
            &quot;WHNP|WHNP-TMP|WHNP-ADV|NP|NP-TMP|NP-ADV|FRAG &lt; (NP=target !&lt;: CD $- /^,$/ $-- /^(?:WH)?NP/) !&lt; CC|CONJP !&lt; &quot; + FW_ETC_PAT + &quot; !&lt; &quot; + ETC_PAT,
            &quot;WHNP|WHNP-TMP|WHNP-ADV|NP|NP-TMP|NP-ADV|FRAG &lt; (PRN=target &lt; (NP &lt; /^(?:NN|CD)/ $-- /^-LRB-$/ $+ /^-RRB-$/))&quot;,
            // NP-ADV is a npadvmod, NP-TMP is a tmod
            &quot;@WHNP|NP &lt; (NP=target !&lt;: CD &lt;, /^-LRB-$/ &lt;` /^-RRB-$/ $-- /^(?:WH)?NP/ !$ CC|CONJP)&quot;,
            // TODO: next pattern with NNP doesn't work because leftmost NNP is deemed head in a
            // structure like (NP (NNP Norway) (, ,) (NNP Verdens_Gang) (, ,))
            &quot;NP|NP-TMP|NP-ADV &lt; (NNP $+ (/^,$/ $+ NNP=target)) !&lt; CC|CONJP !&lt; &quot; + FW_ETC_PAT + &quot; !&lt; &quot; + ETC_PAT,
            // find abbreviations
            // for biomedical English, the former NNP heuristic really doesn't work, because they use NN for all chemical entities
            // while not unfoolable, this version produces less false positives and more true positives.
            &quot;WHNP|WHNP-TMP|WHNP-ADV|NP|NP-TMP|NP-ADV &lt; (PRN=target &lt;, /^-LRB-$/ &lt;- /^-RRB-$/ !&lt;&lt; /^(?:POS|(?:WP|PRP)\\$|[,$#]|CC|RB|CD)$/ &lt;+(NP) (NNP|NN &lt; /^(?:[A-Z]\\.?){2,}/) )&quot;,
            // Handles cases such as &quot;(NP (Her daughter) Jordan)&quot;
            &quot;WHNP|WHNP-TMP|WHNP-ADV|NP|NP-TMP|NP-ADV &lt; (NP=target &lt;: NNP $- (/^(?:WH)?NP/ !&lt; POS)) !&lt; CC|CONJP !&lt; &quot; + FW_ETC_PAT + &quot; !&lt; &quot; + ETC_PAT,
            // Handle cases in the Web Treebank such as &quot;Subject: ....&quot;
            &quot;FRAG|NP &lt; (NP $+ (/:/ $+ @SQ|S=target) &lt;: NN|NNS)&quot;);


  /**
   * The &quot;discourse element&quot; grammatical relation. This is used for interjections and
   * other discourse particles and elements (which are not clearly linked to the structure
   * of the sentence, except in an expressive way). We generally follow the
   * guidelines of what the Penn Treebanks count as an INTJ.  They
   * define this to include: interjections (oh, uh-huh, Welcome), fillers (um, ah),
   * and discourse markers (well, like, actually, but not: you know).
   * We also use it for emoticons.
   */
<span class="fc" id="L1010">   public static final GrammaticalRelation DISCOURSE_ELEMENT =</span>
    new GrammaticalRelation(Language.UniversalEnglish, &quot;discourse&quot;, &quot;discourse element&quot;,
        MODIFIER, &quot;.*&quot;, tregexCompiler,
            &quot;__ &lt; (NFP=target [ &lt; &quot; + WESTERN_SMILEY + &quot; | &lt; &quot; + ASIAN_SMILEY + &quot; ] )&quot;,
            &quot;__ [ &lt; INTJ=target | &lt; (PRN=target &lt;1 /^(?:,|-LRB-)$/ &lt;2 INTJ [ !&lt;3 __ | &lt;3 /^(?:,|-RRB-)$/ ] ) ]&quot;);


  /**
   * The &quot;clausal modifier of noun&quot; relation. {@code acl} is used for
   * finite and non-finite clauses that modify a noun. Note that in
   * English relative clauses get assigned a specific relation
   * &lt;code&gt;acl:relcl&lt;/code&gt;, a subtype of {@code acl}.
   * &lt;p/&gt;
   * Examples: &lt;br/&gt;
   * &quot;the issues as he sees them&quot; &amp;rarr;
   * {@code acl}(issues, sees) &lt;br/&gt;
   */
<span class="fc" id="L1027">  public static final GrammaticalRelation CLAUSAL_MODIFIER =</span>
      new GrammaticalRelation(Language.UniversalEnglish, &quot;acl&quot;, &quot;clausal modifier of noun&quot;,
          MODIFIER, &quot;WHNP|WHNP-TMP|WHNP-ADV|NP(?:-[A-Z]+)?|NML|NX&quot;, tregexCompiler,
          &quot;WHNP|WHNP-TMP|WHNP-ADV|NP|NP-TMP|NP-ADV|NML|NX &lt; (VP=target &lt; VBG|VBN|VBD $-- @NP|NML|NX)&quot;,  // also allow VBD since it quite often occurs in treebank errors and parse errors
          // to get &quot;MBUSA, headquartered ...&quot;
          // Allows an adverb to come before the participle
          &quot;WHNP|WHNP-TMP|WHNP-ADV|NP|NP-TMP|NP-ADV|NML|NX &lt; (/^,$/ $+ (VP=target [ &lt;1 VBG|VBN | &lt;2 (VBG|VBN $-- ADVP) ]))&quot;,

          //former pcomp
          &quot;/^(?:(?:WH)?(?:NP|NX|NML)(?:-TMP|-ADV)?)$/ &lt; (WHPP|WHPP-TMP|PP|PP-TMP=target !&lt; @NP|WHNP|NML !$- (@CC|CONJP $- __) &lt; /^((?!(PP|CC|CONJP|,)).)*$/  !&lt; (@PP &lt;1 IN|RB|MWE|PCONJP|VBN|JJ &lt;2 @NP))  !&lt;- &quot; + ETC_PAT + &quot; !&lt;- &quot; + FW_ETC_PAT,


          &quot;/^NP(?:-[A-Z]+)?$/ &lt; (S=target &lt; (VP &lt; TO) $-- NP|NN|NNP|NNS)&quot;,
          &quot;/^NP(?:-[A-Z]+)?$/ &lt; (SBAR=target &lt; (S &lt; (VP &lt; TO)) $-- NP|NN|NNP|NNS)&quot;);

  /**
   * The &quot;relative clause modifier&quot; grammatical relation.  A relative clause
   * modifier of an NP is a relative clause modifying the NP.  The link
   * points from the head noun of the NP to the head of the relative clause,
   * normally a verb.
   * &lt;p/&gt;
   * &lt;p/&gt;
   * Examples: &lt;br/&gt;
   * &quot;I saw the man you love&quot; &amp;rarr;
   * {@code relcl}(man, love)  &lt;br/&gt;
   * &quot;I saw the book which you bought&quot; &amp;rarr;
   * {@code relcl}(book, bought)
   */
<span class="fc" id="L1055">  public static final GrammaticalRelation RELATIVE_CLAUSE_MODIFIER =</span>
    new GrammaticalRelation(Language.UniversalEnglish, &quot;acl:relcl&quot;, &quot;relative clause modifier&quot;,
            CLAUSAL_MODIFIER, &quot;(?:WH)?(?:NP|NML|ADVP)(?:-.*)?&quot;, tregexCompiler,
            &quot;@NP|WHNP|NML=np $++ (SBAR=target [ &lt;+(SBAR) WHPP|WHNP | &lt;: (S !&lt; (VP &lt; TO)) ]) !$-- @NP|WHNP|NML !$++ &quot; + ETC_PAT + &quot; !$++ &quot; + FW_ETC_PAT + &quot; &gt; @NP|WHNP : (=np !$++ (CC|CONJP $++ =target))&quot;,
            &quot;NP|NML $++ (SBAR=target &lt; (WHADVP &lt; (WRB &lt;/^(?i:where|why|when)/))) !$-- NP|NML !$++ &quot; + ETC_PAT + &quot; !$++ &quot; + FW_ETC_PAT + &quot; &gt; @NP&quot;,
            // for case of relative clauses with no relativizer
            // (it doesn't distinguish whether actually gapped).
            &quot;@NP|WHNP &lt; RRC=target &lt;# NP|WHNP|NML|DT|S&quot;,
            &quot;@ADVP &lt; (@ADVP &lt; (RB &lt; /where$/)) &lt; @SBAR=target&quot;,
            &quot;NP &lt; (NP $++ (SBAR=target !&lt; (IN &lt; /^(?i:than|that|whether)$/) !&lt; (WHPP|WHNP|WHADVP) &lt; (S &lt; (@NP $++ (VP !&lt; (/^(?:VB|AUX)/ &lt; &quot; + copularWordRegex + &quot; !$+ VP)  !&lt;+(VP) (/^(?:VB|AUX)/ &lt; &quot; + copularWordRegex + &quot; $+ (VP &lt; VBN|VBD)) !&lt;+(VP) NP !&lt; SBAR !&lt;+(VP) (PP &lt;- IN|TO)))) !&lt;: (S !&lt; (VP &lt; TO))) !$++ (CC $++ =target))&quot;);


  /**
   * The &quot;adverbial modifier&quot; grammatical relation.  An adverbial
   * modifier of a word is a (non-clausal) RB or ADVP that serves to modify
   * the meaning of the word.&lt;p&gt;
   * &lt;p/&gt;
   * Examples: &lt;br/&gt;
   * &quot;genetically modified food&quot; &amp;rarr;
   * {@code advmod}(modified, genetically) &lt;br/&gt;
   * &quot;less often&quot; &amp;rarr;
   * {@code advmod}(often, less)
   */
<span class="fc" id="L1078">  public static final GrammaticalRelation ADVERBIAL_MODIFIER =</span>
    new GrammaticalRelation(Language.UniversalEnglish, &quot;advmod&quot;, &quot;adverbial modifier&quot;,
        MODIFIER,
        &quot;VP|ADJP|WHADJP|ADVP|WHADVP|S|SBAR|SINV|SQ|SBARQ|XS|(?:WH)?(?:PP|NP)(?:-TMP|-ADV)?|RRC|CONJP|JJP|QP&quot;, tregexCompiler,
            //last term is to exclude &quot;at least/most...&quot;
            &quot;/^(?:VP|ADJP|JJP|WHADJP|SQ?|SBARQ?|SINV|XS|RRC|(?:WH)?NP(?:-TMP|-ADV)?)$/ &lt; (RB|RBR|RBS|WRB|ADVP|WHADVP=target !&lt; &quot; + NOT_PAT + &quot; !&lt; &quot; + ETC_PAT + &quot; [!&lt;+(/ADVP/) (@ADVP &lt; (IN &lt; /(?i:at)/)) |  !&lt;+(/ADVP/) (@ADVP &lt; NP)] )&quot;,
            &quot;QP &lt; IN|RB|RBR|RBS|PDT|DT|JJ|JJR|JJS|XS=target&quot;, //quantmod relation in original SD
            &quot;QP &lt; (MWE=target &lt; (JJR|RBR|IN &lt; /^(?i)(more|less)$/) &lt; (IN &lt; /^(?i)than$/))&quot;, //more than / less than
            // avoids adverb conjunctions matching as advmod; added JJ to catch How long
            // &quot;!&lt; no&quot; so we can get neg instead for &quot;no foo&quot; when no is tagged as RB
            // we allow CC|CONJP as long as it is not between the target and the head
            // TODO: perhaps remove that last clause if we transform
            // more and more, less and less, etc.
            &quot;ADVP|WHADVP &lt; (RB|RBR|RBS|WRB|ADVP|WHADVP|JJ=target !&lt; &quot; + NOT_PAT + &quot; !&lt; /^(?i:no)$/ !&lt; &quot; + ETC_PAT + &quot;) [ !&lt; /^CC|CONJP$/ | ( &lt;#__=head !&lt; (/^CC|CONJP$/ [ ($++ =head $-- =target) | ($-- =head $++ =target) ])) ]&quot;,
            //this one gets &quot;at least&quot; advmod(at, least) or &quot;fewer than&quot; advmod(than, fewer)
            &quot;SBAR &lt; (WHNP=target &lt; WRB)&quot;, &quot;SBARQ &lt;, WHADVP=target&quot;, &quot;XS &lt; JJ=target&quot;,
            // for PP, only ones before head, or after NP, since others afterwards are pcomp
            &quot;/(?:WH)?PP(?:-TMP|-ADV)?$/ &lt;# (__ $-- (RB|RBR|RBS|WRB|ADVP|WHADVP=target !&lt; &quot; + NOT_PAT + &quot; !&lt; &quot; + ETC_PAT + &quot;))&quot;,
            &quot;/(?:WH)?PP(?:-TMP|-ADV)?$/ &lt; @NP|WHNP &lt; (RB|RBR|RBS|WRB|ADVP|WHADVP=target !&lt; &quot; + NOT_PAT + &quot; !&lt; &quot; + ETC_PAT + &quot;)&quot;,
            &quot;CONJP &lt; (RB=target !&lt; &quot; + NOT_PAT + &quot; !&lt; &quot; + ETC_PAT + &quot;)&quot;);


  /**
   * The &quot;negation modifier&quot; grammatical relation.  The negation modifier
   * is the relation between a negation word and the word it modifies.
   * &lt;p/&gt;
   * Examples: &lt;br/&gt;
   * &quot;Bill is not a scientist&quot; &amp;rarr;
   * {@code neg}(scientist, not) &lt;br/&gt;
   * &quot;Bill doesn't drive&quot; &amp;rarr;
   * {@code neg}(drive, n't)
   */
<span class="fc" id="L1110">  public static final GrammaticalRelation NEGATION_MODIFIER =</span>
    new GrammaticalRelation(Language.UniversalEnglish, &quot;neg&quot;, &quot;negation modifier&quot;,
        ADVERBIAL_MODIFIER,
        &quot;VP|ADJP|S|SBAR|SINV|SQ|NP(?:-TMP|-ADV)?|FRAG|CONJP|PP|NAC|NML|NX|ADVP|WHADVP&quot;, tregexCompiler,
            &quot;/^(?:VP|NP(?:-TMP|-ADV)?|ADJP|SQ|S|FRAG|CONJP|PP)$/&lt; (RB=target &lt; &quot; + NOT_PAT + &quot;)&quot;,
            &quot;VP|ADJP|S|SBAR|SINV|FRAG &lt; (ADVP=target &lt;# (RB &lt; &quot; + NOT_PAT + &quot;))&quot;,
            &quot;VP &gt; SQ $-- (RB=target &lt; &quot; + NOT_PAT + &quot;)&quot;,
            // the commented out parts were relevant for the &quot;det&quot;,
            // but don't seem to matter for the &quot;neg&quot; relation
            &quot;/^(?:NP(?:-TMP|-ADV)?|NAC|NML|NX|ADJP|ADVP)$/ &lt; (DT|RB=target &lt; /^(?i:no)$/ &quot; + /* !$++ CC */ &quot; $++ /^(?:N[MNXP]|CD|JJ|JJR|FW|ADJP|QP|RB|RBR|PRP(?![$])|PRN)/ &quot; + /* =det !$++ (/^PRP[$]|POS/ $++ =det !$++ (/''/ $++ =det)) */ &quot;)&quot;,
            // catches &quot;no more&quot;, possibly others as well
            // !&lt; CC|CONJP catches phrases such as &quot;no more or less&quot;, which maybe should be preconj
            &quot;ADVP|WHADVP &lt; (RB|RBR|RBS|WRB|ADVP|WHADVP|JJ=target &lt; /^(?i:no)$/) !&lt; CC|CONJP&quot;);


  /**
   * The &quot;noun phrase as adverbial modifier&quot; grammatical relation.
   * This relation captures various places where something syntactically a noun
   * phrase is used as an adverbial modifier in a sentence.  These usages include:
   * &lt;ul&gt;
   * &lt;li&gt; A measure phrase, which is the relation between
   * the head of an ADJP/ADVP and the head of a measure-phrase modifying the ADJP/ADVP.
   * &lt;p/&gt;
   * Example: &lt;br/&gt;
   * &quot;The director is 65 years old&quot; &amp;rarr;
   * {@code npadvmod}(old, years)
   * &lt;/li&gt;
   * &lt;li&gt; Noun phrases giving extent inside a VP which are not objects
   * &lt;p/&gt;
   * Example: &lt;br/&gt;
   * &quot;Shares eased a fraction&quot; &amp;rarr;
   * {@code npadvmod}(eased, fraction)
   * &lt;/li&gt;
   * &lt;li&gt; Financial constructions involving an adverbial or PP-like NP, notably
   * the following construction where the NP means &quot;per share&quot;
   * &lt;p/&gt;
   * Example: &lt;br/&gt;
   * &quot;IBM earned $ 5 a share&quot; &amp;rarr;
   * {@code npadvmod}($, share)
   * &lt;/li&gt;
   * &lt;li&gt;Floating reflexives
   * &lt;p/&gt;
   * Example: &lt;br/&gt;
   * &quot;The silence is itself significant&quot; &amp;rarr;
   * {@code npadvmod}(significant, itself)
   * &lt;/li&gt;
   * &lt;li&gt;Certain other absolutive NP constructions.
   * &lt;p/&gt;
   * Example: &lt;br/&gt;
   * &quot;90% of Australians like him, the most of any country&quot; &amp;rarr;
   * {@code npadvmod}(like, most)
   * &lt;/ul&gt;
   * A temporal modifier (tmod) is a subclass of npadvmod which is distinguished
   * as a separate relation.
   */
<span class="fc" id="L1165">  public static final GrammaticalRelation NP_ADVERBIAL_MODIFIER =</span>
    new GrammaticalRelation(Language.UniversalEnglish, &quot;nmod:npmod&quot;, &quot;noun phrase adverbial modifier&quot;,
        MODIFIER, &quot;VP|(?:WH)?(?:NP|ADJP|ADVP|PP|QP)(?:-TMP|-ADV)?&quot;, tregexCompiler,
            &quot;@ADVP|ADJP|WHADJP|WHADVP|PP|WHPP &lt;# (JJ|JJR|IN|RB|RBR !&lt; notwithstanding $- (@NP=target !&lt; NNP|NNPS))&quot;,
            // one word nouns like &quot;cost efficient&quot;, &quot;ice-free&quot;
            &quot;@ADJP &lt; (NN=target $++ /^JJ/) !&lt; CC|CONJP&quot;,
            &quot;@ADVP &lt;# (/^(RB|ADVP)/ $++ @NP=target)&quot;, //up 20%, once a week, ...
            &quot;@NP|WHNP &lt; /^NP-ADV/=target&quot;,
            // Mr. Bush himself ..., in a couple different parse
            // patterns.  Looking for CC|CONJP leaves out phrases such
            // as &quot;he and myself&quot;
            &quot;@NP|WHNP [ &lt; (NP=target &lt;: (PRP &lt; &quot; + selfRegex + &quot;)) | &lt; (PRP=target &lt; &quot; + selfRegex + &quot;) ] : (=target $-- NP|NN|NNS|NNP|NNPS|PRP=noun !$-- (/^,|CC|CONJP$/ $-- =noun))&quot;,
            // this next one is for weird financial listings: 4.7% three months
            &quot;@NP &lt;1 (@NP &lt;&lt;# /^%$/) &lt;2 (@NP=target &lt;&lt;# days|month|months) !&lt;3 __&quot;,
            &quot;@VP &lt; /^NP-ADV/=target&quot;,
            &quot;@NP|ADVP|QP &lt;+(/ADVP/) (@ADVP=target &lt; (IN &lt; /(?i:at)/) &lt; NP)&quot; //at least/most/...
            );


  /**
   * The &quot;temporal modifier&quot; grammatical relation.  A temporal modifier
   *  is a subtype of the nmod relation: if the modifier is specifying
   *  a time, it is labeled as tmod.
   * &lt;p/&gt;
   * Example: &lt;br/&gt;
   * &quot;Last night, I swam in the pool&quot; &amp;rarr;
   * {@code nmod:tmod}(swam, night)
   */
<span class="fc" id="L1193">  public static final GrammaticalRelation TEMPORAL_MODIFIER =</span>
    new GrammaticalRelation(Language.UniversalEnglish, &quot;nmod:tmod&quot;, &quot;temporal modifier&quot;,
        NOMINAL_MODIFIER, &quot;VP|S|ADJP|PP|SBAR|SBARQ|NP|RRC&quot;, tregexCompiler,
            &quot;VP|ADJP|RRC [ &lt; NP-TMP=target | &lt; (VP=target &lt;# NP-TMP !$ /^,|CC|CONJP$/) | &lt; (NP=target &lt;# (/^NN/ &lt; &quot; + timeWordRegex + &quot;) !$+ (/^JJ/ &lt; old)) ]&quot;,
            // CDM Jan 2010: For constructions like &quot;during the same period last year&quot;
            // combining expressions into a single disjunction should improve speed a little
            &quot;@PP &lt; (IN|TO|VBG|FW $++ (@NP [ $+ NP-TMP=target | $+ (NP=target &lt;# (/^NN/ &lt; &quot; + timeWordRegex + &quot;)) ]))&quot;,
            &quot;S &lt; (NP-TMP=target $++ VP $ NP )&quot;,
            &quot;S &lt; (NP=target &lt;# (/^NN/ &lt; &quot; + timeWordRegex + &quot;) $++ (NP $++ VP))&quot;,
            // matches when relative clauses as temporal modifiers of verbs!
            &quot;SBAR &lt; (@WHADVP &lt; (WRB &lt; when)) &lt; (S &lt; (NP $+ (VP !&lt; (/^(?:VB|AUX)/ &lt; &quot; + copularWordRegex + &quot; !$+ VP) ))) !$-- CC $-- NP &gt; NP=target&quot;,
            &quot;SBARQ &lt; (@WHNP=target &lt;# (/^NN/ &lt; &quot; + timeWordRegex + &quot;)) &lt; (SQ &lt; @NP)&quot;,
            &quot;NP &lt; NP-TMP=target&quot;);

  /**
   * The &quot;multi-word expression&quot; grammatical relation.
   * This covers various multi-word constructions for which it would
   * seem pointless or arbitrary to claim grammatical relations between words:
   * as well as, rather than, instead of, but also;
   * such as, because of, all but, in addition to ....
   * &lt;p/&gt;
   * Examples: &lt;br/&gt;
   * &quot;dogs as well as cats&quot; &amp;rarr;
   * {@code mwe}(as, well)&lt;br/&gt;
   * {@code mwe}(as, as)&lt;p/&gt;
   * &quot;fewer than 700 bottles&quot; &amp;rarr;
   * {@code mwe}(fewer, than)
   *
   * @see {@link CoordinationTransformer#MWETransform(Tree)}
   * @see &lt;a href=&quot;http://universaldependencies.github.io/docs/en/dep/mwe.html&quot;&gt;List of multi-word expressions&lt;/a&gt;
   */
<span class="fc" id="L1224">  public static final GrammaticalRelation MULTI_WORD_EXPRESSION =</span>
    new GrammaticalRelation(Language.UniversalEnglish, &quot;mwe&quot;, &quot;multi-word expression&quot;,
        MODIFIER, &quot;MWE&quot;, tregexCompiler,
            &quot;MWE &lt; (IN|TO|RB|NP|NN|JJ|VB|CC|VBZ|VBD|ADVP|PP|JJS|RBS=target)&quot;);

  /**
   * The &quot;determiner&quot; grammatical relation.
   * &lt;p&gt; &lt;p/&gt;
   * Examples: &lt;br/&gt;
   * &quot;The man is here&quot; &amp;rarr; {@code det}(man,the) &lt;br/&gt;
   * &quot;Which man do you prefer?&quot; &amp;rarr; {@code det}(man,which) &lt;br&gt;
   * (The ADVP match is because sometimes &quot;a little&quot; or &quot;every time&quot; is tagged
   * as an AVDVP with POS tags straight under it.)
   */
<span class="fc" id="L1238">  public static final GrammaticalRelation DETERMINER =</span>
    new GrammaticalRelation(Language.UniversalEnglish, &quot;det&quot;, &quot;determiner&quot;,
        MODIFIER, &quot;(?:WH)?NP(?:-TMP|-ADV)?|NAC|NML|NX|X|ADVP|ADJP&quot;, tregexCompiler,
            &quot;/^(?:NP(?:-TMP|-ADV)?|NAC|NML|NX|X)$/ &lt; (DT=target !&lt; /^(?i:either|neither|both|no)$/ !$+ DT !$++ CC $++ /^(?:N[MNXP]|CD|JJ|FW|ADJP|QP|RB|PRP(?![$])|PRN)/=det !$++ (/^PRP[$]|POS/ $++ =det !$++ (/''/ $++ =det)))&quot;,
            &quot;NP|NP-TMP|NP-ADV &lt; (DT=target [ (&lt; /^(?i:either|neither|both)$/ !$+ DT !$++ CC $++ /^(?:NN|NX|NML)/ !$++ (NP &lt; CC)) | &quot; +
                                            &quot;(!&lt; /^(?i:either|neither|both|no)$/ $++ CC $++ /^(?:NN|NX|NML)/) | &quot; +
                                            &quot;(!&lt; /^(?i:no)$/ $++ (/^JJ/ !$+ /^NN/) !$++CC !$+ DT) ] )&quot;,
            // &quot;NP|NP-TMP|NP-ADV &lt; (RB=target $++ (/^PDT$/ $+ /^NN/))&quot;, // todo: This matches nothing. Was it meant to be a PDT rule for (NP almost/RB no/DT chairs/NNS)?
            &quot;NP|NP-TMP|NP-ADV &lt;&lt;, PRP &lt;- (NP|DT|RB=target &lt;&lt;- /^(?i:all|both|each)$/)&quot;, // we all, them all; various structures
            &quot;WHNP &lt; (NP $-- (WHNP=target &lt; WDT))&quot;,
            // testing against CC|CONJP avoids conflicts with preconj in
            // phrases such as &quot;both foo and bar&quot;
            // however, we allow WDT|WP to account for &quot;what foo or bar&quot; and &quot;whatever foo or bar&quot;
            &quot;@WHNP|ADVP|ADJP &lt; (/^(?:NP|NN|CD|RBS|JJ)/ $-- (DT|WDT|WP=target !&lt; /^(?i:no)$/ [ ==WDT|WP | !$++ CC|CONJP ]))&quot;,
            &quot;@NP &lt; (/^(?:NP|NN|CD|RBS)/ $-- WDT|WP=target)&quot;);


  /**
   * The &quot;predeterminer&quot; grammatical relation.
   * &lt;p&gt; &lt;p/&gt;
   * Example: &lt;br/&gt;
   * &quot;All the boys are here&quot; &amp;rarr; {@code predet}(boys,all)
   */
<span class="fc" id="L1261">  public static final GrammaticalRelation PREDETERMINER =</span>
    new GrammaticalRelation(Language.UniversalEnglish, &quot;det:predet&quot;, &quot;predeterminer&quot;,
        MODIFIER, &quot;(?:WH)?(?:NP|NX|NAC|NML)(?:-TMP|-ADV)?&quot;, tregexCompiler,
            &quot;/^(?:(?:WH)?NP(?:-TMP|-ADV)?|NX|NAC|NML)$/ &lt; (PDT|DT=target $+ /^(?:DT|WP\\$|PRP\\$)$/ $++ /^(?:NN|NX|NML)/ !$++ CC)&quot;,
            &quot;WHNP|WHNP-TMP|WHNP-ADV|NP|NP-TMP|NP-ADV &lt; (PDT|DT=target $+ DT $++ (/^JJ/ !$+ /^NN/)) !$++ CC&quot;,
            &quot;WHNP|WHNP-TMP|WHNP-ADV|NP|NP-TMP|NP-ADV &lt; PDT=target &lt;- DT&quot;);


  /**
   * The &quot;preconjunct&quot; grammatical relation.
   * &lt;p/&gt;
   * Example: &lt;br/&gt;
   * &quot;Both the boys and the girls are here&quot; &amp;rarr; {@code cc:preconj}(boys,both)
   */
  //TODO: web_tbk/data/reviews/penntree/122270.xml.tree:
  // &quot;both of the work..&quot;
<span class="fc" id="L1277">  public static final GrammaticalRelation PRECONJUNCT =</span>
    new GrammaticalRelation(Language.UniversalEnglish, &quot;cc:preconj&quot;, &quot;preconjunct&quot;,
        MODIFIER,
        &quot;S|VP|ADJP|PP|ADVP|UCP(?:-TMP|-ADV)?|NX|NML|SBAR|NP(?:-TMP|-ADV)?&quot;, tregexCompiler,
            &quot;NP|NP-TMP|NP-ADV|NX|NML &lt; (PDT|CC|DT=target &lt; /^(?i:either|neither|both)$/ $++ CC)&quot;,
            &quot;NP|NP-TMP|NP-ADV|NX|NML &lt; (CONJP=target &lt; (RB &lt; /^(?i:not)$/) &lt; (RB|JJ &lt; /^(?i:only|merely|just)$/) $++ CC|CONJP)&quot;,
            // This matches weird/wrong NP-internal preconjuncts where you get (NP PDT (NP NP CC NP)) or similar
            &quot;NP|NP-TMP|NP-ADV|NX|NML &lt; (PDT|CC|DT=target &lt; /^(?i:either|neither|both)$/ ) &lt; (NP &lt; CC)&quot;,
            &quot;/^S|VP|ADJP|PP|ADVP|UCP(?:-TMP|-ADV)?|NX|NML|SBAR$/ &lt; (PDT|DT|CC=target &lt; /^(?i:either|neither|both)$/ $++ CC)&quot;,
            &quot;/^S|VP|ADJP|PP|ADVP|UCP(?:-TMP|-ADV)?|NX|NML|SBAR$/ &lt; (CONJP=target &lt; (RB &lt; /^(?i:not)$/) &lt; (RB|JJ &lt; /^(?i:only|merely|just)$/) $++ CC|CONJP)&quot;);


  //TODO: change some of it to nmod, ?also change pronouns?
  /**
   * The &quot;possession&quot; grammatical relation between the possessum and the possessor.&lt;p&gt;
   * &lt;/p&gt;
   * Examples: &lt;br/&gt;
   * &quot;their offices&quot; &amp;rarr;
   * {@code poss}(offices, their)&lt;br/&gt;
   * &quot;Bill 's clothes&quot; &amp;rarr;
   * {@code poss}(clothes, Bill)
   */
<span class="fc" id="L1299">  public static final GrammaticalRelation POSSESSION_MODIFIER =</span>
    new GrammaticalRelation(Language.UniversalEnglish, &quot;nmod:poss&quot;, &quot;possession modifier&quot;,
        MODIFIER, &quot;(?:WH)?(NP|ADJP|INTJ|PRN|NAC|NX|NML)(?:-.*)?&quot;, tregexCompiler,
            &quot;/^(?:WH)?(?:NP|INTJ|ADJP|PRN|NAC|NX|NML)(?:-.*)?$/ &lt; /^(?:WP\\$|PRP\\$)$/=target&quot;,
            // todo: possessive pronoun under ADJP needs more work for one case of (ADJP his or her own)
            // basic NP possessive: we want to allow little conjunctions in head noun (NP (NP ... POS) NN CC NN) but not falsely match when there are conjoined NPs.  See tests.

            &quot;/^(?:WH)?(?:NP|NML)(?:-.*)?$/ [ &lt; (WHNP|WHNML|NP|NML=target [ &lt; POS | &lt; (VBZ &lt; /^'s$/) ] ) !&lt; (CC|CONJP $++ WHNP|WHNML|NP|NML) |  &lt; (WHNP|WHNML|NP|NML=target &lt; (CC|CONJP $++ WHNP|WHNML|NP|NML) &lt; (WHNP|WHNML|NP|NML [ &lt; POS | &lt; (VBZ &lt; /^'s$/) ] )) ]&quot;,
            // handle a few too flat NPs
            // note that ' matches both ' and 's
            &quot;/^(?:WH)?(?:NP|NML|NX)(?:-.*)?$/ &lt; (/^NN|NP/=target $++ (POS=pos &lt; /\'/ $++ /^NN/) !$++ (/^NN|NP/ $++ =pos))&quot;
            );

  //todo: update documentation
  /**
   * The &quot;prepositional modifier&quot; grammatical relation.  A prepositional
   * modifier of a verb, adjective, or noun is any prepositional phrase that serves to modify
   * the meaning of the verb, adjective, or noun.
   * We also generate prep modifiers of PPs to account for treebank (PP PP PP) constructions
   * (from 1984 through 2002). &lt;p&gt;
   * &lt;p/&gt;
   * Examples: &lt;br/&gt;
   * &quot;I saw a cat in a hat&quot; &amp;rarr;
   * {@code case}(hat, in) &lt;br/&gt;
   * &quot;I saw a cat with a telescope&quot; &amp;rarr;
   * {@code case}(telescope, with) &lt;br/&gt;
   * &quot;He is responsible for meals&quot; &amp;rarr;
   * {@code case}(meals, for)
   */
<span class="fc" id="L1328">  public static final GrammaticalRelation CASE_MARKER =</span>
    new GrammaticalRelation(Language.UniversalEnglish, &quot;case&quot;, &quot;case marker&quot;,
        MODIFIER, &quot;(?:WH)?(?:PP.*|SBARQ|NP|NML|ADVP)(?:-TMP|-ADV)?&quot;, tregexCompiler,
            //&quot;/(?:WH)?PP(?:-TMP)?/ !$- (@CC|CONJP $- __) &lt; IN|TO|MWE=target&quot;,
            &quot;/(?:WH)?PP(?:-TMP)?/ &lt; (IN|TO|MWE|PCONJP|VBN|JJ=target !$+ @SBAR [!$+ @S | $+ (S &lt;, (VP &lt;, NN))] )&quot;,
            //&quot;/(?:WH)?PP(?:-TMP)?/ &lt; (IN|TO|MWE|PCONJP=target !$+ @SBAR|S)&quot;,
            &quot;/^(?:WH)?(?:NP|NML)(?:-TMP|-ADV)?$/ &lt; POS=target&quot;, //'s
            &quot;/^(?:WH)?(?:NP|NML)(?:-TMP|-ADV)?$/ &lt; (VBZ=target &lt; /^'s$/)&quot;, //'s


            //TODO: integrate the following into nmod???
            //&quot;/^(?:(?:WH)?(?:NP|ADJP|ADVP|NX|NML)(?:-TMP|-ADV)?|VP|NAC|SQ|FRAG|PRN|X|RRC)$/ &lt; (S=target &lt;: WHPP|WHPP-TMP|PP|PP-TMP)&quot;,
            // only allow a PP &lt; PP one if there is not a conj, verb, or other pattern that matches pcomp under it.  Else pcomp
            //&quot;WHPP|WHPP-TMP|WHPP-ADV|PP|PP-TMP|PP-ADV &lt; (WHPP|WHPP-TMP|WHPP-ADV|PP|PP-TMP|PP-ADV=target !$- IN|VBG|VBN|TO) !&lt; @CC|CONJP&quot;,
            //&quot;S|SINV &lt; (PP|PP-TMP=target !&lt; SBAR) &lt; VP|S&quot;,
            //&quot;SBAR|SBARQ &lt; /^(?:WH)?PP/=target &lt; S|SQ&quot;,
            // to handle &quot;What weapon is Apollo most proficient with?&quot;
            //&quot;SBARQ &lt; (WHNP $++ ((/^(?:VB|AUX)/ &lt; &quot; + copularWordRegex + &quot;) $++ (ADJP=adj &lt; (PP=target !&lt; NP)) $++ (NP $++ =adj)))&quot;,

            // to handle &quot;Nothing but their scratches&quot;
            &quot;/(?:WH)?PP(?:-TMP)?/ &lt;1 CC=target &lt;2 NP&quot;,


            &quot;/(?:WH)?PP(?:-TMP)?/ &lt;, VBG=target !&lt; (@PP &lt; @SBAR|S)&quot;,


            //&quot;at most/at best/...&quot;
            &quot;@ADVP &lt; IN=target&quot;);


            /*
            &quot;/^(?:(?:WH)?(?:NP|ADJP|ADVP|NX|NML)(?:-TMP|-ADV)?|VP|NAC|SQ|FRAG|PRN|X|RRC)$/ &lt; (WHPP|WHPP-TMP|PP|PP-TMP=target !$- (@CC|CONJP $- __)) !&lt;- &quot; + ETC_PAT + &quot; !&lt;- &quot; + FW_ETC_PAT,
            &quot;/^(?:(?:WH)?(?:NP|ADJP|ADVP|NX|NML)(?:-TMP|-ADV)?|VP|NAC|SQ|FRAG|PRN|X|RRC)$/ &lt; (S=target &lt;: WHPP|WHPP-TMP|PP|PP-TMP)&quot;,
            // only allow a PP &lt; PP one if there is not a conj, verb, or other pattern that matches pcomp under it.  Else pcomp
            &quot;WHPP|WHPP-TMP|WHPP-ADV|PP|PP-TMP|PP-ADV &lt; (WHPP|WHPP-TMP|WHPP-ADV|PP|PP-TMP|PP-ADV=target !$- IN|VBG|VBN|TO) !&lt; @CC|CONJP&quot;,
            &quot;S|SINV &lt; (PP|PP-TMP=target !&lt; SBAR) &lt; VP|S&quot;,
            &quot;SBAR|SBARQ &lt; /^(?:WH)?PP/=target &lt; S|SQ&quot;,
            &quot;@NP &lt; (@UCP|PRN=target &lt;# @PP)&quot;);
            */


  /**
   * The &quot;phrasal verb particle&quot; grammatical relation.  The &quot;phrasal verb particle&quot;
   * relation identifies phrasal verb.&lt;p&gt;
   * &lt;p/&gt;
   * Example: &lt;br/&gt;
   * &quot;They shut down the station.&quot; &amp;rarr;
   * {@code prt}(shut, down)
   */
<span class="fc" id="L1377">  public static final GrammaticalRelation PHRASAL_VERB_PARTICLE =</span>
    new GrammaticalRelation(Language.UniversalEnglish, &quot;compound:prt&quot;, &quot;phrasal verb particle&quot;,
        MODIFIER, &quot;VP|ADJP&quot;, tregexCompiler,
            &quot;VP &lt; PRT=target&quot;,
            &quot;ADJP &lt; /^VB/ &lt; RP=target&quot;);


  /**
   * The &quot;parataxis&quot; grammatical relation. Relation between the main verb of a sentence
   * and other sentential elements, such as a sentential parenthetical, a sentence after a &quot;:&quot; or a &quot;;&quot;, when two
   * sentences are juxtaposed next to each other without any coordinator or subordinator, etc.
   * &lt;p&gt; &lt;p/&gt;
   * Examples: &lt;br/&gt;
   * &quot;The guy, John said, left early in the morning.&quot; &amp;rarr; {@code parataxis}(left,said) &lt;br/&gt;
   * &quot;
   */
<span class="fc" id="L1393">  public static final GrammaticalRelation PARATAXIS =</span>
    new GrammaticalRelation(Language.UniversalEnglish, &quot;parataxis&quot;, &quot;parataxis&quot;,
        DEPENDENT, &quot;S|VP|FRAG|NP&quot;, tregexCompiler,
            &quot;VP &lt; (PRN=target &lt; S|SINV|SBAR)&quot;, // parenthetical
            &quot;VP $ (PRN=target [ &lt; S|SINV|SBAR | &lt; VP &lt; @NP ] )&quot;, // parenthetical
            // The next relation handles a colon between sentences
            // and similar punct such as --
            // Sometimes these are lists, especially in the case of &quot;;&quot;,
            // so we don't trigger if there is a CC|CONJP that occurs
            // anywhere other than the first child
            // First child can occur in rare circumstances such as
            // &quot;But even if he agrees -- which he won't -- etc etc&quot;
            &quot;S|FRAG|VP &lt; (/^:$/ $+ /^S/=target) !&lt;, (__ $++ CC|CONJP)&quot;,
            // two juxtaposed sentences; common in web materials (but this also matches quite a few wsj things)
            &quot;@S|FRAG &lt; (@S|SBARQ|SQ|FRAG $++ @S|SBARQ|SQ|FRAG=target !$++ @CC|CONJP|MWE !$++ (/:/ &lt; /;/))&quot;,
            &quot;@S|FRAG|VP &lt; (/^:$/ $-- /^V/ $+ @NP=target) !&lt; @CONJP|CC&quot;, // sometimes CC cases are right node raising, etc.
            &quot;FRAG|NP &lt; (NP $+ (/:/ $+ @SQ|S=target) &lt;&lt; NNP|NNPS)&quot;
    );

  /**
   * The &quot;goes with&quot; grammatical relation.  This corresponds to use of the GW (goes with) part-of-speech tag
   * in the recent Penn Treebanks. It marks partial words that should be combined with some other word. &lt;p&gt;
   * &lt;p/&gt;
   * Example: &lt;br/&gt;
   * &quot;They come here with out legal permission.&quot; &amp;rarr;
   * {@code goeswith}(out, with)
   */
<span class="fc" id="L1420">  public static final GrammaticalRelation GOES_WITH =</span>
    new GrammaticalRelation(Language.UniversalEnglish, &quot;goeswith&quot;, &quot;goes with&quot;,
        MODIFIER, &quot;.*&quot;, tregexCompiler,
            &quot;__ &lt; GW=target&quot;);


  /**
   * The &quot;list&quot; relation.
   */
<span class="fc" id="L1429">  public static final GrammaticalRelation LIST =</span>
      new GrammaticalRelation(Language.UniversalEnglish, &quot;list&quot;, &quot;list&quot;,
          DEPENDENT, &quot;FRAG&quot;, tregexCompiler,
          &quot;FRAG &lt; (NP $+ (/,/ $+ (NP=target $+ (/,/ $+ NP))) !$++ CC|CONJP|MWE)&quot;,
          &quot;FRAG &lt; (NP $+ (/,/ $+ (NP $++ (/,/ $+ NP=target))) !$++ CC|CONJP|MWE)&quot;);


  /**
   * The quantificational modifier relation. Used in the enhanced++
   * representation for the quanfiticational determiner in
   * partitive and light noun constructions.
   *
   * &lt;p/&gt;
   * Example: &lt;br/&gt;
   * &quot;Both of the planes&quot; &amp;rarr;
   * {@code det:qmod}(planes, both)&lt;br/&gt;
   * {@code mwe}(both, of)&lt;br/&gt;
   * {@code mwe}(both, the)&lt;br/&gt;
   *
   */
<span class="fc" id="L1449">  public static final GrammaticalRelation QMOD =</span>
      new GrammaticalRelation(Language.UniversalEnglish, &quot;det:qmod&quot;, &quot;quantificational modifier&quot;,
          UniversalEnglishGrammaticalRelations.DETERMINER);


  /** The &quot;controlling nominal subject&quot; relation. Used in the enhanced and enhanced++
   * representations between a controlled verb and its nominal controller.
   *
   * &lt;p/&gt;
   * Example: &lt;br/&gt;
   * &quot;Sue wants to buy a hat.&quot; &amp;rarr;
   * {@code nsubj}(Sue, wants)&lt;br/&gt;
   * {@code nsubj:xsubj}(Sue, wants)&lt;br/&gt;
   * {@code mark}(to, buy)&lt;br/&gt;
   * {@code xcomp}(buy, wants)&lt;br/&gt;
   * {@code det}(a, hat)&lt;br/&gt;
   * {@code dobj}(hat, buy)&lt;br/&gt;
   */
<span class="fc" id="L1467">  public static final GrammaticalRelation CONTROLLING_NOMINAL_SUBJECT =</span>
      new GrammaticalRelation(Language.UniversalEnglish, &quot;nsubj:xsubj&quot;, &quot;controlling nominal subject&quot;,
          UniversalEnglishGrammaticalRelations.NOMINAL_SUBJECT);


  /** The &quot;controlling nominal passive subject&quot; relation.
   * Used in the enhanced and enhanced++ representations between
   * a controlled verb and its nominal controller, if the controlled
   * verb is in passive voice.
   *
   * &lt;p/&gt;
   * Example: &lt;br/&gt;
   * &quot;The hat seemed to have been bought.&quot; &amp;rarr;
   * {@code nsubj}(hat, seemed)&lt;br/&gt;
   * {@code nsubjpass:xsubj}(hat, bought)&lt;br/&gt;
   * {@code mark}(to, bought)&lt;br/&gt;
   * {@code aux}(have, bought)&lt;br/&gt;
   * {@code auxpass}(been, bought)&lt;br/&gt;
   *
   */
<span class="fc" id="L1487">  public static final GrammaticalRelation CONTROLLING_NOMINAL_PASSIVE_SUBJECT =</span>
      new GrammaticalRelation(Language.UniversalEnglish, &quot;nsubjpass:xsubj&quot;, &quot;controlling nominal passive subject&quot;,
          UniversalEnglishGrammaticalRelations.NOMINAL_PASSIVE_SUBJECT);



  /** The &quot;controlling clausal subject&quot; relation. Used in the enhanced and enhanced++
   * representations between a controlled verb and its nominal controller.
   *
   * &lt;p/&gt;
   * Example: &lt;br/&gt;
   * &quot;That they bought the company &quot; &amp;rarr;
   * {@code nsubj}(hat, seemed)&lt;br/&gt;
   * {@code nsubjpass:xsubj}(hat, bought)&lt;br/&gt;
   * {@code mark}(to, bought)&lt;br/&gt;
   * {@code aux}(have, bought)&lt;br/&gt;
   * {@code auxpass}(been, bought)&lt;br/&gt;
   *
   */
<span class="fc" id="L1506">  public static final GrammaticalRelation CONTROLLING_CLAUSAL_SUBJECT =</span>
      new GrammaticalRelation(Language.UniversalEnglish, &quot;csubj:xsubj&quot;, &quot;controlling clausal subject&quot;,
          UniversalEnglishGrammaticalRelations.NOMINAL_PASSIVE_SUBJECT);



  /** The &quot;controlling clausal passive subject&quot; relation. Used in the enhanced and enhanced++
   * representations between a controlled verb and its nominal controller, if the controlled verb is in passive voice.
   *
   * TODO: Is this a possible relation?
   *
   */
<span class="fc" id="L1518">  public static final GrammaticalRelation CONTROLLING_CLAUSAL_PASSIVE_SUBJECT =</span>
      new GrammaticalRelation(Language.UniversalEnglish, &quot;csubjpass:xsubj&quot;, &quot;controlling clausal passive subject&quot;,
          UniversalEnglishGrammaticalRelations.NOMINAL_PASSIVE_SUBJECT);



  /**
   * The &quot;semantic dependent&quot; grammatical relation has been
   * introduced as a supertype for the controlling subject relation.
   */
<span class="fc" id="L1528">  public static final GrammaticalRelation SEMANTIC_DEPENDENT =</span>
    new GrammaticalRelation(Language.UniversalEnglish, &quot;sdep&quot;, &quot;semantic dependent&quot;, DEPENDENT);


  /**
   * The &quot;agent&quot; grammatical relation. The agent of a passive VP
   * is the complement introduced by &quot;by&quot; and doing the action.&lt;p&gt;
   * &lt;p/&gt;
   * Example: &lt;br/&gt;
   * &quot;The man has been killed by the police&quot; &amp;rarr;
   * {@code agent}(killed, police)
   */
<span class="fc" id="L1540">  public static final GrammaticalRelation AGENT =</span>
    new GrammaticalRelation(Language.UniversalEnglish, &quot;agent&quot;, &quot;agent&quot;, DEPENDENT);


  // TODO would be nice to have this set up automatically...
  /**
   * A list of GrammaticalRelation values.  New GrammaticalRelations must be
   * added to this list (until we make this an enum!).
   * The GR recognizers are tried in the order listed.  A taxonomic
   * relationship trumps an ordering relationship, but otherwise, the first
   * listed relation will appear in dependency output.  Known ordering
   * constraints where both match include:
   * &lt;ul&gt;
   * &lt;li&gt;NUMERIC_MODIFIER &amp;lt; ADJECTIVAL_MODIFIER
   * &lt;/ul&gt;
   */
  @SuppressWarnings({&quot;RedundantArrayCreation&quot;})
<span class="fc" id="L1557">  private static final List&lt;GrammaticalRelation&gt; values =</span>
<span class="fc" id="L1558">    Generics.newArrayList(Arrays.asList(new GrammaticalRelation[]{</span>
            GOVERNOR,
            DEPENDENT,
            PREDICATE,
            AUX_MODIFIER,
            AUX_PASSIVE_MODIFIER,
            COPULA,
            CONJUNCT,
            COORDINATION,
            PUNCTUATION,
            ARGUMENT,
            SUBJECT,
            NOMINAL_SUBJECT,
            NOMINAL_PASSIVE_SUBJECT,
            CLAUSAL_SUBJECT,
            CLAUSAL_PASSIVE_SUBJECT,
            COMPLEMENT,
            OBJECT,
            DIRECT_OBJECT,
            INDIRECT_OBJECT,
            NOMINAL_MODIFIER,
            CLAUSAL_COMPLEMENT,
            XCLAUSAL_COMPLEMENT,
            MARKER,
            RELATIVE,
            REFERENT,
            EXPLETIVE,
            MODIFIER,
            ADV_CLAUSE_MODIFIER,
            TEMPORAL_MODIFIER,
            RELATIVE_CLAUSE_MODIFIER,
            NUMERIC_MODIFIER,
            ADJECTIVAL_MODIFIER,
            COMPOUND_MODIFIER,
            NAME_MODIFIER,
            APPOSITIONAL_MODIFIER,
            CLAUSAL_MODIFIER,
            ADVERBIAL_MODIFIER,
            NEGATION_MODIFIER,
            MULTI_WORD_EXPRESSION,
            DETERMINER,
            PREDETERMINER,
            PRECONJUNCT,
            POSSESSION_MODIFIER,
            CASE_MARKER,
            PHRASAL_VERB_PARTICLE,
            SEMANTIC_DEPENDENT,
            AGENT,
            NP_ADVERBIAL_MODIFIER,
            PARATAXIS,
            DISCOURSE_ELEMENT,
            GOES_WITH,
            LIST,
            PREPOSITION,
            QMOD,
            CONTROLLING_NOMINAL_SUBJECT,
            CONTROLLING_NOMINAL_PASSIVE_SUBJECT,
            CONTROLLING_CLAUSAL_SUBJECT,
            CONTROLLING_CLAUSAL_PASSIVE_SUBJECT
    }));
  // Cache frequently used views of the values list
<span class="fc" id="L1619">  private static final List&lt;GrammaticalRelation&gt; synchronizedValues =</span>
<span class="fc" id="L1620">    Collections.synchronizedList(values);</span>
<span class="fc" id="L1621">  private static final List&lt;GrammaticalRelation&gt; unmodifiableSynchronizedValues =</span>
<span class="fc" id="L1622">    Collections.unmodifiableList(values);</span>
<span class="fc" id="L1623">  public static final ReadWriteLock valuesLock = new ReentrantReadWriteLock();</span>
  //Relations that can connect two clauses.
<span class="fc" id="L1625">  public static final Set&lt;GrammaticalRelation&gt; clauseRelations =</span>
<span class="fc" id="L1626">      Collections.unmodifiableSet(CollectionUtils.asSet(</span>
              CONJUNCT,
              XCLAUSAL_COMPLEMENT,
              CLAUSAL_COMPLEMENT,
              CLAUSAL_MODIFIER,
              ADV_CLAUSE_MODIFIER,
              RELATIVE_CLAUSE_MODIFIER,
              PARATAXIS,
              APPOSITIONAL_MODIFIER,
              LIST));

  // Map from English GrammaticalRelation short names to their corresponding
  // GrammaticalRelation objects
<span class="fc" id="L1639">  public static final Map&lt;String, GrammaticalRelation&gt; shortNameToGRel = new ConcurrentHashMap&lt;&gt;();</span>
  static {
<span class="fc" id="L1641">    valuesLock().lock();</span>
    try {
<span class="fc bfc" id="L1643" title="All 2 branches covered.">      for (GrammaticalRelation gr : values()) {</span>
<span class="fc" id="L1644">        shortNameToGRel.put(gr.toString().toLowerCase(), gr);</span>
<span class="fc" id="L1645">      }</span>
    } finally {
<span class="pc" id="L1647">      valuesLock().unlock();</span>
<span class="fc" id="L1648">    }</span>
  }

  public static List&lt;GrammaticalRelation&gt; values() {
<span class="fc" id="L1652">    return unmodifiableSynchronizedValues;</span>
  }

  public static Lock valuesLock() {
<span class="fc" id="L1656">    return valuesLock.readLock();</span>
  }

  /**
   * This method is meant to be called when you want to add a relation
   * to the values list in a thread-safe manner.  Currently, this method
   * is always used in preference to values.add() because we expect to
   * add new EnglishGrammaticalRelations very rarely, so the eased
   * concurrency seems to outweigh the fairly slight cost of thread-safe
   * access.
   * @param relation the relation to be added to the values list
   */
  public static void threadSafeAddRelation(GrammaticalRelation relation) {
<span class="fc" id="L1669">    valuesLock.writeLock().lock();</span>
    try { // try-finally structure taken from Javadoc code sample for ReentrantReadWriteLock
<span class="fc" id="L1671">      synchronizedValues.add(relation);</span>
<span class="fc" id="L1672">      shortNameToGRel.put(relation.toString(), relation);</span>
    } finally {
<span class="pc" id="L1674">      valuesLock.writeLock().unlock();</span>
<span class="fc" id="L1675">    }</span>
<span class="fc" id="L1676">  }</span>



  // the exhaustive list of conjunction relations
<span class="fc" id="L1681">  private static final Map&lt;String, GrammaticalRelation&gt; conjs = Generics.newConcurrentHashMap();</span>

  public static Collection&lt;GrammaticalRelation&gt; getConjs() {
<span class="fc" id="L1684">    return conjs.values();</span>
  }

  /**
   * The &quot;conj&quot; grammatical relation. Used to enhance conjunct relations.
   * They will be turned into conj:word, where &quot;word&quot; is a conjunction.
   *
   * @param conjunctionString The conjunction to make a GrammaticalRelation out of
   * @return A grammatical relation for this conjunction
   */
  public static GrammaticalRelation getConj(String conjunctionString) {
<span class="fc" id="L1695">    GrammaticalRelation result = conjs.get(conjunctionString);</span>
<span class="fc bfc" id="L1696" title="All 2 branches covered.">    if (result == null) {</span>
<span class="fc" id="L1697">      synchronized(conjs) {</span>
<span class="fc" id="L1698">        result = conjs.get(conjunctionString);</span>
<span class="pc bpc" id="L1699" title="1 of 2 branches missed.">        if (result == null) {</span>
<span class="fc" id="L1700">          result = new GrammaticalRelation(Language.UniversalEnglish, &quot;conj&quot;, &quot;conj_collapsed&quot;, CONJUNCT, conjunctionString);</span>
<span class="fc" id="L1701">          conjs.put(conjunctionString, result);</span>
<span class="fc" id="L1702">          threadSafeAddRelation(result);</span>
        }
<span class="pc" id="L1704">      }</span>
    }
<span class="fc" id="L1706">    return result;</span>
  }

  // the exhaustive list of preposition relations
<span class="fc" id="L1710">  private static final Map&lt;String, GrammaticalRelation&gt; nmods = Generics.newConcurrentHashMap();</span>
<span class="fc" id="L1711">  private static final Map&lt;String, GrammaticalRelation&gt; acls = Generics.newConcurrentHashMap();</span>
<span class="fc" id="L1712">  private static final Map&lt;String, GrammaticalRelation&gt; advcls = Generics.newConcurrentHashMap();</span>


  public static Collection&lt;GrammaticalRelation&gt; getNmods() {
<span class="nc" id="L1716">    return nmods.values();</span>
  }

  public static Collection&lt;GrammaticalRelation&gt; getAcls() {
<span class="nc" id="L1720">    return acls.values();</span>
  }

  public static Collection&lt;GrammaticalRelation&gt; getAdvcls() {
<span class="nc" id="L1724">    return advcls.values();</span>
  }



  /**
   * The &quot;nmod&quot; grammatical relation. Used to add case marker information
   *  to nominal modifier relations.&lt;p&gt;
   * They will be turned into nmod:word, where &quot;word&quot; is a preposition.
   *
   * @param prepositionString The preposition to make a GrammaticalRelation out of
   * @return A grammatical relation for this preposition
   */
  public static GrammaticalRelation getNmod(String prepositionString) {

    /* Check for nmod subtypes which are not stored in the `nmods` map. */
<span class="pc bpc" id="L1740" title="1 of 2 branches missed.">    if (prepositionString.equals(&quot;npmod&quot;)) {</span>
<span class="nc" id="L1741">      return NP_ADVERBIAL_MODIFIER;</span>
<span class="pc bpc" id="L1742" title="1 of 2 branches missed.">    } else if(prepositionString.equals(&quot;tmod&quot;)) {</span>
<span class="nc" id="L1743">      return TEMPORAL_MODIFIER;</span>
<span class="pc bpc" id="L1744" title="1 of 2 branches missed.">    } else if(prepositionString.equals(&quot;poss&quot;)) {</span>
<span class="nc" id="L1745">      return POSSESSION_MODIFIER;</span>
    }

<span class="fc" id="L1748">    GrammaticalRelation result = nmods.get(prepositionString);</span>
<span class="fc bfc" id="L1749" title="All 2 branches covered.">    if (result == null) {</span>
<span class="fc" id="L1750">      synchronized(nmods) {</span>
<span class="fc" id="L1751">        result = nmods.get(prepositionString);</span>
<span class="pc bpc" id="L1752" title="1 of 2 branches missed.">        if (result == null) {</span>
<span class="fc" id="L1753">          result = new GrammaticalRelation(Language.UniversalEnglish, &quot;nmod&quot;, &quot;nmod_preposition&quot;, NOMINAL_MODIFIER, prepositionString);</span>
<span class="fc" id="L1754">          nmods.put(prepositionString, result);</span>
<span class="fc" id="L1755">          threadSafeAddRelation(result);</span>
        }
<span class="pc" id="L1757">      }</span>
    }
<span class="fc" id="L1759">    return result;</span>
  }


  /**
   * The &quot;advcl&quot; grammatical relation. Used to add case marker information
   *  to adverbial clause relations.&lt;p&gt;
   * They will be turned into advcl:word, where &quot;word&quot; is a preposition.
   *
   * @param advclString The preposition to make a GrammaticalRelation out of
   * @return A grammatical relation for this preposition
   */
  public static GrammaticalRelation getAdvcl(String advclString) {
<span class="nc" id="L1772">    GrammaticalRelation result = advcls.get(advclString);</span>
<span class="nc bnc" id="L1773" title="All 2 branches missed.">    if (result == null) {</span>
<span class="nc" id="L1774">      synchronized(advcls) {</span>
<span class="nc" id="L1775">        result = advcls.get(advclString);</span>
<span class="nc bnc" id="L1776" title="All 2 branches missed.">        if (result == null) {</span>
<span class="nc" id="L1777">          result = new GrammaticalRelation(Language.UniversalEnglish, &quot;advcl&quot;, &quot;advcl_preposition&quot;, ADV_CLAUSE_MODIFIER, advclString);</span>
<span class="nc" id="L1778">          advcls.put(advclString, result);</span>
<span class="nc" id="L1779">          threadSafeAddRelation(result);</span>
        }
<span class="nc" id="L1781">      }</span>
    }
<span class="nc" id="L1783">    return result;</span>
  }


  /**
   * The &quot;acl&quot; grammatical relation. Used to add case marker information to
   * adjectival clause relations.&lt;p&gt;
   * They will be turned into acl:word, where &quot;word&quot; is a preposition.
   *
   * @param aclString The preposition to make a GrammaticalRelation out of
   * @return A grammatical relation for this preposition
   */
  public static GrammaticalRelation getAcl(String aclString) {

    /* Check for nmod subtypes which are not stored in the `nmods` map. */
<span class="nc bnc" id="L1798" title="All 2 branches missed.">    if (aclString.equals(&quot;relcl&quot;)) {</span>
<span class="nc" id="L1799">      return RELATIVE_CLAUSE_MODIFIER;</span>
    }

<span class="nc" id="L1802">    GrammaticalRelation result = acls.get(aclString);</span>
<span class="nc bnc" id="L1803" title="All 2 branches missed.">    if (result == null) {</span>
<span class="nc" id="L1804">      synchronized(acls) {</span>
<span class="nc" id="L1805">        result = acls.get(aclString);</span>
<span class="nc bnc" id="L1806" title="All 2 branches missed.">        if (result == null) {</span>
<span class="nc" id="L1807">          result = new GrammaticalRelation(Language.UniversalEnglish, &quot;acl&quot;, &quot;acl_preposition&quot;, CLAUSAL_MODIFIER, aclString);</span>
<span class="nc" id="L1808">          acls.put(aclString, result);</span>
<span class="nc" id="L1809">          threadSafeAddRelation(result);</span>
        }
<span class="nc" id="L1811">      }</span>
    }
<span class="nc" id="L1813">    return result;</span>
  }

  /**
   * Returns the EnglishGrammaticalRelation having the given string
   * representation (e.g., &quot;nsubj&quot;), or null if no such is found.
   *
   * @param s The short name of the GrammaticalRelation
   * @return The EnglishGrammaticalRelation with that name
   */
  public static GrammaticalRelation valueOf(String s) {
<span class="nc" id="L1824">    return GrammaticalRelation.valueOf(s, synchronizedValues, valuesLock());</span>

//    // TODO does this need to be changed?
//    // modification NOTE: do not commit until go-ahead
//    // If this is a collapsed relation (indicated by a &quot;_&quot; separating
//    // the type and the dependent, instantiate a collapsed version.
//    // Currently handcode against conjunctions and prepositions, but
//    // should do this in a more robust fashion.
//    String[] tuples = s.trim().split(&quot;_&quot;, 2);
//    if (tuples.length == 2) {
//      String reln = tuples[0];
//      String specific = tuples[1];
//      if (reln.equals(PREPOSITIONAL_MODIFIER.getShortName())) {
//        return getPrep(specific);
//      } else if (reln.equals(CONJUNCT.getShortName())) {
//        return getConj(specific);
//      }
//    }
//
//    return null;
  }

  /**
   * Returns an EnglishGrammaticalRelation based on the argument.
   * It works if passed a GrammaticalRelation or the String
   * representation of one (e.g., &quot;nsubj&quot;).  It returns {@code null}
   * for other classes or if no string match is found.
   *
   * @param o A GrammaticalRelation or String
   * @return The EnglishGrammaticalRelation with that name
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static GrammaticalRelation valueOf(Object o) {
<span class="nc bnc" id="L1857" title="All 2 branches missed.">    if (o instanceof GrammaticalRelation) {</span>
<span class="nc" id="L1858">      return (GrammaticalRelation) o;</span>
<span class="nc bnc" id="L1859" title="All 2 branches missed.">    } else if (o instanceof String) {</span>
<span class="nc" id="L1860">      return valueOf((String) o);</span>
    } else {
<span class="nc" id="L1862">      return null;</span>
    }
  }

  /**
   * Prints out the English grammatical relations hierarchy.
   * See {@code EnglishGrammaticalStructure} for a main method that
   * will print the grammatical relations of a sentence or tree.
   *
   * @param args Args are ignored.
   */
  public static void main(String[] args) {
<span class="nc" id="L1874">    System.out.println(DEPENDENT.toPrettyString());</span>
<span class="nc" id="L1875">  }</span>

}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>