<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SemanticHeadFinder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.trees</a> &gt; <span class="el_source">SemanticHeadFinder.java</span></div><h1>SemanticHeadFinder.java</h1><pre class="source lang-java linenums">// SemanticHeadFinder -- An implementation of content-word heads.
// Copyright (c) 2005 - 2014 The Board of Trustees of
// The Leland Stanford Junior University. All Rights Reserved.
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software Foundation,
// Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
//
// For more information, bug reports, fixes, contact:
//    Christopher Manning
//    Dept of Computer Science, Gates 1A
//    Stanford CA 94305-9010
//    USA
//    parser-support@lists.stanford.edu
//    http://nlp.stanford.edu/software/stanford-dependencies.shtml

package edu.stanford.nlp.trees; 
import edu.stanford.nlp.util.logging.Redwood;

import edu.stanford.nlp.ling.HasCategory;
import edu.stanford.nlp.ling.HasTag;
import edu.stanford.nlp.ling.HasWord;
import edu.stanford.nlp.ling.Label;
import edu.stanford.nlp.trees.tregex.TregexMatcher;
import edu.stanford.nlp.trees.tregex.TregexPattern;
import edu.stanford.nlp.util.ArrayUtils;
import java.util.function.Predicate;
import edu.stanford.nlp.util.Generics;

import java.util.Arrays;
import java.util.List;
import java.util.Set;


/**
 * Implements a 'semantic head' variant of the the English HeadFinder
 * found in Michael Collins' 1999 thesis.
 * This use of mainly content words as heads is used for determining
 * the dependency structure in English Stanford Dependencies (SD).
 * This version chooses the semantic head verb rather than the verb form
 * for cases with verbs.  And it makes similar themed changes to other
 * categories: e.g., in question phrases, like &quot;Which Brazilian game&quot;, the
 * head is made &quot;game&quot; not &quot;Which&quot; as in common PTB head rules.&lt;p/&gt;
 * &lt;p/&gt;
 * By default the SemanticHeadFinder uses a treatment of copula where the
 * complement of the copula is taken as the head.  That is, a sentence like
 * &quot;Bill is big&quot; will be analyzed as &lt;p/&gt;
 * &lt;p/&gt;
 * &lt;code&gt;nsubj&lt;/code&gt;(big, Bill) &lt;br/&gt;
 * &lt;code&gt;cop&lt;/code&gt;(big, is) &lt;p/&gt;
 * &lt;p/&gt;
 * This analysis is used for questions and declaratives for adjective
 * complements and declarative nominal complements.  However Wh-sentences
 * with nominal complements do not receive this treatment.
 * &quot;Who is the president?&quot; is analyzed with &quot;the president&quot; as nsubj and &quot;who&quot;
 * as &quot;attr&quot; of the copula:&lt;p/&gt;&lt;p&gt;
 * &lt;code&gt;nsubj&lt;/code&gt;(is, president)&lt;br/&gt;
 * &lt;code&gt;attr&lt;/code&gt;(is, Who) &lt;p/&gt;
 * &lt;p/&gt;
 * (Such nominal copula sentences are complex: arguably, depending on the
 * circumstances, several analyses are possible, with either the overt NP able
 * to be any of the subject, the predicate, or one of two referential entities
 * connected by an equational copula.  These uses aren't differentiated.)
 * &lt;p/&gt;
 * Existential sentences are treated as follows:  &lt;br/&gt;
 * &quot;There is a man&quot; &lt;br/&gt;
 * &lt;code&gt;expl&lt;/code&gt;(is, There) &lt;br/&gt;
 * &lt;code&gt;det&lt;/code&gt;(man-4, a-3) &lt;br/&gt;
 * &lt;code&gt;nsubj&lt;/code&gt;(is-2, man-4)&lt;br/&gt;
 *
 * @author John Rappaport
 * @author Marie-Catherine de Marneffe
 * @author Anna Rafferty
 */
public class SemanticHeadFinder extends ModCollinsHeadFinder  {

  /** A logger for this class */
<span class="fc" id="L88">  private static Redwood.RedwoodChannels log = Redwood.channels(SemanticHeadFinder.class);</span>

<span class="pc bpc" id="L90" title="1 of 2 branches missed.">  private static final boolean DEBUG = System.getProperty(&quot;SemanticHeadFinder&quot;, null) != null;</span>

  /* A few times the apostrophe is missing on &quot;'s&quot;, so we have &quot;s&quot; */
  /* Tricky auxiliaries: &quot;a&quot;, &quot;na&quot; is from &quot;(gon|wan)na&quot;, &quot;ve&quot; from &quot;Weve&quot;, etc.  &quot;of&quot; as non-standard for &quot;have&quot; */
  /* &quot;as&quot; is &quot;has&quot; with missing first letter. &quot;to&quot; is rendered &quot;the&quot; once in EWT. */
<span class="fc" id="L95">  private static final String[] auxiliaries = {</span>
          &quot;will&quot;, &quot;wo&quot;, &quot;shall&quot;, &quot;sha&quot;, &quot;may&quot;, &quot;might&quot;, &quot;should&quot;, &quot;would&quot;, &quot;can&quot;, &quot;could&quot;, &quot;ca&quot;, &quot;must&quot;, &quot;'ll&quot;, &quot;ll&quot;, &quot;-ll&quot;, &quot;cold&quot;,
          &quot;has&quot;, &quot;have&quot;, &quot;had&quot;, &quot;having&quot;, &quot;'ve&quot;, &quot;ve&quot;, &quot;v&quot;, &quot;of&quot;, &quot;hav&quot;, &quot;hvae&quot;, &quot;as&quot;,
          &quot;get&quot;, &quot;gets&quot;, &quot;getting&quot;, &quot;got&quot;, &quot;gotten&quot;, &quot;do&quot;, &quot;does&quot;, &quot;did&quot;, &quot;'d&quot;, &quot;d&quot;, &quot;du&quot;,
          &quot;to&quot;, &quot;2&quot;, &quot;na&quot;, &quot;a&quot;, &quot;ot&quot;, &quot;ta&quot;, &quot;the&quot;, &quot;too&quot; };

  // include Charniak tags (AUX, AUXG) so can do BLLIP right
<span class="fc" id="L102">  private static final String[] verbTags = {&quot;TO&quot;, &quot;MD&quot;, &quot;VB&quot;, &quot;VBD&quot;, &quot;VBP&quot;, &quot;VBZ&quot;, &quot;VBG&quot;, &quot;VBN&quot;, &quot;AUX&quot;, &quot;AUXG&quot;};</span>
  // These ones are always auxiliaries, even if the word is &quot;too&quot;, &quot;my&quot;, or whatever else appears in web text.
<span class="fc" id="L104">  private static final String[] unambiguousAuxTags = {&quot;TO&quot;, &quot;MD&quot;, &quot;AUX&quot;, &quot;AUXG&quot;};</span>


  private final Set&lt;String&gt; verbalAuxiliaries;
  private final Set&lt;String&gt; copulars;
  private final Set&lt;String&gt; passiveAuxiliaries;
  private final Set&lt;String&gt; verbalTags;
  private final Set&lt;String&gt; unambiguousAuxiliaryTags;

  private final boolean makeCopulaHead;


  public SemanticHeadFinder() {
<span class="fc" id="L117">    this(new PennTreebankLanguagePack(), true);</span>
<span class="fc" id="L118">  }</span>

  public SemanticHeadFinder(boolean noCopulaHead) {
<span class="fc" id="L121">    this(new PennTreebankLanguagePack(), noCopulaHead);</span>
<span class="fc" id="L122">  }</span>


  /** Create a SemanticHeadFinder.
   *
   * @param tlp The TreebankLanguagePack, used by the superclass to get basic
   *     category of constituents.
   * @param noCopulaHead If true, a copular verb (a form of be)
   *     is not treated as head when it has an AdjP or NP complement.  If false,
   *     a copula verb is still always treated as a head.  But it will still
   *     be treated as an auxiliary in periphrastic tenses with a VP complement.
   */
  public SemanticHeadFinder(TreebankLanguagePack tlp, boolean noCopulaHead) {
<span class="fc" id="L135">    super(tlp);</span>

    // TODO: reverse the polarity of noCopulaHead
<span class="fc bfc" id="L138" title="All 2 branches covered.">    this.makeCopulaHead = !noCopulaHead;</span>

<span class="fc" id="L140">    ruleChanges();</span>

    // make a distinction between auxiliaries and copula verbs to
    // get the NP has semantic head in sentences like &quot;Bill is an honest man&quot;.  (Added &quot;sha&quot; for &quot;shan't&quot; May 2009
<span class="fc" id="L144">    verbalAuxiliaries = Generics.newHashSet(Arrays.asList(auxiliaries));</span>

<span class="fc" id="L146">    passiveAuxiliaries = Generics.newHashSet(Arrays.asList(EnglishPatterns.beGetVerbs));</span>

    //copula verbs having an NP complement
<span class="fc" id="L149">    copulars = Generics.newHashSet();</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">    if (noCopulaHead) {</span>
<span class="fc" id="L151">      copulars.addAll(Arrays.asList(EnglishPatterns.copularVerbs));</span>
    }

<span class="fc" id="L154">    verbalTags = Generics.newHashSet(Arrays.asList(verbTags));</span>
<span class="fc" id="L155">    unambiguousAuxiliaryTags = Generics.newHashSet(Arrays.asList(unambiguousAuxTags));</span>
<span class="fc" id="L156">  }</span>

  @Override
  public boolean makesCopulaHead() {
<span class="fc" id="L160">    return makeCopulaHead;</span>
  }

  //makes modifications of Collins' rules to better fit with semantic notions of heads
  private void ruleChanges() {
    //  NP: don't want a POS to be the head
    // verbs are here so that POS isn't favored in the case of bad parses
<span class="fc" id="L167">    nonTerminalInfo.put(&quot;NP&quot;, new String[][]{{&quot;rightdis&quot;, &quot;NN&quot;, &quot;NNP&quot;, &quot;NNPS&quot;, &quot;NNS&quot;, &quot;NX&quot;, &quot;NML&quot;, &quot;JJR&quot;, &quot;WP&quot; }, {&quot;left&quot;, &quot;NP&quot;, &quot;PRP&quot;}, {&quot;rightdis&quot;, &quot;$&quot;, &quot;ADJP&quot;, &quot;FW&quot;}, {&quot;right&quot;, &quot;CD&quot;}, {&quot;rightdis&quot;, &quot;JJ&quot;, &quot;JJS&quot;, &quot;QP&quot;, &quot;DT&quot;, &quot;WDT&quot;, &quot;NML&quot;, &quot;PRN&quot;, &quot;RB&quot;, &quot;RBR&quot;, &quot;ADVP&quot;}, {&quot;rightdis&quot;, &quot;VP&quot;, &quot;VB&quot;, &quot;VBZ&quot;, &quot;VBD&quot;, &quot;VBP&quot;}, {&quot;left&quot;, &quot;POS&quot;}});</span>
<span class="fc" id="L168">    nonTerminalInfo.put(&quot;NX&quot;, nonTerminalInfo.get(&quot;NP&quot;));</span>
<span class="fc" id="L169">    nonTerminalInfo.put(&quot;NML&quot;, nonTerminalInfo.get(&quot;NP&quot;));</span>
    // WHNP clauses should have the same sort of head as an NP
    // but it a WHNP has a NP and a WHNP under it, the WHNP should be the head.  E.g.,  (WHNP (WHNP (WP$ whose) (JJ chief) (JJ executive) (NN officer))(, ,) (NP (NNP James) (NNP Gatward))(, ,))
<span class="fc" id="L172">    nonTerminalInfo.put(&quot;WHNP&quot;, new String[][]{{&quot;rightdis&quot;, &quot;NN&quot;, &quot;NNP&quot;, &quot;NNPS&quot;, &quot;NNS&quot;, &quot;NX&quot;, &quot;NML&quot;, &quot;JJR&quot;, &quot;WP&quot;}, {&quot;left&quot;, &quot;WHNP&quot;, &quot;NP&quot;}, {&quot;rightdis&quot;, &quot;$&quot;, &quot;ADJP&quot;, &quot;PRN&quot;, &quot;FW&quot;}, {&quot;right&quot;, &quot;CD&quot;}, {&quot;rightdis&quot;, &quot;JJ&quot;, &quot;JJS&quot;, &quot;RB&quot;, &quot;QP&quot;}, {&quot;left&quot;, &quot;WHPP&quot;, &quot;WHADJP&quot;, &quot;WP$&quot;, &quot;WDT&quot;}});</span>
    //WHADJP
<span class="fc" id="L174">    nonTerminalInfo.put(&quot;WHADJP&quot;, new String[][]{{&quot;left&quot;, &quot;ADJP&quot;, &quot;JJ&quot;, &quot;JJR&quot;, &quot;WP&quot;}, {&quot;right&quot;, &quot;RB&quot;}, {&quot;right&quot;}});</span>
    //WHADJP
<span class="fc" id="L176">    nonTerminalInfo.put(&quot;WHADVP&quot;, new String[][]{{&quot;rightdis&quot;, &quot;WRB&quot;, &quot;WHADVP&quot;, &quot;RB&quot;, &quot;JJ&quot;}}); // if not WRB or WHADVP, probably has flat NP structure, allow JJ for &quot;how long&quot; constructions</span>
    // QP: we don't want the first CD to be the semantic head (e.g., &quot;three billion&quot;: head should be &quot;billion&quot;), so we go from right to left
<span class="fc" id="L178">    nonTerminalInfo.put(&quot;QP&quot;, new String[][]{{&quot;right&quot;, &quot;$&quot;, &quot;NNS&quot;, &quot;NN&quot;, &quot;CD&quot;, &quot;JJ&quot;, &quot;PDT&quot;, &quot;DT&quot;, &quot;IN&quot;, &quot;RB&quot;, &quot;NCD&quot;, &quot;QP&quot;, &quot;JJR&quot;, &quot;JJS&quot;}});</span>

    // S, SBAR and SQ clauses should prefer the main verb as the head
    // S: &quot;He considered him a friend&quot; -&gt; we want a friend to be the head
<span class="fc" id="L182">    nonTerminalInfo.put(&quot;S&quot;, new String[][]{{&quot;left&quot;, &quot;VP&quot;, &quot;S&quot;, &quot;FRAG&quot;, &quot;SBAR&quot;, &quot;ADJP&quot;, &quot;UCP&quot;, &quot;TO&quot;}, {&quot;right&quot;, &quot;NP&quot;}});</span>

<span class="fc" id="L184">    nonTerminalInfo.put(&quot;SBAR&quot;, new String[][]{{&quot;left&quot;, &quot;S&quot;, &quot;SQ&quot;, &quot;SINV&quot;, &quot;SBAR&quot;, &quot;FRAG&quot;, &quot;VP&quot;, &quot;WHNP&quot;, &quot;WHPP&quot;, &quot;WHADVP&quot;, &quot;WHADJP&quot;, &quot;IN&quot;, &quot;DT&quot;}});</span>
    // VP shouldn't be needed in SBAR, but occurs in one buggy tree in PTB3 wsj_1457 and otherwise does no harm

<span class="fc bfc" id="L187" title="All 2 branches covered.">    if (makeCopulaHead) {</span>
<span class="fc" id="L188">      nonTerminalInfo.put(&quot;SQ&quot;, new String[][]{{&quot;left&quot;, &quot;VP&quot;, &quot;SQ&quot;, &quot;VB&quot;, &quot;VBZ&quot;, &quot;VBD&quot;, &quot;VBP&quot;, &quot;MD&quot;, &quot;AUX&quot;, &quot;AUXG&quot;, &quot;ADJP&quot;}});</span>
    } else {
<span class="fc" id="L190">      nonTerminalInfo.put(&quot;SQ&quot;, new String[][]{{&quot;left&quot;, &quot;VP&quot;, &quot;SQ&quot;, &quot;ADJP&quot;, &quot;VB&quot;, &quot;VBZ&quot;, &quot;VBD&quot;, &quot;VBP&quot;, &quot;MD&quot;, &quot;AUX&quot;, &quot;AUXG&quot;}});</span>
    }

    // UCP take the first element as head
<span class="fc" id="L194">    nonTerminalInfo.put(&quot;UCP&quot;, new String[][]{{&quot;left&quot;}});</span>

    // CONJP: we want different heads for &quot;but also&quot; and &quot;but not&quot; and we don't want &quot;not&quot; to be the head in &quot;not to mention&quot;; now make &quot;mention&quot; head of &quot;not to mention&quot;
<span class="fc" id="L197">    nonTerminalInfo.put(&quot;CONJP&quot;, new String[][]{{&quot;right&quot;, &quot;CC&quot;, &quot;VB&quot;, &quot;JJ&quot;, &quot;RB&quot;, &quot;IN&quot; }});</span>

    // FRAG: crap rule needs to be change if you want to parse
    // glosses; but it is correct to have ADJP and ADVP before S
    // because of weird parses of reduced sentences.
<span class="fc" id="L202">    nonTerminalInfo.put(&quot;FRAG&quot;, new String[][]{{&quot;left&quot;, &quot;IN&quot;}, {&quot;right&quot;, &quot;RB&quot;}, {&quot;left&quot;, &quot;NP&quot;}, {&quot;left&quot;, &quot;ADJP&quot;, &quot;ADVP&quot;, &quot;FRAG&quot;, &quot;S&quot;, &quot;SBAR&quot;, &quot;VP&quot;}});</span>

    // PRN: sentence first
<span class="fc" id="L205">    nonTerminalInfo.put(&quot;PRN&quot;, new String[][]{{&quot;left&quot;, &quot;VP&quot;, &quot;SQ&quot;, &quot;S&quot;, &quot;SINV&quot;, &quot;SBAR&quot;, &quot;NP&quot;, &quot;ADJP&quot;, &quot;PP&quot;, &quot;ADVP&quot;, &quot;INTJ&quot;, &quot;WHNP&quot;, &quot;NAC&quot;, &quot;VBP&quot;, &quot;JJ&quot;, &quot;NN&quot;, &quot;NNP&quot;}});</span>

    // add the constituent XS (special node to add a layer in a QP tree introduced in our QPTreeTransformer)
<span class="fc" id="L208">    nonTerminalInfo.put(&quot;XS&quot;, new String[][]{{&quot;right&quot;, &quot;IN&quot;}});</span>

    // add a rule to deal with the CoNLL data
<span class="fc" id="L211">    nonTerminalInfo.put(&quot;EMBED&quot;, new String[][]{{&quot;right&quot;, &quot;INTJ&quot;}});</span>

<span class="fc" id="L213">  }</span>


  private boolean shouldSkip(Tree t, boolean origWasInterjection) {
<span class="pc bpc" id="L217" title="2 of 8 branches missed.">    return t.isPreTerminal() &amp;&amp; (tlp.isPunctuationTag(t.value()) || ! origWasInterjection &amp;&amp; &quot;UH&quot;.equals(t.value())) ||</span>
<span class="pc bpc" id="L218" title="3 of 4 branches missed.">           &quot;INTJ&quot;.equals(t.value()) &amp;&amp; ! origWasInterjection;</span>
  }

  private int findPreviousHead(int headIdx, Tree[] daughterTrees, boolean origWasInterjection) {
<span class="fc" id="L222">    boolean seenSeparator = false;</span>
<span class="fc" id="L223">    int newHeadIdx = headIdx;</span>
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">    while (newHeadIdx &gt;= 0) {</span>
<span class="fc" id="L225">      newHeadIdx = newHeadIdx - 1;</span>
<span class="pc bpc" id="L226" title="1 of 2 branches missed.">      if (newHeadIdx &lt; 0) {</span>
<span class="nc" id="L227">        return newHeadIdx;</span>
      }
<span class="fc" id="L229">      String label = tlp.basicCategory(daughterTrees[newHeadIdx].value());</span>
<span class="fc bfc" id="L230" title="All 4 branches covered.">      if (&quot;,&quot;.equals(label) || &quot;:&quot;.equals(label)) {</span>
<span class="fc" id="L231">        seenSeparator = true;</span>
<span class="pc bpc" id="L232" title="3 of 8 branches missed.">      } else if (daughterTrees[newHeadIdx].isPreTerminal() &amp;&amp; (tlp.isPunctuationTag(label) || ! origWasInterjection &amp;&amp; &quot;UH&quot;.equals(label)) ||</span>
<span class="pc bpc" id="L233" title="3 of 4 branches missed.">               &quot;INTJ&quot;.equals(label) &amp;&amp; ! origWasInterjection) {</span>
        // keep looping
      } else {
<span class="fc bfc" id="L236" title="All 2 branches covered.">        if ( ! seenSeparator) {</span>
<span class="fc" id="L237">          newHeadIdx = -1;</span>
        }
        break;
      }
<span class="fc" id="L241">    }</span>
<span class="fc" id="L242">    return newHeadIdx;</span>
  }

  /**
   * Overwrite the postOperationFix method.  For &quot;a, b and c&quot; or similar: we want &quot;a&quot; to be the head.
   */
  @Override
  protected int postOperationFix(int headIdx, Tree[] daughterTrees) {
<span class="fc bfc" id="L250" title="All 2 branches covered.">    if (headIdx &gt;= 2) {</span>
<span class="fc" id="L251">      String prevLab = tlp.basicCategory(daughterTrees[headIdx - 1].value());</span>
<span class="pc bpc" id="L252" title="1 of 4 branches missed.">      if (prevLab.equals(&quot;CC&quot;) || prevLab.equals(&quot;CONJP&quot;)) {</span>
<span class="fc" id="L253">        boolean origWasInterjection = &quot;UH&quot;.equals(tlp.basicCategory(daughterTrees[headIdx].value()));</span>
<span class="fc" id="L254">        int newHeadIdx = headIdx - 2;</span>
        // newHeadIdx is now left of conjunction.  Now try going back over commas, etc. for 3+ conjuncts
        // Don't allow INTJ unless conjoined with INTJ - important in informal genres &quot;Oh and don't forget to call!&quot;
<span class="pc bpc" id="L257" title="1 of 4 branches missed.">        while (newHeadIdx &gt;= 0 &amp;&amp; shouldSkip(daughterTrees[newHeadIdx], origWasInterjection)) {</span>
<span class="fc" id="L258">          newHeadIdx--;</span>
        }
        // We're now at newHeadIdx &lt; 0 or have found a left head
        // Now consider going back some number of punct that includes a , or : tagged thing and then find non-punct
<span class="fc bfc" id="L262" title="All 2 branches covered.">        while (newHeadIdx &gt;= 2) {</span>
<span class="fc" id="L263">          int nextHead = findPreviousHead(newHeadIdx, daughterTrees, origWasInterjection);</span>
<span class="fc bfc" id="L264" title="All 2 branches covered.">          if (nextHead &lt; 0) {</span>
<span class="fc" id="L265">            break;</span>
          }
<span class="fc" id="L267">          newHeadIdx = nextHead;</span>
<span class="fc" id="L268">        }</span>
<span class="pc bpc" id="L269" title="1 of 2 branches missed.">        if (newHeadIdx &gt;= 0) {</span>
<span class="fc" id="L270">          headIdx = newHeadIdx;</span>
        }
      }
    }
<span class="fc" id="L274">    return headIdx;</span>
  }

  // Note: The first two SBARQ patterns only work when the SQ
  // structure has already been removed in CoordinationTransformer.
<span class="fc" id="L279">  static final TregexPattern[] headOfCopulaTregex = {</span>
    // Matches phrases such as &quot;what is wrong&quot;
<span class="fc" id="L281">    TregexPattern.compile(&quot;SBARQ &lt; (WHNP $++ (/^VB/ &lt; &quot; + EnglishPatterns.copularWordRegex + &quot; $++ ADJP=head))&quot;),</span>

    // matches WHNP $+ VB&lt;copula $+ NP
    // for example, &quot;Who am I to judge?&quot;
    // !$++ ADJP matches against &quot;Why is the dog pink?&quot;
<span class="fc" id="L286">    TregexPattern.compile(&quot;SBARQ &lt; (WHNP=head $++ (/^VB/ &lt; &quot; + EnglishPatterns.copularWordRegex + &quot; $+ NP !$++ ADJP))&quot;),</span>

    // Actually somewhat limited in scope, this detects &quot;Tuesday it is&quot;,
    // &quot;Such a great idea this was&quot;, etc
<span class="fc" id="L290">    TregexPattern.compile(&quot;SINV &lt; (NP=head $++ (NP $++ (VP &lt; (/^(?:VB|AUX)/ &lt; &quot; + EnglishPatterns.copularWordRegex + &quot;))))&quot;),</span>
  };

<span class="fc" id="L293">  static final TregexPattern[] headOfConjpTregex = {</span>
<span class="fc" id="L294">    TregexPattern.compile(&quot;CONJP &lt; (CC &lt;: /^(?i:but|and)$/ $+ (RB=head &lt;: /^(?i:not)$/))&quot;),</span>
<span class="fc" id="L295">    TregexPattern.compile(&quot;CONJP &lt; (CC &lt;: /^(?i:but)$/ [ ($+ (RB=head &lt;: /^(?i:also|rather)$/)) | ($+ (ADVP=head &lt;: (RB &lt;: /^(?i:also|rather)$/))) ])&quot;),</span>
<span class="fc" id="L296">    TregexPattern.compile(&quot;CONJP &lt; (CC &lt;: /^(?i:and)$/ [ ($+ (RB=head &lt;: /^(?i:yet)$/)) | ($+ (ADVP=head &lt;: (RB &lt;: /^(?i:yet)$/))) ])&quot;),</span>
  };

<span class="fc" id="L299">  static final TregexPattern noVerbOverTempTregex = TregexPattern.compile(&quot;/^VP/ &lt; NP-TMP !&lt; /^V/ !&lt; NNP|NN|NNPS|NNS|NP|JJ|ADJP|S&quot;);</span>

  /**
   * We use this to avoid making a -TMP or -ADV the head of a copular phrase.
   * For example, in the sentence &quot;It is hands down the best dessert ...&quot;,
   * we want to avoid using &quot;hands down&quot; as the head.
   */
<span class="fc" id="L306">  static final Predicate&lt;Tree&gt; REMOVE_TMP_AND_ADV = tree -&gt; {</span>
<span class="pc bpc" id="L307" title="1 of 2 branches missed.">    if (tree == null)</span>
<span class="nc" id="L308">      return false;</span>
<span class="fc" id="L309">    Label label = tree.label();</span>
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">    if (label == null)</span>
<span class="nc" id="L311">      return false;</span>
<span class="pc bpc" id="L312" title="2 of 4 branches missed.">    if (label.value().contains(&quot;-TMP&quot;) || label.value().contains(&quot;-ADV&quot;))</span>
<span class="nc" id="L313">      return false;</span>
<span class="pc bpc" id="L314" title="1 of 4 branches missed.">    if (label.value().startsWith(&quot;VP&quot;) &amp;&amp; noVerbOverTempTregex.matcher(tree).matches()) {</span>
<span class="nc" id="L315">      return false;</span>
    }
<span class="fc" id="L317">    return true;</span>
  };

  /**
   * Determine which daughter of the current parse tree is the
   * head.  It assumes that the daughters already have had their
   * heads determined.  Uses special rule for VP heads
   *
   * @param t The parse tree to examine the daughters of.
   *          This is assumed to never be a leaf
   * @return The parse tree that is the head
   */
  @Override
  protected Tree determineNonTrivialHead(Tree t, Tree parent) {
<span class="fc" id="L331">    String motherCat = tlp.basicCategory(t.label().value());</span>

<span class="pc bpc" id="L333" title="1 of 2 branches missed.">    if (DEBUG) {</span>
<span class="nc" id="L334">      log.info(&quot;At &quot; + motherCat + &quot;, my parent is &quot; + parent);</span>
    }

    // Some conj expressions seem to make more sense with the &quot;not&quot; or
    // other key words as the head.  For example, &quot;and not&quot; means
    // something completely different than &quot;and&quot;.  Furthermore,
    // downstream code was written assuming &quot;not&quot; would be the head...
<span class="fc bfc" id="L341" title="All 2 branches covered.">    if (motherCat.equals(&quot;CONJP&quot;)) {</span>
<span class="fc bfc" id="L342" title="All 2 branches covered.">      for (TregexPattern pattern : headOfConjpTregex) {</span>
<span class="fc" id="L343">        TregexMatcher matcher = pattern.matcher(t);</span>
<span class="fc bfc" id="L344" title="All 2 branches covered.">        if (matcher.matchesAt(t)) {</span>
<span class="fc" id="L345">          return matcher.getNode(&quot;head&quot;);</span>
        }
      }
      // if none of the above patterns match, use the standard method
    }

<span class="fc bfc" id="L351" title="All 4 branches covered.">    if (motherCat.equals(&quot;SBARQ&quot;) || motherCat.equals(&quot;SINV&quot;)) {</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">      if (!makeCopulaHead) {</span>
<span class="fc bfc" id="L353" title="All 2 branches covered.">        for (TregexPattern pattern : headOfCopulaTregex) {</span>
<span class="fc" id="L354">          TregexMatcher matcher = pattern.matcher(t);</span>
<span class="fc bfc" id="L355" title="All 2 branches covered.">          if (matcher.matchesAt(t)) {</span>
<span class="fc" id="L356">            return matcher.getNode(&quot;head&quot;);</span>
          }
        }
      }
      // if none of the above patterns match, use the standard method
    }

    // do VPs with auxiliary as special case
<span class="fc bfc" id="L364" title="All 6 branches covered.">    if ((motherCat.equals(&quot;VP&quot;) || motherCat.equals(&quot;SQ&quot;) || motherCat.equals(&quot;SINV&quot;))) {</span>
<span class="fc" id="L365">      Tree[] kids = t.children();</span>
      // try to find if there is an auxiliary verb

<span class="pc bpc" id="L368" title="1 of 2 branches missed.">      if (DEBUG) {</span>
<span class="nc" id="L369">        log.info(&quot;Semantic head finder: at VP&quot;);</span>
<span class="nc" id="L370">        log.info(&quot;Class is &quot; + t.getClass().getName());</span>
<span class="nc" id="L371">        t.pennPrint(System.err);</span>
        //log.info(&quot;hasVerbalAuxiliary = &quot; + hasVerbalAuxiliary(kids, verbalAuxiliaries));
      }

      // looks for auxiliaries
<span class="fc" id="L376">      Tree[] tmpFilteredChildren = null;</span>
<span class="fc bfc" id="L377" title="All 4 branches covered.">      if (hasVerbalAuxiliary(kids, verbalAuxiliaries, true) || hasPassiveProgressiveAuxiliary(kids)) {</span>
        // String[] how = new String[] {&quot;left&quot;, &quot;VP&quot;, &quot;ADJP&quot;, &quot;NP&quot;};
        // Including NP etc seems okay for copular sentences but is
        // problematic for other auxiliaries, like 'he has an answer'
        String[] how ;
<span class="fc bfc" id="L382" title="All 2 branches covered.">        if (hasVerbalAuxiliary(kids, copulars, true)) {</span>
          // Only allow ADJP in copular constructions
          // In constructions like &quot;It gets cold&quot;, &quot;get&quot; should be the head
<span class="fc" id="L385">          how = new String[]{ &quot;left&quot;, &quot;VP&quot;, &quot;ADJP&quot; };</span>
        } else {
<span class="fc" id="L387">          how = new String[]{ &quot;left&quot;, &quot;VP&quot; };</span>
        }

<span class="pc bpc" id="L390" title="1 of 2 branches missed.">        if (tmpFilteredChildren == null) {</span>
<span class="fc" id="L391">          tmpFilteredChildren = ArrayUtils.filter(kids, REMOVE_TMP_AND_ADV);</span>
        }
<span class="fc" id="L393">        Tree pti = traverseLocate(tmpFilteredChildren, how, false);</span>
<span class="pc bpc" id="L394" title="1 of 2 branches missed.">        if (DEBUG) {</span>
<span class="nc" id="L395">          log.info(&quot;Determined head (case 1) for &quot; + t.value() + &quot; is: &quot; + pti);</span>
        }
<span class="fc bfc" id="L397" title="All 2 branches covered.">        if (pti != null) {</span>
<span class="fc" id="L398">          return pti;</span>
        // } else {
          // log.info(&quot;------&quot;);
          // log.info(&quot;SemanticHeadFinder failed to reassign head for&quot;);
          // t.pennPrint(System.err);
          // log.info(&quot;------&quot;);
        }
      }

      // looks for copular verbs
<span class="fc bfc" id="L408" title="All 6 branches covered.">      if (hasVerbalAuxiliary(kids, copulars, false) &amp;&amp; ! isExistential(t, parent) &amp;&amp; ! isWHQ(t, parent)) {</span>
        String[] how;
<span class="fc bfc" id="L410" title="All 2 branches covered.">        if (motherCat.equals(&quot;SQ&quot;)) {</span>
<span class="fc" id="L411">          how = new String[]{&quot;right&quot;, &quot;VP&quot;, &quot;ADJP&quot;, &quot;NP&quot;, &quot;WHADJP&quot;, &quot;WHNP&quot;};</span>
        } else {
<span class="fc" id="L413">          how = new String[]{&quot;left&quot;, &quot;VP&quot;, &quot;ADJP&quot;, &quot;NP&quot;, &quot;WHADJP&quot;, &quot;WHNP&quot;};</span>
        }
        // Avoid undesirable heads by filtering them from the list of potential children
<span class="pc bpc" id="L416" title="1 of 2 branches missed.">        if (tmpFilteredChildren == null) {</span>
<span class="fc" id="L417">          tmpFilteredChildren = ArrayUtils.filter(kids, REMOVE_TMP_AND_ADV);</span>
        }
<span class="fc" id="L419">        Tree pti = traverseLocate(tmpFilteredChildren, how, false);</span>
        // In SQ, only allow an NP to become head if there is another one to the left (then it's probably predicative)
<span class="pc bpc" id="L421" title="3 of 8 branches missed.">        if (motherCat.equals(&quot;SQ&quot;) &amp;&amp; pti != null &amp;&amp; pti.label() != null &amp;&amp; pti.label().value().startsWith(&quot;NP&quot;)) {</span>
<span class="fc" id="L422">            boolean foundAnotherNp = false;</span>
<span class="pc bpc" id="L423" title="1 of 2 branches missed.">            for (Tree kid : kids) {</span>
<span class="fc bfc" id="L424" title="All 2 branches covered.">              if (kid == pti) {</span>
<span class="fc" id="L425">                break;</span>
<span class="pc bpc" id="L426" title="1 of 4 branches missed.">              } else if (kid.label() != null &amp;&amp; kid.label().value().startsWith(&quot;NP&quot;)) {</span>
<span class="fc" id="L427">                foundAnotherNp = true;</span>
<span class="fc" id="L428">                break;</span>
              }
            }
<span class="fc bfc" id="L431" title="All 2 branches covered.">          if ( ! foundAnotherNp) {</span>
<span class="fc" id="L432">            pti = null;</span>
          }
        }

<span class="pc bpc" id="L436" title="1 of 2 branches missed.">        if (DEBUG) {</span>
<span class="nc" id="L437">          log.info(&quot;Determined head (case 2) for &quot; + t.value() + &quot; is: &quot; + pti);</span>
        }
<span class="fc bfc" id="L439" title="All 2 branches covered.">        if (pti != null) {</span>
<span class="fc" id="L440">          return pti;</span>
        } else {
<span class="pc bpc" id="L442" title="1 of 2 branches missed.">          if (DEBUG) {</span>
<span class="nc" id="L443">            log.info(&quot;------&quot;);</span>
<span class="nc" id="L444">            log.info(&quot;SemanticHeadFinder failed to reassign head for&quot;);</span>
<span class="nc" id="L445">            t.pennPrint(System.err);</span>
<span class="nc" id="L446">            log.info(&quot;------&quot;);</span>
          }
        }
      }
    }

<span class="fc" id="L452">    Tree hd = super.determineNonTrivialHead(t, parent);</span>

    /* ----
    // This should now be handled at the AbstractCollinsHeadFinder level, so see if we can comment this out
    // Heuristically repair punctuation heads
    Tree[] hdChildren = hd.children();
    if (hdChildren != null &amp;&amp; hdChildren.length &gt; 0 &amp;&amp;
        hdChildren[0].isLeaf()) {
      if (tlp.isPunctuationWord(hdChildren[0].label().value())) {
         Tree[] tChildren = t.children();
         if (DEBUG) {
           System.err.printf(&quot;head is punct: %s\n&quot;, hdChildren[0].label());
         }
         for (int i = tChildren.length - 1; i &gt;= 0; i--) {
           if (!tlp.isPunctuationWord(tChildren[i].children()[0].label().value())) {
             hd = tChildren[i];
             if (DEBUG) {
               System.err.printf(&quot;New head of %s is %s%n&quot;, hd.label(), hd.children()[0].label());
             }
             break;
           }
         }
      }
    }
    */

<span class="pc bpc" id="L478" title="1 of 2 branches missed.">    if (DEBUG) {</span>
<span class="nc" id="L479">      log.info(&quot;Determined head (case 3) for &quot; + t.value() + &quot; is: &quot; + hd);</span>
    }
<span class="fc" id="L481">    return hd;</span>
  }

  /* Checks whether the tree t is an existential constituent
   * There are two cases:
   * -- affirmative sentences in which &quot;there&quot; is a left sister of the VP
   * -- questions in which &quot;there&quot; is a daughter of the SQ.
   *
   */
  private boolean isExistential(Tree t, Tree parent) {
<span class="pc bpc" id="L491" title="1 of 2 branches missed.">    if (DEBUG) {</span>
<span class="nc" id="L492">      log.info(&quot;isExistential: &quot; + t + ' ' + parent);</span>
    }
<span class="fc" id="L494">    boolean toReturn = false;</span>
<span class="fc" id="L495">    String motherCat = tlp.basicCategory(t.label().value());</span>
    // affirmative case
<span class="fc bfc" id="L497" title="All 4 branches covered.">    if (motherCat.equals(&quot;VP&quot;) &amp;&amp; parent != null) {</span>
      //take t and the sisters
<span class="fc" id="L499">      Tree[] kids = parent.children();</span>
      // iterate over the sisters before t and checks if existential
<span class="pc bpc" id="L501" title="1 of 2 branches missed.">      for (Tree kid : kids) {</span>
<span class="fc bfc" id="L502" title="All 2 branches covered.">        if (!kid.value().equals(&quot;VP&quot;)) {</span>
<span class="fc" id="L503">          List&lt;Label&gt; tags = kid.preTerminalYield();</span>
<span class="fc bfc" id="L504" title="All 2 branches covered.">          for (Label tag : tags) {</span>
<span class="fc bfc" id="L505" title="All 2 branches covered.">            if (tag.value().equals(&quot;EX&quot;)) {</span>
<span class="fc" id="L506">              toReturn = true;</span>
            }
<span class="fc" id="L508">          }</span>
        } else {
          break;
        }
      }
<span class="fc" id="L513">    }</span>
    // question case
<span class="pc bpc" id="L515" title="1 of 4 branches missed.">    else if (motherCat.startsWith(&quot;SQ&quot;) &amp;&amp; parent != null) {</span>
      //take the daughters
<span class="fc" id="L517">      Tree[] kids = parent.children();</span>
      // iterate over the daughters and checks if existential
<span class="fc bfc" id="L519" title="All 2 branches covered.">      for (Tree kid : kids) {</span>
<span class="pc bpc" id="L520" title="1 of 2 branches missed.">        if (!kid.value().startsWith(&quot;VB&quot;)) {//not necessary to look into the verb</span>
<span class="fc" id="L521">          List&lt;Label&gt; tags = kid.preTerminalYield();</span>
<span class="fc bfc" id="L522" title="All 2 branches covered.">          for (Label tag : tags) {</span>
<span class="fc bfc" id="L523" title="All 2 branches covered.">            if (tag.value().equals(&quot;EX&quot;)) {</span>
<span class="fc" id="L524">              toReturn = true;</span>
            }
<span class="fc" id="L526">          }</span>
        }
      }
    }

<span class="pc bpc" id="L531" title="1 of 2 branches missed.">    if (DEBUG) {</span>
<span class="nc" id="L532">      log.info(&quot;decision &quot; + toReturn);</span>
    }

<span class="fc" id="L535">    return toReturn;</span>
  }


  /* Is the tree t a WH-question?
   *  At present this is only true if the tree t is a SQ having a WH.* sister
   *  and headed by a SBARQ.
   * (It was changed to looser definition in Feb 2006.)
   *
   */
  private static boolean isWHQ(Tree t, Tree parent) {
<span class="pc bpc" id="L546" title="1 of 2 branches missed.">    if (t == null) {</span>
<span class="nc" id="L547">      return false;</span>
    }
<span class="fc" id="L549">    boolean toReturn = false;</span>
<span class="fc bfc" id="L550" title="All 2 branches covered.">    if (t.value().startsWith(&quot;SQ&quot;)) {</span>
<span class="pc bpc" id="L551" title="1 of 4 branches missed.">      if (parent != null &amp;&amp; parent.value().equals(&quot;SBARQ&quot;)) {</span>
<span class="fc" id="L552">        Tree[] kids = parent.children();</span>
<span class="fc bfc" id="L553" title="All 2 branches covered.">        for (Tree kid : kids) {</span>
          // looks for a WH.*
<span class="fc bfc" id="L555" title="All 2 branches covered.">          if (kid.value().startsWith(&quot;WH&quot;)) {</span>
<span class="fc" id="L556">            toReturn = true;</span>
          }
        }
      }
    }

<span class="pc bpc" id="L562" title="1 of 2 branches missed.">    if (DEBUG) {</span>
<span class="nc" id="L563">      log.info(&quot;in isWH, decision: &quot; + toReturn + &quot; for node &quot; + t);</span>
    }

<span class="fc" id="L566">    return toReturn;</span>
  }

  private boolean isVerbalAuxiliary(Tree preterminal, Set&lt;String&gt; verbalSet, boolean allowJustTagMatch) {
<span class="fc bfc" id="L570" title="All 2 branches covered.">    if (preterminal.isPreTerminal()) {</span>
<span class="fc" id="L571">      Label kidLabel = preterminal.label();</span>
<span class="fc" id="L572">      String tag = null;</span>
<span class="pc bpc" id="L573" title="1 of 2 branches missed.">      if (kidLabel instanceof HasTag) {</span>
<span class="fc" id="L574">        tag = ((HasTag) kidLabel).tag();</span>
      }
<span class="pc bpc" id="L576" title="1 of 2 branches missed.">      if (tag == null) {</span>
<span class="fc" id="L577">        tag = preterminal.value();</span>
      }
<span class="fc" id="L579">      Label wordLabel = preterminal.firstChild().label();</span>
<span class="fc" id="L580">      String word = null;</span>
<span class="pc bpc" id="L581" title="1 of 2 branches missed.">      if (wordLabel instanceof HasWord) {</span>
<span class="fc" id="L582">        word = ((HasWord) wordLabel).word();</span>
      }
<span class="pc bpc" id="L584" title="1 of 2 branches missed.">      if (word == null) {</span>
<span class="nc" id="L585">        word = wordLabel.value();</span>
      }

<span class="pc bpc" id="L588" title="1 of 2 branches missed.">      if (DEBUG) {</span>
<span class="nc" id="L589">        log.info(&quot;Checking &quot; + preterminal.value() + &quot; head is &quot; + word + '/' + tag);</span>
      }
<span class="fc" id="L591">      String lcWord = word.toLowerCase();</span>
<span class="fc bfc" id="L592" title="All 8 branches covered.">      if (allowJustTagMatch &amp;&amp; unambiguousAuxiliaryTags.contains(tag) || verbalTags.contains(tag) &amp;&amp; verbalSet.contains(lcWord)) {</span>
<span class="pc bpc" id="L593" title="1 of 2 branches missed.">        if (DEBUG) {</span>
<span class="nc" id="L594">          log.info(&quot;isAuxiliary found desired type of aux&quot;);</span>
        }
<span class="fc" id="L596">        return true;</span>
      }
    }
<span class="fc" id="L599">    return false;</span>
  }

  /**
   * Returns true if this tree is a preterminal that is a verbal auxiliary.
   *
   * @param t A tree to examine for being an auxiliary.
   * @return Whether it is a verbal auxiliary (be, do, have, get)
   */
  public boolean isVerbalAuxiliary(Tree t) {
<span class="nc" id="L609">    return isVerbalAuxiliary(t, verbalAuxiliaries, true);</span>
  }


  // now overly complex so it deals with coordinations.  Maybe change this class to use tregrex?f
  private boolean hasPassiveProgressiveAuxiliary(Tree[] kids) {
<span class="pc bpc" id="L615" title="1 of 2 branches missed.">    if (DEBUG) {</span>
<span class="nc" id="L616">      log.info(&quot;Checking for passive/progressive auxiliary&quot;);</span>
    }
<span class="fc" id="L618">    boolean foundPassiveVP = false;</span>
<span class="fc" id="L619">    boolean foundPassiveAux = false;</span>
<span class="fc bfc" id="L620" title="All 2 branches covered.">    for (Tree kid : kids) {</span>
<span class="pc bpc" id="L621" title="1 of 2 branches missed.">      if (DEBUG) {</span>
<span class="nc" id="L622">        log.info(&quot;  checking in &quot; + kid);</span>
      }
<span class="fc bfc" id="L624" title="All 2 branches covered.">      if (isVerbalAuxiliary(kid, passiveAuxiliaries, false)) {</span>
<span class="fc" id="L625">          foundPassiveAux = true;</span>
<span class="fc bfc" id="L626" title="All 2 branches covered.">      } else if (kid.isPhrasal()) {</span>
<span class="fc" id="L627">        Label kidLabel = kid.label();</span>
<span class="fc" id="L628">        String cat = null;</span>
<span class="pc bpc" id="L629" title="1 of 2 branches missed.">        if (kidLabel instanceof HasCategory) {</span>
<span class="fc" id="L630">          cat = ((HasCategory) kidLabel).category();</span>
        }
<span class="pc bpc" id="L632" title="1 of 2 branches missed.">        if (cat == null) {</span>
<span class="fc" id="L633">          cat = kid.value();</span>
        }
<span class="fc bfc" id="L635" title="All 2 branches covered.">        if ( ! cat.startsWith(&quot;VP&quot;)) {</span>
<span class="fc" id="L636">          continue;</span>
        }
<span class="pc bpc" id="L638" title="1 of 2 branches missed.">        if (DEBUG) {</span>
<span class="nc" id="L639">          log.info(&quot;hasPassiveProgressiveAuxiliary found VP&quot;);</span>
        }
<span class="fc" id="L641">        Tree[] kidkids = kid.children();</span>
<span class="fc" id="L642">        boolean foundParticipleInVp = false;</span>
<span class="fc bfc" id="L643" title="All 2 branches covered.">        for (Tree kidkid : kidkids) {</span>
<span class="pc bpc" id="L644" title="1 of 2 branches missed.">          if (DEBUG) {</span>
<span class="nc" id="L645">            log.info(&quot;  hasPassiveProgressiveAuxiliary examining &quot; + kidkid);</span>
          }
<span class="fc bfc" id="L647" title="All 2 branches covered.">          if (kidkid.isPreTerminal()) {</span>
<span class="fc" id="L648">            Label kidkidLabel = kidkid.label();</span>
<span class="fc" id="L649">            String tag = null;</span>
<span class="pc bpc" id="L650" title="1 of 2 branches missed.">            if (kidkidLabel instanceof HasTag) {</span>
<span class="fc" id="L651">              tag = ((HasTag) kidkidLabel).tag();</span>
            }
<span class="pc bpc" id="L653" title="1 of 2 branches missed.">            if (tag == null) {</span>
<span class="fc" id="L654">              tag = kidkid.value();</span>
            }
            // we allow in VBD because of frequent tagging mistakes
<span class="fc bfc" id="L657" title="All 6 branches covered.">            if (&quot;VBN&quot;.equals(tag) || &quot;VBG&quot;.equals(tag) || &quot;VBD&quot;.equals(tag)) {</span>
<span class="fc" id="L658">              foundPassiveVP = true;</span>
<span class="pc bpc" id="L659" title="1 of 2 branches missed.">              if (DEBUG) {</span>
<span class="nc" id="L660">                log.info(&quot;hasPassiveAuxiliary found VBN/VBG/VBD VP&quot;);</span>
              }
              break;
<span class="pc bpc" id="L663" title="1 of 4 branches missed.">            } else if (&quot;CC&quot;.equals(tag) &amp;&amp; foundParticipleInVp) {</span>
<span class="fc" id="L664">              foundPassiveVP = true;</span>
<span class="pc bpc" id="L665" title="1 of 2 branches missed.">              if (DEBUG) {</span>
<span class="nc" id="L666">                log.info(&quot;hasPassiveAuxiliary [coordination] found (VP (VP[VBN/VBG/VBD] CC&quot;);</span>
              }
              break;
            }
<span class="pc bpc" id="L670" title="1 of 2 branches missed.">          } else if (kidkid.isPhrasal()) {</span>
<span class="fc" id="L671">            String catcat = null;</span>
<span class="pc bpc" id="L672" title="1 of 2 branches missed.">            if (kidLabel instanceof HasCategory) {</span>
<span class="fc" id="L673">              catcat = ((HasCategory) kidLabel).category();</span>
            }
<span class="pc bpc" id="L675" title="1 of 2 branches missed.">            if (catcat == null) {</span>
<span class="fc" id="L676">              catcat = kid.value();</span>
            }
<span class="pc bpc" id="L678" title="1 of 2 branches missed.">            if (&quot;VP&quot;.equals(catcat)) {</span>
<span class="pc bpc" id="L679" title="1 of 2 branches missed.">              if (DEBUG) {</span>
<span class="nc" id="L680">                log.info(&quot;hasPassiveAuxiliary found (VP (VP)), recursing&quot;);</span>
              }
<span class="fc" id="L682">              foundParticipleInVp = vpContainsParticiple(kidkid);</span>
<span class="nc bnc" id="L683" title="All 6 branches missed.">            } else if ((&quot;CONJP&quot;.equals(catcat) || &quot;PRN&quot;.equals(catcat)) &amp;&amp; foundParticipleInVp) { // occasionally get PRN in CONJ-like structures</span>
<span class="nc" id="L684">              foundPassiveVP = true;</span>
<span class="nc bnc" id="L685" title="All 2 branches missed.">              if (DEBUG) {</span>
<span class="nc" id="L686">                log.info(&quot;hasPassiveAuxiliary [coordination] found (VP (VP[VBN/VBG/VBD] CONJP&quot;);</span>
              }
              break;
            }
          }
        }
      }
<span class="fc bfc" id="L693" title="All 4 branches covered.">      if (foundPassiveAux &amp;&amp; foundPassiveVP) {</span>
<span class="fc" id="L694">        break;</span>
      }
    } // end for (Tree kid : kids)
<span class="pc bpc" id="L697" title="1 of 2 branches missed.">    if (DEBUG) {</span>
<span class="nc bnc" id="L698" title="All 4 branches missed.">      log.info(&quot;hasPassiveProgressiveAuxiliary returns &quot; + (foundPassiveAux &amp;&amp; foundPassiveVP));</span>
    }
<span class="fc bfc" id="L700" title="All 4 branches covered.">    return foundPassiveAux &amp;&amp; foundPassiveVP;</span>
  }

  private static boolean vpContainsParticiple(Tree t) {
<span class="fc bfc" id="L704" title="All 2 branches covered.">    for (Tree kid : t.children()) {</span>
<span class="pc bpc" id="L705" title="1 of 2 branches missed.">      if (DEBUG) {</span>
<span class="nc" id="L706">        log.info(&quot;vpContainsParticiple examining &quot; + kid);</span>
      }
<span class="fc bfc" id="L708" title="All 2 branches covered.">      if (kid.isPreTerminal()) {</span>
<span class="fc" id="L709">        Label kidLabel = kid.label();</span>
<span class="fc" id="L710">        String tag = null;</span>
<span class="pc bpc" id="L711" title="1 of 2 branches missed.">        if (kidLabel instanceof HasTag) {</span>
<span class="fc" id="L712">          tag = ((HasTag) kidLabel).tag();</span>
        }
<span class="pc bpc" id="L714" title="1 of 2 branches missed.">        if (tag == null) {</span>
<span class="fc" id="L715">          tag = kid.value();</span>
        }
<span class="pc bpc" id="L717" title="2 of 6 branches missed.">        if (&quot;VBN&quot;.equals(tag) || &quot;VBG&quot;.equals(tag) || &quot;VBD&quot;.equals(tag)) {</span>
<span class="pc bpc" id="L718" title="1 of 2 branches missed.">          if (DEBUG) {</span>
<span class="nc" id="L719">            log.info(&quot;vpContainsParticiple found VBN/VBG/VBD VP&quot;);</span>
          }
<span class="fc" id="L721">          return true;</span>
        }
      }
    }
<span class="fc" id="L725">    return false;</span>
  }


  /** This looks to see whether any of the children is a preterminal headed by a word
   *  which is within the set verbalSet (which in practice is either
   *  auxiliary or copula verbs).  It only returns true if it's a preterminal head, since
   *  you don't want to pick things up in phrasal daughters.  That is an error.
   *
   * @param kids The child trees
   * @param verbalSet The set of words
   * @param allowTagOnlyMatch If true, it's sufficient to match on an unambiguous auxiliary tag.
   *                          Make true iff verbalSet is &quot;all auxiliaries&quot;
   * @return Returns true if one of the child trees is a preterminal verb headed
   *      by a word in verbalSet
   */
  private boolean hasVerbalAuxiliary(Tree[] kids, Set&lt;String&gt; verbalSet, boolean allowTagOnlyMatch) {
<span class="pc bpc" id="L742" title="1 of 2 branches missed.">    if (DEBUG) {</span>
<span class="nc" id="L743">      log.info(&quot;Checking for verbal auxiliary&quot;);</span>
    }
<span class="fc bfc" id="L745" title="All 2 branches covered.">    for (Tree kid : kids) {</span>
<span class="pc bpc" id="L746" title="1 of 2 branches missed.">      if (DEBUG) {</span>
<span class="nc" id="L747">        log.info(&quot;  checking in &quot; + kid);</span>
      }
<span class="fc bfc" id="L749" title="All 2 branches covered.">      if (isVerbalAuxiliary(kid, verbalSet, allowTagOnlyMatch)) {</span>
<span class="fc" id="L750">        return true;</span>
      }
    }
<span class="pc bpc" id="L753" title="1 of 2 branches missed.">    if (DEBUG) {</span>
<span class="nc" id="L754">      log.info(&quot;hasVerbalAuxiliary returns false&quot;);</span>
    }
<span class="fc" id="L756">    return false;</span>
  }


  private static final long serialVersionUID = 5721799188009249808L;

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>