<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Trees.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.trees</a> &gt; <span class="el_source">Trees.java</span></div><h1>Trees.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.trees;

import edu.stanford.nlp.io.IOUtils;
import java.util.function.Function;
import edu.stanford.nlp.util.Generics;
import edu.stanford.nlp.util.MutableInteger;
import edu.stanford.nlp.util.StringUtils;
import edu.stanford.nlp.ling.*;

import java.util.*;
import java.io.*;

/**
 * Various static utilities for the &lt;code&gt;Tree&lt;/code&gt; class.
 *
 * @author Roger Levy
 * @author Dan Klein
 * @author Aria Haghighi (tree path methods)
 */
public class Trees {

<span class="fc" id="L22">  private static final LabeledScoredTreeFactory defaultTreeFactory = new LabeledScoredTreeFactory();</span>

<span class="nc" id="L24">  private Trees() {}</span>


  /**
   * Returns the positional index of the left edge of a tree &lt;i&gt;t&lt;/i&gt;
   * within a given root, as defined by the size of the yield of all
   * material preceding &lt;i&gt;t&lt;/i&gt;.
   */
  public static int leftEdge(Tree t, Tree root) {
<span class="nc" id="L33">    MutableInteger i = new MutableInteger(0);</span>
<span class="nc bnc" id="L34" title="All 2 branches missed.">    if (leftEdge(t, root, i)) {</span>
<span class="nc" id="L35">      return i.intValue();</span>
    } else {
<span class="nc" id="L37">      throw new RuntimeException(&quot;Tree is not a descendant of root.&quot;);</span>
//      return -1;
    }
  }

  /**
   * Returns the positional index of the left edge of a tree &lt;i&gt;t&lt;/i&gt;
   * within a given root, as defined by the size of the yield of all
   * material preceding &lt;i&gt;t&lt;/i&gt;.
   * This method returns -1 if no path is found, rather than exceptioning.
   *
   * @see Trees#leftEdge(Tree, Tree)
   */
  public static int leftEdgeUnsafe(Tree t, Tree root) {
<span class="nc" id="L51">    MutableInteger i = new MutableInteger(0);</span>
<span class="nc bnc" id="L52" title="All 2 branches missed.">    if (leftEdge(t, root, i)) {</span>
<span class="nc" id="L53">      return i.intValue();</span>
    } else {
<span class="nc" id="L55">      return -1;</span>
    }
  }

  static boolean leftEdge(Tree t, Tree t1, MutableInteger i) {
<span class="nc bnc" id="L60" title="All 2 branches missed.">    if (t == t1) {</span>
<span class="nc" id="L61">      return true;</span>
<span class="nc bnc" id="L62" title="All 2 branches missed.">    } else if (t1.isLeaf()) {</span>
<span class="nc" id="L63">      int j = t1.yield().size(); // so that empties don't add size</span>
<span class="nc" id="L64">      i.set(i.intValue() + j);</span>
<span class="nc" id="L65">      return false;</span>
    } else {
<span class="nc bnc" id="L67" title="All 2 branches missed.">      for (Tree kid : t1.children()) {</span>
<span class="nc bnc" id="L68" title="All 2 branches missed.">        if (leftEdge(t, kid, i)) {</span>
<span class="nc" id="L69">          return true;</span>
        }
      }
<span class="nc" id="L72">      return false;</span>
    }
  }

  /**
   * Returns the positional index of the right edge of a tree
   * &lt;i&gt;t&lt;/i&gt; within a given root, as defined by the size of the yield
   * of all material preceding &lt;i&gt;t&lt;/i&gt; plus all the material
   * contained in &lt;i&gt;t&lt;/i&gt;.
   */
  public static int rightEdge(Tree t, Tree root) {
<span class="nc" id="L83">    MutableInteger i = new MutableInteger(root.yield().size());</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">    if (rightEdge(t, root, i)) {</span>
<span class="nc" id="L85">      return i.intValue();</span>
    } else {
<span class="nc" id="L87">      throw new RuntimeException(&quot;Tree is not a descendant of root.&quot;);</span>
//      return root.yield().size() + 1;
    }
  }

  /**
   * Returns the positional index of the right edge of a tree
   * &lt;i&gt;t&lt;/i&gt; within a given root, as defined by the size of the yield
   * of all material preceding &lt;i&gt;t&lt;/i&gt; plus all the material
   * contained in &lt;i&gt;t&lt;/i&gt;.
   * This method returns root.yield().size() + 1 if no path is found, rather than exceptioning.
   *
   * @see Trees#rightEdge(Tree, Tree)
   */
  public static int rightEdgeUnsafe(Tree t, Tree root) {
<span class="nc" id="L102">    MutableInteger i = new MutableInteger(root.yield().size());</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">    if (rightEdge(t, root, i)) {</span>
<span class="nc" id="L104">      return i.intValue();</span>
    } else {
<span class="nc" id="L106">      return root.yield().size() + 1;</span>
    }
  }

  static boolean rightEdge(Tree t, Tree t1, MutableInteger i) {
<span class="nc bnc" id="L111" title="All 2 branches missed.">    if (t == t1) {</span>
<span class="nc" id="L112">      return true;</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">    } else if (t1.isLeaf()) {</span>
<span class="nc" id="L114">      int j = t1.yield().size(); // so that empties don't add size</span>
<span class="nc" id="L115">      i.set(i.intValue() - j);</span>
<span class="nc" id="L116">      return false;</span>
    } else {
<span class="nc" id="L118">      Tree[] kids = t1.children();</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">      for (int j = kids.length - 1; j &gt;= 0; j--) {</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">        if (rightEdge(t, kids[j], i)) {</span>
<span class="nc" id="L121">          return true;</span>
        }
      }
<span class="nc" id="L124">      return false;</span>
    }
  }


  /**
   * Returns a lexicalized Tree whose Labels are CategoryWordTag
   * instances, all corresponds to the input tree.
   */
  public static Tree lexicalize(Tree t, HeadFinder hf) {
    Function&lt;Tree,Tree&gt; a =
<span class="nc" id="L135">      TreeFunctions.getLabeledTreeToCategoryWordTagTreeFunction();</span>
<span class="nc" id="L136">    Tree t1 = a.apply(t);</span>
<span class="nc" id="L137">    t1.percolateHeads(hf);</span>
<span class="nc" id="L138">    return t1;</span>
  }

  /**
   * returns the leaves in a Tree in the order that they're found.
   */
  public static List&lt;Tree&gt; leaves(Tree t) {
<span class="fc" id="L145">    List&lt;Tree&gt; l = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L146">    leaves(t, l);</span>
<span class="fc" id="L147">    return l;</span>
  }

  private static void leaves(Tree t, List&lt;Tree&gt; l) {
<span class="fc bfc" id="L151" title="All 2 branches covered.">    if (t.isLeaf()) {</span>
<span class="fc" id="L152">      l.add(t);</span>
    } else {
<span class="fc bfc" id="L154" title="All 2 branches covered.">      for (Tree kid : t.children()) {</span>
<span class="fc" id="L155">        leaves(kid, l);</span>
      }
    }
<span class="fc" id="L158">  }</span>

  public static List&lt;Tree&gt; preTerminals(Tree t) {
<span class="nc" id="L161">    List&lt;Tree&gt; l = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L162">    preTerminals(t, l);</span>
<span class="nc" id="L163">    return l;</span>
  }

  private static void preTerminals(Tree t, List&lt;Tree&gt; l) {
<span class="nc bnc" id="L167" title="All 2 branches missed.">    if (t.isPreTerminal()) {</span>
<span class="nc" id="L168">      l.add(t);</span>
    } else {
<span class="nc bnc" id="L170" title="All 2 branches missed.">      for (Tree kid : t.children()) {</span>
<span class="nc" id="L171">        preTerminals(kid, l);</span>
      }
    }
<span class="nc" id="L174">  }</span>


  /**
   * returns the labels of the leaves in a Tree in the order that they're found.
   */
  public static List&lt;Label&gt; leafLabels(Tree t) {
<span class="nc" id="L181">    List&lt;Label&gt; l = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L182">    leafLabels(t, l);</span>
<span class="nc" id="L183">    return l;</span>
  }

  private static void leafLabels(Tree t, List&lt;Label&gt; l) {
<span class="nc bnc" id="L187" title="All 2 branches missed.">    if (t.isLeaf()) {</span>
<span class="nc" id="L188">      l.add(t.label());</span>
    } else {
<span class="nc bnc" id="L190" title="All 2 branches missed.">      for (Tree kid : t.children()) {</span>
<span class="nc" id="L191">        leafLabels(kid, l);</span>
      }
    }
<span class="nc" id="L194">  }</span>

  /**
   * returns the labels of the leaves in a Tree, augmented with POS tags.  assumes that
   * the labels are CoreLabels.
   */
  public static List&lt;CoreLabel&gt; taggedLeafLabels(Tree t) {
<span class="nc" id="L201">    List&lt;CoreLabel&gt; l = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L202">    taggedLeafLabels(t, l);</span>
<span class="nc" id="L203">    return l;</span>
  }

  private static void taggedLeafLabels(Tree t, List&lt;CoreLabel&gt; l) {
<span class="nc bnc" id="L207" title="All 2 branches missed.">    if (t.isPreTerminal()) {</span>
<span class="nc" id="L208">      CoreLabel fl = (CoreLabel)t.getChild(0).label();</span>
<span class="nc" id="L209">      fl.set(CoreAnnotations.TagLabelAnnotation.class, t.label());</span>
<span class="nc" id="L210">      l.add(fl);</span>
<span class="nc" id="L211">    } else {</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">      for (Tree kid : t.children()) {</span>
<span class="nc" id="L213">        taggedLeafLabels(kid, l);</span>
      }
    }
<span class="nc" id="L216">  }</span>

  /**
   * Given a tree, set the tags on the leaf nodes if they are not
   * already set.  Do this by using the preterminal's value as a tag.
   */
  public static void setLeafTagsIfUnset(Tree tree) {
<span class="fc bfc" id="L223" title="All 2 branches covered.">    if (tree.isPreTerminal()) {</span>
<span class="fc" id="L224">      Tree leaf = tree.children()[0];</span>
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">      if (!(leaf.label() instanceof HasTag)) {</span>
<span class="nc" id="L226">        return;</span>
      }
<span class="fc" id="L228">      HasTag label = (HasTag) leaf.label();</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">      if (label.tag() == null) {</span>
<span class="fc" id="L230">        label.setTag(tree.value());</span>
      }
<span class="fc" id="L232">    } else {</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">      for (Tree child : tree.children()) {</span>
<span class="fc" id="L234">        setLeafTagsIfUnset(child);</span>
      }
    }
<span class="fc" id="L237">  }</span>

  /**
   * Replace the labels of the leaves with the given leaves.
   */
  public static void setLeafLabels(Tree tree, List&lt;Label&gt; labels) {
<span class="fc" id="L243">    Iterator&lt;Tree&gt; leafIterator = tree.getLeaves().iterator();</span>
<span class="fc" id="L244">    Iterator&lt;Label&gt; labelIterator = labels.iterator();</span>
<span class="pc bpc" id="L245" title="1 of 4 branches missed.">    while (leafIterator.hasNext() &amp;&amp; labelIterator.hasNext()) {</span>
<span class="fc" id="L246">      Tree leaf = leafIterator.next();</span>
<span class="fc" id="L247">      Label label = labelIterator.next();</span>
<span class="fc" id="L248">      leaf.setLabel(label);</span>
      //leafIterator.next().setLabel(labelIterator.next());
<span class="fc" id="L250">    }</span>
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">    if (leafIterator.hasNext()) {</span>
<span class="nc" id="L252">      throw new IllegalArgumentException(&quot;Tree had more leaves than the labels provided&quot;);</span>
    }
<span class="pc bpc" id="L254" title="1 of 2 branches missed.">    if (labelIterator.hasNext()) {</span>
<span class="nc" id="L255">      throw new IllegalArgumentException(&quot;More labels provided than tree had leaves&quot;);</span>
    }
<span class="fc" id="L257">  }</span>


  /**
   * returns the maximal projection of &lt;code&gt;head&lt;/code&gt; in
   * &lt;code&gt;root&lt;/code&gt; given a {@link HeadFinder}
   */
  public static Tree maximalProjection(Tree head, Tree root, HeadFinder hf) {
<span class="nc" id="L265">    Tree projection = head;</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">    if (projection == root) {</span>
<span class="nc" id="L267">      return root;</span>
    }
<span class="nc" id="L269">    Tree parent = projection.parent(root);</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">    while (hf.determineHead(parent) == projection) {</span>
<span class="nc" id="L271">      projection = parent;</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">      if (projection == root) {</span>
<span class="nc" id="L273">        return root;</span>
      }
<span class="nc" id="L275">      parent = projection.parent(root);</span>
    }
<span class="nc" id="L277">    return projection;</span>
  }

  /* applies a TreeVisitor to all projections (including the node itself) of a node in a Tree.
  *  Does nothing if head is not in root.
  * @return the maximal projection of head in root.
  */
  public static Tree applyToProjections(TreeVisitor v, Tree head, Tree root, HeadFinder hf) {
<span class="nc" id="L285">    Tree projection = head;</span>
<span class="nc" id="L286">    Tree parent = projection.parent(root);</span>
<span class="nc bnc" id="L287" title="All 4 branches missed.">    if (parent == null &amp;&amp; projection != root) {</span>
<span class="nc" id="L288">      return null;</span>
    }
<span class="nc" id="L290">    v.visitTree(projection);</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">    if (projection == root) {</span>
<span class="nc" id="L292">      return root;</span>
    }
<span class="nc bnc" id="L294" title="All 2 branches missed.">    while (hf.determineHead(parent) == projection) {</span>
<span class="nc" id="L295">      projection = parent;</span>
<span class="nc" id="L296">      v.visitTree(projection);</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">      if (projection == root) {</span>
<span class="nc" id="L298">        return root;</span>
      }
<span class="nc" id="L300">      parent = projection.parent(root);</span>
    }
<span class="nc" id="L302">    return projection;</span>
  }

  /**
   * gets the &lt;code&gt;n&lt;/code&gt;th terminal in &lt;code&gt;tree&lt;/code&gt;.  The first terminal is number zero.
   */
  public static Tree getTerminal(Tree tree, int n) {
<span class="nc" id="L309">    return getTerminal(tree, new MutableInteger(0), n);</span>
  }

  static Tree getTerminal(Tree tree, MutableInteger i, int n) {
<span class="nc bnc" id="L313" title="All 2 branches missed.">    if (i.intValue() == n) {</span>
<span class="nc bnc" id="L314" title="All 2 branches missed.">      if (tree.isLeaf()) {</span>
<span class="nc" id="L315">        return tree;</span>
      } else {
<span class="nc" id="L317">        return getTerminal(tree.children()[0], i, n);</span>
      }
    } else {
<span class="nc bnc" id="L320" title="All 2 branches missed.">      if (tree.isLeaf()) {</span>
<span class="nc" id="L321">        i.set(i.intValue() + tree.yield().size());</span>
<span class="nc" id="L322">        return null;</span>
      } else {
<span class="nc bnc" id="L324" title="All 2 branches missed.">        for (Tree kid : tree.children()) {</span>
<span class="nc" id="L325">          Tree result = getTerminal(kid, i, n);</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">          if (result != null) {</span>
<span class="nc" id="L327">            return result;</span>
          }
        }
<span class="nc" id="L330">        return null;</span>
      }
    }
  }

  /**
   * gets the &lt;code&gt;n&lt;/code&gt;th preterminal in &lt;code&gt;tree&lt;/code&gt;.  The first terminal is number zero.
   */
  public static Tree getPreTerminal(Tree tree, int n) {
<span class="nc" id="L339">    return getPreTerminal(tree, new MutableInteger(0), n);</span>
  }

  static Tree getPreTerminal(Tree tree, MutableInteger i, int n) {
<span class="nc bnc" id="L343" title="All 2 branches missed.">    if (i.intValue() == n) {</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">      if (tree.isPreTerminal()) {</span>
<span class="nc" id="L345">        return tree;</span>
      } else {
<span class="nc" id="L347">        return getPreTerminal(tree.children()[0], i, n);</span>
      }
    } else {
<span class="nc bnc" id="L350" title="All 2 branches missed.">      if (tree.isPreTerminal()) {</span>
<span class="nc" id="L351">        i.set(i.intValue() + tree.yield().size());</span>
<span class="nc" id="L352">        return null;</span>
      } else {
<span class="nc bnc" id="L354" title="All 2 branches missed.">        for (Tree kid : tree.children()) {</span>
<span class="nc" id="L355">          Tree result = getPreTerminal(kid, i, n);</span>
<span class="nc bnc" id="L356" title="All 2 branches missed.">          if (result != null) {</span>
<span class="nc" id="L357">            return result;</span>
          }
        }
<span class="nc" id="L360">        return null;</span>
      }
    }
  }

  /**
   * returns the syntactic category of the tree as a list of the syntactic categories of the mother and the daughters
   */
  public static List&lt;String&gt; localTreeAsCatList(Tree t) {
<span class="nc" id="L369">    List&lt;String&gt; l = new ArrayList&lt;&gt;(t.children().length + 1);</span>
<span class="nc" id="L370">    l.add(t.label().value());</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">    for (int i = 0; i &lt; t.children().length; i++) {</span>
<span class="nc" id="L372">      l.add(t.children()[i].label().value());</span>
    }
<span class="nc" id="L374">    return l;</span>
  }

  /**
   * Returns the index of &lt;code&gt;daughter&lt;/code&gt; in &lt;code&gt;parent&lt;/code&gt; by ==.
   * Returns -1 if &lt;code&gt;daughter&lt;/code&gt; not found.
   */
  public static int objectEqualityIndexOf(Tree parent, Tree daughter) {
<span class="pc bpc" id="L382" title="1 of 2 branches missed.">    for (int i = 0; i &lt; parent.children().length; i++) {</span>
<span class="fc bfc" id="L383" title="All 2 branches covered.">      if (daughter == parent.children()[i]) {</span>
<span class="fc" id="L384">        return i;</span>
      }
    }
<span class="nc" id="L387">    return -1;</span>
  }

  /** Returns a String reporting what kinds of Tree and Label nodes this
   *  Tree contains.
   *
   *  @param t The tree to examine.
   *  @return A human-readable String reporting what kinds of Tree and Label nodes this
   *      Tree contains.
   */
  public static String toStructureDebugString(Tree t) {
<span class="nc" id="L398">    String tCl = StringUtils.getShortClassName(t);</span>
<span class="nc" id="L399">    String tfCl = StringUtils.getShortClassName(t.treeFactory());</span>
<span class="nc" id="L400">    String lCl = StringUtils.getShortClassName(t.label());</span>
<span class="nc" id="L401">    String lfCl = StringUtils.getShortClassName(t.label().labelFactory());</span>
<span class="nc" id="L402">    Set&lt;String&gt; otherClasses = Generics.newHashSet();</span>
<span class="nc" id="L403">    String leafLabels = null;</span>
<span class="nc" id="L404">    String tagLabels = null;</span>
<span class="nc" id="L405">    String phraseLabels = null;</span>
<span class="nc" id="L406">    String leaves = null;</span>
<span class="nc" id="L407">    String nodes = null;</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">    for (Tree st : t) {</span>
<span class="nc" id="L409">      String stCl = StringUtils.getShortClassName(st);</span>
<span class="nc" id="L410">      String stfCl = StringUtils.getShortClassName(st.treeFactory());</span>
<span class="nc" id="L411">      String slCl = StringUtils.getShortClassName(st.label());</span>
<span class="nc" id="L412">      String slfCl = StringUtils.getShortClassName(st.label().labelFactory());</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">      if ( ! tCl.equals(stCl)) {</span>
<span class="nc" id="L414">        otherClasses.add(stCl);</span>
      }
<span class="nc bnc" id="L416" title="All 2 branches missed.">      if ( ! tfCl.equals(stfCl)) {</span>
<span class="nc" id="L417">        otherClasses.add(stfCl);</span>
      }
<span class="nc bnc" id="L419" title="All 2 branches missed.">      if ( ! lCl.equals(slCl)) {</span>
<span class="nc" id="L420">        otherClasses.add(slCl);</span>
      }
<span class="nc bnc" id="L422" title="All 2 branches missed.">      if ( ! lfCl.equals(slfCl)) {</span>
<span class="nc" id="L423">        otherClasses.add(slfCl);</span>
      }
<span class="nc bnc" id="L425" title="All 2 branches missed.">      if (st.isPhrasal()) {</span>
<span class="nc bnc" id="L426" title="All 2 branches missed.">        if (nodes == null) {</span>
<span class="nc" id="L427">          nodes = stCl;</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">        } else if ( ! nodes.equals(stCl)) {</span>
<span class="nc" id="L429">          nodes = &quot;mixed&quot;;</span>
        }
<span class="nc bnc" id="L431" title="All 2 branches missed.">        if (phraseLabels == null) {</span>
<span class="nc" id="L432">          phraseLabels = slCl;</span>
<span class="nc bnc" id="L433" title="All 2 branches missed.">        } else if ( ! phraseLabels.equals(slCl)) {</span>
<span class="nc" id="L434">          phraseLabels = &quot;mixed&quot;;</span>
        }
<span class="nc bnc" id="L436" title="All 2 branches missed.">      } else if (st.isPreTerminal()) {</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">        if (nodes == null) {</span>
<span class="nc" id="L438">          nodes = stCl;</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">        } else if ( ! nodes.equals(stCl)) {</span>
<span class="nc" id="L440">          nodes = &quot;mixed&quot;;</span>
        }
<span class="nc bnc" id="L442" title="All 2 branches missed.">        if (tagLabels == null) {</span>
<span class="nc" id="L443">          tagLabels = StringUtils.getShortClassName(slCl);</span>
<span class="nc bnc" id="L444" title="All 2 branches missed.">        } else if ( ! tagLabels.equals(slCl)) {</span>
<span class="nc" id="L445">          tagLabels = &quot;mixed&quot;;</span>
        }
<span class="nc bnc" id="L447" title="All 2 branches missed.">      } else if (st.isLeaf()) {</span>
<span class="nc bnc" id="L448" title="All 2 branches missed.">        if (leaves == null) {</span>
<span class="nc" id="L449">          leaves = stCl;</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">        } else if ( ! leaves.equals(stCl)) {</span>
<span class="nc" id="L451">          leaves = &quot;mixed&quot;;</span>
        }
<span class="nc bnc" id="L453" title="All 2 branches missed.">        if (leafLabels == null) {</span>
<span class="nc" id="L454">          leafLabels = slCl;</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">        } else if ( ! leafLabels.equals(slCl)) {</span>
<span class="nc" id="L456">          leafLabels = &quot;mixed&quot;;</span>
        }
      } else {
<span class="nc" id="L459">        throw new IllegalStateException(&quot;Bad tree state: &quot; + t);</span>
      }
<span class="nc" id="L461">    } // end for Tree st : this</span>
<span class="nc" id="L462">    StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L463">    sb.append(&quot;Tree with root of class &quot;).append(tCl).append(&quot; and factory &quot;).append(tfCl);</span>
<span class="nc" id="L464">    sb.append(&quot; and root label class &quot;).append(lCl).append(&quot; and factory &quot;).append(lfCl);</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">    if ( ! otherClasses.isEmpty()) {</span>
<span class="nc" id="L466">      sb.append(&quot; and the following classes also found within the tree: &quot;).append(otherClasses);</span>
<span class="nc" id="L467">      return &quot; with &quot; + nodes + &quot; interior nodes and &quot; + leaves +</span>
        &quot; leaves, and &quot; + phraseLabels + &quot; phrase labels, &quot; +
        tagLabels + &quot; tag labels, and &quot; + leafLabels + &quot; leaf labels.&quot;;
    } else {
<span class="nc" id="L471">      sb.append(&quot; (and uniform use of these Tree and Label classes throughout the tree).&quot;);</span>
    }
<span class="nc" id="L473">    return sb.toString();</span>
  }


  /** Turns a sentence into a flat phrasal tree.
   *  The structure is S -&amp;gt; tag*.  And then each tag goes to a word.
   *  The tag is either found from the label or made &quot;WD&quot;.
   *  The tag and phrasal node have a StringLabel.
   *
   *  @param s The Sentence to make the Tree from
   *  @return The one phrasal level Tree
   */
  public static Tree toFlatTree(List&lt;HasWord&gt; s) {
<span class="nc" id="L486">    return toFlatTree(s, new StringLabelFactory());</span>
  }

  /** Turns a sentence into a flat phrasal tree.
   *  The structure is S -&amp;gt; tag*.  And then each tag goes to a word.
   *  The tag is either found from the label or made &quot;WD&quot;.
   *  The tag and phrasal node have a StringLabel.
   *
   *  @param s The Sentence to make the Tree from
   *  @param lf The LabelFactory with which to create the new Tree labels
   *  @return The one phrasal level Tree
   */
  public static Tree toFlatTree(List&lt;? extends HasWord&gt; s, LabelFactory lf) {
<span class="nc" id="L499">    List&lt;Tree&gt; daughters = new ArrayList&lt;&gt;(s.size());</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">    for (HasWord word : s) {</span>
<span class="nc" id="L501">      Tree wordNode = new LabeledScoredTreeNode(lf.newLabel(word.word()));</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">      if (word instanceof TaggedWord) {</span>
<span class="nc" id="L503">        TaggedWord taggedWord = (TaggedWord) word;</span>
<span class="nc" id="L504">        wordNode = new LabeledScoredTreeNode(new StringLabel(taggedWord.tag()), Collections.singletonList(wordNode));</span>
<span class="nc" id="L505">      } else {</span>
<span class="nc" id="L506">        wordNode = new LabeledScoredTreeNode(lf.newLabel(&quot;WD&quot;), Collections.singletonList(wordNode));</span>
      }
<span class="nc" id="L508">      daughters.add(wordNode);</span>
<span class="nc" id="L509">    }</span>
<span class="nc" id="L510">    return new LabeledScoredTreeNode(new StringLabel(&quot;S&quot;), daughters);</span>
  }


   public static String treeToLatex(Tree t) {
<span class="nc" id="L515">     StringBuilder connections = new StringBuilder();</span>
<span class="nc" id="L516">     StringBuilder hierarchy = new StringBuilder();</span>
<span class="nc" id="L517">     treeToLatexHelper(t,connections,hierarchy,0,1,0);</span>
<span class="nc" id="L518">     return &quot;\\tree&quot;+hierarchy+ '\n' +connections+ '\n';</span>
   }

  private static int treeToLatexHelper(Tree t, StringBuilder c, StringBuilder h,
                                       int n, int nextN, int indent) {
<span class="nc" id="L523">    StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L524" title="All 2 branches missed.">    for (int i=0; i&lt;indent; i++)</span>
<span class="nc" id="L525">      sb.append(&quot;  &quot;);</span>
<span class="nc" id="L526">    h.append('\n').append(sb);</span>
<span class="nc bnc" id="L527" title="All 2 branches missed.">    h.append(&quot;{\\&quot;).append(t.isLeaf() ? &quot;&quot; : &quot;n&quot;).append(&quot;tnode{z&quot;).append(n).append(&quot;}{&quot;).append(t.label()).append('}');</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">    if (!t.isLeaf()) {</span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">      for (int k=0; k&lt;t.children().length; k++) {</span>
<span class="nc" id="L530">        h.append(&quot;, &quot;);</span>
<span class="nc" id="L531">        c.append(&quot;\\nodeconnect{z&quot;).append(n).append(&quot;}{z&quot;).append(nextN).append(&quot;}\n&quot;);</span>
<span class="nc" id="L532">        nextN = treeToLatexHelper(t.children()[k],c,h,nextN,nextN+1,indent+1);</span>
      }
    }
<span class="nc" id="L535">    h.append('}');</span>
<span class="nc" id="L536">    return nextN;</span>
  }

  public static String treeToLatexEven(Tree t) {
<span class="nc" id="L540">    StringBuilder connections = new StringBuilder();</span>
<span class="nc" id="L541">    StringBuilder hierarchy = new StringBuilder();</span>
<span class="nc" id="L542">    int maxDepth = t.depth();</span>
<span class="nc" id="L543">    treeToLatexEvenHelper(t,connections,hierarchy,0,1,0,0,maxDepth);</span>
<span class="nc" id="L544">    return &quot;\\tree&quot;+hierarchy+ '\n' +connections+ '\n';</span>
  }

  private static int treeToLatexEvenHelper(Tree t, StringBuilder c, StringBuilder h, int n,
                                           int nextN, int indent, int curDepth, int maxDepth) {
<span class="nc" id="L549">    StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L550" title="All 2 branches missed.">    for (int i=0; i&lt;indent; i++)</span>
<span class="nc" id="L551">      sb.append(&quot;  &quot;);</span>
<span class="nc" id="L552">    h.append('\n').append(sb);</span>
<span class="nc" id="L553">    int tDepth = t.depth();</span>
<span class="nc bnc" id="L554" title="All 4 branches missed.">    if (tDepth == 0 &amp;&amp; tDepth+curDepth &lt; maxDepth) {</span>
<span class="nc bnc" id="L555" title="All 2 branches missed.">      for (int pad=0; pad &lt; maxDepth-tDepth-curDepth; pad++) {</span>
<span class="nc" id="L556">        h.append(&quot;{\\ntnode{pad}{}, &quot;);</span>
      }
    }
<span class="nc" id="L559">    h.append(&quot;{\\ntnode{z&quot;).append(n).append(&quot;}{&quot;).append(t.label()).append('}');</span>
<span class="nc bnc" id="L560" title="All 2 branches missed.">    if (!t.isLeaf()) {</span>
<span class="nc bnc" id="L561" title="All 2 branches missed.">      for (int k=0; k&lt;t.children().length; k++) {</span>
<span class="nc" id="L562">        h.append(&quot;, &quot;);</span>
<span class="nc" id="L563">        c.append(&quot;\\nodeconnect{z&quot;).append(n).append(&quot;}{z&quot;).append(nextN).append(&quot;}\n&quot;);</span>
<span class="nc" id="L564">        nextN = treeToLatexEvenHelper(t.children()[k],c,h,nextN,nextN+1,indent+1,curDepth+1,maxDepth);</span>
      }
    }
<span class="nc bnc" id="L567" title="All 4 branches missed.">    if (tDepth == 0 &amp;&amp; tDepth+curDepth &lt; maxDepth) {</span>
<span class="nc bnc" id="L568" title="All 2 branches missed.">      for (int pad=0; pad &lt; maxDepth-tDepth-curDepth; pad++) {</span>
<span class="nc" id="L569">        h.append('}');</span>
      }
    }
<span class="nc" id="L572">    h.append('}');</span>
<span class="nc" id="L573">    return nextN;</span>
  }

  static String texTree(Tree t) {
<span class="nc" id="L577">    return treeToLatex(t);</span>
  }

  static String escape(String s) {
<span class="nc" id="L581">    StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L582" title="All 2 branches missed.">    for (int i=0; i&lt;s.length(); i++) {</span>
<span class="nc" id="L583">      char c = s.charAt(i);</span>
<span class="nc bnc" id="L584" title="All 2 branches missed.">      if (c == '^')</span>
<span class="nc" id="L585">        sb.append('\\');</span>
<span class="nc" id="L586">      sb.append(c);</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">      if (c == '^')</span>
<span class="nc" id="L588">        sb.append(&quot;{}&quot;);</span>
    }
<span class="nc" id="L590">    return sb.toString();</span>
  }


  public static void main(String[] args) throws IOException {
<span class="nc" id="L595">    int i = 0;</span>
<span class="nc bnc" id="L596" title="All 2 branches missed.">    while (i &lt; args.length) {</span>
<span class="nc" id="L597">      Tree tree = Tree.valueOf(args[i]);</span>
<span class="nc bnc" id="L598" title="All 2 branches missed.">      if (tree == null) {</span>
        // maybe it was a filename
<span class="nc" id="L600">        tree = Tree.valueOf(IOUtils.slurpFile(args[i]));</span>
      }
<span class="nc bnc" id="L602" title="All 2 branches missed.">      if (tree != null) {</span>
<span class="nc" id="L603">        System.out.println(escape(texTree(tree)));</span>
      }
<span class="nc" id="L605">      i++;</span>
<span class="nc" id="L606">    }</span>
<span class="nc bnc" id="L607" title="All 2 branches missed.">    if (i == 0) {</span>
<span class="nc" id="L608">      Tree tree = (new PennTreeReader(new BufferedReader(new</span>
              InputStreamReader(System.in)), new LabeledScoredTreeFactory(new
<span class="nc" id="L610">              StringLabelFactory()))).readTree();</span>
<span class="nc" id="L611">      System.out.println(escape(texTree(tree)));</span>
    }
<span class="nc" id="L613">  }</span>

  public static Tree normalizeTree(Tree tree, TreeNormalizer tn, TreeFactory tf) {
<span class="nc bnc" id="L616" title="All 2 branches missed.">    for (Tree node : tree) {</span>
<span class="nc bnc" id="L617" title="All 2 branches missed.">      if (node.isLeaf()) {</span>
<span class="nc" id="L618">        node.label().setValue(tn.normalizeTerminal(node.label().value()));</span>
      } else {
<span class="nc" id="L620">        node.label().setValue(tn.normalizeNonterminal(node.label().value()));</span>
      }
<span class="nc" id="L622">    }</span>
<span class="nc" id="L623">    return tn.normalizeWholeTree(tree, tf);</span>
  }


  /**
   * Gets the &lt;i&gt;i&lt;/i&gt;th leaf of a tree from the left.
   * The leftmost leaf is numbered 0.
   *
   * @return The &lt;i&gt;i&lt;/i&gt;&lt;sup&gt;th&lt;/sup&gt; leaf as a Tree, or &lt;code&gt;null&lt;/code&gt;
   *     if there is no such leaf.
   */
  public static Tree getLeaf(Tree tree, int i) {
<span class="nc" id="L635">    int count = -1;</span>
<span class="nc bnc" id="L636" title="All 2 branches missed.">    for (Tree next : tree) {</span>
<span class="nc bnc" id="L637" title="All 2 branches missed.">      if (next.isLeaf()) {</span>
<span class="nc" id="L638">        count++;</span>
      }
<span class="nc bnc" id="L640" title="All 2 branches missed.">      if (count == i) {</span>
<span class="nc" id="L641">        return next;</span>
      }
<span class="nc" id="L643">    }</span>
<span class="nc" id="L644">    return null;</span>
  }


  /**
   * Get lowest common ancestor of all the nodes in the list with the tree rooted at root
   */
  public static Tree getLowestCommonAncestor(List&lt;Tree&gt; nodes, Tree root) {
<span class="fc" id="L652">    List&lt;List&lt;Tree&gt;&gt; paths = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L653">    int min = Integer.MAX_VALUE;</span>
<span class="fc bfc" id="L654" title="All 2 branches covered.">    for (Tree t : nodes) {</span>
<span class="fc" id="L655">      List&lt;Tree&gt; path = pathFromRoot(t, root);</span>
<span class="pc bpc" id="L656" title="1 of 2 branches missed.">      if (path == null) return null;</span>
<span class="fc" id="L657">      min = Math.min(min, path.size());</span>
<span class="fc" id="L658">      paths.add(path);</span>
<span class="fc" id="L659">    }</span>
<span class="fc" id="L660">    Tree commonAncestor = null;</span>
<span class="fc bfc" id="L661" title="All 2 branches covered.">    for (int i = 0; i &lt; min; ++i) {</span>
<span class="fc" id="L662">      Tree ancestor = paths.get(0).get(i);</span>
<span class="fc" id="L663">      boolean quit = false;</span>
<span class="fc bfc" id="L664" title="All 2 branches covered.">      for (List&lt;Tree&gt; path : paths) {</span>
<span class="fc bfc" id="L665" title="All 2 branches covered.">        if (!path.get(i).equals(ancestor)) {</span>
<span class="fc" id="L666">          quit = true;</span>
<span class="fc" id="L667">          break;</span>
        }
<span class="fc" id="L669">      }</span>
<span class="fc bfc" id="L670" title="All 2 branches covered.">      if (quit) break;</span>
<span class="fc" id="L671">      commonAncestor = ancestor;</span>
    }
<span class="fc" id="L673">    return commonAncestor;</span>
  }


  /**
   * returns a list of categories that is the path from Tree from to Tree
   * to within Tree root.  If either from or to is not in root,
   * returns null.  Otherwise includes both from and to in the list.
   */
  public static List&lt;String&gt; pathNodeToNode(Tree from, Tree to, Tree root) {
<span class="nc" id="L683">    List&lt;Tree&gt; fromPath = pathFromRoot(from, root);</span>
    //System.out.println(treeListToCatList(fromPath));
<span class="nc bnc" id="L685" title="All 2 branches missed.">    if (fromPath == null)</span>
<span class="nc" id="L686">      return null;</span>

<span class="nc" id="L688">    List&lt;Tree&gt; toPath = pathFromRoot(to, root);</span>
    //System.out.println(treeListToCatList(toPath));
<span class="nc bnc" id="L690" title="All 2 branches missed.">    if (toPath == null)</span>
<span class="nc" id="L691">      return null;</span>

    //System.out.println(treeListToCatList(fromPath));
    //System.out.println(treeListToCatList(toPath));

<span class="nc" id="L696">    int last = 0;</span>
<span class="nc bnc" id="L697" title="All 2 branches missed.">    int min = fromPath.size() &lt;= toPath.size() ? fromPath.size() : toPath.size();</span>

<span class="nc" id="L699">    Tree lastNode = null;</span>
//     while((! (fromPath.isEmpty() || toPath.isEmpty())) &amp;&amp;  fromPath.get(0).equals(toPath.get(0))) {
//       lastNode = (Tree) fromPath.remove(0);
//       toPath.remove(0);
//     }
<span class="nc bnc" id="L704" title="All 4 branches missed.">    while (last &lt; min &amp;&amp; fromPath.get(last).equals(toPath.get(last))) {</span>
<span class="nc" id="L705">      lastNode = fromPath.get(last);</span>
<span class="nc" id="L706">      last++;</span>
    }

    //System.out.println(treeListToCatList(fromPath));
    //System.out.println(treeListToCatList(toPath));
<span class="nc" id="L711">    List&lt;String&gt; totalPath = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L713" title="All 2 branches missed.">    for (int i = fromPath.size() - 1; i &gt;= last; i--) {</span>
<span class="nc" id="L714">      Tree t = fromPath.get(i);</span>
<span class="nc" id="L715">      totalPath.add(&quot;up-&quot; + t.label().value());</span>
    }

<span class="nc bnc" id="L718" title="All 2 branches missed.">    if (lastNode != null)</span>
<span class="nc" id="L719">      totalPath.add(&quot;up-&quot; + lastNode.label().value());</span>

<span class="nc bnc" id="L721" title="All 2 branches missed.">    for (Tree t: toPath)</span>
<span class="nc" id="L722">      totalPath.add(&quot;down-&quot; + t.label().value());</span>


//     for(ListIterator i = fromPath.listIterator(fromPath.size()); i.hasPrevious(); ){
//       Tree t = (Tree) i.previous();
//       totalPath.add(&quot;up-&quot; + t.label().value());
//     }

//     if(lastNode != null)
//     totalPath.add(&quot;up-&quot; + lastNode.label().value());

//     for(ListIterator j = toPath.listIterator(); j.hasNext(); ){
//       Tree t = (Tree) j.next();
//       totalPath.add(&quot;down-&quot; + t.label().value());
//     }

<span class="nc" id="L738">    return totalPath;</span>
  }


  /**
   * returns list of tree nodes to root from t.  Includes root and
   * t. Returns null if tree not found dominated by root
   */
  public static List&lt;Tree&gt; pathFromRoot(Tree t, Tree root) {
<span class="pc bpc" id="L747" title="1 of 2 branches missed.">    if (t == root) {</span>
      //if (t.equals(root)) {
<span class="nc" id="L749">      List&lt;Tree&gt; l = new ArrayList&lt;&gt;(1);</span>
<span class="nc" id="L750">      l.add(t);</span>
<span class="nc" id="L751">      return l;</span>
<span class="pc bpc" id="L752" title="1 of 2 branches missed.">    } else if (root == null) {</span>
<span class="nc" id="L753">      return null;</span>
    }
<span class="fc" id="L755">    return root.dominationPath(t);</span>
  }


  /**
   * replaces all instances (by ==) of node with node1.  Doesn't affect
   * the node t itself
   */
  public static void replaceNode(Tree node, Tree node1, Tree t) {
<span class="nc bnc" id="L764" title="All 2 branches missed.">    if (t.isLeaf())</span>
<span class="nc" id="L765">      return;</span>
<span class="nc" id="L766">    Tree[] kids = t.children();</span>
<span class="nc" id="L767">    List&lt;Tree&gt; newKids = new ArrayList&lt;&gt;(kids.length);</span>
<span class="nc bnc" id="L768" title="All 2 branches missed.">    for (Tree kid : kids) {</span>
<span class="nc bnc" id="L769" title="All 2 branches missed.">      if (kid != node) {</span>
<span class="nc" id="L770">        newKids.add(kid);</span>
<span class="nc" id="L771">        replaceNode(node, node1, kid);</span>
      } else {
<span class="nc" id="L773">        newKids.add(node1);</span>
      }
    }
<span class="nc" id="L776">    t.setChildren(newKids);</span>
<span class="nc" id="L777">  }</span>


  /**
   * returns the node of a tree which represents the lowest common
   * ancestor of nodes t1 and t2 dominated by root. If either t1 or
   * or t2 is not dominated by root, returns null.
   */
  public static Tree getLowestCommonAncestor(Tree t1, Tree t2, Tree root) {
<span class="nc" id="L786">    List&lt;Tree&gt; t1Path = pathFromRoot(t1, root);</span>
<span class="nc" id="L787">    List&lt;Tree&gt; t2Path = pathFromRoot(t2, root);</span>
<span class="nc bnc" id="L788" title="All 4 branches missed.">    if (t1Path == null || t2Path == null) return null;</span>

<span class="nc" id="L790">    int min = Math.min(t1Path.size(), t2Path.size());</span>
<span class="nc" id="L791">    Tree commonAncestor = null;</span>
<span class="nc bnc" id="L792" title="All 4 branches missed.">    for (int i = 0; i &lt; min &amp;&amp; t1Path.get(i).equals(t2Path.get(i)); ++i) {</span>
<span class="nc" id="L793">      commonAncestor = t1Path.get(i);</span>
    }

<span class="nc" id="L796">    return commonAncestor;</span>
  }

  // todo [cdm 2015]: These next two methods duplicate the Tree.valueOf methods!
  /**
   * Simple tree reading utility method.  Given a tree formatted as a PTB string, returns a Tree made by a specific TreeFactory.
   */
  public static Tree readTree(String ptbTreeString, TreeFactory treeFactory) {
    try {
<span class="nc" id="L805">      PennTreeReader ptr = new PennTreeReader(new StringReader(ptbTreeString), treeFactory);</span>
<span class="nc" id="L806">      return ptr.readTree();</span>
<span class="nc" id="L807">    } catch (IOException ex) {</span>
<span class="nc" id="L808">      throw new RuntimeException(ex);</span>
    }
  }

  /**
   * Simple tree reading utility method.  Given a tree formatted as a PTB string, returns a Tree made by the default TreeFactory (LabeledScoredTreeFactory)
   */
  public static Tree readTree(String str) {
<span class="nc" id="L816">    return readTree(str, defaultTreeFactory);</span>
  }

  /**
   * Outputs the labels on the trees, not just the words.
   */
  public static void outputTreeLabels(Tree tree) {
<span class="nc" id="L823">    outputTreeLabels(tree, 0);</span>
<span class="nc" id="L824">  }</span>

  public static void outputTreeLabels(Tree tree, int depth) {
<span class="nc bnc" id="L827" title="All 2 branches missed.">    for (int i = 0; i &lt; depth; ++i) {</span>
<span class="nc" id="L828">      System.out.print(&quot; &quot;);</span>
    }
<span class="nc" id="L830">    System.out.println(tree.label());</span>
<span class="nc bnc" id="L831" title="All 2 branches missed.">    for (Tree child : tree.children()) {</span>
<span class="nc" id="L832">      outputTreeLabels(child, depth + 1);</span>
    }
<span class="nc" id="L834">  }</span>

  /**
   * Converts the tree labels to CoreLabels.
   * We need this because we store additional info in the CoreLabel, like token span.
   * @param tree
   */
  public static void convertToCoreLabels(Tree tree) {
<span class="fc" id="L842">    Label l = tree.label();</span>
<span class="fc bfc" id="L843" title="All 2 branches covered.">    if (!(l instanceof CoreLabel)) {</span>
<span class="fc" id="L844">      CoreLabel cl = new CoreLabel();</span>
<span class="fc" id="L845">      cl.setValue(l.value());</span>
<span class="fc" id="L846">      tree.setLabel(cl);</span>
    }

<span class="fc bfc" id="L849" title="All 2 branches covered.">    for (Tree kid : tree.children()) {</span>
<span class="fc" id="L850">      convertToCoreLabels(kid);</span>
    }
<span class="fc" id="L852">  }</span>


  /**
   * Set the sentence index of all the leaves in the tree
   * (only works on CoreLabel)
   */
  public static void setSentIndex(Tree tree, int sentIndex) {
<span class="nc" id="L860">    List&lt;Label&gt; leaves = tree.yield();</span>
<span class="nc bnc" id="L861" title="All 2 branches missed.">    for (Label leaf : leaves) {</span>
<span class="nc bnc" id="L862" title="All 2 branches missed.">      if (!(leaf instanceof CoreLabel)) {</span>
<span class="nc" id="L863">        throw new IllegalArgumentException(&quot;Only works on CoreLabel&quot;);</span>
      }
<span class="nc" id="L865">      ((CoreLabel) leaf).setSentIndex(sentIndex);</span>
<span class="nc" id="L866">    }</span>
<span class="nc" id="L867">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>