<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GrammaticalStructureConversionUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.trees</a> &gt; <span class="el_source">GrammaticalStructureConversionUtils.java</span></div><h1>GrammaticalStructureConversionUtils.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.trees;

import edu.stanford.nlp.io.IOUtils;
import edu.stanford.nlp.io.RuntimeIOException;
import edu.stanford.nlp.ling.*;
import edu.stanford.nlp.parser.lexparser.TreebankLangParserParams;
import edu.stanford.nlp.process.PTBTokenizer;
import edu.stanford.nlp.process.WhitespaceTokenizer;
import edu.stanford.nlp.trees.international.pennchinese.CTBErrorCorrectingTreeNormalizer;
import edu.stanford.nlp.util.*;
import edu.stanford.nlp.util.logging.Redwood;

import java.io.*;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.*;
import java.util.function.Function;
import java.util.function.Predicate;

/**
 * Contains several utility methods to convert constituency trees to
 * dependency trees.
 *
 * Used by {@link GrammaticalStructure#main(String[])}
 */

<span class="nc" id="L27">public class GrammaticalStructureConversionUtils {</span>


  public static final String DEFAULT_PARSER_FILE = &quot;edu/stanford/nlp/models/lexparser/englishPCFG.ser.gz&quot;;

  /**
   * Print typed dependencies in either the Stanford dependency representation
   * or in the conllx format.
   *
   * @param deps Typed dependencies to print
   * @param tree Tree corresponding to typed dependencies (only necessary if conllx
   *          == true)
   * @param conllx If true use conllx format, otherwise use Stanford representation
   * @param extraSep If true, in the Stanford representation, the extra dependencies
   *          (which do not preserve the tree structure) are printed after the
   *          basic dependencies
   * @param convertToUPOS If true convert the POS tags to universal POS tags and output
   *                      them along the original POS tags.
   */
  public static void printDependencies(GrammaticalStructure gs, Collection&lt;TypedDependency&gt; deps, Tree tree,
                                       boolean conllx, boolean extraSep, boolean convertToUPOS) {
<span class="nc" id="L48">    System.out.println(dependenciesToString(gs, deps, tree, conllx, extraSep, convertToUPOS));</span>
<span class="nc" id="L49">  }</span>


  /**
   * Calls dependenciesToCoNLLXString with the basic dependencies
   * from a grammatical structure.
   *
   * (see {@link #dependenciesToCoNLLXString(Collection, CoreMap)})
   */
  public static String dependenciesToCoNLLXString(GrammaticalStructure gs, CoreMap sentence) {
<span class="nc" id="L59">    return dependenciesToCoNLLXString(gs.typedDependencies(), sentence);</span>
  }


  /**
   *
   * Returns a dependency tree in CoNNL-X format.
   * It requires a CoreMap for the sentence with a TokensAnnotation.
   * Each token has to contain a word and a POS tag.
   *
   * @param deps The list of TypedDependency relations.
   * @param sentence The corresponding CoreMap for the sentence.
   * @return Dependency tree in CoNLL-X format.
   */
  public static String dependenciesToCoNLLXString(Collection&lt;TypedDependency&gt; deps, CoreMap sentence) {
<span class="nc" id="L74">    StringBuilder bf = new StringBuilder();</span>

<span class="nc" id="L76">    HashMap&lt;Integer, TypedDependency&gt; indexedDeps = new HashMap&lt;&gt;(deps.size());</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">    for (TypedDependency dep : deps) {</span>
<span class="nc" id="L78">      indexedDeps.put(dep.dep().index(), dep);</span>
<span class="nc" id="L79">    }</span>

<span class="nc" id="L81">    List&lt;CoreLabel&gt; tokens = sentence.get(CoreAnnotations.TokensAnnotation.class);</span>
<span class="nc bnc" id="L82" title="All 2 branches missed.">    if (tokens == null) {</span>
<span class="nc" id="L83">      throw new RuntimeException(&quot;dependenciesToCoNLLXString: CoreMap does not have required TokensAnnotation.&quot;);</span>
    }
<span class="nc" id="L85">    int idx = 1;</span>

<span class="nc bnc" id="L87" title="All 2 branches missed.">    for (CoreLabel token : tokens) {</span>
<span class="nc" id="L88">      String word = token.value();</span>
<span class="nc" id="L89">      String pos = token.tag();</span>
<span class="nc bnc" id="L90" title="All 2 branches missed.">      String cPos = (token.get(CoreAnnotations.CoarseTagAnnotation.class) != null) ?</span>
<span class="nc" id="L91">          token.get(CoreAnnotations.CoarseTagAnnotation.class) : pos;</span>
<span class="nc bnc" id="L92" title="All 2 branches missed.">      String lemma = token.lemma() != null ? token.lemma() : &quot;_&quot;;</span>
<span class="nc bnc" id="L93" title="All 2 branches missed.">      Integer gov = indexedDeps.containsKey(idx) ? indexedDeps.get(idx).gov().index() : 0;</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">      String reln = indexedDeps.containsKey(idx) ? indexedDeps.get(idx).reln().toString() : &quot;erased&quot;;</span>
<span class="nc" id="L95">      String out = String.format(&quot;%d\t%s\t%s\t%s\t%s\t_\t%d\t%s\t_\t_\n&quot;, idx, word, lemma, cPos, pos, gov, reln);</span>
<span class="nc" id="L96">      bf.append(out);</span>
<span class="nc" id="L97">      idx++;</span>
<span class="nc" id="L98">    }</span>
<span class="nc" id="L99">    return bf.toString();</span>
  }

  public static String dependenciesToString(GrammaticalStructure gs, Collection&lt;TypedDependency&gt; deps, Tree tree,
                                            boolean conllx, boolean extraSep, boolean convertToUPOS) {
<span class="fc" id="L104">    StringBuilder bf = new StringBuilder();</span>

<span class="fc" id="L106">    Map&lt;Integer, Integer&gt; indexToPos = Generics.newHashMap();</span>
<span class="fc" id="L107">    indexToPos.put(0,0); // to deal with the special node &quot;ROOT&quot;</span>
<span class="fc" id="L108">    List&lt;Tree&gt; gsLeaves = gs.root.getLeaves();</span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">    for (int i = 0; i &lt; gsLeaves.size(); i++) {</span>
<span class="fc" id="L110">      TreeGraphNode leaf = (TreeGraphNode) gsLeaves.get(i);</span>
<span class="fc" id="L111">      indexToPos.put(leaf.label.index(), i + 1);</span>
    }

<span class="pc bpc" id="L114" title="1 of 2 branches missed.">    if (conllx) {</span>

<span class="nc" id="L116">      List&lt;Tree&gt; leaves = tree.getLeaves();</span>
<span class="nc" id="L117">      List&lt;Label&gt; uposLabels = null;</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">      if (convertToUPOS) {</span>
<span class="nc" id="L119">        Tree uposTree = UniversalPOSMapper.mapTree(tree);</span>
<span class="nc" id="L120">        uposLabels = uposTree.preTerminalYield();</span>
<span class="nc" id="L121">      } else {</span>
<span class="nc" id="L122">        uposLabels = tree.preTerminalYield();</span>
      }
<span class="nc" id="L124">      int index = 0;</span>
<span class="nc" id="L125">      CoreMap sentence = new CoreLabel();</span>
<span class="nc" id="L126">      List&lt;CoreLabel&gt; tokens = new ArrayList&lt;&gt;(leaves.size());</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">      for (Tree leaf : leaves) {</span>
<span class="nc" id="L128">        index++;</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">        if (!indexToPos.containsKey(index)) {</span>
<span class="nc" id="L130">          continue;</span>
        }
<span class="nc" id="L132">        CoreLabel token = new CoreLabel();</span>
<span class="nc" id="L133">        token.setIndex(index);</span>
<span class="nc" id="L134">        token.setValue(leaf.value());</span>
<span class="nc" id="L135">        token.setWord(leaf.value());</span>
<span class="nc" id="L136">        token.setTag(leaf.parent(tree).value());</span>
<span class="nc" id="L137">        token.set(CoreAnnotations.CoarseTagAnnotation.class, uposLabels.get(index - 1).value());</span>
<span class="nc" id="L138">        tokens.add(token);</span>
<span class="nc" id="L139">      }</span>
<span class="nc" id="L140">      sentence.set(CoreAnnotations.TokensAnnotation.class, tokens);</span>
<span class="nc" id="L141">      bf.append(dependenciesToCoNLLXString(deps, sentence));</span>
<span class="nc" id="L142">    } else {</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">      if (extraSep) {</span>
<span class="fc" id="L144">        List&lt;TypedDependency&gt; extraDeps = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">        for (TypedDependency dep : deps) {</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">          if (dep.extra()) {</span>
<span class="fc" id="L147">            extraDeps.add(dep);</span>
          } else {
<span class="fc" id="L149">            bf.append(toStringIndex(dep, indexToPos));</span>
<span class="fc" id="L150">            bf.append(&quot;\n&quot;);</span>
          }
<span class="fc" id="L152">        }</span>
        // now we print the separator for extra dependencies, and print these if
        // there are some
<span class="pc bpc" id="L155" title="1 of 2 branches missed.">        if (!extraDeps.isEmpty()) {</span>
<span class="fc" id="L156">          bf.append(&quot;======\n&quot;);</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">          for (TypedDependency dep : extraDeps) {</span>
<span class="fc" id="L158">            bf.append(toStringIndex(dep, indexToPos));</span>
<span class="fc" id="L159">            bf.append(&quot;\n&quot;);</span>
<span class="fc" id="L160">          }</span>
        }
<span class="fc" id="L162">      } else {</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">        for (TypedDependency dep : deps) {</span>
<span class="fc" id="L164">          bf.append(toStringIndex(dep, indexToPos));</span>
<span class="fc" id="L165">          bf.append(&quot;\n&quot;);</span>
<span class="fc" id="L166">        }</span>
      }
    }

<span class="fc" id="L170">    return bf.toString();</span>
  }

  private static String toStringIndex(TypedDependency td, Map&lt;Integer, Integer&gt; indexToPos) {
<span class="fc" id="L174">    IndexedWord gov = td.gov();</span>
<span class="fc" id="L175">    IndexedWord dep = td.dep();</span>
<span class="fc" id="L176">    return td.reln() + &quot;(&quot; + gov.value() + &quot;-&quot; + indexToPos.get(gov.index()) + gov.toPrimes() + &quot;, &quot; + dep.value() + &quot;-&quot; + indexToPos.get(dep.index()) + dep.toPrimes() + &quot;)&quot;;</span>
  }


  /** A logger for this class */
<span class="fc" id="L181">  private static Redwood.RedwoodChannels log = Redwood.channels(GrammaticalStructureConversionUtils.class);</span>

  private static String[] parseClassConstructArgs(String namePlusArgs) {
<span class="nc" id="L184">    String[] args = StringUtils.EMPTY_STRING_ARRAY;</span>
<span class="nc" id="L185">    String name = namePlusArgs;</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">    if (namePlusArgs.matches(&quot;.*\\([^)]*\\)$&quot;)) {</span>
<span class="nc" id="L187">      String argStr = namePlusArgs.replaceFirst(&quot;^.*\\(([^)]*)\\)$&quot;, &quot;$1&quot;);</span>
<span class="nc" id="L188">      args = argStr.split(&quot;,&quot;);</span>
<span class="nc" id="L189">      name = namePlusArgs.replaceFirst(&quot;\\([^)]*\\)$&quot;, &quot;&quot;);</span>
    }
<span class="nc" id="L191">    String[] tokens = new String[1 + args.length];</span>
<span class="nc" id="L192">    tokens[0] = name;</span>
<span class="nc" id="L193">    System.arraycopy(args, 0, tokens, 1, args.length);</span>
<span class="nc" id="L194">    return tokens;</span>
  }


  private static DependencyReader loadAlternateDependencyReader(String altDepReaderName) {
<span class="nc" id="L199">    Class&lt;? extends DependencyReader&gt; altDepReaderClass = null;</span>
<span class="nc" id="L200">    String[] toks = parseClassConstructArgs(altDepReaderName);</span>
<span class="nc" id="L201">    altDepReaderName = toks[0];</span>
<span class="nc" id="L202">    String[] depReaderArgs = new String[toks.length - 1];</span>
<span class="nc" id="L203">    System.arraycopy(toks, 1, depReaderArgs, 0, toks.length - 1);</span>

    try {
<span class="nc" id="L206">      Class&lt;?&gt; cl = Class.forName(altDepReaderName);</span>
<span class="nc" id="L207">      altDepReaderClass = cl.asSubclass(DependencyReader.class);</span>
<span class="nc" id="L208">    } catch (ClassNotFoundException e) {</span>
      // have a second go below
<span class="nc" id="L210">    }</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">    if (altDepReaderClass == null) {</span>
      try {
<span class="nc" id="L213">        Class&lt;?&gt; cl = Class.forName(&quot;edu.stanford.nlp.trees.&quot; + altDepReaderName);</span>
<span class="nc" id="L214">        altDepReaderClass = cl.asSubclass(DependencyReader.class);</span>
<span class="nc" id="L215">      } catch (ClassNotFoundException e) {</span>
        //
<span class="nc" id="L217">      }</span>
    }
<span class="nc bnc" id="L219" title="All 2 branches missed.">    if (altDepReaderClass == null) {</span>
<span class="nc" id="L220">      log.info(&quot;Can't load dependency reader &quot; + altDepReaderName + &quot; or edu.stanford.nlp.trees.&quot; + altDepReaderName);</span>
<span class="nc" id="L221">      return null;</span>
    }

    DependencyReader altDepReader; // initialized below
<span class="nc bnc" id="L225" title="All 2 branches missed.">    if (depReaderArgs.length == 0) {</span>
      try {
<span class="nc" id="L227">        altDepReader = altDepReaderClass.newInstance();</span>
<span class="nc" id="L228">      } catch (InstantiationException e) {</span>
<span class="nc" id="L229">        throw new RuntimeException(e);</span>
<span class="nc" id="L230">      } catch (IllegalAccessException e) {</span>
<span class="nc" id="L231">        log.info(&quot;No argument constructor to &quot; + altDepReaderName + &quot; is not public&quot;);</span>
<span class="nc" id="L232">        return null;</span>
<span class="nc" id="L233">      }</span>
    } else {
      try {
<span class="nc" id="L236">        altDepReader = altDepReaderClass.getConstructor(String[].class).newInstance((Object) depReaderArgs);</span>
<span class="nc" id="L237">      } catch (IllegalArgumentException | SecurityException | InvocationTargetException e) {</span>
<span class="nc" id="L238">        throw new RuntimeException(e);</span>
<span class="nc" id="L239">      } catch (InstantiationException e) {</span>
<span class="nc" id="L240">        e.printStackTrace();</span>
<span class="nc" id="L241">        return null;</span>
<span class="nc" id="L242">      } catch (IllegalAccessException e) {</span>
<span class="nc" id="L243">        log.info(depReaderArgs.length + &quot; argument constructor to &quot; + altDepReaderName + &quot; is not public.&quot;);</span>
<span class="nc" id="L244">        return null;</span>
<span class="nc" id="L245">      } catch (NoSuchMethodException e) {</span>
<span class="nc" id="L246">        log.info(&quot;String arguments constructor to &quot; + altDepReaderName + &quot; does not exist.&quot;);</span>
<span class="nc" id="L247">        return null;</span>
<span class="nc" id="L248">      }</span>
    }
<span class="nc" id="L250">    return altDepReader;</span>
  }



  private static DependencyPrinter loadAlternateDependencyPrinter(String altDepPrinterName) {
<span class="nc" id="L256">    Class&lt;? extends DependencyPrinter&gt; altDepPrinterClass = null;</span>
<span class="nc" id="L257">    String[] toks = parseClassConstructArgs(altDepPrinterName);</span>
<span class="nc" id="L258">    altDepPrinterName = toks[0];</span>
<span class="nc" id="L259">    String[] depPrintArgs = new String[toks.length - 1];</span>
<span class="nc" id="L260">    System.arraycopy(toks, 1, depPrintArgs, 0, toks.length - 1);</span>

    try {
<span class="nc" id="L263">      Class&lt;?&gt; cl = Class.forName(altDepPrinterName);</span>
<span class="nc" id="L264">      altDepPrinterClass = cl.asSubclass(DependencyPrinter.class);</span>
<span class="nc" id="L265">    } catch (ClassNotFoundException e) {</span>
      //
<span class="nc" id="L267">    }</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">    if (altDepPrinterClass == null) {</span>
      try {
<span class="nc" id="L270">        Class&lt;?&gt; cl = Class.forName(&quot;edu.stanford.nlp.trees.&quot; + altDepPrinterName);</span>
<span class="nc" id="L271">        altDepPrinterClass = cl.asSubclass(DependencyPrinter.class);</span>
<span class="nc" id="L272">      } catch (ClassNotFoundException e) {</span>
        //
<span class="nc" id="L274">      }</span>
    }
<span class="nc bnc" id="L276" title="All 2 branches missed.">    if (altDepPrinterClass == null) {</span>
<span class="nc" id="L277">      System.err.printf(&quot;Unable to load alternative printer %s or %s. Is your classpath set correctly?\n&quot;, altDepPrinterName, &quot;edu.stanford.nlp.trees.&quot; + altDepPrinterName);</span>
<span class="nc" id="L278">      return null;</span>
    }
    try {
      DependencyPrinter depPrinter;
<span class="nc bnc" id="L282" title="All 2 branches missed.">      if (depPrintArgs.length == 0) {</span>
<span class="nc" id="L283">        depPrinter = altDepPrinterClass.newInstance();</span>
      } else {
<span class="nc" id="L285">        depPrinter = altDepPrinterClass.getConstructor(String[].class).newInstance((Object) depPrintArgs);</span>
      }
<span class="nc" id="L287">      return depPrinter;</span>
<span class="nc" id="L288">    } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L289">      e.printStackTrace();</span>
<span class="nc" id="L290">      return null;</span>
<span class="nc" id="L291">    } catch (SecurityException e) {</span>
<span class="nc" id="L292">      e.printStackTrace();</span>
<span class="nc" id="L293">      return null;</span>
<span class="nc" id="L294">    } catch (InstantiationException e) {</span>
<span class="nc" id="L295">      e.printStackTrace();</span>
<span class="nc" id="L296">      return null;</span>
<span class="nc" id="L297">    } catch (IllegalAccessException e) {</span>
<span class="nc" id="L298">      e.printStackTrace();</span>
<span class="nc" id="L299">      return null;</span>
<span class="nc" id="L300">    } catch (InvocationTargetException e) {</span>
<span class="nc" id="L301">      e.printStackTrace();</span>
<span class="nc" id="L302">      return null;</span>
<span class="nc" id="L303">    } catch (NoSuchMethodException e) {</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">      if (depPrintArgs.length == 0) {</span>
<span class="nc" id="L305">        System.err.printf(&quot;Can't find no-argument constructor %s().%n&quot;, altDepPrinterName);</span>
      } else {
<span class="nc" id="L307">        System.err.printf(&quot;Can't find constructor %s(%s).%n&quot;, altDepPrinterName, Arrays.toString(depPrintArgs));</span>
      }
<span class="nc" id="L309">      return null;</span>
    }
  }

  private static Function&lt;List&lt;? extends HasWord&gt;, Tree&gt; loadParser(String parserFile, String parserOptions, boolean makeCopulaHead) {
<span class="nc bnc" id="L314" title="All 4 branches missed.">    if (parserFile == null || &quot;&quot;.equals(parserFile)) {</span>
<span class="nc" id="L315">      parserFile = DEFAULT_PARSER_FILE;</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">      if (parserOptions == null) {</span>
<span class="nc" id="L317">        parserOptions = &quot;-retainTmpSubcategories&quot;;</span>
      }
    }
<span class="nc bnc" id="L320" title="All 2 branches missed.">    if (parserOptions == null) {</span>
<span class="nc" id="L321">      parserOptions = &quot;&quot;;</span>
    }
<span class="nc bnc" id="L323" title="All 2 branches missed.">    if (makeCopulaHead) {</span>
<span class="nc" id="L324">      parserOptions = &quot;-makeCopulaHead &quot; + parserOptions;</span>
    }
<span class="nc" id="L326">    parserOptions = parserOptions.trim();</span>
    // Load parser by reflection, so that this class doesn't require parser
    // for runtime use
    // LexicalizedParser lp = LexicalizedParser.loadModel(parserFile);
    // For example, the tregex package uses TreePrint, which uses
    // GrammaticalStructure, which would then import the
    // LexicalizedParser.  The tagger can read trees, which means it
    // would depend on tregex and therefore depend on the parser.
    Function&lt;List&lt;? extends HasWord&gt;, Tree&gt; lp;
    try {
<span class="nc" id="L336">      Class&lt;?&gt;[] classes = new Class&lt;?&gt;[] { String.class, String[].class };</span>
<span class="nc" id="L337">      Method method = Class.forName(&quot;edu.stanford.nlp.parser.lexparser.LexicalizedParser&quot;).getMethod(&quot;loadModel&quot;, classes);</span>
<span class="nc" id="L338">      String[] opts = StringUtils.EMPTY_STRING_ARRAY;</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">      if ( ! parserOptions.isEmpty()) {</span>
<span class="nc" id="L340">        opts = parserOptions.split(&quot; +&quot;);</span>
      }
<span class="nc" id="L342">      lp = (Function&lt;List&lt;? extends HasWord&gt;,Tree&gt;) method.invoke(null, parserFile, opts);</span>
<span class="nc" id="L343">    } catch (Exception cnfe) {</span>
<span class="nc" id="L344">      throw new RuntimeException(cnfe);</span>
<span class="nc" id="L345">    }</span>
<span class="nc" id="L346">    return lp;</span>
  }


  /**
   * Allow a collection of trees, that is a Treebank, appear to be a collection
   * of GrammaticalStructures.
   *
   * @author danielcer
   *
   */
  private static class TreeBankGrammaticalStructureWrapper implements Iterable&lt;GrammaticalStructure&gt; {

    private final Iterable&lt;Tree&gt; trees;
    private final boolean keepPunct;
    private final TreebankLangParserParams params;

<span class="nc" id="L363">    private final Map&lt;GrammaticalStructure, Tree&gt; origTrees = new WeakHashMap&lt;&gt;();</span>

<span class="nc" id="L365">    public TreeBankGrammaticalStructureWrapper(Iterable&lt;Tree&gt; wrappedTrees, boolean keepPunct, TreebankLangParserParams params) {</span>
<span class="nc" id="L366">      trees = wrappedTrees;</span>
<span class="nc" id="L367">      this.keepPunct = keepPunct;</span>
<span class="nc" id="L368">      this.params = params;</span>
<span class="nc" id="L369">    }</span>

    @Override
    public Iterator&lt;GrammaticalStructure&gt; iterator() {
<span class="nc" id="L373">      return new GsIterator();</span>
    }

    public Tree getOriginalTree(GrammaticalStructure gs) {
<span class="nc" id="L377">      return origTrees.get(gs);</span>
    }


    private class GsIterator implements Iterator&lt;GrammaticalStructure&gt; {

<span class="nc" id="L383">      private final Iterator&lt;Tree&gt; tbIterator = trees.iterator();</span>
      private final Predicate&lt;String&gt; puncFilter;
      private final HeadFinder hf;
      private GrammaticalStructure next;

<span class="nc" id="L388">      public GsIterator() {</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">        if (keepPunct) {</span>
<span class="nc" id="L390">          puncFilter = Filters.acceptFilter();</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">        } else if (params.generateOriginalDependencies()) {</span>
<span class="nc" id="L392">          puncFilter = params.treebankLanguagePack().punctuationWordRejectFilter();</span>
        } else {
<span class="nc" id="L394">          puncFilter = params.treebankLanguagePack().punctuationTagRejectFilter();</span>
        }
<span class="nc" id="L396">        hf = params.typedDependencyHeadFinder();</span>
<span class="nc" id="L397">        primeGs();</span>
<span class="nc" id="L398">      }</span>

      private void primeGs() {
<span class="nc" id="L401">        GrammaticalStructure gs = null;</span>
<span class="nc bnc" id="L402" title="All 4 branches missed.">        while (gs == null &amp;&amp; tbIterator.hasNext()) {</span>
<span class="nc" id="L403">          Tree t = tbIterator.next();</span>
          // log.info(&quot;GsIterator: Next tree is&quot;);
          // log.info(t);
<span class="nc bnc" id="L406" title="All 2 branches missed.">          if (t == null) {</span>
<span class="nc" id="L407">            continue;</span>
          }
          try {
<span class="nc" id="L410">            gs = params.getGrammaticalStructure(t, puncFilter, hf);</span>
<span class="nc" id="L411">            origTrees.put(gs, t);</span>
<span class="nc" id="L412">            next = gs;</span>
            // log.info(&quot;GsIterator: Next tree is&quot;);
            // log.info(t);
<span class="nc" id="L415">            return;</span>
<span class="nc" id="L416">          } catch (NullPointerException npe) {</span>
<span class="nc" id="L417">            log.info(&quot;Bung tree caused below dump. Continuing....&quot;);</span>
<span class="nc" id="L418">            log.info(t);</span>
<span class="nc" id="L419">            npe.printStackTrace();</span>
          }
<span class="nc" id="L421">        }</span>
<span class="nc" id="L422">        next = null;</span>
<span class="nc" id="L423">      }</span>

      @Override
      public boolean hasNext() {
<span class="nc bnc" id="L427" title="All 2 branches missed.">        return next != null;</span>
      }

      @Override
      public GrammaticalStructure next() {
<span class="nc" id="L432">        GrammaticalStructure ret = next;</span>
<span class="nc bnc" id="L433" title="All 2 branches missed.">        if (ret == null) {</span>
<span class="nc" id="L434">          throw new NoSuchElementException();</span>
        }
<span class="nc" id="L436">        primeGs();</span>
<span class="nc" id="L437">        return ret;</span>
      }

      @Override
      public void remove() {
<span class="nc" id="L442">        throw new UnsupportedOperationException();</span>
      }

    }
  } // end static class TreebankGrammaticalStructureWrapper


  /**
   * Enum to identify the different TokenizerTypes. To add a new
   * TokenizerType, add it to the list with a default options string
   * and add a clause in getTokenizerType to identify it.
   */
<span class="nc" id="L454">  public enum ConverterOptions {</span>
<span class="nc" id="L455">    UniversalEnglish(&quot;en&quot;, new NPTmpRetainingTreeNormalizer(0, false, 1, false),</span>
        &quot;edu.stanford.nlp.parser.lexparser.EnglishTreebankParserParams&quot;, false, true),
<span class="nc" id="L457">    UniversalChinese(&quot;zh&quot;, new CTBErrorCorrectingTreeNormalizer(false, false, false, false),</span>
        &quot;edu.stanford.nlp.parser.lexparser.ChineseTreebankParserParams&quot;, false, false),
<span class="nc" id="L459">    English(&quot;en-sd&quot;, new NPTmpRetainingTreeNormalizer(0, false, 1, false),</span>
        &quot;edu.stanford.nlp.parser.lexparser.EnglishTreebankParserParams&quot;, true, true),
<span class="nc" id="L461">    Chinese(&quot;zh-sd&quot;, new CTBErrorCorrectingTreeNormalizer(false, false, false, false),</span>
        &quot;edu.stanford.nlp.parser.lexparser.ChineseTreebankParserParams&quot;, true, false);

    public final String abbreviation;
    public final TreeNormalizer treeNormalizer;
    public final String tlPPClassName;
    public final boolean stanfordDependencies;
    /* Conversion to UPOS is currently only supported for English. */
    public final boolean convertToUPOS;

    ConverterOptions(String abbreviation, TreeNormalizer treeNormalizer, String tlPPClassName,
<span class="nc" id="L472">                     boolean stanfordDependencies, boolean convertToUPOS) {</span>
<span class="nc" id="L473">      this.abbreviation = abbreviation;</span>
<span class="nc" id="L474">      this.treeNormalizer = treeNormalizer;</span>
<span class="nc" id="L475">      this.tlPPClassName = tlPPClassName;</span>
      /* Generate old Stanford Dependencies instead of UD, when set to true. */
<span class="nc" id="L477">      this.stanfordDependencies = stanfordDependencies;</span>
<span class="nc" id="L478">      this.convertToUPOS = convertToUPOS;</span>
<span class="nc" id="L479">    }</span>

<span class="nc" id="L481">    private static final Map&lt;String, ConverterOptions&gt; nameToTokenizerMap = initializeNameMap();</span>

    private static Map&lt;String, ConverterOptions&gt; initializeNameMap() {
<span class="nc" id="L484">      Map&lt;String, ConverterOptions&gt; map = Generics.newHashMap();</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">      for (ConverterOptions opts : ConverterOptions.values()) {</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">        if (opts.abbreviation != null) {</span>
<span class="nc" id="L487">          map.put(opts.abbreviation.toUpperCase(), opts);</span>
        }
<span class="nc" id="L489">        map.put(opts.toString().toUpperCase(), opts);</span>
      }
<span class="nc" id="L491">      return Collections.unmodifiableMap(map);</span>
    }

    public static ConverterOptions getConverterOptions(String language) {
<span class="nc bnc" id="L495" title="All 2 branches missed.">      if (language == null) { return nameToTokenizerMap.get(&quot;EN&quot;); }</span>
<span class="nc" id="L496">      ConverterOptions opts = nameToTokenizerMap.get(language.toUpperCase());</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">      return opts != null ? opts : nameToTokenizerMap.get(&quot;EN&quot;);</span>
    }
  }

  /**
   * Given sentences or trees, output the typed dependencies.
   * &lt;p&gt;

   * By default, the method outputs the collapsed typed dependencies with
   * processing of conjuncts. The input can be given as plain text (one sentence
   * by line) using the option -sentFile, or as trees using the option
   * -treeFile. For -sentFile, the input has to be strictly one sentence per
   * line. You can specify where to find a parser with -parserFile
   * serializedParserPath. See LexicalizedParser for more flexible processing of
   * text files (including with Stanford Dependencies output). The above options
   * assume a file as input. You can also feed trees (only) via stdin by using
   * the option -filter.  If one does not specify a -parserFile, one
   * can specify which language pack to use with -tLPP, This option
   * specifies a class which determines which GrammaticalStructure to
   * use, which HeadFinder to use, etc.  It will default to
   * edu.stanford.nlp.parser.lexparser.EnglishTreebankParserParams,
   * but any TreebankLangParserParams can be specified.
   * &lt;p&gt;
   * If no method of producing trees is given other than to use the
   * LexicalizedParser, but no parser is specified, a default parser
   * is used, the English parser.  You can specify options to load
   * with the parser using the -parserOpts flag.  If the default
   * parser is used, and no options are provided, the option
   * -retainTmpSubcategories is used.
   * &lt;p&gt;
   * The following options can be used to specify the types of dependencies
   * wanted: &lt;/p&gt;
   * &lt;ul&gt;
   * &lt;li&gt; -collapsed collapsed dependencies
   * &lt;li&gt; -basic non-collapsed dependencies that preserve a tree structure
   * &lt;li&gt; -nonCollapsed non-collapsed dependencies that do not preserve a tree
   * structure (the basic dependencies plus the extra ones)
   * &lt;li&gt; -CCprocessed
   * collapsed dependencies and conjunctions processed (dependencies are added
   * for each conjunct) -- this is the default if no options are passed
   * &lt;li&gt; -collapsedTree collapsed dependencies retaining a tree structure
   * &lt;li&gt; -makeCopulaHead Contrary to the approach argued for in the SD papers,
   *  nevertheless make the verb 'to be' the head, not the predicate noun, adjective,
   *  etc. (However, when the verb 'to be' is used as an auxiliary verb, the main
   *  verb is still treated as the head.)
   * &lt;li&gt; -originalDependencies generate the dependencies using the original converter
   * instead of the Universal Dependencies converter.
   * &lt;/ul&gt;
   * &lt;p&gt;
   * The {@code -conllx} option will output the dependencies in the CoNLL format,
   * instead of in the standard Stanford format (relation(governor,dependent))
   * and will retain punctuation by default.
   * When used in the &quot;collapsed&quot; format, words such as prepositions, conjunctions
   * which get collapsed into the grammatical relations and are not part of the
   * sentence per se anymore will be annotated with &quot;erased&quot; as grammatical relation
   * and attached to the fake &quot;ROOT&quot; node with index 0.
   * &lt;p/&gt;&lt;p&gt;
   * There is also an option to retain dependencies involving punctuation:
   * {@code -keepPunct}
   * &lt;/p&gt;&lt;p&gt;
   * The {@code -extraSep} option used with -nonCollapsed will print the basic
   * dependencies first, then a separator ======, and then the extra
   * dependencies that do not preserve the tree structure. The -test option is
   * used for debugging: it prints the grammatical structure, as well as the
   * basic, collapsed and CCprocessed dependencies. It also checks the
   * connectivity of the collapsed dependencies. If the collapsed dependencies
   * list doesn't constitute a connected graph, it prints the possible offending
   * nodes (one of them is the real root of the graph).
   * &lt;/p&gt;&lt;p&gt;
   * Using the -conllxFile, you can pass a file containing Stanford dependencies
   * in the CoNLL format (e.g., the basic dependencies), and obtain another
   * representation using one of the representation options.
   * &lt;/p&gt;&lt;p&gt;
   * Usage: &lt;br&gt;
   * &lt;code&gt;java edu.stanford.nlp.trees.GrammaticalStructure [-treeFile FILE | -sentFile FILE | -conllxFile FILE | -filter] &lt;br&gt;
   * [-collapsed -basic -CCprocessed -test -generateOriginalDependencies]&lt;/code&gt;
   *
   * @param args Command-line arguments, as above
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static void convertTrees(String[] args, String defaultLang) {

    /* Use a tree normalizer that removes all empty nodes.
       This prevents wrong indexing of the nodes in the dependency relations. */



<span class="nc" id="L584">    Iterable&lt;GrammaticalStructure&gt; gsBank = null;</span>
<span class="nc" id="L585">    Properties props = StringUtils.argsToProperties(args);</span>

<span class="nc" id="L587">    String language = props.getProperty(&quot;language&quot;, defaultLang);</span>
<span class="nc" id="L588">    ConverterOptions opts = ConverterOptions.getConverterOptions(language);</span>


<span class="nc" id="L591">    MemoryTreebank tb = new MemoryTreebank(opts.treeNormalizer);</span>
<span class="nc" id="L592">    Iterable&lt;Tree&gt; trees = tb;</span>



<span class="nc" id="L596">    String encoding = props.getProperty(&quot;encoding&quot;, &quot;utf-8&quot;);</span>
    try {
<span class="nc" id="L598">      System.setOut(new PrintStream(System.out, true, encoding));</span>
<span class="nc" id="L599">    } catch (IOException e) {</span>
<span class="nc" id="L600">      throw new RuntimeException(e);</span>
<span class="nc" id="L601">    }</span>

<span class="nc" id="L603">    String treeFileName = props.getProperty(&quot;treeFile&quot;);</span>
<span class="nc" id="L604">    String sentFileName = props.getProperty(&quot;sentFile&quot;);</span>
<span class="nc" id="L605">    String conllXFileName = props.getProperty(&quot;conllxFile&quot;);</span>
<span class="nc" id="L606">    String altDepPrinterName = props.getProperty(&quot;altprinter&quot;);</span>
<span class="nc" id="L607">    String altDepReaderName = props.getProperty(&quot;altreader&quot;);</span>
<span class="nc" id="L608">    String altDepReaderFilename = props.getProperty(&quot;altreaderfile&quot;);</span>

<span class="nc" id="L610">    String filter = props.getProperty(&quot;filter&quot;);</span>

<span class="nc bnc" id="L612" title="All 2 branches missed.">    boolean makeCopulaHead = props.getProperty(&quot;makeCopulaHead&quot;) != null;</span>
<span class="nc bnc" id="L613" title="All 4 branches missed.">    boolean generateOriginalDependencies = props.getProperty(&quot;originalDependencies&quot;) != null || opts.stanfordDependencies;</span>

    // TODO: if a parser is specified, load this from the parser
    // instead of ever loading it from this way
<span class="nc" id="L617">    String tLPP = props.getProperty(&quot;tLPP&quot;, opts.tlPPClassName);</span>
<span class="nc" id="L618">    TreebankLangParserParams params = ReflectionLoading.loadByReflection(tLPP);</span>
<span class="nc" id="L619">    params.setGenerateOriginalDependencies(generateOriginalDependencies);</span>

<span class="nc bnc" id="L621" title="All 2 branches missed.">    if (makeCopulaHead) {</span>
      // TODO: generalize and allow for more options
<span class="nc" id="L623">      String[] options = { &quot;-makeCopulaHead&quot; };</span>
<span class="nc" id="L624">      params.setOptionFlag(options, 0);</span>
    }

<span class="nc bnc" id="L627" title="All 12 branches missed.">    if (sentFileName == null &amp;&amp; (altDepReaderName == null || altDepReaderFilename == null) &amp;&amp; treeFileName == null &amp;&amp; conllXFileName == null &amp;&amp; filter == null) {</span>
      try {
<span class="nc" id="L629">        System.err.printf(&quot;Usage: java %s%n&quot;, GrammaticalStructure.class.getCanonicalName());</span>
<span class="nc" id="L630">        System.err.println(&quot;Options:&quot;);</span>
<span class="nc" id="L631">        System.err.println(&quot;  Dependency representation:&quot;);</span>
<span class="nc" id="L632">        System.err.println(&quot;    -basic:\t\tGenerate basic dependencies.&quot;);</span>
<span class="nc" id="L633">        System.err.println(&quot;    -enhanced:\t\tGenerate enhanced dependencies, currently only implemented for English UD.&quot;);</span>
<span class="nc" id="L634">        System.err.println(&quot;    -enhanced++:\tGenerate enhanced++ dependencies (default), currently only implemented for English UD.&quot;);</span>
<span class="nc" id="L635">        System.err.println(&quot;    -collapsed:\t\tGenerate collapsed dependencies, deprecated.&quot;);</span>
<span class="nc" id="L636">        System.err.println(&quot;    -CCprocessed:\tGenerate CC-processed dependencies, deprecated.&quot;);</span>
<span class="nc" id="L637">        System.err.println(&quot;    -collapsedTree:\tGenerate collapsed-tree dependencies, deprecated.&quot;);</span>
<span class="nc" id="L638">        System.err.println(&quot;&quot;);</span>
<span class="nc" id="L639">        System.err.println(&quot;  Input:&quot;);</span>
<span class="nc" id="L640">        System.err.println(&quot;    -treeFile &lt;FILE&gt;:\tConvert from constituency trees in &lt;FILE&gt;&quot;);</span>
<span class="nc" id="L641">        System.err.println(&quot;    -sentFile &lt;FILE&gt;:\tParse and convert sentences from &lt;FILE&gt;. Only implemented for English.&quot;);</span>
<span class="nc" id="L642">        System.err.println(&quot;&quot;);</span>
<span class="nc" id="L643">        System.err.println(&quot;  Output:&quot;);</span>
<span class="nc" id="L644">        System.err.println(&quot;    -conllx:\t\tOutput dependencies in CoNLL format.&quot;);</span>
<span class="nc" id="L645">        System.err.println(&quot;&quot;);</span>
<span class="nc" id="L646">        System.err.println(&quot;  Language:&quot;);</span>
<span class="nc" id="L647">        System.err.println(&quot;    -language [en|zh|en-sd|zh-sd]:\t (Universal English Dependencies, Universal Chinese Dependencies, English Stanford Dependencies, Chinese Stanford Dependencies)&quot;);</span>
<span class="nc" id="L648">        System.err.println(&quot;&quot;);</span>
<span class="nc" id="L649">        System.err.println(&quot;&quot;);</span>
<span class="nc" id="L650">        System.err.println(&quot;&quot;);</span>
<span class="nc" id="L651">        System.err.println(&quot;Example:&quot;);</span>
<span class="nc" id="L652">        TreeReader tr = new PennTreeReader(new StringReader(&quot;((S (NP (NNP Sam)) (VP (VBD died) (NP-TMP (NN today)))))&quot;));</span>
<span class="nc" id="L653">        tb.add(tr.readTree());</span>
<span class="nc" id="L654">      } catch (Exception e) {</span>
<span class="nc" id="L655">        log.info(&quot;Horrible error: &quot; + e);</span>
<span class="nc" id="L656">        e.printStackTrace();</span>
<span class="nc" id="L657">      }</span>
<span class="nc bnc" id="L658" title="All 4 branches missed.">    } else if (altDepReaderName != null &amp;&amp; altDepReaderFilename != null) {</span>
<span class="nc" id="L659">      DependencyReader altDepReader = loadAlternateDependencyReader(altDepReaderName);</span>
      try {
<span class="nc" id="L661">        gsBank = altDepReader.readDependencies(altDepReaderFilename);</span>
<span class="nc" id="L662">      } catch (IOException e) {</span>
<span class="nc" id="L663">        log.info(&quot;Error reading &quot; + altDepReaderFilename);</span>
<span class="nc" id="L664">        return;</span>
<span class="nc" id="L665">      }</span>
<span class="nc bnc" id="L666" title="All 2 branches missed.">    } else if (treeFileName != null) {</span>
<span class="nc" id="L667">      tb.loadPath(treeFileName);</span>
<span class="nc bnc" id="L668" title="All 2 branches missed.">    } else if (filter != null) {</span>
<span class="nc" id="L669">      tb.load(IOUtils.readerFromStdin());</span>
<span class="nc bnc" id="L670" title="All 2 branches missed.">    } else if (conllXFileName != null) {</span>
      try {
<span class="nc" id="L672">        gsBank = params.readGrammaticalStructureFromFile(conllXFileName);</span>
<span class="nc" id="L673">      } catch (RuntimeIOException e) {</span>
<span class="nc" id="L674">        log.info(&quot;Error reading &quot; + conllXFileName);</span>
<span class="nc" id="L675">        return;</span>
<span class="nc" id="L676">      }</span>
    } else {
<span class="nc" id="L678">      String parserFile = props.getProperty(&quot;parserFile&quot;);</span>
<span class="nc" id="L679">      String parserOpts = props.getProperty(&quot;parserOpts&quot;);</span>
<span class="nc bnc" id="L680" title="All 2 branches missed.">      boolean tokenized = props.getProperty(&quot;tokenized&quot;) != null;</span>
<span class="nc" id="L681">      Function&lt;List&lt;? extends HasWord&gt;, Tree&gt; lp = loadParser(parserFile, parserOpts, makeCopulaHead);</span>
<span class="nc" id="L682">      trees = new LazyLoadTreesByParsing(sentFileName, encoding, tokenized, lp);</span>

      // Instead of getting this directly from the LP, use reflection
      // so that a package which uses GrammaticalStructure doesn't
      // necessarily have to use LexicalizedParser
      try {
<span class="nc" id="L688">        Method method = lp.getClass().getMethod(&quot;getTLPParams&quot;);</span>
<span class="nc" id="L689">        params = (TreebankLangParserParams) method.invoke(lp);</span>
<span class="nc" id="L690">        params.setGenerateOriginalDependencies(generateOriginalDependencies);</span>
<span class="nc" id="L691">      } catch (Exception cnfe) {</span>
<span class="nc" id="L692">        throw new RuntimeException(cnfe);</span>
<span class="nc" id="L693">      }</span>
    }

    // treats the output according to the options passed
<span class="nc bnc" id="L697" title="All 2 branches missed.">    boolean basic = props.getProperty(&quot;basic&quot;) != null;</span>
<span class="nc bnc" id="L698" title="All 2 branches missed.">    boolean collapsed = props.getProperty(&quot;collapsed&quot;) != null;</span>
<span class="nc bnc" id="L699" title="All 2 branches missed.">    boolean CCprocessed = props.getProperty(&quot;CCprocessed&quot;) != null;</span>
<span class="nc bnc" id="L700" title="All 2 branches missed.">    boolean collapsedTree = props.getProperty(&quot;collapsedTree&quot;) != null;</span>
<span class="nc bnc" id="L701" title="All 2 branches missed.">    boolean nonCollapsed = props.getProperty(&quot;nonCollapsed&quot;) != null;</span>
<span class="nc bnc" id="L702" title="All 2 branches missed.">    boolean extraSep = props.getProperty(&quot;extraSep&quot;) != null;</span>
<span class="nc bnc" id="L703" title="All 2 branches missed.">    boolean parseTree = props.getProperty(&quot;parseTree&quot;) != null;</span>
<span class="nc bnc" id="L704" title="All 2 branches missed.">    boolean test = props.getProperty(&quot;test&quot;) != null;</span>
<span class="nc" id="L705">    boolean keepPunct = true; //always keep punctuation marks</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">    boolean conllx = props.getProperty(&quot;conllx&quot;) != null;</span>
    // todo: Support checkConnected on more options (including basic)
<span class="nc bnc" id="L708" title="All 2 branches missed.">    boolean checkConnected = props.getProperty(&quot;checkConnected&quot;) != null;</span>
<span class="nc bnc" id="L709" title="All 2 branches missed.">    boolean portray = props.getProperty(&quot;portray&quot;) != null;</span>
<span class="nc bnc" id="L710" title="All 2 branches missed.">    boolean enhanced = props.getProperty(&quot;enhanced&quot;) != null;</span>
<span class="nc bnc" id="L711" title="All 2 branches missed.">    boolean enhancedPlusPlus = props.getProperty(&quot;enhanced++&quot;) != null;</span>


    // If requested load alternative printer
<span class="nc" id="L715">    DependencyPrinter altDepPrinter = null;</span>
<span class="nc bnc" id="L716" title="All 2 branches missed.">    if (altDepPrinterName != null) {</span>
<span class="nc" id="L717">      altDepPrinter = loadAlternateDependencyPrinter(altDepPrinterName);</span>
    }

    // log.info(&quot;First tree in tb is&quot;);
    // log.info(((MemoryTreebank) tb).get(0));

<span class="nc" id="L723">    Method m = null;</span>
<span class="nc bnc" id="L724" title="All 2 branches missed.">    if (test) {</span>
      // see if we can use SemanticGraph(Factory) to check for being a DAG
      // Do this by reflection to avoid this becoming a dependency when we distribute the parser
      try {
<span class="nc" id="L728">        Class sgf = Class.forName(&quot;edu.stanford.nlp.semgraph.SemanticGraphFactory&quot;);</span>
<span class="nc" id="L729">        m = sgf.getDeclaredMethod(&quot;makeFromTree&quot;, GrammaticalStructure.class, boolean.class, boolean.class, boolean.class, boolean.class, boolean.class, boolean.class, Predicate.class, String.class, int.class);</span>
<span class="nc" id="L730">      } catch (Exception e) {</span>
<span class="nc" id="L731">        log.info(&quot;Test cannot check for cycles in tree format (classes not available)&quot;);</span>
<span class="nc" id="L732">      }</span>
    }

<span class="nc bnc" id="L735" title="All 2 branches missed.">    if (gsBank == null) {</span>
<span class="nc" id="L736">      gsBank = new TreeBankGrammaticalStructureWrapper(trees, keepPunct, params);</span>
    }

<span class="nc bnc" id="L739" title="All 2 branches missed.">    for (GrammaticalStructure gs : gsBank) {</span>

      Tree tree;
<span class="nc bnc" id="L742" title="All 2 branches missed.">      if (gsBank instanceof TreeBankGrammaticalStructureWrapper) {</span>
        // log.info(&quot;Using TreeBankGrammaticalStructureWrapper branch&quot;);
<span class="nc" id="L744">        tree = ((TreeBankGrammaticalStructureWrapper) gsBank).getOriginalTree(gs);</span>
        // log.info(&quot;Tree is: &quot;);
        // log.info(t);
      } else {
        // log.info(&quot;Using gs.root() branch&quot;);
<span class="nc" id="L749">        tree = gs.root(); // recover tree</span>
        // log.info(&quot;Tree from gs is&quot;);
        // log.info(t);
      }

<span class="nc bnc" id="L754" title="All 2 branches missed.">      if (test) { // print the grammatical structure, the basic, collapsed and CCprocessed</span>

<span class="nc" id="L756">        System.out.println(&quot;============= parse tree =======================&quot;);</span>
<span class="nc" id="L757">        tree.pennPrint();</span>
<span class="nc" id="L758">        System.out.println();</span>

<span class="nc" id="L760">        System.out.println(&quot;------------- GrammaticalStructure -------------&quot;);</span>
<span class="nc" id="L761">        System.out.println(gs);</span>

<span class="nc" id="L763">        boolean allConnected = true;</span>
        boolean connected;
<span class="nc" id="L765">        Collection&lt;TypedDependency&gt; bungRoots = null;</span>
<span class="nc" id="L766">        System.out.println(&quot;------------- basic dependencies ---------------&quot;);</span>
<span class="nc" id="L767">        List&lt;TypedDependency&gt; gsb = gs.typedDependencies(GrammaticalStructure.Extras.NONE);</span>
<span class="nc" id="L768">        System.out.println(StringUtils.join(gsb, &quot;\n&quot;));</span>
<span class="nc" id="L769">        connected = GrammaticalStructure.isConnected(gsb);</span>
<span class="nc bnc" id="L770" title="All 4 branches missed.">        if ( ! connected &amp;&amp; bungRoots == null) {</span>
<span class="nc" id="L771">          bungRoots = GrammaticalStructure.getRoots(gsb);</span>
        }
<span class="nc bnc" id="L773" title="All 4 branches missed.">        allConnected = connected &amp;&amp; allConnected;</span>

<span class="nc" id="L775">        System.out.println(&quot;------------- non-collapsed dependencies (basic + extra) ---------------&quot;);</span>
<span class="nc" id="L776">        List&lt;TypedDependency&gt; gse = gs.typedDependencies(GrammaticalStructure.Extras.MAXIMAL);</span>
<span class="nc" id="L777">        System.out.println(StringUtils.join(gse, &quot;\n&quot;));</span>
<span class="nc" id="L778">        connected = GrammaticalStructure.isConnected(gse);</span>
<span class="nc bnc" id="L779" title="All 4 branches missed.">        if ( ! connected &amp;&amp; bungRoots == null) {</span>
<span class="nc" id="L780">          bungRoots = GrammaticalStructure.getRoots(gse);</span>
        }
<span class="nc bnc" id="L782" title="All 4 branches missed.">        allConnected = connected &amp;&amp; allConnected;</span>

<span class="nc" id="L784">        System.out.println(&quot;------------- collapsed dependencies -----------&quot;);</span>
<span class="nc" id="L785">        System.out.println(StringUtils.join(gs.typedDependenciesCollapsed(GrammaticalStructure.Extras.MAXIMAL), &quot;\n&quot;));</span>

<span class="nc" id="L787">        System.out.println(&quot;------------- collapsed dependencies tree -----------&quot;);</span>
<span class="nc" id="L788">        System.out.println(StringUtils.join(gs.typedDependenciesCollapsedTree(), &quot;\n&quot;));</span>

<span class="nc" id="L790">        System.out.println(&quot;------------- CCprocessed dependencies --------&quot;);</span>
<span class="nc" id="L791">        List&lt;TypedDependency&gt; gscc = gs.typedDependenciesCollapsed(GrammaticalStructure.Extras.MAXIMAL);</span>
<span class="nc" id="L792">        System.out.println(StringUtils.join(gscc, &quot;\n&quot;));</span>

<span class="nc" id="L794">        System.out.println(&quot;-----------------------------------------------&quot;);</span>
        // connectivity tests
<span class="nc" id="L796">        connected = GrammaticalStructure.isConnected(gscc);</span>
<span class="nc bnc" id="L797" title="All 4 branches missed.">        if ( ! connected &amp;&amp; bungRoots == null) {</span>
<span class="nc" id="L798">          bungRoots = GrammaticalStructure.getRoots(gscc);</span>
        }
<span class="nc bnc" id="L800" title="All 4 branches missed.">        allConnected = connected &amp;&amp; allConnected;</span>
<span class="nc bnc" id="L801" title="All 2 branches missed.">        if (allConnected) {</span>
<span class="nc" id="L802">          System.out.println(&quot;dependencies form connected graphs.&quot;);</span>
        } else {
<span class="nc" id="L804">          System.out.println(&quot;dependency graph NOT connected! possible offending nodes: &quot; + bungRoots);</span>
        }

        // test for collapsed dependencies being a tree:
        // make sure at least it doesn't contain cycles (i.e., is a DAG)
        // Do this by reflection so parser doesn't need SemanticGraph and its
        // libraries
<span class="nc bnc" id="L811" title="All 2 branches missed.">        if (m != null) {</span>
          try {
            // the first arg is null because it's a static method....
<span class="nc" id="L814">            Object semGraph = m.invoke(null, gs, false, true, false, false, false, false, null, null, 0);</span>
<span class="nc" id="L815">            Class sg = Class.forName(&quot;edu.stanford.nlp.semgraph.SemanticGraph&quot;);</span>
<span class="nc" id="L816">            Method mDag = sg.getDeclaredMethod(&quot;isDag&quot;);</span>
<span class="nc" id="L817">            boolean isDag = (Boolean) mDag.invoke(semGraph);</span>

<span class="nc" id="L819">            System.out.println(&quot;tree dependencies form a DAG: &quot; + isDag);</span>
<span class="nc" id="L820">          } catch (Exception e) {</span>
<span class="nc" id="L821">            e.printStackTrace();</span>
<span class="nc" id="L822">          }</span>
        }
<span class="nc" id="L824">      }// end of &quot;test&quot; output</span>

      else {
<span class="nc bnc" id="L827" title="All 2 branches missed.">        if (parseTree) {</span>
<span class="nc" id="L828">          System.out.println(&quot;============= parse tree =======================&quot;);</span>
<span class="nc" id="L829">          tree.pennPrint();</span>
<span class="nc" id="L830">          System.out.println();</span>
        }

<span class="nc bnc" id="L833" title="All 2 branches missed.">        if (basic) {</span>
<span class="nc bnc" id="L834" title="All 12 branches missed.">          if (collapsed || CCprocessed || collapsedTree || nonCollapsed || enhanced || enhancedPlusPlus) {</span>
<span class="nc" id="L835">            System.out.println(&quot;------------- basic dependencies ---------------&quot;);</span>
          }
<span class="nc bnc" id="L837" title="All 2 branches missed.">          if (altDepPrinter == null) {</span>
<span class="nc" id="L838">            printDependencies(gs, gs.typedDependencies(GrammaticalStructure.Extras.NONE), tree, conllx, false, opts.convertToUPOS);</span>
          } else {
<span class="nc" id="L840">            System.out.println(altDepPrinter.dependenciesToString(gs, gs.typedDependencies(GrammaticalStructure.Extras.NONE), tree));</span>
          }
        }

<span class="nc bnc" id="L844" title="All 2 branches missed.">        if (nonCollapsed) {</span>
<span class="nc bnc" id="L845" title="All 8 branches missed.">          if (basic || CCprocessed || collapsed || collapsedTree) {</span>
<span class="nc" id="L846">            System.out.println(&quot;----------- non-collapsed dependencies (basic + extra) -----------&quot;);</span>
          }
<span class="nc" id="L848">          printDependencies(gs, gs.allTypedDependencies(), tree, conllx, extraSep, opts.convertToUPOS);</span>
        }

<span class="nc bnc" id="L851" title="All 2 branches missed.">        if (collapsed) {</span>
<span class="nc bnc" id="L852" title="All 8 branches missed.">          if (basic || CCprocessed || collapsedTree || nonCollapsed) {</span>
<span class="nc" id="L853">            System.out.println(&quot;----------- collapsed dependencies -----------&quot;);</span>
          }
<span class="nc" id="L855">          printDependencies(gs, gs.typedDependenciesCollapsed(GrammaticalStructure.Extras.MAXIMAL), tree, conllx, false, opts.convertToUPOS);</span>
        }

<span class="nc bnc" id="L858" title="All 2 branches missed.">        if (CCprocessed) {</span>
<span class="nc bnc" id="L859" title="All 8 branches missed.">          if (basic || collapsed || collapsedTree || nonCollapsed) {</span>
<span class="nc" id="L860">            System.out.println(&quot;---------- CCprocessed dependencies ----------&quot;);</span>
          }
<span class="nc" id="L862">          List&lt;TypedDependency&gt; deps = gs.typedDependenciesCCprocessed(GrammaticalStructure.Extras.MAXIMAL);</span>
<span class="nc bnc" id="L863" title="All 2 branches missed.">          if (checkConnected) {</span>
<span class="nc bnc" id="L864" title="All 2 branches missed.">            if (!GrammaticalStructure.isConnected(deps)) {</span>
<span class="nc" id="L865">              log.info(&quot;Graph is not connected for:&quot;);</span>
<span class="nc" id="L866">              log.info(tree);</span>
<span class="nc" id="L867">              log.info(&quot;possible offending nodes: &quot; + GrammaticalStructure.getRoots(deps));</span>
            }
          }
<span class="nc" id="L870">          printDependencies(gs, deps, tree, conllx, false, opts.convertToUPOS);</span>
        }

<span class="nc bnc" id="L873" title="All 2 branches missed.">        if (collapsedTree) {</span>
<span class="nc bnc" id="L874" title="All 8 branches missed.">          if (basic || CCprocessed || collapsed || nonCollapsed) {</span>
<span class="nc" id="L875">            System.out.println(&quot;----------- collapsed dependencies tree -----------&quot;);</span>
          }
<span class="nc" id="L877">          printDependencies(gs, gs.typedDependenciesCollapsedTree(), tree, conllx, false, opts.convertToUPOS);</span>
        }

<span class="nc bnc" id="L880" title="All 2 branches missed.">        if (enhanced) {</span>
<span class="nc bnc" id="L881" title="All 4 branches missed.">          if (basic || enhancedPlusPlus) {</span>
<span class="nc" id="L882">            System.out.println(&quot;----------- enhanced dependencies tree -----------&quot;);</span>
          }
<span class="nc" id="L884">          printDependencies(gs, gs.typedDependenciesEnhanced(), tree, conllx, false, opts.convertToUPOS);</span>
        }

<span class="nc bnc" id="L887" title="All 2 branches missed.">        if (enhancedPlusPlus) {</span>
<span class="nc bnc" id="L888" title="All 4 branches missed.">          if (basic || enhanced) {</span>
<span class="nc" id="L889">            System.out.println(&quot;----------- enhanced++ dependencies tree -----------&quot;);</span>
          }
<span class="nc" id="L891">          printDependencies(gs, gs.typedDependenciesEnhancedPlusPlus(), tree, conllx, false, opts.convertToUPOS);</span>
        }

        // default use: enhanced++ for UD, CCprocessed for SD (to parallel what happens within the parser)
<span class="nc bnc" id="L895" title="All 14 branches missed.">        if (!basic &amp;&amp; !collapsed &amp;&amp; !CCprocessed &amp;&amp; !collapsedTree &amp;&amp; !nonCollapsed &amp;&amp; !enhanced &amp;&amp; !enhancedPlusPlus) {</span>
          // System.out.println(&quot;----------- CCprocessed dependencies -----------&quot;);

<span class="nc bnc" id="L898" title="All 2 branches missed.">          if (generateOriginalDependencies) {</span>
<span class="nc" id="L899">            printDependencies(gs, gs.typedDependenciesCCprocessed(GrammaticalStructure.Extras.MAXIMAL), tree, conllx, false, opts.convertToUPOS);</span>
          } else {
<span class="nc" id="L901">            printDependencies(gs, gs.typedDependenciesEnhancedPlusPlus(), tree, conllx, false, opts.convertToUPOS);</span>
          }
        }
      }

<span class="nc bnc" id="L906" title="All 2 branches missed.">      if (portray) {</span>
        try {
          // put up a window showing it
<span class="nc" id="L909">          Class sgu = Class.forName(&quot;edu.stanford.nlp.semgraph.SemanticGraphUtils&quot;);</span>
<span class="nc" id="L910">          Method mRender = sgu.getDeclaredMethod(&quot;render&quot;, GrammaticalStructure.class, String.class);</span>
          // the first arg is null because it's a static method....
<span class="nc" id="L912">          mRender.invoke(null, gs, &quot;Collapsed, CC processed deps&quot;);</span>
<span class="nc" id="L913">        } catch (Exception e) {</span>
<span class="nc" id="L914">          throw new RuntimeException(&quot;Couldn't use swing to portray semantic graph&quot;, e);</span>
<span class="nc" id="L915">        }</span>
      }

<span class="nc" id="L918">    } // end for</span>
<span class="nc" id="L919">  } // end convertTrees</span>


  // todo [cdm 2013]: Take this out and make it a trees class: TreeIterableByParsing
<span class="nc" id="L923">  static class LazyLoadTreesByParsing implements Iterable&lt;Tree&gt; {</span>

    final Reader reader;
    final String filename;
    final boolean tokenized;
    final String encoding;
    final Function&lt;List&lt;? extends HasWord&gt;, Tree&gt; lp;

<span class="nc" id="L931">    public LazyLoadTreesByParsing(String filename, String encoding, boolean tokenized, Function&lt;List&lt;? extends HasWord&gt;, Tree&gt; lp) {</span>
<span class="nc" id="L932">      this.filename = filename;</span>
<span class="nc" id="L933">      this.encoding = encoding;</span>
<span class="nc" id="L934">      this.reader = null;</span>
<span class="nc" id="L935">      this.tokenized = tokenized;</span>
<span class="nc" id="L936">      this.lp = lp;</span>
<span class="nc" id="L937">    }</span>

    @Override
    public Iterator&lt;Tree&gt; iterator() {
      final BufferedReader iReader;
<span class="nc bnc" id="L942" title="All 2 branches missed.">      if (reader != null) {</span>
<span class="nc" id="L943">        iReader = new BufferedReader(reader);</span>
      } else {
        try {
<span class="nc" id="L946">          iReader = new BufferedReader(new InputStreamReader(new FileInputStream(filename), encoding));</span>
<span class="nc" id="L947">        } catch (IOException e) {</span>
<span class="nc" id="L948">          throw new RuntimeException(e);</span>
<span class="nc" id="L949">        }</span>
      }

<span class="nc" id="L952">      return new Iterator&lt;Tree&gt;() {</span>

        String line; // = null;

        @Override
        public boolean hasNext() {
<span class="nc bnc" id="L958" title="All 2 branches missed.">          if (line != null) {</span>
<span class="nc" id="L959">            return true;</span>
          } else {
            try {
<span class="nc" id="L962">              line = iReader.readLine();</span>
<span class="nc" id="L963">            } catch (IOException e) {</span>
<span class="nc" id="L964">              throw new RuntimeException(e);</span>
<span class="nc" id="L965">            }</span>
<span class="nc bnc" id="L966" title="All 2 branches missed.">            if (line == null) {</span>
              try {
<span class="nc bnc" id="L968" title="All 2 branches missed.">                if (reader == null) iReader.close();</span>
<span class="nc" id="L969">              } catch (Exception e) {</span>
<span class="nc" id="L970">                throw new RuntimeException(e);</span>
<span class="nc" id="L971">              }</span>
<span class="nc" id="L972">              return false;</span>
            }
<span class="nc" id="L974">            return true;</span>
          }
        }

        @Override
        public Tree next() {
<span class="nc bnc" id="L980" title="All 2 branches missed.">          if (line == null) {</span>
<span class="nc" id="L981">            throw new NoSuchElementException();</span>
          }
<span class="nc" id="L983">          Reader lineReader = new StringReader(line);</span>
<span class="nc" id="L984">          line = null;</span>
          List&lt;Word&gt; words;
<span class="nc bnc" id="L986" title="All 2 branches missed.">          if (tokenized) {</span>
<span class="nc" id="L987">            words = WhitespaceTokenizer.newWordWhitespaceTokenizer(lineReader).tokenize();</span>
          } else {
<span class="nc" id="L989">            words = PTBTokenizer.newPTBTokenizer(lineReader).tokenize();</span>
          }
<span class="nc bnc" id="L991" title="All 2 branches missed.">          if (!words.isEmpty()) {</span>
            // the parser throws an exception if told to parse an empty sentence.
<span class="nc" id="L993">            Tree parseTree = lp.apply(words);</span>
<span class="nc" id="L994">            return parseTree;</span>
          } else {
<span class="nc" id="L996">            return new SimpleTree();</span>
          }
        }

        @Override
        public void remove() {
<span class="nc" id="L1002">          throw new UnsupportedOperationException();</span>
        }

      };
    }

  } // end static class LazyLoadTreesByParsing


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>