<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>EnglishGrammaticalStructure.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.trees</a> &gt; <span class="el_source">EnglishGrammaticalStructure.java</span></div><h1>EnglishGrammaticalStructure.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.trees;

import java.io.*;
import java.util.*;
import java.util.function.Predicate;

import edu.stanford.nlp.ling.IndexedWord;
import edu.stanford.nlp.process.Morphology;
import edu.stanford.nlp.semgraph.SemanticGraph;
import edu.stanford.nlp.semgraph.SemanticGraphEdge;
import edu.stanford.nlp.semgraph.semgrex.SemgrexMatcher;
import edu.stanford.nlp.semgraph.semgrex.SemgrexPattern;
import edu.stanford.nlp.util.*;
import edu.stanford.nlp.util.logging.Redwood;

import static edu.stanford.nlp.trees.EnglishGrammaticalRelations.*;
import static edu.stanford.nlp.trees.GrammaticalRelation.*;

/**
 * A GrammaticalStructure for English. This is the class that produces Stanford Dependencies.
 *
 * For feeding Stanford parser trees into this class, the Stanford parser should be run with the
 * &quot;-retainNPTmpSubcategories&quot; option for best results!
 *
 * @author Bill MacCartney
 * @author Marie-Catherine de Marneffe
 * @author Christopher Manning
 * @author Daniel Cer (CoNLLX format and alternative user selected dependency
 *         printer/reader interface)
 * @author John Bauer
 */
public class EnglishGrammaticalStructure extends GrammaticalStructure  {

  /** A logger for this class */
<span class="fc" id="L35">  private static Redwood.RedwoodChannels log = Redwood.channels(EnglishGrammaticalStructure.class);</span>

  private static final long serialVersionUID = -1866362375001969402L;

<span class="pc bpc" id="L39" title="1 of 2 branches missed.">  private static final boolean DEBUG = System.getProperty(&quot;EnglishGrammaticalStructure&quot;, null) != null;</span>

  /**
   * Construct a new {@code EnglishGrammaticalStructure} from an existing parse
   * tree. The new {@code GrammaticalStructure} has the same tree structure
   * and label values as the given tree (but no shared storage). As part of
   * construction, the parse tree is analyzed using definitions from
   * {@link GrammaticalRelation {@code GrammaticalRelation}} to populate
   * the new {@code GrammaticalStructure} with as many labeled grammatical
   * relations as it can.
   *
   * @param t Parse tree to make grammatical structure from
   */
  public EnglishGrammaticalStructure(Tree t) {
<span class="fc" id="L53">    this(t, new PennTreebankLanguagePack().punctuationWordRejectFilter());</span>
<span class="fc" id="L54">  }</span>

  /**
   * This gets used by GrammaticalStructureFactory (by reflection). DON'T DELETE.
   *
   * @param t Parse tree to make grammatical structure from
   * @param puncFilter Filter to remove punctuation dependencies
   */
  public EnglishGrammaticalStructure(Tree t, Predicate&lt;String&gt; puncFilter) {
<span class="fc" id="L63">    this(t, puncFilter, new SemanticHeadFinder(true));</span>
<span class="fc" id="L64">  }</span>

  /**
   * Construct a new {@code GrammaticalStructure} from an existing parse
   * tree. The new {@code GrammaticalStructure} has the same tree structure
   * and label values as the given tree (but no shared storage). As part of
   * construction, the parse tree is analyzed using definitions from
   * {@link GrammaticalRelation {@code GrammaticalRelation}} to populate
   * the new {@code GrammaticalStructure} with as many labeled grammatical
   * relations as it can.
   *
   * Once upon a time this method had an extra parameter as to whether to operate
   * in a threadsafe manner. We decided that that was a really bad idea, and this
   * method now always acts in a threadsafe manner.
   * This method gets used by GrammaticalStructureFactory (by reflection). DON'T DELETE.
   *
   * @param t Parse tree to make grammatical structure from
   * @param puncFilter Filter for punctuation words
   * @param hf HeadFinder to use when building it
   */
  public EnglishGrammaticalStructure(Tree t, Predicate&lt;String&gt; puncFilter, HeadFinder hf) {
    // the tree is normalized (for index and functional tag stripping) inside CoordinationTransformer
<span class="fc" id="L86">    super(t, EnglishGrammaticalRelations.values(), EnglishGrammaticalRelations.valuesLock(), new CoordinationTransformer(hf), hf, puncFilter, Filters.acceptFilter());</span>
<span class="fc" id="L87">  }</span>

  /** Used for postprocessing CoNLL X dependencies */
  public EnglishGrammaticalStructure(List&lt;TypedDependency&gt; projectiveDependencies, TreeGraphNode root) {
<span class="nc" id="L91">    super(projectiveDependencies, root);</span>
<span class="nc" id="L92">  }</span>


  /**
   * Returns a Filter which checks dependencies for usefulness as
   * extra tree-based dependencies.  By default, everything is
   * accepted.  One example of how this can be useful is in the
   * English dependencies, where the REL dependency is used as an
   * intermediate and we do not want this to be added when we make a
   * second pass over the trees for missing dependencies.
   */
  @Override
  protected Predicate&lt;TypedDependency&gt; extraTreeDepFilter() {
<span class="fc" id="L105">    return extraTreeDepFilter;</span>
  }

<span class="fc" id="L108">  private static class ExtraTreeDepFilter implements Predicate&lt;TypedDependency&gt;, Serializable {</span>
    @Override
    public boolean test(TypedDependency d) {
<span class="pc bpc" id="L111" title="1 of 4 branches missed.">      return d != null &amp;&amp; d.reln() != RELATIVE;</span>
    }

    private static final long serialVersionUID = 1L;
  }

<span class="fc" id="L117">  private static final Predicate&lt;TypedDependency&gt; extraTreeDepFilter = new ExtraTreeDepFilter();</span>


  @Override
  protected void correctDependencies(List&lt;TypedDependency&gt; list) {
<span class="pc bpc" id="L122" title="1 of 2 branches missed.">    if (DEBUG) {</span>
<span class="nc" id="L123">      printListSorted(&quot;At correctDependencies:&quot;, list);</span>
    }
<span class="fc" id="L125">    correctSubjPass(list);</span>
<span class="pc bpc" id="L126" title="1 of 2 branches missed.">    if (DEBUG) {</span>
<span class="nc" id="L127">      printListSorted(&quot;After correctSubjPass:&quot;, list);</span>
    }
<span class="fc" id="L129">    removeExactDuplicates(list);</span>
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">    if (DEBUG) {</span>
<span class="nc" id="L131">      printListSorted(&quot;After removeExactDuplicates:&quot;, list);</span>
    }
<span class="fc" id="L133">  }</span>

  private static void printListSorted(String title, Collection&lt;TypedDependency&gt; list) {
<span class="nc" id="L136">    List&lt;TypedDependency&gt; lis = new ArrayList&lt;&gt;(list);</span>
<span class="nc" id="L137">    Collections.sort(lis);</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">    if (title != null) {</span>
<span class="nc" id="L139">      log.info(title);</span>
    }
<span class="nc" id="L141">    log.info(lis);</span>
<span class="nc" id="L142">  }</span>

  @Override
  protected void postProcessDependencies(List&lt;TypedDependency&gt; list) {
<span class="pc bpc" id="L146" title="1 of 2 branches missed.">    if (DEBUG) {</span>
<span class="nc" id="L147">      printListSorted(&quot;At postProcessDependencies:&quot;, list);</span>
    }

<span class="fc" id="L150">    SemanticGraph sg = new SemanticGraph(list);</span>
<span class="fc" id="L151">    correctWHAttachment(sg);</span>
<span class="fc" id="L152">    list.clear();</span>
<span class="fc" id="L153">    list.addAll(sg.typedDependencies());</span>
<span class="pc bpc" id="L154" title="1 of 2 branches missed.">    if (DEBUG) {</span>
<span class="nc" id="L155">      printListSorted(&quot;After correcting WH movement&quot;, list);</span>
    }

<span class="fc" id="L158">    convertRel(list);</span>
<span class="pc bpc" id="L159" title="1 of 2 branches missed.">    if (DEBUG) {</span>
<span class="nc" id="L160">      printListSorted(&quot;After converting rel:&quot;, list);</span>
    }
<span class="fc" id="L162">  }</span>

  @Override
  protected void getExtras(List&lt;TypedDependency&gt; list) {
<span class="fc" id="L166">    addRef(list);</span>
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">    if (DEBUG) {</span>
<span class="nc" id="L168">      printListSorted(&quot;After adding ref:&quot;, list);</span>
    }

<span class="fc" id="L171">    addExtraNSubj(list);</span>
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">    if (DEBUG) {</span>
<span class="nc" id="L173">      printListSorted(&quot;After adding extra nsubj:&quot;, list);</span>
    }

<span class="fc" id="L176">    addStrandedPobj(list);</span>
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">    if (DEBUG) {</span>
<span class="nc" id="L178">      printListSorted(&quot;After adding stranded pobj:&quot;, list);</span>
    }
<span class="fc" id="L180">  }</span>

  // Using this makes addStrandedPobj a lot cleaner looking, but it
  // makes the converter roughly 2% slower.  Might not be worth it.
  // Similar changes could be made to many of the other complicated
  // collapsing methods.
  // static final SemgrexPattern strandedPobjSemgrex = SemgrexPattern.compile(&quot;{}=head &gt;rcmod ({} [ == {}=prepgov | &gt;xcomp {}=prepgov | &gt;conj {}=prepgov ]) : {}=prepgov &gt;prep ({}=prepdep !&gt;pcomp {} !&gt; pobj {})&quot;);
  // // Deal with preposition stranding in relative clauses.
  // // For example, &quot;the only thing I'm rooting for&quot;
  // // This method will add pobj(for, thing) by connecting using the rcmod and prep
  // private static void addStrandedPobj(List&lt;TypedDependency&gt; list) {
  //   SemanticGraph graph = new SemanticGraph(list);
  //   SemgrexMatcher matcher = strandedPobjSemgrex.matcher(graph);
  //   while (matcher.find()) {
  //     IndexedWord gov = matcher.getNode(&quot;prepdep&quot;);
  //     IndexedWord dep = matcher.getNode(&quot;head&quot;);

  //     TypedDependency newDep = new TypedDependency(PREPOSITIONAL_OBJECT, gov, dep);
  //     newDep.setExtra();
  //     list.add(newDep);
  //   }
  // }


  // Deal with preposition stranding in relative clauses.
  // For example, &quot;the only thing I'm rooting for&quot;
  // This method will add pobj(for, thing) by connecting using the rcmod and prep
  private static void addStrandedPobj(List&lt;TypedDependency&gt; list) {
<span class="fc" id="L208">    List&lt;IndexedWord&gt; depNodes = null;</span>
<span class="fc" id="L209">    List&lt;TypedDependency&gt; newDeps = null;</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">    for (TypedDependency rcmod : list) {</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">      if (rcmod.reln() != RELATIVE_CLAUSE_MODIFIER) {</span>
<span class="fc" id="L212">        continue;</span>
      }

<span class="fc" id="L215">      IndexedWord head = rcmod.gov();</span>
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">      if (depNodes == null) {</span>
<span class="fc" id="L217">        depNodes = Generics.newArrayList();</span>
      } else {
<span class="nc" id="L219">        depNodes.clear();</span>
      }
<span class="fc" id="L221">      depNodes.add(rcmod.dep());</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">      for (TypedDependency connected : list) {</span>
<span class="pc bpc" id="L223" title="1 of 6 branches missed.">        if (connected.gov().equals(rcmod.dep()) &amp;&amp; (connected.reln() == XCLAUSAL_COMPLEMENT || connected.reln() == CONJUNCT)) {</span>
<span class="fc" id="L224">          depNodes.add(connected.dep());</span>
        }
<span class="fc" id="L226">      }</span>

<span class="fc bfc" id="L228" title="All 2 branches covered.">      for (IndexedWord dep : depNodes) {</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">        for (TypedDependency prep : list) {</span>
<span class="fc bfc" id="L230" title="All 4 branches covered.">          if (!prep.gov().equals(dep) || prep.reln() != PREPOSITIONAL_MODIFIER) {</span>
<span class="fc" id="L231">            continue;</span>
          }

<span class="fc" id="L234">          boolean found = false;</span>
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">          for (TypedDependency other : list) {</span>
<span class="pc bpc" id="L236" title="2 of 6 branches missed.">            if (other.gov().equals(prep.dep()) &amp;&amp; (other.reln() == PREPOSITIONAL_COMPLEMENT || other.reln() == PREPOSITIONAL_OBJECT)) {</span>
<span class="fc" id="L237">              found = true;</span>
<span class="fc" id="L238">              break;</span>
            }
<span class="fc" id="L240">          }</span>
<span class="pc bpc" id="L241" title="1 of 2 branches missed.">          if (!found) {</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">            if (newDeps == null) {</span>
<span class="nc" id="L243">              newDeps = Generics.newArrayList();</span>
            }
<span class="nc" id="L245">            TypedDependency newDep = new TypedDependency(PREPOSITIONAL_OBJECT, prep.dep(), head);</span>
<span class="nc" id="L246">            newDeps.add(newDep);</span>
          }
<span class="fc" id="L248">        }</span>
<span class="fc" id="L249">      }</span>

<span class="fc" id="L251">    }</span>
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">    if (newDeps != null) {</span>
<span class="nc" id="L253">      list.addAll(newDeps);</span>
    }
<span class="fc" id="L255">  }</span>


  /* Used by correctWHAttachment */
<span class="fc" id="L259">  private static final SemgrexPattern XCOMP_PATTERN = SemgrexPattern.compile(&quot;{}=root &gt;xcomp {}=embedded &gt;/^(dep|dobj)$/ {}=wh ?&gt;/([di]obj)/ {}=obj&quot;);</span>

  /**
   * Tries to correct complicated cases of WH-movement in
   * sentences such as &quot;What does Mary seem to have?&quot; in
   * which &quot;What&quot; should attach to &quot;have&quot; instead of the
   * control verb.
   *
   * @param sg The Semantic graph to operate on.
   */
  private static void correctWHAttachment(SemanticGraph sg) {
    /* Semgrexes require a graph with a root. */
<span class="pc bpc" id="L271" title="1 of 2 branches missed.">    if (sg.getRoots().isEmpty())</span>
<span class="nc" id="L272">      return;</span>

<span class="fc" id="L274">    SemanticGraph sgCopy = sg.makeSoftCopy();</span>
<span class="fc" id="L275">    SemgrexMatcher matcher = XCOMP_PATTERN.matcher(sgCopy);</span>
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">    while (matcher.findNextMatchingNode()) {</span>
<span class="nc" id="L277">      IndexedWord root = matcher.getNode(&quot;root&quot;);</span>
<span class="nc" id="L278">      IndexedWord embeddedVerb = matcher.getNode(&quot;embedded&quot;);</span>
<span class="nc" id="L279">      IndexedWord wh = matcher.getNode(&quot;wh&quot;);</span>
<span class="nc" id="L280">      IndexedWord dobj = matcher.getNode(&quot;obj&quot;);</span>

      /* Check if the object is a WH-word. */
<span class="nc bnc" id="L283" title="All 2 branches missed.">      if (wh.tag().startsWith(&quot;W&quot;)) {</span>
<span class="nc" id="L284">        boolean reattach = false;</span>
        /* If the control verb already has an object, then
           we have to reattach th WH-word to the verb in the embedded clause. */
<span class="nc bnc" id="L287" title="All 2 branches missed.">        if (dobj != null) {</span>
<span class="nc" id="L288">          reattach = true;</span>
        } else {
          /* If the control verb can't have an object, we also have to reattach. */
<span class="nc" id="L291">          String lemma = Morphology.lemmaStatic(root.value(), root.tag());</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">          if (lemma.matches(EnglishPatterns.NP_V_S_INF_VERBS_REGEX)) {</span>
<span class="nc" id="L293">            reattach = true;</span>
          }
        }

<span class="nc bnc" id="L297" title="All 2 branches missed.">        if (reattach) {</span>
<span class="nc" id="L298">          SemanticGraphEdge edge = sg.getEdge(root, wh);</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">          if (edge != null) {</span>
<span class="nc" id="L300">            sg.removeEdge(edge);</span>
<span class="nc" id="L301">            sg.addEdge(embeddedVerb, wh, DIRECT_OBJECT, Double.NEGATIVE_INFINITY, false);</span>
          }
        }
      }
<span class="nc" id="L305">    }</span>
<span class="fc" id="L306">  }</span>

  /**
   * What we do in this method is look for temporary dependencies of
   * the type &quot;rel&quot;.  These occur in sentences such as &quot;I saw the man
   * who you love&quot;.  In that case, we should produce dobj(love, who).
   * On the other hand, in the sentence &quot;... which Mr. Bush was
   * fighting for&quot;, we should have pobj(for, which).
   */
  private static void convertRel(List&lt;TypedDependency&gt; list) {
<span class="fc" id="L316">    List&lt;TypedDependency&gt; newDeps = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L317" title="All 2 branches covered.">    for (TypedDependency rel : list) {</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">      if (rel.reln() != RELATIVE) {</span>
<span class="fc" id="L319">        continue;</span>
      }

<span class="fc" id="L322">      boolean foundPrep = false;</span>
<span class="fc bfc" id="L323" title="All 2 branches covered.">      for (TypedDependency prep : list) {</span>

        // todo: It would also be good to add a rule here to prefer ccomp nsubj over dobj if there is a ccomp with no subj
        // then we could get right: Which eco-friendly options do you think there will be on the new Lexus?

<span class="fc bfc" id="L328" title="All 2 branches covered.">        if (prep.reln() != PREPOSITIONAL_MODIFIER) {</span>
<span class="fc" id="L329">          continue;</span>
        }
<span class="fc bfc" id="L331" title="All 2 branches covered.">        if (!prep.gov().equals(rel.gov())) {</span>

          //Try to find a clausal complement with a preposition without an
          //object. For sentences such as &quot;What am I good at?&quot;
<span class="fc" id="L335">          boolean hasCompParent = false;</span>
<span class="pc bpc" id="L336" title="1 of 2 branches missed.">          for (TypedDependency prep2 : list) {</span>
<span class="pc bpc" id="L337" title="1 of 2 branches missed.">            if (prep2.reln() == XCLAUSAL_COMPLEMENT</span>
<span class="fc bfc" id="L338" title="All 2 branches covered.">                || prep2.reln() == ADJECTIVAL_COMPLEMENT</span>
<span class="pc bpc" id="L339" title="1 of 2 branches missed.">                || prep2.reln() == CLAUSAL_COMPLEMENT</span>
<span class="fc bfc" id="L340" title="All 2 branches covered.">                || prep2.reln() == ROOT) {</span>
<span class="pc bpc" id="L341" title="1 of 4 branches missed.">              if (prep.gov().equals(prep2.dep()) &amp;&amp; prep2.gov().equals(rel.gov())) {</span>
<span class="fc" id="L342">                hasCompParent = true;</span>
<span class="fc" id="L343">                break;</span>
              }
            }
<span class="fc" id="L346">          }</span>

<span class="pc bpc" id="L348" title="1 of 2 branches missed.">          if ( ! hasCompParent)</span>
<span class="nc" id="L349">            continue;</span>
        }

        // at this point, we have two dependencies as in the Mr. Bush
        // example.  it should be rel(fighting, which) and
        // prep(fighting, for).  We now look to see if there is a
        // corresponding pobj associated with the dependent of the
        // prep relation.  If not, we will connect the dep of the prep
        // relation and the head of the rel relation.  Otherwise, the
        // original rel relation will become a dobj.
<span class="fc" id="L359">        boolean foundPobj = false;</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">        for (TypedDependency pobj : list) {</span>
<span class="pc bpc" id="L361" title="1 of 4 branches missed.">          if (pobj.reln() != PREPOSITIONAL_OBJECT &amp;&amp; pobj.reln() != PREPOSITIONAL_COMPLEMENT) {</span>
<span class="fc" id="L362">            continue;</span>
          }
<span class="fc bfc" id="L364" title="All 2 branches covered.">          if (!pobj.gov().equals(prep.dep())) {</span>
<span class="fc" id="L365">            continue;</span>
          }
          // we did find a pobj/pcomp, so it is not necessary to
          // change this rel.
<span class="fc" id="L369">          foundPobj = true;</span>
<span class="fc" id="L370">          break;</span>
        }

<span class="fc bfc" id="L373" title="All 2 branches covered.">        if (!foundPobj) {</span>
<span class="fc" id="L374">          foundPrep = true;</span>
<span class="fc" id="L375">          TypedDependency newDep = new TypedDependency(PREPOSITIONAL_OBJECT, prep.dep(), rel.dep());</span>
<span class="fc" id="L376">          newDeps.add(newDep);</span>
<span class="fc" id="L377">          rel.setReln(KILL);</span>
          // break; // only put it in one place (or do we want to allow across-the-board effects?
        }
<span class="fc" id="L380">      }</span>
<span class="pc bpc" id="L381" title="1 of 2 branches missed.">      if (!foundPrep) {</span>
<span class="nc" id="L382">        rel.setReln(DIRECT_OBJECT);</span>
      }
<span class="fc" id="L384">    }</span>

<span class="fc" id="L386">    filterKill(list);</span>
<span class="fc bfc" id="L387" title="All 2 branches covered.">    for (TypedDependency dep : newDeps) {</span>
<span class="pc bpc" id="L388" title="1 of 2 branches missed.">      if (!list.contains(dep)) {</span>
<span class="fc" id="L389">        list.add(dep);</span>
      }
<span class="fc" id="L391">    }</span>
<span class="fc" id="L392">  }</span>

  /**
   * Alters a list in place by removing all the KILL relations
   */
  private static void filterKill(Collection&lt;TypedDependency&gt; deps) {
<span class="fc" id="L398">    List&lt;TypedDependency&gt; filtered = Generics.newArrayList();</span>
<span class="fc bfc" id="L399" title="All 2 branches covered.">    for (TypedDependency dep : deps) {</span>
<span class="fc bfc" id="L400" title="All 2 branches covered.">      if (dep.reln() != KILL) {</span>
<span class="fc" id="L401">        filtered.add(dep);</span>
      }
<span class="fc" id="L403">    }</span>
<span class="fc" id="L404">    deps.clear();</span>
<span class="fc" id="L405">    deps.addAll(filtered);</span>
<span class="fc" id="L406">  }</span>


  /**
   * Destructively modifies this {@code Collection&lt;TypedDependency&gt;}
   * by collapsing several types of transitive pairs of dependencies.
   * If called with a tree of dependencies and both CCprocess and
   * includeExtras set to false, then the tree structure is preserved.
   * &lt;dl&gt;
   * &lt;dt&gt;prepositional object dependencies: pobj&lt;/dt&gt;
   * &lt;dd&gt;
   * {@code prep(cat, in)} and {@code pobj(in, hat)} are collapsed to
   * {@code prep_in(cat, hat)}&lt;/dd&gt;
   * &lt;dt&gt;prepositional complement dependencies: pcomp&lt;/dt&gt;
   * &lt;dd&gt;
   * {@code prep(heard, of)} and {@code pcomp(of, attacking)} are
   * collapsed to {@code prepc_of(heard, attacking)}&lt;/dd&gt;
   * &lt;dt&gt;conjunct dependencies&lt;/dt&gt;
   * &lt;dd&gt;
   * {@code cc(investors, and)} and
   * {@code conj(investors, regulators)} are collapsed to
   * {@code conj_and(investors,regulators)}&lt;/dd&gt;
   * &lt;dt&gt;possessive dependencies: possessive&lt;/dt&gt;
   * &lt;dd&gt;
   * {@code possessive(Montezuma, 's)} will be erased. This is like a collapsing, but
   * due to the flatness of NPs, two dependencies are not actually composed.&lt;/dd&gt;
   * &lt;dt&gt;For relative clauses, it will collapse referent&lt;/dt&gt;
   * &lt;dd&gt;
   * {@code ref(man, that)} and {@code dobj(love, that)} are collapsed
   * to {@code dobj(love, man)}&lt;/dd&gt;
   * &lt;/dl&gt;
   */
  @Override
  protected void collapseDependencies(List&lt;TypedDependency&gt; list, boolean CCprocess, Extras includeExtras) {
<span class="pc bpc" id="L440" title="1 of 2 branches missed.">    if (DEBUG) {</span>
<span class="nc" id="L441">      printListSorted(&quot;collapseDependencies: CCproc: &quot; + CCprocess + &quot; includeExtras: &quot; + includeExtras, list);</span>
    }
<span class="fc" id="L443">    correctDependencies(list);</span>
<span class="pc bpc" id="L444" title="1 of 2 branches missed.">    if (DEBUG) {</span>
<span class="nc" id="L445">      printListSorted(&quot;After correctDependencies:&quot;, list);</span>
    }

<span class="fc" id="L448">    eraseMultiConj(list);</span>
<span class="pc bpc" id="L449" title="1 of 2 branches missed.">    if (DEBUG) {</span>
<span class="nc" id="L450">      printListSorted(&quot;After collapse multi conj:&quot;, list);</span>
    }

<span class="fc" id="L453">    collapse2WP(list);</span>
<span class="pc bpc" id="L454" title="1 of 2 branches missed.">    if (DEBUG) {</span>
<span class="nc" id="L455">      printListSorted(&quot;After collapse2WP:&quot;, list);</span>
    }

<span class="fc" id="L458">    collapseFlatMWP(list);</span>
<span class="pc bpc" id="L459" title="1 of 2 branches missed.">    if (DEBUG) {</span>
<span class="nc" id="L460">      printListSorted(&quot;After collapseFlatMWP:&quot;, list);</span>
    }

<span class="fc" id="L463">    collapse2WPbis(list);</span>
<span class="pc bpc" id="L464" title="1 of 2 branches missed.">    if (DEBUG) {</span>
<span class="nc" id="L465">      printListSorted(&quot;After collapse2WPbis:&quot;, list);</span>
    }

<span class="fc" id="L468">    collapse3WP(list);</span>
<span class="pc bpc" id="L469" title="1 of 2 branches missed.">    if (DEBUG) {</span>
<span class="nc" id="L470">      printListSorted(&quot;After collapse3WP:&quot;, list);</span>
    }

<span class="fc" id="L473">    collapsePrepAndPoss(list);</span>
<span class="pc bpc" id="L474" title="1 of 2 branches missed.">    if (DEBUG) {</span>
<span class="nc" id="L475">      printListSorted(&quot;After PrepAndPoss:&quot;, list);</span>
    }

<span class="fc" id="L478">    collapseConj(list);</span>
<span class="pc bpc" id="L479" title="1 of 2 branches missed.">    if (DEBUG) {</span>
<span class="nc" id="L480">      printListSorted(&quot;After conj:&quot;, list);</span>
    }

<span class="pc bpc" id="L483" title="1 of 2 branches missed.">    if (includeExtras.doRef) {</span>
<span class="fc" id="L484">      addRef(list);</span>
<span class="pc bpc" id="L485" title="1 of 2 branches missed.">      if (DEBUG) {</span>
<span class="nc" id="L486">        printListSorted(&quot;After adding ref:&quot;, list);</span>
      }

<span class="pc bpc" id="L489" title="1 of 2 branches missed.">      if (includeExtras.collapseRef) {</span>
<span class="fc" id="L490">        collapseReferent(list);</span>
<span class="pc bpc" id="L491" title="1 of 2 branches missed.">        if (DEBUG) {</span>
<span class="nc" id="L492">          printListSorted(&quot;After collapse referent:&quot;, list);</span>
        }
      }
    }

<span class="fc bfc" id="L497" title="All 2 branches covered.">    if (CCprocess) {</span>
<span class="fc" id="L498">      treatCC(list);</span>
<span class="pc bpc" id="L499" title="1 of 2 branches missed.">      if (DEBUG) {</span>
<span class="nc" id="L500">        printListSorted(&quot;After treatCC:&quot;, list);</span>
      }
    }

<span class="pc bpc" id="L504" title="1 of 2 branches missed.">    if (includeExtras.doSubj) {</span>
<span class="fc" id="L505">      addExtraNSubj(list);</span>
<span class="pc bpc" id="L506" title="1 of 2 branches missed.">      if (DEBUG) {</span>
<span class="nc" id="L507">        printListSorted(&quot;After adding extra nsubj:&quot;, list);</span>
      }

<span class="fc" id="L510">      correctSubjPass(list);</span>
<span class="pc bpc" id="L511" title="1 of 2 branches missed.">      if (DEBUG) {</span>
<span class="nc" id="L512">        printListSorted(&quot;After correctSubjPass:&quot;, list);</span>
      }
    }

<span class="fc" id="L516">    removeDep(list);</span>
<span class="pc bpc" id="L517" title="1 of 2 branches missed.">    if (DEBUG) {</span>
<span class="nc" id="L518">      printListSorted(&quot;After remove dep:&quot;, list);</span>
    }

<span class="fc" id="L521">    Collections.sort(list);</span>
<span class="pc bpc" id="L522" title="1 of 2 branches missed.">    if (DEBUG) {</span>
<span class="nc" id="L523">      printListSorted(&quot;After all collapse:&quot;, list);</span>
    }
<span class="fc" id="L525">  }</span>

  @Override
  protected void collapseDependenciesTree(List&lt;TypedDependency&gt; list) {
<span class="nc" id="L529">    collapseDependencies(list, false, Extras.NONE);</span>
<span class="nc" id="L530">  }</span>

  /**
   * Does some hard coding to deal with relation in CONJP. For now we deal with:
   * but not, if not, instead of, rather than, but rather GO TO negcc &lt;br&gt;
   * as well as, not to mention, but also, &amp;amp; GO TO and.
   *
   * @param conj The head dependency of the conjunction marker
   * @return A GrammaticalRelation made from a normalized form of that
   *         conjunction.
   */
  private static GrammaticalRelation conjValue(String conj) {
<span class="fc" id="L542">    String newConj = conj.toLowerCase();</span>
<span class="pc bpc" id="L543" title="1 of 6 branches missed.">    if (newConj.equals(&quot;not&quot;) || newConj.equals(&quot;instead&quot;) || newConj.equals(&quot;rather&quot;)) {</span>
<span class="fc" id="L544">      newConj = &quot;negcc&quot;;</span>
<span class="pc bpc" id="L545" title="2 of 10 branches missed.">    } else if (newConj.equals(&quot;mention&quot;) || newConj.equals(&quot;to&quot;) || newConj.equals(&quot;also&quot;) || newConj.contains(&quot;well&quot;) || newConj.equals(&quot;&amp;&quot;)) {</span>
<span class="fc" id="L546">      newConj = &quot;and&quot;;</span>
    }
<span class="fc" id="L548">    return EnglishGrammaticalRelations.getConj(newConj);</span>
  }


  private static void treatCC(Collection&lt;TypedDependency&gt; list) {
    // Construct a map from tree nodes to the set of typed
    // dependencies in which the node appears as dependent.
<span class="fc" id="L555">    Map&lt;IndexedWord, Set&lt;TypedDependency&gt;&gt; map = Generics.newHashMap();</span>
    // Construct a map of tree nodes being governor of a subject grammatical
    // relation to that relation
<span class="fc" id="L558">    Map&lt;IndexedWord, TypedDependency&gt; subjectMap = Generics.newHashMap();</span>
    // Construct a set of TreeGraphNodes with a passive auxiliary on them
<span class="fc" id="L560">    Set&lt;IndexedWord&gt; withPassiveAuxiliary = Generics.newHashSet();</span>
    // Construct a map of tree nodes being governor of an object grammatical
    // relation to that relation
    // Map&lt;TreeGraphNode, TypedDependency&gt; objectMap = new
    // HashMap&lt;TreeGraphNode, TypedDependency&gt;();

<span class="fc" id="L566">    List&lt;IndexedWord&gt; rcmodHeads = Generics.newArrayList();</span>
<span class="fc" id="L567">    List&lt;IndexedWord&gt; prepcDep = Generics.newArrayList();</span>

<span class="fc bfc" id="L569" title="All 2 branches covered.">    for (TypedDependency typedDep : list) {</span>
<span class="fc bfc" id="L570" title="All 2 branches covered.">      if (!map.containsKey(typedDep.dep())) {</span>
        // NB: Here and in other places below, we use a TreeSet (which extends
        // SortedSet) to guarantee that results are deterministic)
<span class="fc" id="L573">        map.put(typedDep.dep(), new TreeSet&lt;&gt;());</span>
      }
<span class="fc" id="L575">      map.get(typedDep.dep()).add(typedDep);</span>

<span class="fc bfc" id="L577" title="All 2 branches covered.">      if (typedDep.reln().equals(AUX_PASSIVE_MODIFIER)) {</span>
<span class="fc" id="L578">        withPassiveAuxiliary.add(typedDep.gov());</span>
      }

      // look for subjects
<span class="pc bpc" id="L582" title="1 of 6 branches missed.">      if (typedDep.reln().getParent() == NOMINAL_SUBJECT || typedDep.reln().getParent() == SUBJECT || typedDep.reln().getParent() == CLAUSAL_SUBJECT) {</span>
<span class="pc bpc" id="L583" title="1 of 2 branches missed.">        if (!subjectMap.containsKey(typedDep.gov())) {</span>
<span class="fc" id="L584">          subjectMap.put(typedDep.gov(), typedDep);</span>
        }
      }

      // look for objects
      // this map was only required by the code commented out below, so comment
      // it out too
      // if (typedDep.reln() == DIRECT_OBJECT) {
      // if (!objectMap.containsKey(typedDep.gov())) {
      // objectMap.put(typedDep.gov(), typedDep);
      // }
      // }

      // look for rcmod relations
<span class="fc bfc" id="L598" title="All 2 branches covered.">      if (typedDep.reln() == RELATIVE_CLAUSE_MODIFIER) {</span>
<span class="fc" id="L599">        rcmodHeads.add(typedDep.gov());</span>
      }
      // look for prepc relations: put the dependent of such a relation in the
      // list
      // to avoid wrong propagation of dobj
<span class="fc bfc" id="L604" title="All 2 branches covered.">      if (typedDep.reln().toString().startsWith(&quot;prepc&quot;)) {</span>
<span class="fc" id="L605">        prepcDep.add(typedDep.dep());</span>
      }
<span class="fc" id="L607">    }</span>

    // log.info(map);
    // if (DEBUG) log.info(&quot;Subject map: &quot; + subjectMap);
    // if (DEBUG) log.info(&quot;Object map: &quot; + objectMap);
    // log.info(rcmodHeads);

    // create a new list of typed dependencies
<span class="fc" id="L615">    Collection&lt;TypedDependency&gt; newTypedDeps = new ArrayList&lt;&gt;(list);</span>

    // find typed deps of form conj(gov,dep)
<span class="fc bfc" id="L618" title="All 2 branches covered.">    for (TypedDependency td : list) {</span>
<span class="fc bfc" id="L619" title="All 2 branches covered.">      if (EnglishGrammaticalRelations.getConjs().contains(td.reln())) {</span>
<span class="fc" id="L620">        IndexedWord gov = td.gov();</span>
<span class="fc" id="L621">        IndexedWord dep = td.dep();</span>

        // look at the dep in the conjunct
<span class="fc" id="L624">        Set&lt;TypedDependency&gt; gov_relations = map.get(gov);</span>
        // log.info(&quot;gov &quot; + gov);
<span class="pc bpc" id="L626" title="1 of 2 branches missed.">        if (gov_relations != null) {</span>
<span class="fc bfc" id="L627" title="All 2 branches covered.">          for (TypedDependency td1 : gov_relations) {</span>
            // log.info(&quot;gov rel &quot; + td1);
<span class="fc" id="L629">            IndexedWord newGov = td1.gov();</span>
            // in the case of errors in the basic dependencies, it
            // is possible to have overlapping newGov &amp; dep
<span class="pc bpc" id="L632" title="1 of 2 branches missed.">            if (newGov.equals(dep)) {</span>
<span class="nc" id="L633">              continue;</span>
            }
<span class="fc" id="L635">            GrammaticalRelation newRel = td1.reln();</span>
<span class="fc bfc" id="L636" title="All 2 branches covered.">            if (newRel != ROOT) {</span>
<span class="pc bpc" id="L637" title="3 of 4 branches missed.">              if (rcmodHeads.contains(gov) &amp;&amp; rcmodHeads.contains(dep)) {</span>
                // to prevent wrong propagation in the case of long dependencies in relative clauses
<span class="nc bnc" id="L639" title="All 4 branches missed.">                if (newRel != DIRECT_OBJECT &amp;&amp; newRel != NOMINAL_SUBJECT) {</span>
<span class="nc bnc" id="L640" title="All 2 branches missed.">                  if (DEBUG) {</span>
<span class="nc" id="L641">                    log.info(&quot;Adding new &quot; + newRel + &quot; dependency from &quot; + newGov + &quot; to &quot; + dep + &quot; (subj/obj case)&quot;);</span>
                  }
<span class="nc" id="L643">                  newTypedDeps.add(new TypedDependency(newRel, newGov, dep));</span>
                }
              } else {
<span class="pc bpc" id="L646" title="1 of 2 branches missed.">                if (DEBUG) {</span>
<span class="nc" id="L647">                  log.info(&quot;Adding new &quot; + newRel + &quot; dependency from &quot; + newGov + &quot; to &quot; + dep);</span>
                }
<span class="fc" id="L649">                newTypedDeps.add(new TypedDependency(newRel, newGov, dep));</span>
              }
            }
<span class="fc" id="L652">          }</span>
        }

        // propagate subjects
        // look at the gov in the conjunct: if it is has a subject relation,
        // the dep is a verb and the dep doesn't have a subject relation
        // then we want to add a subject relation for the dep.
        // (By testing for the dep to be a verb, we are going to miss subject of
        // copula verbs! but
        // is it safe to relax this assumption?? i.e., just test for the subject
        // part)
        // CDM 2008: I also added in JJ, since participial verbs are often
        // tagged JJ
<span class="fc" id="L665">        String tag = dep.tag();</span>
<span class="pc bpc" id="L666" title="1 of 8 branches missed.">        if (subjectMap.containsKey(gov) &amp;&amp; (tag.startsWith(&quot;VB&quot;) || tag.startsWith(&quot;JJ&quot;)) &amp;&amp; ! subjectMap.containsKey(dep)) {</span>
<span class="fc" id="L667">          TypedDependency tdsubj = subjectMap.get(gov);</span>
          // check for wrong nsubjpass: if the new verb is VB or VBZ or VBP or JJ, then
          // add nsubj (if it is tagged correctly, should do this for VBD too, but we don't)
<span class="fc" id="L670">          GrammaticalRelation relation = tdsubj.reln();</span>
<span class="fc bfc" id="L671" title="All 2 branches covered.">          if (relation == NOMINAL_PASSIVE_SUBJECT) {</span>
<span class="pc bpc" id="L672" title="1 of 2 branches missed.">            if (isDefinitelyActive(tag)) {</span>
<span class="fc" id="L673">              relation = NOMINAL_SUBJECT;</span>
            }
<span class="pc bpc" id="L675" title="1 of 2 branches missed.">          } else if (relation == CLAUSAL_PASSIVE_SUBJECT) {</span>
<span class="nc bnc" id="L676" title="All 2 branches missed.">            if (isDefinitelyActive(tag)) {</span>
<span class="nc" id="L677">              relation = CLAUSAL_SUBJECT;</span>
            }
<span class="pc bpc" id="L679" title="1 of 2 branches missed.">          } else if (relation == NOMINAL_SUBJECT) {</span>
<span class="fc bfc" id="L680" title="All 2 branches covered.">            if (withPassiveAuxiliary.contains(dep)) {</span>
<span class="fc" id="L681">              relation = NOMINAL_PASSIVE_SUBJECT;</span>
            }
<span class="nc bnc" id="L683" title="All 2 branches missed.">          } else if (relation == CLAUSAL_SUBJECT) {</span>
<span class="nc bnc" id="L684" title="All 2 branches missed.">            if (withPassiveAuxiliary.contains(dep)) {</span>
<span class="nc" id="L685">              relation = CLAUSAL_PASSIVE_SUBJECT;</span>
            }
          }
<span class="pc bpc" id="L688" title="1 of 2 branches missed.">          if (DEBUG) {</span>
<span class="nc" id="L689">            log.info(&quot;Adding new &quot; + relation + &quot; dependency from &quot; + dep + &quot; to &quot; + tdsubj.dep() + &quot; (subj propagation case)&quot;);</span>
          }
<span class="fc" id="L691">          newTypedDeps.add(new TypedDependency(relation, dep, tdsubj.dep()));</span>
        }

        // propagate objects
        // cdm july 2010: This bit of code would copy a dobj from the first
        // clause to a later conjoined clause if it didn't
        // contain its own dobj or prepc. But this is too aggressive and wrong
        // if the later clause is intransitive
        // (including passivized cases) and so I think we have to not have this
        // done always, and see no good &quot;sometimes&quot; heuristic.
        // IF WE WERE TO REINSTATE, SHOULD ALSO NOT ADD OBJ IF THERE IS A ccomp
        // (SBAR).
        // if (objectMap.containsKey(gov) &amp;&amp;
        // dep.tag().startsWith(&quot;VB&quot;) &amp;&amp; ! objectMap.containsKey(dep)
        // &amp;&amp; ! prepcDep.contains(gov)) {
        // TypedDependency tdobj = objectMap.get(gov);
        // if (DEBUG) {
        // log.info(&quot;Adding new &quot; + tdobj.reln() + &quot; dependency from &quot;
        // + dep + &quot; to &quot; + tdobj.dep() + &quot; (obj propagation case)&quot;);
        // }
        // newTypedDeps.add(new TypedDependency(tdobj.reln(), dep,
        // tdobj.dep()));
        // }
      }
<span class="fc" id="L715">    }</span>
<span class="fc" id="L716">    list.clear();</span>
<span class="fc" id="L717">    list.addAll(newTypedDeps);</span>
<span class="fc" id="L718">  }</span>

  private static boolean isDefinitelyActive(String tag) {
    // we should include VBD, but don't as it is often a tagging mistake.
<span class="pc bpc" id="L722" title="7 of 8 branches missed.">    return tag.equals(&quot;VB&quot;) || tag.equals(&quot;VBZ&quot;) || tag.equals(&quot;VBP&quot;) || tag.startsWith(&quot;JJ&quot;);</span>
  }


  /**
   * This rewrites the &quot;conj&quot; relation to &quot;conj_word&quot; and deletes cases of the
   * &quot;cc&quot; relation providing this rewrite has occurred (but not if there is only
   * something like a clause-initial and). For instance, cc(elected-5, and-9)
   * conj(elected-5, re-elected-11) becomes conj_and(elected-5, re-elected-11)
   *
   * @param list List of dependencies.
   */
  private static void collapseConj(Collection&lt;TypedDependency&gt; list) {
<span class="fc" id="L735">    List&lt;IndexedWord&gt; govs = Generics.newArrayList();</span>
    // find typed deps of form cc(gov, dep)
<span class="fc bfc" id="L737" title="All 2 branches covered.">    for (TypedDependency td : list) {</span>
<span class="fc bfc" id="L738" title="All 2 branches covered.">      if (td.reln() == COORDINATION) { // i.e. &quot;cc&quot;</span>
<span class="fc" id="L739">        IndexedWord gov = td.gov();</span>
<span class="fc" id="L740">        GrammaticalRelation conj = conjValue(td.dep().value());</span>
<span class="pc bpc" id="L741" title="1 of 2 branches missed.">        if (DEBUG) {</span>
<span class="nc" id="L742">          log.info(&quot;Set conj to &quot; + conj + &quot; based on &quot; + td);</span>
        }

        // find other deps of that gov having reln &quot;conj&quot;
<span class="fc" id="L746">        boolean foundOne = false;</span>
<span class="fc bfc" id="L747" title="All 2 branches covered.">        for (TypedDependency td1 : list) {</span>
<span class="fc bfc" id="L748" title="All 2 branches covered.">          if (td1.gov().equals(gov)) {</span>
<span class="fc bfc" id="L749" title="All 2 branches covered.">            if (td1.reln() == CONJUNCT) { // i.e., &quot;conj&quot;</span>
              // change &quot;conj&quot; to the actual (lexical) conjunction
<span class="pc bpc" id="L751" title="1 of 2 branches missed.">              if (DEBUG) {</span>
<span class="nc" id="L752">                log.info(&quot;Changing &quot; + td1 + &quot; to have relation &quot; + conj);</span>
              }
<span class="fc" id="L754">              td1.setReln(conj);</span>
<span class="fc" id="L755">              foundOne = true;</span>
<span class="fc bfc" id="L756" title="All 2 branches covered.">            } else if (td1.reln() == COORDINATION) {</span>
<span class="fc" id="L757">              conj = conjValue(td1.dep().value());</span>
<span class="pc bpc" id="L758" title="1 of 2 branches missed.">              if (DEBUG) {</span>
<span class="nc" id="L759">                log.info(&quot;Set conj to &quot; + conj + &quot; based on &quot; + td1);</span>
              }
            }
          }
<span class="fc" id="L763">        }</span>

        // register to remove cc from this governor
<span class="fc bfc" id="L766" title="All 2 branches covered.">        if (foundOne) {</span>
<span class="fc" id="L767">          govs.add(gov);</span>
        }
      }
<span class="fc" id="L770">    }</span>

    // now remove typed dependencies with reln &quot;cc&quot; if we have successfully
    // collapsed
<span class="fc bfc" id="L774" title="All 4 branches covered.">    list.removeIf(td2 -&gt; td2.reln() == COORDINATION &amp;&amp; govs.contains(td2.gov()));</span>
<span class="fc" id="L775">  }</span>

  /**
   * This method will collapse a referent relation such as follows. e.g.:
   * &quot;The man that I love &amp;hellip; &quot; ref(man, that) dobj(love, that) -&amp;gt;
   * dobj(love, man)
   */
  private static void collapseReferent(Collection&lt;TypedDependency&gt; list) {
    // find typed deps of form ref(gov, dep)
    // put them in a List for processing; remove them from the set of deps
<span class="fc" id="L785">    List&lt;TypedDependency&gt; refs = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L786" title="All 2 branches covered.">    for (Iterator&lt;TypedDependency&gt; iter = list.iterator(); iter.hasNext();) {</span>
<span class="fc" id="L787">      TypedDependency td = iter.next();</span>
<span class="fc bfc" id="L788" title="All 2 branches covered.">      if (td.reln() == REFERENT) {</span>
<span class="fc" id="L789">        refs.add(td);</span>
<span class="fc" id="L790">        iter.remove();</span>
      }
<span class="fc" id="L792">    }</span>

    // now substitute target of referent where possible
<span class="fc bfc" id="L795" title="All 2 branches covered.">    for (TypedDependency ref : refs) {</span>
<span class="fc" id="L796">      IndexedWord dep = ref.dep();// take the relative word</span>
<span class="fc" id="L797">      IndexedWord ant = ref.gov();// take the antecedent</span>
<span class="fc bfc" id="L798" title="All 2 branches covered.">      for (TypedDependency td : list) {</span>
        // the last condition below maybe shouldn't be necessary, but it has
        // helped stop things going haywire a couple of times (it stops the
        // creation of a unit cycle that probably leaves something else
        // disconnected) [cdm Jan 2010]
<span class="pc bpc" id="L803" title="2 of 6 branches missed.">        if (td.dep().equals(dep) &amp;&amp; td.reln() != REFERENT &amp;&amp; !td.gov().equals(ant)) {</span>
<span class="pc bpc" id="L804" title="1 of 2 branches missed.">          if (DEBUG) {</span>
<span class="nc" id="L805">            log.info(&quot;referent: changing &quot; + td);</span>
          }
<span class="fc" id="L807">          td.setDep(ant);</span>
<span class="fc" id="L808">          td.setExtra();</span>
<span class="pc bpc" id="L809" title="1 of 2 branches missed.">          if (DEBUG) {</span>
<span class="nc" id="L810">            log.info(&quot; to &quot; + td);</span>
          }
        }
<span class="fc" id="L813">      }</span>
<span class="fc" id="L814">    }</span>
<span class="fc" id="L815">  }</span>

  /**
   * Look for ref rules for a given word.  We look through the
   * children and grandchildren of the rcmod dependency, and if any
   * children or grandchildren depend on a that/what/which/etc word,
   * we take the leftmost that/what/which/etc word as the dependent
   * for the ref TypedDependency.
   */
  private static void addRef(Collection&lt;TypedDependency&gt; list) {
<span class="fc" id="L825">    List&lt;TypedDependency&gt; newDeps = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L827" title="All 2 branches covered.">    for (TypedDependency rcmod : list) {</span>
<span class="fc bfc" id="L828" title="All 2 branches covered.">      if (rcmod.reln() != RELATIVE_CLAUSE_MODIFIER) {</span>
        // we only add ref dependencies across relative clauses
<span class="fc" id="L830">        continue;</span>
      }

<span class="fc" id="L833">      IndexedWord head = rcmod.gov();</span>
<span class="fc" id="L834">      IndexedWord modifier = rcmod.dep();</span>

<span class="fc" id="L836">      TypedDependency leftChild = null;</span>
<span class="fc bfc" id="L837" title="All 2 branches covered.">      for (TypedDependency child : list) {</span>
<span class="fc bfc" id="L838" title="All 2 branches covered.">        if (child.gov().equals(modifier) &amp;&amp;</span>
<span class="pc bpc" id="L839" title="1 of 4 branches missed.">            EnglishPatterns.RELATIVIZING_WORD_PATTERN.matcher(child.dep().value()).matches() &amp;&amp;</span>
<span class="nc bnc" id="L840" title="All 2 branches missed.">            (leftChild == null || child.dep().index() &lt; leftChild.dep().index())) {</span>
<span class="fc" id="L841">          leftChild = child;</span>
        }
<span class="fc" id="L843">      }</span>

      // TODO: could be made more efficient
<span class="fc" id="L846">      TypedDependency leftGrandchild = null;</span>
<span class="fc bfc" id="L847" title="All 2 branches covered.">      for (TypedDependency child : list) {</span>
<span class="fc bfc" id="L848" title="All 2 branches covered.">        if (!child.gov().equals(modifier)) {</span>
<span class="fc" id="L849">          continue;</span>
        }
<span class="fc bfc" id="L851" title="All 2 branches covered.">        for (TypedDependency grandchild : list) {</span>
<span class="fc bfc" id="L852" title="All 2 branches covered.">          if (grandchild.gov().equals(child.dep()) &amp;&amp;</span>
<span class="pc bpc" id="L853" title="1 of 4 branches missed.">              EnglishPatterns.RELATIVIZING_WORD_PATTERN.matcher(grandchild.dep().value()).matches() &amp;&amp;</span>
<span class="nc bnc" id="L854" title="All 2 branches missed.">              (leftGrandchild == null || grandchild.dep().index() &lt; leftGrandchild.dep().index())) {</span>
<span class="fc" id="L855">            leftGrandchild = grandchild;</span>
          }
<span class="fc" id="L857">        }</span>
<span class="fc" id="L858">      }</span>

<span class="fc" id="L860">      TypedDependency newDep = null;</span>
<span class="pc bpc" id="L861" title="3 of 6 branches missed.">      if (leftGrandchild != null &amp;&amp; (leftChild == null || leftGrandchild.dep().index() &lt; leftChild.dep().index())) {</span>
<span class="fc" id="L862">        newDep = new TypedDependency(REFERENT, head, leftGrandchild.dep());</span>
<span class="fc bfc" id="L863" title="All 2 branches covered.">      } else if (leftChild != null) {</span>
<span class="fc" id="L864">        newDep = new TypedDependency(REFERENT, head, leftChild.dep());</span>
      }
<span class="fc bfc" id="L866" title="All 2 branches covered.">      if (newDep != null) {</span>
<span class="fc" id="L867">        newDeps.add(newDep);</span>
      }
<span class="fc" id="L869">    }</span>

<span class="fc bfc" id="L871" title="All 2 branches covered.">    for (TypedDependency newDep : newDeps) {</span>
<span class="fc bfc" id="L872" title="All 2 branches covered.">      if (!list.contains(newDep)) {</span>
<span class="fc" id="L873">        newDep.setExtra();</span>
<span class="fc" id="L874">        list.add(newDep);</span>
      }
<span class="fc" id="L876">    }</span>
<span class="fc" id="L877">  }</span>

  /**
   * Add extra nsubj dependencies when collapsing basic dependencies.
   * &lt;br&gt;
   * In the general case, we look for an aux modifier under an xcomp
   * modifier, and assuming there aren't already associated nsubj
   * dependencies as daughters of the original xcomp dependency, we
   * add nsubj dependencies for each nsubj daughter of the aux.
   * &lt;br&gt;
   * There is also a special case for &quot;to&quot; words, in which case we add
   * a dependency if and only if there is no nsubj associated with the
   * xcomp and there is no other aux dependency.  This accounts for
   * sentences such as &quot;he decided not to&quot; with no following verb.
   */
  private static void addExtraNSubj(Collection&lt;TypedDependency&gt; list) {
<span class="fc" id="L893">    List&lt;TypedDependency&gt; newDeps = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L895" title="All 2 branches covered.">    for (TypedDependency xcomp : list) {</span>
<span class="fc bfc" id="L896" title="All 2 branches covered.">      if (xcomp.reln() != XCLAUSAL_COMPLEMENT) {</span>
        // we only add extra nsubj dependencies to some xcomp dependencies
<span class="fc" id="L898">        continue;</span>
      }

<span class="fc" id="L901">      IndexedWord modifier = xcomp.dep();</span>
<span class="fc" id="L902">      IndexedWord head = xcomp.gov();</span>

<span class="fc" id="L904">      boolean hasSubjectDaughter = false;</span>
<span class="fc" id="L905">      boolean hasAux = false;</span>
<span class="fc" id="L906">      List&lt;IndexedWord&gt; subjects = Generics.newArrayList();</span>
<span class="fc" id="L907">      List&lt;IndexedWord&gt; objects = Generics.newArrayList();</span>
<span class="fc bfc" id="L908" title="All 2 branches covered.">      for (TypedDependency dep : list) {</span>
        // already have a subject dependency
<span class="pc bpc" id="L910" title="1 of 6 branches missed.">        if ((dep.reln() == NOMINAL_SUBJECT || dep.reln() == NOMINAL_PASSIVE_SUBJECT) &amp;&amp; dep.gov().equals(modifier)) {</span>
<span class="fc" id="L911">          hasSubjectDaughter = true;</span>
<span class="fc" id="L912">          break;</span>
        }

<span class="fc bfc" id="L915" title="All 4 branches covered.">        if (dep.reln() == AUX_MODIFIER &amp;&amp; dep.gov().equals(modifier)) {</span>
<span class="fc" id="L916">          hasAux = true;</span>
        }

<span class="pc bpc" id="L919" title="1 of 6 branches missed.">        if ((dep.reln() == NOMINAL_SUBJECT || dep.reln() == NOMINAL_PASSIVE_SUBJECT) &amp;&amp; dep.gov().equals(head)) {</span>
<span class="fc" id="L920">          subjects.add(dep.dep());</span>
        }

<span class="pc bpc" id="L923" title="1 of 4 branches missed.">        if (dep.reln() == DIRECT_OBJECT &amp;&amp; dep.gov().equals(head)) {</span>
<span class="nc" id="L924">          objects.add(dep.dep());</span>
        }
<span class="fc" id="L926">      }</span>

      // if we already have an nsubj dependency, no need to add an extra nsubj
<span class="fc bfc" id="L929" title="All 2 branches covered.">      if (hasSubjectDaughter) {</span>
<span class="fc" id="L930">        continue;</span>
      }

<span class="pc bpc" id="L933" title="3 of 4 branches missed.">      if ((modifier.value().equalsIgnoreCase(&quot;to&quot;) &amp;&amp; hasAux) ||</span>
<span class="pc bpc" id="L934" title="1 of 4 branches missed.">          (!modifier.value().equalsIgnoreCase(&quot;to&quot;) &amp;&amp; !hasAux)) {</span>
<span class="fc" id="L935">        continue;</span>
      }

      // In general, we find that the objects of the verb are better
      // for extra nsubj than the original nsubj of the verb.  For example,
      // &quot;Many investors wrote asking the SEC to require ...&quot;
      // There is no nsubj of asking, but the dobj, SEC, is the extra nsubj of require.
      // Similarly, &quot;The law tells them when to do so&quot;
      // Instead of nsubj(do, law) we want nsubj(do, them)
<span class="pc bpc" id="L944" title="1 of 2 branches missed.">      if (objects.size() &gt; 0) {</span>
<span class="nc bnc" id="L945" title="All 2 branches missed.">        for (IndexedWord object : objects) {</span>
<span class="nc" id="L946">          TypedDependency newDep = new TypedDependency(NOMINAL_SUBJECT, modifier, object);</span>
<span class="nc" id="L947">          newDeps.add(newDep);</span>
<span class="nc" id="L948">        }</span>
      } else {
<span class="fc bfc" id="L950" title="All 2 branches covered.">        for (IndexedWord subject : subjects) {</span>
<span class="fc" id="L951">          TypedDependency newDep = new TypedDependency(NOMINAL_SUBJECT, modifier, subject);</span>
<span class="fc" id="L952">          newDeps.add(newDep);</span>
<span class="fc" id="L953">        }</span>
      }
<span class="fc" id="L955">    }</span>

<span class="fc bfc" id="L957" title="All 2 branches covered.">    for (TypedDependency newDep : newDeps) {</span>
<span class="pc bpc" id="L958" title="1 of 2 branches missed.">      if (!list.contains(newDep)) {</span>
<span class="fc" id="L959">        newDep.setExtra();</span>
<span class="fc" id="L960">        list.add(newDep);</span>
      }
<span class="fc" id="L962">    }</span>
<span class="fc" id="L963">  }</span>

  /**
   * This method corrects subjects of verbs for which we identified an auxpass,
   * but didn't identify the subject as passive.
   *
   * @param list List of typedDependencies to work on
   */
  private static void correctSubjPass(Collection&lt;TypedDependency&gt; list) {
    // put in a list verbs having an auxpass
<span class="fc" id="L973">    List&lt;IndexedWord&gt; list_auxpass = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L974" title="All 2 branches covered.">    for (TypedDependency td : list) {</span>
<span class="fc bfc" id="L975" title="All 2 branches covered.">      if (td.reln() == AUX_PASSIVE_MODIFIER) {</span>
<span class="fc" id="L976">        list_auxpass.add(td.gov());</span>
      }
<span class="fc" id="L978">    }</span>
<span class="fc bfc" id="L979" title="All 2 branches covered.">    for (TypedDependency td : list) {</span>
      // correct nsubj
<span class="fc bfc" id="L981" title="All 4 branches covered.">      if (td.reln() == NOMINAL_SUBJECT &amp;&amp; list_auxpass.contains(td.gov())) {</span>
        // log.info(&quot;%%% Changing subj to passive: &quot; + td);
<span class="fc" id="L983">        td.setReln(NOMINAL_PASSIVE_SUBJECT);</span>
      }
<span class="pc bpc" id="L985" title="1 of 4 branches missed.">      if (td.reln() == CLAUSAL_SUBJECT &amp;&amp; list_auxpass.contains(td.gov())) {</span>
        // log.info(&quot;%%% Changing subj to passive: &quot; + td);
<span class="nc" id="L987">        td.setReln(CLAUSAL_PASSIVE_SUBJECT);</span>
      }

      // correct unretrieved poss: dep relation in which the dependent is a
      // PRP$ or WP$
      // cdm: Now done in basic rules.  The only cases that this still matches
      // are (1) tagging mistakes where PRP in dobj position is mistagged PRP$
      // or a couple of parsing errors where the dependency is wrong anyway, so
      // it's probably okay to keep it a dep.  So I'm disabling this.
      // String tag = td.dep().tag();
      // if (td.reln() == DEPENDENT &amp;&amp; (tag.equals(&quot;PRP$&quot;) || tag.equals(&quot;WP$&quot;))) {
      //  log.info(&quot;%%% Unrecognized basic possessive pronoun: &quot; + td);
      //  td.setReln(POSSESSION_MODIFIER);
      // }
<span class="fc" id="L1001">    }</span>
<span class="fc" id="L1002">  }</span>

  private static boolean inConjDeps(TypedDependency td, List&lt;Triple&lt;TypedDependency, TypedDependency, Boolean&gt;&gt; conjs) {
<span class="fc bfc" id="L1005" title="All 2 branches covered.">    for (Triple&lt;TypedDependency, TypedDependency, Boolean&gt; trip : conjs) {</span>
<span class="fc bfc" id="L1006" title="All 2 branches covered.">      if (td.equals(trip.first())) {</span>
<span class="fc" id="L1007">        return true;</span>
      }
<span class="fc" id="L1009">    }</span>
<span class="fc" id="L1010">    return false;</span>
  }

  private static void collapsePrepAndPoss(Collection&lt;TypedDependency&gt; list) {

    // Man oh man, how gnarly is the logic of this method....

<span class="fc" id="L1017">    Collection&lt;TypedDependency&gt; newTypedDeps = new ArrayList&lt;&gt;();</span>

    // Construct a map from tree nodes to the set of typed
    // dependencies in which the node appears as governor.
    // cdm: could use CollectionValuedMap here!
<span class="fc" id="L1022">    Map&lt;IndexedWord, SortedSet&lt;TypedDependency&gt;&gt; map = Generics.newHashMap();</span>
<span class="fc" id="L1023">    List&lt;IndexedWord&gt; vmod = Generics.newArrayList();</span>

<span class="fc bfc" id="L1025" title="All 2 branches covered.">    for (TypedDependency typedDep : list) {</span>
<span class="fc bfc" id="L1026" title="All 2 branches covered.">      if (!map.containsKey(typedDep.gov())) {</span>
<span class="fc" id="L1027">        map.put(typedDep.gov(), new TreeSet&lt;&gt;());</span>
      }
<span class="fc" id="L1029">      map.get(typedDep.gov()).add(typedDep);</span>

<span class="fc bfc" id="L1031" title="All 2 branches covered.">      if (typedDep.reln() == VERBAL_MODIFIER) {</span>
        // look for aux deps which indicate this was a to-be verb
<span class="fc" id="L1033">        boolean foundAux = false;</span>
<span class="fc bfc" id="L1034" title="All 2 branches covered.">        for (TypedDependency auxDep : list) {</span>
<span class="pc bpc" id="L1035" title="1 of 2 branches missed.">          if (auxDep.reln() != AUX_MODIFIER) {</span>
<span class="fc" id="L1036">            continue;</span>
          }
<span class="nc bnc" id="L1038" title="All 4 branches missed.">          if (!auxDep.gov().equals(typedDep.dep()) || !auxDep.dep().value().equalsIgnoreCase(&quot;to&quot;)) {</span>
<span class="nc" id="L1039">            continue;</span>
          }
<span class="nc" id="L1041">          foundAux = true;</span>
<span class="nc" id="L1042">          break;</span>
        }
<span class="pc bpc" id="L1044" title="1 of 2 branches missed.">        if (!foundAux) {</span>
<span class="fc" id="L1045">          vmod.add(typedDep.dep());</span>
        }
      }
<span class="fc" id="L1048">    }</span>
    // log.info(&quot;here's the vmod list: &quot; + vmod);

    // Do preposition conjunction interaction for
    // governor p NP and p NP case ... a lot of special code cdm jan 2006

<span class="fc bfc" id="L1054" title="All 2 branches covered.">    for (TypedDependency td1 : list) {</span>
<span class="fc bfc" id="L1055" title="All 2 branches covered.">      if (td1.reln() != PREPOSITIONAL_MODIFIER) {</span>
<span class="fc" id="L1056">        continue;</span>
      }

<span class="fc" id="L1059">      IndexedWord td1Dep = td1.dep();</span>
<span class="fc" id="L1060">      SortedSet&lt;TypedDependency&gt; possibles = map.get(td1Dep);</span>
<span class="pc bpc" id="L1061" title="1 of 2 branches missed.">      if (possibles == null) {</span>
<span class="nc" id="L1062">        continue;</span>
      }

      // look for the &quot;second half&quot;

      // unique: the head prep and whether it should be pobj
<span class="fc" id="L1068">      Pair&lt;TypedDependency, Boolean&gt; prepDep = null;</span>
<span class="fc" id="L1069">      TypedDependency ccDep = null; // treat as unique</span>
      // list of dep and prepOtherDep and pobj (or pcomp)
<span class="fc" id="L1071">      List&lt;Triple&lt;TypedDependency, TypedDependency, Boolean&gt;&gt; conjs = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1072">      Set&lt;TypedDependency&gt; otherDtrs = new TreeSet&lt;&gt;();</span>

      // first look for a conj(prep, prep) (there might be several conj relations!!!)
<span class="fc" id="L1075">      boolean samePrepositionInEachConjunct = true;</span>
<span class="fc" id="L1076">      int conjIndex = -1;</span>
<span class="fc bfc" id="L1077" title="All 2 branches covered.">      for (TypedDependency td2 : possibles) {</span>
<span class="fc bfc" id="L1078" title="All 2 branches covered.">        if (td2.reln() == CONJUNCT) {</span>
<span class="fc" id="L1079">          IndexedWord td2Dep = td2.dep();</span>
<span class="fc" id="L1080">          String td2DepPOS = td2Dep.tag();</span>
<span class="pc bpc" id="L1081" title="1 of 4 branches missed.">          if (td2DepPOS.equals(&quot;IN&quot;) || td2DepPOS.equals(&quot;TO&quot;)) {</span>
<span class="fc bfc" id="L1082" title="All 4 branches covered.">            samePrepositionInEachConjunct = samePrepositionInEachConjunct &amp;&amp; td2Dep.value().equals(td1Dep.value());</span>
<span class="fc" id="L1083">            Set&lt;TypedDependency&gt; possibles2 = map.get(td2Dep);</span>
<span class="fc" id="L1084">            boolean pobj = true;// default of collapsing preposition is prep_</span>
<span class="fc" id="L1085">            TypedDependency prepOtherDep = null;</span>
<span class="fc bfc" id="L1086" title="All 2 branches covered.">            if (possibles2 != null) {</span>
<span class="fc bfc" id="L1087" title="All 2 branches covered.">              for (TypedDependency td3 : possibles2) {</span>
<span class="fc" id="L1088">                IndexedWord td3Dep = td3.dep();</span>
<span class="fc" id="L1089">                String td3DepPOS = td3Dep.tag();</span>
                // CDM Mar 2006: I put in disjunction here when I added in
                // PREPOSITIONAL_OBJECT. If it catches all cases, we should
                // be able to delete the DEPENDENT disjunct
                // maybe better to delete the DEPENDENT disjunct - it creates
                // problem with multiple prep (mcdm)
<span class="pc bpc" id="L1095" title="4 of 10 branches missed.">                if ((td3.reln() == PREPOSITIONAL_OBJECT || td3.reln() == PREPOSITIONAL_COMPLEMENT) &amp;&amp; (!(td3DepPOS.equals(&quot;IN&quot;) || td3DepPOS.equals(&quot;TO&quot;))) &amp;&amp; prepOtherDep == null) {</span>
<span class="fc" id="L1096">                  prepOtherDep = td3;</span>
<span class="pc bpc" id="L1097" title="1 of 2 branches missed.">                  if (td3.reln() == PREPOSITIONAL_COMPLEMENT) {</span>
<span class="nc" id="L1098">                    pobj = false;</span>
                  }
                } else {
<span class="fc" id="L1101">                  otherDtrs.add(td3);</span>
                }
<span class="fc" id="L1103">              }</span>
            }
<span class="pc bpc" id="L1105" title="1 of 2 branches missed.">            if (conjIndex &lt; td2Dep.index()) {</span>
<span class="fc" id="L1106">              conjIndex = td2Dep.index();</span>
            }
<span class="fc" id="L1108">            conjs.add(new Triple&lt;&gt;(td2, prepOtherDep, pobj));</span>
          }
        }
<span class="fc" id="L1111">      } // end td2:possibles</span>

<span class="fc bfc" id="L1113" title="All 2 branches covered.">      if (conjs.isEmpty()) {</span>
<span class="fc" id="L1114">        continue;</span>
      }

      // if we have a conj under a preposition dependency, we look for the other
      // parts

<span class="fc" id="L1120">      String td1DepPOS = td1Dep.tag();</span>
<span class="fc bfc" id="L1121" title="All 2 branches covered.">      for (TypedDependency td2 : possibles) {</span>
        // we look for the cc linked to this conjDep
        // the cc dep must have an index smaller than the dep of conjDep
<span class="pc bpc" id="L1124" title="1 of 4 branches missed.">        if (td2.reln() == COORDINATION &amp;&amp; td2.dep().index() &lt; conjIndex) {</span>
<span class="fc" id="L1125">          ccDep = td2;</span>
        } else {
<span class="fc" id="L1127">          IndexedWord td2Dep = td2.dep();</span>
<span class="fc" id="L1128">          String td2DepPOS = td2Dep.tag();</span>
          // log.info(&quot;prepDep find: td1.reln: &quot; + td1.reln() +
          // &quot;; td2.reln: &quot; + td2.reln() + &quot;; td1DepPos: &quot; + td1DepPOS +
          // &quot;; td2DepPos: &quot; + td2DepPOS + &quot;; index &quot; + index +
          // &quot;; td2.dep().index(): &quot; + td2.dep().index());
<span class="pc bpc" id="L1133" title="8 of 20 branches missed.">          if ((td2.reln() == DEPENDENT || td2.reln() == PREPOSITIONAL_OBJECT || td2.reln() == PREPOSITIONAL_COMPLEMENT) &amp;&amp; (td1DepPOS.equals(&quot;IN&quot;) || td1DepPOS.equals(&quot;TO&quot;) || td1DepPOS.equals(&quot;VBG&quot;)) &amp;&amp; prepDep == null &amp;&amp; (!(td2DepPOS.equals(&quot;RB&quot;) || td2DepPOS.equals(&quot;IN&quot;) || td2DepPOS.equals(&quot;TO&quot;)))) {</span>
            // same index trick, in case we have multiple deps
            // I deleted this to see if it helped [cdm Jan 2010] &amp;&amp;
            // td2.dep().index() &lt; index)
<span class="fc bfc" id="L1137" title="All 2 branches covered.">            prepDep = new Pair&lt;&gt;(td2, td2.reln() != PREPOSITIONAL_COMPLEMENT);</span>
<span class="fc bfc" id="L1138" title="All 2 branches covered.">          } else if (!inConjDeps(td2, conjs)) {// don't want to add the conjDep</span>
            // again!
<span class="fc" id="L1140">            otherDtrs.add(td2);</span>
          }
        }
<span class="fc" id="L1143">      }</span>

<span class="pc bpc" id="L1145" title="2 of 4 branches missed.">      if (prepDep == null || ccDep == null) {</span>
<span class="nc" id="L1146">        continue; // we can't deal with it in the hairy prep/conj interaction case!</span>
      }

<span class="pc bpc" id="L1149" title="1 of 2 branches missed.">      if (DEBUG) {</span>
        // ccDep must be non-null given test above
<span class="nc" id="L1151">        log.info(&quot;!! Conj and prep case:&quot;);</span>
<span class="nc" id="L1152">        log.info(&quot;  td1 (prep): &quot; + td1);</span>
<span class="nc" id="L1153">        log.info(&quot;  Kids of td1 are: &quot; + possibles);</span>
<span class="nc" id="L1154">        log.info(&quot;  prepDep: &quot; + prepDep);</span>
<span class="nc" id="L1155">        log.info(&quot;  ccDep: &quot; + ccDep);</span>
<span class="nc" id="L1156">        log.info(&quot;  conjs: &quot; + conjs);</span>
<span class="nc" id="L1157">        log.info(&quot;  samePrepositionInEachConjunct: &quot; + samePrepositionInEachConjunct);</span>
<span class="nc" id="L1158">        log.info(&quot;  otherDtrs: &quot; + otherDtrs);</span>
      }

      // check if we have the same prepositions in the conjunction
<span class="fc bfc" id="L1162" title="All 2 branches covered.">      if (samePrepositionInEachConjunct) { // conjDep != null &amp;&amp; prepOtherDep !=</span>
        // null &amp;&amp;
        // OK, we have a conjunction over parallel PPs: Fred flew to Greece and
        // to Serbia.
<span class="fc" id="L1166">        GrammaticalRelation reln = determinePrepRelation(map, vmod, td1, td1, prepDep.second());</span>

<span class="fc" id="L1168">        TypedDependency tdNew = new TypedDependency(reln, td1.gov(), prepDep.first().dep());</span>
<span class="fc" id="L1169">        newTypedDeps.add(tdNew);</span>
<span class="pc bpc" id="L1170" title="1 of 2 branches missed.">        if (DEBUG) {</span>
<span class="nc" id="L1171">          log.info(&quot;PrepPoss Conj branch (two parallel PPs) adding: &quot; + tdNew);</span>
<span class="nc" id="L1172">          log.info(&quot;  removing: &quot; + td1 + &quot;  &quot; + prepDep + &quot;  &quot; + ccDep);</span>
        }
<span class="fc" id="L1174">        td1.setReln(KILL);// remember these are &quot;used up&quot;</span>
<span class="fc" id="L1175">        prepDep.first().setReln(KILL);</span>
<span class="fc" id="L1176">        ccDep.setReln(KILL);</span>

<span class="fc bfc" id="L1178" title="All 2 branches covered.">        for (Triple&lt;TypedDependency, TypedDependency, Boolean&gt; trip : conjs) {</span>
<span class="fc" id="L1179">          TypedDependency conjDep = trip.first();</span>
<span class="fc" id="L1180">          TypedDependency prepOtherDep = trip.second();</span>
<span class="fc bfc" id="L1181" title="All 2 branches covered.">          if (prepOtherDep == null) {</span>
            // CDM July 2010: I think this should only ever happen if there is a
            // misparse, but it has happened in such circumstances. You have
            // something like (PP in or in (NP Serbia)), with the two
            // prepositions the same. We just clean up the mess.
<span class="pc bpc" id="L1186" title="1 of 2 branches missed.">            if (DEBUG) {</span>
<span class="nc" id="L1187">              log.info(&quot;  apparent misparse: same P twice with only one NP object (prepOtherDep is null)&quot;);</span>
<span class="nc" id="L1188">              log.info(&quot;  removing: &quot; + conjDep);</span>
            }
<span class="fc" id="L1190">            ccDep.setReln(KILL);</span>
          } else {
<span class="fc" id="L1192">            TypedDependency tdNew2 = new TypedDependency(conjValue(ccDep.dep().value()), prepDep.first().dep(), prepOtherDep.dep());</span>
<span class="fc" id="L1193">            newTypedDeps.add(tdNew2);</span>
<span class="pc bpc" id="L1194" title="1 of 2 branches missed.">            if (DEBUG) {</span>
<span class="nc" id="L1195">              log.info(&quot;  adding: &quot; + tdNew2);</span>
<span class="nc" id="L1196">              log.info(&quot;  removing: &quot; + conjDep + &quot;  &quot; + prepOtherDep);</span>
            }
<span class="fc" id="L1198">            prepOtherDep.setReln(KILL);</span>
          }
<span class="fc" id="L1200">          conjDep.setReln(KILL);</span>
<span class="fc" id="L1201">        }</span>

        // promote dtrs that would be orphaned
<span class="fc bfc" id="L1204" title="All 2 branches covered.">        for (TypedDependency otd : otherDtrs) {</span>
<span class="pc bpc" id="L1205" title="1 of 2 branches missed.">          if (DEBUG) {</span>
<span class="nc" id="L1206">            log.info(&quot;Changed &quot; + otd);</span>
          }
<span class="fc" id="L1208">          otd.setGov(td1.gov());</span>
<span class="pc bpc" id="L1209" title="1 of 2 branches missed.">          if (DEBUG) {</span>
<span class="nc" id="L1210">            log.info(&quot; to &quot; + otd);</span>
          }
<span class="fc" id="L1212">        }</span>

        // Now we need to see if there are any TDs that will be &quot;orphaned&quot;
        // by this collapse. Example: if we have:
        // dep(drew, on)
        // dep(on, book)
        // dep(on, right)
        // the first two will be collapsed to on(drew, book), but then
        // the third one will be orphaned, since its governor no
        // longer appears. So, change its governor to 'drew'.
        // CDM Feb 2010: This used to not move COORDINATION OR CONJUNCT, but now
        // it does, since they're not automatically deleted
        // Some things in possibles may have already been changed, so check gov
<span class="pc bpc" id="L1225" title="1 of 2 branches missed.">        if (DEBUG) {</span>
<span class="nc" id="L1226">          log.info(&quot;td1: &quot; + td1 + &quot;; possibles: &quot; + possibles);</span>
        }
<span class="fc bfc" id="L1228" title="All 2 branches covered.">        for (TypedDependency td2 : possibles) {</span>
          // if (DEBUG) {
          // log.info(&quot;[a] td2.reln &quot; + td2.reln() + &quot; td2.gov &quot; +
          // td2.gov() + &quot; td1.dep &quot; + td1.dep());
          // }
<span class="pc bpc" id="L1233" title="1 of 4 branches missed.">          if (td2.reln() != KILL &amp;&amp; td2.gov().equals(td1.dep())) { // &amp;&amp; td2.reln()</span>
            // != COORDINATION
            // &amp;&amp; td2.reln()
            // != CONJUNCT
<span class="nc bnc" id="L1237" title="All 2 branches missed.">            if (DEBUG) {</span>
<span class="nc" id="L1238">              log.info(&quot;Changing &quot; + td2 + &quot; to have governor of &quot; + td1 + &quot; [a]&quot;);</span>
            }
<span class="nc" id="L1240">            td2.setGov(td1.gov());</span>
          }
<span class="fc" id="L1242">        }</span>
<span class="fc" id="L1243">        continue; // This one has been dealt with successfully</span>
      } // end same prepositions

      // case of &quot;Lufthansa flies to and from Serbia&quot;. Make it look like next
      // case :-)
      // that is, the prepOtherDep should be the same as prepDep !
<span class="fc bfc" id="L1249" title="All 2 branches covered.">      for (Triple&lt;TypedDependency, TypedDependency, Boolean&gt; trip : conjs) {</span>
<span class="pc bpc" id="L1250" title="1 of 4 branches missed.">        if (trip.first() != null &amp;&amp; trip.second() == null) {</span>
<span class="fc" id="L1251">          trip.setSecond(new TypedDependency(prepDep.first().reln(), trip.first().dep(), prepDep.first().dep()));</span>
<span class="fc" id="L1252">          trip.setThird(prepDep.second());</span>
        }
<span class="fc" id="L1254">      }</span>

      // we have two different prepositions in the conjunction
      // in this case we need to add a node
      // &quot;Bill jumped over the fence and through the hoop&quot;
      // prep_over(jumped, fence)
      // conj_and(jumped, jumped)
      // prep_through(jumped, hoop)
      // Extra complication:
      // If &quot;jumped&quot; is already part of a conjunction, we should add the new one off that rather than chaining
<span class="fc" id="L1264">      IndexedWord conjHead = td1.gov();</span>
<span class="fc bfc" id="L1265" title="All 2 branches covered.">      for (TypedDependency td3 : list) {</span>
<span class="pc bpc" id="L1266" title="1 of 4 branches missed.">        if (td3.dep().equals(td1.gov()) &amp;&amp; td3.reln().equals(CONJUNCT)) {</span>
<span class="nc" id="L1267">          conjHead = td3.gov();</span>
        }
<span class="fc" id="L1269">      }</span>

<span class="fc" id="L1271">      GrammaticalRelation reln = determinePrepRelation(map, vmod, td1, td1, prepDep.second());</span>
<span class="fc" id="L1272">      TypedDependency tdNew = new TypedDependency(reln, td1.gov(), prepDep.first().dep());</span>
<span class="fc" id="L1273">      newTypedDeps.add(tdNew);</span>
<span class="pc bpc" id="L1274" title="1 of 2 branches missed.">      if (DEBUG) {</span>
<span class="nc" id="L1275">        log.info(&quot;ConjPP (different preps) adding: &quot; + tdNew);</span>
<span class="nc" id="L1276">        log.info(&quot;  deleting: &quot; + td1 + &quot;  &quot; + prepDep.first() + &quot;  &quot; + ccDep);</span>
      }
<span class="fc" id="L1278">      td1.setReln(KILL);// remember these are &quot;used up&quot;</span>
<span class="fc" id="L1279">      prepDep.first().setReln(KILL);</span>
<span class="fc" id="L1280">      ccDep.setReln(KILL);</span>
      // so far we added the first prep grammatical relation

<span class="fc" id="L1283">      int copyNumber = 1;</span>
<span class="fc bfc" id="L1284" title="All 2 branches covered.">      for (Triple&lt;TypedDependency, TypedDependency, Boolean&gt; trip : conjs) {</span>
<span class="fc" id="L1285">        TypedDependency conjDep = trip.first();</span>
<span class="fc" id="L1286">        TypedDependency prepOtherDep = trip.second();</span>
<span class="fc" id="L1287">        boolean pobj = trip.third();</span>
        // OK, we have a conjunction over different PPs
        // we create a new node;
        // in order to make a distinction between the original node and its copy
        // we set the &quot;copyCount&quot; variable in the IndexedWord
        // existence of copyCount &gt; 0 is checked at printing (toString method of
        // TypedDependency)
<span class="fc" id="L1294">        IndexedWord label = td1.gov().makeSoftCopy(copyNumber);</span>
<span class="fc" id="L1295">        copyNumber++;</span>

        // now we add the conjunction relation between conjHead (either td1.gov
        // or what it is itself conjoined with) and the copy
        // the copy has the same label as td1.gov() but is another TreeGraphNode
        // todo: Or that's the plan; there are a couple of knock on changes to fix before we can do this!
        // TypedDependency tdNew2 = new TypedDependency(conjValue(ccDep.dep().value()), conjHead, label);
<span class="fc" id="L1302">        TypedDependency tdNew2 = new TypedDependency(conjValue(ccDep.dep().value()), td1.gov(), label);</span>
<span class="fc" id="L1303">        newTypedDeps.add(tdNew2);</span>

        // now we still need to add the second prep grammatical relation
        // between the copy and the dependent of the prepOtherDep node
        TypedDependency tdNew3;

<span class="fc" id="L1309">        GrammaticalRelation reln2 = determinePrepRelation(map, vmod, conjDep, td1, pobj);</span>
<span class="fc" id="L1310">        tdNew3 = new TypedDependency(reln2, label, prepOtherDep.dep());</span>
<span class="fc" id="L1311">        newTypedDeps.add(tdNew3);</span>

<span class="pc bpc" id="L1313" title="1 of 2 branches missed.">        if (DEBUG) {</span>
<span class="nc" id="L1314">          log.info(&quot;  adding: &quot; + tdNew2 + &quot;  &quot; + tdNew3);</span>
<span class="nc" id="L1315">          log.info(&quot;  deleting: &quot; + conjDep + &quot;  &quot; + prepOtherDep);</span>
        }
<span class="fc" id="L1317">        conjDep.setReln(KILL);</span>
<span class="fc" id="L1318">        prepOtherDep.setReln(KILL);</span>

        // promote dtrs that would be orphaned
<span class="fc bfc" id="L1321" title="All 2 branches covered.">        for (TypedDependency otd : otherDtrs) {</span>
          // special treatment for prepositions: the original relation is
          // likely to be a &quot;dep&quot; and we want this to be a &quot;prep&quot;
<span class="pc bpc" id="L1324" title="1 of 2 branches missed.">          if (otd.dep().tag().equals(&quot;IN&quot;)) {</span>
<span class="nc" id="L1325">            otd.setReln(PREPOSITIONAL_MODIFIER);</span>
          }
<span class="fc" id="L1327">          otd.setGov(td1.gov());</span>
<span class="fc" id="L1328">        }</span>
<span class="fc" id="L1329">      }</span>

      // Now we need to see if there are any TDs that will be &quot;orphaned&quot; off
      // the first preposition
      // by this collapse. Example: if we have:
      // dep(drew, on)
      // dep(on, book)
      // dep(on, right)
      // the first two will be collapsed to on(drew, book), but then
      // the third one will be orphaned, since its governor no
      // longer appears. So, change its governor to 'drew'.
      // CDM Feb 2010: This used to not move COORDINATION OR CONJUNCT, but now
      // it does, since they're not automatically deleted
<span class="fc bfc" id="L1342" title="All 2 branches covered.">      for (TypedDependency td2 : possibles) {</span>
<span class="pc bpc" id="L1343" title="1 of 2 branches missed.">        if (td2.reln() != KILL) { // &amp;&amp; td2.reln() != COORDINATION &amp;&amp;</span>
          // td2.reln() != CONJUNCT) {
<span class="nc bnc" id="L1345" title="All 2 branches missed.">          if (DEBUG) {</span>
<span class="nc" id="L1346">            log.info(&quot;Changing &quot; + td2 + &quot; to have governor of &quot; + td1 + &quot; [b]&quot;);</span>
          }
<span class="nc" id="L1348">          td2.setGov(td1.gov());</span>
        }
<span class="fc" id="L1350">      }</span>
      // end for different prepositions
<span class="fc" id="L1352">    } // for TypedDependency td1 : list</span>

    // below here is the single preposition/possessor basic case!!
<span class="fc bfc" id="L1355" title="All 2 branches covered.">    for (TypedDependency td1 : list) {</span>
<span class="fc bfc" id="L1356" title="All 2 branches covered.">      if (td1.reln() == KILL) {</span>
<span class="fc" id="L1357">        continue;</span>
      }

<span class="fc" id="L1360">      IndexedWord td1Dep = td1.dep();</span>
<span class="fc" id="L1361">      String td1DepPOS = td1Dep.tag();</span>
      // find all other typedDeps having our dep as gov
<span class="fc" id="L1363">      Set&lt;TypedDependency&gt; possibles = map.get(td1Dep);</span>

<span class="fc bfc" id="L1365" title="All 8 branches covered.">      if (possibles != null &amp;&amp; (td1.reln() == PREPOSITIONAL_MODIFIER || td1.reln() == POSSESSION_MODIFIER || td1.reln() == CONJUNCT)) {</span>

        // look for the &quot;second half&quot;
<span class="fc" id="L1368">        boolean pobj = true;// default for prep relation is prep_</span>
<span class="fc bfc" id="L1369" title="All 2 branches covered.">        for (TypedDependency td2 : possibles) {</span>
<span class="fc bfc" id="L1370" title="All 4 branches covered.">          if (td2.reln() != COORDINATION &amp;&amp; td2.reln() != CONJUNCT) {</span>

<span class="fc" id="L1372">            IndexedWord td2Dep = td2.dep();</span>
<span class="fc" id="L1373">            String td2DepPOS = td2Dep.tag();</span>
<span class="fc bfc" id="L1374" title="All 4 branches covered.">            if ((td1.reln() == POSSESSION_MODIFIER || td1.reln() == CONJUNCT)) {</span>
<span class="fc bfc" id="L1375" title="All 2 branches covered.">              if (td2.reln() == POSSESSIVE_MODIFIER) {</span>
<span class="pc bpc" id="L1376" title="1 of 2 branches missed.">                if ( ! map.containsKey(td2Dep)) {  // if 's has no kids of its own (it shouldn't!)</span>
<span class="fc" id="L1377">                  td2.setReln(KILL);</span>
                }
              }
<span class="pc bpc" id="L1380" title="7 of 18 branches missed.">            } else if ((td2.reln() == PREPOSITIONAL_OBJECT || td2.reln() == PREPOSITIONAL_COMPLEMENT) &amp;&amp; (td1DepPOS.equals(&quot;IN&quot;) || td1DepPOS.equals(&quot;TO&quot;) || td1DepPOS.equals(&quot;VBG&quot;)) &amp;&amp; (!(td2DepPOS.equals(&quot;RB&quot;) || td2DepPOS.equals(&quot;IN&quot;) || td2DepPOS.equals(&quot;TO&quot;))) &amp;&amp; !isConjWithNoPrep(td2.gov(), possibles)) {</span>
              // we don't collapse preposition conjoined with a non-preposition
              // to avoid disconnected constituents
              // OK, we have a pair td1, td2 to collapse to td3
<span class="pc bpc" id="L1384" title="1 of 2 branches missed.">              if (DEBUG) {</span>
<span class="nc" id="L1385">                log.info(&quot;(Single prep/poss base case collapsing &quot; + td1 + &quot; and &quot; + td2);</span>
              }

              // check whether we are in a pcomp case:
<span class="fc bfc" id="L1389" title="All 2 branches covered.">              if (td2.reln() == PREPOSITIONAL_COMPLEMENT) {</span>
<span class="fc" id="L1390">                pobj = false;</span>
              }

<span class="fc" id="L1393">              GrammaticalRelation reln = determinePrepRelation(map, vmod, td1, td1, pobj);</span>
<span class="fc" id="L1394">              TypedDependency td3 = new TypedDependency(reln, td1.gov(), td2.dep());</span>
<span class="pc bpc" id="L1395" title="1 of 2 branches missed.">              if (DEBUG) {</span>
<span class="nc" id="L1396">                log.info(&quot;PP adding: &quot; + td3 + &quot; deleting: &quot; + td1 + ' ' + td2);</span>
              }
              // add it to map to deal with recursive cases like &quot;achieved this (PP (PP in part) with talent)&quot;
<span class="fc" id="L1399">              map.get(td3.gov()).add(td3);</span>

<span class="fc" id="L1401">              newTypedDeps.add(td3);</span>
<span class="fc" id="L1402">              td1.setReln(KILL);// remember these are &quot;used up&quot;</span>
<span class="fc" id="L1403">              td2.setReln(KILL);// remember these are &quot;used up&quot;</span>
            }
          }
<span class="fc" id="L1406">        } // for TypedDependency td2</span>
      }

      // Now we need to see if there are any TDs that will be &quot;orphaned&quot;
      // by this collapse. Example: if we have:
      // dep(drew, on)
      // dep(on, book)
      // dep(on, right)
      // the first two will be collapsed to on(drew, book), but then
      // the third one will be orphaned, since its governor no
      // longer appears. So, change its governor to 'drew'.
      // CDM Feb 2010: This used to not move COORDINATION OR CONJUNCT, but now
      // it does, since they're not automatically deleted
<span class="fc bfc" id="L1419" title="All 4 branches covered.">      if (possibles != null &amp;&amp; td1.reln() == KILL) {</span>
<span class="fc bfc" id="L1420" title="All 2 branches covered.">        for (TypedDependency td2 : possibles) {</span>
<span class="fc bfc" id="L1421" title="All 2 branches covered.">          if (td2.reln() != KILL) { // &amp;&amp; td2.reln() != COORDINATION &amp;&amp;</span>
            // td2.reln() != CONJUNCT) {
<span class="pc bpc" id="L1423" title="1 of 2 branches missed.">            if (DEBUG) {</span>
<span class="nc" id="L1424">              log.info(&quot;Changing &quot; + td2 + &quot; to have governor of &quot; + td1 + &quot; [c]&quot;);</span>
            }
<span class="fc" id="L1426">            td2.setGov(td1.gov());</span>
          }
<span class="fc" id="L1428">        }</span>
      }

<span class="fc" id="L1431">    } // for TypedDependency td1</span>

    // now remove typed dependencies with reln &quot;kill&quot; and add new ones.
<span class="fc bfc" id="L1434" title="All 2 branches covered.">    for (Iterator&lt;TypedDependency&gt; iter = list.iterator(); iter.hasNext();) {</span>
<span class="fc" id="L1435">      TypedDependency td = iter.next();</span>
<span class="fc bfc" id="L1436" title="All 2 branches covered.">      if (td.reln() == KILL) {</span>
<span class="pc bpc" id="L1437" title="1 of 2 branches missed.">        if (DEBUG) {</span>
<span class="nc" id="L1438">          log.info(&quot;Removing dep killed in poss/prep (conj) collapse: &quot; + td);</span>
        }
<span class="fc" id="L1440">        iter.remove();</span>
      }
<span class="fc" id="L1442">    }</span>
<span class="fc" id="L1443">    list.addAll(newTypedDeps);</span>
<span class="fc" id="L1444">  } // end collapsePrepAndPoss()</span>


  /** Work out prep relation name. pc is the dependency whose dep() is the
   *  preposition to do a name for. topPrep may be the same or different.
   *  Among the daughters of its gov is where to look for an auxpass.
   */
  private static GrammaticalRelation determinePrepRelation(Map&lt;IndexedWord, ? extends Set&lt;TypedDependency&gt;&gt; map, List&lt;IndexedWord&gt; vmod, TypedDependency pc, TypedDependency topPrep, boolean pobj) {
    // handling the case of an &quot;agent&quot;:
    // the governor of a &quot;by&quot; preposition must have an &quot;auxpass&quot; dependency
    // or be the dependent of a &quot;vmod&quot; relation
    // if it is the case, the &quot;agent&quot; variable becomes true
<span class="fc" id="L1456">    boolean agent = false;</span>
<span class="fc" id="L1457">    String preposition = pc.dep().value().toLowerCase();</span>
<span class="fc bfc" id="L1458" title="All 2 branches covered.">    if (preposition.equals(&quot;by&quot;)) {</span>
      // look if we have an auxpass
<span class="fc" id="L1460">      Set&lt;TypedDependency&gt; aux_pass_poss = map.get(topPrep.gov());</span>
<span class="pc bpc" id="L1461" title="1 of 2 branches missed.">      if (aux_pass_poss != null) {</span>
<span class="fc bfc" id="L1462" title="All 2 branches covered.">        for (TypedDependency td_pass : aux_pass_poss) {</span>
<span class="fc bfc" id="L1463" title="All 2 branches covered.">          if (td_pass.reln() == AUX_PASSIVE_MODIFIER) {</span>
<span class="fc" id="L1464">            agent = true;</span>
          }
<span class="fc" id="L1466">        }</span>
      }
      // look if we have a vmod
<span class="pc bpc" id="L1469" title="3 of 4 branches missed.">      if (!vmod.isEmpty() &amp;&amp; vmod.contains(topPrep.gov())) {</span>
<span class="nc" id="L1470">        agent = true;</span>
      }
    }

    GrammaticalRelation reln;
<span class="fc bfc" id="L1475" title="All 2 branches covered.">    if (agent) {</span>
<span class="fc" id="L1476">      reln = AGENT;</span>
    } else {
      // for prepositions, use the preposition
      // for pobj: we collapse into &quot;prep&quot;; for pcomp: we collapse into &quot;prepc&quot;
<span class="fc bfc" id="L1480" title="All 2 branches covered.">      if (pobj) {</span>
<span class="fc" id="L1481">        reln = EnglishGrammaticalRelations.getPrep(preposition);</span>
      } else {
<span class="fc" id="L1483">        reln = EnglishGrammaticalRelations.getPrepC(preposition);</span>
      }
    }
<span class="fc" id="L1486">    return reln;</span>
  }

  // used by collapse2WP(), collapseFlatMWP(), collapse2WPbis() KEPT IN
  // ALPHABETICAL ORDER
<span class="fc" id="L1491">  private static final String[][] MULTIWORD_PREPS = { { &quot;according&quot;, &quot;to&quot; }, { &quot;across&quot;, &quot;from&quot; }, { &quot;ahead&quot;, &quot;of&quot; }, { &quot;along&quot;, &quot;with&quot; }, { &quot;alongside&quot;, &quot;of&quot; }, { &quot;apart&quot;, &quot;from&quot; }, { &quot;as&quot;, &quot;for&quot; }, { &quot;as&quot;, &quot;from&quot; }, { &quot;as&quot;, &quot;of&quot; }, { &quot;as&quot;, &quot;per&quot; }, { &quot;as&quot;, &quot;to&quot; }, { &quot;aside&quot;, &quot;from&quot; }, { &quot;away&quot;, &quot;from&quot; }, { &quot;based&quot;, &quot;on&quot; }, { &quot;because&quot;, &quot;of&quot; }, { &quot;close&quot;, &quot;by&quot; }, { &quot;close&quot;, &quot;to&quot; }, { &quot;contrary&quot;, &quot;to&quot; }, { &quot;compared&quot;, &quot;to&quot; }, { &quot;compared&quot;, &quot;with&quot; }, { &quot;due&quot;, &quot;to&quot; }, { &quot;depending&quot;, &quot;on&quot; }, { &quot;except&quot;, &quot;for&quot; }, { &quot;exclusive&quot;, &quot;of&quot; }, { &quot;far&quot;, &quot;from&quot; }, { &quot;followed&quot;, &quot;by&quot; }, { &quot;inside&quot;, &quot;of&quot; }, { &quot;instead&quot;, &quot;of&quot; }, { &quot;irrespective&quot;, &quot;of&quot; }, { &quot;next&quot;, &quot;to&quot; }, { &quot;near&quot;, &quot;to&quot; }, { &quot;off&quot;, &quot;of&quot; }, { &quot;out&quot;, &quot;of&quot; }, { &quot;outside&quot;, &quot;of&quot; }, { &quot;owing&quot;, &quot;to&quot; }, { &quot;preliminary&quot;, &quot;to&quot; },</span>
      { &quot;preparatory&quot;, &quot;to&quot; }, { &quot;previous&quot;, &quot;to&quot; }, { &quot;prior&quot;, &quot;to&quot; }, { &quot;pursuant&quot;, &quot;to&quot; }, { &quot;regardless&quot;, &quot;of&quot; }, { &quot;subsequent&quot;, &quot;to&quot; }, { &quot;such&quot;, &quot;as&quot; }, { &quot;thanks&quot;, &quot;to&quot; }, { &quot;together&quot;, &quot;with&quot; } };

  // used by collapse3WP() KEPT IN ALPHABETICAL ORDER
<span class="fc" id="L1495">  private static final String[][] THREEWORD_PREPS = { { &quot;by&quot;, &quot;means&quot;, &quot;of&quot; }, { &quot;in&quot;, &quot;accordance&quot;, &quot;with&quot; }, { &quot;in&quot;, &quot;addition&quot;, &quot;to&quot; }, { &quot;in&quot;, &quot;case&quot;, &quot;of&quot; }, { &quot;in&quot;, &quot;front&quot;, &quot;of&quot; }, { &quot;in&quot;, &quot;lieu&quot;, &quot;of&quot; }, { &quot;in&quot;, &quot;place&quot;, &quot;of&quot; }, { &quot;in&quot;, &quot;spite&quot;, &quot;of&quot; }, { &quot;on&quot;, &quot;account&quot;, &quot;of&quot; }, { &quot;on&quot;, &quot;behalf&quot;, &quot;of&quot; }, { &quot;on&quot;, &quot;top&quot;, &quot;of&quot; }, { &quot;with&quot;, &quot;regard&quot;, &quot;to&quot; }, { &quot;with&quot;, &quot;respect&quot;, &quot;to&quot; } };</span>

  /**
   * Given a list of typedDependencies, returns true if the node &quot;node&quot; is the
   * governor of a conj relation with a dependent which is not a preposition
   *
   * @param node
   *          A node in this GrammaticalStructure
   * @param list
   *          A list of typedDependencies
   * @return true If node is the governor of a conj relation in the list with
   *         the dep not being a preposition
   */
  private static boolean isConjWithNoPrep(IndexedWord node, Collection&lt;TypedDependency&gt; list) {
<span class="fc bfc" id="L1509" title="All 2 branches covered.">    for (TypedDependency td : list) {</span>
<span class="pc bpc" id="L1510" title="2 of 4 branches missed.">      if (td.gov().equals(node) &amp;&amp; td.reln() == CONJUNCT) {</span>
        // we have a conjunct
        // check the POS of the dependent
<span class="nc" id="L1513">        String tdDepPOS = td.dep().tag();</span>
<span class="nc bnc" id="L1514" title="All 4 branches missed.">        if (!(tdDepPOS.equals(&quot;IN&quot;) || tdDepPOS.equals(&quot;TO&quot;))) {</span>
<span class="nc" id="L1515">          return true;</span>
        }
      }
<span class="fc" id="L1518">    }</span>
<span class="fc" id="L1519">    return false;</span>
  }

  /**
   * Collapse multiword preposition of the following format:
   * prep|advmod|dep|amod(gov, mwp[0]) &lt;br/&gt;
   * dep(mpw[0],mwp[1]) &lt;br/&gt;
   * pobj|pcomp(mwp[1], compl) or pobj|pcomp(mwp[0], compl) &lt;br/&gt;
   * -&amp;gt; prep_mwp[0]_mwp[1](gov, compl) &lt;br/&gt;
   *
   * prep|advmod|dep|amod(gov, mwp[1]) &lt;br/&gt;
   * dep(mpw[1],mwp[0]) &lt;br/&gt;
   * pobj|pcomp(mwp[1], compl) or pobj|pcomp(mwp[0], compl) &lt;br/&gt;
   * -&amp;gt; prep_mwp[0]_mwp[1](gov, compl)
   * &lt;p/&gt;
   *
   * The collapsing has to be done at once in order to know exactly which node
   * is the gov and the dep of the multiword preposition. Otherwise this can
   * lead to problems: removing a non-multiword &quot;to&quot; preposition for example!!!
   * This method replaces the old &quot;collapsedMultiWordPreps&quot;
   *
   * @param list
   *          list of typedDependencies to work on
   */
  private static void collapse2WP(Collection&lt;TypedDependency&gt; list) {
<span class="fc" id="L1544">    Collection&lt;TypedDependency&gt; newTypedDeps = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L1546" title="All 2 branches covered.">    for (String[] mwp : MULTIWORD_PREPS) {</span>
      // first look for patterns such as:
      // X(gov, mwp[0])
      // Y(mpw[0],mwp[1])
      // Z(mwp[1], compl) or Z(mwp[0], compl)
      // -&gt; prep_mwp[0]_mwp[1](gov, compl)
<span class="fc" id="L1552">      collapseMultiWordPrep(list, newTypedDeps, mwp[0], mwp[1], mwp[0], mwp[1]);</span>

      // now look for patterns such as:
      // X(gov, mwp[1])
      // Y(mpw[1],mwp[0])
      // Z(mwp[1], compl) or Z(mwp[0], compl)
      // -&gt; prep_mwp[0]_mwp[1](gov, compl)
<span class="fc" id="L1559">      collapseMultiWordPrep(list, newTypedDeps, mwp[0], mwp[1], mwp[1], mwp[0]);</span>
    }
<span class="fc" id="L1561">  }</span>

  /**
   * Collapse multiword preposition of the following format:
   * prep|advmod|dep|amod(gov, mwp0) dep(mpw0,mwp1) pobj|pcomp(mwp1, compl) or
   * pobj|pcomp(mwp0, compl) -&amp;gt; prep_mwp0_mwp1(gov, compl)
   * &lt;p/&gt;
   *
   * @param list List of typedDependencies to work on,
   * @param newTypedDeps List of typedDependencies that we construct
   * @param str_mwp0 First part of the multiword preposition to construct the collapsed
   *          preposition
   * @param str_mwp1 Second part of the multiword preposition to construct the
   *          collapsed preposition
   * @param w_mwp0 First part of the multiword preposition that we look for
   * @param w_mwp1 Second part of the multiword preposition that we look for
   */
  private static void collapseMultiWordPrep(Collection&lt;TypedDependency&gt; list, Collection&lt;TypedDependency&gt; newTypedDeps, String str_mwp0, String str_mwp1, String w_mwp0, String w_mwp1) {

    // first find the multiword_preposition: dep(mpw[0], mwp[1])
    // the two words should be next to another in the sentence (difference of
    // indexes = 1)
<span class="fc" id="L1583">    IndexedWord mwp0 = null;</span>
<span class="fc" id="L1584">    IndexedWord mwp1 = null;</span>
<span class="fc" id="L1585">    TypedDependency dep = null;</span>
<span class="fc bfc" id="L1586" title="All 2 branches covered.">    for (TypedDependency td : list) {</span>
<span class="pc bpc" id="L1587" title="3 of 6 branches missed.">      if (td.gov().value().equalsIgnoreCase(w_mwp0) &amp;&amp; td.dep().value().equalsIgnoreCase(w_mwp1) &amp;&amp; Math.abs(td.gov().index() - td.dep().index()) == 1) {</span>
<span class="nc" id="L1588">        mwp0 = td.gov();</span>
<span class="nc" id="L1589">        mwp1 = td.dep();</span>
<span class="nc" id="L1590">        dep = td;</span>
      }
<span class="fc" id="L1592">    }</span>

<span class="pc bpc" id="L1594" title="1 of 2 branches missed.">    if (mwp0 == null) {</span>
<span class="fc" id="L1595">      return;</span>
    }

    // now search for prep|advmod|dep|amod(gov, mwp0)
<span class="nc" id="L1599">    IndexedWord governor = null;</span>
<span class="nc" id="L1600">    TypedDependency prep = null;</span>
<span class="nc bnc" id="L1601" title="All 2 branches missed.">    for (TypedDependency td1 : list) {</span>
<span class="nc bnc" id="L1602" title="All 12 branches missed.">      if ((td1.reln() == PREPOSITIONAL_MODIFIER || td1.reln() == ADVERBIAL_MODIFIER || td1.reln() == ADJECTIVAL_MODIFIER || td1.reln() == DEPENDENT || td1.reln() == MULTI_WORD_EXPRESSION) &amp;&amp; td1.dep().equals(mwp0)) {</span>
        // we found prep|advmod|dep|amod(gov, mwp0)
<span class="nc" id="L1604">        prep = td1;</span>
<span class="nc" id="L1605">        governor = prep.gov();</span>
      }
<span class="nc" id="L1607">    }</span>

<span class="nc bnc" id="L1609" title="All 2 branches missed.">    if (prep == null) {</span>
<span class="nc" id="L1610">      return;</span>
    }

    // search for the complement: pobj|pcomp(mwp1,X)
    // or for pobj|pcomp(mwp0,X)
    // There may be more than one in weird constructions; if there are several,
    // take the one with the LOWEST index!
<span class="nc" id="L1617">    TypedDependency pobj = null;</span>
<span class="nc" id="L1618">    TypedDependency newtd = null;</span>
<span class="nc bnc" id="L1619" title="All 2 branches missed.">    for (TypedDependency td2 : list) {</span>
<span class="nc bnc" id="L1620" title="All 8 branches missed.">      if ((td2.reln() == PREPOSITIONAL_OBJECT || td2.reln() == PREPOSITIONAL_COMPLEMENT) &amp;&amp; (td2.gov().equals(mwp1) || td2.gov().equals(mwp0))) {</span>
<span class="nc bnc" id="L1621" title="All 4 branches missed.">        if (pobj == null || pobj.dep().index() &gt; td2.dep().index()) {</span>
<span class="nc" id="L1622">          pobj = td2;</span>
          // create the new gr relation
          GrammaticalRelation gr;
<span class="nc bnc" id="L1625" title="All 2 branches missed.">          if (td2.reln() == PREPOSITIONAL_COMPLEMENT) {</span>
<span class="nc" id="L1626">            gr = EnglishGrammaticalRelations.getPrepC(str_mwp0 + '_' + str_mwp1);</span>
          } else {
<span class="nc" id="L1628">            gr = EnglishGrammaticalRelations.getPrep(str_mwp0 + '_' + str_mwp1);</span>
          }
<span class="nc bnc" id="L1630" title="All 2 branches missed.">          if (governor != null) {</span>
<span class="nc" id="L1631">            newtd = new TypedDependency(gr, governor, pobj.dep());</span>
          }
        }
      }
<span class="nc" id="L1635">    }</span>

<span class="nc bnc" id="L1637" title="All 4 branches missed.">    if (pobj == null || newtd == null) {</span>
<span class="nc" id="L1638">      return;</span>
    }

    // only if we found the three parts, set to KILL and remove
    // and add the new one
    // Necessarily from the above: prep != null, dep != null, pobj != null, newtd != null

<span class="nc bnc" id="L1645" title="All 2 branches missed.">    if (DEBUG) {</span>
<span class="nc" id="L1646">      log.info(&quot;Removing &quot; + prep + &quot;, &quot; + dep + &quot;, and &quot; + pobj);</span>
<span class="nc" id="L1647">      log.info(&quot;  and adding &quot; + newtd);</span>
    }
<span class="nc" id="L1649">    prep.setReln(KILL);</span>
<span class="nc" id="L1650">    dep.setReln(KILL);</span>
<span class="nc" id="L1651">    pobj.setReln(KILL);</span>
<span class="nc" id="L1652">    newTypedDeps.add(newtd);</span>

    // now remove typed dependencies with reln &quot;kill&quot;
    // and promote possible orphans
<span class="nc bnc" id="L1656" title="All 2 branches missed.">    for (TypedDependency td1 : list) {</span>
<span class="nc bnc" id="L1657" title="All 2 branches missed.">      if (td1.reln() != KILL) {</span>
<span class="nc bnc" id="L1658" title="All 4 branches missed.">        if (td1.gov().equals(mwp0) || td1.gov().equals(mwp1)) {</span>
          // CDM: Thought of adding this in Jan 2010, but it causes
          // conflicting relations tmod vs. pobj. Needs more thought
          // maybe restrict pobj to first NP in PP, and allow tmod for a later
          // one?
<span class="nc bnc" id="L1663" title="All 2 branches missed.">          if (td1.reln() == TEMPORAL_MODIFIER) {</span>
            // special case when an extra NP-TMP is buried in a PP for
            // &quot;during the same period last year&quot;
<span class="nc" id="L1666">            td1.setGov(pobj.dep());</span>
          } else {
<span class="nc" id="L1668">            td1.setGov(governor);</span>
          }
        }
<span class="nc bnc" id="L1671" title="All 2 branches missed.">        if (!newTypedDeps.contains(td1)) {</span>
<span class="nc" id="L1672">          newTypedDeps.add(td1);</span>
        }
      }
<span class="nc" id="L1675">    }</span>
<span class="nc" id="L1676">    list.clear();</span>
<span class="nc" id="L1677">    list.addAll(newTypedDeps);</span>
<span class="nc" id="L1678">  }</span>

  /**
   * Collapse multi-words preposition of the following format: advmod|prt(gov,
   * mwp[0]) prep(gov,mwp[1]) pobj|pcomp(mwp[1], compl) -&amp;gt;
   * prep_mwp[0]_mwp[1](gov, compl)
   * &lt;p/&gt;
   *
   * @param list
   *          List of typedDependencies to work on
   */
  private static void collapse2WPbis(Collection&lt;TypedDependency&gt; list) {
<span class="fc" id="L1690">    Collection&lt;TypedDependency&gt; newTypedDeps = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L1692" title="All 2 branches covered.">    for (String[] mwp : MULTIWORD_PREPS) {</span>
<span class="fc" id="L1693">      newTypedDeps.clear();</span>

<span class="fc" id="L1695">      IndexedWord mwp0 = null;</span>
<span class="fc" id="L1696">      IndexedWord mwp1 = null;</span>
<span class="fc" id="L1697">      IndexedWord governor = null;</span>

<span class="fc" id="L1699">      TypedDependency prep = null;</span>
<span class="fc" id="L1700">      TypedDependency dep = null;</span>
<span class="fc" id="L1701">      TypedDependency pobj = null;</span>
<span class="fc" id="L1702">      TypedDependency newtd = null;</span>

      // first find the first part of the multi_preposition: advmod|prt(gov, mwp[0])

<span class="fc bfc" id="L1706" title="All 2 branches covered.">      for (TypedDependency td : list) {</span>
<span class="pc bpc" id="L1707" title="3 of 10 branches missed.">        if (td.dep().value().equalsIgnoreCase(mwp[0]) &amp;&amp; (td.reln() == PHRASAL_VERB_PARTICLE || td.reln() == ADVERBIAL_MODIFIER || td.reln() == DEPENDENT || td.reln() == MULTI_WORD_EXPRESSION)) {</span>
          // we found advmod(gov, mwp0) or prt(gov, mwp0)
<span class="fc" id="L1709">          governor = td.gov();</span>
<span class="fc" id="L1710">          mwp0 = td.dep();</span>
<span class="fc" id="L1711">          dep = td;</span>
        }
<span class="fc" id="L1713">      }</span>

      // now search for the second part: prep(gov, mwp1)
      // the two words in the mwp should be next to another in the sentence
      // (difference of indexes = 1)

<span class="pc bpc" id="L1719" title="1 of 4 branches missed.">      if (mwp0 == null || governor == null) {</span>
<span class="nc" id="L1720">        continue;</span>
      }

<span class="fc bfc" id="L1723" title="All 2 branches covered.">      for (TypedDependency td1 : list) {</span>
<span class="pc bpc" id="L1724" title="5 of 8 branches missed.">        if (td1.reln() == PREPOSITIONAL_MODIFIER &amp;&amp; td1.dep().value().equalsIgnoreCase(mwp[1]) &amp;&amp; Math.abs(td1.dep().index() - mwp0.index()) == 1 &amp;&amp; td1.gov().equals(governor)) {// we</span>
          // found
          // prep(gov,
          // mwp1)
<span class="nc" id="L1728">          mwp1 = td1.dep();</span>
<span class="nc" id="L1729">          prep = td1;</span>
        }
<span class="fc" id="L1731">      }</span>

<span class="pc bpc" id="L1733" title="1 of 2 branches missed.">      if (mwp1 == null) {</span>
<span class="fc" id="L1734">        continue;</span>
      }

      // search for the complement: pobj|pcomp(mwp1,X)
<span class="nc bnc" id="L1738" title="All 2 branches missed.">      for (TypedDependency td2 : list) {</span>
<span class="nc bnc" id="L1739" title="All 4 branches missed.">        if (td2.reln() == PREPOSITIONAL_OBJECT &amp;&amp; td2.gov().equals(mwp1)) {</span>
<span class="nc" id="L1740">          pobj = td2;</span>
          // create the new gr relation
<span class="nc" id="L1742">          GrammaticalRelation gr = EnglishGrammaticalRelations.getPrep(mwp[0] + '_' + mwp[1]);</span>
<span class="nc" id="L1743">          newtd = new TypedDependency(gr, governor, pobj.dep());</span>
        }
<span class="nc bnc" id="L1745" title="All 4 branches missed.">        if (td2.reln() == PREPOSITIONAL_COMPLEMENT &amp;&amp; td2.gov().equals(mwp1)) {</span>
<span class="nc" id="L1746">          pobj = td2;</span>
          // create the new gr relation
<span class="nc" id="L1748">          GrammaticalRelation gr = EnglishGrammaticalRelations.getPrepC(mwp[0] + '_' + mwp[1]);</span>
<span class="nc" id="L1749">          newtd = new TypedDependency(gr, governor, pobj.dep());</span>
        }
<span class="nc" id="L1751">      }</span>

<span class="nc bnc" id="L1753" title="All 2 branches missed.">      if (pobj == null) {</span>
<span class="nc" id="L1754">        return;</span>
      }

      // only if we found the three parts, set to KILL and remove
      // and add the new one
      // now prep != null, pobj != null and newtd != null

<span class="nc" id="L1761">      prep.setReln(KILL);</span>
<span class="nc" id="L1762">      dep.setReln(KILL);</span>
<span class="nc" id="L1763">      pobj.setReln(KILL);</span>
<span class="nc" id="L1764">      newTypedDeps.add(newtd);</span>

      // now remove typed dependencies with reln &quot;kill&quot;
      // and promote possible orphans
<span class="nc bnc" id="L1768" title="All 2 branches missed.">      for (TypedDependency td1 : list) {</span>
<span class="nc bnc" id="L1769" title="All 2 branches missed.">        if (td1.reln() != KILL) {</span>
<span class="nc bnc" id="L1770" title="All 4 branches missed.">          if (td1.gov().equals(mwp0) || td1.gov().equals(mwp1)) {</span>
<span class="nc" id="L1771">            td1.setGov(governor);</span>
          }
<span class="nc bnc" id="L1773" title="All 2 branches missed.">          if (!newTypedDeps.contains(td1)) {</span>
<span class="nc" id="L1774">            newTypedDeps.add(td1);</span>
          }
        }
<span class="nc" id="L1777">      }</span>
<span class="nc" id="L1778">      list.clear();</span>
<span class="nc" id="L1779">      list.addAll(newTypedDeps);</span>
    }
<span class="fc" id="L1781">  }</span>

  /**
   * Collapse 3-word preposition of the following format: &lt;br/&gt;
   * This will be the case when the preposition is analyzed as a NP &lt;br/&gt;
   * prep(gov, mwp0) &lt;br/&gt;
   * X(mwp0,mwp1) &lt;br/&gt;
   * X(mwp1,mwp2) &lt;br/&gt;
   * pobj|pcomp(mwp2, compl) &lt;br/&gt;
   * -&amp;gt; prep_mwp[0]_mwp[1]_mwp[2](gov, compl)
   * &lt;p/&gt;
   *
   * It also takes flat annotation into account: &lt;br/&gt;
   * prep(gov,mwp0) &lt;br/&gt;
   * X(mwp0,mwp1) &lt;br/&gt;
   * X(mwp0,mwp2) &lt;br/&gt;
   * pobj|pcomp(mwp0, compl) &lt;br/&gt;
   * -&amp;gt; prep_mwp[0]_mwp[1]_mwp[2](gov, compl)
   * &lt;p/&gt;
   *
   *
   * @param list List of typedDependencies to work on
   */
  private static void collapse3WP(Collection&lt;TypedDependency&gt; list) {
<span class="fc" id="L1805">    Collection&lt;TypedDependency&gt; newTypedDeps = new ArrayList&lt;&gt;();</span>

    // first, loop over the prepositions for NP annotation
<span class="fc bfc" id="L1808" title="All 2 branches covered.">    for (String[] mwp : THREEWORD_PREPS) {</span>
<span class="fc" id="L1809">      newTypedDeps.clear();</span>

<span class="fc" id="L1811">      IndexedWord mwp0 = null;</span>
<span class="fc" id="L1812">      IndexedWord mwp1 = null;</span>
<span class="fc" id="L1813">      IndexedWord mwp2 = null;</span>

<span class="fc" id="L1815">      TypedDependency dep1 = null;</span>
<span class="fc" id="L1816">      TypedDependency dep2 = null;</span>

      // first find the first part of the 3word preposition: dep(mpw[0], mwp[1])
      // the two words should be next to another in the sentence (difference of
      // indexes = 1)

<span class="fc bfc" id="L1822" title="All 2 branches covered.">      for (TypedDependency td : list) {</span>
<span class="pc bpc" id="L1823" title="3 of 6 branches missed.">        if (td.gov().value().equalsIgnoreCase(mwp[0]) &amp;&amp; td.dep().value().equalsIgnoreCase(mwp[1]) &amp;&amp; Math.abs(td.gov().index() - td.dep().index()) == 1) {</span>
<span class="nc" id="L1824">          mwp0 = td.gov();</span>
<span class="nc" id="L1825">          mwp1 = td.dep();</span>
<span class="nc" id="L1826">          dep1 = td;</span>
        }
<span class="fc" id="L1828">      }</span>

      // find the second part of the 3word preposition: dep(mpw[1], mwp[2])
      // the two words should be next to another in the sentence (difference of
      // indexes = 1)

<span class="fc bfc" id="L1834" title="All 2 branches covered.">      for (TypedDependency td : list) {</span>
<span class="pc bpc" id="L1835" title="5 of 6 branches missed.">        if (td.gov().equals(mwp1) &amp;&amp; td.dep().value().equalsIgnoreCase(mwp[2]) &amp;&amp; Math.abs(td.gov().index() - td.dep().index()) == 1) {</span>
<span class="nc" id="L1836">          mwp2 = td.dep();</span>
<span class="nc" id="L1837">          dep2 = td;</span>
        }
<span class="fc" id="L1839">      }</span>

<span class="pc bpc" id="L1841" title="3 of 4 branches missed.">      if (dep1 != null &amp;&amp; dep2 != null) {</span>

        // now search for prep(gov, mwp0)
<span class="nc" id="L1844">        IndexedWord governor = null;</span>
<span class="nc" id="L1845">        TypedDependency prep = null;</span>
<span class="nc bnc" id="L1846" title="All 2 branches missed.">        for (TypedDependency td1 : list) {</span>
<span class="nc bnc" id="L1847" title="All 4 branches missed.">          if (td1.reln() == PREPOSITIONAL_MODIFIER &amp;&amp; td1.dep().equals(mwp0)) {// we</span>
            // found
            // prep(gov,
            // mwp0)
<span class="nc" id="L1851">            prep = td1;</span>
<span class="nc" id="L1852">            governor = prep.gov();</span>
          }
<span class="nc" id="L1854">        }</span>

        // search for the complement: pobj|pcomp(mwp2,X)

<span class="nc" id="L1858">        TypedDependency pobj = null;</span>
<span class="nc" id="L1859">        TypedDependency newtd = null;</span>
<span class="nc bnc" id="L1860" title="All 2 branches missed.">        for (TypedDependency td2 : list) {</span>
<span class="nc bnc" id="L1861" title="All 4 branches missed.">          if (td2.reln() == PREPOSITIONAL_OBJECT &amp;&amp; td2.gov().equals(mwp2)) {</span>
<span class="nc" id="L1862">            pobj = td2;</span>
            // create the new gr relation
<span class="nc" id="L1864">            GrammaticalRelation gr = EnglishGrammaticalRelations.getPrep(mwp[0] + '_' + mwp[1] + '_' + mwp[2]);</span>
<span class="nc bnc" id="L1865" title="All 2 branches missed.">            if (governor != null) {</span>
<span class="nc" id="L1866">              newtd = new TypedDependency(gr, governor, pobj.dep());</span>
            }
          }
<span class="nc bnc" id="L1869" title="All 4 branches missed.">          if (td2.reln() == PREPOSITIONAL_COMPLEMENT &amp;&amp; td2.gov().equals(mwp2)) {</span>
<span class="nc" id="L1870">            pobj = td2;</span>
            // create the new gr relation
<span class="nc" id="L1872">            GrammaticalRelation gr = EnglishGrammaticalRelations.getPrepC(mwp[0] + '_' + mwp[1] + '_' + mwp[2]);</span>
<span class="nc bnc" id="L1873" title="All 2 branches missed.">            if (governor != null) {</span>
<span class="nc" id="L1874">              newtd = new TypedDependency(gr, governor, pobj.dep());</span>
            }
          }
<span class="nc" id="L1877">        }</span>

        // only if we found the governor and complement parts, set to KILL and
        // remove
        // and add the new one
<span class="nc bnc" id="L1882" title="All 6 branches missed.">        if (prep != null &amp;&amp; pobj != null &amp;&amp; newtd != null) {</span>
<span class="nc" id="L1883">          prep.setReln(KILL);</span>
<span class="nc" id="L1884">          dep1.setReln(KILL);</span>
<span class="nc" id="L1885">          dep2.setReln(KILL);</span>
<span class="nc" id="L1886">          pobj.setReln(KILL);</span>
<span class="nc" id="L1887">          newTypedDeps.add(newtd);</span>

          // now remove typed dependencies with reln &quot;kill&quot;
          // and promote possible orphans
<span class="nc bnc" id="L1891" title="All 2 branches missed.">          for (TypedDependency td1 : list) {</span>
<span class="nc bnc" id="L1892" title="All 2 branches missed.">            if (td1.reln() != KILL) {</span>
<span class="nc bnc" id="L1893" title="All 6 branches missed.">              if (td1.gov().equals(mwp0) || td1.gov().equals(mwp1) || td1.gov().equals(mwp2)) {</span>
<span class="nc" id="L1894">                td1.setGov(governor);</span>
              }
<span class="nc bnc" id="L1896" title="All 2 branches missed.">              if (!newTypedDeps.contains(td1)) {</span>
<span class="nc" id="L1897">                newTypedDeps.add(td1);</span>
              }
            }
<span class="nc" id="L1900">          }</span>
<span class="nc" id="L1901">          list.clear();</span>
<span class="nc" id="L1902">          list.addAll(newTypedDeps);</span>
        }
      }
    }

    // second, loop again looking at flat annotation
<span class="fc bfc" id="L1908" title="All 2 branches covered.">    for (String[] mwp : THREEWORD_PREPS) {</span>
<span class="fc" id="L1909">      newTypedDeps.clear();</span>

<span class="fc" id="L1911">      IndexedWord mwp0 = null;</span>
<span class="fc" id="L1912">      IndexedWord mwp1 = null;</span>
<span class="fc" id="L1913">      IndexedWord mwp2 = null;</span>

<span class="fc" id="L1915">      TypedDependency dep1 = null;</span>
<span class="fc" id="L1916">      TypedDependency dep2 = null;</span>

      // first find the first part of the 3word preposition: dep(mpw[0], mwp[1])
      // the two words should be next to another in the sentence (difference of
      // indexes = 1)
<span class="fc bfc" id="L1921" title="All 2 branches covered.">      for (TypedDependency td : list) {</span>
<span class="pc bpc" id="L1922" title="3 of 6 branches missed.">        if (td.gov().value().equalsIgnoreCase(mwp[0]) &amp;&amp; td.dep().value().equalsIgnoreCase(mwp[1]) &amp;&amp; Math.abs(td.gov().index() - td.dep().index()) == 1) {</span>
<span class="nc" id="L1923">          mwp0 = td.gov();</span>
<span class="nc" id="L1924">          mwp1 = td.dep();</span>
<span class="nc" id="L1925">          dep1 = td;</span>
        }
<span class="fc" id="L1927">      }</span>

      // find the second part of the 3word preposition: dep(mpw[0], mwp[2])
      // the two words should be one word apart in the sentence (difference of
      // indexes = 2)
<span class="fc bfc" id="L1932" title="All 2 branches covered.">      for (TypedDependency td : list) {</span>
<span class="pc bpc" id="L1933" title="5 of 6 branches missed.">        if (td.gov().equals(mwp0) &amp;&amp; td.dep().value().equalsIgnoreCase(mwp[2]) &amp;&amp; Math.abs(td.gov().index() - td.dep().index()) == 2) {</span>
<span class="nc" id="L1934">          mwp2 = td.dep();</span>
<span class="nc" id="L1935">          dep2 = td;</span>
        }
<span class="fc" id="L1937">      }</span>

<span class="pc bpc" id="L1939" title="3 of 4 branches missed.">      if (dep1 != null &amp;&amp; dep2 != null) {</span>

        // now search for prep(gov, mwp0)
<span class="nc" id="L1942">        IndexedWord governor = null;</span>
<span class="nc" id="L1943">        TypedDependency prep = null;</span>
<span class="nc bnc" id="L1944" title="All 2 branches missed.">        for (TypedDependency td1 : list) {</span>
<span class="nc bnc" id="L1945" title="All 4 branches missed.">          if (td1.dep().equals(mwp0) &amp;&amp; td1.reln() == PREPOSITIONAL_MODIFIER) {// we</span>
            // found
            // prep(gov,
            // mwp0)
<span class="nc" id="L1949">            prep = td1;</span>
<span class="nc" id="L1950">            governor = prep.gov();</span>
          }
<span class="nc" id="L1952">        }</span>

        // search for the complement: pobj|pcomp(mwp0,X)

<span class="nc" id="L1956">        TypedDependency pobj = null;</span>
<span class="nc" id="L1957">        TypedDependency newtd = null;</span>
<span class="nc bnc" id="L1958" title="All 2 branches missed.">        for (TypedDependency td2 : list) {</span>
<span class="nc bnc" id="L1959" title="All 4 branches missed.">          if (td2.gov().equals(mwp0) &amp;&amp; td2.reln() == PREPOSITIONAL_OBJECT) {</span>
<span class="nc" id="L1960">            pobj = td2;</span>
            // create the new gr relation
<span class="nc" id="L1962">            GrammaticalRelation gr = EnglishGrammaticalRelations.getPrep(mwp[0] + '_' + mwp[1] + '_' + mwp[2]);</span>
<span class="nc bnc" id="L1963" title="All 2 branches missed.">            if (governor != null) {</span>
<span class="nc" id="L1964">              newtd = new TypedDependency(gr, governor, pobj.dep());</span>
            }
          }
<span class="nc bnc" id="L1967" title="All 4 branches missed.">          if (td2.gov().equals(mwp0) &amp;&amp; td2.reln() == PREPOSITIONAL_COMPLEMENT) {</span>
<span class="nc" id="L1968">            pobj = td2;</span>
            // create the new gr relation
<span class="nc" id="L1970">            GrammaticalRelation gr = EnglishGrammaticalRelations.getPrepC(mwp[0] + '_' + mwp[1] + '_' + mwp[2]);</span>
<span class="nc bnc" id="L1971" title="All 2 branches missed.">            if (governor != null) {</span>
<span class="nc" id="L1972">              newtd = new TypedDependency(gr, governor, pobj.dep());</span>
            }
          }
<span class="nc" id="L1975">        }</span>

        // only if we found the governor and complement parts, set to KILL and
        // remove
        // and add the new one
<span class="nc bnc" id="L1980" title="All 6 branches missed.">        if (prep != null &amp;&amp; pobj != null &amp;&amp; newtd != null) {</span>
<span class="nc" id="L1981">          prep.setReln(KILL);</span>
<span class="nc" id="L1982">          dep1.setReln(KILL);</span>
<span class="nc" id="L1983">          dep2.setReln(KILL);</span>
<span class="nc" id="L1984">          pobj.setReln(KILL);</span>
<span class="nc" id="L1985">          newTypedDeps.add(newtd);</span>

          // now remove typed dependencies with reln &quot;kill&quot;
          // and promote possible orphans
<span class="nc bnc" id="L1989" title="All 2 branches missed.">          for (TypedDependency td1 : list) {</span>
<span class="nc bnc" id="L1990" title="All 2 branches missed.">            if (td1.reln() != KILL) {</span>
<span class="nc bnc" id="L1991" title="All 6 branches missed.">              if (td1.gov().equals(mwp0) || td1.gov().equals(mwp1) || td1.gov().equals(mwp2)) {</span>
<span class="nc" id="L1992">                td1.setGov(governor);</span>
              }
<span class="nc bnc" id="L1994" title="All 2 branches missed.">              if (!newTypedDeps.contains(td1)) {</span>
<span class="nc" id="L1995">                newTypedDeps.add(td1);</span>
              }
            }
<span class="nc" id="L1998">          }</span>
<span class="nc" id="L1999">          list.clear();</span>
<span class="nc" id="L2000">          list.addAll(newTypedDeps);</span>
        }
      }
    }
<span class="fc" id="L2004">  }</span>

  /*
   *
   * While upgrading, here are some lists of common multiword prepositions which
   * we might try to cover better. (Also do corpus counts for same?)
   *
   * (Prague Dependency Treebank) as per CRIT except for RESTR but for RESTR
   * apart from RESTR away from RESTR aside from RESTR as from TSIN ahead of
   * TWHEN back of LOC, DIR3 exclusive of* RESTR instead of SUBS outside of LOC,
   * DIR3 off of DIR1 upwards of LOC, DIR3 as of TSIN because of CAUS inside of
   * LOC, DIR3 irrespective of REG out of LOC, DIR1 regardless of REG according
   * to CRIT due to CAUS next to LOC, RESTR owing to* CAUS preparatory to* TWHEN
   * prior to* TWHEN subsequent to* TWHEN as to/for REG contrary to* CPR close
   * to* LOC, EXT (except the case named in the next table) near to LOC, DIR3
   * nearer to LOC, DIR3 preliminary to* TWHEN previous to* TWHEN pursuant to*
   * CRIT thanks to CAUS along with ACMP together with ACMP devoid of* ACMP void
   * of* ACMP
   *
   * http://www.keepandshare.com/doc/view.php?u=13166
   *
   * according to ahead of as far as as well as by means of due to far from in
   * addition to in case of in front of in place of in spite of inside of
   * instead of in to (into) near to next to on account of on behalf of on top
   * of on to (onto) out of outside of owing to prior to with regards to
   *
   * www.eslmonkeys.com/book/learner/prepositions.pdf According to Ahead of
   * Along with Apart from As for As to Aside from Because of But for Contrary
   * to Except for Instead of Next to Out of Prior to Thanks to
   */

  /**
   * Collapse multi-words preposition of the following format, which comes from
   * flat annotation. This handles e.g., &quot;because of&quot; (PP (IN because) (IN of)
   * ...), &quot;such as&quot; (PP (JJ such) (IN as) ...)
   * &lt;p/&gt;
   * prep(gov, mwp[1]) dep(mpw[1], mwp[0]) pobj(mwp[1], compl) -&amp;gt;
   * prep_mwp[0]_mwp[1](gov, compl)
   *
   * @param list List of typedDependencies to work on
   */
  private static void collapseFlatMWP(Collection&lt;TypedDependency&gt; list) {
<span class="fc" id="L2046">    Collection&lt;TypedDependency&gt; newTypedDeps = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L2048" title="All 2 branches covered.">    for (String[] mwp : MULTIWORD_PREPS) {</span>
<span class="fc" id="L2049">      newTypedDeps.clear();</span>

<span class="fc" id="L2051">      IndexedWord mwp1 = null;</span>
<span class="fc" id="L2052">      IndexedWord governor = null;</span>

<span class="fc" id="L2054">      TypedDependency prep = null;</span>
<span class="fc" id="L2055">      TypedDependency dep = null;</span>
<span class="fc" id="L2056">      TypedDependency pobj = null;</span>

      // first find the multi_preposition: dep(mpw[1], mwp[0])
<span class="fc bfc" id="L2059" title="All 2 branches covered.">      for (TypedDependency td : list) {</span>
<span class="pc bpc" id="L2060" title="1 of 6 branches missed.">        if (Math.abs(td.gov().index() - td.dep().index()) == 1 &amp;&amp; td.gov().value().equalsIgnoreCase(mwp[1]) &amp;&amp; td.dep().value().equalsIgnoreCase(mwp[0])) {</span>
<span class="nc" id="L2061">          mwp1 = td.gov();</span>
<span class="nc" id="L2062">          dep = td;</span>
        }
<span class="fc" id="L2064">      }</span>

<span class="pc bpc" id="L2066" title="1 of 2 branches missed.">      if (mwp1 == null) {</span>
<span class="fc" id="L2067">        continue;</span>
      }

      // now search for prep(gov, mwp1)
<span class="nc bnc" id="L2071" title="All 2 branches missed.">      for (TypedDependency td1 : list) {</span>
<span class="nc bnc" id="L2072" title="All 4 branches missed.">        if (td1.dep().equals(mwp1) &amp;&amp; td1.reln() == PREPOSITIONAL_MODIFIER) {</span>
          // we found prep(gov, mwp1)
<span class="nc" id="L2074">          prep = td1;</span>
<span class="nc" id="L2075">          governor = prep.gov();</span>
        }
<span class="nc" id="L2077">      }</span>

<span class="nc bnc" id="L2079" title="All 2 branches missed.">      if (prep == null) {</span>
<span class="nc" id="L2080">        continue;</span>
      }

      // search for the complement: pobj|pcomp(mwp1,X)
<span class="nc bnc" id="L2084" title="All 2 branches missed.">      for (TypedDependency td2 : list) {</span>
<span class="nc bnc" id="L2085" title="All 4 branches missed.">        if (td2.gov().equals(mwp1) &amp;&amp; td2.reln() == PREPOSITIONAL_OBJECT) {</span>
<span class="nc" id="L2086">          pobj = td2;</span>
          // create the new gr relation
<span class="nc" id="L2088">          GrammaticalRelation gr = EnglishGrammaticalRelations.getPrep(mwp[0] + '_' + mwp[1]);</span>
<span class="nc" id="L2089">          newTypedDeps.add(new TypedDependency(gr, governor, pobj.dep()));</span>
        }
<span class="nc bnc" id="L2091" title="All 4 branches missed.">        if (td2.gov().equals(mwp1) &amp;&amp; td2.reln() == PREPOSITIONAL_COMPLEMENT) {</span>
<span class="nc" id="L2092">          pobj = td2;</span>
          // create the new gr relation
<span class="nc" id="L2094">          GrammaticalRelation gr = EnglishGrammaticalRelations.getPrepC(mwp[0] + '_' + mwp[1]);</span>
<span class="nc" id="L2095">          newTypedDeps.add(new TypedDependency(gr, governor, pobj.dep()));</span>
        }
<span class="nc" id="L2097">      }</span>

<span class="nc bnc" id="L2099" title="All 2 branches missed.">      if (pobj == null) {</span>
<span class="nc" id="L2100">        return;</span>
      }
      // only if we found the three parts, set to KILL and remove
      // we know prep != null &amp;&amp; dep != null &amp;&amp; dep != null
<span class="nc" id="L2104">      prep.setReln(KILL);</span>
<span class="nc" id="L2105">      dep.setReln(KILL);</span>
<span class="nc" id="L2106">      pobj.setReln(KILL);</span>

      // now remove typed dependencies with reln &quot;kill&quot;
      // and promote possible orphans
<span class="nc bnc" id="L2110" title="All 2 branches missed.">      for (TypedDependency td1 : list) {</span>
<span class="nc bnc" id="L2111" title="All 2 branches missed.">        if (td1.reln() != KILL) {</span>
<span class="nc bnc" id="L2112" title="All 2 branches missed.">          if (td1.gov().equals(mwp1)) {</span>
<span class="nc" id="L2113">            td1.setGov(governor);</span>
          }
<span class="nc bnc" id="L2115" title="All 2 branches missed.">          if (!newTypedDeps.contains(td1)) {</span>
<span class="nc" id="L2116">            newTypedDeps.add(td1);</span>
          }
        }
<span class="nc" id="L2119">      }</span>
<span class="nc" id="L2120">      list.clear();</span>
<span class="nc" id="L2121">      list.addAll(newTypedDeps);</span>
    }
<span class="fc" id="L2123">  }</span>

  /**
   * This method gets rid of multiwords in conjunctions to avoid having them
   * creating disconnected constituents e.g.,
   * &quot;bread-1 as-2 well-3 as-4 cheese-5&quot; will be turned into conj_and(bread,
   * cheese) and then dep(well-3, as-2) and dep(well-3, as-4) cannot be attached
   * to the graph, these dependencies are erased
   *
   * @param list List of words to get rid of multiword conjunctions from
   */
  private static void eraseMultiConj(Collection&lt;TypedDependency&gt; list) {
    // find typed deps of form cc(gov, x)
<span class="fc bfc" id="L2136" title="All 2 branches covered.">    for (TypedDependency td1 : list) {</span>
<span class="fc bfc" id="L2137" title="All 2 branches covered.">      if (td1.reln() == COORDINATION) {</span>
<span class="fc" id="L2138">        IndexedWord x = td1.dep();</span>
        // find typed deps of form dep(x,y) and kill them
<span class="fc bfc" id="L2140" title="All 2 branches covered.">        for (TypedDependency td2 : list) {</span>
<span class="pc bpc" id="L2141" title="1 of 8 branches missed.">          if (td2.gov().equals(x) &amp;&amp; (td2.reln() == DEPENDENT || td2.reln() == MULTI_WORD_EXPRESSION || td2.reln() == COORDINATION ||</span>
<span class="pc bpc" id="L2142" title="1 of 6 branches missed.">                  td2.reln() == ADVERBIAL_MODIFIER || td2.reln() == NEGATION_MODIFIER || td2.reln() == AUX_MODIFIER)) {</span>
<span class="fc" id="L2143">            td2.setReln(KILL);</span>
          }
<span class="fc" id="L2145">        }</span>
      }
<span class="fc" id="L2147">    }</span>

<span class="fc" id="L2149">    filterKill(list);</span>
<span class="fc" id="L2150">  }</span>

  /**
   * Remove duplicate relations: it can happen when collapsing stranded
   * prepositions. E.g., &quot;What does CPR stand for?&quot; we get dep(stand, what), and
   * after collapsing we also get prep_for(stand, what).
   *
   * @param list A list of typed dependencies to check through
   */
  private static void removeDep(Collection&lt;TypedDependency&gt; list) {
<span class="fc" id="L2160">    Set&lt;GrammaticalRelation&gt; prepRels = Generics.newHashSet(EnglishGrammaticalRelations.getPreps());</span>
<span class="fc" id="L2161">    prepRels.addAll(EnglishGrammaticalRelations.getPrepsC());</span>
<span class="fc bfc" id="L2162" title="All 2 branches covered.">    for (TypedDependency td1 : list) {</span>
<span class="fc bfc" id="L2163" title="All 2 branches covered.">      if (prepRels.contains(td1.reln())) { // if we have a prep_ relation</span>
<span class="fc" id="L2164">        IndexedWord gov = td1.gov();</span>
<span class="fc" id="L2165">        IndexedWord dep = td1.dep();</span>

<span class="fc bfc" id="L2167" title="All 2 branches covered.">        for (TypedDependency td2 : list) {</span>
<span class="pc bpc" id="L2168" title="3 of 6 branches missed.">          if (td2.reln() == DEPENDENT &amp;&amp; td2.gov().equals(gov) &amp;&amp; td2.dep().equals(dep)) {</span>
<span class="nc" id="L2169">            td2.setReln(KILL);</span>
          }
<span class="fc" id="L2171">        }</span>
      }
<span class="fc" id="L2173">    }</span>

    // now remove typed dependencies with reln &quot;kill&quot;
<span class="fc bfc" id="L2176" title="All 2 branches covered.">    for (Iterator&lt;TypedDependency&gt; iter = list.iterator(); iter.hasNext();) {</span>
<span class="fc" id="L2177">      TypedDependency td = iter.next();</span>
<span class="pc bpc" id="L2178" title="1 of 2 branches missed.">      if (td.reln() == KILL) {</span>
<span class="nc bnc" id="L2179" title="All 2 branches missed.">        if (DEBUG) {</span>
<span class="nc" id="L2180">          log.info(&quot;Removing duplicate relation: &quot; + td);</span>
        }
<span class="nc" id="L2182">        iter.remove();</span>
      }
<span class="fc" id="L2184">    }</span>
<span class="fc" id="L2185">  }</span>

  /**
   * Find and remove any exact duplicates from a dependency list.
   * For example, the method that &quot;corrects&quot; nsubj dependencies can
   * turn them into nsubjpass dependencies.  If there is some other
   * source of nsubjpass dependencies, there may now be multiple
   * copies of the nsubjpass dependency.  If the containing data type
   * is a List, they may both now be in the List.
   */
  private static void removeExactDuplicates(Collection&lt;TypedDependency&gt; list) {
<span class="fc" id="L2196">    Set&lt;TypedDependency&gt; set = new TreeSet&lt;&gt;(list);</span>
<span class="fc" id="L2197">    list.clear();</span>
<span class="fc" id="L2198">    list.addAll(set);</span>
<span class="fc" id="L2199">  }</span>


  public static List&lt;GrammaticalStructure&gt; readCoNLLXGrammaticalStructureCollection(String fileName) throws IOException {
<span class="nc" id="L2203">    return readCoNLLXGrammaticalStructureCollection(fileName, EnglishGrammaticalRelations.shortNameToGRel, new FromDependenciesFactory());</span>
  }

  public static EnglishGrammaticalStructure buildCoNLLXGrammaticalStructure(List&lt;List&lt;String&gt;&gt; tokenFields) {
<span class="nc" id="L2207">    return (EnglishGrammaticalStructure) buildCoNLLXGrammaticalStructure(tokenFields, EnglishGrammaticalRelations.shortNameToGRel, new FromDependenciesFactory());</span>
  }

<span class="nc" id="L2210">  public static class FromDependenciesFactory</span>
    implements GrammaticalStructureFromDependenciesFactory {
    @Override
    public EnglishGrammaticalStructure build(List&lt;TypedDependency&gt; tdeps, TreeGraphNode root) {
<span class="nc" id="L2214">      return new EnglishGrammaticalStructure(tdeps, root);</span>
    }
  }

  public static void main(String[] args) {
<span class="nc" id="L2219">    GrammaticalStructureConversionUtils.convertTrees(args, &quot;en-sd&quot;);</span>
<span class="nc" id="L2220">  }</span>

} // end class EnglishGrammaticalStructure
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>