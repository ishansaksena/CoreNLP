<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ConstantsAndVariables.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.patterns</a> &gt; <span class="el_source">ConstantsAndVariables.java</span></div><h1>ConstantsAndVariables.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.patterns;

import java.io.File;
import java.io.IOException;
import java.io.Serializable;
import java.lang.reflect.Field;
import java.util.*;
import java.util.Map.Entry;
import java.util.concurrent.ConcurrentHashMap;
import java.util.regex.Pattern;

import edu.stanford.nlp.io.IOUtils;
import edu.stanford.nlp.ling.CoreAnnotations;
import edu.stanford.nlp.ling.tokensregex.Env;
import edu.stanford.nlp.ling.tokensregex.NodePattern;
import edu.stanford.nlp.ling.tokensregex.TokenSequencePattern;
import edu.stanford.nlp.patterns.GetPatternsFromDataMultiClass.PatternScoring;
import edu.stanford.nlp.patterns.GetPatternsFromDataMultiClass.WordScoring;
import edu.stanford.nlp.patterns.dep.DepPatternFactory;
import edu.stanford.nlp.patterns.surface.SurfacePatternFactory;
import edu.stanford.nlp.process.WordShapeClassifier;
import edu.stanford.nlp.stats.ClassicCounter;
import edu.stanford.nlp.stats.Counter;
import edu.stanford.nlp.stats.Counters;
import edu.stanford.nlp.util.*;
import edu.stanford.nlp.util.ArgumentParser.Option;
import edu.stanford.nlp.util.TypesafeMap.Key;
import edu.stanford.nlp.util.logging.Redwood;

import javax.json.Json;
import javax.json.JsonArrayBuilder;
import javax.json.JsonObjectBuilder;

<span class="pc bpc" id="L34" title="1 of 2 branches missed.">public class ConstantsAndVariables implements Serializable {</span>

  private static final long serialVersionUID = 1L;

  /**
   * Maximum number of iterations to run
   */
<span class="pc" id="L41">  @Option(name = &quot;numIterationsForPatterns&quot;)</span>
<span class="pc" id="L42">  public Integer numIterationsForPatterns = 10;</span>

  /**
   * Maximum number of patterns learned in each iteration
   */
<span class="pc" id="L47">  @Option(name = &quot;numPatterns&quot;)</span>
  public int numPatterns = 10;

  /**
   * The output directory where the justifications of learning patterns and
   * phrases would be saved. These are needed for visualization
   */
<span class="pc" id="L54">  @Option(name = &quot;outDir&quot;)</span>
  public String outDir = null;

  /**
   * Cached file of all patterns for all tokens
   */
<span class="pc" id="L60">  @Option(name = &quot;allPatternsDir&quot;)</span>
  public String allPatternsDir = null;

  /**
   * If all patterns should be computed. Otherwise patterns are read from
   * allPatternsFile
   */
<span class="pc" id="L67">  @Option(name = &quot;computeAllPatterns&quot;)</span>
  public boolean computeAllPatterns = true;

  // @Option(name = &quot;removeRedundantPatterns&quot;)
  // public boolean removeRedundantPatterns = true;

  /**
   * Pattern Scoring mechanism. See {@link PatternScoring} for options.
   */
<span class="pc" id="L76">  @Option(name = &quot;patternScoring&quot;)</span>
  public PatternScoring patternScoring = PatternScoring.PosNegUnlabOdds;

  /**
   * Threshold for learning a pattern
   */
<span class="pc" id="L82">  @Option(name = &quot;thresholdSelectPattern&quot;)</span>
  public double thresholdSelectPattern = 1.0;

//  /**
//   * Do not learn patterns that do not extract any unlabeled tokens (kind of
//   * useless)
//   */
//  @Option(name = &quot;discardPatternsWithNoUnlabSupport&quot;)
//  public boolean discardPatternsWithNoUnlabSupport = true;

  /**
   * Currently, does not work correctly. TODO: make this work. Ideally this
   * would label words only when they occur in the context of any learned
   * pattern. This comment seems old. Test it!
   */
<span class="pc" id="L97">  @Option(name = &quot;restrictToMatched&quot;)</span>
  public boolean restrictToMatched = false;

  /**
   * Label words that are learned so that in further iterations we have more
   * information
   */
<span class="pc" id="L104">  @Option(name = &quot;usePatternResultAsLabel&quot;)</span>
  public boolean usePatternResultAsLabel = true;

  /**
   * Debug flag for learning patterns. 0 means no output, 1 means necessary output, 2 means necessary output+some justification, 3 means extreme debug output
   */
<span class="pc" id="L110">  @Option(name = &quot;debug&quot;)</span>
  public int debug = 1;

  /**
   * Do not learn patterns in which the neighboring words have the same label.
   * Deprecated!
   */
  //@Option(name = &quot;ignorePatWithLabeledNeigh&quot;)
  //public boolean ignorePatWithLabeledNeigh = false;

  /**
   * Save this run as ...
   */
<span class="pc" id="L123">  @Option(name = &quot;identifier&quot;)</span>
  public String identifier = &quot;getpatterns&quot;;

  /**
   * Use the actual dictionary matching phrase(s) instead of the token word or
   * lemma in calculating the stats
   */
<span class="pc" id="L130">  @Option(name = &quot;useMatchingPhrase&quot;)</span>
  public boolean useMatchingPhrase = true;

  /**
   * Reduce pattern threshold (=0.8*current_value) to extract as many patterns
   * as possible (still restricted by &lt;code&gt;numPatterns&lt;/code&gt;)
   */
<span class="pc" id="L137">  @Option(name = &quot;tuneThresholdKeepRunning&quot;)</span>
  public boolean tuneThresholdKeepRunning = false;

  /**
   * Maximum number of words to learn
   */
<span class="pc" id="L143">  @Option(name = &quot;maxExtractNumWords&quot;)</span>
  public int maxExtractNumWords = Integer.MAX_VALUE;

  /**
   * use the seed dictionaries and the new words learned for the other labels in
   * the previous iterations as negative
   */
<span class="pc" id="L150">  @Option(name = &quot;useOtherLabelsWordsasNegative&quot;)</span>
  public boolean useOtherLabelsWordsasNegative = true;

  /**
   * If not null, write the output like
   * &quot;w1 w2 &lt;label1&gt; w3 &lt;label2&gt;w4&lt;/label2&gt; &lt;/label1&gt; w5 ... &quot; if w3 w4 have
   * label1 and w4 has label 2
   */
<span class="pc" id="L158">  @Option(name = &quot;markedOutputTextFile&quot;)</span>
  String markedOutputTextFile = null;

  /**
   * If you want output of form &quot;word\tlabels-separated-by-comma&quot; in newlines
   */
<span class="pc" id="L164">  @Option(name=&quot;columnOutputFile&quot;)</span>
  String columnOutputFile = null;


  /**
   * Lowercase the context words/lemmas
   */
  @Option(name = &quot;matchLowerCaseContext&quot;)
<span class="fc" id="L172">  public static boolean matchLowerCaseContext = true;</span>


  /**
   * Initials of all POS tags to use if
   * &lt;code&gt;usePOS4Pattern&lt;/code&gt; is true, separated by comma.
   */
<span class="pc" id="L179">  @Option(name = &quot;targetAllowedTagsInitialsStr&quot;)</span>
  public String targetAllowedTagsInitialsStr = null;

<span class="pc" id="L182">  public Map&lt;String, Set&lt;String&gt;&gt; allowedTagsInitials = null;</span>

  /**
   * Allowed NERs for labels. Format is label1,NER1,NER11;label2,NER2,NER21,NER22;label3,...
   * &lt;code&gt;useTargetNERRestriction&lt;/code&gt; flag should be true
   */
<span class="pc" id="L188">  @Option(name = &quot;targetAllowedNERs&quot;)</span>
  public String targetAllowedNERs = null;


<span class="pc" id="L192">  public Map&lt;String, Set&lt;String&gt;&gt; allowedNERsforLabels = null;</span>

  /**
   * Number of words to learn in each iteration
   */
<span class="pc" id="L197">  @Option(name = &quot;numWordsToAdd&quot;)</span>
  public int numWordsToAdd = 10;


<span class="pc" id="L201">  @Option(name = &quot;thresholdNumPatternsApplied&quot;)</span>
  public double thresholdNumPatternsApplied = 2;

<span class="pc" id="L204">  @Option(name = &quot;wordScoring&quot;)</span>
  public WordScoring wordScoring = WordScoring.WEIGHTEDNORM;

<span class="pc" id="L207">  @Option(name = &quot;thresholdWordExtract&quot;)</span>
  public double thresholdWordExtract = 0.2;

<span class="pc" id="L210">  public boolean justify = false;</span>

  /**
   * Sigma for L2 regularization in Logisitic regression, if a classifier is
   * used to score phrases
   */
<span class="pc" id="L216">  @Option(name = &quot;LRSigma&quot;)</span>
  public double LRSigma = 1.0;

  /**
   * English words that are not labeled when labeling using seed dictionaries
   */
<span class="pc" id="L222">  @Option(name = &quot;englishWordsFiles&quot;)</span>
  public String englishWordsFiles = null;

<span class="pc" id="L225">  private Set&lt;String&gt; englishWords = new HashSet&lt;&gt;();</span>

  /**
   * Words to be ignored when learning phrases if
   * &lt;code&gt;removePhrasesWithStopWords&lt;/code&gt; or
   * &lt;code&gt;removeStopWordsFromSelectedPhrases&lt;/code&gt; is true. Also, these words
   * are considered negative when scoring a pattern (similar to
   * othersemanticclasses).
   */
<span class="pc" id="L234">  @Option(name = &quot;commonWordsPatternFiles&quot;)</span>
  public String commonWordsPatternFiles = null;

<span class="pc" id="L237">  private Set&lt;String&gt; commonEngWords = null;</span>

  /**
   * List of dictionary phrases that are negative for all labels to be learned.
   * Format is file_1,file_2,... where file_i has each phrase in a different
   * line
   *
   */
<span class="pc" id="L245">  @Option(name = &quot;otherSemanticClassesFiles&quot;)</span>
  public String otherSemanticClassesFiles = null;

  // set of words that are considered negative for all classes
<span class="pc" id="L249">  private Set&lt;CandidatePhrase&gt; otherSemanticClassesWords = null;</span>

  /**
   * Seed dictionary, set in the class that uses this class
   */
<span class="pc" id="L254">  private Map&lt;String, Set&lt;CandidatePhrase&gt;&gt; seedLabelDictionary = new HashMap&lt;&gt;();</span>

  /**
   * Just the set of labels
   */
<span class="pc" id="L259">  private Set&lt;String&gt; labels = new HashSet&lt;&gt;();</span>


<span class="pc" id="L262">  private Map&lt;String, Class&lt;? extends TypesafeMap.Key&lt;String&gt;&gt;&gt; answerClass = null;</span>


  /**
   * Can be used only when using the API - using the appropriate constructor.
   * Tokens with specified classes set (has to be boolean return value, even
   * though this variable says object) will be ignored.
   */
<span class="pc" id="L270">  @SuppressWarnings(&quot;rawtypes&quot;)</span>
  private Map&lt;String, Map&lt;Class, Object&gt;&gt; ignoreWordswithClassesDuringSelection = null;

  /**
   * These classes will be generalized. It can only be used via the API using
   * the appropriate constructor. All label classes are by default generalized.
   */
  @SuppressWarnings(&quot;rawtypes&quot;)
<span class="fc" id="L278">  private static Map&lt;String, Class&gt; generalizeClasses = new HashMap&lt;&gt;();</span>

  /**
   * Minimum length of words that can be matched fuzzily
   */
<span class="pc" id="L283">  @Option(name = &quot;minLen4FuzzyForPattern&quot;)</span>
  public int minLen4FuzzyForPattern = 6;

  /**
   * Do not learn phrases that match this regex.
   */
<span class="pc" id="L289">  @Option(name = &quot;wordIgnoreRegex&quot;)</span>
  public String wordIgnoreRegex = &quot;[^a-zA-Z]*&quot;;

  /**
   * Number of threads
   */
<span class="pc" id="L295">  @Option(name = &quot;numThreads&quot;)</span>
  public int numThreads = 1;

  /**
   * Words that are not learned. Patterns are not created around these words.
   * And, if useStopWordsBeforeTerm in {@link edu.stanford.nlp.patterns.surface.CreatePatterns} is true.
   */
<span class="pc" id="L302">  @Option(name = &quot;stopWordsPatternFiles&quot;, gloss = &quot;stop words&quot;)</span>
  public String stopWordsPatternFiles = null;

<span class="fc" id="L305">  private static Set&lt;CandidatePhrase&gt; stopWords = null;</span>



  /**
   * Environment for {@link TokenSequencePattern}
   */
<span class="pc" id="L312">  public Map&lt;String, Env&gt; env = new HashMap&lt;&gt;();</span>

<span class="fc" id="L314">  public static Env globalEnv = TokenSequencePattern.getNewEnv();</span>


  /**
   *
   */
<span class="pc" id="L320">  @Option(name = &quot;removeStopWordsFromSelectedPhrases&quot;)</span>
  public boolean removeStopWordsFromSelectedPhrases = false;

  /**
   *
   */
<span class="pc" id="L326">  @Option(name = &quot;removePhrasesWithStopWords&quot;)</span>
  public boolean removePhrasesWithStopWords = false;

<span class="pc" id="L329">  private boolean alreadySetUp = false;</span>

  /**
   * Cluster file, in which each line is word/phrase&lt;tab&gt;clusterid
   */
<span class="pc" id="L334">  @Option(name = &quot;wordClassClusterFile&quot;)</span>
  String wordClassClusterFile = null;

<span class="pc" id="L337">  private Map&lt;String, Integer&gt; wordClassClusters = new HashMap&lt;&gt;();</span>

  /**
   * General cluster file, if you wanna use it somehow, in which each line is
   * word/phrase&lt;tab&gt;clusterid
   */
<span class="pc" id="L343">  @Option(name = &quot;generalWordClassClusterFile&quot;)</span>
  String generalWordClassClusterFile = null;

<span class="pc" id="L346">  private Map&lt;String, Integer&gt; generalWordClassClusters = null;</span>

//  @Option(name = &quot;includeExternalFeatures&quot;)
//  public boolean includeExternalFeatures = false;

<span class="pc" id="L351">  @Option(name = &quot;externalFeatureWeightsFile&quot;)</span>
  public String externalFeatureWeightsDir = null;

<span class="pc" id="L354">  @Option(name = &quot;doNotApplyPatterns&quot;)</span>
  public boolean doNotApplyPatterns = false;


  /**
   * If score for a pattern is square rooted
   */
<span class="pc" id="L361">  @Option(name = &quot;sqrtPatScore&quot;)</span>
  public boolean sqrtPatScore = false;

  /**
   * Remove patterns that have number of unlabeled words is less than this.
   */
<span class="pc" id="L367">  @Option(name = &quot;minUnlabPhraseSupportForPat&quot;)</span>
  public int minUnlabPhraseSupportForPat = 0;

  /**
   * Remove patterns that have number of positive words less than this.
   */
<span class="pc" id="L373">  @Option(name = &quot;minPosPhraseSupportForPat&quot;)</span>
  public int minPosPhraseSupportForPat = 1;

  /**
   * For example, if positive seed dict contains &quot;cancer&quot; and &quot;breast cancer&quot; then &quot;breast&quot; is included as negative
   */
<span class="pc" id="L379">  @Option(name=&quot;addIndvWordsFromPhrasesExceptLastAsNeg&quot;)</span>
  public boolean addIndvWordsFromPhrasesExceptLastAsNeg = false;

  /**
   * Cached files
   */
<span class="pc" id="L385">  private ConcurrentHashMap&lt;String, Double&gt; editDistanceFromEnglishWords = new ConcurrentHashMap&lt;&gt;();</span>
  /**
   * Cached files
   */
<span class="pc" id="L389">  private ConcurrentHashMap&lt;String, String&gt; editDistanceFromEnglishWordsMatches = new ConcurrentHashMap&lt;&gt;();</span>
  /**
   * Cached files
   */
<span class="pc" id="L393">  private ConcurrentHashMap&lt;String, Double&gt; editDistanceFromOtherSemanticClasses = new ConcurrentHashMap&lt;&gt;();</span>
  /**
   * Cached files
   */
<span class="pc" id="L397">  private ConcurrentHashMap&lt;String, String&gt; editDistanceFromOtherSemanticClassesMatches = new ConcurrentHashMap&lt;&gt;();</span>
  /**
   * Cached files
   */
<span class="pc" id="L401">  private ConcurrentHashMap&lt;String, Double&gt; editDistanceFromThisClass = new ConcurrentHashMap&lt;&gt;();</span>
  /**
   * Cached files
   */
<span class="pc" id="L405">  private ConcurrentHashMap&lt;String, String&gt; editDistanceFromThisClassMatches = new ConcurrentHashMap&lt;&gt;();</span>

<span class="pc" id="L407">  private ConcurrentHashMap&lt;String, Counter&lt;String&gt;&gt; wordShapesForLabels = new ConcurrentHashMap&lt;&gt;();</span>



<span class="pc" id="L411">  String channelNameLogger = &quot;settingUp&quot;;</span>

<span class="pc" id="L413">  public Map&lt;String, Counter&lt;Integer&gt;&gt; distSimWeights = new HashMap&lt;&gt;();</span>
<span class="pc" id="L414">  public Map&lt;String, Counter&lt;CandidatePhrase&gt;&gt; dictOddsWeights = new HashMap&lt;&gt;();</span>

<span class="pc" id="L416">  @Option(name=&quot;invertedIndexClass&quot;, gloss=&quot;another option is Lucene backed, which is not included in the CoreNLP release. Contact us to get a copy (distributed under Apache License).&quot;)</span>
  public Class&lt;? extends SentenceIndex&gt; invertedIndexClass = InvertedIndexByTokens.class;

  /**
   * Where the inverted index (either in memory or lucene) is stored
   */
  @Option(name=&quot;invertedIndexDirectory&quot;)
  public String invertedIndexDirectory;

<span class="pc" id="L425">  @Option(name=&quot;clubNeighboringLabeledWords&quot;)</span>
  public boolean clubNeighboringLabeledWords = false;

<span class="pc" id="L428">  @Option(name=&quot;patternType&quot;)</span>
  public PatternFactory.PatternType patternType = PatternFactory.PatternType.SURFACE;

<span class="pc" id="L431">  @Option(name=&quot;subsampleUnkAsNegUsingSim&quot;, gloss=&quot;When learning a classifier, remove phrases from unknown phrases that are too close to the positive phrases&quot;)</span>
  public boolean subsampleUnkAsNegUsingSim = false;

//  @Option(name=&quot;subSampleUnkAsNegUsingSimPercentage&quot;, gloss=&quot;When using subsampleUnkAsNegUsingSim, select bottom %&quot;)
//  public double subSampleUnkAsNegUsingSimPercentage = 0.95;

<span class="pc" id="L437">  @Option(name=&quot;expandPositivesWhenSampling&quot;, gloss=&quot;when sampling for learning feature wts for learning phrases, expand the positives&quot;)</span>
  public boolean expandPositivesWhenSampling = false;

<span class="pc" id="L440">  @Option(name=&quot;expandNegativesWhenSampling&quot;, gloss=&quot;when sampling for learning feature wts for learning phrases, expand the negatives&quot;)</span>
  public boolean expandNegativesWhenSampling = false;

<span class="pc" id="L443">  @Option(name=&quot;similarityThresholdHighPrecision&quot;, gloss=&quot;used for expanding positives&quot;)</span>
  public double similarityThresholdHighPrecision  = 0.7;

<span class="pc" id="L446">  @Option(name=&quot;positiveSimilarityThresholdLowPrecision&quot;, gloss=&quot;used for not choosing close unknowns as positives&quot;)</span>
  public double positiveSimilarityThresholdLowPrecision  = 0.5;

//  @Option(name=&quot;subSampleUnkAsPosUsingSimPercentage&quot;, gloss=&quot;When using expandPositivesWhenSampling, select top % after applying the threshold&quot;)
//  public double subSampleUnkAsPosUsingSimPercentage = 0.05;

<span class="pc" id="L452">  @Option(name=&quot;wordVectorFile&quot;, gloss = &quot;if using word vectors for computing similarities&quot;)</span>
  public String wordVectorFile = null;

  @Option(name=&quot;useWordVectorsToComputeSim&quot;, gloss=&quot;use vectors directly instead of word classes for computing similarity&quot;)
  public boolean useWordVectorsToComputeSim;

<span class="pc" id="L458">  @Option(name=&quot;logFileVectorSimilarity&quot;, gloss=&quot;To store vectors for selected/almost-selected positive and negative words&quot;)</span>
  String logFileVectorSimilarity = null;

<span class="pc" id="L461">  @Option(name=&quot;goldEntitiesEvalFiles&quot;, gloss=&quot;label1,gold_list_of_entities_file;label2,...&quot;)</span>
  public String goldEntitiesEvalFiles = null;

<span class="pc" id="L464">  @Option(name=&quot;evaluate&quot;)</span>
  public boolean evaluate = false;

<span class="pc" id="L467">  Map&lt;String, Map&lt;String, Boolean&gt;&gt; goldEntities = new HashMap&lt;&gt;();</span>

<span class="pc" id="L469">  @Option(name=&quot;featureCountThreshold&quot;)</span>
  public int featureCountThreshold = 1;

<span class="pc" id="L472">  @Option(name=&quot;expandPhrasesNumTopSimilar&quot;, gloss=&quot;k in kNN&quot;)</span>
  public int expandPhrasesNumTopSimilar = 1;

  /**
   * Whether to do a fuzzy matching when matching seeds to text. You can tune minLen4FuzzyForPattern parameter.
   */
<span class="pc" id="L478">  @Option(name=&quot;fuzzyMatch&quot;)</span>
  public boolean fuzzyMatch = false;

  /**
   * Ignore case when matching seed words. It's a map so something like {name-&gt;true,place-&gt;false}
   */
<span class="pc" id="L484">  @Option(name=&quot;ignoreCaseSeedMatch&quot;)</span>
  public Map&lt;String, String&gt; ignoreCaseSeedMatch = new HashMap&lt;&gt;();

<span class="pc" id="L487">  @Option(name=&quot;sentsOutFile&quot;)</span>
  public String sentsOutFile = null;

<span class="pc" id="L490">  @Option(name=&quot;savePatternsWordsDir&quot;)</span>
  public boolean savePatternsWordsDir = true;

<span class="pc" id="L493">  @Option(name=&quot;learn&quot;)</span>
  public boolean learn = true;


  public Set&lt;String&gt; getLabels() {
<span class="nc" id="L498">    return labels;</span>
  }

//  public void addLearnedWords(String trainLabel, Counter&lt;CandidatePhrase&gt; identifiedWords) {
//    if(!learnedWords.containsKey(trainLabel))
//      learnedWords.put(trainLabel, new ClassicCounter&lt;CandidatePhrase&gt;());
//    this.learnedWords.get(trainLabel).addAll(identifiedWords);
//  }

  public Map&lt;String, String&gt; getAllOptions() {
<span class="nc" id="L508">    Map&lt;String, String&gt; values = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L509" title="All 2 branches missed.">    if(props != null)</span>
<span class="nc bnc" id="L510" title="All 2 branches missed.">      props.forEach( (x,y) -&gt; values.put(x.toString(),y == null?&quot;null&quot;:y.toString()));</span>

    Class&lt;?&gt; thisClass;
    try {
<span class="nc" id="L514">      thisClass = Class.forName(this.getClass().getName());</span>

<span class="nc" id="L516">      Field[] aClassFields = thisClass.getDeclaredFields();</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">      for(Field f : aClassFields){</span>
<span class="nc bnc" id="L518" title="All 4 branches missed.">        if(f.getType().getClass().isPrimitive() || Arrays.binarySearch(GetPatternsFromDataMultiClass.printOptionClass, f.getType()) &gt;= 0){</span>
<span class="nc" id="L519">          String fName = f.getName();</span>
<span class="nc" id="L520">          Object fvalue = f.get(this);</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">          values.put(fName, fvalue == null ? &quot;null&quot; : fvalue.toString());</span>
        }
      }

<span class="nc" id="L525">    } catch (Exception e) {</span>
<span class="nc" id="L526">      e.printStackTrace();</span>
<span class="nc" id="L527">    }</span>
<span class="nc" id="L528">    return values;</span>
  }

  public boolean hasSeedWordOrOtherSem(CandidatePhrase p) {
<span class="nc bnc" id="L532" title="All 2 branches missed.">    for(Map.Entry&lt;String, Set&lt;CandidatePhrase&gt;&gt; seeds: this.seedLabelDictionary.entrySet()){</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">      if(seeds.getValue().contains(p))</span>
<span class="nc" id="L534">        return true;</span>
<span class="nc" id="L535">    }</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">    if(otherSemanticClassesWords.contains(p))</span>
<span class="nc" id="L537">      return true;</span>
<span class="nc" id="L538">    return false;</span>
  }

  public TreeMap&lt;Integer, Counter&lt;CandidatePhrase&gt;&gt; getLearnedWordsEachIter(String label) {
<span class="nc" id="L542">    return learnedWordsEachIter.get(label);</span>
  }

  public Map&lt;String, TreeMap&lt;Integer, Counter&lt;CandidatePhrase&gt;&gt;&gt;  getLearnedWordsEachIter() {
<span class="nc" id="L546">    return learnedWordsEachIter;</span>
  }

  public void setLearnedWordsEachIter(TreeMap&lt;Integer, Counter&lt;CandidatePhrase&gt;&gt; words, String label) {
<span class="nc" id="L550">    this.learnedWordsEachIter.put(label, words);</span>
<span class="nc" id="L551">  }</span>


  //PatternFactory.PatternType.SURFACE;


//  public PatternIndex getPatternIndex() {
//    return patternIndex;
//  }
//
//  public void setPatternIndex(PatternIndex patternIndex) {
//    this.patternIndex = patternIndex;
//  }


  static public class ScorePhraseMeasures implements Comparable {

        String name;
<span class="nc" id="L569">    static int num = 0;</span>
    int numObj;
<span class="nc" id="L571">    static Map&lt;String, ScorePhraseMeasures&gt; createdObjects = new ConcurrentHashMap&lt;&gt;();</span>

    public static ScorePhraseMeasures create(String n){
<span class="nc bnc" id="L574" title="All 2 branches missed.">      if(createdObjects.containsKey(n))</span>
<span class="nc" id="L575">        return createdObjects.get(n);</span>
      else
<span class="nc" id="L577">        return new ScorePhraseMeasures(n);</span>
    }

<span class="nc" id="L580">    private ScorePhraseMeasures(String n){</span>
<span class="nc" id="L581">      this.name= n;</span>
<span class="nc" id="L582">      numObj = num++;</span>
<span class="nc" id="L583">      createdObjects.put(n, this);</span>
<span class="nc" id="L584">    }</span>

    @Override
<span class="nc" id="L587">    public String toString(){return name;}</span>

    @Override
    public boolean equals(Object o){
<span class="nc bnc" id="L591" title="All 2 branches missed.">      if(! (o instanceof ScorePhraseMeasures)) return false;</span>
<span class="nc bnc" id="L592" title="All 2 branches missed.">      return ((ScorePhraseMeasures)o).numObj == (this.numObj);</span>
    }

<span class="nc" id="L595">    static final ScorePhraseMeasures DISTSIM = new ScorePhraseMeasures(&quot;DistSim&quot;);</span>
<span class="nc" id="L596">    static final ScorePhraseMeasures GOOGLENGRAM = new ScorePhraseMeasures(&quot;GoogleNGram&quot;);</span>
<span class="nc" id="L597">    static final ScorePhraseMeasures PATWTBYFREQ=new ScorePhraseMeasures(&quot;PatWtByFreq&quot;);</span>
<span class="nc" id="L598">    static final ScorePhraseMeasures  EDITDISTSAME=new ScorePhraseMeasures(&quot;EditDistSame&quot;);</span>
<span class="nc" id="L599">    static final ScorePhraseMeasures  EDITDISTOTHER =new ScorePhraseMeasures(&quot;EditDistOther&quot;);</span>
<span class="nc" id="L600">    static final ScorePhraseMeasures  DOMAINNGRAM =new ScorePhraseMeasures(&quot;DomainNgram&quot;);</span>
<span class="nc" id="L601">    static final ScorePhraseMeasures  SEMANTICODDS =new ScorePhraseMeasures(&quot;SemanticOdds&quot;);</span>
<span class="nc" id="L602">    static final ScorePhraseMeasures  WORDSHAPE = new ScorePhraseMeasures(&quot;WordShape&quot;);</span>
<span class="nc" id="L603">    static final ScorePhraseMeasures WORDVECPOSSIMAVG = new ScorePhraseMeasures(&quot;WordVecPosSimAvg&quot;);</span>
<span class="nc" id="L604">    static final ScorePhraseMeasures WORDVECPOSSIMMAX = new ScorePhraseMeasures(&quot;WordVecPosSimMax&quot;);</span>
<span class="nc" id="L605">    static final ScorePhraseMeasures WORDVECNEGSIMAVG = new ScorePhraseMeasures(&quot;WordVecNegSimAvg&quot;);</span>
<span class="nc" id="L606">    static final ScorePhraseMeasures WORDVECNEGSIMMAX = new ScorePhraseMeasures(&quot;WordVecNegSimMax&quot;);</span>
<span class="nc" id="L607">    static final ScorePhraseMeasures ISFIRSTCAPITAL = new ScorePhraseMeasures(&quot;IsFirstLetterCapital&quot;);</span>
<span class="nc" id="L608">    static final ScorePhraseMeasures WORDSHAPESTR = new  ScorePhraseMeasures(&quot;WordShapeStr&quot;);</span>
<span class="nc" id="L609">    static final ScorePhraseMeasures BOW = new ScorePhraseMeasures(&quot;Word&quot;);</span>
    @Override
    public int compareTo(Object o) {
<span class="nc bnc" id="L612" title="All 2 branches missed.">      if(!(o instanceof  ScorePhraseMeasures))</span>
<span class="nc" id="L613">        return -1;</span>
<span class="nc" id="L614">      else return o.toString().compareTo(this.toString());</span>
    }
  }


  /**
   * Keeps only one label for each token, whichever has the longest
   */
<span class="pc" id="L622">  @Option(name=&quot;removeOverLappingLabelsFromSeed&quot;)</span>
  public boolean removeOverLappingLabelsFromSeed = false;

  /**
   * Only works if you have single label. And the word classes are given.
   */
<span class="pc" id="L628">  @Option(name = &quot;usePhraseEvalWordClass&quot;)</span>
  public boolean usePhraseEvalWordClass = false;

  /**
   * Only works if you have single label. And the word vectors are given.
   */
<span class="pc" id="L634">  @Option(name = &quot;usePhraseEvalWordVector&quot;)</span>
  public boolean usePhraseEvalWordVector = false;

  /**
   * use google tf-idf for learning phrases. Need to also provide googleNgram_dbname,
   * googleNgram_username and googleNgram_host
   */
<span class="pc" id="L641">  @Option(name = &quot;usePhraseEvalGoogleNgram&quot;)</span>
  public boolean usePhraseEvalGoogleNgram = false;

  /**
   * use domain tf-idf for learning phrases
   */
<span class="pc" id="L647">  @Option(name = &quot;usePhraseEvalDomainNgram&quot;)</span>
  public boolean usePhraseEvalDomainNgram = false;

  /**
   * use \sum_allpat pattern_wt_that_extracted_phrase/phrase_freq for learning
   * phrases
   */
<span class="pc" id="L654">  @Option(name = &quot;usePhraseEvalPatWtByFreq&quot;)</span>
  public boolean usePhraseEvalPatWtByFreq = true;

  /**
   * odds of the phrase freq in the label dictionary vs other dictionaries
   */
<span class="pc" id="L660">  @Option(name = &quot;usePhraseEvalSemanticOdds&quot;)</span>
  public boolean usePhraseEvalSemanticOdds = false;

  /**
   * Edit distance between this phrase and the other phrases in the label
   * dictionary
   */
<span class="pc" id="L667">  @Option(name = &quot;usePhraseEvalEditDistSame&quot;)</span>
  public boolean usePhraseEvalEditDistSame = false;

  /**
   * Edit distance between this phrase and other phrases in other dictionaries
   */
<span class="pc" id="L673">  @Option(name = &quot;usePhraseEvalEditDistOther&quot;)</span>
  public boolean usePhraseEvalEditDistOther = false;

<span class="pc" id="L676">  @Option(name = &quot;usePhraseEvalWordShape&quot;, gloss=&quot;% of phrases of that label that have the same word shape&quot;)</span>
  public boolean usePhraseEvalWordShape = false;

<span class="pc" id="L679">  @Option(name=&quot;usePhraseEvalWordShapeStr&quot;, gloss=&quot;uses the word shape str as a feature&quot;)</span>
  public boolean usePhraseEvalWordShapeStr = false;

  @Option(name=&quot;usePhraseEvalFirstCapital&quot;, gloss=&quot;words starts with a capital letter&quot;)
  public boolean usePhraseEvalFirstCapital;

  /**
   * use bag of words
   */
<span class="pc" id="L688">  @Option(name=&quot;usePhraseEvalBOW&quot;)</span>
  public boolean usePhraseEvalBOW = false;

  /**
   * Used only if {@link #patternScoring} is &lt;code&gt;PhEvalInPat&lt;/code&gt; or
   * &lt;code&gt;PhEvalInPat&lt;/code&gt;. See usePhrase* for meanings.
   */
<span class="pc" id="L695">  @Option(name = &quot;usePatternEvalWordClass&quot;)</span>
  public boolean usePatternEvalWordClass = false;

  /**
   * Used only if {@link #patternScoring} is &lt;code&gt;PhEvalInPat&lt;/code&gt; or
   * &lt;code&gt;PhEvalInPat&lt;/code&gt;. See usePhrase* for meanings.
   */
<span class="pc" id="L702">  @Option(name = &quot;usePatternEvalWordShape&quot;)</span>
  public boolean usePatternEvalWordShape = false;

<span class="pc" id="L705">  @Option(name=&quot;usePatternEvalWordShapeStr&quot;, gloss=&quot;uses the word shape str as a feature&quot;)</span>
  public boolean usePatternEvalWordShapeStr = false;

  @Option(name=&quot;usePatternEvalFirstCapital&quot;, gloss=&quot;words starts with a capital letter&quot;)
  public boolean usePatternEvalFirstCapital;

  /**
   * Used only if {@link #patternScoring} is &lt;code&gt;PhEvalInPat&lt;/code&gt; or
   * &lt;code&gt;PhEvalInPat&lt;/code&gt;. See usePhrase* for meanings.
   */
<span class="pc" id="L715">  @Option(name = &quot;usePatternEvalGoogleNgram&quot;)</span>
  public boolean usePatternEvalGoogleNgram = false;

  /**
   * Used only if {@link #patternScoring} is &lt;code&gt;PhEvalInPat&lt;/code&gt; or
   * &lt;code&gt;PhEvalInPat&lt;/code&gt;. See usePhrase* for meanings. Need to also provide googleNgram_dbname,
   * googleNgram_username and googleNgram_host
   */
<span class="pc" id="L723">  @Option(name = &quot;usePatternEvalDomainNgram&quot;)</span>
  public boolean usePatternEvalDomainNgram = false;

  /**
   * Used only if {@link #patternScoring} is &lt;code&gt;PhEvalInPat&lt;/code&gt; or
   * &lt;code&gt;PhEvalInPatLogP&lt;/code&gt;. See usePhrase* for meanings.
   */
<span class="pc" id="L730">  @Option(name = &quot;usePatternEvalSemanticOdds&quot;)</span>
  public boolean usePatternEvalSemanticOdds = false;

  /**
   * Used only if {@link #patternScoring} is &lt;code&gt;PhEvalInPat&lt;/code&gt; or
   * &lt;code&gt;PhEvalInPatLogP&lt;/code&gt;. See usePhrase* for meanings.
   */
<span class="pc" id="L737">  @Option(name = &quot;usePatternEvalEditDistSame&quot;)</span>
  public boolean usePatternEvalEditDistSame = false;

  /**
   * Used only if {@link #patternScoring} is &lt;code&gt;PhEvalInPat&lt;/code&gt; or
   * &lt;code&gt;PhEvalInPatLogP&lt;/code&gt;. See usePhrase* for meanings.
   */
<span class="pc" id="L744">  @Option(name = &quot;usePatternEvalEditDistOther&quot;)</span>
  public boolean usePatternEvalEditDistOther = false;

  /**
   * use bag of words
   */
<span class="pc" id="L750">  @Option(name=&quot;usePatternEvalBOW&quot;)</span>
  public boolean usePatternEvalBOW = false;


  /**
   * These are used to learn weights for features if using logistic regression.
   * Percentage of non-labeled tokens selected as negative.
   */
<span class="pc" id="L758">  @Option(name = &quot;perSelectRand&quot;)</span>
  public double perSelectRand = 0.01;

  /**
   * These are used to learn weights for features if using logistic regression.
   * Percentage of negative tokens selected as negative.
   */
<span class="pc" id="L765">  @Option(name = &quot;perSelectNeg&quot;)</span>
  public double perSelectNeg = 1;

  /**
   * Especially useful for multi word phrase extraction. Do not extract a phrase
   * if any word is labeled with any other class.
   */
<span class="pc" id="L772">  @Option(name = &quot;doNotExtractPhraseAnyWordLabeledOtherClass&quot;)</span>
  public boolean doNotExtractPhraseAnyWordLabeledOtherClass = true;

  /**
   * You can save the inverted index. Lucene index is saved by default to &lt;code&gt;invertedIndexDirectory&lt;/code&gt; if given.
   */
<span class="pc" id="L778">  @Option(name=&quot;saveInvertedIndex&quot;)</span>
  public boolean saveInvertedIndex  = false;

  /**
   * You can load the inverted index using this file.
   * If false and using lucene index, the existing directory is deleted and new index is made.
   */
<span class="pc" id="L785">  @Option(name=&quot;loadInvertedIndex&quot;)</span>
  public boolean loadInvertedIndex  = false;


<span class="pc" id="L789">  @Option(name = &quot;storePatsForEachToken&quot;, gloss=&quot;used for storing patterns in PSQL/MEMORY/LUCENE&quot;)</span>
  public PatternForEachTokenWay storePatsForEachToken = PatternForEachTokenWay.MEMORY;
//
//  @Option(name = &quot;storePatsIndex&quot;, gloss=&quot;used for storing patterns index&quot;)
//  public PatternIndexWay storePatsIndex = PatternIndexWay.MEMORY;

<span class="pc" id="L795">  @Option(name=&quot;sampleSentencesForSufficientStats&quot;,gloss=&quot;% sentences to use for learning pattterns&quot; )</span>
  double sampleSentencesForSufficientStats = 1.0;

//  /**
//   * Directory where to save the sentences ser files.
//   */
//  @Option(name=&quot;saveSentencesSerDir&quot;)
//  public File saveSentencesSerDir = null;
//
//  public boolean usingDirForSentsInIndex = false;

  // @Option(name = &quot;wekaOptions&quot;)
  // public String wekaOptions = &quot;&quot;;

<span class="fc" id="L809">  public static String backgroundSymbol = &quot;O&quot;;</span>

<span class="pc" id="L811">  int wordShaper = WordShapeClassifier.WORDSHAPECHRIS2;</span>
<span class="pc" id="L812">  private ConcurrentHashMap&lt;String, String&gt; wordShapeCache = new ConcurrentHashMap&lt;&gt;();</span>

  public SentenceIndex invertedIndex;

<span class="fc" id="L816">  public static String extremedebug = &quot;extremePatDebug&quot;;</span>
<span class="fc" id="L817">  public static String minimaldebug = &quot;minimaldebug&quot;;</span>

  Properties props;

<span class="pc" id="L821">  public enum PatternForEachTokenWay {MEMORY, LUCENE, DB};</span>
<span class="nc" id="L822">  public enum PatternIndexWay {MEMORY, OPENHFT, LUCENE};</span>

<span class="pc" id="L824">  public List&lt;String&gt; functionWords = Arrays.asList(&quot;a&quot;,&quot;an&quot;,&quot;the&quot;,&quot;of&quot;,&quot;at&quot;,&quot;on&quot;,&quot;in&quot;,&quot;he&quot;,&quot;she&quot;,&quot;him&quot;,&quot;her&quot;,&quot;they&quot;,&quot;them&quot;,&quot;and&quot;,&quot;no&quot;,&quot;not&quot;,&quot;nor&quot;,&quot;as&quot;,&quot;do&quot;);</span>

  public ConstantsAndVariables(Properties props, Set&lt;String&gt; labels, Map&lt;String, Class&lt;? extends Key&lt;String&gt;&gt;&gt; answerClass, Map&lt;String, Class&gt; generalizeClasses,
<span class="nc" id="L827">                               Map&lt;String, Map&lt;Class, Object&gt;&gt; ignoreClasses) throws IOException {</span>
<span class="nc" id="L828">    this.labels = labels;</span>
<span class="nc bnc" id="L829" title="All 2 branches missed.">    for(String label: labels){</span>
<span class="nc" id="L830">      this.seedLabelDictionary.put(label, new HashSet&lt;&gt;());</span>
<span class="nc" id="L831">    }</span>
<span class="nc" id="L832">    this.answerClass = answerClass;</span>
<span class="nc" id="L833">    this.generalizeClasses = generalizeClasses;</span>
<span class="nc bnc" id="L834" title="All 2 branches missed.">    if(this.generalizeClasses == null)</span>
<span class="nc" id="L835">      this.generalizeClasses = new HashMap&lt;&gt;();</span>
<span class="nc" id="L836">    this.generalizeClasses.putAll(answerClass);</span>
<span class="nc" id="L837">    this.ignoreWordswithClassesDuringSelection = ignoreClasses;</span>
<span class="nc" id="L838">    setUp(props);</span>
<span class="nc" id="L839">  }</span>

  public ConstantsAndVariables(Properties props, Map&lt;String, Set&lt;CandidatePhrase&gt;&gt; labelDictionary, Map&lt;String, Class&lt;? extends Key&lt;String&gt;&gt;&gt; answerClass, Map&lt;String, Class&gt; generalizeClasses,
<span class="nc" id="L842">                               Map&lt;String, Map&lt;Class, Object&gt;&gt; ignoreClasses) throws IOException {</span>

    //make the list unmodifiable!
<span class="nc bnc" id="L845" title="All 2 branches missed.">    for(Entry&lt;String, Set&lt;CandidatePhrase&gt;&gt; en2: labelDictionary.entrySet()){</span>
<span class="nc" id="L846">      seedLabelDictionary.put(en2.getKey(), Collections.unmodifiableSet(en2.getValue()));</span>
<span class="nc" id="L847">    }</span>

<span class="nc" id="L849">    this.labels = labelDictionary.keySet();</span>
<span class="nc" id="L850">    this.answerClass = answerClass;</span>
<span class="nc" id="L851">    this.generalizeClasses = generalizeClasses;</span>
<span class="nc bnc" id="L852" title="All 2 branches missed.">    if(this.generalizeClasses == null)</span>
<span class="nc" id="L853">      this.generalizeClasses = new HashMap&lt;&gt;();</span>
<span class="nc" id="L854">    this.generalizeClasses.putAll(answerClass);</span>
<span class="nc" id="L855">    this.ignoreWordswithClassesDuringSelection = ignoreClasses;</span>
<span class="nc" id="L856">    setUp(props);</span>
<span class="nc" id="L857">  }</span>

<span class="fc" id="L859">  public ConstantsAndVariables(Properties props, Set&lt;String&gt; labels,  Map&lt;String, Class&lt;? extends TypesafeMap.Key&lt;String&gt;&gt;&gt; answerClass) throws IOException {</span>
<span class="fc" id="L860">    this.labels = labels;</span>
<span class="pc bpc" id="L861" title="1 of 2 branches missed.">    for(String label: labels){</span>
<span class="nc" id="L862">      this.seedLabelDictionary.put(label, new HashSet&lt;&gt;());</span>
<span class="nc" id="L863">    }</span>
<span class="fc" id="L864">    this.answerClass = answerClass;</span>
<span class="fc" id="L865">    this.generalizeClasses = new HashMap&lt;&gt;();</span>
<span class="fc" id="L866">    this.generalizeClasses.putAll(answerClass);</span>
<span class="fc" id="L867">    setUp(props);</span>
<span class="fc" id="L868">  }</span>

<span class="nc" id="L870">  public ConstantsAndVariables(Properties props, String label,  Class&lt;? extends TypesafeMap.Key&lt;String&gt;&gt; answerClass) throws IOException {</span>
<span class="nc" id="L871">    this.labels = new HashSet&lt;&gt;();</span>
<span class="nc" id="L872">    this.labels.add(label);</span>
<span class="nc" id="L873">    this.seedLabelDictionary.put(label, new HashSet&lt;&gt;());</span>
<span class="nc" id="L874">    this.answerClass = new HashMap&lt;&gt;();</span>
<span class="nc" id="L875">    this.answerClass.put(label, answerClass);</span>
<span class="nc" id="L876">    this.generalizeClasses = new HashMap&lt;&gt;();</span>
<span class="nc" id="L877">    this.generalizeClasses.putAll(this.answerClass);</span>
<span class="nc" id="L878">    setUp(props);</span>
<span class="nc" id="L879">  }</span>


<span class="nc" id="L882">  public ConstantsAndVariables(Properties props, Set&lt;String&gt; labels,  Map&lt;String, Class&lt;? extends TypesafeMap.Key&lt;String&gt;&gt;&gt; answerClass, Map&lt;String, Class&gt; generalizeClasses) throws IOException {</span>
<span class="nc" id="L883">    this.labels = labels;</span>
<span class="nc bnc" id="L884" title="All 2 branches missed.">    for(String label: labels){</span>
<span class="nc" id="L885">      this.seedLabelDictionary.put(label, new HashSet&lt;&gt;());</span>
<span class="nc" id="L886">    }</span>
<span class="nc" id="L887">    this.answerClass = answerClass;</span>
<span class="nc" id="L888">    this.generalizeClasses = generalizeClasses;</span>
<span class="nc bnc" id="L889" title="All 2 branches missed.">    if(this.generalizeClasses == null)</span>
<span class="nc" id="L890">      this.generalizeClasses = new HashMap&lt;&gt;();</span>
<span class="nc" id="L891">    this.generalizeClasses.putAll(answerClass);</span>
<span class="nc" id="L892">    setUp(props);</span>
<span class="nc" id="L893">  }</span>

  @SuppressWarnings(&quot;rawtypes&quot;)
  public void setUp(Properties props) throws IOException {
<span class="fc bfc" id="L897" title="All 2 branches covered.">    if (alreadySetUp) {</span>
<span class="fc" id="L898">      return;</span>
    }

<span class="fc" id="L901">    Redwood.log(Redwood.DBG, &quot;Setting up ConstantsAndVariables&quot;);</span>

<span class="fc" id="L903">    ArgumentParser.fillOptions(this, props);</span>
<span class="fc" id="L904">    ArgumentParser.fillOptions(PatternFactory.class, props);</span>
<span class="fc" id="L905">    ArgumentParser.fillOptions(SurfacePatternFactory.class, props);</span>
<span class="fc" id="L906">    ArgumentParser.fillOptions(DepPatternFactory.class, props);</span>

<span class="pc bpc" id="L908" title="2 of 4 branches missed.">    if (wordIgnoreRegex != null &amp;&amp; !wordIgnoreRegex.isEmpty()) {</span>
<span class="fc" id="L909">      Redwood.log(Redwood.DBG, &quot;Ignore word regex is &quot; + wordIgnoreRegex);</span>
<span class="fc" id="L910">      PatternFactory.ignoreWordRegex = Pattern.compile(wordIgnoreRegex);</span>
    }

<span class="pc bpc" id="L913" title="1 of 2 branches missed.">    for (String label : labels) {</span>
<span class="nc" id="L914">      env.put(label, TokenSequencePattern.getNewEnv());</span>
      // env.get(label).bind(&quot;answer&quot;, answerClass.get(label));
<span class="nc bnc" id="L916" title="All 2 branches missed.">      for (Entry&lt;String, Class&lt;? extends Key&lt;String&gt;&gt;&gt; en : this.answerClass</span>
<span class="nc" id="L917">          .entrySet()) {</span>
<span class="nc" id="L918">        env.get(label).bind(en.getKey(), en.getValue());</span>
<span class="nc" id="L919">      }</span>
<span class="nc bnc" id="L920" title="All 2 branches missed.">      for (Entry&lt;String, Class&gt; en : generalizeClasses.entrySet())</span>
<span class="nc" id="L921">        env.get(label).bind(en.getKey(), en.getValue());</span>
<span class="nc" id="L922">    }</span>
<span class="fc" id="L923">    Redwood.log(Redwood.DBG, channelNameLogger, &quot;Running with debug output&quot;);</span>
<span class="fc" id="L924">    stopWords = new HashSet&lt;&gt;();</span>

<span class="pc bpc" id="L926" title="1 of 2 branches missed.">    if(stopWordsPatternFiles != null) {</span>
<span class="nc" id="L927">      Redwood.log(ConstantsAndVariables.minimaldebug, channelNameLogger, &quot;Reading stop words from &quot;</span>
        + stopWordsPatternFiles);
<span class="nc bnc" id="L929" title="All 2 branches missed.">      for (String stopwfile : stopWordsPatternFiles.split(&quot;[;,]&quot;))</span>
      {
<span class="nc bnc" id="L931" title="All 2 branches missed.">        for(String word: IOUtils.readLines(stopwfile)){</span>
<span class="nc bnc" id="L932" title="All 2 branches missed.">          if(!word.trim().isEmpty())</span>
<span class="nc" id="L933">            stopWords.add(CandidatePhrase.createOrGet(word.trim()));</span>
<span class="nc" id="L934">        }</span>
      }
    }

<span class="fc" id="L938">    englishWords = new HashSet&lt;&gt;();</span>
<span class="pc bpc" id="L939" title="1 of 2 branches missed.">    if(englishWordsFiles != null) {</span>
<span class="nc" id="L940">      System.out.println(&quot;Reading english words from &quot; + englishWordsFiles);</span>
<span class="nc bnc" id="L941" title="All 2 branches missed.">      for (String englishWordsFile : englishWordsFiles.split(&quot;[;,]&quot;))</span>
<span class="nc" id="L942">        englishWords.addAll(IOUtils.linesFromFile(englishWordsFile));</span>
    }

<span class="pc bpc" id="L945" title="1 of 2 branches missed.">    if (commonWordsPatternFiles != null) {</span>
<span class="nc" id="L946">      commonEngWords = Collections.synchronizedSet(new HashSet&lt;&gt;());</span>
<span class="nc bnc" id="L947" title="All 2 branches missed.">      for (String file : commonWordsPatternFiles.split(&quot;[;,]&quot;))</span>
<span class="nc" id="L948">        commonEngWords.addAll(IOUtils.linesFromFile(file));</span>
    }

<span class="pc bpc" id="L951" title="1 of 2 branches missed.">    if (otherSemanticClassesFiles != null) {</span>
<span class="nc bnc" id="L952" title="All 2 branches missed.">      if (otherSemanticClassesWords == null)</span>
<span class="nc" id="L953">        otherSemanticClassesWords = Collections</span>
<span class="nc" id="L954">            .synchronizedSet(new HashSet&lt;&gt;());</span>
<span class="nc bnc" id="L955" title="All 2 branches missed.">      for (String file : otherSemanticClassesFiles.split(&quot;[;,]&quot;)) {</span>
<span class="nc bnc" id="L956" title="All 2 branches missed.">        for (File f : listFileIncludingItself(file)) {</span>
<span class="nc bnc" id="L957" title="All 2 branches missed.">          for (String w : IOUtils.readLines(f)) {</span>
<span class="nc" id="L958">            String[] t = w.split(&quot;\\s+&quot;);</span>
<span class="nc bnc" id="L959" title="All 2 branches missed.">            if (t.length &lt;= PatternFactory.numWordsCompoundMax)</span>
<span class="nc" id="L960">              otherSemanticClassesWords.add(CandidatePhrase.createOrGet(w));</span>
<span class="nc" id="L961">          }</span>
<span class="nc" id="L962">        }</span>
      }
<span class="nc" id="L964">      System.out.println(&quot;Size of othersemantic class variables is &quot;</span>
<span class="nc" id="L965">        + otherSemanticClassesWords.size());</span>
    } else {
<span class="fc" id="L967">      otherSemanticClassesWords = Collections.synchronizedSet(new HashSet&lt;&gt;());</span>
<span class="fc" id="L968">      System.out.println(&quot;Size of othersemantic class variables is &quot; + 0);</span>
    }

<span class="fc" id="L971">    String stopStr = &quot;/&quot;;</span>
<span class="fc" id="L972">    int i = 0;</span>
<span class="pc bpc" id="L973" title="1 of 2 branches missed.">    for (CandidatePhrase s : stopWords) {</span>
<span class="nc bnc" id="L974" title="All 2 branches missed.">      if (i &gt; 0)</span>
<span class="nc" id="L975">        stopStr += &quot;|&quot;;</span>
<span class="nc" id="L976">      stopStr += Pattern.quote(s.getPhrase().replaceAll(&quot;\\\\&quot;, &quot;\\\\\\\\&quot;));</span>
<span class="nc" id="L977">      i++;</span>
<span class="nc" id="L978">    }</span>
<span class="fc" id="L979">    stopStr += &quot;/&quot;;</span>
<span class="pc bpc" id="L980" title="1 of 2 branches missed.">    for (String label : labels) {</span>
<span class="nc" id="L981">      env.get(label).bind(&quot;$FILLER&quot;,</span>
<span class="nc" id="L982">          &quot;/&quot; + StringUtils.join(PatternFactory.fillerWords, &quot;|&quot;) + &quot;/&quot;);</span>
<span class="nc" id="L983">      env.get(label).bind(&quot;$STOPWORD&quot;, stopStr);</span>
<span class="nc" id="L984">      env.get(label).bind(&quot;$MOD&quot;, &quot;[{tag:/JJ.*/}]&quot;);</span>
<span class="nc bnc" id="L985" title="All 2 branches missed.">      if (matchLowerCaseContext){</span>
<span class="nc" id="L986">        env.get(label).setDefaultStringMatchFlags(NodePattern.CASE_INSENSITIVE);</span>
<span class="nc" id="L987">        env.get(label).setDefaultStringPatternFlags(Pattern.CASE_INSENSITIVE);</span>
      }
<span class="nc" id="L989">      env.get(label).bind(&quot;OTHERSEM&quot;,</span>
          PatternsAnnotations.OtherSemanticLabel.class);
<span class="nc" id="L991">      env.get(label).bind(&quot;grandparentparsetag&quot;, CoreAnnotations.GrandparentAnnotation.class);</span>
<span class="nc" id="L992">    }</span>

<span class="pc bpc" id="L994" title="1 of 2 branches missed.">    if (wordClassClusterFile != null) {</span>
<span class="nc" id="L995">      wordClassClusters = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L996" title="All 2 branches missed.">      for (String line : IOUtils.readLines(wordClassClusterFile)) {</span>
<span class="nc" id="L997">        String[] t = line.split(&quot;\t&quot;);</span>
<span class="nc" id="L998">        wordClassClusters.put(t[0], Integer.parseInt(t[1]));</span>
<span class="nc" id="L999">      }</span>
    }

<span class="pc bpc" id="L1002" title="1 of 2 branches missed.">    if (generalWordClassClusterFile != null) {</span>
<span class="nc" id="L1003">      setGeneralWordClassClusters(new HashMap&lt;&gt;());</span>
<span class="nc bnc" id="L1004" title="All 2 branches missed.">      for (String line : IOUtils.readLines(generalWordClassClusterFile)) {</span>
<span class="nc" id="L1005">        String[] t = line.split(&quot;\t&quot;);</span>
<span class="nc" id="L1006">        getGeneralWordClassClusters().put(t[0], Integer.parseInt(t[1]));</span>
<span class="nc" id="L1007">      }</span>
    }

<span class="pc bpc" id="L1010" title="1 of 2 branches missed.">    if(targetAllowedTagsInitialsStr!= null){</span>
<span class="nc" id="L1011">      allowedTagsInitials = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1012" title="All 2 branches missed.">      for(String labelstr : targetAllowedTagsInitialsStr.split(&quot;;&quot;)){</span>
<span class="nc" id="L1013">        String[] t = labelstr.split(&quot;,&quot;);</span>
<span class="nc" id="L1014">        Set&lt;String&gt; st = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L1015" title="All 2 branches missed.">        for(int j = 1; j &lt; t.length; j++)</span>
<span class="nc" id="L1016">          st.add(t[j]);</span>
<span class="nc" id="L1017">        allowedTagsInitials.put(t[0], st);</span>
      }
    }

<span class="pc bpc" id="L1021" title="3 of 4 branches missed.">    if(PatternFactory.useTargetNERRestriction &amp;&amp; targetAllowedNERs !=null){</span>
<span class="nc" id="L1022">      allowedNERsforLabels = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1023" title="All 2 branches missed.">      for(String labelstr : targetAllowedNERs.split(&quot;;&quot;)){</span>
<span class="nc" id="L1024">        String[] t = labelstr.split(&quot;,&quot;);</span>
<span class="nc" id="L1025">        Set&lt;String&gt; st = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L1026" title="All 2 branches missed.">        for(int j = 1; j &lt; t.length; j++)</span>
<span class="nc" id="L1027">          st.add(t[j]);</span>
<span class="nc" id="L1028">        allowedNERsforLabels.put(t[0], st);</span>

      }
    }

<span class="pc bpc" id="L1033" title="1 of 2 branches missed.">    for(String label: labels){</span>
<span class="nc" id="L1034">      learnedWordsEachIter.put(label, new TreeMap&lt;&gt;());</span>
<span class="nc" id="L1035">    }</span>

<span class="pc bpc" id="L1037" title="2 of 4 branches missed.">   if(usePhraseEvalGoogleNgram || usePatternEvalDomainNgram) {</span>
<span class="nc" id="L1038">     Data.usingGoogleNgram = true;</span>
<span class="nc" id="L1039">     ArgumentParser.fillOptions(GoogleNGramsSQLBacked.class, props);</span>
   }
<span class="pc bpc" id="L1041" title="3 of 4 branches missed.">  if(goldEntitiesEvalFiles !=null &amp;&amp; evaluate)</span>
<span class="nc" id="L1042">    goldEntities = readGoldEntities(goldEntitiesEvalFiles);</span>
<span class="fc" id="L1043">    alreadySetUp = true;</span>
<span class="fc" id="L1044">  }</span>


  public static Iterable&lt;File&gt; listFileIncludingItself(String file) {
<span class="nc" id="L1048">    File f = new File(file);</span>
<span class="nc bnc" id="L1049" title="All 2 branches missed.">    if(!f.isDirectory())</span>
<span class="nc" id="L1050">      return Arrays.asList(f);</span>
<span class="nc" id="L1051">    else return IOUtils.iterFilesRecursive(f);</span>
  }

  // The format of goldEntitiesEvalFiles is assumed same as
  // seedwordsfiles: label,file;label2,file2;...
  // Each file of gold entities consists of each entity in newline with
  // incorrect entities marked with &quot;#&quot; at the end of the entity.
  // Learned entities not present in the gold file are considered
  // negative.
  static Map&lt;String, Map&lt;String, Boolean&gt;&gt; readGoldEntities(String goldEntitiesEvalFiles){
<span class="nc" id="L1061">    Map&lt;String, Map&lt;String, Boolean&gt;&gt; goldWords = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1062" title="All 2 branches missed.">    if (goldEntitiesEvalFiles != null) {</span>
<span class="nc bnc" id="L1063" title="All 2 branches missed.">      for (String gfile : goldEntitiesEvalFiles.split(&quot;;&quot;)) {</span>
<span class="nc" id="L1064">        String[] t = gfile.split(&quot;,&quot;);</span>
<span class="nc" id="L1065">        String label = t[0];</span>
<span class="nc" id="L1066">        String goldfile = t[1];</span>
<span class="nc" id="L1067">        Map&lt;String, Boolean&gt; goldWords4Label = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1068" title="All 2 branches missed.">        for (String line : IOUtils.readLines(goldfile)) {</span>
<span class="nc" id="L1069">          line = line.trim();</span>
<span class="nc bnc" id="L1070" title="All 2 branches missed.">          if (line.isEmpty())</span>
<span class="nc" id="L1071">            continue;</span>

<span class="nc bnc" id="L1073" title="All 2 branches missed.">          if (line.endsWith(&quot;#&quot;))</span>
<span class="nc" id="L1074">            goldWords4Label.put(line.substring(0, line.length() - 1), false);</span>
          else
<span class="nc" id="L1076">            goldWords4Label.put(line, true);</span>
<span class="nc" id="L1077">        }</span>
<span class="nc" id="L1078">        goldWords.put(label, goldWords4Label);</span>
      }
    }
<span class="nc" id="L1081">    return goldWords;</span>
  }


  //streams sents, files-from-which-sents-were read
  static public class DataSentsIterator implements Iterator&lt;Pair&lt;Map&lt;String, DataInstance&gt;, File&gt;&gt; {

<span class="nc" id="L1088">    boolean readInMemory = false;</span>
<span class="nc" id="L1089">    Iterator&lt;File&gt; sentfilesIter = null;</span>
    boolean batchProcessSents;
<span class="nc" id="L1091">    public DataSentsIterator(boolean batchProcessSents){</span>
<span class="nc" id="L1092">      this.batchProcessSents = batchProcessSents;</span>
<span class="nc bnc" id="L1093" title="All 2 branches missed.">      if(batchProcessSents){</span>
<span class="nc" id="L1094">        sentfilesIter = Data.sentsFiles.iterator();</span>
        }

<span class="nc" id="L1097">    }</span>
    @Override
    public boolean hasNext() {
<span class="nc bnc" id="L1100" title="All 2 branches missed.">      if(batchProcessSents){</span>
<span class="nc" id="L1101">       return sentfilesIter.hasNext();</span>
      }else{
<span class="nc bnc" id="L1103" title="All 2 branches missed.">        return !readInMemory;</span>
      }
    }

    @Override
    public Pair&lt;Map&lt;String, DataInstance&gt;, File&gt; next() {
<span class="nc bnc" id="L1109" title="All 2 branches missed.">      if(batchProcessSents){</span>
        try {
<span class="nc" id="L1111">          File f= sentfilesIter.next();</span>
<span class="nc" id="L1112">          return new Pair&lt;&gt;(IOUtils.readObjectFromFile(f), f);</span>
<span class="nc" id="L1113">        } catch (IOException | ClassNotFoundException e) {</span>
<span class="nc" id="L1114">          throw new RuntimeException(e);</span>
        }
      }else{
<span class="nc" id="L1117">        readInMemory= true;</span>
<span class="nc" id="L1118">        return new Pair&lt;&gt;(Data.sents, new File(Data.inMemorySaveFileLocation));</span>
      }
    }
  }

  public Map&lt;String, Counter&lt;String&gt;&gt; getWordShapesForLabels() {
<span class="nc" id="L1124">    return wordShapesForLabels;</span>
  }

//  public void setWordShapesForLabels(ConcurrentHashMap&lt;String, Counter&lt;String&gt;&gt; wordShapesForLabels) {
//    this.wordShapesForLabels = wordShapesForLabels;
//  }
//  public void addGeneralizeClasses(Map&lt;String, Class&gt; gen) {
//    this.generalizeClasses.putAll(gen);
//  }

  public static Map&lt;String, Class&gt; getGeneralizeClasses() {
<span class="nc" id="L1135">    return generalizeClasses;</span>
  }

  public static Set&lt;CandidatePhrase&gt; getStopWords() {
<span class="fc" id="L1139">    return stopWords;</span>
  }

  public void addWordShapes(String label, Set&lt;CandidatePhrase&gt; words){
<span class="nc bnc" id="L1143" title="All 2 branches missed.">    if(!this.wordShapesForLabels.containsKey(label)){</span>
<span class="nc" id="L1144">      this.wordShapesForLabels.put(label, new ClassicCounter&lt;&gt;());</span>
    }
<span class="nc bnc" id="L1146" title="All 2 branches missed.">    for(CandidatePhrase wc: words){</span>
<span class="nc" id="L1147">      String w = wc.getPhrase();</span>
<span class="nc" id="L1148">      String ws = null;</span>
<span class="nc bnc" id="L1149" title="All 2 branches missed.">      if(wordShapeCache.containsKey(w))</span>
<span class="nc" id="L1150">        ws = wordShapeCache.get(w);</span>
      else{
<span class="nc" id="L1152">       ws = WordShapeClassifier.wordShape(w, wordShaper);</span>
<span class="nc" id="L1153">       wordShapeCache.put(w, ws);</span>
      }

<span class="nc" id="L1156">      wordShapesForLabels.get(label).incrementCount(ws);</span>

<span class="nc" id="L1158">    }</span>
<span class="nc" id="L1159">  }</span>

//  public void setSeedLabelDictionary(Map&lt;String, Set&lt;CandidatePhrase&gt;&gt; seedSets) {
//    this.seedLabelDictionary = seedSets;
//
//    if(usePhraseEvalWordShape || usePatternEvalWordShape){
//      this.wordShapesForLabels.clear();
//     for(Entry&lt;String, Set&lt;CandidatePhrase&gt;&gt; en: seedSets.entrySet())
//       addWordShapes(en.getKey(), en.getValue());
//    }
//  }

  public Map&lt;String, Set&lt;CandidatePhrase&gt;&gt; getSeedLabelDictionary() {

<span class="nc" id="L1173">    return this.seedLabelDictionary;</span>
  }


  //Map&lt;String, Counter&lt;CandidatePhrase&gt;&gt; learnedWords = new HashMap&lt;String, Counter&lt;CandidatePhrase&gt;&gt;();
<span class="pc" id="L1178">  Map&lt;String, TreeMap&lt;Integer, Counter&lt;CandidatePhrase&gt;&gt;&gt; learnedWordsEachIter = new HashMap&lt;&gt;();</span>

  public Counter&lt;CandidatePhrase&gt; getLearnedWords(String label) {
<span class="nc" id="L1181">    Counter&lt;CandidatePhrase&gt; learned = Counters.flatten(learnedWordsEachIter.get(label));</span>
<span class="nc bnc" id="L1182" title="All 2 branches missed.">    if(learned == null){</span>
<span class="nc" id="L1183">      learned = new ClassicCounter&lt;&gt;();</span>
<span class="nc" id="L1184">      learnedWordsEachIter.put(label, new TreeMap&lt;&gt;());</span>
    }
<span class="nc" id="L1186">    return learned;</span>
  }

//  public Map&lt;String, Counter&lt;CandidatePhrase&gt;&gt; getLearnedWords() {
//    return Counters.flatten(learnedWordsEachIter);
//  }
  //public void setLearnedWords(Counter&lt;CandidatePhrase&gt; words, String label) {
  //  this.learnedWords.put(label, words);
  //}

  public String getLearnedWordsAsJson(){
<span class="nc" id="L1197">    JsonObjectBuilder obj = Json.createObjectBuilder();</span>
<span class="nc bnc" id="L1198" title="All 2 branches missed.">    for(String label: getLabels()){</span>
<span class="nc" id="L1199">    Counter&lt;CandidatePhrase&gt; learnedWords =  getLearnedWords(label);</span>
<span class="nc" id="L1200">      JsonArrayBuilder arr = Json.createArrayBuilder();</span>
<span class="nc bnc" id="L1201" title="All 2 branches missed.">      for(CandidatePhrase k: learnedWords.keySet())</span>
<span class="nc" id="L1202">        arr.add(k.getPhrase());</span>
<span class="nc" id="L1203">      obj.add(label, arr);</span>
<span class="nc" id="L1204">    }</span>
<span class="nc" id="L1205">    return obj.build().toString();</span>
  }

  public String getLearnedWordsAsJsonLastIteration(){
<span class="nc" id="L1209">    JsonObjectBuilder obj = Json.createObjectBuilder();</span>
<span class="nc bnc" id="L1210" title="All 2 branches missed.">    for(String label: getLabels()){</span>
<span class="nc" id="L1211">      Counter&lt;CandidatePhrase&gt; learnedWords =  getLearnedWordsEachIter(label).lastEntry().getValue();</span>
<span class="nc" id="L1212">      JsonArrayBuilder arr = Json.createArrayBuilder();</span>
<span class="nc bnc" id="L1213" title="All 2 branches missed.">      for(CandidatePhrase k: learnedWords.keySet())</span>
<span class="nc" id="L1214">        arr.add(k.getPhrase());</span>
<span class="nc" id="L1215">      obj.add(label, arr);</span>
<span class="nc" id="L1216">    }</span>
<span class="nc" id="L1217">    return obj.build().toString();</span>
  }

  public String getSetWordsAsJson(Map&lt;String, Counter&lt;CandidatePhrase&gt;&gt; words){
<span class="nc" id="L1221">    JsonObjectBuilder obj = Json.createObjectBuilder();</span>
<span class="nc bnc" id="L1222" title="All 2 branches missed.">    for(String label: getLabels()){</span>
<span class="nc" id="L1223">      JsonArrayBuilder arr = Json.createArrayBuilder();</span>
<span class="nc bnc" id="L1224" title="All 2 branches missed.">      for(CandidatePhrase k: words.get(label).keySet())</span>
<span class="nc" id="L1225">        arr.add(k.getPhrase());</span>
<span class="nc" id="L1226">      obj.add(label, arr);</span>
<span class="nc" id="L1227">    }</span>
<span class="nc" id="L1228">    return obj.build().toString();</span>
  }



  public Set&lt;String&gt; getEnglishWords() {
<span class="nc" id="L1234">    return this.englishWords;</span>
  }

  public Set&lt;String&gt; getCommonEngWords() {
<span class="nc" id="L1238">    return this.commonEngWords;</span>
  }

  public Set&lt;CandidatePhrase&gt; getOtherSemanticClassesWords() {
<span class="nc" id="L1242">    return this.otherSemanticClassesWords;</span>
  }

  public void setOtherSemanticClassesWords(Set&lt;CandidatePhrase&gt; other) {
<span class="nc" id="L1246">    this.otherSemanticClassesWords = other;</span>
<span class="nc" id="L1247">  }</span>

  public Map&lt;String, Integer&gt; getWordClassClusters() {
<span class="nc" id="L1250">    return this.wordClassClusters;</span>
  }

  private Pair&lt;String, Double&gt; getEditDist(Collection&lt;CandidatePhrase&gt; words, String ph) {
<span class="nc" id="L1254">    double minD = editDistMax;</span>
<span class="nc" id="L1255">    String minPh = ph;</span>
<span class="nc bnc" id="L1256" title="All 2 branches missed.">    for (CandidatePhrase ec : words) {</span>
<span class="nc" id="L1257">      String e = ec.getPhrase();</span>
<span class="nc bnc" id="L1258" title="All 2 branches missed.">      if (e.equals(ph))</span>
<span class="nc" id="L1259">        return new Pair&lt;&gt;(ph, 0.0);</span>

<span class="nc" id="L1261">      double d = EditDistanceDamerauLevenshteinLike.editDistance(e, ph, 3);</span>

<span class="nc bnc" id="L1263" title="All 2 branches missed.">      if (d == 1)</span>
<span class="nc" id="L1264">        return new Pair&lt;&gt;(e, d);</span>
<span class="nc bnc" id="L1265" title="All 2 branches missed.">      if (d == -1)</span>
<span class="nc" id="L1266">        d = editDistMax;</span>
<span class="nc bnc" id="L1267" title="All 2 branches missed.">      if (d &lt; minD) {</span>
<span class="nc" id="L1268">        minD = d;</span>
<span class="nc" id="L1269">        minPh = e;</span>
      }
<span class="nc" id="L1271">    }</span>
<span class="nc" id="L1272">    return new Pair&lt;&gt;(minPh, minD);</span>

  }

<span class="pc" id="L1276">  final double editDistMax = 1000;</span>

  /**
   * Use this option if you are limited by memory ; ignored if fileFormat is ser.
   */
<span class="pc" id="L1281">  @Option(name=&quot;batchProcessSents&quot;)</span>
  public boolean batchProcessSents = false;

<span class="pc" id="L1284">  @Option(name=&quot;writeMatchedTokensFiles&quot;)</span>
  public boolean writeMatchedTokensFiles = false;

<span class="pc" id="L1287">  @Option(name=&quot;writeMatchedTokensIdsForEachPhrase&quot;)</span>
  public boolean writeMatchedTokensIdsForEachPhrase = false;

  public Pair&lt;String, Double&gt; getEditDistanceFromThisClass(String label,
      String ph, int minLen) {
<span class="nc bnc" id="L1292" title="All 2 branches missed.">    if (ph.length() &lt; minLen)</span>
<span class="nc" id="L1293">      return new Pair&lt;&gt;(ph, editDistMax);</span>
//    if (editDistanceFromThisClass.containsKey(ph))
//      return new Pair&lt;String, Double&gt;(editDistanceFromThisClassMatches.get(ph),
//          editDistanceFromThisClass.get(ph));

<span class="nc" id="L1298">    Set&lt;CandidatePhrase&gt; words = new HashSet&lt;&gt;(seedLabelDictionary.get(label));</span>
<span class="nc" id="L1299">    words.addAll(getLearnedWords(label).keySet());</span>
<span class="nc" id="L1300">    Pair&lt;String, Double&gt; minD = getEditDist(words, ph);</span>

<span class="nc" id="L1302">    double minDtotal = minD.second();</span>
<span class="nc" id="L1303">    String minPh = minD.first();</span>
<span class="nc bnc" id="L1304" title="All 4 branches missed.">    assert (!minPh.isEmpty());</span>
//    editDistanceFromThisClass.putIfAbsent(ph, minDtotal);
//    editDistanceFromThisClassMatches.putIfAbsent(ph, minPh);
<span class="nc" id="L1307">    return new Pair&lt;&gt;(minPh, minDtotal);</span>
  }

  public Pair&lt;String, Double&gt; getEditDistanceFromOtherClasses(String label, String ph, int minLen) {
<span class="nc bnc" id="L1311" title="All 2 branches missed.">    if (ph.length() &lt; minLen)</span>
<span class="nc" id="L1312">      return new Pair&lt;&gt;(ph, editDistMax);</span>
//    if (editDistanceFromOtherSemanticClasses.containsKey(ph))
//      return new Pair&lt;String, Double&gt;(
//          editDistanceFromOtherSemanticClassesMatches.get(ph),
//          editDistanceFromOtherSemanticClasses.get(ph));

<span class="nc" id="L1318">    Pair&lt;String, Double&gt; minD = getEditDist(otherSemanticClassesWords, ph);</span>
<span class="nc" id="L1319">    String minPh = minD.first();</span>
<span class="nc" id="L1320">    double minDfinal = minD.second();</span>
<span class="nc bnc" id="L1321" title="All 2 branches missed.">    for(String l: labels){</span>
<span class="nc bnc" id="L1322" title="All 2 branches missed.">      if(l.equals(label))</span>
<span class="nc" id="L1323">        continue;</span>
<span class="nc" id="L1324">      Pair&lt;String, Double&gt; editMatch = getEditDistanceFromThisClass(l, ph, minLen);</span>
<span class="nc bnc" id="L1325" title="All 2 branches missed.">      if(editMatch.second() &lt; minDfinal){</span>
<span class="nc" id="L1326">        minDfinal = editMatch.second();</span>
<span class="nc" id="L1327">        minPh = editMatch.first();</span>
      }
<span class="nc" id="L1329">    }</span>
    // double minDtotal = editDistMax;
    // String minPh = &quot;&quot;;
    // if (minD.second() == editDistMax &amp;&amp; ph.contains(&quot; &quot;)) {
    // for (String s : ph.split(&quot;\\s+&quot;)) {
    // Pair&lt;String, Double&gt; minDSingle = getEditDist(otherSemanticClassesWords, s);
    // if (minDSingle.second() &lt; minDtotal) {
    // minDtotal = minDSingle.second;
    // }
    // minPh += &quot; &quot; + minDSingle.first();
    // }
    // minPh = minPh.trim();
    // } else {

    // }
<span class="nc bnc" id="L1344" title="All 4 branches missed.">    assert (!minPh.isEmpty());</span>
//    editDistanceFromOtherSemanticClasses.putIfAbsent(ph, minDtotal);
//    editDistanceFromOtherSemanticClassesMatches.putIfAbsent(ph, minPh);
<span class="nc" id="L1347">    return new Pair&lt;&gt;(minPh, minDfinal);</span>
  }

//  public double getEditDistanceFromEng(String ph, int minLen) {
//    if (ph.length() &lt; minLen)
//      return editDistMax;
//    if (editDistanceFromEnglishWords.containsKey(ph))
//      return editDistanceFromEnglishWords.get(ph);
//    Pair&lt;String, Double&gt; d = getEditDist(commonEngWords, ph);
//    double minD = d.second();
//    String minPh = d.first();
//    if (d.second() &gt; 2) {
//      Pair&lt;String, Double&gt; minD2 = getEditDist(CandidatePhrase.convertToString(otherSemanticClassesWords), ph);
//      if (minD2.second &lt; minD) {
//        minD = minD2.second();
//        minPh = minD2.first();
//      }
//    }
//
//    editDistanceFromEnglishWords.putIfAbsent(ph, minD);
//    editDistanceFromEnglishWordsMatches.putIfAbsent(ph, minPh);
//    return minD;
//  }

  public ConcurrentHashMap&lt;String, Double&gt; getEditDistanceFromEnglishWords() {
<span class="nc" id="L1372">    return this.editDistanceFromEnglishWords;</span>
  }

  public ConcurrentHashMap&lt;String, String&gt; getEditDistanceFromEnglishWordsMatches() {
<span class="nc" id="L1376">    return this.editDistanceFromEnglishWordsMatches;</span>
  }

  public double getEditDistanceScoresOtherClass(String label, String g) {
    double editDist;
    String editDistPh;
//    if (editDistanceFromOtherSemanticClasses.containsKey(g)) {
//      editDist = editDistanceFromOtherSemanticClasses.get(g);
//      editDistPh = editDistanceFromOtherSemanticClassesMatches.get(g);
//    } else {
<span class="nc" id="L1386">      Pair&lt;String, Double&gt; editMatch = getEditDistanceFromOtherClasses(label, g, 4);</span>
<span class="nc" id="L1387">      editDist = editMatch.second();</span>
<span class="nc" id="L1388">      editDistPh = editMatch.first();</span>
//    }
<span class="nc bnc" id="L1390" title="All 4 branches missed.">    assert (!editDistPh.isEmpty());</span>
<span class="nc bnc" id="L1391" title="All 2 branches missed.">    return (editDist == editDistMax ? 1.0 : (editDist / (double) Math.max(g.length(), editDistPh.length())));</span>
  }

  /**
   * 1 if lies in edit distance, 0 if not close to any words
   *
   * @param g
   * @return
   */
  public double getEditDistanceScoresOtherClassThreshold(String label, String g) {
<span class="nc" id="L1401">    double editDistRatio = getEditDistanceScoresOtherClass(label, g);</span>

<span class="nc bnc" id="L1403" title="All 2 branches missed.">    if (editDistRatio &lt; 0.2)</span>
<span class="nc" id="L1404">      return 1;</span>
    else
<span class="nc" id="L1406">      return 0;</span>
  }

  public double getEditDistanceScoresThisClassThreshold(String label, String g) {
<span class="nc" id="L1410">    double editDistRatio = getEditDistanceScoresThisClass(label, g);</span>
<span class="nc bnc" id="L1411" title="All 2 branches missed.">    if (editDistRatio &lt; 0.2)</span>
<span class="nc" id="L1412">      return 1;</span>
    else
<span class="nc" id="L1414">      return 0;</span>
  }

  public double getEditDistanceScoresThisClass(String label, String g) {
    double editDist;
    String editDistPh;
//    if (editDistanceFromThisClass.containsKey(g)) {
//      editDist = editDistanceFromThisClass.get(g);
//      editDistPh = editDistanceFromThisClassMatches.get(g);
//      assert (!editDistPh.isEmpty());
//    } else {
//
<span class="nc" id="L1426">      Pair&lt;String, Double&gt; editMatch = getEditDistanceFromThisClass(label, g, 4);</span>
<span class="nc" id="L1427">      editDist = editMatch.second();</span>
<span class="nc" id="L1428">      editDistPh = editMatch.first();</span>
<span class="nc bnc" id="L1429" title="All 4 branches missed.">      assert (!editDistPh.isEmpty());</span>
    //}

<span class="nc bnc" id="L1432" title="All 2 branches missed.">    return ((editDist == editDistMax) ? 1.0 : (editDist / (double) Math.max(g.length(), editDistPh.length())));</span>
  }

  public static boolean isFuzzyMatch(String w1, String w2, int minLen4Fuzzy) {
<span class="nc" id="L1436">    EditDistance editDistance = new EditDistance(true);</span>
<span class="nc bnc" id="L1437" title="All 2 branches missed.">    if (w1.equals(w2))</span>
<span class="nc" id="L1438">      return true;</span>
<span class="nc bnc" id="L1439" title="All 2 branches missed.">    if (w2.length() &gt; minLen4Fuzzy) {</span>
<span class="nc" id="L1440">      double d = editDistance.score(w1, w2);</span>
<span class="nc bnc" id="L1441" title="All 2 branches missed.">      if (d == 1) {</span>
<span class="nc" id="L1442">        return true;</span>
      }
    }
<span class="nc" id="L1445">    return false;</span>
  }

  public static CandidatePhrase containsFuzzy(Set&lt;CandidatePhrase&gt; words, CandidatePhrase w,
      int minLen4Fuzzy) {
<span class="nc bnc" id="L1450" title="All 2 branches missed.">    for (CandidatePhrase w1 : words) {</span>
<span class="nc bnc" id="L1451" title="All 2 branches missed.">      if (isFuzzyMatch(w1.getPhrase(), w.getPhrase(), minLen4Fuzzy))</span>
<span class="nc" id="L1452">        return w1;</span>
<span class="nc" id="L1453">    }</span>
<span class="nc" id="L1454">    return null;</span>
  }

  public Map&lt;String, Integer&gt; getGeneralWordClassClusters() {
<span class="nc" id="L1458">    return generalWordClassClusters;</span>
  }

  public void setGeneralWordClassClusters(
      Map&lt;String, Integer&gt; generalWordClassClusters) {
<span class="nc" id="L1463">    this.generalWordClassClusters = generalWordClassClusters;</span>
<span class="nc" id="L1464">  }</span>

  public Map&lt;String, String&gt; getWordShapeCache() {
<span class="nc" id="L1467">    return wordShapeCache;</span>
  }


  public Map&lt;String, Class&lt;? extends Key&lt;String&gt;&gt;&gt; getAnswerClass() {
<span class="nc" id="L1472">    return answerClass;</span>
  }


  public Map&lt;String, Map&lt;Class, Object&gt;&gt; getIgnoreWordswithClassesDuringSelection() {
<span class="nc" id="L1477">    return ignoreWordswithClassesDuringSelection;</span>
  }

  public void addSeedWords(String label, Collection&lt;CandidatePhrase&gt; seeds) throws Exception {
<span class="nc bnc" id="L1481" title="All 2 branches missed.">    if(!seedLabelDictionary.containsKey(label)){</span>
<span class="nc" id="L1482">      throw new Exception(&quot;label not present in the model&quot;);</span>
    }

<span class="nc" id="L1485">    Set&lt;CandidatePhrase&gt; seedWords = new HashSet&lt;&gt;(seedLabelDictionary.get(label));</span>
<span class="nc" id="L1486">    seedWords.addAll(seeds);</span>
<span class="nc" id="L1487">    seedLabelDictionary.put(label, Collections.unmodifiableSet(seedWords));</span>
<span class="nc" id="L1488">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>