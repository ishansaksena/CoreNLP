<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ScorePhrases.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.patterns</a> &gt; <span class="el_source">ScorePhrases.java</span></div><h1>ScorePhrases.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.patterns;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.util.*;
import java.util.Map.Entry;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

import javax.json.Json;
import javax.json.JsonArray;
import javax.json.JsonArrayBuilder;
import javax.json.JsonObjectBuilder;
import javax.json.JsonReader;
import javax.json.JsonValue;

import edu.stanford.nlp.io.IOUtils;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.ling.tokensregex.Env;
import edu.stanford.nlp.ling.tokensregex.TokenSequencePattern;
import edu.stanford.nlp.patterns.dep.ApplyDepPatterns;
import edu.stanford.nlp.patterns.surface.*;
import edu.stanford.nlp.patterns.GetPatternsFromDataMultiClass.WordScoring;
import edu.stanford.nlp.patterns.PhraseScorer.Normalization;
import edu.stanford.nlp.semgraph.semgrex.SemgrexPattern;
import edu.stanford.nlp.stats.ClassicCounter;
import edu.stanford.nlp.stats.Counter;
import edu.stanford.nlp.stats.Counters;
import edu.stanford.nlp.stats.TwoDimensionalCounter;
import edu.stanford.nlp.util.*;
import edu.stanford.nlp.util.ArgumentParser.Option;
import edu.stanford.nlp.util.logging.Redwood;

<span class="nc bnc" id="L39" title="All 2 branches missed.">public class ScorePhrases&lt;E extends Pattern&gt;  {</span>

  /** A logger for this class */
<span class="nc" id="L42">  private static Redwood.RedwoodChannels log = Redwood.channels(ScorePhrases.class);</span>

<span class="nc" id="L44">  Map&lt;String, Boolean&gt; writtenInJustification = new HashMap&lt;&gt;();</span>

<span class="nc" id="L46">  ConstantsAndVariables constVars = null;</span>

<span class="nc" id="L48">  @Option(name = &quot;phraseScorerClass&quot;)</span>
  Class&lt;? extends PhraseScorer&gt; phraseScorerClass = ScorePhrasesAverageFeatures.class;
<span class="nc" id="L50">  PhraseScorer phraseScorer = null;</span>

<span class="nc" id="L52">  public ScorePhrases(Properties props, ConstantsAndVariables cv){</span>
<span class="nc" id="L53">    ArgumentParser.fillOptions(this, props);</span>
<span class="nc" id="L54">    this.constVars = cv;</span>
    try {
<span class="nc" id="L56">      phraseScorer = phraseScorerClass</span>
<span class="nc" id="L57">          .getConstructor(ConstantsAndVariables.class).newInstance(constVars);</span>
<span class="nc" id="L58">    } catch (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {</span>
<span class="nc" id="L59">      throw new RuntimeException(e);</span>
<span class="nc" id="L60">    }</span>
<span class="nc" id="L61">    ArgumentParser.fillOptions(phraseScorer, props);</span>
<span class="nc" id="L62">  }</span>

  public Counter&lt;CandidatePhrase&gt; chooseTopWords(Counter&lt;CandidatePhrase&gt; newdt,
                                                 TwoDimensionalCounter&lt;CandidatePhrase, E&gt; terms,
                                                 Counter&lt;CandidatePhrase&gt; useThresholdNumPatternsForTheseWords,
                                                 Set&lt;CandidatePhrase&gt; ignoreWords, double thresholdWordExtract) {

<span class="nc" id="L69">    Iterator&lt;CandidatePhrase&gt; termIter = Counters.toPriorityQueue(newdt).iterator();</span>
<span class="nc" id="L70">    Counter&lt;CandidatePhrase&gt; finalwords = new ClassicCounter&lt;&gt;();</span>

<span class="nc bnc" id="L72" title="All 2 branches missed.">    while (termIter.hasNext()) {</span>

<span class="nc bnc" id="L74" title="All 2 branches missed.">      if (finalwords.size() &gt;= constVars.numWordsToAdd){</span>
<span class="nc" id="L75">        break;</span>
      }
<span class="nc" id="L77">      CandidatePhrase w = termIter.next();</span>
<span class="nc bnc" id="L78" title="All 2 branches missed.">      if (newdt.getCount(w) &lt; thresholdWordExtract) {</span>
<span class="nc" id="L79">        Redwood.log(ConstantsAndVariables.extremedebug,&quot;not adding word &quot; + w + &quot; and any later words because the score &quot; + newdt.getCount(w) + &quot; is less than the threshold of  &quot; + thresholdWordExtract);</span>
<span class="nc" id="L80">        break;</span>
      }
<span class="nc bnc" id="L82" title="All 4 branches missed.">      assert (newdt.getCount(w) != Double.POSITIVE_INFINITY);</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">      if (useThresholdNumPatternsForTheseWords.containsKey(w)</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">          &amp;&amp; numNonRedundantPatterns(terms, w) &lt; constVars.thresholdNumPatternsApplied) {</span>
<span class="nc" id="L85">        Redwood</span>
<span class="nc" id="L86">            .log(</span>
                &quot;extremePatDebug&quot;,
                &quot;Not adding &quot;
                    + w
                    + &quot; because the number of non redundant patterns are below threshold of &quot; +  constVars.thresholdNumPatternsApplied + &quot;:&quot;
<span class="nc" id="L91">                    + terms.getCounter(w).keySet());</span>
<span class="nc" id="L92">        continue;</span>
      }
<span class="nc" id="L94">      CandidatePhrase matchedFuzzy = null;</span>
<span class="nc bnc" id="L95" title="All 4 branches missed.">      if (constVars.minLen4FuzzyForPattern &gt; 0 &amp;&amp; ignoreWords != null)</span>
<span class="nc" id="L96">        matchedFuzzy = ConstantsAndVariables.containsFuzzy(ignoreWords, w, constVars.minLen4FuzzyForPattern);</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">      if (matchedFuzzy == null) {</span>
<span class="nc" id="L98">        Redwood.log(&quot;extremePatDebug&quot;, &quot;adding word &quot; + w);</span>
<span class="nc" id="L99">        finalwords.setCount(w, newdt.getCount(w));</span>
      } else {
<span class="nc" id="L101">        Redwood</span>
<span class="nc" id="L102">            .log(&quot;extremePatDebug&quot;, &quot;not adding &quot; + w</span>
                + &quot; because it matched &quot; + matchedFuzzy
                + &quot; in common English word&quot;);
<span class="nc" id="L105">        ignoreWords.add(w);</span>
      }
<span class="nc" id="L107">    }</span>
<span class="nc" id="L108">     String nextTen = &quot;&quot;;</span>
<span class="nc" id="L109">     int n = 0;</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">     while (termIter.hasNext()) {</span>
<span class="nc" id="L111">     n++;</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">     if (n &gt; 10)</span>
<span class="nc" id="L113">     break;</span>
<span class="nc" id="L114">       CandidatePhrase w = termIter.next();</span>
<span class="nc" id="L115">     nextTen += &quot;;\t&quot; + w + &quot;:&quot; + newdt.getCount(w);</span>
<span class="nc" id="L116">     }</span>
<span class="nc" id="L117">     Redwood.log(Redwood.DBG, &quot;Next ten phrases were &quot; + nextTen);</span>
<span class="nc" id="L118">    return finalwords;</span>
  }

  public static &lt;E, F&gt; void removeKeys(TwoDimensionalCounter&lt;E, F&gt; counter,
      Collection&lt;E&gt; removeKeysCollection) {

<span class="nc bnc" id="L124" title="All 2 branches missed.">    for (E key : removeKeysCollection)</span>
<span class="nc" id="L125">      counter.remove(key);</span>
<span class="nc" id="L126">  }</span>

  private double numNonRedundantPatterns(
      TwoDimensionalCounter&lt;CandidatePhrase, E&gt; terms, CandidatePhrase w) {
<span class="nc" id="L130">    Object[] pats = terms.getCounter(w).keySet()</span>
<span class="nc" id="L131">        .toArray();</span>
<span class="nc" id="L132">    int numPat = 0;</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">    for (int i = 0; i &lt; pats.length; i++) {</span>
      //String pati = constVars.getPatternIndex().get(pats[i]).toString();
<span class="nc" id="L135">      String pati = pats[i].toString();</span>
<span class="nc" id="L136">      boolean contains = false;</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">      for (int j = i + 1; j &lt; pats.length; j++) {</span>
        //String patj = constVars.getPatternIndex().get(pats[j]).toString();
<span class="nc" id="L139">        String patj = pats[j].toString();</span>
<span class="nc bnc" id="L140" title="All 4 branches missed.">        if (patj.contains(pati) || pati.contains(patj)) {</span>
<span class="nc" id="L141">          contains = true;</span>
<span class="nc" id="L142">          break;</span>
        }
      }
<span class="nc bnc" id="L145" title="All 2 branches missed.">      if (!contains)</span>
<span class="nc" id="L146">        numPat++;</span>
    }
<span class="nc" id="L148">    return numPat;</span>
  }

  public Counter&lt;CandidatePhrase&gt; learnNewPhrases(
    String label,
    PatternsForEachToken patternsForEachToken,
    Counter&lt;E&gt; patternsLearnedThisIter,
    Counter&lt;E&gt; allSelectedPatterns,
    CollectionValuedMap&lt;E, Triple&lt;String, Integer, Integer&gt;&gt; tokensMatchedPatterns,
    Counter&lt;CandidatePhrase&gt; scoreForAllWordsThisIteration,
    TwoDimensionalCounter&lt;CandidatePhrase, E&gt; terms,
    TwoDimensionalCounter&lt;CandidatePhrase, E&gt; wordsPatExtracted,
    TwoDimensionalCounter&lt;E, CandidatePhrase&gt; patternsAndWords4Label,
    String identifier, Set&lt;CandidatePhrase&gt; ignoreWords) throws IOException, ClassNotFoundException {

<span class="nc" id="L163">    boolean computeProcDataFreq = false;</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">    if (Data.processedDataFreq == null) {</span>
<span class="nc" id="L165">      computeProcDataFreq = true;</span>
<span class="nc" id="L166">      Data.processedDataFreq = new ClassicCounter&lt;&gt;();</span>
<span class="nc bnc" id="L167" title="All 4 branches missed.">      assert Data.rawFreq != null;</span>
    }

<span class="nc" id="L170">    Set&lt;CandidatePhrase&gt; alreadyIdentifiedWords = new HashSet&lt;&gt;(constVars.getLearnedWords(label).keySet());</span>
<span class="nc" id="L171">    alreadyIdentifiedWords.addAll(constVars.getSeedLabelDictionary().get(label));</span>
<span class="nc" id="L172">    Counter&lt;CandidatePhrase&gt; words = learnNewPhrasesPrivate(label,</span>
        patternsForEachToken, patternsLearnedThisIter, allSelectedPatterns, alreadyIdentifiedWords,
        tokensMatchedPatterns, scoreForAllWordsThisIteration, terms,
        wordsPatExtracted,  patternsAndWords4Label,
        identifier, ignoreWords, computeProcDataFreq);

    //constVars.addLabelDictionary(label, words.keySet());


<span class="nc" id="L181">    return words;</span>
  }

  void runParallelApplyPats(Map&lt;String, DataInstance&gt; sents, String label, E pattern, TwoDimensionalCounter&lt;CandidatePhrase, E&gt; wordsandLemmaPatExtracted,
                            CollectionValuedMap&lt;E, Triple&lt;String, Integer, Integer&gt;&gt; matchedTokensByPat, Set&lt;CandidatePhrase&gt; alreadyLabeledWords) {

<span class="nc" id="L187">    Redwood.log(Redwood.DBG, &quot;Applying pattern &quot; + pattern + &quot; to a total of &quot; + sents.size() + &quot; sentences &quot;);</span>
<span class="nc" id="L188">    List&lt;String&gt; notAllowedClasses = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L189">    List&lt;String&gt; sentids = CollectionUtils.toList(sents.keySet());</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">    if(constVars.doNotExtractPhraseAnyWordLabeledOtherClass){</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">      for(String l: constVars.getAnswerClass().keySet()){</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">        if(!l.equals(label)){</span>
<span class="nc" id="L193">          notAllowedClasses.add(l);</span>
        }
<span class="nc" id="L195">      }</span>
<span class="nc" id="L196">      notAllowedClasses.add(&quot;OTHERSEM&quot;);</span>
    }


<span class="nc" id="L200">    Map&lt;TokenSequencePattern, E&gt; surfacePatternsLearnedThisIterConverted = null;</span>
<span class="nc" id="L201">    Map&lt;SemgrexPattern, E&gt; depPatternsLearnedThisIterConverted = null;</span>

<span class="nc bnc" id="L203" title="All 2 branches missed.">    if(constVars.patternType.equals(PatternFactory.PatternType.SURFACE)) {</span>
<span class="nc" id="L204">      surfacePatternsLearnedThisIterConverted = new HashMap&lt;&gt;();</span>
<span class="nc" id="L205">      String patternStr = null;</span>
      try{
<span class="nc" id="L207">        patternStr = pattern.toString(notAllowedClasses);</span>
<span class="nc" id="L208">        TokenSequencePattern pat = TokenSequencePattern.compile(constVars.env.get(label), patternStr);</span>
<span class="nc" id="L209">        surfacePatternsLearnedThisIterConverted.put(pat, pattern);</span>
<span class="nc" id="L210">      }catch(Exception e){</span>
<span class="nc" id="L211">        log.info(&quot;Error applying patterrn &quot; + patternStr + &quot;. Probably an ill formed pattern (can be because of special symbols in label names). Contact the software developer.&quot;);</span>
<span class="nc" id="L212">        throw e;</span>
<span class="nc" id="L213">      }</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">    }else if(constVars.patternType.equals(PatternFactory.PatternType.DEP)){</span>
<span class="nc" id="L215">      depPatternsLearnedThisIterConverted = new HashMap&lt;&gt;();</span>
<span class="nc" id="L216">      SemgrexPattern pat = SemgrexPattern.compile(pattern.toString(notAllowedClasses), new edu.stanford.nlp.semgraph.semgrex.Env(constVars.env.get(label).getVariables()));</span>
<span class="nc" id="L217">      depPatternsLearnedThisIterConverted.put(pat, pattern);</span>
<span class="nc" id="L218">    } else</span>
<span class="nc" id="L219">    throw new UnsupportedOperationException();</span>

    //Apply the patterns and extract candidate phrases
    int num;
<span class="nc" id="L223">    int numThreads = constVars.numThreads;</span>

    //If number of sentences is less, do not create so many threads
<span class="nc bnc" id="L226" title="All 2 branches missed.">    if(sents.size() &lt; 50)</span>
<span class="nc" id="L227">      numThreads = 1;</span>

<span class="nc bnc" id="L229" title="All 2 branches missed.">    if (numThreads == 1)</span>
<span class="nc" id="L230">      num = sents.size();</span>
    else
<span class="nc" id="L232">      num = sents.size() / (numThreads - 1);</span>

<span class="nc" id="L234">    ExecutorService executor = Executors.newFixedThreadPool(constVars.numThreads);</span>
<span class="nc" id="L235">    List&lt;Future&lt;Triple&lt;TwoDimensionalCounter&lt;CandidatePhrase, E&gt;, CollectionValuedMap&lt;E, Triple&lt;String, Integer, Integer&gt;&gt;, Set&lt;CandidatePhrase&gt;&gt;&gt;&gt; list = new ArrayList&lt;&gt;();</span>


<span class="nc bnc" id="L238" title="All 2 branches missed.">    for (int i = 0; i &lt; numThreads; i++) {</span>

<span class="nc" id="L240">      Callable&lt;Triple&lt;TwoDimensionalCounter&lt;CandidatePhrase, E&gt;, CollectionValuedMap&lt;E, Triple&lt;String, Integer, Integer&gt;&gt;, Set&lt;CandidatePhrase&gt;&gt;&gt; task = null;</span>

<span class="nc bnc" id="L242" title="All 2 branches missed.">      if(pattern.type.equals(PatternFactory.PatternType.SURFACE))</span>
        //Redwood.log(Redwood.DBG, &quot;Applying pats: assigning sentences &quot; + i*num + &quot; to &quot; +Math.min(sentids.size(), (i + 1) * num) + &quot; to thread &quot; + (i+1));
<span class="nc bnc" id="L244" title="All 2 branches missed.">        task = new ApplyPatterns(sents, num == sents.size() ? sentids : sentids.subList(i * num,</span>
<span class="nc" id="L245">          Math.min(sentids.size(), (i + 1) * num)), surfacePatternsLearnedThisIterConverted, label,</span>
          constVars.removeStopWordsFromSelectedPhrases,
          constVars.removePhrasesWithStopWords, constVars);
      else
<span class="nc bnc" id="L249" title="All 2 branches missed.">        task = new ApplyDepPatterns(sents, num == sents.size() ? sentids : sentids.subList(i * num,</span>
<span class="nc" id="L250">          Math.min(sentids.size(), (i + 1) * num)), depPatternsLearnedThisIterConverted, label,</span>
          constVars.removeStopWordsFromSelectedPhrases,
          constVars.removePhrasesWithStopWords, constVars);


<span class="nc" id="L255">      Future&lt;Triple&lt;TwoDimensionalCounter&lt;CandidatePhrase, E&gt;, CollectionValuedMap&lt;E, Triple&lt;String, Integer, Integer&gt;&gt;, Set&lt;CandidatePhrase&gt;&gt;&gt; submit = executor</span>
<span class="nc" id="L256">          .submit(task);</span>
<span class="nc" id="L257">      list.add(submit);</span>
    }

    // Now retrieve the result
<span class="nc bnc" id="L261" title="All 2 branches missed.">    for (Future&lt;Triple&lt;TwoDimensionalCounter&lt;CandidatePhrase, E&gt;, CollectionValuedMap&lt;E, Triple&lt;String, Integer, Integer&gt;&gt;,Set&lt;CandidatePhrase&gt;&gt;&gt; future : list) {</span>
      try{
<span class="nc" id="L263">        Triple&lt;TwoDimensionalCounter&lt;CandidatePhrase, E&gt;, CollectionValuedMap&lt;E, Triple&lt;String, Integer, Integer&gt;&gt;,Set&lt;CandidatePhrase&gt;&gt; result = future</span>
<span class="nc" id="L264">            .get();</span>
<span class="nc" id="L265">        Redwood.log(ConstantsAndVariables.extremedebug, &quot;Pattern &quot; + pattern + &quot; extracted phrases &quot; + result.first());</span>
<span class="nc" id="L266">        wordsandLemmaPatExtracted.addAll(result.first());</span>
<span class="nc" id="L267">        matchedTokensByPat.addAll(result.second());</span>
<span class="nc" id="L268">        alreadyLabeledWords.addAll(result.third());</span>
<span class="nc" id="L269">      }catch(Exception e){</span>
<span class="nc" id="L270">        executor.shutdownNow();</span>
<span class="nc" id="L271">        throw new RuntimeException(e);</span>
<span class="nc" id="L272">      }</span>
<span class="nc" id="L273">    }</span>
<span class="nc" id="L274">    executor.shutdown();</span>
<span class="nc" id="L275">  }</span>
/*
  void runParallelApplyPats(Map&lt;String, List&lt;CoreLabel&gt;&gt; sents, Set&lt;String&gt; sentIds, String label, Counter&lt;E&gt; patternsLearnedThisIter,  TwoDimensionalCounter&lt;Pair&lt;String, String&gt;, Integer&gt; wordsandLemmaPatExtracted,
                            CollectionValuedMap&lt;Integer, Triple&lt;String, Integer, Integer&gt;&gt; matchedTokensByPat) throws InterruptedException, ExecutionException{
    List&lt;String&gt; keyset = new ArrayList&lt;String&gt;(sentIds);
    List&lt;String&gt; notAllowedClasses = new ArrayList&lt;String&gt;();

    if(constVars.doNotExtractPhraseAnyWordLabeledOtherClass){
      for(String l: constVars.getAnswerClass().keySet()){
        if(!l.equals(label)){
          notAllowedClasses.add(l+&quot;:&quot;+l);
        }
      }
      notAllowedClasses.add(&quot;OTHERSEM:OTHERSEM&quot;);
    }

    //Apply the patterns and extract candidate phrases
    int num = 0;
    if (constVars.numThreads == 1)
      num = keyset.size();
    else
      num = keyset.size() / (constVars.numThreads - 1);
    ExecutorService executor = Executors.newFixedThreadPool(constVars.numThreads);
    List&lt;Future&lt;Pair&lt;TwoDimensionalCounter&lt;Pair&lt;String, String&gt;, Integer&gt;, CollectionValuedMap&lt;Integer, Triple&lt;String, Integer, Integer&gt;&gt;&gt;&gt;&gt; list = new ArrayList&lt;Future&lt;Pair&lt;TwoDimensionalCounter&lt;Pair&lt;String, String&gt;, Integer&gt;, CollectionValuedMap&lt;Integer, Triple&lt;String, Integer, Integer&gt;&gt;&gt;&gt;&gt;();
    for (int i = 0; i &lt; constVars.numThreads; i++) {

      Callable&lt;Pair&lt;TwoDimensionalCounter&lt;Pair&lt;String, String&gt;, Integer&gt;, CollectionValuedMap&lt;Integer, Triple&lt;String, Integer, Integer&gt;&gt;&gt;&gt; task = null;
      Map&lt;TokenSequencePattern, Integer&gt; patternsLearnedThisIterConverted = new HashMap&lt;TokenSequencePattern , Integer&gt;();
      for(Integer pindex : patternsLearnedThisIter.keySet()){
        SurfacePattern p = constVars.getPatternIndex().get(pindex);
        TokenSequencePattern pat = TokenSequencePattern.compile(constVars.env.get(label), p.toString(notAllowedClasses));
        patternsLearnedThisIterConverted.put(pat, pindex);
      }

      task = new ApplyPatternsMulti(sents, keyset.subList(i * num,
        Math.min(keyset.size(), (i + 1) * num)), patternsLearnedThisIterConverted, label,
        constVars.removeStopWordsFromSelectedPhrases,
        constVars.removePhrasesWithStopWords, constVars);

      Future&lt;Pair&lt;TwoDimensionalCounter&lt;Pair&lt;String, String&gt;, Integer&gt;, CollectionValuedMap&lt;Integer, Triple&lt;String, Integer, Integer&gt;&gt;&gt;&gt; submit = executor
        .submit(task);
      list.add(submit);
    }

    // Now retrieve the result
    for (Future&lt;Pair&lt;TwoDimensionalCounter&lt;Pair&lt;String, String&gt;, Integer&gt;, CollectionValuedMap&lt;Integer, Triple&lt;String, Integer, Integer&gt;&gt;&gt;&gt; future : list) {
      try{
        Pair&lt;TwoDimensionalCounter&lt;Pair&lt;String, String&gt;, Integer&gt;, CollectionValuedMap&lt;Integer, Triple&lt;String, Integer, Integer&gt;&gt;&gt; result = future
          .get();
        wordsandLemmaPatExtracted.addAll(result.first());
        matchedTokensByPat.addAll(result.second());
      }catch(Exception e){
        executor.shutdownNow();
        throw new RuntimeException(e);
      }
    }
    executor.shutdown();
  }
*/

  protected Map&lt;E, Map&lt;String, DataInstance&gt;&gt; getSentences(Map&lt;E, Set&lt;String&gt;&gt; sentids) {
    try{

<span class="nc" id="L338">      Set&lt;File&gt; files = new HashSet&lt;&gt;();</span>

<span class="nc" id="L340">      Map&lt;E, Map&lt;String, DataInstance&gt;&gt; sentsAll  = new HashMap&lt;&gt;();</span>
<span class="nc" id="L341">      CollectionValuedMap&lt;String, E&gt; sentIds2Pats = new CollectionValuedMap&lt;&gt;();</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">      for(Map.Entry&lt;E, Set&lt;String&gt;&gt; setEn: sentids.entrySet()){</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">        if(!sentsAll.containsKey(setEn.getKey()))</span>
<span class="nc" id="L344">          sentsAll.put(setEn.getKey(), new HashMap&lt;&gt;());</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">        for(String s: setEn.getValue()){</span>
<span class="nc" id="L346">          sentIds2Pats.add(s, setEn.getKey());</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">          if(constVars.batchProcessSents){</span>
<span class="nc" id="L348">            File f = Data.sentId2File.get(s);</span>
<span class="nc bnc" id="L349" title="All 4 branches missed.">            assert f!= null : &quot;How come no file for sentence &quot; + s;</span>
<span class="nc" id="L350">            files.add(f);</span>
          }
<span class="nc" id="L352">        }</span>
<span class="nc" id="L353">      }</span>

<span class="nc bnc" id="L355" title="All 2 branches missed.">      if(constVars.batchProcessSents){</span>
<span class="nc bnc" id="L356" title="All 2 branches missed.">        for(File f: files){</span>
<span class="nc" id="L357">          Map&lt;String, DataInstance&gt; sentsf = IOUtils.readObjectFromFile(f);</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">          for(Map.Entry&lt;String, DataInstance&gt; s: sentsf.entrySet()){</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">            for(E pat: sentIds2Pats.get(s.getKey()))</span>
<span class="nc" id="L360">              sentsAll.get(pat).put(s.getKey(), s.getValue());</span>
<span class="nc" id="L361">          }</span>
<span class="nc" id="L362">        }</span>
      }else{
<span class="nc bnc" id="L364" title="All 2 branches missed.">        for(Map.Entry&lt;String, DataInstance&gt; s: Data.sents.entrySet()){</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">          for(E pat: sentIds2Pats.get(s.getKey()))</span>
<span class="nc" id="L366">            sentsAll.get(pat).put(s.getKey(), s.getValue());</span>
<span class="nc" id="L367">        }</span>
      }

//      /System.out.println(&quot;All sentences are &quot; + sentsAll.entrySet().stream().map( x -&gt; constVars.patternIndex.get(x.getKey())+&quot;:&quot;+x.getValue()).collect(Collectors.toList()));
<span class="nc" id="L371">      return sentsAll;</span>
<span class="nc" id="L372">    }catch(ClassNotFoundException e){</span>
<span class="nc" id="L373">      throw new RuntimeException(e);</span>
<span class="nc" id="L374">    }catch(IOException e1){</span>
<span class="nc" id="L375">      throw new RuntimeException(e1);</span>

    }
  }


  public void applyPats(Counter&lt;E&gt; patterns, String label, TwoDimensionalCounter&lt;CandidatePhrase, E&gt; wordsandLemmaPatExtracted,
                        CollectionValuedMap&lt;E, Triple&lt;String, Integer, Integer&gt;&gt; matchedTokensByPat, Set&lt;CandidatePhrase&gt; alreadyLabeledWords){
 //   Counter&lt;E&gt; patternsLearnedThisIterConsistsOnlyGeneralized = new ClassicCounter&lt;E&gt;();
 //   Counter&lt;E&gt; patternsLearnedThisIterRest = new ClassicCounter&lt;E&gt;();
//    Set&lt;String&gt; specialWords = constVars.invertedIndex.getSpecialWordsList();

<span class="nc bnc" id="L387" title="All 2 branches missed.">    for(Map.Entry&lt;String, Env&gt; en: constVars.env.entrySet()){</span>
<span class="nc" id="L388">      en.getValue().getVariables().putAll(ConstantsAndVariables.globalEnv.getVariables());</span>
<span class="nc" id="L389">    }</span>

<span class="nc" id="L391">    Map&lt;E, Map&lt;String, DataInstance&gt;&gt; sentencesForPatterns = getSentences(constVars.invertedIndex.queryIndex(patterns.keySet()));</span>

<span class="nc bnc" id="L393" title="All 2 branches missed.">    for(Map.Entry&lt;E, Map&lt;String, DataInstance&gt;&gt; en: sentencesForPatterns.entrySet()){</span>
<span class="nc" id="L394">      runParallelApplyPats(en.getValue(), label, en.getKey(), wordsandLemmaPatExtracted, matchedTokensByPat, alreadyLabeledWords);</span>
<span class="nc" id="L395">    }</span>

<span class="nc" id="L397">    Redwood.log(Redwood.DBG, &quot;# words/lemma and pattern pairs are &quot; + wordsandLemmaPatExtracted.size());</span>
<span class="nc" id="L398">  }</span>
  /*
  public void applyPats(Counter&lt;E&gt; patterns, String label, boolean computeDataFreq,  TwoDimensionalCounter&lt;Pair&lt;String, String&gt;, Integer&gt; wordsandLemmaPatExtracted,
                        CollectionValuedMap&lt;Integer, Triple&lt;String, Integer, Integer&gt;&gt; matchedTokensByPat) throws ClassNotFoundException, IOException, InterruptedException, ExecutionException{
    Counter&lt;E&gt; patternsLearnedThisIterConsistsOnlyGeneralized = new ClassicCounter&lt;E&gt;();
    Counter&lt;E&gt; patternsLearnedThisIterRest = new ClassicCounter&lt;E&gt;();
    Set&lt;String&gt; specialWords = constVars.invertedIndex.getSpecialWordsList();
    List&lt;String&gt; extremelySmallStopWordsList = Arrays.asList(&quot;.&quot;,&quot;,&quot;,&quot;in&quot;,&quot;on&quot;,&quot;of&quot;,&quot;a&quot;,&quot;the&quot;,&quot;an&quot;);

    for(Entry&lt;Integer, Double&gt; en: patterns.entrySet()){
      Integer pindex = en.getKey();
      SurfacePattern p = constVars.getPatternIndex().get(pindex);
      String[] n = p.getSimplerTokensNext();
      String[] pr = p.getSimplerTokensPrev();
      boolean rest = false;
      if(n!=null){
        for(String e: n){
          if(!specialWords.contains(e)){
            rest = true;
            break;
          }
        }
      }
      if(rest == false &amp;&amp; pr!=null){
        for(String e: pr){
          if(!specialWords.contains(e) &amp;&amp; !extremelySmallStopWordsList.contains(e)){
            rest = true;
            break;
          }
        }
      }
      if(rest)
        patternsLearnedThisIterRest.setCount(en.getKey(), en.getValue());
      else
        patternsLearnedThisIterConsistsOnlyGeneralized.setCount(en.getKey(), en.getValue());
    }



    Map&lt;String, Set&lt;String&gt;&gt; sentidswithfilerest = constVars.invertedIndex.getFileSentIdsFromPats(patternsLearnedThisIterRest.keySet(), constVars.getPatternIndex());

    if (constVars.batchProcessSents) {
      List&lt;File&gt; filesToLoad;
      if(patternsLearnedThisIterConsistsOnlyGeneralized.size() &gt; 0)
        filesToLoad = Data.sentsFiles;
      else{
        filesToLoad = new ArrayList&lt;File&gt;();
        for (String fname : sentidswithfilerest.keySet()) {
          String filename;
//          if(!constVars.usingDirForSentsInIndex)
//            filename = constVars.saveSentencesSerDir+&quot;/&quot;+fname;
//          else
            filename = fname;
          filesToLoad.add(new File(filename));
        }
      }

      for (File fname : filesToLoad) {
        Redwood.log(Redwood.DBG, &quot;Applying patterns to sents from &quot; + fname);
        Map&lt;String, List&lt;CoreLabel&gt;&gt; sents = IOUtils.readObjectFromFile(fname);

        if(sentidswithfilerest != null &amp;&amp; !sentidswithfilerest.isEmpty()){

          String filename;
//          if(constVars.usingDirForSentsInIndex)
//            filename = constVars.saveSentencesSerDir+&quot;/&quot;+fname.getName();
//          else
            filename = fname.getAbsolutePath();

          Set&lt;String&gt; sentIDs = sentidswithfilerest.get(filename);
          if (sentIDs != null){
            this.runParallelApplyPats(sents, sentIDs, label, patternsLearnedThisIterRest, wordsandLemmaPatExtracted, matchedTokensByPat);
          } else
            Redwood.log(Redwood.DBG, &quot;No sentIds for &quot; + filename  + &quot; in the index for the keywords from the patterns! The index came up with these files: &quot; + sentidswithfilerest.keySet());
        }
        if(patternsLearnedThisIterConsistsOnlyGeneralized.size() &gt; 0){
          this.runParallelApplyPats(sents, sents.keySet(), label, patternsLearnedThisIterConsistsOnlyGeneralized, wordsandLemmaPatExtracted, matchedTokensByPat);
        }

        if (computeDataFreq){
          Data.computeRawFreqIfNull(sents, constVars.numWordsCompound);
          Data.fileNamesUsedToComputeRawFreq.add(fname.getName());
        }
      }

      //Compute Frequency from the files not loaded using the invertedindex query. otherwise, later on there is an error.
      if(computeDataFreq){
        for(File f: Data.sentsFiles){
          if(!Data.fileNamesUsedToComputeRawFreq.contains(f.getName())){
            Map&lt;String, List&lt;CoreLabel&gt;&gt; sents = IOUtils.readObjectFromFile(f);
            Data.computeRawFreqIfNull(sents, constVars.numWordsCompound);
            Data.fileNamesUsedToComputeRawFreq.add(f.getName());
          }
        }
      }

    } else {

      if (sentidswithfilerest != null &amp;&amp; !sentidswithfilerest.isEmpty()) {
        String filename = CollectionUtils.toList(sentidswithfilerest.keySet()).get(0);
        Set&lt;String&gt; sentids = sentidswithfilerest.get(filename);
        if (sentids != null) {
          this.runParallelApplyPats(Data.sents, sentids, label, patternsLearnedThisIterRest, wordsandLemmaPatExtracted, matchedTokensByPat);
        } else
          throw new RuntimeException(&quot;How come no sentIds for &quot; + filename  + &quot;. Index keyset is &quot; + constVars.invertedIndex.getKeySet());
      }
      if(patternsLearnedThisIterConsistsOnlyGeneralized.size() &gt; 0){
        this.runParallelApplyPats(Data.sents, Data.sents.keySet(), label, patternsLearnedThisIterConsistsOnlyGeneralized, wordsandLemmaPatExtracted, matchedTokensByPat);
      }
      Data.computeRawFreqIfNull(Data.sents, constVars.numWordsCompound);
    }
    Redwood.log(Redwood.DBG, &quot;# words/lemma and pattern pairs are &quot; + wordsandLemmaPatExtracted.size());
  }
  */

  private void statsWithoutApplyingPatterns(Map&lt;String, DataInstance&gt; sents, PatternsForEachToken patternsForEachToken,
      Counter&lt;E&gt; patternsLearnedThisIter, TwoDimensionalCounter&lt;CandidatePhrase, E&gt; wordsandLemmaPatExtracted){
<span class="nc bnc" id="L515" title="All 2 branches missed.">    for (Entry&lt;String, DataInstance&gt; sentEn : sents.entrySet()) {</span>
<span class="nc" id="L516">      Map&lt;Integer, Set&lt;E&gt;&gt; pat4Sent = patternsForEachToken.getPatternsForAllTokens(sentEn.getKey());</span>

<span class="nc bnc" id="L518" title="All 2 branches missed.">      if (pat4Sent == null) {</span>
<span class="nc" id="L519">        throw new RuntimeException(&quot;How come there are no patterns for &quot;</span>
<span class="nc" id="L520">            + sentEn.getKey());</span>
      }
<span class="nc bnc" id="L522" title="All 2 branches missed.">      for (Entry&lt;Integer, Set&lt;E&gt;&gt; en : pat4Sent</span>
<span class="nc" id="L523">          .entrySet()) {</span>
<span class="nc" id="L524">        CoreLabel token = null;</span>
<span class="nc" id="L525">        Set&lt;E&gt; p1 = en.getValue();</span>

//        Set&lt;Integer&gt; p1 = en.getValue().first();
//        Set&lt;Integer&gt; p2 = en.getValue().second();
//        Set&lt;Integer&gt; p3 = en.getValue().third();
<span class="nc bnc" id="L530" title="All 2 branches missed.">        for (E index : patternsLearnedThisIter.keySet()) {</span>

<span class="nc bnc" id="L532" title="All 2 branches missed.">          if (p1.contains(index)) {</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">            if (token == null)</span>
<span class="nc" id="L534">              token = sentEn.getValue().getTokens().get(en.getKey());</span>
<span class="nc" id="L535">            wordsandLemmaPatExtracted.incrementCount(CandidatePhrase.createOrGet(token.word(), token.lemma()), index);</span>
          }
<span class="nc" id="L537">        }</span>
<span class="nc" id="L538">      }</span>
<span class="nc" id="L539">    }</span>
<span class="nc" id="L540">  }</span>

  private Counter&lt;CandidatePhrase&gt; learnNewPhrasesPrivate(
    String label,
    PatternsForEachToken patternsForEachToken,
    Counter&lt;E&gt; patternsLearnedThisIter,
    Counter&lt;E&gt; allSelectedPatterns,
    Set&lt;CandidatePhrase&gt; alreadyIdentifiedWords, CollectionValuedMap&lt;E, Triple&lt;String, Integer, Integer&gt;&gt; matchedTokensByPat,
    Counter&lt;CandidatePhrase&gt; scoreForAllWordsThisIteration,
    TwoDimensionalCounter&lt;CandidatePhrase, E&gt; terms,
    TwoDimensionalCounter&lt;CandidatePhrase, E&gt; wordsPatExtracted,
    TwoDimensionalCounter&lt;E, CandidatePhrase&gt; patternsAndWords4Label,
    String identifier, Set&lt;CandidatePhrase&gt; ignoreWords, boolean computeProcDataFreq) throws IOException, ClassNotFoundException {

<span class="nc" id="L554">    Set&lt;CandidatePhrase&gt; alreadyLabeledWords = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L555" title="All 2 branches missed.">    if (constVars.doNotApplyPatterns) {</span>
      // if want to get the stats by the lossy way of just counting without
      // applying the patterns
<span class="nc" id="L558">      ConstantsAndVariables.DataSentsIterator sentsIter = new ConstantsAndVariables.DataSentsIterator(constVars.batchProcessSents);</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">      while(sentsIter.hasNext()) {</span>
<span class="nc" id="L560">        Pair&lt;Map&lt;String, DataInstance&gt;, File&gt; sentsf = sentsIter.next();</span>
<span class="nc" id="L561">        this.statsWithoutApplyingPatterns(sentsf.first(), patternsForEachToken, patternsLearnedThisIter, wordsPatExtracted);</span>
<span class="nc" id="L562">      }</span>
<span class="nc" id="L563">    } else {</span>
<span class="nc bnc" id="L564" title="All 2 branches missed.">      if (patternsLearnedThisIter.size() &gt; 0) {</span>
<span class="nc" id="L565">        this.applyPats(patternsLearnedThisIter, label, wordsPatExtracted, matchedTokensByPat, alreadyLabeledWords);</span>

      }
    }
<span class="nc bnc" id="L569" title="All 2 branches missed.">    if(computeProcDataFreq){</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">      if (!phraseScorer.wordFreqNorm.equals(Normalization.NONE)) {</span>
<span class="nc" id="L571">        Redwood.log(Redwood.DBG, &quot;computing processed freq&quot;);</span>
<span class="nc bnc" id="L572" title="All 2 branches missed.">        for (Entry&lt;CandidatePhrase, Double&gt; fq : Data.rawFreq.entrySet()) {</span>
<span class="nc" id="L573">          Double in = fq.getValue();</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">          if (phraseScorer.wordFreqNorm.equals(Normalization.SQRT))</span>
<span class="nc" id="L575">            in = Math.sqrt(in);</span>

<span class="nc bnc" id="L577" title="All 2 branches missed.">          else if (phraseScorer.wordFreqNorm.equals(Normalization.LOG))</span>
<span class="nc" id="L578">            in = 1 + Math.log(in);</span>
          else
<span class="nc" id="L580">            throw new RuntimeException(&quot;can't understand the normalization&quot;);</span>

<span class="nc bnc" id="L582" title="All 4 branches missed.">          assert !in.isNaN(): &quot;Why is processed freq nan when rawfreq is &quot; + in;</span>

<span class="nc" id="L584">          Data.processedDataFreq.setCount(fq.getKey(), in);</span>
<span class="nc" id="L585">        }</span>
      } else
<span class="nc" id="L587">        Data.processedDataFreq = Data.rawFreq;</span>
    }

<span class="nc bnc" id="L590" title="All 2 branches missed.">    if (constVars.wordScoring.equals(WordScoring.WEIGHTEDNORM)) {</span>

<span class="nc bnc" id="L592" title="All 2 branches missed.">      for (CandidatePhrase en : wordsPatExtracted.firstKeySet()) {</span>

<span class="nc bnc" id="L594" title="All 8 branches missed.">        if (!constVars.getOtherSemanticClassesWords().contains(en) &amp;&amp; (en.getPhraseLemma() ==null || !constVars.getOtherSemanticClassesWords().contains(CandidatePhrase.createOrGet(en.getPhraseLemma()))) &amp;&amp; !alreadyLabeledWords.contains(en)){</span>
<span class="nc" id="L595">          terms.addAll(en, wordsPatExtracted.getCounter(en));</span>
        }
<span class="nc" id="L597">      }</span>
<span class="nc" id="L598">      removeKeys(terms, constVars.getStopWords());</span>

<span class="nc" id="L600">      Counter&lt;CandidatePhrase&gt; phraseScores = phraseScorer.scorePhrases(label,</span>
          terms, wordsPatExtracted, allSelectedPatterns,
          alreadyIdentifiedWords, false);
<span class="nc" id="L603">      System.out.println(&quot;count for word U.S. is &quot; + phraseScores.getCount(CandidatePhrase.createOrGet(&quot;U.S.&quot;)));</span>
      Set&lt;CandidatePhrase&gt; ignoreWordsAll ;
<span class="nc bnc" id="L605" title="All 4 branches missed.">      if(ignoreWords !=null &amp;&amp; !ignoreWords.isEmpty()){</span>
<span class="nc" id="L606">        ignoreWordsAll = CollectionUtils.unionAsSet(ignoreWords, constVars.getOtherSemanticClassesWords());</span>
      }
      else
<span class="nc" id="L609">        ignoreWordsAll = new HashSet&lt;&gt;(constVars.getOtherSemanticClassesWords());</span>

<span class="nc" id="L611">      ignoreWordsAll.addAll(constVars.getSeedLabelDictionary().get(label));</span>
<span class="nc" id="L612">      ignoreWordsAll.addAll(constVars.getLearnedWords(label).keySet());</span>
<span class="nc" id="L613">      System.out.println(&quot;ignoreWordsAll contains word U.S. is &quot; + ignoreWordsAll.contains(CandidatePhrase.createOrGet(&quot;U.S.&quot;)));</span>

<span class="nc" id="L615">      Counter&lt;CandidatePhrase&gt; finalwords = chooseTopWords(phraseScores, terms,</span>
          phraseScores, ignoreWordsAll, constVars.thresholdWordExtract);

<span class="nc" id="L618">      phraseScorer.printReasonForChoosing(finalwords);</span>

<span class="nc" id="L620">      scoreForAllWordsThisIteration.clear();</span>
<span class="nc" id="L621">      Counters.addInPlace(scoreForAllWordsThisIteration, phraseScores);</span>

<span class="nc" id="L623">      Redwood.log(</span>
          ConstantsAndVariables.minimaldebug,
          &quot;\n\n## Selected Words for &quot; + label + &quot; : &quot;
<span class="nc" id="L626">              + Counters.toSortedString(finalwords, finalwords.size(),</span>
                  &quot;%1$s:%2$.2f&quot;, &quot;\t&quot;));

<span class="nc bnc" id="L629" title="All 2 branches missed.">      if(constVars.goldEntities != null){</span>
<span class="nc" id="L630">        Map&lt;String, Boolean&gt; goldEntities4Label = constVars.goldEntities.get(label);</span>
<span class="nc bnc" id="L631" title="All 2 branches missed.">        if(goldEntities4Label != null) {</span>
<span class="nc" id="L632">          StringBuffer s = new StringBuffer();</span>
<span class="nc" id="L633">          finalwords.keySet().stream().forEach(x -&gt;</span>
<span class="nc bnc" id="L634" title="All 2 branches missed.">            s.append(x.getPhrase() + (goldEntities4Label.containsKey(x.getPhrase()) ? &quot;:&quot;+goldEntities4Label.get(x.getPhrase()) : &quot;:UKNOWN&quot;)+&quot;\n&quot;));</span>

<span class="nc" id="L636">          Redwood.log(ConstantsAndVariables.minimaldebug,</span>
<span class="nc" id="L637">            &quot;\n\n## Gold labels for selected words for label &quot; + label + &quot; : &quot; + s.toString());</span>
<span class="nc" id="L638">        } else</span>
<span class="nc" id="L639">          Redwood.log(Redwood.DBG, &quot;No gold entities provided for label &quot; + label);</span>
      }

<span class="nc bnc" id="L642" title="All 4 branches missed.">      if (constVars.outDir != null &amp;&amp; !constVars.outDir.isEmpty()) {</span>
<span class="nc" id="L643">        String outputdir = constVars.outDir + &quot;/&quot; + identifier +&quot;/&quot;+ label;</span>
<span class="nc" id="L644">        IOUtils.ensureDir(new File(outputdir));</span>
<span class="nc" id="L645">        TwoDimensionalCounter&lt;CandidatePhrase, CandidatePhrase&gt; reasonForWords = new TwoDimensionalCounter&lt;&gt;();</span>
<span class="nc bnc" id="L646" title="All 2 branches missed.">        for (CandidatePhrase word : finalwords.keySet()) {</span>
<span class="nc bnc" id="L647" title="All 2 branches missed.">          for (E l : wordsPatExtracted.getCounter(word).keySet()) {</span>
<span class="nc bnc" id="L648" title="All 2 branches missed.">            for (CandidatePhrase w2 : patternsAndWords4Label.getCounter(l)) {</span>
<span class="nc" id="L649">              reasonForWords.incrementCount(word, w2);</span>
<span class="nc" id="L650">            }</span>
<span class="nc" id="L651">          }</span>
<span class="nc" id="L652">        }</span>
<span class="nc" id="L653">        Redwood.log(ConstantsAndVariables.minimaldebug, &quot;Saving output in &quot; + outputdir);</span>
<span class="nc" id="L654">        String filename = outputdir + &quot;/words.json&quot;;</span>

        // the json object is an array corresponding to each iteration - of list
        // of objects,
        // each of which is a bean of entity and reasons

<span class="nc" id="L660">        JsonArrayBuilder obj = Json.createArrayBuilder();</span>
<span class="nc bnc" id="L661" title="All 2 branches missed.">        if (writtenInJustification.containsKey(label)</span>
<span class="nc bnc" id="L662" title="All 2 branches missed.">            &amp;&amp; writtenInJustification.get(label)) {</span>
<span class="nc" id="L663">          JsonReader jsonReader = Json.createReader(new BufferedInputStream(</span>
              new FileInputStream(filename)));
<span class="nc" id="L665">          JsonArray objarr = jsonReader.readArray();</span>
<span class="nc bnc" id="L666" title="All 2 branches missed.">          for (JsonValue o : objarr)</span>
<span class="nc" id="L667">            obj.add(o);</span>
<span class="nc" id="L668">          jsonReader.close();</span>

        }
<span class="nc" id="L671">        JsonArrayBuilder objThisIter = Json.createArrayBuilder();</span>

<span class="nc bnc" id="L673" title="All 2 branches missed.">        for (CandidatePhrase w : reasonForWords.firstKeySet()) {</span>
<span class="nc" id="L674">          JsonObjectBuilder objinner = Json.createObjectBuilder();</span>

<span class="nc" id="L676">          JsonArrayBuilder l = Json.createArrayBuilder();</span>
<span class="nc bnc" id="L677" title="All 2 branches missed.">          for (CandidatePhrase w2 : reasonForWords.getCounter(w).keySet()) {</span>
<span class="nc" id="L678">            l.add(w2.getPhrase());</span>
<span class="nc" id="L679">          }</span>
<span class="nc" id="L680">          JsonArrayBuilder pats = Json.createArrayBuilder();</span>
<span class="nc bnc" id="L681" title="All 2 branches missed.">          for (E p : wordsPatExtracted.getCounter(w)) {</span>
<span class="nc" id="L682">            pats.add(p.toStringSimple());</span>
<span class="nc" id="L683">          }</span>
<span class="nc" id="L684">          objinner.add(&quot;reasonwords&quot;, l);</span>
<span class="nc" id="L685">          objinner.add(&quot;patterns&quot;, pats);</span>
<span class="nc" id="L686">          objinner.add(&quot;score&quot;, finalwords.getCount(w));</span>
<span class="nc" id="L687">          objinner.add(&quot;entity&quot;, w.getPhrase());</span>
<span class="nc" id="L688">          objThisIter.add(objinner.build());</span>
<span class="nc" id="L689">        }</span>
<span class="nc" id="L690">        obj.add(objThisIter);</span>

        // Redwood.log(ConstantsAndVariables.minimaldebug, channelNameLogger,
        // &quot;Writing justification at &quot; + filename);
<span class="nc" id="L694">        IOUtils.writeStringToFile(StringUtils.normalize(StringUtils.toAscii(obj.build().toString())), filename, &quot;ASCII&quot;);</span>
<span class="nc" id="L695">        writtenInJustification.put(label, true);</span>
      }
<span class="nc bnc" id="L697" title="All 2 branches missed.">      if (constVars.justify) {</span>
<span class="nc" id="L698">        Redwood.log(Redwood.DBG, &quot;\nJustification for phrases:\n&quot;);</span>
<span class="nc bnc" id="L699" title="All 2 branches missed.">        for (CandidatePhrase word : finalwords.keySet()) {</span>
<span class="nc" id="L700">          Redwood.log(</span>
              Redwood.DBG, &quot;Phrase &quot; +
              word
                  + &quot; extracted because of patterns: \t&quot;
<span class="nc" id="L704">                  + Counters.toSortedString(wordsPatExtracted.getCounter(word),</span>
<span class="nc" id="L705">                      wordsPatExtracted.getCounter(word).size(), &quot;%1$s:%2$f&quot;,</span>
                      &quot;\n&quot;));
<span class="nc" id="L707">        }</span>
      }
      // if (usePatternResultAsLabel)
      // if (answerLabel != null)
      // labelWords(sents, commonEngWords, finalwords.keySet(),
      // patterns.keySet(), outFile);
      // else
      // throw new RuntimeException(&quot;why is the answer label null?&quot;);

<span class="nc" id="L716">      return finalwords;</span>
<span class="nc bnc" id="L717" title="All 2 branches missed.">    } else if (constVars.wordScoring.equals(WordScoring.BPB)) {</span>
<span class="nc" id="L718">      Counters.addInPlace(terms, wordsPatExtracted);</span>
<span class="nc" id="L719">      Counter&lt;CandidatePhrase&gt; maxPatWeightTerms = new ClassicCounter&lt;&gt;();</span>
<span class="nc" id="L720">      Map&lt;CandidatePhrase, E&gt; wordMaxPat = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L721" title="All 2 branches missed.">      for (Entry&lt;CandidatePhrase, ClassicCounter&lt;E&gt;&gt; en : terms.entrySet()) {</span>
<span class="nc" id="L722">        Counter&lt;E&gt; weights = new ClassicCounter&lt;&gt;();</span>
<span class="nc bnc" id="L723" title="All 2 branches missed.">        for (E k : en.getValue().keySet())</span>
<span class="nc" id="L724">          weights.setCount(k, patternsLearnedThisIter.getCount(k));</span>
<span class="nc" id="L725">        maxPatWeightTerms.setCount(en.getKey(), Counters.max(weights));</span>
<span class="nc" id="L726">        wordMaxPat.put(en.getKey(), Counters.argmax(weights));</span>
<span class="nc" id="L727">      }</span>
<span class="nc" id="L728">      Counters.removeKeys(maxPatWeightTerms, alreadyIdentifiedWords);</span>
<span class="nc" id="L729">      double maxvalue = Counters.max(maxPatWeightTerms);</span>
<span class="nc" id="L730">      Set&lt;CandidatePhrase&gt; words = Counters.keysAbove(maxPatWeightTerms,</span>
          maxvalue - 1e-10);
<span class="nc" id="L732">      CandidatePhrase bestw = null;</span>
<span class="nc bnc" id="L733" title="All 2 branches missed.">      if (words.size() &gt; 1) {</span>
<span class="nc" id="L734">        double max = Double.NEGATIVE_INFINITY;</span>
<span class="nc bnc" id="L735" title="All 2 branches missed.">        for (CandidatePhrase w : words) {</span>
<span class="nc bnc" id="L736" title="All 2 branches missed.">          if (terms.getCount(w, wordMaxPat.get(w)) &gt; max) {</span>
<span class="nc" id="L737">            max = terms.getCount(w, wordMaxPat.get(w));</span>
<span class="nc" id="L738">            bestw = w;</span>
          }
<span class="nc" id="L740">        }</span>
<span class="nc bnc" id="L741" title="All 2 branches missed.">      } else if (words.size() == 1)</span>
<span class="nc" id="L742">        bestw = words.iterator().next();</span>
      else
<span class="nc" id="L744">        return new ClassicCounter&lt;&gt;();</span>

<span class="nc" id="L746">      Redwood.log(ConstantsAndVariables.minimaldebug, &quot;Selected Words: &quot; + bestw);</span>

<span class="nc" id="L748">      return Counters.asCounter(Arrays.asList(bestw));</span>
    }

    else
<span class="nc" id="L752">      throw new RuntimeException(&quot;wordscoring &quot; + constVars.wordScoring</span>
          + &quot; not identified&quot;);
  }

  // private void combineExternalFeatures(Counter&lt;String&gt; words) {
  //
  // for (Entry&lt;String, Double&gt; en : words.entrySet()) {
  // Integer num = constVars.distSimClusters.get(en.getKey());
  // if (num == null)
  // num = -1;
  // // Double score = externalWeights.getCount(num);
  // // if not present in the clusters, take minimum of the scores of the
  // // individual words
  // // if (num == null) {
  // // for (String w : en.getKey().split(&quot;\\s+&quot;)) {
  // // Integer n = constVars.distSimClusters.get(w);
  // // if (n == null)
  // // continue;
  // // score = Math.min(score, externalWeights.getCount(n));
  // // }
  // // }
  // words.setCount(en.getKey(), en.getValue() *
  // constVars.distSimWeights.getCount(num));
  // }
  // }

  Counter&lt;String&gt; getLearnedScores() {
<span class="nc" id="L779">    return phraseScorer.getLearnedScores();</span>
  }

  // private Counter&lt;String&gt; getLookAheadWeights(Counter&lt;String&gt; words,
  // Counter&lt;String&gt; externalWordWeights, Set&lt;String&gt; alreadyIdentifiedWords,
  // String label,
  // Counter&lt;SurfacePattern&gt; currentAllPatternWeights,
  // TwoDimensionalCounter&lt;SurfacePattern, String&gt; allPatternsandWords) throws
  // IOException {
  // System.out.println(&quot;size of patterns weight counter is &quot; +
  // currentAllPatternWeights.size());
  //
  // DirectedWeightedMultigraph&lt;String, DefaultWeightedEdge&gt; graph = new
  // DirectedWeightedMultigraph&lt;String,
  // DefaultWeightedEdge&gt;(org.jgrapht.graph.DefaultWeightedEdge.class);
  //
  // if (Data.googleNGram.size() == 0) {
  // Data.loadGoogleNGrams();
  // }
  //
  // TwoDimensionalCounter&lt;String, SurfacePattern&gt; allPatsAndWords =
  // TwoDimensionalCounter.reverseIndexOrder(allPatternsandWords);
  // System.out.println(&quot;We have patterns for &quot; + allPatsAndWords.size() +
  // &quot; words &quot;);
  // TwoDimensionalCounter&lt;String, String&gt; lookaheadweights = new
  // TwoDimensionalCounter&lt;String, String&gt;();
  // // Counter&lt;String&gt; weights = new ClassicCounter&lt;String&gt;();
  //
  // for (Entry&lt;String, Double&gt; en : words.entrySet()) {
  // Counter&lt;SurfacePattern&gt; pats = new
  // ClassicCounter&lt;SurfacePattern&gt;(allPatsAndWords.getCounter(en.getKey()));
  // for (SurfacePattern p : pats.keySet()) {
  // pats.setCount(p, pats.getCount(p) * currentAllPatternWeights.getCount(p));
  // }
  //
  // for (Pair&lt;SurfacePattern, Double&gt; p : Counters.topKeysWithCounts(pats, 10))
  // {
  //
  // for (Entry&lt;String, Double&gt; pen :
  // allPatternsandWords.getCounter(p.first()).entrySet()) {
  // if (pen.getKey().equals(en.getKey()) ||
  // alreadyIdentifiedWords.contains(pen.getKey()) ||
  // constVars.otherSemanticClasses.contains(pen.getKey()))
  // continue;
  //
  // double ngramWt = 1.0;
  // if (Data.googleNGram.containsKey(pen.getKey())) {
  // assert (Data.rawFreq.containsKey(pen.getKey()));
  // ngramWt = (1 + Data.rawFreq.getCount(pen.getKey())) / (Data.rawFreq.size()
  // + Data.googleNGram.getCount(pen.getKey()));
  // }
  // double wordweight = ngramWt;// (minExternalWordWeight +
  // // externalWordWeights.getCount(pen.getKey()))
  // // * p.second() * (0.1 +
  // // currentAllPatternWeights.getCount(p.first()))
  // // * ;
  // // if (wordweight != 0)
  // if (wordweight == 0) {
  // // System.out.println(&quot;word weight is zero for &quot; + pen.getKey() +
  // // &quot; and the weights were &quot; +
  // // externalWordWeights.getCount(pen.getKey()) + &quot;;&quot; + p.second() +
  // // &quot;;&quot;
  // // + (0.1 + currentPatternWeights.getCount(p.first())) + &quot;;&quot; +
  // // ngramWt);
  // } else {
  // lookaheadweights.setCount(en.getKey(), pen.getKey(), Math.log(wordweight));
  // graph.addVertex(en.getKey());
  // graph.addVertex(pen.getKey());
  // DefaultWeightedEdge e = graph.addEdge(en.getKey(), pen.getKey());
  // graph.setEdgeWeight(e, lookaheadweights.getCount(en.getKey(),
  // pen.getKey()));
  // }
  //
  // }
  //
  // }
  // // weights.setCount(en.getKey(),
  // // Math.exp(Counters(lookaheadweights.getCounter(en.getKey()))));
  //
  // }
  // Counter&lt;String&gt; weights = new ClassicCounter&lt;String&gt;();
  // for (Entry&lt;String, ClassicCounter&lt;String&gt;&gt; en :
  // lookaheadweights.entrySet()) {
  // // List&lt;Pair&lt;String, Double&gt;&gt; sorted =
  // // Counters.toSortedListWithCounts(en.getValue());
  // // double val = sorted.get((int) Math.floor(sorted.size() / 2)).second();
  // double wt = Math.exp(en.getValue().totalCount() / en.getValue().size());
  //
  // weights.setCount(en.getKey(), wt);
  // }
  // // Counters.expInPlace(weights);
  // // List&lt;String&gt; tk = Counters.topKeys(weights, 50);
  // // BufferedWriter w = new BufferedWriter(new FileWriter(&quot;lookahead_&quot; +
  // // answerLabel, true));
  // // for (String s : tk) {
  // // w.write(s + &quot;\t&quot; + weights.getCount(s) + &quot;\t&quot; +
  // // lookaheadweights.getCounter(s) + &quot;\n&quot;);
  // // }
  // // w.close();
  // // BufferedWriter writer = new BufferedWriter(new FileWriter(&quot;graph.gdf&quot;));
  // // writeGraph(writer, graph);
  // System.out.println(&quot;done writing graph&quot;);
  // Redwood.log(ConstantsAndVariables.minimaldebug, &quot;calculated look ahead weights for &quot; +
  // weights.size() + &quot; words&quot;);
  //
  // return weights;
  // }

  // void writeGraph(BufferedWriter w, DirectedWeightedMultigraph&lt;String,
  // DefaultWeightedEdge&gt; g) throws IOException {
  // w.write(&quot;nodedef&gt;name VARCHAR\n&quot;);
  // for (String n : g.vertexSet()) {
  // w.write(n + &quot;\n&quot;);
  // }
  // w.write(&quot;edgedef&gt;node1 VARCHAR,node2 VARCHAR, weight DOUBLE\n&quot;);
  // for (DefaultWeightedEdge e : g.edgeSet()) {
  // w.write(g.getEdgeSource(e) + &quot;,&quot; + g.getEdgeTarget(e) + &quot;,&quot; +
  // g.getEdgeWeight(e) + &quot;\n&quot;);
  // }
  // w.close();
  // }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>