<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GetPatternsFromDataMultiClass.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.patterns</a> &gt; <span class="el_source">GetPatternsFromDataMultiClass.java</span></div><h1>GetPatternsFromDataMultiClass.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.patterns;

import java.io.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.sql.SQLException;
import java.text.DecimalFormat;
import java.util.*;
import java.util.Map.Entry;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Function;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;


import javax.json.*;

import edu.stanford.nlp.io.IOUtils;
import edu.stanford.nlp.io.RegExFileFilter;
import edu.stanford.nlp.ling.CoreAnnotations;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.ling.CoreAnnotations.GoldAnswerAnnotation;
import edu.stanford.nlp.ling.IndexedWord;
import edu.stanford.nlp.ling.tokensregex.Env;
import edu.stanford.nlp.ling.tokensregex.TokenSequencePattern;
import edu.stanford.nlp.patterns.dep.DataInstanceDep;
import edu.stanford.nlp.patterns.surface.*;
import edu.stanford.nlp.patterns.ConstantsAndVariables.ScorePhraseMeasures;
import edu.stanford.nlp.pipeline.Annotation;
import edu.stanford.nlp.pipeline.StanfordCoreNLP;
import edu.stanford.nlp.semgraph.SemanticGraph;
import edu.stanford.nlp.semgraph.SemanticGraphEdge;
import edu.stanford.nlp.sequences.IOBUtils;
import edu.stanford.nlp.stats.ClassicCounter;
import edu.stanford.nlp.stats.Counter;
import edu.stanford.nlp.stats.Counters;
import edu.stanford.nlp.stats.TwoDimensionalCounter;
import edu.stanford.nlp.trees.GrammaticalRelation;
import edu.stanford.nlp.trees.Tree;
import edu.stanford.nlp.trees.TreeCoreAnnotations.TreeAnnotation;
import edu.stanford.nlp.util.*;
import edu.stanford.nlp.util.PriorityQueue;
import edu.stanford.nlp.util.TypesafeMap.Key;
import edu.stanford.nlp.util.logging.Redwood;
import org.joda.time.Interval;
import org.joda.time.Period;

/**
 * Given text and a seed list, this class gives more words like the seed words
 * by learning surface word or dependency patterns.
 * &lt;p&gt;
 *
 * The multi-threaded class ({@code nthread} parameter for number of
 * threads) takes as input.
 *
 * To use the default options, run
 * &lt;p&gt;
 * {@code java -mx1000m edu.stanford.nlp.patterns.GetPatternsFromDataMultiClass -file text_file -seedWordsFiles label1,seedwordlist1;label2,seedwordlist2;... -outDir output_directory (optional)}
 * &lt;p&gt;
 *
 * {@code fileFormat}: (Optional) Default is text. Valid values are text
 * (or txt) and ser, where the serialized file is of the type {@code Map&lt;String,List&lt;CoreLabel&gt;&gt;}.
 * &lt;p&gt;
 * {@code file}: (Required) Input file(s) (default assumed text). Can be
 * one or more of (concatenated by comma or semi-colon): file, directory, files
 * with regex in the filename (for example: &quot;mydir/health-.*-processed.txt&quot;)
 * &lt;p&gt;
 * {@code seedWordsFiles}: (Required)
 * label1,file_seed_words1;label2,file_seed_words2;... where file_seed_words are
 * files with list of seed words, one in each line
 * &lt;p&gt;
 * {@code outDir}: (Optional) output directory where visualization/output
 * files are stored
 * &lt;p&gt;
 * For other flags, see individual comments for each flag.
 *
 * &lt;p&gt;
 * To use a properties file, see
 * projects/core/data/edu/stanford/nlp/patterns/surface/example.properties or patterns/example.properties (depends on which codebase you are using)
 * as an example for the flags and their brief descriptions. Run the code as:
 * {@code java -mx1000m -cp classpath edu.stanford.nlp.patterns.GetPatternsFromDataMultiClass -props dir-as-above/example.properties}
 *
 * &lt;p&gt;
 * IMPORTANT: Many flags are described in the classes
 * {@link ConstantsAndVariables}, {@link edu.stanford.nlp.patterns.surface.CreatePatterns}, and
 * {@link PhraseScorer}.
 *
 * @author Sonal Gupta (sonal@cs.stanford.edu)
 */

<span class="pc bpc" id="L93" title="1 of 2 branches missed.">public class GetPatternsFromDataMultiClass&lt;E extends Pattern&gt; implements Serializable  {</span>

  /** A logger for this class */
<span class="fc" id="L96">  private static Redwood.RedwoodChannels log = Redwood.channels(GetPatternsFromDataMultiClass.class);</span>

  private static final long serialVersionUID = 1L;

  //public Map&lt;String, Map&lt;Integer, Set&lt;E&gt;&gt;&gt; patternsForEachToken = null;

<span class="nc" id="L102">  private PatternsForEachToken&lt;E&gt; patsForEachToken = null;</span>

<span class="nc" id="L104">  public Map&lt;String, Set&lt;String&gt;&gt; wordsForOtherClass = null;</span>

  // String channelNameLogger = &quot;patterns&quot;;
  /**
   *
   * RlogF is from Riloff 1996, when R's denominator is (pos+neg+unlabeled)
   * &lt;p&gt;
   * RlogFPosNeg is when the R's denominator is just (pos+negative) examples
   * &lt;p&gt;
   * PosNegOdds is just the ratio of number of positive words to number of
   * negative
   * &lt;p&gt;
   * PosNegUnlabOdds is just the ratio of number of positive words to number of
   * negative (unlabeled words + negative)
   * &lt;p&gt;
   * RatioAll is pos/(neg+pos+unlabeled)
   * &lt;p&gt;
   * YanGarber02 is the modified version presented in
   * &quot;Unsupervised Learning of Generalized Names&quot;
   * &lt;p&gt;
   * LOGREG is learning a logistic regression classifier to combine weights to
   * score a phrase (Same as PhEvalInPat, except score of an unlabeled phrase is
   * computed using a logistic regression classifier)
   * &lt;p&gt;
   * LOGREGlogP is learning a logistic regression classifier to combine weights
   * to score a phrase (Same as PhEvalInPatLogP, except score of an unlabeled
   * phrase is computed using a logistic regression classifier)
   * &lt;p&gt;
   * SqrtAllRatio is the pattern scoring used in Gupta et al. JAMIA 2014 paper
   * &lt;p&gt;
   * Below F1SeedPattern and BPB based on paper
   * &quot;Unsupervised Method for Automatics Construction of a disease dictionary...&quot;
   * &lt;p&gt;
   * Precision, Recall, and FMeasure (controlled by fbeta flag) is ranking the patterns using
   * their precision, recall and F_beta measure
   */
<span class="pc" id="L140">  public enum PatternScoring {</span>
<span class="fc" id="L141">    F1SeedPattern, RlogF, RlogFPosNeg, RlogFUnlabNeg, RlogFNeg, PhEvalInPat, PhEvalInPatLogP, PosNegOdds,</span>
<span class="fc" id="L142">    YanGarber02, PosNegUnlabOdds, RatioAll, LOGREG, LOGREGlogP, SqrtAllRatio, LinICML03, kNN</span>
  }

<span class="pc" id="L145">  enum WordScoring {</span>
<span class="fc" id="L146">    BPB, WEIGHTEDNORM</span>
  }

<span class="nc" id="L149">  private Map&lt;String, Boolean&gt; writtenPatInJustification = new HashMap&lt;&gt;();</span>

<span class="nc" id="L151">  private Map&lt;String, Counter&lt;E&gt;&gt; learnedPatterns = new HashMap&lt;&gt;();</span>
  //Same as learnedPatterns but with iteration information
<span class="nc" id="L153">  private Map&lt;String, Map&lt;Integer, Counter&lt;E&gt;&gt;&gt; learnedPatternsEachIter = new HashMap&lt;&gt;();</span>
<span class="nc" id="L154">  Map&lt;String, Counter&lt;CandidatePhrase&gt;&gt; matchedSeedWords = new HashMap&lt;&gt;();</span>
<span class="nc" id="L155">  public Map&lt;String, TwoDimensionalCounter&lt;CandidatePhrase, E&gt;&gt; wordsPatExtracted = new HashMap&lt;&gt;();</span>

  Properties props;
  public ScorePhrases scorePhrases;
  public ConstantsAndVariables constVars;
  public CreatePatterns createPats;

<span class="nc" id="L162">  private final DecimalFormat df = new DecimalFormat(&quot;#.##&quot;);</span>

<span class="nc" id="L164">  private boolean notComputedAllPatternsYet = true;</span>

  /*
   * when there is only one label
   */
  public GetPatternsFromDataMultiClass(Properties props, Map&lt;String, DataInstance&gt; sents, Set&lt;CandidatePhrase&gt; seedSet, boolean labelUsingSeedSets,
      String answerLabel) throws IOException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException,
      NoSuchMethodException, SecurityException, InterruptedException, ExecutionException, ClassNotFoundException {
<span class="nc" id="L172">    this(props, sents, seedSet, labelUsingSeedSets, PatternsAnnotations.PatternLabel1.class, answerLabel);</span>
<span class="nc" id="L173">  }</span>

  @SuppressWarnings(&quot;rawtypes&quot;)
  public GetPatternsFromDataMultiClass(Properties props, Map&lt;String, DataInstance&gt; sents, Set&lt;CandidatePhrase&gt; seedSet, boolean labelUsingSeedSets,
      Class answerClass, String answerLabel) throws IOException, InstantiationException, IllegalAccessException, IllegalArgumentException,
<span class="nc" id="L178">      InvocationTargetException, NoSuchMethodException, SecurityException, InterruptedException, ExecutionException, ClassNotFoundException {</span>
<span class="nc" id="L179">    this.props = props;</span>
<span class="nc" id="L180">    Map&lt;String, Class&lt;? extends TypesafeMap.Key&lt;String&gt;&gt;&gt; ansCl = new HashMap&lt;&gt;();</span>
<span class="nc" id="L181">    ansCl.put(answerLabel, answerClass);</span>

<span class="nc" id="L183">    Map&lt;String, Class&gt; generalizeClasses = new HashMap&lt;&gt;();</span>

<span class="nc" id="L185">    Map&lt;String, Map&lt;Class, Object&gt;&gt; ignoreClasses = new HashMap&lt;&gt;();</span>
<span class="nc" id="L186">    ignoreClasses.put(answerLabel, new HashMap&lt;&gt;());</span>

<span class="nc" id="L188">    Map&lt;String, Set&lt;CandidatePhrase&gt;&gt; seedSets = new HashMap&lt;&gt;();</span>
<span class="nc" id="L189">    seedSets.put(answerLabel, seedSet);</span>
<span class="nc" id="L190">    setUpConstructor(sents, seedSets, labelUsingSeedSets, ansCl, generalizeClasses, ignoreClasses);</span>

<span class="nc" id="L192">  }</span>

  @SuppressWarnings(&quot;rawtypes&quot;)
  public GetPatternsFromDataMultiClass(Properties props, Map&lt;String, DataInstance&gt; sents, Set&lt;CandidatePhrase&gt; seedSet, boolean labelUsingSeedSets,
      String answerLabel, Map&lt;String, Class&gt; generalizeClasses, Map&lt;Class, Object&gt; ignoreClasses) throws IOException, InstantiationException,
      IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SecurityException, InterruptedException,
      ExecutionException, ClassNotFoundException {
<span class="nc" id="L199">    this(props, sents, seedSet, labelUsingSeedSets, PatternsAnnotations.PatternLabel1.class, answerLabel, generalizeClasses, ignoreClasses);</span>
<span class="nc" id="L200">  }</span>

  @SuppressWarnings(&quot;rawtypes&quot;)
  public GetPatternsFromDataMultiClass(Properties props, Map&lt;String, DataInstance&gt; sents, Set&lt;CandidatePhrase&gt; seedSet, boolean labelUsingSeedSets,
      Class answerClass, String answerLabel, Map&lt;String, Class&gt; generalizeClasses, Map&lt;Class, Object&gt; ignoreClasses) throws IOException,
      InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SecurityException,
<span class="nc" id="L206">      InterruptedException, ExecutionException, ClassNotFoundException {</span>
<span class="nc" id="L207">    this.props = props;</span>
<span class="nc" id="L208">    Map&lt;String, Class&lt;? extends TypesafeMap.Key&lt;String&gt;&gt;&gt; ansCl = new HashMap&lt;&gt;();</span>
<span class="nc" id="L209">    ansCl.put(answerLabel, answerClass);</span>

<span class="nc" id="L211">    Map&lt;String, Map&lt;Class, Object&gt;&gt; iC = new HashMap&lt;&gt;();</span>
<span class="nc" id="L212">    iC.put(answerLabel, ignoreClasses);</span>

<span class="nc" id="L214">    Map&lt;String, Set&lt;CandidatePhrase&gt;&gt; seedSets = new HashMap&lt;&gt;();</span>
<span class="nc" id="L215">    seedSets.put(answerLabel, seedSet);</span>
<span class="nc" id="L216">    setUpConstructor(sents, seedSets, labelUsingSeedSets, ansCl, generalizeClasses, iC);</span>
<span class="nc" id="L217">  }</span>

  @SuppressWarnings(&quot;rawtypes&quot;)
  public GetPatternsFromDataMultiClass(Properties props, Map&lt;String, DataInstance&gt; sents, Map&lt;String, Set&lt;CandidatePhrase&gt;&gt; seedSets,
      boolean labelUsingSeedSets) throws IOException, InstantiationException, IllegalAccessException, IllegalArgumentException,
<span class="nc" id="L222">      InvocationTargetException, NoSuchMethodException, SecurityException, ClassNotFoundException, InterruptedException, ExecutionException {</span>
<span class="nc" id="L223">    this.props = props;</span>
<span class="nc" id="L224">    Map&lt;String, Class&lt;? extends TypesafeMap.Key&lt;String&gt;&gt;&gt; ansCl = new HashMap&lt;&gt;();</span>
<span class="nc" id="L225">    Map&lt;String, Class&gt; gC = new HashMap&lt;&gt;();</span>
<span class="nc" id="L226">    Map&lt;String, Map&lt;Class, Object&gt;&gt; iC = new HashMap&lt;&gt;();</span>
<span class="nc" id="L227">    int i = 1;</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">    for (String label : seedSets.keySet()) {</span>
<span class="nc" id="L229">      String ansclstr = &quot;edu.stanford.nlp.patterns.PatternsAnnotations$PatternLabel&quot; + i;</span>
<span class="nc" id="L230">      ansCl.put(label, (Class&lt;? extends Key&lt;String&gt;&gt;) Class.forName(ansclstr));</span>
<span class="nc" id="L231">      iC.put(label, new HashMap&lt;&gt;());</span>
<span class="nc" id="L232">      i++;</span>
<span class="nc" id="L233">    }</span>

<span class="nc" id="L235">    setUpConstructor(sents, seedSets, labelUsingSeedSets, ansCl, gC, iC);</span>
<span class="nc" id="L236">  }</span>

  @SuppressWarnings(&quot;rawtypes&quot;)
  public GetPatternsFromDataMultiClass(Properties props, Map&lt;String, DataInstance&gt; sents, Map&lt;String, Set&lt;CandidatePhrase&gt;&gt; seedSets,
      boolean labelUsingSeedSets, Map&lt;String, Class&lt;? extends TypesafeMap.Key&lt;String&gt;&gt;&gt; answerClass) throws IOException, InstantiationException,
      IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SecurityException, InterruptedException,
      ExecutionException, ClassNotFoundException {
<span class="nc" id="L243">    this(props, sents, seedSets, labelUsingSeedSets, answerClass, new HashMap&lt;&gt;(), new HashMap&lt;&gt;());</span>
<span class="nc" id="L244">  }</span>

  /**
   * Generalize classes basically maps label strings to a map of generalized
   * strings and the corresponding class ignoreClasses have to be boolean.
   *
   * @throws IOException
   * @throws SecurityException
   * @throws NoSuchMethodException
   * @throws InvocationTargetException
   * @throws IllegalArgumentException
   * @throws IllegalAccessException
   * @throws InstantiationException
   * @throws ExecutionException
   * @throws InterruptedException
   * @throws ClassNotFoundException
   */
  @SuppressWarnings(&quot;rawtypes&quot;)
  public GetPatternsFromDataMultiClass(Properties props, Map&lt;String, DataInstance&gt; sents, Map&lt;String, Set&lt;CandidatePhrase&gt;&gt; seedSets,
      boolean labelUsingSeedSets, Map&lt;String, Class&lt;? extends TypesafeMap.Key&lt;String&gt;&gt;&gt; answerClass, Map&lt;String, Class&gt; generalizeClasses,
      Map&lt;String, Map&lt;Class, Object&gt;&gt; ignoreClasses) throws IOException, InstantiationException, IllegalAccessException, IllegalArgumentException,
<span class="nc" id="L265">      InvocationTargetException, NoSuchMethodException, SecurityException, InterruptedException, ExecutionException, ClassNotFoundException {</span>
<span class="nc" id="L266">    this.props = props;</span>

<span class="nc bnc" id="L268" title="All 2 branches missed.">    if (ignoreClasses.isEmpty()) {</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">      for (String label : seedSets.keySet())</span>
<span class="nc" id="L270">        ignoreClasses.put(label, new HashMap&lt;&gt;());</span>
    }
<span class="nc" id="L272">    setUpConstructor(sents, seedSets, labelUsingSeedSets, answerClass, generalizeClasses, ignoreClasses);</span>
<span class="nc" id="L273">  }</span>

  @SuppressWarnings(&quot;rawtypes&quot;)
  private void setUpConstructor(Map&lt;String, DataInstance&gt; sents, Map&lt;String, Set&lt;CandidatePhrase&gt;&gt; seedSets, boolean labelUsingSeedSets,
      Map&lt;String, Class&lt;? extends TypesafeMap.Key&lt;String&gt;&gt;&gt; answerClass, Map&lt;String, Class&gt; generalizeClasses,
      Map&lt;String, Map&lt;Class, Object&gt;&gt; ignoreClasses) throws IOException, InstantiationException, IllegalAccessException, IllegalArgumentException,
      InvocationTargetException, NoSuchMethodException, SecurityException, InterruptedException, ExecutionException, ClassNotFoundException {

<span class="nc" id="L281">    Data.sents = sents;</span>
<span class="nc" id="L282">    ArgumentParser.fillOptions(Data.class, props);</span>
<span class="nc" id="L283">    ArgumentParser.fillOptions(ConstantsAndVariables.class, props);</span>
<span class="nc" id="L284">    PatternFactory.setUp(props, PatternFactory.PatternType.valueOf(props.getProperty(Flags.patternType)), seedSets.keySet());</span>

<span class="nc" id="L286">    constVars = new ConstantsAndVariables(props, seedSets, answerClass, generalizeClasses, ignoreClasses);</span>

<span class="nc bnc" id="L288" title="All 4 branches missed.">    if (constVars.writeMatchedTokensFiles &amp;&amp; constVars.batchProcessSents) {</span>
<span class="nc" id="L289">      throw new RuntimeException(</span>
          &quot;writeMatchedTokensFiles and batchProcessSents cannot be true at the same time (not implemented; also doesn't make sense to save a large sentences json file)&quot;);
    }

<span class="nc bnc" id="L293" title="All 2 branches missed.">    if (constVars.debug &lt; 1) {</span>
<span class="nc" id="L294">      Redwood.hideChannelsEverywhere(ConstantsAndVariables.minimaldebug);</span>
    }

<span class="nc bnc" id="L297" title="All 2 branches missed.">    if (constVars.debug &lt; 2) {</span>
<span class="nc" id="L298">      Redwood.hideChannelsEverywhere(Redwood.DBG);</span>
    }
<span class="nc" id="L300">    constVars.justify = true;</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">    if (constVars.debug &lt; 3) {</span>
<span class="nc" id="L302">      constVars.justify = false;</span>
    }
<span class="nc bnc" id="L304" title="All 2 branches missed.">    if (constVars.debug &lt; 4) {</span>
<span class="nc" id="L305">      Redwood.hideChannelsEverywhere(ConstantsAndVariables.extremedebug);</span>
    }

<span class="nc" id="L308">    Redwood.log(Redwood.DBG, &quot;Running with debug output&quot;);</span>
<span class="nc" id="L309">    Redwood.log(ConstantsAndVariables.extremedebug, &quot;Running with extreme debug output&quot;);</span>

<span class="nc" id="L311">    wordsPatExtracted = new HashMap&lt;&gt;();</span>

<span class="nc bnc" id="L313" title="All 2 branches missed.">    for (String label : answerClass.keySet()) {</span>
<span class="nc" id="L314">      wordsPatExtracted.put(label, new TwoDimensionalCounter&lt;&gt;());</span>
<span class="nc" id="L315">    }</span>

<span class="nc" id="L317">    scorePhrases = new ScorePhrases(props, constVars);</span>
<span class="nc" id="L318">    createPats = new CreatePatterns(props, constVars);</span>
<span class="nc bnc" id="L319" title="All 8 branches missed.">    assert !(constVars.doNotApplyPatterns &amp;&amp; (PatternFactory.useStopWordsBeforeTerm || PatternFactory.numWordsCompoundMax &gt; 1)) : &quot; Cannot have both doNotApplyPatterns and (useStopWordsBeforeTerm true or numWordsCompound &gt; 1)!&quot;;</span>

<span class="nc bnc" id="L321" title="All 2 branches missed.">    if(constVars.invertedIndexDirectory == null){</span>
<span class="nc" id="L322">      File f  = File.createTempFile(&quot;inv&quot;,&quot;index&quot;);</span>
<span class="nc" id="L323">      f.deleteOnExit();</span>
<span class="nc" id="L324">      f.mkdir();</span>
<span class="nc" id="L325">      constVars.invertedIndexDirectory = f.getAbsolutePath();</span>
    }

<span class="nc" id="L328">    Set&lt;String&gt; extremelySmallStopWordsList = CollectionUtils.asSet(&quot;.&quot;, &quot;,&quot;, &quot;in&quot;, &quot;on&quot;, &quot;of&quot;, &quot;a&quot;, &quot;the&quot;, &quot;an&quot;);</span>

    //Function to use to how to add CoreLabels to index
<span class="nc" id="L331">    Function&lt;CoreLabel, Map&lt;String, String&gt;&gt; transformCoreLabelToString = l -&gt; {</span>
<span class="nc" id="L332">      Map&lt;String, String&gt; add = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">      for (Class gn: constVars.getGeneralizeClasses().values()) {</span>
<span class="nc" id="L334">        Object b  = l.get(gn);</span>
<span class="nc bnc" id="L335" title="All 4 branches missed.">        if (b != null &amp;&amp; !b.toString().equals(constVars.backgroundSymbol)) {</span>
<span class="nc" id="L336">          add.put(Token.getKeyForClass(gn),b.toString());</span>
        }
<span class="nc" id="L338">      }</span>
<span class="nc" id="L339">      return add;</span>
    };

<span class="nc" id="L342">    boolean createIndex = false;</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">    if (constVars.loadInvertedIndex)</span>
<span class="nc" id="L344">      constVars.invertedIndex = SentenceIndex.loadIndex(constVars.invertedIndexClass, props, extremelySmallStopWordsList, constVars.invertedIndexDirectory, transformCoreLabelToString);</span>
    else {
<span class="nc" id="L346">      constVars.invertedIndex = SentenceIndex.createIndex(constVars.invertedIndexClass, null, props, extremelySmallStopWordsList, constVars.invertedIndexDirectory, transformCoreLabelToString);</span>
<span class="nc" id="L347">      createIndex = true;</span>
    }

<span class="nc" id="L350">    int totalNumSents = 0;</span>

<span class="nc" id="L352">    boolean computeDataFreq = false;</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">    if (Data.rawFreq == null) {</span>
<span class="nc" id="L354">      Data.rawFreq = new ClassicCounter&lt;&gt;();</span>
<span class="nc" id="L355">      computeDataFreq = true;</span>
    }

<span class="nc" id="L358">    ConstantsAndVariables.DataSentsIterator iter = new ConstantsAndVariables.DataSentsIterator(constVars.batchProcessSents);</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">    while(iter.hasNext()){</span>
<span class="nc" id="L360">      Pair&lt;Map&lt;String, DataInstance&gt;, File&gt; sentsIter = iter.next();</span>
<span class="nc" id="L361">      Map&lt;String, DataInstance&gt; sentsf = sentsIter.first();</span>

<span class="nc bnc" id="L363" title="All 2 branches missed.">      if(constVars.batchProcessSents) {</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">        for (Entry&lt;String, DataInstance&gt; en : sentsf.entrySet()) {</span>
<span class="nc" id="L365">          Data.sentId2File.put(en.getKey(), sentsIter.second());</span>
<span class="nc" id="L366">        }</span>
      }

<span class="nc" id="L369">      totalNumSents += sentsf.size();</span>

<span class="nc bnc" id="L371" title="All 2 branches missed.">      if(computeDataFreq){</span>
<span class="nc" id="L372">        Data.computeRawFreqIfNull(sentsf, PatternFactory.numWordsCompoundMax);</span>
      }


<span class="nc" id="L376">      Redwood.log(Redwood.DBG, &quot;Initializing sents size &quot; + sentsf.size()</span>
        + &quot; sentences, either by labeling with the seed set or just setting the right classes&quot;);
<span class="nc bnc" id="L378" title="All 2 branches missed.">      for (String l : constVars.getAnswerClass().keySet()) {</span>
<span class="nc bnc" id="L379" title="All 2 branches missed.">        Redwood.log(Redwood.DBG, &quot;labelUsingSeedSets is &quot; + labelUsingSeedSets + &quot; and seed set size for &quot; + l + &quot; is &quot; + (seedSets == null?&quot;null&quot;:seedSets.get(l).size()));</span>

<span class="nc bnc" id="L381" title="All 6 branches missed.">        Set&lt;CandidatePhrase&gt; seed = seedSets == null || !labelUsingSeedSets ? new HashSet&lt;&gt;() : (seedSets.containsKey(l) ? seedSets.get(l)</span>
          : new HashSet&lt;&gt;());

<span class="nc bnc" id="L384" title="All 2 branches missed.">        if(!matchedSeedWords.containsKey(l)){</span>
<span class="nc" id="L385">          matchedSeedWords.put(l, new ClassicCounter&lt;&gt;());</span>
        }
<span class="nc" id="L387">        Counter&lt;CandidatePhrase&gt; matched = runLabelSeedWords(sentsf, constVars.getAnswerClass().get(l), l, seed, constVars, labelUsingSeedSets);</span>
<span class="nc" id="L388">        System.out.println(&quot;matched phrases for &quot; + l + &quot; is &quot; + matched);</span>
<span class="nc" id="L389">        matchedSeedWords.get(l).addAll(matched);</span>


<span class="nc bnc" id="L392" title="All 2 branches missed.">        if (constVars.addIndvWordsFromPhrasesExceptLastAsNeg) {</span>
<span class="nc" id="L393">          Redwood.log(ConstantsAndVariables.minimaldebug, &quot;adding indv words from phrases except last as neg&quot;);</span>
<span class="nc" id="L394">          Set&lt;CandidatePhrase&gt; otherseed = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">          if(labelUsingSeedSets){</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">            for (CandidatePhrase s : seed) {</span>
<span class="nc" id="L397">              String[] t = s.getPhrase().split(&quot;\\s+&quot;);</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">              for (int i = 0; i &lt; t.length - 1; i++) {</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">                if (!seed.contains(t[i])) {</span>
<span class="nc" id="L400">                  otherseed.add(CandidatePhrase.createOrGet(t[i]));</span>
                }
              }
<span class="nc" id="L403">            }</span>
          }

<span class="nc" id="L406">          runLabelSeedWords(sentsf, PatternsAnnotations.OtherSemanticLabel.class, &quot;OTHERSEM&quot;, otherseed, constVars, labelUsingSeedSets);</span>
        }

<span class="nc" id="L409">      }</span>

<span class="nc bnc" id="L411" title="All 4 branches missed.">      if (labelUsingSeedSets &amp;&amp; constVars.getOtherSemanticClassesWords() != null) {</span>
<span class="nc" id="L412">        String l = &quot;OTHERSEM&quot;;</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">        if(!matchedSeedWords.containsKey(l)){</span>
<span class="nc" id="L414">          matchedSeedWords.put(l, new ClassicCounter&lt;&gt;());</span>
        }
<span class="nc" id="L416">        matchedSeedWords.get(l).addAll(runLabelSeedWords(sentsf, PatternsAnnotations.OtherSemanticLabel.class, l, constVars.getOtherSemanticClassesWords(), constVars, labelUsingSeedSets));</span>
      }

<span class="nc bnc" id="L419" title="All 2 branches missed.">      if(constVars.removeOverLappingLabelsFromSeed){</span>
<span class="nc" id="L420">        removeOverLappingLabels(sentsf);</span>
      }

<span class="nc bnc" id="L423" title="All 2 branches missed.">      if(createIndex)</span>
<span class="nc" id="L424">        constVars.invertedIndex.add(sentsf, true);</span>

<span class="nc bnc" id="L426" title="All 2 branches missed.">      if(sentsIter.second().exists()){</span>
<span class="nc" id="L427">        Redwood.log(Redwood.DBG, &quot;Saving the labeled seed sents (if given the option) to the same file &quot; + sentsIter.second());</span>
<span class="nc" id="L428">        IOUtils.writeObjectToFile(sentsf, sentsIter.second());</span>
      }

<span class="nc" id="L431">    }</span>


<span class="nc" id="L434">    Redwood.log(Redwood.DBG, &quot;Done loading/creating inverted index of tokens and labeling data with total of &quot;</span>
<span class="nc" id="L435">        + constVars.invertedIndex.size() + &quot; sentences&quot;);</span>

    //If the scorer class is LearnFeatWt then individual word class is added as a feature
<span class="nc bnc" id="L438" title="All 6 branches missed.">    if (scorePhrases.phraseScorerClass.equals(ScorePhrasesAverageFeatures.class) &amp;&amp; (constVars.usePatternEvalWordClass || constVars.usePhraseEvalWordClass)) {</span>

<span class="nc bnc" id="L440" title="All 2 branches missed.">      if (constVars.externalFeatureWeightsDir == null) {</span>
<span class="nc" id="L441">        File f = File.createTempFile(&quot;tempfeat&quot;, &quot;.txt&quot;);</span>
<span class="nc" id="L442">        f.delete();</span>
<span class="nc" id="L443">        f.deleteOnExit();</span>
<span class="nc" id="L444">        constVars.externalFeatureWeightsDir = f.getAbsolutePath();</span>
      }

<span class="nc" id="L447">      IOUtils.ensureDir(new File(constVars.externalFeatureWeightsDir));</span>

<span class="nc bnc" id="L449" title="All 2 branches missed.">      for (String label : seedSets.keySet()) {</span>
<span class="nc" id="L450">        String externalFeatureWeightsFileLabel = constVars.externalFeatureWeightsDir + &quot;/&quot; + label;</span>
<span class="nc" id="L451">        File f = new File(externalFeatureWeightsFileLabel);</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">        if (!f.exists()) {</span>
<span class="nc" id="L453">          Redwood.log(Redwood.DBG, &quot;externalweightsfile for the label &quot; + label + &quot; does not exist: learning weights!&quot;);</span>
<span class="nc" id="L454">          LearnImportantFeatures lmf = new LearnImportantFeatures();</span>
<span class="nc" id="L455">          ArgumentParser.fillOptions(lmf, props);</span>
<span class="nc" id="L456">          lmf.answerClass = answerClass.get(label);</span>
<span class="nc" id="L457">          lmf.answerLabel = label;</span>
<span class="nc" id="L458">          lmf.setUp();</span>
<span class="nc" id="L459">          lmf.getTopFeatures(new ConstantsAndVariables.DataSentsIterator(constVars.batchProcessSents), constVars.perSelectRand, constVars.perSelectNeg,</span>
              externalFeatureWeightsFileLabel);

        }
<span class="nc" id="L463">        Counter&lt;Integer&gt; distSimWeightsLabel = new ClassicCounter&lt;&gt;();</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">        for (String line : IOUtils.readLines(externalFeatureWeightsFileLabel)) {</span>
<span class="nc" id="L465">          String[] t = line.split(&quot;:&quot;);</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">          if (!t[0].startsWith(&quot;Cluster&quot;))</span>
<span class="nc" id="L467">            continue;</span>
<span class="nc" id="L468">          String s = t[0].replace(&quot;Cluster-&quot;, &quot;&quot;);</span>
<span class="nc" id="L469">          Integer clusterNum = Integer.parseInt(s);</span>
<span class="nc" id="L470">          distSimWeightsLabel.setCount(clusterNum, Double.parseDouble(t[1]));</span>
<span class="nc" id="L471">        }</span>
<span class="nc" id="L472">        constVars.distSimWeights.put(label, distSimWeightsLabel);</span>
<span class="nc" id="L473">      }</span>
    }

    // computing semantic odds values
<span class="nc bnc" id="L477" title="All 4 branches missed.">    if (constVars.usePatternEvalSemanticOdds || constVars.usePhraseEvalSemanticOdds) {</span>
<span class="nc" id="L478">      Counter&lt;CandidatePhrase&gt; dictOddsWeightsLabel = new ClassicCounter&lt;&gt;();</span>
<span class="nc" id="L479">      Counter&lt;CandidatePhrase&gt; otherSemanticClassFreq = new ClassicCounter&lt;&gt;();</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">      for (CandidatePhrase s : constVars.getOtherSemanticClassesWords()) {</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">        for (String s1 : StringUtils.getNgrams(Arrays.asList(s.getPhrase().split(&quot;\\s+&quot;)), 1, PatternFactory.numWordsCompoundMax))</span>
<span class="nc" id="L482">          otherSemanticClassFreq.incrementCount(CandidatePhrase.createOrGet(s1));</span>
<span class="nc" id="L483">      }</span>
<span class="nc" id="L484">      otherSemanticClassFreq = Counters.add(otherSemanticClassFreq, 1.0);</span>
      // otherSemanticClassFreq.setDefaultReturnValue(1.0);

<span class="nc" id="L487">      Map&lt;String, Counter&lt;CandidatePhrase&gt;&gt; labelDictNgram = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L488" title="All 2 branches missed.">      for (String label : seedSets.keySet()) {</span>
<span class="nc" id="L489">        Counter&lt;CandidatePhrase&gt; classFreq = new ClassicCounter&lt;&gt;();</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">        for (CandidatePhrase s : seedSets.get(label)) {</span>
<span class="nc bnc" id="L491" title="All 2 branches missed.">          for (String s1 : StringUtils.getNgrams(Arrays.asList(s.getPhrase().split(&quot;\\s+&quot;)), 1, PatternFactory.numWordsCompoundMax))</span>
<span class="nc" id="L492">            classFreq.incrementCount(CandidatePhrase.createOrGet(s1));</span>
<span class="nc" id="L493">        }</span>
<span class="nc" id="L494">        classFreq = Counters.add(classFreq, 1.0);</span>
<span class="nc" id="L495">        labelDictNgram.put(label, classFreq);</span>
        // classFreq.setDefaultReturnValue(1.0);
<span class="nc" id="L497">      }</span>

<span class="nc bnc" id="L499" title="All 2 branches missed.">      for (String label : seedSets.keySet()) {</span>
<span class="nc" id="L500">        Counter&lt;CandidatePhrase&gt; otherLabelFreq = new ClassicCounter&lt;&gt;();</span>
<span class="nc bnc" id="L501" title="All 2 branches missed.">        for (String label2 : seedSets.keySet()) {</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">          if (label.equals(label2))</span>
<span class="nc" id="L503">            continue;</span>
<span class="nc" id="L504">          otherLabelFreq.addAll(labelDictNgram.get(label2));</span>
<span class="nc" id="L505">        }</span>
<span class="nc" id="L506">        otherLabelFreq.addAll(otherSemanticClassFreq);</span>
<span class="nc" id="L507">        dictOddsWeightsLabel = Counters.divisionNonNaN(labelDictNgram.get(label), otherLabelFreq);</span>
<span class="nc" id="L508">        constVars.dictOddsWeights.put(label, dictOddsWeightsLabel);</span>
<span class="nc" id="L509">      }</span>
    }

    //Redwood.log(Redwood.DBG, &quot;All options are:&quot; + &quot;\n&quot; + Maps.toString(getAllOptions(), &quot;&quot;,&quot;&quot;,&quot;\t&quot;,&quot;\n&quot;));
<span class="nc" id="L513">  }</span>

  public PatternsForEachToken getPatsForEachToken() {
<span class="nc" id="L516">    return patsForEachToken;</span>
  }

  /**
   * If a token is labeled for two or more labels, then keep the one that has the longest matching phrase. For example, &quot;lung&quot; as BODYPART label and &quot;lung cancer&quot; as DISEASE label,
   * keep only the DISEASE label for &quot;lung&quot;. For this to work, you need to have {@code PatternsAnnotations.Ln} set, which is already done in runLabelSeedWords function.
   */
  private void removeOverLappingLabels(Map&lt;String, DataInstance&gt; sents){
<span class="nc bnc" id="L524" title="All 2 branches missed.">    for(Map.Entry&lt;String, DataInstance&gt; sentEn: sents.entrySet()){</span>

<span class="nc bnc" id="L526" title="All 2 branches missed.">      for(CoreLabel l : sentEn.getValue().getTokens()){</span>
<span class="nc" id="L527">        Map&lt;String, CandidatePhrase&gt; longestMatchingMap = l.get(PatternsAnnotations.LongestMatchedPhraseForEachLabel.class);</span>
<span class="nc" id="L528">        String longestMatchingString = &quot;&quot;;</span>
<span class="nc" id="L529">        String longestMatchingLabel = null;</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">        for(Map.Entry&lt;String, CandidatePhrase&gt; en: longestMatchingMap.entrySet()){</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">          if(en.getValue().getPhrase().length() &gt; longestMatchingString.length()){</span>
<span class="nc" id="L532">              longestMatchingLabel = en.getKey();</span>
<span class="nc" id="L533">              longestMatchingString = en.getValue().getPhrase();</span>
          }
<span class="nc" id="L535">        }</span>

<span class="nc bnc" id="L537" title="All 2 branches missed.">        if(longestMatchingLabel  != null){</span>

<span class="nc bnc" id="L539" title="All 2 branches missed.">          if(!&quot;OTHERSEM&quot;.equals(longestMatchingLabel))</span>
<span class="nc" id="L540">             l.set(PatternsAnnotations.OtherSemanticLabel.class, constVars.backgroundSymbol);</span>

<span class="nc bnc" id="L542" title="All 2 branches missed.">          for(Entry&lt;String, Class&lt;? extends Key&lt;String&gt;&gt;&gt; en: constVars.getAnswerClass().entrySet()) {</span>
<span class="nc bnc" id="L543" title="All 2 branches missed.">            if (!en.getKey().equals(longestMatchingLabel)){</span>
<span class="nc" id="L544">              l.set(en.getValue(), constVars.backgroundSymbol);</span>
            }
            else
<span class="nc" id="L547">              l.set(en.getValue(), en.getKey());</span>
<span class="nc" id="L548">          }</span>
        }
<span class="nc" id="L550">      }</span>
<span class="nc" id="L551">    }</span>
<span class="nc" id="L552">  }</span>

  public static Map&lt;String, DataInstance&gt; runPOSNERParseOnTokens(Map&lt;String, DataInstance&gt; sents, Properties propsoriginal){

<span class="nc" id="L556">    PatternFactory.PatternType type = PatternFactory.PatternType.valueOf(propsoriginal.getProperty(Flags.patternType));</span>
<span class="nc" id="L557">    Properties props = new Properties();</span>
<span class="nc" id="L558">    List&lt;String&gt; anns = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L559">    anns.add(&quot;pos&quot;);</span>
<span class="nc" id="L560">    anns.add(&quot;lemma&quot;);</span>

<span class="nc" id="L562">    boolean useTargetParserParentRestriction = Boolean.parseBoolean(propsoriginal.getProperty(Flags.useTargetParserParentRestriction));</span>
<span class="nc" id="L563">    boolean useTargetNERRestriction = Boolean.parseBoolean(propsoriginal.getProperty(Flags.useTargetNERRestriction));</span>
<span class="nc" id="L564">    String posModelPath = props.getProperty(Flags.posModelPath);</span>
<span class="nc" id="L565">    String numThreads = propsoriginal.getProperty(Flags.numThreads);</span>

<span class="nc bnc" id="L567" title="All 2 branches missed.">    if (useTargetParserParentRestriction){</span>
<span class="nc" id="L568">      anns.add(&quot;parse&quot;);</span>
<span class="nc bnc" id="L569" title="All 2 branches missed.">    } else if(type.equals(PatternFactory.PatternType.DEP))</span>
<span class="nc" id="L570">      anns.add(&quot;depparse&quot;);</span>

<span class="nc bnc" id="L572" title="All 2 branches missed.">    if (useTargetNERRestriction) {</span>
<span class="nc" id="L573">      anns.add(&quot;ner&quot;);</span>
    }

<span class="nc" id="L576">    props.setProperty(&quot;annotators&quot;, StringUtils.join(anns, &quot;,&quot;));</span>
<span class="nc" id="L577">    props.setProperty(&quot;parse.maxlen&quot;, &quot;80&quot;);</span>
<span class="nc" id="L578">    props.setProperty(&quot;nthreads&quot;, numThreads);</span>
<span class="nc" id="L579">    props.setProperty(&quot;threads&quot;, numThreads);</span>
    // props.put( &quot;tokenize.options&quot;,
    // &quot;ptb3Escaping=false,normalizeParentheses=false,escapeForwardSlashAsterisk=false&quot;);

<span class="nc bnc" id="L583" title="All 2 branches missed.">    if (posModelPath != null) {</span>
<span class="nc" id="L584">      props.setProperty(&quot;pos.model&quot;, posModelPath);</span>
    }
<span class="nc" id="L586">    StanfordCoreNLP pipeline = new StanfordCoreNLP(props, false);</span>
<span class="nc" id="L587">    Redwood.log(Redwood.DBG, &quot;Annotating text&quot;);</span>

<span class="nc bnc" id="L589" title="All 2 branches missed.">    for(Map.Entry&lt;String, DataInstance&gt; en: sents.entrySet()) {</span>
<span class="nc" id="L590">      List&lt;CoreMap&gt; temp = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L591">      CoreMap s= new ArrayCoreMap();</span>
<span class="nc" id="L592">      s.set(CoreAnnotations.TokensAnnotation.class, en.getValue().getTokens());</span>
<span class="nc" id="L593">      temp.add(s);</span>
<span class="nc" id="L594">      Annotation doc = new Annotation(temp);</span>
      try {
<span class="nc" id="L596">        pipeline.annotate(doc);</span>
<span class="nc bnc" id="L597" title="All 2 branches missed.">        if (useTargetParserParentRestriction)</span>
<span class="nc" id="L598">          inferParentParseTag(s.get(TreeAnnotation.class));</span>
<span class="nc" id="L599">      } catch (Exception e) {</span>
<span class="nc" id="L600">        log.warn(&quot;Ignoring error: for sentence  &quot; + StringUtils.joinWords(en.getValue().getTokens(), &quot; &quot;));</span>
<span class="nc" id="L601">        log.warn(e);</span>
<span class="nc" id="L602">      }</span>

<span class="nc" id="L604">    }</span>

<span class="nc" id="L606">    Redwood.log(Redwood.DBG, &quot;Done annotating text&quot;);</span>
<span class="nc" id="L607">    return sents;</span>
  }

  public static Map&lt;String, DataInstance&gt; runPOSNEROnTokens(List&lt;CoreMap&gt; sentsCM, String posModelPath, boolean useTargetNERRestriction,
      String prefix, boolean useTargetParserParentRestriction, String numThreads, PatternFactory.PatternType type) {
<span class="nc" id="L612">    Annotation doc = new Annotation(sentsCM);</span>

<span class="nc" id="L614">    Properties props = new Properties();</span>
<span class="nc" id="L615">    List&lt;String&gt; anns = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L616">    anns.add(&quot;pos&quot;);</span>
<span class="nc" id="L617">    anns.add(&quot;lemma&quot;);</span>

<span class="nc bnc" id="L619" title="All 2 branches missed.">    if (useTargetParserParentRestriction){</span>
<span class="nc" id="L620">      anns.add(&quot;parse&quot;);</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">    } else if(type.equals(PatternFactory.PatternType.DEP))</span>
<span class="nc" id="L622">      anns.add(&quot;depparse&quot;);</span>

<span class="nc bnc" id="L624" title="All 2 branches missed.">    if (useTargetNERRestriction) {</span>
<span class="nc" id="L625">      anns.add(&quot;ner&quot;);</span>
    }

<span class="nc" id="L628">    props.setProperty(&quot;annotators&quot;, StringUtils.join(anns, &quot;,&quot;));</span>
<span class="nc" id="L629">    props.setProperty(&quot;parse.maxlen&quot;, &quot;80&quot;);</span>
<span class="nc" id="L630">    props.setProperty(&quot;nthreads&quot;, numThreads);</span>
<span class="nc" id="L631">    props.setProperty(&quot;threads&quot;, numThreads);</span>

    // props.put( &quot;tokenize.options&quot;,
    // &quot;ptb3Escaping=false,normalizeParentheses=false,escapeForwardSlashAsterisk=false&quot;);

<span class="nc bnc" id="L636" title="All 2 branches missed.">    if (posModelPath != null) {</span>
<span class="nc" id="L637">      props.setProperty(&quot;pos.model&quot;, posModelPath);</span>
    }
<span class="nc" id="L639">    StanfordCoreNLP pipeline = new StanfordCoreNLP(props, false);</span>

<span class="nc" id="L641">    Redwood.log(Redwood.DBG, &quot;Annotating text&quot;);</span>
<span class="nc" id="L642">    pipeline.annotate(doc);</span>
<span class="nc" id="L643">    Redwood.log(Redwood.DBG, &quot;Done annotating text&quot;);</span>

<span class="nc" id="L645">    Map&lt;String, DataInstance&gt; sents = new HashMap&lt;&gt;();</span>

<span class="nc bnc" id="L647" title="All 2 branches missed.">    for (CoreMap s : doc.get(CoreAnnotations.SentencesAnnotation.class)) {</span>
<span class="nc bnc" id="L648" title="All 2 branches missed.">      if (useTargetParserParentRestriction)</span>
<span class="nc" id="L649">        inferParentParseTag(s.get(TreeAnnotation.class));</span>
<span class="nc" id="L650">      DataInstance d = DataInstance.getNewInstance(type, s);</span>
<span class="nc" id="L651">      sents.put(prefix + s.get(CoreAnnotations.DocIDAnnotation.class), d);</span>
<span class="nc" id="L652">    }</span>

<span class="nc" id="L654">    return sents;</span>
  }

<span class="fc" id="L657">  static StanfordCoreNLP pipeline = null;</span>

  public static int tokenize(Iterator&lt;String&gt; textReader, String posModelPath, boolean lowercase, boolean useTargetNERRestriction, String sentIDPrefix,
                             boolean useTargetParserParentRestriction, String numThreads, boolean batchProcessSents, int numMaxSentencesPerBatchFile,
                             File saveSentencesSerDirFile, Map&lt;String, DataInstance&gt; sents, int numFilesTillNow, PatternFactory.PatternType type) throws InterruptedException, ExecutionException,
    IOException {
<span class="nc bnc" id="L663" title="All 2 branches missed.">    if (pipeline == null) {</span>
<span class="nc" id="L664">      Properties props = new Properties();</span>
<span class="nc" id="L665">      List&lt;String&gt; anns = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L666">      anns.add(&quot;tokenize&quot;);</span>
<span class="nc" id="L667">      anns.add(&quot;ssplit&quot;);</span>
<span class="nc" id="L668">      anns.add(&quot;pos&quot;);</span>
<span class="nc" id="L669">      anns.add(&quot;lemma&quot;);</span>

<span class="nc bnc" id="L671" title="All 2 branches missed.">      if (useTargetParserParentRestriction){</span>
<span class="nc" id="L672">        anns.add(&quot;parse&quot;);</span>
      }
<span class="nc bnc" id="L674" title="All 2 branches missed.">      if(type.equals(PatternFactory.PatternType.DEP))</span>
<span class="nc" id="L675">        anns.add(&quot;depparse&quot;);</span>

<span class="nc bnc" id="L677" title="All 2 branches missed.">      if (useTargetNERRestriction) {</span>
<span class="nc" id="L678">        anns.add(&quot;ner&quot;);</span>
      }

<span class="nc" id="L681">      props.setProperty(&quot;annotators&quot;, StringUtils.join(anns, &quot;,&quot;));</span>
<span class="nc" id="L682">      props.setProperty(&quot;parse.maxlen&quot;, &quot;80&quot;);</span>
<span class="nc bnc" id="L683" title="All 2 branches missed.">      if(numThreads != null)</span>
<span class="nc" id="L684">        props.setProperty(&quot;threads&quot;, numThreads);</span>

<span class="nc" id="L686">      props.setProperty(&quot;tokenize.options&quot;, &quot;ptb3Escaping=false,normalizeParentheses=false,escapeForwardSlashAsterisk=false&quot;);</span>

<span class="nc bnc" id="L688" title="All 2 branches missed.">      if (posModelPath != null) {</span>
<span class="nc" id="L689">        props.setProperty(&quot;pos.model&quot;, posModelPath);</span>
      }
<span class="nc" id="L691">      pipeline = new StanfordCoreNLP(props);</span>
    }

<span class="nc" id="L694">    String text = &quot;&quot;;</span>
<span class="nc" id="L695">    int numLines = 0;</span>
<span class="nc bnc" id="L696" title="All 2 branches missed.">    while(textReader.hasNext()) {</span>
<span class="nc" id="L697">      String line = textReader.next();</span>
<span class="nc" id="L698">      numLines ++;</span>
<span class="nc bnc" id="L699" title="All 4 branches missed.">      if (batchProcessSents &amp;&amp; numLines &gt; numMaxSentencesPerBatchFile) {</span>
<span class="nc" id="L700">        break;</span>
      }
<span class="nc bnc" id="L702" title="All 2 branches missed.">      if (lowercase)</span>
<span class="nc" id="L703">        line = line.toLowerCase();</span>
<span class="nc" id="L704">      text += line+&quot;\n&quot;;</span>
<span class="nc" id="L705">    }</span>

<span class="nc" id="L707">    Annotation doc = new Annotation(text);</span>
<span class="nc" id="L708">    pipeline.annotate(doc);</span>


<span class="nc" id="L711">    int i = -1;</span>
<span class="nc bnc" id="L712" title="All 2 branches missed.">    for (CoreMap s : doc.get(CoreAnnotations.SentencesAnnotation.class)) {</span>
<span class="nc" id="L713">      i++;</span>
<span class="nc bnc" id="L714" title="All 2 branches missed.">      if (useTargetParserParentRestriction)</span>
<span class="nc" id="L715">        inferParentParseTag(s.get(TreeAnnotation.class));</span>
<span class="nc" id="L716">      DataInstance d = DataInstance.getNewInstance(type, s);</span>
<span class="nc" id="L717">      sents.put(sentIDPrefix + i, d);</span>

//      if (batchProcessSents &amp;&amp; sents.size() &gt;= numMaxSentencesPerBatchFile) {
//        numFilesTillNow++;
//        File file = new File(saveSentencesSerDirFile + &quot;/sents_&quot; + numFilesTillNow);
//        IOUtils.writeObjectToFile(sents, file);
//        sents = new HashMap&lt;String, DataInstance&gt;();
//        Data.sentsFiles.add(file);
//      }
<span class="nc" id="L726">    }</span>

<span class="nc" id="L728">    Redwood.log(Redwood.DBG, &quot;Done annotating text with &quot; + i + &quot; sentences&quot;);</span>

<span class="nc bnc" id="L730" title="All 4 branches missed.">    if (sents.size() &gt; 0 &amp;&amp; batchProcessSents) {</span>
<span class="nc" id="L731">      numFilesTillNow++;</span>
<span class="nc" id="L732">      File file = new File(saveSentencesSerDirFile + &quot;/sents_&quot; + numFilesTillNow);</span>
<span class="nc" id="L733">      IOUtils.writeObjectToFile(sents, file);</span>
<span class="nc" id="L734">      Data.sentsFiles.add(file);</span>

<span class="nc bnc" id="L736" title="All 2 branches missed.">      for(String sentid: sents.keySet()) {</span>
<span class="nc bnc" id="L737" title="All 4 branches missed.">        assert !Data.sentId2File.containsKey(sentid) : &quot;Data.sentId2File already contains &quot; + sentid + &quot;. Make sure sentIds are unique!&quot;;</span>
<span class="nc" id="L738">        Data.sentId2File.put(sentid, file);</span>
<span class="nc" id="L739">      }</span>
<span class="nc" id="L740">      sents.clear();</span>
    }
    // not lugging around sents if batch processing
<span class="nc bnc" id="L743" title="All 2 branches missed.">    if (batchProcessSents)</span>
<span class="nc" id="L744">      sents = null;</span>
<span class="nc" id="L745">    return numFilesTillNow;</span>
  }

  /*
  public static int tokenize(String text, String posModelPath, boolean lowercase, boolean useTargetNERRestriction, String sentIDPrefix,
      boolean useTargetParserParentRestriction, String numThreads, boolean batchProcessSents, int numMaxSentencesPerBatchFile,
      File saveSentencesSerDirFile, Map&lt;String, DataInstance&gt; sents, int numFilesTillNow) throws InterruptedException, ExecutionException,
      IOException {
    if (pipeline == null) {
      Properties props = new Properties();
      List&lt;String&gt; anns = new ArrayList&lt;String&gt;();
      anns.add(&quot;tokenize&quot;);
      anns.add(&quot;ssplit&quot;);
      anns.add(&quot;pos&quot;);
      anns.add(&quot;lemma&quot;);

      if (useTargetParserParentRestriction) {
        anns.add(&quot;parse&quot;);
      }
      if (useTargetNERRestriction) {
        anns.add(&quot;ner&quot;);
      }

      props.setProperty(&quot;annotators&quot;, StringUtils.join(anns, &quot;,&quot;));
      props.setProperty(&quot;parse.maxlen&quot;, &quot;80&quot;);
      props.setProperty(&quot;threads&quot;, numThreads);

      props.put(&quot;tokenize.options&quot;, &quot;ptb3Escaping=false,normalizeParentheses=false,escapeForwardSlashAsterisk=false&quot;);

      if (posModelPath != null) {
        props.setProperty(&quot;pos.model&quot;, posModelPath);
      }
      pipeline = new StanfordCoreNLP(props);
    }
    if (lowercase)
      text = text.toLowerCase();

    Annotation doc = new Annotation(text);
    pipeline.annotate(doc);
    Redwood.log(Redwood.DBG, &quot;Done annotating text&quot;);

    int i = -1;
    for (CoreMap s : doc.get(CoreAnnotations.SentencesAnnotation.class)) {
      i++;
      if (useTargetParserParentRestriction)
        inferParentParseTag(s.get(TreeAnnotation.class));
      sents.put(sentIDPrefix + i, s.get(CoreAnnotations.TokensAnnotation.class));
      if (batchProcessSents &amp;&amp; sents.size() &gt;= numMaxSentencesPerBatchFile) {
        numFilesTillNow++;
        File file = new File(saveSentencesSerDirFile + &quot;/sents_&quot; + numFilesTillNow);
        IOUtils.writeObjectToFile(sents, file);
        sents = new HashMap&lt;String, DataInstance&gt;();
        Data.sentsFiles.add(file);
      }

    }
    if (sents.size() &gt; 0 &amp;&amp; batchProcessSents) {
      numFilesTillNow++;
      File file = new File(saveSentencesSerDirFile + &quot;/sents_&quot; + numFilesTillNow);
      IOUtils.writeObjectToFile(sents, file);
      Data.sentsFiles.add(file);
      sents.clear();
    }
    // not lugging around sents if batch processing
    if (batchProcessSents)
      sents = null;
    return numFilesTillNow;
  }
*/

  private static void inferParentParseTag(Tree tree) {

<span class="nc" id="L817">    String grandstr = tree.value();</span>
<span class="nc bnc" id="L818" title="All 2 branches missed.">    for (Tree child : tree.children()) {</span>
<span class="nc bnc" id="L819" title="All 2 branches missed.">      for (Tree grand : child.children()) {</span>
<span class="nc bnc" id="L820" title="All 2 branches missed.">        if (grand.isLeaf()) {</span>
<span class="nc" id="L821">          ((CoreLabel) grand.label()).set(CoreAnnotations.GrandparentAnnotation.class, grandstr);</span>
        }
      }
<span class="nc" id="L824">      inferParentParseTag(child);</span>
    }

<span class="nc" id="L827">  }</span>

  /**
   * If l1 is a part of l2, it finds the starting index of l1 in l2 If l1 is not
   * a sub-array of l2, then it returns -1 note that l2 should have the exact
   * elements and order as in l1
   *
   * @param l1 array you want to find in l2
   * @param l2
   * @return starting index of the sublist
   */
  public static List&lt;Integer&gt; getSubListIndex(String[] l1, String[] l2, String[] subl2, Set&lt;String&gt; doNotLabelTheseWords, HashSet&lt;String&gt; seenFuzzyMatches,
      int minLen4Fuzzy, boolean fuzzyMatch, boolean ignoreCaseSeedMatch) {
<span class="nc bnc" id="L840" title="All 2 branches missed.">    if (l1.length &gt; l2.length)</span>
<span class="nc" id="L841">      return null;</span>
<span class="nc" id="L842">    EditDistance editDistance = new EditDistance(true);</span>
<span class="nc" id="L843">    List&lt;Integer&gt; allIndices = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L844">    boolean matched = false;</span>
<span class="nc" id="L845">    int index = -1;</span>
<span class="nc" id="L846">    int lastUnmatchedIndex = 0;</span>
<span class="nc bnc" id="L847" title="All 2 branches missed.">    for (int i = 0; i &lt; l2.length;) {</span>

<span class="nc bnc" id="L849" title="All 2 branches missed.">      for (int j = 0; j &lt; l1.length;) {</span>
<span class="nc" id="L850">        boolean d1 = false, d2 = false;</span>
<span class="nc" id="L851">        boolean compareFuzzy = true;</span>
<span class="nc bnc" id="L852" title="All 10 branches missed.">        if (!fuzzyMatch || doNotLabelTheseWords.contains(l2[i]) || doNotLabelTheseWords.contains(subl2[i]) || l2[i].length() &lt;= minLen4Fuzzy || subl2[i].length() &lt;= minLen4Fuzzy)</span>
<span class="nc" id="L853">          compareFuzzy = false;</span>
<span class="nc bnc" id="L854" title="All 4 branches missed.">        if (compareFuzzy == false || l1[j].length() &lt;= minLen4Fuzzy) {</span>
<span class="nc bnc" id="L855" title="All 6 branches missed.">          d1 = (ignoreCaseSeedMatch &amp;&amp; l1[j].equalsIgnoreCase(l2[i])) || l1[j].equals(l2[i]);</span>
<span class="nc bnc" id="L856" title="All 4 branches missed.">          if (!d1 &amp;&amp; fuzzyMatch)</span>
<span class="nc bnc" id="L857" title="All 6 branches missed.">            d2 = (ignoreCaseSeedMatch &amp;&amp; subl2[i].equalsIgnoreCase(l1[j])) || subl2[i].equals(l1[j]);</span>
        } else {
<span class="nc" id="L859">          String combo = l1[j] + &quot;#&quot; + l2[i];</span>
<span class="nc bnc" id="L860" title="All 8 branches missed.">          if ((ignoreCaseSeedMatch &amp;&amp; l1[j].equalsIgnoreCase(l2[i])) || l1[j].equals(l2[i])  || seenFuzzyMatches.contains(combo))</span>
<span class="nc" id="L861">            d1 = true;</span>
          else {
<span class="nc bnc" id="L863" title="All 2 branches missed.">            d1 = editDistance.score(l1[j], l2[i]) &lt;= 1;</span>
<span class="nc bnc" id="L864" title="All 2 branches missed.">            if (!d1) {</span>
<span class="nc" id="L865">              String combo2 = l1[j] + &quot;#&quot; + subl2[i];</span>
<span class="nc bnc" id="L866" title="All 8 branches missed.">              if ((ignoreCaseSeedMatch &amp;&amp; l1[j].equalsIgnoreCase(subl2[i]) )||l1[j].equals(subl2[i]) || seenFuzzyMatches.contains(combo2))</span>
<span class="nc" id="L867">                d2 = true;</span>
              else {
<span class="nc bnc" id="L869" title="All 2 branches missed.">                d2 = editDistance.score(l1[j], subl2[i]) &lt;= 1;</span>
<span class="nc bnc" id="L870" title="All 2 branches missed.">                if (d2) {</span>
                  // System.out.println(l1[j] + &quot; matched with &quot; + subl2[i]);
<span class="nc" id="L872">                  seenFuzzyMatches.add(combo2);</span>
                }
              }
<span class="nc bnc" id="L875" title="All 2 branches missed.">            } else if (d1) {</span>
              // System.out.println(l1[j] + &quot; matched with &quot; + l2[i]);
<span class="nc" id="L877">              seenFuzzyMatches.add(combo);</span>
            }
          }
        }
        // if (l1[j].equals(l2[i]) || subl2[i].equals(l1[j])) {
<span class="nc bnc" id="L882" title="All 4 branches missed.">        if (d1 || d2) {</span>

<span class="nc" id="L884">          index = i;</span>
<span class="nc" id="L885">          i++;</span>
<span class="nc" id="L886">          j++;</span>
<span class="nc bnc" id="L887" title="All 2 branches missed.">          if (j == l1.length) {</span>
<span class="nc" id="L888">            matched = true;</span>
<span class="nc" id="L889">            break;</span>
          }
        } else {
<span class="nc" id="L892">          j = 0;</span>
<span class="nc" id="L893">          i = lastUnmatchedIndex + 1;</span>
<span class="nc" id="L894">          lastUnmatchedIndex = i;</span>
<span class="nc" id="L895">          index = -1;</span>
<span class="nc bnc" id="L896" title="All 2 branches missed.">          if (lastUnmatchedIndex == l2.length)</span>
<span class="nc" id="L897">            break;</span>
        }
<span class="nc bnc" id="L899" title="All 2 branches missed.">        if (i &gt;= l2.length) {</span>
<span class="nc" id="L900">          index = -1;</span>
<span class="nc" id="L901">          break;</span>
        }
<span class="nc" id="L903">      }</span>
<span class="nc bnc" id="L904" title="All 4 branches missed.">      if (i == l2.length || matched) {</span>
<span class="nc bnc" id="L905" title="All 2 branches missed.">        if (index &gt;= 0)</span>
          // index = index - l1.length + 1;
<span class="nc" id="L907">          allIndices.add(index - l1.length + 1);</span>
<span class="nc" id="L908">        matched = false;</span>
<span class="nc" id="L909">        lastUnmatchedIndex = index;</span>

        // break;
      }
    }
    // get starting point

<span class="nc" id="L916">    return allIndices;</span>
  }

  //if matchcontextlowercase is on, transform that. escape the word etc. Useful for pattern matching later on
<span class="pc bpc" id="L920" title="1 of 2 branches missed.">  private static Function&lt;CoreLabel, String&gt; stringTransformationFunction = new Function&lt;CoreLabel, String&gt;() {</span>
    @Override
    public String apply(CoreLabel l) {
      String s;
<span class="nc bnc" id="L924" title="All 2 branches missed.">      if(PatternFactory.useLemmaContextTokens){</span>
<span class="nc" id="L925">        s = l.lemma();</span>
<span class="nc bnc" id="L926" title="All 4 branches missed.">        assert s!=null : &quot;Lemma is null and useLemmaContextTokens is true&quot;;</span>
      }
      else
<span class="nc" id="L929">        s= l.word();</span>
<span class="nc bnc" id="L930" title="All 2 branches missed.">      if(ConstantsAndVariables.matchLowerCaseContext)</span>
<span class="nc" id="L931">        s = s.toLowerCase();</span>
<span class="nc bnc" id="L932" title="All 4 branches missed.">      assert s!= null;</span>
<span class="nc" id="L933">      return s;</span>
    }
  };

  public static&lt;E&gt; List&lt;List&lt;E&gt;&gt; getThreadBatches(List&lt;E&gt; keyset, int numThreads){
    int num;
<span class="nc bnc" id="L939" title="All 2 branches missed.">    if (numThreads == 1)</span>
<span class="nc" id="L940">      num = keyset.size();</span>
    else
<span class="nc" id="L942">      num = keyset.size() / (numThreads - 1);</span>
<span class="nc" id="L943">    Redwood.log(ConstantsAndVariables.extremedebug, &quot;keyset size is &quot; + keyset.size());</span>
<span class="nc" id="L944">    List&lt;List&lt;E&gt;&gt; threadedSentIds = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L945" title="All 2 branches missed.">    for (int i = 0; i &lt; numThreads; i++) {</span>
<span class="nc" id="L946">      List&lt;E&gt; keys = keyset.subList(i * num, Math.min(keyset.size(), (i + 1) * num));</span>
<span class="nc" id="L947">      threadedSentIds.add(keys);</span>
<span class="nc" id="L948">      Redwood.log(ConstantsAndVariables.extremedebug, &quot;assigning from &quot; + i * num + &quot; till &quot; + Math.min(keyset.size(), (i + 1) * num));</span>
    }
<span class="nc" id="L950">    return threadedSentIds;</span>
  }

  /** Warning: sets labels of words that are not in the given seed set as O!!!
   * */
  public static Counter&lt;CandidatePhrase&gt; runLabelSeedWords(Map&lt;String, DataInstance&gt; sents, Class answerclass, String label, Collection&lt;CandidatePhrase&gt; seedWords, ConstantsAndVariables constVars, boolean overwriteExistingLabels)
      throws InterruptedException, ExecutionException, IOException {

<span class="nc" id="L958">    Redwood.log(Redwood.DBG,&quot;ignoreCaseSeedMatch is &quot; + constVars.ignoreCaseSeedMatch);</span>
<span class="nc" id="L959">    List&lt;List&lt;String&gt;&gt; threadedSentIds = getThreadBatches(new ArrayList&lt;&gt;(sents.keySet()), constVars.numThreads);</span>
<span class="nc" id="L960">    ExecutorService executor = Executors.newFixedThreadPool(constVars.numThreads);</span>
<span class="nc" id="L961">    List&lt;Future&lt;Pair&lt;Map&lt;String, DataInstance&gt;, Counter&lt;CandidatePhrase&gt;&gt;&gt;&gt; list = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L962">    Counter&lt;CandidatePhrase&gt; matchedPhrasesCounter = new ClassicCounter&lt;&gt;();</span>
<span class="nc bnc" id="L963" title="All 2 branches missed.">    for (List&lt;String&gt; keys: threadedSentIds) {</span>
<span class="nc" id="L964">      Callable&lt;Pair&lt;Map&lt;String, DataInstance&gt;, Counter&lt;CandidatePhrase&gt;&gt;&gt; task = new LabelWithSeedWords(seedWords, sents, keys, answerclass, label, constVars.fuzzyMatch, constVars.minLen4FuzzyForPattern, constVars.backgroundSymbol, constVars.getEnglishWords(),</span>
        stringTransformationFunction, constVars.writeMatchedTokensIdsForEachPhrase, overwriteExistingLabels, constVars.patternType, constVars.ignoreCaseSeedMatch);
<span class="nc" id="L966">      Pair&lt;Map&lt;String, DataInstance&gt;, Counter&lt;CandidatePhrase&gt;&gt; sentsi  = executor.submit(task).get();</span>
<span class="nc" id="L967">      sents.putAll(sentsi.first());</span>
<span class="nc" id="L968">      matchedPhrasesCounter.addAll(sentsi.second());</span>
<span class="nc" id="L969">    }</span>
<span class="nc" id="L970">    executor.shutdown();</span>
<span class="nc" id="L971">    Redwood.log(&quot;extremedebug&quot;,&quot;Matched phrases freq is &quot; + matchedPhrasesCounter);</span>
<span class="nc" id="L972">    return matchedPhrasesCounter;</span>
  }

  public static void getFeatures(SemanticGraph graph, IndexedWord vertex, boolean isHead, Collection&lt;String&gt; features, GrammaticalRelation reln){
<span class="nc bnc" id="L976" title="All 2 branches missed.">    if(isHead){</span>
<span class="nc" id="L977">      List&lt;Pair&lt;GrammaticalRelation, IndexedWord&gt;&gt; pt = graph.parentPairs(vertex);</span>
<span class="nc bnc" id="L978" title="All 2 branches missed.">      for(Pair&lt;GrammaticalRelation, IndexedWord&gt; en: pt) {</span>
<span class="nc" id="L979">        features.add(&quot;PARENTREL-&quot; + en.first());</span>
<span class="nc" id="L980">      }</span>
<span class="nc" id="L981">    } else{</span>
      //find the relation to the parent
<span class="nc bnc" id="L983" title="All 2 branches missed.">      if(reln == null){</span>
<span class="nc" id="L984">        List&lt;SemanticGraphEdge&gt; parents = graph.getOutEdgesSorted(vertex);</span>
<span class="nc bnc" id="L985" title="All 2 branches missed.">        if(parents.size() &gt; 0)</span>
<span class="nc" id="L986">        reln = parents.get(0).getRelation();</span>
      }
<span class="nc bnc" id="L988" title="All 2 branches missed.">      if(reln != null)</span>
<span class="nc" id="L989">        features.add(&quot;REL-&quot; + reln.getShortName());</span>
    }
    //System.out.println(&quot;For graph &quot; + graph.toFormattedString() + &quot; and vertex &quot; + vertex + &quot; the features are &quot; + features);
<span class="nc" id="L992">  }</span>


  /**
   * Warning: sets labels of words that are not in the given seed set as O!!!
   */
<span class="nc bnc" id="L998" title="All 2 branches missed.">  @SuppressWarnings(&quot;rawtypes&quot;)</span>
  public static class LabelWithSeedWords implements Callable&lt;Pair&lt;Map&lt;String, DataInstance&gt;, Counter&lt;CandidatePhrase&gt;&gt;&gt; {
<span class="nc" id="L1000">    Map&lt;CandidatePhrase, String[]&gt; seedwordsTokens = new HashMap&lt;&gt;();</span>
    Map&lt;String, DataInstance&gt; sents;
    List&lt;String&gt; keyset;
    Class labelClass;
<span class="nc" id="L1004">    HashSet&lt;String&gt; seenFuzzyMatches = new HashSet&lt;&gt;();</span>
    String label;
    int minLen4FuzzyForPattern;
<span class="nc" id="L1007">    String backgroundSymbol = &quot;O&quot;;</span>
<span class="nc" id="L1008">    Set&lt;String&gt; doNotLabelDictWords = null;</span>
    Function&lt;CoreLabel, String&gt; stringTransformation;
<span class="nc" id="L1010">    boolean writeMatchedTokensIdsForEachPhrase = false;</span>
    boolean overwriteExistingLabels;
    PatternFactory.PatternType patternType;
<span class="nc" id="L1013">    boolean fuzzyMatch = false;</span>
    Map&lt;String, String&gt; ignoreCaseSeedMatch;

    public LabelWithSeedWords(Collection&lt;CandidatePhrase&gt; seedwords, Map&lt;String, DataInstance&gt; sents, List&lt;String&gt; keyset, Class labelclass, String label, boolean fuzzyMatch,
                              int minLen4FuzzyForPattern, String backgroundSymbol, Set&lt;String&gt; doNotLabelDictWords,
                              Function&lt;CoreLabel, String&gt; stringTransformation, boolean writeMatchedTokensIdsForEachPhrase, boolean overwriteExistingLabels, PatternFactory.PatternType type,
<span class="nc" id="L1019">                              Map&lt;String, String&gt; ignoreCaseSeedMatch) {</span>
<span class="nc bnc" id="L1020" title="All 2 branches missed.">      for (CandidatePhrase s : seedwords)</span>
<span class="nc" id="L1021">        this.seedwordsTokens.put(s, s.getPhrase().split(&quot;\\s+&quot;));</span>
<span class="nc" id="L1022">      this.sents = sents;</span>
<span class="nc" id="L1023">      this.keyset = keyset;</span>
<span class="nc" id="L1024">      this.labelClass = labelclass;</span>
<span class="nc" id="L1025">      this.label = label;</span>
<span class="nc" id="L1026">      this.minLen4FuzzyForPattern= minLen4FuzzyForPattern;</span>
<span class="nc" id="L1027">      this.backgroundSymbol = backgroundSymbol;</span>
<span class="nc" id="L1028">      this.doNotLabelDictWords = doNotLabelDictWords;</span>
<span class="nc" id="L1029">      this.stringTransformation = stringTransformation;</span>
<span class="nc" id="L1030">      this.writeMatchedTokensIdsForEachPhrase = writeMatchedTokensIdsForEachPhrase;</span>
<span class="nc" id="L1031">      this.overwriteExistingLabels = overwriteExistingLabels;</span>
<span class="nc" id="L1032">      this.patternType = type;</span>
<span class="nc" id="L1033">      this.fuzzyMatch = fuzzyMatch;</span>
<span class="nc" id="L1034">      this.ignoreCaseSeedMatch = ignoreCaseSeedMatch;</span>
<span class="nc" id="L1035">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public Pair&lt;Map&lt;String, DataInstance&gt;,Counter&lt;CandidatePhrase&gt;&gt; call()  {
<span class="nc" id="L1040">      Map&lt;String, DataInstance&gt; newsent = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1041">      Counter&lt;CandidatePhrase&gt; matchedPhrasesCounter = new ClassicCounter&lt;&gt;();</span>
<span class="nc bnc" id="L1042" title="All 2 branches missed.">      for (String k : keyset) {</span>
<span class="nc" id="L1043">        DataInstance sent = sents.get(k);</span>
<span class="nc" id="L1044">        List&lt;CoreLabel&gt; tokensCore = sent.getTokens();</span>

<span class="nc" id="L1046">        SemanticGraph graph = null;</span>
<span class="nc bnc" id="L1047" title="All 2 branches missed.">        if(patternType.equals(PatternFactory.PatternType.DEP)){</span>
<span class="nc" id="L1048">          graph = ((DataInstanceDep)sent).getGraph();</span>
        }

<span class="nc" id="L1051">        String[] tokens = new String[tokensCore.size()];</span>
<span class="nc" id="L1052">        String[] tokenslemma = new String[tokensCore.size()];</span>
<span class="nc" id="L1053">        int num = 0;</span>
<span class="nc bnc" id="L1054" title="All 2 branches missed.">        for (CoreLabel l : tokensCore) {</span>

          //Setting the processedTextAnnotation, used in indexing and pattern matching
<span class="nc" id="L1057">          l.set(PatternsAnnotations.ProcessedTextAnnotation.class, stringTransformation.apply(l));</span>

<span class="nc" id="L1059">          tokens[num] = l.word();</span>
<span class="nc bnc" id="L1060" title="All 4 branches missed.">          if(fuzzyMatch &amp;&amp; l.lemma() == null)</span>
<span class="nc" id="L1061">            throw new RuntimeException(&quot;how come lemma is null&quot;);</span>
<span class="nc" id="L1062">          tokenslemma[num] = l.lemma();</span>

<span class="nc" id="L1064">          num++;</span>
<span class="nc" id="L1065">        }</span>
<span class="nc" id="L1066">        boolean[] labels = new boolean[tokens.length];</span>

<span class="nc" id="L1068">        CollectionValuedMap&lt;Integer, CandidatePhrase&gt; matchedPhrases = new CollectionValuedMap&lt;&gt;();</span>
<span class="nc" id="L1069">        Map&lt;Integer, CandidatePhrase&gt; longestMatchedPhrases = new HashMap&lt;&gt;();</span>

<span class="nc bnc" id="L1071" title="All 2 branches missed.">        for (Entry&lt;CandidatePhrase, String[]&gt; sEn : seedwordsTokens.entrySet()) {</span>
<span class="nc" id="L1072">          String[] s = sEn.getValue();</span>
<span class="nc" id="L1073">          CandidatePhrase sc = sEn.getKey();</span>
<span class="nc" id="L1074">          List&lt;Integer&gt; indices = getSubListIndex(s, tokens, tokenslemma, doNotLabelDictWords, seenFuzzyMatches,</span>
<span class="nc bnc" id="L1075" title="All 2 branches missed.">              minLen4FuzzyForPattern, fuzzyMatch, (ignoreCaseSeedMatch.containsKey(label) ? Boolean.valueOf(ignoreCaseSeedMatch.get(label))  : false));</span>

<span class="nc bnc" id="L1077" title="All 4 branches missed.">          if (indices != null &amp;&amp; !indices.isEmpty()){</span>
<span class="nc" id="L1078">            String ph = StringUtils.join(s, &quot; &quot;);</span>
<span class="nc" id="L1079">            sc.addFeature(&quot;LENGTH-&quot; + s.length, 1.0);</span>

<span class="nc" id="L1081">            Collection&lt;String&gt; features = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L1083" title="All 2 branches missed.">            for (int index : indices){</span>
<span class="nc bnc" id="L1084" title="All 2 branches missed.">              if(graph != null){</span>
<span class="nc" id="L1085">                GetPatternsFromDataMultiClass.getFeatures(graph, graph.getNodeByIndex(index + 1), true, features, null);</span>
              }

<span class="nc bnc" id="L1088" title="All 2 branches missed.">              if(writeMatchedTokensIdsForEachPhrase) {</span>
<span class="nc" id="L1089">                addToMatchedTokensByPhrase(ph, k, index, s.length);</span>
              }

<span class="nc bnc" id="L1092" title="All 2 branches missed.">              for (int i = 0; i &lt; s.length; i++) {</span>
<span class="nc" id="L1093">                matchedPhrases.add(index + i, sc);</span>

<span class="nc bnc" id="L1095" title="All 2 branches missed.">                if(graph != null){</span>
                  try{
<span class="nc" id="L1097">                  GetPatternsFromDataMultiClass.getFeatures(graph, graph.getNodeByIndex(index+ i + 1), false, features, null);</span>
<span class="nc" id="L1098">                  } catch(Exception e) { log.warn(e); }</span>
                }

<span class="nc" id="L1101">                CandidatePhrase longPh = longestMatchedPhrases.get(index+i);</span>
<span class="nc bnc" id="L1102" title="All 4 branches missed.">                longPh = longPh != null &amp;&amp; longPh.getPhrase().length() &gt; sc.getPhrase().length() ? longPh: sc;</span>
<span class="nc" id="L1103">                longestMatchedPhrases.put(index+i, longPh);</span>

<span class="nc" id="L1105">                labels[index + i] = true;</span>
              }
<span class="nc" id="L1107">            }</span>
<span class="nc" id="L1108">          sc.addFeatures(features);</span>
          }
<span class="nc" id="L1110">        }</span>
<span class="nc" id="L1111">        int i = -1;</span>
<span class="nc bnc" id="L1112" title="All 2 branches missed.">        for (CoreLabel l : sent.getTokens()) {</span>
<span class="nc" id="L1113">          i++;</span>

          //The second clause is for old sents ser files compatibility reason
<span class="nc bnc" id="L1116" title="All 4 branches missed.">          if (!l.containsKey(PatternsAnnotations.MatchedPhrases.class) || !(PatternsAnnotations.MatchedPhrases.class.isInstance(l.get(PatternsAnnotations.MatchedPhrases.class))))</span>
<span class="nc" id="L1117">            l.set(PatternsAnnotations.MatchedPhrases.class, new CollectionValuedMap&lt;&gt;());</span>

<span class="nc bnc" id="L1119" title="All 2 branches missed.">          if(!l.containsKey(PatternsAnnotations.LongestMatchedPhraseForEachLabel.class))</span>
<span class="nc" id="L1120">            l.set(PatternsAnnotations.LongestMatchedPhraseForEachLabel.class, new HashMap&lt;&gt;());</span>

<span class="nc bnc" id="L1122" title="All 2 branches missed.">          if (labels[i]) {</span>
<span class="nc" id="L1123">            l.set(labelClass, label);</span>

            //set whether labeled by the seeds or not
<span class="nc bnc" id="L1126" title="All 2 branches missed.">            if(!l.containsKey(PatternsAnnotations.SeedLabeledOrNot.class))</span>
<span class="nc" id="L1127">              l.set(PatternsAnnotations.SeedLabeledOrNot.class, new HashMap&lt;&gt;());</span>
<span class="nc" id="L1128">            l.get(PatternsAnnotations.SeedLabeledOrNot.class).put(labelClass, true);</span>


<span class="nc" id="L1131">            CandidatePhrase longestMatchingPh = l.get(PatternsAnnotations.LongestMatchedPhraseForEachLabel.class).get(label);</span>
<span class="nc bnc" id="L1132" title="All 4 branches missed.">            assert longestMatchedPhrases.containsKey(i);</span>
<span class="nc bnc" id="L1133" title="All 4 branches missed.">            longestMatchingPh = (longestMatchingPh != null &amp;&amp; (longestMatchingPh.getPhrase().length() &gt; longestMatchedPhrases.get(i).getPhrase().length())) ? longestMatchingPh : longestMatchedPhrases.get(i);</span>
<span class="nc" id="L1134">            l.get(PatternsAnnotations.LongestMatchedPhraseForEachLabel.class).put(label, longestMatchingPh);</span>
<span class="nc" id="L1135">            matchedPhrasesCounter.incrementCount(longestMatchingPh, 1.0);</span>
<span class="nc" id="L1136">            l.get(PatternsAnnotations.MatchedPhrases.class).addAll(label, matchedPhrases.get(i));</span>

<span class="nc" id="L1138">            Redwood.log(ConstantsAndVariables.extremedebug, &quot;labeling &quot; + l.word() + &quot; or its lemma &quot; + l.lemma() + &quot; as &quot; + label</span>
<span class="nc" id="L1139">              + &quot; because of the dict phrases &quot; + matchedPhrases.get(i));</span>

<span class="nc bnc" id="L1141" title="All 2 branches missed.">          } else if(overwriteExistingLabels)</span>
<span class="nc" id="L1142">            l.set(labelClass, backgroundSymbol);</span>


<span class="nc" id="L1145">        }</span>
<span class="nc" id="L1146">        newsent.put(k, sent);</span>
<span class="nc" id="L1147">      }</span>
<span class="nc" id="L1148">      return new Pair(newsent, matchedPhrasesCounter);</span>
    }
  }

  private static void addToMatchedTokensByPhrase(String ph, String sentid, int index, int length){
<span class="nc bnc" id="L1153" title="All 2 branches missed.">    if(!Data.matchedTokensForEachPhrase.containsKey(ph))</span>
<span class="nc" id="L1154">      Data.matchedTokensForEachPhrase.put(ph, new HashMap&lt;&gt;());</span>
<span class="nc" id="L1155">    Map&lt;String, List&lt;Integer&gt;&gt; matcheds = Data.matchedTokensForEachPhrase.get(ph);</span>
<span class="nc bnc" id="L1156" title="All 2 branches missed.">    if(!matcheds.containsKey(sentid))</span>
<span class="nc" id="L1157">      matcheds.put(sentid, new ArrayList&lt;&gt;());</span>
<span class="nc bnc" id="L1158" title="All 2 branches missed.">    for (int i = 0; i &lt; length; i++)</span>
<span class="nc" id="L1159">      matcheds.get(sentid).add(index + i);</span>
<span class="nc" id="L1160">  }</span>

<span class="nc" id="L1162">  public Map&lt;String, TwoDimensionalCounter&lt;E, CandidatePhrase&gt;&gt; patternsandWords = null;</span>
  //public Map&lt;String, TwoDimensionalCounter&lt;E, String&gt;&gt; allPatternsandWords = null;
<span class="nc" id="L1164">  public Map&lt;String, Counter&lt;E&gt;&gt; currentPatternWeights = null;</span>

  //deleteExistingIndex is def false for the second call to this function
  public void processSents(Map&lt;String, DataInstance&gt; sents, Boolean deleteExistingIndex) throws IOException, ClassNotFoundException {

<span class="nc bnc" id="L1169" title="All 2 branches missed.">    if (constVars.computeAllPatterns) {</span>
<span class="nc" id="L1170">        props.setProperty(&quot;createTable&quot;, deleteExistingIndex.toString());</span>
<span class="nc" id="L1171">        props.setProperty(&quot;deleteExisting&quot;, deleteExistingIndex.toString());</span>
<span class="nc" id="L1172">        props.setProperty(&quot;createPatLuceneIndex&quot;, deleteExistingIndex.toString());</span>
<span class="nc" id="L1173">        Redwood.log(Redwood.DBG, &quot;Computing all patterns&quot;);</span>
<span class="nc" id="L1174">        createPats.getAllPatterns(sents, props, constVars.storePatsForEachToken);</span>
      }
    else
<span class="nc" id="L1177">      Redwood.log(Redwood.DBG, &quot;Reading patterns from existing dir&quot;);</span>

<span class="nc" id="L1179">    props.setProperty(&quot;createTable&quot;, &quot;false&quot;);</span>
<span class="nc" id="L1180">    props.setProperty(&quot;deleteExisting&quot;,&quot;false&quot;);</span>
<span class="nc" id="L1181">    props.setProperty(&quot;createPatLuceneIndex&quot;,&quot;false&quot;);</span>

<span class="nc" id="L1183">  }</span>

  private void readSavedPatternsAndIndex() throws IOException, ClassNotFoundException {
<span class="nc bnc" id="L1186" title="All 2 branches missed.">    if(!constVars.computeAllPatterns) {</span>
<span class="nc bnc" id="L1187" title="All 4 branches missed.">      assert constVars.allPatternsDir != null : &quot;allPatternsDir flag cannot be empty if computeAllPatterns is false!&quot;;</span>
      //constVars.setPatternIndex(PatternIndex.load(constVars.allPatternsDir, constVars.storePatsIndex));
<span class="nc bnc" id="L1189" title="All 2 branches missed.">      if(constVars.storePatsForEachToken.equals(ConstantsAndVariables.PatternForEachTokenWay.MEMORY))</span>
<span class="nc" id="L1190">        patsForEachToken.load(constVars.allPatternsDir);</span>
    }
<span class="nc" id="L1192">  }</span>

  @SuppressWarnings({ &quot;unchecked&quot; })
  public Counter&lt;E&gt; getPatterns(String label, Set&lt;E&gt; alreadyIdentifiedPatterns, E p0, Counter&lt;CandidatePhrase&gt; p0Set,
      Set&lt;E&gt; ignorePatterns) throws IOException, ClassNotFoundException {

<span class="nc" id="L1198">    TwoDimensionalCounter&lt;E, CandidatePhrase&gt; patternsandWords4Label = new TwoDimensionalCounter&lt;&gt;();</span>
<span class="nc" id="L1199">    TwoDimensionalCounter&lt;E, CandidatePhrase&gt; negPatternsandWords4Label = new TwoDimensionalCounter&lt;&gt;();</span>
    //TwoDimensionalCounter&lt;E, String&gt; posnegPatternsandWords4Label = new TwoDimensionalCounter&lt;E, String&gt;();
<span class="nc" id="L1201">    TwoDimensionalCounter&lt;E, CandidatePhrase&gt; unLabeledPatternsandWords4Label = new TwoDimensionalCounter&lt;&gt;();</span>
    //TwoDimensionalCounter&lt;E, String&gt; negandUnLabeledPatternsandWords4Label = new TwoDimensionalCounter&lt;E, String&gt;();
    //TwoDimensionalCounter&lt;E, String&gt; allPatternsandWords4Label = new TwoDimensionalCounter&lt;E, String&gt;();
<span class="nc" id="L1204">    Set&lt;String&gt; allCandidatePhrases = new HashSet&lt;&gt;();</span>

<span class="nc" id="L1206">    ConstantsAndVariables.DataSentsIterator sentsIter = new ConstantsAndVariables.DataSentsIterator(constVars.batchProcessSents);</span>

<span class="nc" id="L1208">    boolean firstCallToProcessSents = true;</span>
<span class="nc bnc" id="L1209" title="All 2 branches missed.">    while(sentsIter.hasNext()){</span>
<span class="nc" id="L1210">      Pair&lt;Map&lt;String, DataInstance&gt;, File&gt; sentsPair = sentsIter.next();</span>
<span class="nc bnc" id="L1211" title="All 2 branches missed.">      if(notComputedAllPatternsYet){</span>
        //in the first iteration
<span class="nc" id="L1213">        processSents(sentsPair.first(), firstCallToProcessSents);</span>
<span class="nc" id="L1214">        firstCallToProcessSents = false;</span>
<span class="nc bnc" id="L1215" title="All 2 branches missed.">        if(patsForEachToken == null){</span>
          //in the first iteration, for the first file
<span class="nc" id="L1217">          patsForEachToken = PatternsForEachToken.getPatternsInstance(props, constVars.storePatsForEachToken);</span>
<span class="nc" id="L1218">          readSavedPatternsAndIndex();</span>
        }
      }
<span class="nc" id="L1221">      this.calculateSufficientStats(sentsPair.first(), patsForEachToken, label, patternsandWords4Label, negPatternsandWords4Label, unLabeledPatternsandWords4Label, allCandidatePhrases);</span>
<span class="nc" id="L1222">    }</span>

<span class="nc" id="L1224">    notComputedAllPatternsYet = false;</span>

<span class="nc bnc" id="L1226" title="All 2 branches missed.">    if (constVars.computeAllPatterns){</span>
<span class="nc bnc" id="L1227" title="All 2 branches missed.">      if(constVars.storePatsForEachToken.equals(ConstantsAndVariables.PatternForEachTokenWay.DB))</span>
<span class="nc" id="L1228">        patsForEachToken.createIndexIfUsingDBAndNotExists();</span>


//        String systemdir = System.getProperty(&quot;java.io.tmpdir&quot;);
//        File tempFile= File.createTempFile(&quot;patterns&quot;, &quot;.tmp&quot;, new File(systemdir));
//        tempFile.deleteOnExit();
//        tempFile.delete();
//        constVars.allPatternsDir = tempFile.getAbsolutePath();


<span class="nc bnc" id="L1238" title="All 2 branches missed.">      if(constVars.allPatternsDir != null){</span>
<span class="nc" id="L1239">        IOUtils.ensureDir(new File(constVars.allPatternsDir));</span>
<span class="nc" id="L1240">        patsForEachToken.save(constVars.allPatternsDir);</span>
      }
      //savePatternIndex(constVars.allPatternsDir);
    }

<span class="nc" id="L1245">    patsForEachToken.close();</span>

    //This is important. It makes sure that we don't recompute patterns in every iteration!
<span class="nc" id="L1248">    constVars.computeAllPatterns = false;</span>


<span class="nc bnc" id="L1251" title="All 2 branches missed.">    if (patternsandWords == null)</span>
<span class="nc" id="L1252">      patternsandWords = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1253" title="All 2 branches missed.">    if (currentPatternWeights == null)</span>
<span class="nc" id="L1254">      currentPatternWeights = new HashMap&lt;&gt;();</span>

<span class="nc" id="L1256">    Counter&lt;E&gt; currentPatternWeights4Label = new ClassicCounter&lt;&gt;();</span>

<span class="nc" id="L1258">    Set&lt;E&gt; removePats = enforceMinSupportRequirements(patternsandWords4Label, unLabeledPatternsandWords4Label);</span>
<span class="nc" id="L1259">    Counters.removeKeys(patternsandWords4Label, removePats);</span>
<span class="nc" id="L1260">    Counters.removeKeys(unLabeledPatternsandWords4Label, removePats);</span>
<span class="nc" id="L1261">    Counters.removeKeys(negPatternsandWords4Label, removePats);</span>

    ScorePatterns scorePatterns;

<span class="nc" id="L1265">    Class&lt;?&gt; patternscoringclass = getPatternScoringClass(constVars.patternScoring);</span>

<span class="nc bnc" id="L1267" title="All 4 branches missed.">    if (patternscoringclass != null &amp;&amp; patternscoringclass.equals(ScorePatternsF1.class)) {</span>
<span class="nc" id="L1268">      scorePatterns = new ScorePatternsF1(constVars, constVars.patternScoring, label, allCandidatePhrases, patternsandWords4Label, negPatternsandWords4Label,</span>
          unLabeledPatternsandWords4Label, props, p0Set, p0);
<span class="nc" id="L1270">      Counter&lt;E&gt; finalPat = scorePatterns.score();</span>
<span class="nc" id="L1271">      Counters.removeKeys(finalPat, alreadyIdentifiedPatterns);</span>
<span class="nc" id="L1272">      Counters.retainNonZeros(finalPat);</span>
<span class="nc" id="L1273">      Counters.retainTop(finalPat, constVars.numPatterns);</span>
<span class="nc bnc" id="L1274" title="All 2 branches missed.">      if (Double.isNaN(Counters.max(finalPat)))</span>
<span class="nc" id="L1275">        throw new RuntimeException(&quot;how is the value NaN&quot;);</span>
<span class="nc" id="L1276">      Redwood.log(ConstantsAndVariables.minimaldebug, &quot;Selected Patterns: &quot; + finalPat);</span>
<span class="nc" id="L1277">      return finalPat;</span>

<span class="nc bnc" id="L1279" title="All 4 branches missed.">    } else if (patternscoringclass != null &amp;&amp; patternscoringclass.equals(ScorePatternsRatioModifiedFreq.class)) {</span>
<span class="nc" id="L1280">      scorePatterns = new ScorePatternsRatioModifiedFreq(constVars, constVars.patternScoring, label, allCandidatePhrases, patternsandWords4Label,</span>
          negPatternsandWords4Label, unLabeledPatternsandWords4Label, phInPatScoresCache, scorePhrases, props);

<span class="nc bnc" id="L1283" title="All 4 branches missed.">    } else if (patternscoringclass != null &amp;&amp; patternscoringclass.equals(ScorePatternsFreqBased.class)) {</span>
<span class="nc" id="L1284">      scorePatterns = new ScorePatternsFreqBased(constVars, constVars.patternScoring, label, allCandidatePhrases, patternsandWords4Label, negPatternsandWords4Label,</span>
          unLabeledPatternsandWords4Label, props);

<span class="nc bnc" id="L1287" title="All 2 branches missed.">    } else if (constVars.patternScoring.equals(PatternScoring.kNN)) {</span>
      try {
<span class="nc" id="L1289">        Class&lt;? extends ScorePatterns&gt; clazz = (Class&lt;? extends ScorePatterns&gt;) Class.forName(&quot;edu.stanford.nlp.patterns.ScorePatternsKNN&quot;);</span>
<span class="nc" id="L1290">        Constructor&lt;? extends ScorePatterns&gt; ctor = clazz.getConstructor(ConstantsAndVariables.class, PatternScoring.class, String.class, Set.class,</span>
            TwoDimensionalCounter.class, TwoDimensionalCounter.class, TwoDimensionalCounter.class, ScorePhrases.class, Properties.class);
<span class="nc" id="L1292">        scorePatterns = ctor.newInstance(constVars, constVars.patternScoring, label, allCandidatePhrases, patternsandWords4Label, negPatternsandWords4Label,</span>
            unLabeledPatternsandWords4Label, scorePhrases, props);

<span class="nc" id="L1295">      } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L1296">        throw new RuntimeException(&quot;kNN pattern scoring is not released yet. Stay tuned.&quot;);</span>
<span class="nc" id="L1297">      } catch (NoSuchMethodException | InvocationTargetException | InstantiationException | IllegalAccessException e) {</span>
<span class="nc" id="L1298">        throw new RuntimeException(&quot;newinstance of kNN not created&quot;, e);</span>
<span class="nc" id="L1299">      }</span>
    } else {
<span class="nc" id="L1301">      throw new RuntimeException(constVars.patternScoring + &quot; is not implemented (check spelling?). &quot;);</span>
    }

<span class="nc" id="L1304">    scorePatterns.setUp(props);</span>
<span class="nc" id="L1305">    currentPatternWeights4Label = scorePatterns.score();</span>

<span class="nc" id="L1307">    Redwood.log(ConstantsAndVariables.extremedebug, &quot;patterns counter size is &quot; + currentPatternWeights4Label.size());</span>

<span class="nc bnc" id="L1309" title="All 4 branches missed.">    if (ignorePatterns != null &amp;&amp; !ignorePatterns.isEmpty()) {</span>
<span class="nc" id="L1310">      Counters.removeKeys(currentPatternWeights4Label, ignorePatterns);</span>
<span class="nc" id="L1311">      Redwood.log(ConstantsAndVariables.extremedebug, &quot;Removing patterns from ignorePatterns of size  &quot; + ignorePatterns.size()</span>
<span class="nc" id="L1312">          + &quot;. New patterns size &quot; + currentPatternWeights4Label.size());</span>
    }

<span class="nc bnc" id="L1315" title="All 4 branches missed.">    if (alreadyIdentifiedPatterns != null &amp;&amp; !alreadyIdentifiedPatterns.isEmpty()) {</span>
<span class="nc" id="L1316">      Redwood.log(ConstantsAndVariables.extremedebug, &quot;Patterns size is &quot; + currentPatternWeights4Label.size());</span>
<span class="nc" id="L1317">        Counters.removeKeys(currentPatternWeights4Label, alreadyIdentifiedPatterns);</span>
<span class="nc" id="L1318">      Redwood.log(ConstantsAndVariables.extremedebug, &quot;Removing already identified patterns of size  &quot; + alreadyIdentifiedPatterns.size()</span>
<span class="nc" id="L1319">          + &quot;. New patterns size &quot; + currentPatternWeights4Label.size());</span>
    }

<span class="nc" id="L1322">    PriorityQueue&lt;E&gt; q = Counters.toPriorityQueue(currentPatternWeights4Label);</span>
<span class="nc" id="L1323">    int num = 0;</span>

<span class="nc" id="L1325">    Counter&lt;E&gt; chosenPat = new ClassicCounter&lt;&gt;();</span>

<span class="nc" id="L1327">    Set&lt;E&gt; removePatterns = new HashSet&lt;&gt;();</span>

<span class="nc" id="L1329">    Set&lt;E&gt; removeIdentifiedPatterns = null;</span>

<span class="nc bnc" id="L1331" title="All 4 branches missed.">    while (num &lt; constVars.numPatterns &amp;&amp; !q.isEmpty()) {</span>
<span class="nc" id="L1332">      E pat = q.removeFirst();</span>
      //E pat = constVars.getPatternIndex().get(patindex);

<span class="nc bnc" id="L1335" title="All 2 branches missed.">      if (currentPatternWeights4Label.getCount(pat) &lt; constVars.thresholdSelectPattern) {</span>
<span class="nc" id="L1336">        Redwood.log(Redwood.DBG, &quot;The max weight of candidate patterns is &quot; + df.format(currentPatternWeights4Label.getCount(pat))</span>
            + &quot; so not adding anymore patterns&quot;);
<span class="nc" id="L1338">        break;</span>
      }
<span class="nc" id="L1340">      boolean notchoose = false;</span>
<span class="nc bnc" id="L1341" title="All 4 branches missed.">      if (!unLabeledPatternsandWords4Label.containsFirstKey(pat) || unLabeledPatternsandWords4Label.getCounter(pat).isEmpty()) {</span>
<span class="nc" id="L1342">        Redwood.log(ConstantsAndVariables.extremedebug, &quot;Removing pattern &quot; + pat + &quot; because it has no unlab support; pos words: &quot;</span>
<span class="nc" id="L1343">            + patternsandWords4Label.getCounter(pat));</span>
<span class="nc" id="L1344">        notchoose = true;</span>
<span class="nc" id="L1345">        continue;</span>
      }

<span class="nc" id="L1348">      Set&lt;E&gt; removeChosenPats = null;</span>

<span class="nc bnc" id="L1350" title="All 2 branches missed.">      if (!notchoose) {</span>
<span class="nc bnc" id="L1351" title="All 2 branches missed.">        if (alreadyIdentifiedPatterns != null) {</span>
<span class="nc bnc" id="L1352" title="All 2 branches missed.">          for (E p : alreadyIdentifiedPatterns) {</span>
<span class="nc bnc" id="L1353" title="All 2 branches missed.">            if (Pattern.subsumes(constVars.patternType, pat, p)) {</span>
              // if (pat.getNextContextStr().contains(p.getNextContextStr()) &amp;&amp;
              // pat.getPrevContextStr().contains(p.getPrevContextStr())) {
<span class="nc" id="L1356">              Redwood.log(ConstantsAndVariables.extremedebug, &quot;Not choosing pattern &quot; + pat</span>
                  + &quot; because it is contained in or contains the already chosen pattern &quot; + p);
<span class="nc" id="L1358">              notchoose = true;</span>
<span class="nc" id="L1359">              break;</span>
            }

<span class="nc" id="L1362">            int rest = pat.equalContext(p);</span>
            // the contexts dont match
<span class="nc bnc" id="L1364" title="All 2 branches missed.">            if (rest == Integer.MAX_VALUE)</span>
<span class="nc" id="L1365">              continue;</span>
            // if pat is less restrictive, remove p and add pat!
<span class="nc bnc" id="L1367" title="All 2 branches missed.">            if (rest &lt; 0) {</span>
<span class="nc bnc" id="L1368" title="All 2 branches missed.">              if(removeIdentifiedPatterns == null)</span>
<span class="nc" id="L1369">                removeIdentifiedPatterns = new HashSet&lt;&gt;();</span>

<span class="nc" id="L1371">              removeIdentifiedPatterns.add(p);</span>
            } else {
<span class="nc" id="L1373">              notchoose = true;</span>
<span class="nc" id="L1374">              break;</span>
            }
<span class="nc" id="L1376">          }</span>
        }
      }

      // In this iteration:
<span class="nc bnc" id="L1381" title="All 2 branches missed.">      if (!notchoose) {</span>
<span class="nc bnc" id="L1382" title="All 2 branches missed.">        for (Pattern p : chosenPat.keySet()) {</span>
          //E p = constVars.getPatternIndex().get(pindex);

<span class="nc" id="L1385">          boolean removeChosenPatFlag = false;</span>
<span class="nc bnc" id="L1386" title="All 2 branches missed.">          if (Pattern.sameGenre(constVars.patternType, pat, p)) {</span>

<span class="nc bnc" id="L1388" title="All 2 branches missed.">            if(Pattern.subsumes(constVars.patternType, pat, p)){</span>
<span class="nc" id="L1389">              Redwood.log(ConstantsAndVariables.extremedebug, &quot;Not choosing pattern &quot; + pat</span>
                  + &quot; because it is contained in or contains the already chosen pattern &quot; + p);
<span class="nc" id="L1391">              notchoose = true;</span>
<span class="nc" id="L1392">              break;</span>
            }
<span class="nc bnc" id="L1394" title="All 2 branches missed.">            else if (E.subsumes(constVars.patternType, p, pat)) {</span>
              //subsume is true even if equal context

              //check if equal context
<span class="nc" id="L1398">              int rest = pat.equalContext(p);</span>

              // the contexts do not match
<span class="nc bnc" id="L1401" title="All 2 branches missed.">              if (rest == Integer.MAX_VALUE)</span>
              {
<span class="nc" id="L1403">                Redwood.log(ConstantsAndVariables.extremedebug, &quot;Not choosing pattern &quot; + p</span>
                    + &quot; because it is contained in or contains another chosen pattern in this iteration &quot; + pat);
<span class="nc" id="L1405">                removeChosenPatFlag = true;</span>
              }
              // if pat is less restrictive, remove p from chosen patterns and
              // add pat!
<span class="nc bnc" id="L1409" title="All 2 branches missed.">              else if (rest &lt; 0) {</span>
<span class="nc" id="L1410">                removeChosenPatFlag = true;</span>
              } else {
<span class="nc" id="L1412">                notchoose = true;</span>
<span class="nc" id="L1413">                break;</span>
              }
            }


<span class="nc bnc" id="L1418" title="All 2 branches missed.">            if (removeChosenPatFlag) {</span>
<span class="nc bnc" id="L1419" title="All 2 branches missed.">              if(removeChosenPats == null)</span>
<span class="nc" id="L1420">                removeChosenPats = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1421">              removeChosenPats.add(pat);</span>
<span class="nc" id="L1422">              num--;</span>
            }

          }
<span class="nc" id="L1426">        }</span>
      }

<span class="nc bnc" id="L1429" title="All 2 branches missed.">      if (notchoose) {</span>
<span class="nc" id="L1430">        Redwood.log(Redwood.DBG, &quot;Not choosing &quot; + pat + &quot; for whatever reason!&quot;);</span>
<span class="nc" id="L1431">        continue;</span>
      }

<span class="nc bnc" id="L1434" title="All 2 branches missed.">      if (removeChosenPats != null) {</span>
<span class="nc" id="L1435">        Redwood.log(ConstantsAndVariables.extremedebug, &quot;Removing already chosen patterns in this iteration &quot; + removeChosenPats + &quot; in favor of &quot;</span>
            + pat);
<span class="nc" id="L1437">        Counters.removeKeys(chosenPat, removeChosenPats);</span>
      }

<span class="nc bnc" id="L1440" title="All 2 branches missed.">      if (removeIdentifiedPatterns != null) {</span>
<span class="nc" id="L1441">        Redwood.log(ConstantsAndVariables.extremedebug, &quot;Removing already identified patterns &quot; + removeIdentifiedPatterns + &quot; in favor of &quot; + pat);</span>
<span class="nc" id="L1442">        removePatterns.addAll(removeIdentifiedPatterns);</span>

      }

<span class="nc" id="L1446">      chosenPat.setCount(pat, currentPatternWeights4Label.getCount(pat));</span>
<span class="nc" id="L1447">      num++;</span>

<span class="nc" id="L1449">    }</span>

<span class="nc" id="L1451">    this.removeLearnedPatterns(label, removePatterns);</span>

<span class="nc" id="L1453">    Redwood.log(Redwood.DBG, &quot;final size of the patterns is &quot; + chosenPat.size());</span>
<span class="nc" id="L1454">    Redwood.log(ConstantsAndVariables.minimaldebug, &quot;\n\n## Selected Patterns for &quot; + label + &quot;##\n&quot;);</span>
<span class="nc" id="L1455">    List&lt;Pair&lt;E, Double&gt;&gt; chosenPatSorted = Counters.toSortedListWithCounts(chosenPat);</span>
<span class="nc bnc" id="L1456" title="All 2 branches missed.">    for (Pair&lt;E, Double&gt; en : chosenPatSorted)</span>
<span class="nc" id="L1457">      Redwood.log(ConstantsAndVariables.minimaldebug, en.first() + &quot;:&quot; + df.format(en.second) + &quot;\n&quot;);</span>

<span class="nc bnc" id="L1459" title="All 4 branches missed.">    if (constVars.outDir != null &amp;&amp; !constVars.outDir.isEmpty()) {</span>
<span class="nc" id="L1460">      CollectionValuedMap&lt;E, CandidatePhrase&gt; posWords = new CollectionValuedMap&lt;&gt;();</span>
<span class="nc bnc" id="L1461" title="All 2 branches missed.">      for (Entry&lt;E, ClassicCounter&lt;CandidatePhrase&gt;&gt; en : patternsandWords4Label.entrySet()) {</span>
<span class="nc" id="L1462">        posWords.addAll(en.getKey(), en.getValue().keySet());</span>
<span class="nc" id="L1463">      }</span>

<span class="nc" id="L1465">      CollectionValuedMap&lt;E, CandidatePhrase&gt; negWords = new CollectionValuedMap&lt;&gt;();</span>
<span class="nc bnc" id="L1466" title="All 2 branches missed.">      for (Entry&lt;E, ClassicCounter&lt;CandidatePhrase&gt;&gt; en : negPatternsandWords4Label.entrySet()) {</span>
<span class="nc" id="L1467">        negWords.addAll(en.getKey(), en.getValue().keySet());</span>
<span class="nc" id="L1468">      }</span>
<span class="nc" id="L1469">      CollectionValuedMap&lt;E, CandidatePhrase&gt; unlabWords = new CollectionValuedMap&lt;&gt;();</span>
<span class="nc bnc" id="L1470" title="All 2 branches missed.">      for (Entry&lt;E, ClassicCounter&lt;CandidatePhrase&gt;&gt; en : unLabeledPatternsandWords4Label.entrySet()) {</span>
<span class="nc" id="L1471">        unlabWords.addAll(en.getKey(), en.getValue().keySet());</span>
<span class="nc" id="L1472">      }</span>

<span class="nc bnc" id="L1474" title="All 2 branches missed.">      if (constVars.outDir != null) {</span>
<span class="nc" id="L1475">        String outputdir = constVars.outDir + &quot;/&quot; + constVars.identifier + &quot;/&quot; + label;</span>
<span class="nc" id="L1476">        Redwood.log(ConstantsAndVariables.minimaldebug, &quot;Saving output in &quot; + outputdir);</span>

<span class="nc" id="L1478">        IOUtils.ensureDir(new File(outputdir));</span>

<span class="nc" id="L1480">        String filename = outputdir + &quot;/patterns&quot; + &quot;.json&quot;;</span>

<span class="nc" id="L1482">        JsonArrayBuilder obj = Json.createArrayBuilder();</span>
<span class="nc bnc" id="L1483" title="All 4 branches missed.">        if (writtenPatInJustification.containsKey(label) &amp;&amp; writtenPatInJustification.get(label)) {</span>
<span class="nc" id="L1484">          JsonReader jsonReader = Json.createReader(new BufferedInputStream(new FileInputStream(filename)));</span>
<span class="nc" id="L1485">          JsonArray objarr = jsonReader.readArray();</span>
<span class="nc" id="L1486">          jsonReader.close();</span>
<span class="nc bnc" id="L1487" title="All 2 branches missed.">          for (JsonValue o : objarr)</span>
<span class="nc" id="L1488">            obj.add(o);</span>
<span class="nc" id="L1489">        } else</span>
<span class="nc" id="L1490">          obj = Json.createArrayBuilder();</span>

<span class="nc" id="L1492">        JsonObjectBuilder objThisIter = Json.createObjectBuilder();</span>
<span class="nc bnc" id="L1493" title="All 2 branches missed.">        for (Pair&lt;E, Double&gt; pat : chosenPatSorted) {</span>
<span class="nc" id="L1494">          JsonObjectBuilder o = Json.createObjectBuilder();</span>
<span class="nc" id="L1495">          JsonArrayBuilder pos = Json.createArrayBuilder();</span>
<span class="nc" id="L1496">          JsonArrayBuilder neg = Json.createArrayBuilder();</span>
<span class="nc" id="L1497">          JsonArrayBuilder unlab = Json.createArrayBuilder();</span>

<span class="nc bnc" id="L1499" title="All 2 branches missed.">          for (CandidatePhrase w : posWords.get(pat.first()))</span>
<span class="nc" id="L1500">            pos.add(w.getPhrase());</span>
<span class="nc bnc" id="L1501" title="All 2 branches missed.">          for (CandidatePhrase w : negWords.get(pat.first()))</span>
<span class="nc" id="L1502">            neg.add(w.getPhrase());</span>
<span class="nc bnc" id="L1503" title="All 2 branches missed.">          for (CandidatePhrase w : unlabWords.get(pat.first()))</span>
<span class="nc" id="L1504">            unlab.add(w.getPhrase());</span>

<span class="nc" id="L1506">          o.add(&quot;Positive&quot;, pos);</span>
<span class="nc" id="L1507">          o.add(&quot;Negative&quot;, neg);</span>
<span class="nc" id="L1508">          o.add(&quot;Unlabeled&quot;, unlab);</span>
<span class="nc" id="L1509">          o.add(&quot;Score&quot;, pat.second());</span>

<span class="nc" id="L1511">          objThisIter.add(pat.first().toStringSimple(), o);</span>
<span class="nc" id="L1512">        }</span>
<span class="nc" id="L1513">        obj.add(objThisIter.build());</span>

<span class="nc" id="L1515">        IOUtils.ensureDir(new File(filename).getParentFile());</span>
<span class="nc" id="L1516">        IOUtils.writeStringToFile(StringUtils.normalize(StringUtils.toAscii(obj.build().toString())), filename, &quot;ASCII&quot;);</span>
<span class="nc" id="L1517">        writtenPatInJustification.put(label, true);</span>
      }
    }

<span class="nc bnc" id="L1521" title="All 2 branches missed.">    if (constVars.justify) {</span>
<span class="nc" id="L1522">      Redwood.log(Redwood.DBG, &quot;Justification for Patterns:&quot;);</span>
<span class="nc bnc" id="L1523" title="All 2 branches missed.">      for (E key : chosenPat.keySet()) {</span>
<span class="nc" id="L1524">        Redwood.log(Redwood.DBG, &quot;\nPattern: &quot; + key);</span>
<span class="nc" id="L1525">        Redwood.log(</span>
            Redwood.DBG,
            &quot;Positive Words:&quot;
<span class="nc" id="L1528">                + Counters.toSortedString(patternsandWords4Label.getCounter(key), patternsandWords4Label.getCounter(key).size(), &quot;%1$s:%2$f&quot;, &quot;;&quot;));</span>

<span class="nc" id="L1530">        Redwood.log(</span>
            Redwood.DBG,
            &quot;Negative Words:&quot;
<span class="nc" id="L1533">                + Counters.toSortedString(negPatternsandWords4Label.getCounter(key), negPatternsandWords4Label.getCounter(key).size(), &quot;%1$s:%2$f&quot;,</span>
                    &quot;;&quot;));

<span class="nc" id="L1536">        Redwood.log(</span>
            Redwood.DBG,
            &quot;Unlabeled Words:&quot;
<span class="nc" id="L1539">                + Counters.toSortedString(unLabeledPatternsandWords4Label.getCounter(key), unLabeledPatternsandWords4Label.getCounter(key).size(),</span>
                    &quot;%1$s:%2$f&quot;, &quot;;&quot;));
<span class="nc" id="L1541">      }</span>
    }
    //allPatternsandWords.put(label, allPatternsandWords4Label);
<span class="nc" id="L1544">    patternsandWords.put(label, patternsandWords4Label);</span>
<span class="nc" id="L1545">    currentPatternWeights.put(label, currentPatternWeights4Label);</span>

<span class="nc" id="L1547">    return chosenPat;</span>

  }

//  private void savePatternIndex(String dir ) throws IOException {
//    if(dir != null) {
//      IOUtils.ensureDir(new File(dir));
//      constVars.getPatternIndex().save(dir);
//    }
//    //patsForEachToken.savePatternIndex(constVars.getPatternIndex(), dir);
//
//  }

  public static Class getPatternScoringClass(PatternScoring patternScoring) {
<span class="nc bnc" id="L1561" title="All 2 branches missed.">    if (patternScoring.equals(PatternScoring.F1SeedPattern)) {</span>
<span class="nc" id="L1562">      return ScorePatternsF1.class;</span>
<span class="nc bnc" id="L1563" title="All 4 branches missed.">    } else if (patternScoring.equals(PatternScoring.PosNegUnlabOdds) || patternScoring.equals(PatternScoring.PosNegOdds)</span>
<span class="nc bnc" id="L1564" title="All 4 branches missed.">        || patternScoring.equals(PatternScoring.RatioAll) || patternScoring.equals(PatternScoring.PhEvalInPat)</span>
<span class="nc bnc" id="L1565" title="All 4 branches missed.">        || patternScoring.equals(PatternScoring.PhEvalInPatLogP) || patternScoring.equals(PatternScoring.LOGREG)</span>
<span class="nc bnc" id="L1566" title="All 4 branches missed.">        || patternScoring.equals(PatternScoring.LOGREGlogP) || patternScoring.equals(PatternScoring.SqrtAllRatio)) {</span>

<span class="nc" id="L1568">      return ScorePatternsRatioModifiedFreq.class;</span>

<span class="nc bnc" id="L1570" title="All 4 branches missed.">    } else if (patternScoring.equals(PatternScoring.RlogF) || patternScoring.equals(PatternScoring.RlogFPosNeg)</span>
<span class="nc bnc" id="L1571" title="All 4 branches missed.">        || patternScoring.equals(PatternScoring.RlogFUnlabNeg) || patternScoring.equals(PatternScoring.RlogFNeg)</span>
<span class="nc bnc" id="L1572" title="All 4 branches missed.">        || patternScoring.equals(PatternScoring.YanGarber02) || patternScoring.equals(PatternScoring.LinICML03)) {</span>
<span class="nc" id="L1573">      return ScorePatternsFreqBased.class;</span>

    } else {
<span class="nc" id="L1576">      return null;</span>
    }
  }

<span class="fc" id="L1580">  private static AtomicInteger numCallsToCalStats = new AtomicInteger();</span>


  private static &lt;E&gt; List&lt;List&lt;E&gt;&gt; splitIntoNumThreadsWithSampling(List&lt;E&gt; c, int n, int numThreads) {
<span class="nc bnc" id="L1584" title="All 2 branches missed.">    if (n &lt; 0)</span>
<span class="nc" id="L1585">      throw new IllegalArgumentException(&quot;n &lt; 0: &quot; + n);</span>
<span class="nc bnc" id="L1586" title="All 2 branches missed.">    if (n &gt; c.size())</span>
<span class="nc" id="L1587">      throw new IllegalArgumentException(&quot;n &gt; size of collection: &quot; + n + &quot;, &quot; + c.size());</span>
<span class="nc" id="L1588">    List&lt;List&lt;E&gt;&gt; resultAll = new ArrayList&lt;&gt;(numThreads);</span>
    int num;

<span class="nc bnc" id="L1591" title="All 2 branches missed.">    if (numThreads == 1)</span>
<span class="nc" id="L1592">      num = n;</span>
    else
<span class="nc" id="L1594">      num = n / (numThreads - 1);</span>

<span class="nc" id="L1596">    System.out.println(&quot;shuffled &quot; + c.size() + &quot; sentences and selecting &quot; + num  + &quot; sentences per thread&quot;);</span>
<span class="nc" id="L1597">    List&lt;E&gt; result = new ArrayList&lt;&gt;(num);</span>
<span class="nc" id="L1598">    int totalitems = 0;</span>
<span class="nc" id="L1599">    int nitem = 0;</span>
<span class="nc" id="L1600">    Random r = new Random(numCallsToCalStats.incrementAndGet());</span>
<span class="nc" id="L1601">    boolean[] added = new boolean[c.size()];</span>
    // Arrays.fill(added, false);  // not needed; get false by default
<span class="nc bnc" id="L1603" title="All 2 branches missed.">    while(totalitems &lt; n){</span>

      //find the new sample index
      int index;

      do{
<span class="nc" id="L1609">        index =  r.nextInt(c.size());</span>
<span class="nc bnc" id="L1610" title="All 2 branches missed.">      }while(added[index]);</span>
<span class="nc" id="L1611">      added[index] = true;</span>

<span class="nc" id="L1613">      E c1 = c.get(index);</span>

<span class="nc bnc" id="L1615" title="All 2 branches missed.">      if(nitem == num){</span>
<span class="nc" id="L1616">        resultAll.add(result);</span>
<span class="nc" id="L1617">        result = new ArrayList&lt;&gt;(num);</span>
<span class="nc" id="L1618">        nitem= 0;</span>
      }
<span class="nc" id="L1620">      result.add(c1);</span>
<span class="nc" id="L1621">      totalitems++;</span>
<span class="nc" id="L1622">      nitem ++;</span>
<span class="nc" id="L1623">    }</span>

<span class="nc bnc" id="L1625" title="All 2 branches missed.">    if(!result.isEmpty())</span>
<span class="nc" id="L1626">      resultAll.add(result);</span>
<span class="nc" id="L1627">    return resultAll;</span>
  }

  //for each pattern, it calculates positive, negative, and unlabeled words
  private void calculateSufficientStats(Map&lt;String, DataInstance&gt; sents,
                                        PatternsForEachToken patternsForEachToken, String label,
                                        TwoDimensionalCounter&lt;E, CandidatePhrase&gt; patternsandWords4Label,
                                        TwoDimensionalCounter&lt;E, CandidatePhrase&gt; negPatternsandWords4Label,
                                        TwoDimensionalCounter&lt;E, CandidatePhrase&gt; unLabeledPatternsandWords4Label, Set&lt;String&gt; allCandidatePhrases) {

<span class="nc" id="L1637">    Redwood.log(Redwood.DBG,&quot;calculating sufficient stats&quot;);</span>
<span class="nc" id="L1638">    patternsForEachToken.setupSearch();</span>
    // calculating the sufficient statistics
<span class="nc" id="L1640">    Class answerClass4Label = constVars.getAnswerClass().get(label);</span>
<span class="nc bnc" id="L1641" title="All 2 branches missed.">    int sampleSize = constVars.sampleSentencesForSufficientStats == 1.0 ? sents.size(): (int) Math.round(constVars.sampleSentencesForSufficientStats*sents.size());</span>
<span class="nc" id="L1642">    List&lt;List&lt;String&gt;&gt; sampledSentIds = splitIntoNumThreadsWithSampling(CollectionUtils.toList(sents.keySet()), sampleSize, constVars.numThreads);</span>
<span class="nc" id="L1643">    Redwood.log(Redwood.DBG,&quot;sampled &quot; + sampleSize + &quot; sentences (&quot; + constVars.sampleSentencesForSufficientStats*100 + &quot;%)&quot;);</span>

<span class="nc" id="L1645">    ExecutorService executor = Executors.newFixedThreadPool(constVars.numThreads);</span>

<span class="nc" id="L1647">    List&lt;Future&lt;Triple&lt;List&lt;Pair&lt;E, CandidatePhrase&gt;&gt;, List&lt;Pair&lt;E, CandidatePhrase&gt;&gt;, List&lt;Pair&lt;E, CandidatePhrase&gt;&gt;&gt;&gt;&gt; list = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1648" title="All 2 branches missed.">    for (List&lt;String&gt; sampledSents : sampledSentIds) {</span>

<span class="nc" id="L1650">      Callable&lt;Triple&lt;List&lt;Pair&lt;E, CandidatePhrase&gt;&gt;, List&lt;Pair&lt;E, CandidatePhrase&gt;&gt;, List&lt;Pair&lt;E, CandidatePhrase&gt;&gt;&gt;&gt; task = new CalculateSufficientStatsThreads(patternsForEachToken, sampledSents, sents, label, answerClass4Label);</span>
<span class="nc" id="L1651">      Future&lt;Triple&lt;List&lt;Pair&lt;E, CandidatePhrase&gt;&gt;, List&lt;Pair&lt;E, CandidatePhrase&gt;&gt;, List&lt;Pair&lt;E, CandidatePhrase&gt;&gt;&gt;&gt; submit = executor.submit(task);</span>
<span class="nc" id="L1652">      list.add(submit);</span>
<span class="nc" id="L1653">    }</span>

    // Now retrieve the result
<span class="nc bnc" id="L1656" title="All 2 branches missed.">    for (Future&lt;Triple&lt;List&lt;Pair&lt;E, CandidatePhrase&gt;&gt;, List&lt;Pair&lt;E, CandidatePhrase&gt;&gt;, List&lt;Pair&lt;E, CandidatePhrase&gt;&gt;&gt;&gt; future : list) {</span>
      try {
<span class="nc" id="L1658">        Triple&lt;List&lt;Pair&lt;E, CandidatePhrase&gt;&gt;, List&lt;Pair&lt;E, CandidatePhrase&gt;&gt;, List&lt;Pair&lt;E, CandidatePhrase&gt;&gt;&gt; stats = future.get();</span>
<span class="nc" id="L1659">        addStats(patternsandWords4Label, stats.first());</span>
<span class="nc" id="L1660">        addStats(negPatternsandWords4Label, stats.second());</span>
<span class="nc" id="L1661">        addStats(unLabeledPatternsandWords4Label, stats.third());</span>
<span class="nc" id="L1662">      } catch (Exception e) {</span>
<span class="nc" id="L1663">        executor.shutdownNow();</span>
<span class="nc" id="L1664">        throw new RuntimeException(e);</span>
<span class="nc" id="L1665">      }</span>
<span class="nc" id="L1666">    }</span>
<span class="nc" id="L1667">    executor.shutdown();</span>


<span class="nc" id="L1670">  }</span>

  private void addStats(TwoDimensionalCounter&lt;E, CandidatePhrase&gt; pw, List&lt;Pair&lt;E, CandidatePhrase&gt;&gt; v) {
<span class="nc bnc" id="L1673" title="All 2 branches missed.">    for(Pair&lt;E, CandidatePhrase&gt; w: v){</span>
<span class="nc" id="L1674">      pw.incrementCount(w.first(), w.second());</span>
<span class="nc" id="L1675">    }</span>
<span class="nc" id="L1676">  }</span>

  private class CalculateSufficientStatsThreads implements Callable{

    private final Map&lt;String, DataInstance&gt; sents;
    private final PatternsForEachToken patternsForEachToken;
    private final Collection&lt;String&gt; sentIds;
    private final String label;
    private final Class answerClass4Label;

<span class="nc" id="L1686">    public CalculateSufficientStatsThreads(PatternsForEachToken patternsForEachToken, Collection&lt;String&gt; sentIds, Map&lt;String, DataInstance&gt; sents,String label, Class answerClass4Label){</span>
<span class="nc" id="L1687">      this.patternsForEachToken = patternsForEachToken;</span>
<span class="nc" id="L1688">      this.sentIds = sentIds;</span>
<span class="nc" id="L1689">      this.sents = sents;</span>
<span class="nc" id="L1690">      this.label = label;</span>
<span class="nc" id="L1691">      this.answerClass4Label = answerClass4Label;</span>
<span class="nc" id="L1692">    }</span>

    @Override
    public Triple&lt;List&lt;Pair&lt;E, CandidatePhrase&gt;&gt;, List&lt;Pair&lt;E, CandidatePhrase&gt;&gt;, List&lt;Pair&lt;E, CandidatePhrase&gt;&gt;&gt; call() throws Exception {

<span class="nc" id="L1697">      List&lt;Pair&lt;E, CandidatePhrase&gt;&gt; posWords = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1698">      List&lt;Pair&lt;E, CandidatePhrase&gt;&gt; negWords = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1699">      List&lt;Pair&lt;E, CandidatePhrase&gt;&gt; unlabWords = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1700" title="All 2 branches missed.">      for(String sentId: sentIds){</span>
<span class="nc" id="L1701">        Map&lt;Integer, Set&lt;E&gt;&gt; pat4Sent = patternsForEachToken.getPatternsForAllTokens(sentId);</span>
<span class="nc bnc" id="L1702" title="All 2 branches missed.">        if (pat4Sent == null) {</span>
<span class="nc" id="L1703">          throw new RuntimeException(&quot;How come there are no patterns for &quot; + sentId);</span>
        }
<span class="nc" id="L1705">        DataInstance sent = sents.get(sentId);</span>
<span class="nc" id="L1706">        List&lt;CoreLabel&gt; tokens = sent.getTokens();</span>
<span class="nc bnc" id="L1707" title="All 2 branches missed.">        for (int i = 0; i &lt; tokens.size(); i++) {</span>
<span class="nc" id="L1708">          CoreLabel token = tokens.get(i);</span>
          //Map&lt;String, Set&lt;String&gt;&gt; matchedPhrases = token.get(PatternsAnnotations.MatchedPhrases.class);

<span class="nc" id="L1711">          CandidatePhrase tokenWordOrLemma = CandidatePhrase.createOrGet(token.word());</span>
          CandidatePhrase longestMatchingPhrase;

<span class="nc bnc" id="L1714" title="All 2 branches missed.">          if (constVars.useMatchingPhrase) {</span>
<span class="nc" id="L1715">            Map&lt;String, CandidatePhrase&gt; longestMatchingPhrases = token.get(PatternsAnnotations.LongestMatchedPhraseForEachLabel.class);</span>
<span class="nc" id="L1716">            longestMatchingPhrase = longestMatchingPhrases.get(label);</span>
<span class="nc bnc" id="L1717" title="All 4 branches missed.">            longestMatchingPhrase = (longestMatchingPhrase !=null &amp;&amp; (longestMatchingPhrase.getPhrase().length() &gt; tokenWordOrLemma.getPhrase().length()))? longestMatchingPhrase : tokenWordOrLemma;</span>
          /*if (matchedPhrases != null &amp;&amp; !matchedPhrases.isEmpty()) {
            for (String s : matchedPhrases) {
              if (s.equals(tokenWordOrLemma)) {
                longestMatchingPhrase = tokenWordOrLemma;
                break;
              }
              if (longestMatchingPhrase == null || longestMatchingPhrase.length() &gt; s.length()) {
                longestMatchingPhrase = s;
              }
            }
          } else {
            longestMatchingPhrase = tokenWordOrLemma;
          }*/

<span class="nc" id="L1732">          } else</span>
<span class="nc" id="L1733">            longestMatchingPhrase = tokenWordOrLemma;</span>

<span class="nc" id="L1735">          Set&lt;E&gt; pats = pat4Sent.get(i);</span>

          //make a copy of pats because we are changing numwordscompound etc.
<span class="nc" id="L1738">          Set newpats = new HashSet&lt;E&gt;();</span>
<span class="nc" id="L1739">          boolean changedpats = false;</span>
<span class="nc bnc" id="L1740" title="All 2 branches missed.">          for (E s : pats) {</span>
<span class="nc bnc" id="L1741" title="All 2 branches missed.">            if(s instanceof SurfacePattern){</span>
<span class="nc" id="L1742">              changedpats = true;</span>
<span class="nc" id="L1743">              SurfacePattern snew = ((SurfacePattern) s).copyNewToken();</span>
<span class="nc" id="L1744">              snew.setNumWordsCompound(PatternFactory.numWordsCompoundMapped.get(label));</span>
<span class="nc" id="L1745">              newpats.add(snew);</span>
            }
<span class="nc" id="L1747">          }</span>

<span class="nc bnc" id="L1749" title="All 2 branches missed.">          if(changedpats)</span>
<span class="nc" id="L1750">            pats = newpats;</span>

          //This happens when dealing with the collapseddependencies
<span class="nc bnc" id="L1753" title="All 2 branches missed.">          if (pats == null) {</span>
<span class="nc bnc" id="L1754" title="All 2 branches missed.">            if(!constVars.patternType.equals(PatternFactory.PatternType.DEP))</span>
<span class="nc bnc" id="L1755" title="All 2 branches missed.">              throw new RuntimeException(&quot;Why are patterns null for sentence &quot; + sentId + &quot; and token &quot; + i + &quot;(&quot; + tokens.get(i) + &quot;). pat4Sent has token ids &quot; + pat4Sent.keySet() +</span>
<span class="nc" id="L1756">                (constVars.batchProcessSents ? &quot;&quot; : &quot;. The sentence is &quot; + Data.sents.get(sentId)) + &quot;. If you have changed parameters, recompute all patterns.&quot;);</span>
            continue;
          }

//        Set&lt;E&gt; prevPat = pat.first();
//        Set&lt;E&gt; nextPat = pat.second();
//        Set&lt;E&gt; prevnextPat = pat.third();
<span class="nc bnc" id="L1763" title="All 2 branches missed.">          if (PatternFactory.ignoreWordRegex.matcher(token.word()).matches())</span>
<span class="nc" id="L1764">            continue;</span>

          // if the target word/phrase does not satisfy the POS requirement
<span class="nc" id="L1767">          String tag = token.tag();</span>
<span class="nc bnc" id="L1768" title="All 4 branches missed.">          if (constVars.allowedTagsInitials != null &amp;&amp; constVars.allowedTagsInitials.containsKey(label)) {</span>
<span class="nc" id="L1769">            boolean use = false;</span>
<span class="nc bnc" id="L1770" title="All 2 branches missed.">            for (String allowed : constVars.allowedTagsInitials.get(label)) {</span>
<span class="nc bnc" id="L1771" title="All 2 branches missed.">              if (tag.startsWith(allowed)) {</span>
<span class="nc" id="L1772">                use = true;</span>
<span class="nc" id="L1773">                break;</span>
              }
<span class="nc" id="L1775">            }</span>
<span class="nc bnc" id="L1776" title="All 2 branches missed.">            if (!use)</span>
<span class="nc" id="L1777">              continue;</span>
          }

          // if the target word/phrase does not satisfy the NER requirements
<span class="nc" id="L1781">          String nertag = token.ner();</span>
<span class="nc bnc" id="L1782" title="All 4 branches missed.">          if (constVars.allowedNERsforLabels != null &amp;&amp; constVars.allowedNERsforLabels.containsKey(label)) {</span>
<span class="nc bnc" id="L1783" title="All 2 branches missed.">            if (!constVars.allowedNERsforLabels.get(label).contains(nertag)) {</span>
<span class="nc" id="L1784">              continue;</span>
            }
          }

<span class="nc bnc" id="L1788" title="All 2 branches missed.">          if (token.get(answerClass4Label).equals(label)) {</span>
            // Positive
<span class="nc bnc" id="L1790" title="All 2 branches missed.">            for (E s : pats) {</span>
<span class="nc" id="L1791">              posWords.add(new Pair&lt;&gt;(s, longestMatchingPhrase));</span>
<span class="nc" id="L1792">            }</span>

          } else {
            // Negative or unlabeled
<span class="nc" id="L1796">            boolean negToken = false;</span>
<span class="nc" id="L1797">            Map&lt;Class, Object&gt; ignore = constVars.getIgnoreWordswithClassesDuringSelection().get(label);</span>
<span class="nc bnc" id="L1798" title="All 2 branches missed.">            for (Class igCl : ignore.keySet())</span>
<span class="nc bnc" id="L1799" title="All 2 branches missed.">              if ((Boolean) token.get(igCl)) {</span>
<span class="nc" id="L1800">                negToken = true;</span>
<span class="nc" id="L1801">                break;</span>
              }
<span class="nc bnc" id="L1803" title="All 2 branches missed.">            if (!negToken)</span>
<span class="nc bnc" id="L1804" title="All 4 branches missed.">              if (constVars.getOtherSemanticClassesWords().contains(token.word()) || constVars.getOtherSemanticClassesWords().contains(token.lemma()))</span>
<span class="nc" id="L1805">                negToken = true;</span>

<span class="nc bnc" id="L1807" title="All 2 branches missed.">            if(!negToken){</span>
<span class="nc bnc" id="L1808" title="All 2 branches missed.">              for(String labelA : constVars.getLabels()){</span>
<span class="nc bnc" id="L1809" title="All 2 branches missed.">                if(!labelA.equals(label)){</span>
<span class="nc bnc" id="L1810" title="All 4 branches missed.">                  if(constVars.getSeedLabelDictionary().get(labelA).contains(longestMatchingPhrase) || constVars.getSeedLabelDictionary().get(labelA).contains(tokenWordOrLemma)</span>
<span class="nc bnc" id="L1811" title="All 4 branches missed.">                    || constVars.getLearnedWords(labelA).containsKey(longestMatchingPhrase) || constVars.getLearnedWords(labelA).containsKey(tokenWordOrLemma)){</span>
<span class="nc" id="L1812">                    negToken = true;</span>
<span class="nc" id="L1813">                    break;</span>
                  }
                }
<span class="nc" id="L1816">              }</span>
            }

<span class="nc bnc" id="L1819" title="All 2 branches missed.">            for (E sindex : pats) {</span>
<span class="nc bnc" id="L1820" title="All 2 branches missed.">              if (negToken) {</span>
<span class="nc" id="L1821">                negWords.add(new Pair&lt;&gt;(sindex, longestMatchingPhrase));</span>
              } else {
<span class="nc" id="L1823">                unlabWords.add(new Pair&lt;&gt;(sindex, longestMatchingPhrase));</span>
              }

<span class="nc" id="L1826">            }</span>
          }
        }
<span class="nc" id="L1829">      }</span>
<span class="nc" id="L1830">      return new Triple&lt;List&lt;Pair&lt;E, CandidatePhrase&gt;&gt;, List&lt;Pair&lt;E, CandidatePhrase&gt;&gt;, List&lt;Pair&lt;E, CandidatePhrase&gt;&gt;&gt;(posWords, negWords, unlabWords);</span>
    }
  }

  private Set&lt;E&gt; enforceMinSupportRequirements(TwoDimensionalCounter&lt;E, CandidatePhrase&gt; patternsandWords4Label,
      TwoDimensionalCounter&lt;E, CandidatePhrase&gt; unLabeledPatternsandWords4Label) {
<span class="nc" id="L1836">    Set&lt;E&gt; remove = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L1837" title="All 2 branches missed.">    for (Entry&lt;E, ClassicCounter&lt;CandidatePhrase&gt;&gt; en : patternsandWords4Label.entrySet()) {</span>
<span class="nc bnc" id="L1838" title="All 2 branches missed.">      if (en.getValue().size() &lt; constVars.minPosPhraseSupportForPat) {</span>
<span class="nc" id="L1839">        remove.add(en.getKey());</span>
      }

<span class="nc" id="L1842">    }</span>
<span class="nc" id="L1843">    int numRemoved = remove.size();</span>
<span class="nc" id="L1844">    Redwood.log(Redwood.DBG, &quot;Removing &quot; + numRemoved + &quot; patterns that do not meet minPosPhraseSupportForPat requirement of &gt;= &quot;</span>
        + constVars.minPosPhraseSupportForPat);

<span class="nc bnc" id="L1847" title="All 2 branches missed.">    for (Entry&lt;E, ClassicCounter&lt;CandidatePhrase&gt;&gt; en : unLabeledPatternsandWords4Label.entrySet()) {</span>
<span class="nc bnc" id="L1848" title="All 2 branches missed.">      if (en.getValue().size() &lt; constVars.minUnlabPhraseSupportForPat) {</span>
<span class="nc" id="L1849">        remove.add(en.getKey());</span>
      }
<span class="nc" id="L1851">    }</span>
<span class="nc" id="L1852">    Redwood.log(Redwood.DBG, &quot;Removing &quot; + (remove.size() - numRemoved) + &quot; patterns that do not meet minUnlabPhraseSupportForPat requirement of &gt;= &quot;</span>
        + constVars.minUnlabPhraseSupportForPat);
<span class="nc" id="L1854">    return remove;</span>
  }

//  void removeLearnedPattern(String label, E p) {
//    this.learnedPatterns.get(label).remove(p);
//    if (wordsPatExtracted.containsKey(label))
//      for (Entry&lt;String, ClassicCounter&lt;E&gt;&gt; en : this.wordsPatExtracted.get(label).entrySet()) {
//        en.getValue().remove(p);
//      }
//  }

  private void removeLearnedPatterns(String label, Collection&lt;E&gt; pats) {
<span class="nc" id="L1866">    Counters.removeKeys(this.learnedPatterns.get(label), pats);</span>

<span class="nc bnc" id="L1868" title="All 2 branches missed.">    for(Map.Entry&lt;Integer, Counter&lt;E&gt;&gt; en: this.learnedPatternsEachIter.get(label).entrySet())</span>
<span class="nc" id="L1869">      Counters.removeKeys(en.getValue(), pats);</span>

<span class="nc bnc" id="L1871" title="All 2 branches missed.">    if (wordsPatExtracted.containsKey(label))</span>
<span class="nc bnc" id="L1872" title="All 2 branches missed.">      for (Entry&lt;CandidatePhrase, ClassicCounter&lt;E&gt;&gt; en : this.wordsPatExtracted.get(label).entrySet()) {</span>
<span class="nc" id="L1873">        Counters.removeKeys(en.getValue(), pats);</span>
<span class="nc" id="L1874">      }</span>
<span class="nc" id="L1875">  }</span>

  public static &lt;E&gt; Counter&lt;E&gt; normalizeSoftMaxMinMaxScores(Counter&lt;E&gt; scores, boolean minMaxNorm, boolean softmax, boolean oneMinusSoftMax) {
<span class="nc" id="L1878">    double minScore = Double.MAX_VALUE, maxScore = Double.MIN_VALUE;</span>
<span class="nc" id="L1879">    Counter&lt;E&gt; newscores = new ClassicCounter&lt;&gt;();</span>
<span class="nc bnc" id="L1880" title="All 2 branches missed.">    if (softmax) {</span>
<span class="nc bnc" id="L1881" title="All 2 branches missed.">      for (Entry&lt;E, Double&gt; en : scores.entrySet()) {</span>
<span class="nc" id="L1882">        Double score = null;</span>
<span class="nc bnc" id="L1883" title="All 2 branches missed.">        if (oneMinusSoftMax)</span>
<span class="nc" id="L1884">          score = (1 / (1 + Math.exp(Math.min(7, en.getValue()))));</span>
        else
<span class="nc" id="L1886">          score = (1 / (1 + Math.exp(-1 * Math.min(7, en.getValue()))));</span>
<span class="nc bnc" id="L1887" title="All 2 branches missed.">        if (score &lt; minScore)</span>
<span class="nc" id="L1888">          minScore = score;</span>
<span class="nc bnc" id="L1889" title="All 2 branches missed.">        if (score &gt; maxScore)</span>
<span class="nc" id="L1890">          maxScore = score;</span>
<span class="nc" id="L1891">        newscores.setCount(en.getKey(), score);</span>
<span class="nc" id="L1892">      }</span>
    } else {
<span class="nc" id="L1894">      newscores.addAll(scores);</span>
<span class="nc" id="L1895">      minScore = Counters.min(newscores);</span>
<span class="nc" id="L1896">      maxScore = Counters.max(newscores);</span>
    }

<span class="nc bnc" id="L1899" title="All 2 branches missed.">    if (minMaxNorm) {</span>
<span class="nc bnc" id="L1900" title="All 2 branches missed.">      for (Entry&lt;E, Double&gt; en : newscores.entrySet()) {</span>
        double score;
<span class="nc bnc" id="L1902" title="All 2 branches missed.">        if (minScore == maxScore)</span>
<span class="nc" id="L1903">          score = minScore;</span>
        else
<span class="nc" id="L1905">          score = (en.getValue() - minScore + 1e-10) / (maxScore - minScore);</span>
<span class="nc" id="L1906">        newscores.setCount(en.getKey(), score);</span>
<span class="nc" id="L1907">      }</span>
    }
<span class="nc" id="L1909">    return newscores;</span>
  }

<span class="nc" id="L1912">  public TwoDimensionalCounter&lt;String, ScorePhraseMeasures&gt; phInPatScoresCache = new TwoDimensionalCounter&lt;&gt;();</span>


  public void labelWords(String label, Map&lt;String, DataInstance&gt; sents, Collection&lt;CandidatePhrase&gt; identifiedWords) throws IOException {
<span class="nc" id="L1916">    CollectionValuedMap&lt;E, Triple&lt;String, Integer, Integer&gt;&gt; matchedTokensByPat = new CollectionValuedMap&lt;&gt;();</span>
<span class="nc" id="L1917">    labelWords(label, sents, identifiedWords, null, matchedTokensByPat);</span>
<span class="nc" id="L1918">  }</span>

  public void labelWords(String label, Map&lt;String, DataInstance&gt; sents, Collection&lt;CandidatePhrase&gt; identifiedWords, String outFile,
      CollectionValuedMap&lt;E, Triple&lt;String, Integer, Integer&gt;&gt; matchedTokensByPat) throws IOException {

<span class="nc" id="L1923">    Date startTime = new Date();</span>
<span class="nc" id="L1924">    Redwood.log(Redwood.DBG, &quot;Labeling &quot; + sents.size() + &quot; sentences with &quot; + identifiedWords.size() + &quot; phrases for label &quot; + label);</span>

<span class="nc" id="L1926">    int numTokensLabeled = 0;</span>

<span class="nc" id="L1928">    CollectionValuedMap&lt;String, Integer&gt; tokensMatchedPatterns = null;</span>
<span class="nc bnc" id="L1929" title="All 2 branches missed.">    if (constVars.restrictToMatched) {</span>
<span class="nc" id="L1930">      tokensMatchedPatterns = new CollectionValuedMap&lt;&gt;();</span>
<span class="nc bnc" id="L1931" title="All 2 branches missed.">      for (Entry&lt;E, Collection&lt;Triple&lt;String, Integer, Integer&gt;&gt;&gt; en : matchedTokensByPat.entrySet()) {</span>
<span class="nc bnc" id="L1932" title="All 2 branches missed.">        for (Triple&lt;String, Integer, Integer&gt; en2 : en.getValue()) {</span>
<span class="nc bnc" id="L1933" title="All 2 branches missed.">          for (int i = en2.second(); i &lt;= en2.third(); i++) {</span>
<span class="nc" id="L1934">            tokensMatchedPatterns.add(en2.first(), i);</span>
          }
<span class="nc" id="L1936">        }</span>
<span class="nc" id="L1937">      }</span>
    }

<span class="nc" id="L1940">    Map&lt;String, Map&lt;Integer, Set&lt;E&gt;&gt;&gt; tempPatsForSents = new HashMap&lt;&gt;();</span>

<span class="nc bnc" id="L1942" title="All 2 branches missed.">    for (Entry&lt;String, DataInstance&gt; sentEn : sents.entrySet()) {</span>
<span class="nc" id="L1943">      List&lt;CoreLabel&gt; tokens = sentEn.getValue().getTokens();</span>
<span class="nc" id="L1944">      boolean sentenceChanged = false;</span>
<span class="nc" id="L1945">      Map&lt;CandidatePhrase, String[]&gt; identifiedWordsTokens = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1946" title="All 2 branches missed.">      for (CandidatePhrase s : identifiedWords) {</span>
<span class="nc" id="L1947">        String[] toks = s.getPhrase().split(&quot;\\s+&quot;);</span>
<span class="nc" id="L1948">        identifiedWordsTokens.put(s, toks);</span>
<span class="nc" id="L1949">      }</span>
<span class="nc" id="L1950">      String[] sent = new String[tokens.size()];</span>
<span class="nc" id="L1951">      int i = 0;</span>

<span class="nc" id="L1953">      Set&lt;Integer&gt; contextWordsRecalculatePats = new HashSet&lt;&gt;();</span>

<span class="nc bnc" id="L1955" title="All 2 branches missed.">      for (CoreLabel l :tokens) {</span>
<span class="nc" id="L1956">        sent[i] = l.word();</span>
<span class="nc" id="L1957">        i++;</span>
<span class="nc" id="L1958">      }</span>
<span class="nc bnc" id="L1959" title="All 2 branches missed.">      for (Entry&lt;CandidatePhrase, String[]&gt; phEn : identifiedWordsTokens.entrySet()) {</span>
<span class="nc" id="L1960">        String[] ph = phEn.getValue();</span>
<span class="nc bnc" id="L1961" title="All 2 branches missed.">        List&lt;Integer&gt; ints = ArrayUtils.getSubListIndex(ph, sent, o -&gt; constVars.matchLowerCaseContext ? ((String) o.first()).equalsIgnoreCase((String)o.second()): o.first().equals(o.second()));</span>
<span class="nc bnc" id="L1962" title="All 2 branches missed.">        if (ints == null)</span>
<span class="nc" id="L1963">          continue;</span>

<span class="nc bnc" id="L1965" title="All 2 branches missed.">        for (Integer idx : ints) {</span>
<span class="nc" id="L1966">          boolean donotuse = false;</span>
<span class="nc bnc" id="L1967" title="All 2 branches missed.">          if (constVars.restrictToMatched) {</span>
<span class="nc bnc" id="L1968" title="All 2 branches missed.">            for (int j = 0; j &lt; ph.length; j++) {</span>
<span class="nc bnc" id="L1969" title="All 2 branches missed.">              if (!tokensMatchedPatterns.get(sentEn.getKey()).contains(idx + j)) {</span>
<span class="nc" id="L1970">                Redwood.log(ConstantsAndVariables.extremedebug, &quot;not labeling &quot; + tokens.get(idx + j).word());</span>
<span class="nc" id="L1971">                donotuse = true;</span>
<span class="nc" id="L1972">                break;</span>
              }
            }
          }
<span class="nc bnc" id="L1976" title="All 2 branches missed.">          if (donotuse == false) {</span>
<span class="nc" id="L1977">            String phStr = StringUtils.join(ph, &quot; &quot;);</span>

<span class="nc bnc" id="L1979" title="All 2 branches missed.">            if(constVars.writeMatchedTokensIdsForEachPhrase)</span>
<span class="nc" id="L1980">              addToMatchedTokensByPhrase(phStr, sentEn.getKey(), idx, ph.length);</span>


<span class="nc" id="L1983">            Redwood.log(ConstantsAndVariables.extremedebug,&quot;Labeling because of phrase &quot; + phStr);</span>
<span class="nc bnc" id="L1984" title="All 2 branches missed.">            for (int j = 0; j &lt; ph.length; j++) {</span>
<span class="nc" id="L1985">              int index = idx + j;</span>
<span class="nc" id="L1986">              CoreLabel l = tokens.get(index);</span>
<span class="nc bnc" id="L1987" title="All 2 branches missed.">              if (constVars.usePatternResultAsLabel) {</span>
<span class="nc" id="L1988">                sentenceChanged = true;</span>
<span class="nc" id="L1989">                l.set(constVars.getAnswerClass().get(label), label);</span>
<span class="nc" id="L1990">                numTokensLabeled ++;</span>

                //set the matched and the longest phrases
<span class="nc" id="L1993">                CollectionValuedMap&lt;String, CandidatePhrase&gt; matched = new CollectionValuedMap&lt;&gt;();</span>
<span class="nc" id="L1994">                matched.add(label, phEn.getKey());</span>
<span class="nc bnc" id="L1995" title="All 2 branches missed.">                if(!l.containsKey(PatternsAnnotations.MatchedPhrases.class))</span>
<span class="nc" id="L1996">                  l.set(PatternsAnnotations.MatchedPhrases.class, matched);</span>
                else
<span class="nc" id="L1998">                  l.get(PatternsAnnotations.MatchedPhrases.class).addAll(matched);</span>

<span class="nc" id="L2000">                CandidatePhrase longest = l.get(PatternsAnnotations.LongestMatchedPhraseForEachLabel.class).get(label);</span>
<span class="nc bnc" id="L2001" title="All 4 branches missed.">                longest = longest != null &amp;&amp; longest.getPhrase().length() &gt; phEn.getKey().getPhrase().length() ? longest: phEn.getKey();</span>
<span class="nc" id="L2002">                l.get(PatternsAnnotations.LongestMatchedPhraseForEachLabel.class).put(label, longest);</span>

<span class="nc bnc" id="L2004" title="All 2 branches missed.">                for (int k = Math.max(0, index - PatternFactory.numWordsCompoundMapped.get(label)); k &lt; tokens.size()</span>
<span class="nc bnc" id="L2005" title="All 2 branches missed.">                    &amp;&amp; k &lt;= index + PatternFactory.numWordsCompoundMapped.get(label) + 1; k++) {</span>
<span class="nc" id="L2006">                  contextWordsRecalculatePats.add(k);</span>
                }

              }
            }
          }
<span class="nc" id="L2012">        }</span>
<span class="nc" id="L2013">      }</span>

<span class="nc bnc" id="L2015" title="All 2 branches missed.">      if (patsForEachToken != null )//&amp;&amp; patsForEachToken.containsSentId(sentEn.getKey()))</span>
      {
<span class="nc bnc" id="L2017" title="All 2 branches missed.">        for (int index : contextWordsRecalculatePats){</span>
<span class="nc bnc" id="L2018" title="All 2 branches missed.">          if(!tempPatsForSents.containsKey(sentEn.getKey()))</span>
<span class="nc" id="L2019">            tempPatsForSents.put(sentEn.getKey(), new HashMap&lt;&gt;());</span>

<span class="nc" id="L2021">          tempPatsForSents.get(sentEn.getKey()).put(index, Pattern.getContext(constVars.patternType, sentEn.getValue(), index, ConstantsAndVariables.getStopWords()));</span>
          //patsForEachToken.addPatterns(sentEn.getKey(), index, createPats.getContext(sentEn.getValue(), index));
<span class="nc" id="L2023">        }</span>
      }
<span class="nc bnc" id="L2025" title="All 2 branches missed.">      if(sentenceChanged){</span>
<span class="nc" id="L2026">        constVars.invertedIndex.update(sentEn.getValue().getTokens(), sentEn.getKey());</span>
      }
<span class="nc" id="L2028">    }</span>

<span class="nc bnc" id="L2030" title="All 2 branches missed.">    if(patsForEachToken != null) {</span>
<span class="nc" id="L2031">      patsForEachToken.updatePatterns(tempPatsForSents);//sentEn.getKey(), index, createPats.getContext(sentEn.getValue(), index));</span>
    }

<span class="nc" id="L2034">    constVars.invertedIndex.finishUpdating();</span>

<span class="nc bnc" id="L2036" title="All 2 branches missed.">    if (outFile != null) {</span>
<span class="nc" id="L2037">      Redwood.log(ConstantsAndVariables.minimaldebug, &quot;Writing results to &quot; + outFile);</span>
<span class="nc" id="L2038">      IOUtils.writeObjectToFile(sents, outFile);</span>
    }

<span class="nc" id="L2041">    Date endTime = new Date();</span>
<span class="nc" id="L2042">    Redwood.log(Redwood.DBG, &quot;Done labeling provided sents in &quot; + elapsedTime(startTime, endTime) + &quot;. Total # of tokens labeled: &quot; + numTokensLabeled);</span>
<span class="nc" id="L2043">  }</span>


  public void iterateExtractApply() throws IOException, ClassNotFoundException {
<span class="nc" id="L2047">    iterateExtractApply(null, null, null);</span>
<span class="nc" id="L2048">  }</span>

  /**
   *
   * @param p0 Null in most cases. only used for BPB
   * @param p0Set Null in most cases
   * @param ignorePatterns
   *
   */
  public void iterateExtractApply(Map&lt;String, E&gt; p0, Map&lt;String, Counter&lt;CandidatePhrase&gt;&gt; p0Set, Map&lt;String, Set&lt;E&gt;&gt; ignorePatterns) throws IOException, ClassNotFoundException {

<span class="nc" id="L2059">    Map&lt;String, CollectionValuedMap&lt;E, Triple&lt;String, Integer, Integer&gt;&gt;&gt; matchedTokensByPatAllLabels = new HashMap&lt;&gt;();</span>
    //Map&lt;String, Collection&lt;Triple&lt;String, Integer, Integer&gt;&gt;&gt; matchedTokensForPhrases = new HashMap&lt;String, Collection&lt;Triple&lt;String, Integer, Integer&gt;&gt;&gt;();
<span class="nc" id="L2061">    Map&lt;String, TwoDimensionalCounter&lt;CandidatePhrase, E&gt;&gt; termsAllLabels = new HashMap&lt;&gt;();</span>

<span class="nc" id="L2063">    Map&lt;String, Set&lt;CandidatePhrase&gt;&gt; ignoreWordsAll = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L2064" title="All 2 branches missed.">    for (String label : constVars.getSeedLabelDictionary().keySet()) {</span>
<span class="nc" id="L2065">      matchedTokensByPatAllLabels.put(label, new CollectionValuedMap&lt;&gt;());</span>
<span class="nc" id="L2066">      termsAllLabels.put(label, new TwoDimensionalCounter&lt;&gt;());</span>
<span class="nc bnc" id="L2067" title="All 2 branches missed.">      if (constVars.useOtherLabelsWordsasNegative) {</span>
<span class="nc" id="L2068">        Set&lt;CandidatePhrase&gt; w = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L2069" title="All 2 branches missed.">        for (Entry&lt;String, Set&lt;CandidatePhrase&gt;&gt; en : constVars.getSeedLabelDictionary().entrySet()) {</span>
<span class="nc bnc" id="L2070" title="All 2 branches missed.">          if (en.getKey().equals(label))</span>
<span class="nc" id="L2071">            continue;</span>
<span class="nc" id="L2072">          w.addAll(en.getValue());</span>
<span class="nc" id="L2073">        }</span>
<span class="nc" id="L2074">        ignoreWordsAll.put(label, w);</span>
      }
<span class="nc" id="L2076">    }</span>

<span class="nc" id="L2078">    Redwood.log(ConstantsAndVariables.minimaldebug, &quot;Iterating &quot; + constVars.numIterationsForPatterns + &quot; times.&quot;);</span>

<span class="nc" id="L2080">    Map&lt;String, BufferedWriter&gt; wordsOutput = new HashMap&lt;&gt;();</span>
<span class="nc" id="L2081">    Map&lt;String, BufferedWriter&gt; patternsOutput = new HashMap&lt;&gt;();</span>

<span class="nc bnc" id="L2083" title="All 2 branches missed.">    for (String label : constVars.getLabels()) {</span>
<span class="nc bnc" id="L2084" title="All 2 branches missed.">      if(constVars.outDir != null){</span>
<span class="nc" id="L2085">      IOUtils.ensureDir(new File(constVars.outDir + &quot;/&quot; + constVars.identifier + &quot;/&quot; + label));</span>

<span class="nc" id="L2087">      String  wordsOutputFileLabel = constVars.outDir + &quot;/&quot; + constVars.identifier + &quot;/&quot; + label + &quot;/learnedwords.txt&quot;;</span>
<span class="nc" id="L2088">      wordsOutput.put(label, new BufferedWriter(new FileWriter(wordsOutputFileLabel)));</span>
<span class="nc" id="L2089">      Redwood.log(ConstantsAndVariables.minimaldebug, &quot;Saving the learned words for label &quot; + label + &quot; in &quot; + wordsOutputFileLabel);</span>

      }

<span class="nc bnc" id="L2093" title="All 2 branches missed.">      if(constVars.outDir != null){</span>
<span class="nc" id="L2094">        String  patternsOutputFileLabel = constVars.outDir + &quot;/&quot; + constVars.identifier + &quot;/&quot; + label + &quot;/learnedpatterns.txt&quot;;</span>
<span class="nc" id="L2095">        patternsOutput.put(label, new BufferedWriter(new FileWriter(patternsOutputFileLabel)));</span>
<span class="nc" id="L2096">        Redwood.log(ConstantsAndVariables.minimaldebug, &quot;Saving the learned patterns for label &quot; + label + &quot; in &quot; + patternsOutputFileLabel);</span>
      }
<span class="nc" id="L2098">    }</span>

<span class="nc bnc" id="L2100" title="All 2 branches missed.">    for (int i = 0; i &lt; constVars.numIterationsForPatterns; i++) {</span>

<span class="nc" id="L2102">      Redwood</span>
<span class="nc" id="L2103">          .log(ConstantsAndVariables.minimaldebug, &quot;\n\n################################ Iteration &quot; + (i + 1) + &quot; ##############################&quot;);</span>
<span class="nc" id="L2104">      boolean keepRunning = false;</span>
<span class="nc" id="L2105">      Map&lt;String, Counter&lt;CandidatePhrase&gt;&gt; learnedWordsThisIter = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L2106" title="All 2 branches missed.">      for (String label : constVars.getLabels()) {</span>
<span class="nc" id="L2107">        Redwood.log(ConstantsAndVariables.minimaldebug, &quot;\n###Learning for label &quot; + label + &quot; ######&quot;);</span>

<span class="nc bnc" id="L2109" title="All 2 branches missed.">        String sentout = constVars.sentsOutFile == null ? null : constVars.sentsOutFile + &quot;_&quot; + label;</span>

<span class="nc bnc" id="L2111" title="All 4 branches missed.">        Pair&lt;Counter&lt;E&gt;, Counter&lt;CandidatePhrase&gt;&gt; learnedPatWords4label = iterateExtractApply4Label(label, p0 != null ? p0.get(label) : null,</span>
<span class="nc bnc" id="L2112" title="All 2 branches missed.">            p0Set != null ? p0Set.get(label) : null, wordsOutput.get(label), sentout, patternsOutput.get(label),</span>
<span class="nc" id="L2113">            ignorePatterns != null ? ignorePatterns.get(label) : null, ignoreWordsAll.get(label), matchedTokensByPatAllLabels.get(label),</span>
<span class="nc" id="L2114">            termsAllLabels.get(label), i + numIterationsLoadedModel);</span>

<span class="nc" id="L2116">        learnedWordsThisIter.put(label, learnedPatWords4label.second());</span>
<span class="nc bnc" id="L2117" title="All 4 branches missed.">        if (learnedPatWords4label.first().size() &gt; 0 &amp;&amp; constVars.getLearnedWords(label).size() &lt; constVars.maxExtractNumWords) {</span>
<span class="nc" id="L2118">          keepRunning = true;</span>
        }
<span class="nc" id="L2120">      }</span>

<span class="nc bnc" id="L2122" title="All 2 branches missed.">      if (constVars.useOtherLabelsWordsasNegative) {</span>
<span class="nc bnc" id="L2123" title="All 2 branches missed.">        for (String label : constVars.getLabels()) {</span>
<span class="nc bnc" id="L2124" title="All 2 branches missed.">          for (Entry&lt;String, Counter&lt;CandidatePhrase&gt;&gt; en : learnedWordsThisIter.entrySet()) {</span>
<span class="nc bnc" id="L2125" title="All 2 branches missed.">            if (en.getKey().equals(label))</span>
<span class="nc" id="L2126">              continue;</span>
<span class="nc" id="L2127">            ignoreWordsAll.get(label).addAll(en.getValue().keySet());</span>
<span class="nc" id="L2128">          }</span>
<span class="nc" id="L2129">        }</span>
      }

<span class="nc bnc" id="L2132" title="All 2 branches missed.">      if (!keepRunning) {</span>
<span class="nc bnc" id="L2133" title="All 2 branches missed.">        if (!constVars.tuneThresholdKeepRunning) {</span>
<span class="nc" id="L2134">          Redwood.log(ConstantsAndVariables.minimaldebug, &quot;No patterns learned for all labels. Ending iterations.&quot;);</span>
<span class="nc" id="L2135">          break;</span>
        } else {
<span class="nc" id="L2137">          constVars.thresholdSelectPattern = 0.8 * constVars.thresholdSelectPattern;</span>
<span class="nc" id="L2138">          Redwood.log(ConstantsAndVariables.minimaldebug, &quot;\n\nTuning thresholds to keep running. New Pattern threshold is  &quot;</span>
              + constVars.thresholdSelectPattern);
        }
      }
    }

<span class="nc bnc" id="L2144" title="All 4 branches missed.">    if (constVars.outDir != null &amp;&amp; !constVars.outDir.isEmpty()) {</span>
<span class="nc" id="L2145">      Redwood.log(ConstantsAndVariables.minimaldebug, &quot;Writing justification files&quot;);</span>

<span class="nc bnc" id="L2147" title="All 2 branches missed.">      for (String label : constVars.getLabels()) {</span>
<span class="nc" id="L2148">        IOUtils.ensureDir(new File(constVars.outDir + &quot;/&quot; + constVars.identifier + &quot;/&quot; + label));</span>

<span class="nc bnc" id="L2150" title="All 2 branches missed.">        if (constVars.writeMatchedTokensFiles) {</span>
<span class="nc" id="L2151">          ConstantsAndVariables.DataSentsIterator iter = new ConstantsAndVariables.DataSentsIterator(constVars.batchProcessSents);</span>
<span class="nc" id="L2152">          int i = 0;</span>
<span class="nc" id="L2153">          String suffix =&quot;&quot;;</span>
<span class="nc bnc" id="L2154" title="All 2 branches missed.">          while(iter.hasNext()){</span>
<span class="nc" id="L2155">            i++;</span>
<span class="nc bnc" id="L2156" title="All 2 branches missed.">            if(constVars.batchProcessSents)</span>
<span class="nc" id="L2157">              suffix = &quot;_&quot;+i;</span>
<span class="nc" id="L2158">            writeMatchedTokensAndSents(label, iter.next().first(), suffix, matchedTokensByPatAllLabels.get(label));</span>
          }
        }
<span class="nc" id="L2161">      }</span>

<span class="nc bnc" id="L2163" title="All 4 branches missed.">      if(constVars.writeMatchedTokensIdsForEachPhrase &amp;&amp; constVars.outDir != null){</span>
<span class="nc" id="L2164">        String matchedtokensfilename = constVars.outDir + &quot;/&quot; + constVars.identifier  + &quot;/tokenids4matchedphrases&quot; + &quot;.json&quot;;</span>
<span class="nc" id="L2165">        IOUtils.writeStringToFile(matchedTokensByPhraseJsonString(), matchedtokensfilename, &quot;utf8&quot;);</span>

      }
    }

<span class="nc" id="L2170">    System.out.println(&quot;\n\nAll patterns learned:&quot;);</span>

<span class="nc bnc" id="L2172" title="All 2 branches missed.">    for(Map.Entry&lt;String, Map&lt;Integer, Counter&lt;E&gt;&gt;&gt; en2: this.learnedPatternsEachIter.entrySet()) {</span>
<span class="nc" id="L2173">      System.out.println(en2.getKey()+&quot;:&quot;);</span>
<span class="nc bnc" id="L2174" title="All 2 branches missed.">      for (Map.Entry&lt;Integer, Counter&lt;E&gt;&gt; en : en2.getValue().entrySet()) {</span>
<span class="nc" id="L2175">        System.out.println(&quot;Iteration &quot; + en.getKey());</span>
<span class="nc" id="L2176">        System.out.println(StringUtils.join(en.getValue().keySet(), &quot;\n&quot;));</span>
<span class="nc" id="L2177">      }</span>
<span class="nc" id="L2178">    }</span>
<span class="nc" id="L2179">    System.out.println(&quot;\n\nAll words learned:&quot;);</span>
<span class="nc bnc" id="L2180" title="All 2 branches missed.">    for(String label: constVars.getLabels()) {</span>
<span class="nc" id="L2181">      System.out.println(&quot;\nLabel &quot; + label +&quot;\n&quot;);</span>
<span class="nc bnc" id="L2182" title="All 2 branches missed.">      for (Entry&lt;Integer, Counter&lt;CandidatePhrase&gt;&gt; en : this.constVars.getLearnedWordsEachIter(label).entrySet()) {</span>
<span class="nc" id="L2183">        System.out.println(&quot;Iteration &quot; + en.getKey() + &quot;:\t\t&quot; + en.getValue().keySet());</span>
<span class="nc" id="L2184">      }</span>
<span class="nc" id="L2185">    }</span>
    // close all the writers
<span class="nc bnc" id="L2187" title="All 2 branches missed.">    for (String label : constVars.getLabels()) {</span>
<span class="nc bnc" id="L2188" title="All 4 branches missed.">      if(wordsOutput.containsKey(label) &amp;&amp; wordsOutput.get(label) != null)</span>
<span class="nc" id="L2189">        wordsOutput.get(label).close();</span>
<span class="nc bnc" id="L2190" title="All 4 branches missed.">      if(patternsOutput.containsKey(label) &amp;&amp; patternsOutput.get(label) != null)</span>
<span class="nc" id="L2191">        patternsOutput.get(label).close();</span>
<span class="nc" id="L2192">    }</span>
<span class="nc" id="L2193">  }</span>

  private void writeMatchedTokensAndSents(String label, Map&lt;String, DataInstance&gt; sents, String suffix, CollectionValuedMap&lt;E, Triple&lt;String, Integer, Integer&gt;&gt; tokensMatchedPat) throws IOException {
<span class="nc bnc" id="L2196" title="All 2 branches missed.">    if(constVars.outDir != null){</span>
<span class="nc" id="L2197">    Set&lt;String&gt; allMatchedSents = new HashSet&lt;&gt;();</span>
<span class="nc" id="L2198">    String matchedtokensfilename = constVars.outDir + &quot;/&quot; + constVars.identifier + &quot;/&quot; + label + &quot;/tokensmatchedpatterns&quot; + suffix + &quot;.json&quot;;</span>
<span class="nc" id="L2199">    JsonObjectBuilder pats = Json.createObjectBuilder();</span>
<span class="nc bnc" id="L2200" title="All 2 branches missed.">    for (Entry&lt;E, Collection&lt;Triple&lt;String, Integer, Integer&gt;&gt;&gt; en : tokensMatchedPat.entrySet()) {</span>
<span class="nc" id="L2201">      CollectionValuedMap&lt;String, Pair&lt;Integer, Integer&gt;&gt; matchedStrs = new CollectionValuedMap&lt;&gt;();</span>
<span class="nc bnc" id="L2202" title="All 2 branches missed.">      for (Triple&lt;String, Integer, Integer&gt; en2 : en.getValue()) {</span>
<span class="nc" id="L2203">        allMatchedSents.add(en2.first());</span>
<span class="nc" id="L2204">        matchedStrs.add(en2.first(), new Pair&lt;&gt;(en2.second(), en2.third()));</span>
<span class="nc" id="L2205">      }</span>

<span class="nc" id="L2207">      JsonObjectBuilder senttokens = Json.createObjectBuilder();</span>
<span class="nc bnc" id="L2208" title="All 2 branches missed.">      for (Entry&lt;String, Collection&lt;Pair&lt;Integer, Integer&gt;&gt;&gt; sen : matchedStrs.entrySet()) {</span>
<span class="nc" id="L2209">        JsonArrayBuilder obj = Json.createArrayBuilder();</span>
<span class="nc bnc" id="L2210" title="All 2 branches missed.">        for (Pair&lt;Integer, Integer&gt; sen2 : sen.getValue()) {</span>
<span class="nc" id="L2211">          JsonArrayBuilder startend = Json.createArrayBuilder();</span>
<span class="nc" id="L2212">          startend.add(sen2.first());</span>
<span class="nc" id="L2213">          startend.add(sen2.second());</span>
<span class="nc" id="L2214">          obj.add(startend);</span>
<span class="nc" id="L2215">        }</span>
<span class="nc" id="L2216">        senttokens.add(sen.getKey(), obj);</span>
<span class="nc" id="L2217">      }</span>
<span class="nc" id="L2218">      pats.add(en.getKey().toStringSimple(), senttokens);</span>
<span class="nc" id="L2219">    }</span>
<span class="nc" id="L2220">    IOUtils.writeStringToFile(pats.build().toString(), matchedtokensfilename, &quot;utf8&quot;);</span>

    // Writing the sentence json file -- tokens for each sentence
<span class="nc" id="L2223">    JsonObjectBuilder senttokens = Json.createObjectBuilder();</span>
<span class="nc bnc" id="L2224" title="All 2 branches missed.">    for (String sentId : allMatchedSents) {</span>
<span class="nc" id="L2225">      JsonArrayBuilder sent = Json.createArrayBuilder();</span>
<span class="nc bnc" id="L2226" title="All 2 branches missed.">      for (CoreLabel l : sents.get(sentId).getTokens()) {</span>
<span class="nc" id="L2227">        sent.add(l.word());</span>
<span class="nc" id="L2228">      }</span>
<span class="nc" id="L2229">      senttokens.add(sentId, sent);</span>
<span class="nc" id="L2230">    }</span>
<span class="nc" id="L2231">    String sentfilename = constVars.outDir + &quot;/&quot; + constVars.identifier + &quot;/sentences&quot; + suffix  + &quot;.json&quot;;</span>
<span class="nc" id="L2232">    IOUtils.writeStringToFile(senttokens.build().toString(), sentfilename, &quot;utf8&quot;);</span>
    }
<span class="nc" id="L2234">  }</span>

  public static String matchedTokensByPhraseJsonString(String phrase){
<span class="nc bnc" id="L2237" title="All 2 branches missed.">    if(!Data.matchedTokensForEachPhrase.containsKey(phrase))</span>
<span class="nc" id="L2238">      return &quot;&quot;;</span>
<span class="nc" id="L2239">    JsonArrayBuilder arrobj =Json.createArrayBuilder();</span>
<span class="nc bnc" id="L2240" title="All 2 branches missed.">    for (Entry&lt;String, List&lt;Integer&gt;&gt; sen : Data.matchedTokensForEachPhrase.get(phrase).entrySet()) {</span>
<span class="nc" id="L2241">      JsonObjectBuilder obj = Json.createObjectBuilder();</span>
<span class="nc" id="L2242">      JsonArrayBuilder tokens = Json.createArrayBuilder();</span>
<span class="nc bnc" id="L2243" title="All 2 branches missed.">      for(Integer i : sen.getValue()){</span>
<span class="nc" id="L2244">        tokens.add(i);</span>
<span class="nc" id="L2245">      }</span>
<span class="nc" id="L2246">      obj.add(sen.getKey(),tokens);</span>
<span class="nc" id="L2247">      arrobj.add(obj);</span>
<span class="nc" id="L2248">    }</span>
<span class="nc" id="L2249">    return arrobj.build().toString();</span>
  }

  public static String matchedTokensByPhraseJsonString(){
<span class="nc" id="L2253">    JsonObjectBuilder pats = Json.createObjectBuilder();</span>

<span class="nc bnc" id="L2255" title="All 2 branches missed.">    for (Entry&lt;String, Map&lt;String, List&lt;Integer&gt;&gt;&gt; en : Data.matchedTokensForEachPhrase.entrySet()) {</span>

<span class="nc" id="L2257">      JsonArrayBuilder arrobj =Json.createArrayBuilder();</span>
<span class="nc bnc" id="L2258" title="All 2 branches missed.">      for (Entry&lt;String, List&lt;Integer&gt;&gt; sen : en.getValue().entrySet()) {</span>
<span class="nc" id="L2259">        JsonObjectBuilder obj = Json.createObjectBuilder();</span>
<span class="nc" id="L2260">        JsonArrayBuilder tokens = Json.createArrayBuilder();</span>
<span class="nc bnc" id="L2261" title="All 2 branches missed.">        for(Integer i : sen.getValue()){</span>
<span class="nc" id="L2262">          tokens.add(i);</span>
<span class="nc" id="L2263">        }</span>
<span class="nc" id="L2264">        obj.add(sen.getKey(),tokens);</span>
<span class="nc" id="L2265">        arrobj.add(obj);</span>
<span class="nc" id="L2266">      }</span>
<span class="nc" id="L2267">      pats.add(en.getKey(), arrobj);</span>
<span class="nc" id="L2268">    }</span>
<span class="nc" id="L2269">    return pats.build().toString();</span>
  }

  //numIterTotal = numIter + iterations from previously loaded model!
  private Pair&lt;Counter&lt;E&gt;, Counter&lt;CandidatePhrase&gt;&gt; iterateExtractApply4Label(String label, E p0, Counter&lt;CandidatePhrase&gt; p0Set,
      BufferedWriter wordsOutput, String sentsOutFile, BufferedWriter patternsOut, Set&lt;E&gt; ignorePatterns,
      Set&lt;CandidatePhrase&gt; ignoreWords, CollectionValuedMap&lt;E, Triple&lt;String, Integer, Integer&gt;&gt; matchedTokensByPat,
      TwoDimensionalCounter&lt;CandidatePhrase, E&gt; terms, int numIterTotal) throws IOException, ClassNotFoundException {

<span class="nc bnc" id="L2278" title="All 2 branches missed.">    if (!learnedPatterns.containsKey(label)) {</span>
<span class="nc" id="L2279">      learnedPatterns.put(label, new ClassicCounter&lt;&gt;());</span>
    }

<span class="nc bnc" id="L2282" title="All 2 branches missed.">    if (!learnedPatternsEachIter.containsKey(label)) {</span>
<span class="nc" id="L2283">      learnedPatternsEachIter.put(label, new HashMap&lt;&gt;());</span>
    }

<span class="nc bnc" id="L2286" title="All 2 branches missed.">    if (!constVars.getLearnedWordsEachIter().containsKey(label)) {</span>
<span class="nc" id="L2287">      constVars.getLearnedWordsEachIter().put(label, new TreeMap&lt;&gt;());</span>
    }

//    if (!constVars.getLearnedWords().containsKey(label)) {
//      constVars.getLearnedWords().put(label, new ClassicCounter&lt;CandidatePhrase&gt;());
//    }

<span class="nc" id="L2294">    Counter&lt;CandidatePhrase&gt; identifiedWords = new ClassicCounter&lt;&gt;();</span>
<span class="nc" id="L2295">    Counter&lt;E&gt; patterns = new ClassicCounter&lt;&gt;();</span>

<span class="nc" id="L2297">    Counter&lt;E&gt; patternThisIter = getPatterns(label, learnedPatterns.get(label).keySet(), p0, p0Set, ignorePatterns);</span>

<span class="nc" id="L2299">    patterns.addAll(patternThisIter);</span>

<span class="nc" id="L2301">    learnedPatterns.get(label).addAll(patterns);</span>

<span class="nc bnc" id="L2303" title="All 4 branches missed.">    assert !learnedPatternsEachIter.get(label).containsKey(numIterTotal) : &quot;How come learned patterns already have a key for &quot; + numIterTotal + &quot; keys are &quot; + learnedPatternsEachIter.get(label).keySet();</span>

<span class="nc" id="L2305">    learnedPatternsEachIter.get(label).put(numIterTotal, patterns);</span>

<span class="nc bnc" id="L2307" title="All 2 branches missed.">      if (sentsOutFile != null)</span>
<span class="nc" id="L2308">        sentsOutFile = sentsOutFile + &quot;_&quot; + numIterTotal + &quot;iter.ser&quot;;</span>

<span class="nc" id="L2310">      Counter&lt;String&gt; scoreForAllWordsThisIteration = new ClassicCounter&lt;&gt;();</span>

<span class="nc" id="L2312">      identifiedWords.addAll(scorePhrases.learnNewPhrases(label, this.patsForEachToken, patterns, learnedPatterns.get(label), matchedTokensByPat,</span>
<span class="nc" id="L2313">        scoreForAllWordsThisIteration, terms, wordsPatExtracted.get(label), this.patternsandWords.get(label), constVars.identifier, ignoreWords));</span>

<span class="nc bnc" id="L2315" title="All 2 branches missed.">      if (identifiedWords.size() &gt; 0) {</span>
<span class="nc bnc" id="L2316" title="All 2 branches missed.">        if (constVars.usePatternResultAsLabel) {</span>
<span class="nc bnc" id="L2317" title="All 2 branches missed.">          if (constVars.getLabels().contains(label)) {</span>

<span class="nc" id="L2319">            ConstantsAndVariables.DataSentsIterator sentsIter = new ConstantsAndVariables.DataSentsIterator(constVars.batchProcessSents);</span>
<span class="nc bnc" id="L2320" title="All 2 branches missed.">            while(sentsIter.hasNext()){</span>
<span class="nc" id="L2321">              Pair&lt;Map&lt;String, DataInstance&gt;, File&gt; sentsf = sentsIter.next();</span>
<span class="nc" id="L2322">              Redwood.log(Redwood.DBG, &quot;labeling sentences from &quot; + sentsf.second());</span>
<span class="nc" id="L2323">              labelWords(label, sentsf.first(), identifiedWords.keySet(), sentsOutFile, matchedTokensByPat);</span>
              //write only for batch sentences
              //TODO: make this clean!
<span class="nc bnc" id="L2326" title="All 4 branches missed.">              if(sentsf.second().exists() &amp;&amp; constVars.batchProcessSents)</span>
<span class="nc" id="L2327">                  IOUtils.writeObjectToFile(sentsf.first(), sentsf.second());</span>
<span class="nc" id="L2328">            }</span>
<span class="nc" id="L2329">          } else</span>
<span class="nc" id="L2330">            throw new RuntimeException(&quot;why is the answer label null?&quot;);</span>
<span class="nc bnc" id="L2331" title="All 4 branches missed.">          assert !constVars.getLearnedWordsEachIter().get(label).containsKey(numIterTotal) : &quot;How come learned words already have a key for &quot; + numIterTotal;</span>
<span class="nc" id="L2332">          constVars.getLearnedWordsEachIter().get(label).put(numIterTotal, identifiedWords);</span>
        }

<span class="nc bnc" id="L2335" title="All 2 branches missed.">        if (wordsOutput != null) {</span>
<span class="nc" id="L2336">          wordsOutput.write(&quot;\n&quot; + Counters.toSortedString(identifiedWords, identifiedWords.size(), &quot;%1$s&quot;, &quot;\n&quot;));</span>
<span class="nc" id="L2337">          wordsOutput.flush();</span>
        }
      }

    //}
<span class="nc bnc" id="L2342" title="All 2 branches missed.">    if (patternsOut != null)</span>
<span class="nc" id="L2343">      this.writePatternsToFile(patterns, patternsOut);</span>

<span class="nc" id="L2345">    return new Pair&lt;&gt;(patterns, identifiedWords);</span>
  }

  private void writePatternsToFile(Counter&lt;E&gt; pattern, BufferedWriter outFile) throws IOException {
<span class="nc bnc" id="L2349" title="All 2 branches missed.">    for (Entry&lt;E, Double&gt; en : pattern.entrySet())</span>
<span class="nc" id="L2350">      outFile.write(en.getKey().toString() + &quot;\t&quot; + en.getValue() + &quot;\n&quot;);</span>
<span class="nc" id="L2351">  }</span>

  private void writeWordsToFile(Map&lt;Integer, Counter&lt;CandidatePhrase&gt;&gt; words, BufferedWriter outFile) throws IOException {
<span class="nc bnc" id="L2354" title="All 2 branches missed.">    for (Entry&lt;Integer, Counter&lt;CandidatePhrase&gt;&gt; en2 : words.entrySet()) {</span>
<span class="nc" id="L2355">      outFile.write(&quot;###Iteration &quot; + en2.getKey()+&quot;\n&quot;);</span>
<span class="nc bnc" id="L2356" title="All 2 branches missed.">      for (Entry&lt;CandidatePhrase, Double&gt; en : en2.getValue().entrySet())</span>
<span class="nc" id="L2357">        outFile.write(en.getKey() + &quot;\t&quot; + en.getValue() + &quot;\n&quot;);</span>
<span class="nc" id="L2358">    }</span>
<span class="nc" id="L2359">  }</span>

  private static TreeMap&lt;Integer, Counter&lt;CandidatePhrase&gt;&gt; readLearnedWordsFromFile(File file) {
<span class="nc" id="L2362">    TreeMap&lt;Integer, Counter&lt;CandidatePhrase&gt;&gt; learned = new TreeMap&lt;&gt;();</span>
<span class="nc" id="L2363">    Counter&lt;CandidatePhrase&gt; words = null;</span>
<span class="nc" id="L2364">    int numIter = -1;</span>
<span class="nc bnc" id="L2365" title="All 2 branches missed.">    for (String line : IOUtils.readLines(file)) {</span>
<span class="nc bnc" id="L2366" title="All 2 branches missed.">      if(line.startsWith(&quot;###&quot;)){</span>
<span class="nc bnc" id="L2367" title="All 2 branches missed.">        if(words != null)</span>
<span class="nc" id="L2368">          learned.put(numIter, words);</span>
<span class="nc" id="L2369">        numIter ++;</span>
<span class="nc" id="L2370">        words = new ClassicCounter&lt;&gt;();</span>
<span class="nc" id="L2371">        continue;</span>
      }
<span class="nc" id="L2373">      String[] t = line.split(&quot;\t&quot;);</span>
<span class="nc" id="L2374">      words.setCount(CandidatePhrase.createOrGet(t[0]), Double.parseDouble(t[1]));</span>
<span class="nc" id="L2375">    }</span>
<span class="nc bnc" id="L2376" title="All 2 branches missed.">    if(words != null)</span>
<span class="nc" id="L2377">      learned.put(numIter, words);</span>
<span class="nc" id="L2378">    return learned;</span>
  }

  public Counter&lt;E&gt; getLearnedPatterns(String label) {
<span class="nc" id="L2382">    return this.learnedPatterns.get(label);</span>
  }

//  public Counter&lt;E&gt; getLearnedPatternsSurfaceForm(String label) {
//    return this.learnedPatterns.get(label);
//  }


  public Map&lt;String, Counter&lt;E&gt;&gt; getLearnedPatterns() {
<span class="nc" id="L2391">    return this.learnedPatterns;</span>
  }

  public Map&lt;String, Map&lt;Integer, Counter&lt;E&gt;&gt;&gt; getLearnedPatternsEachIter() {
<span class="nc" id="L2395">    return this.learnedPatternsEachIter;</span>
  }

  public Map&lt;Integer, Counter&lt;E&gt;&gt; getLearnedPatternsEachIter(String label) {
<span class="nc" id="L2399">    return this.learnedPatternsEachIter.get(label);</span>
  }


  public void setLearnedPatterns(Counter&lt;E&gt; patterns, String label) {
<span class="nc" id="L2404">    this.learnedPatterns.put(label, patterns);</span>
<span class="nc" id="L2405">  }</span>

  /**
   * COPIED from CRFClassifier: Count the successes and failures of the model on
   * the given document. Fills numbers in to counters for true positives, false
   * positives, and false negatives, and also keeps track of the entities seen. &lt;br&gt;
   * Returns false if we ever encounter null for gold or guess. NOTE: The
   * current implementation of counting wordFN/FP is incorrect.
   */
  public static boolean countResultsPerEntity(List&lt;CoreLabel&gt; doc, Counter&lt;String&gt; entityTP, Counter&lt;String&gt; entityFP, Counter&lt;String&gt; entityFN,
      String background, Counter&lt;String&gt; wordTP, Counter&lt;String&gt; wordTN, Counter&lt;String&gt; wordFP, Counter&lt;String&gt; wordFN,
      Class&lt;? extends TypesafeMap.Key&lt;String&gt;&gt; whichClassToCompare) {
<span class="nc" id="L2417">    int index = 0;</span>
<span class="nc" id="L2418">    int goldIndex = 0, guessIndex = 0;</span>
<span class="nc" id="L2419">    String lastGold = background, lastGuess = background;</span>

    // As we go through the document, there are two events we might be
    // interested in. One is when a gold entity ends, and the other
    // is when a guessed entity ends. If the gold and guessed
    // entities end at the same time, started at the same time, and
    // match entity type, we have a true positive. Otherwise we
    // either have a false positive or a false negative.
<span class="nc" id="L2427">    String str = &quot;&quot;;</span>

<span class="nc" id="L2429">    String s = &quot;&quot;;</span>
<span class="nc bnc" id="L2430" title="All 2 branches missed.">    for (CoreLabel l : doc) {</span>
<span class="nc" id="L2431">      s += &quot; &quot; + l.word() + &quot;:&quot; + l.get(CoreAnnotations.GoldAnswerAnnotation.class) + &quot;:&quot; + l.get(whichClassToCompare);</span>
<span class="nc" id="L2432">    }</span>
<span class="nc bnc" id="L2433" title="All 2 branches missed.">    for (CoreLabel line : doc) {</span>

<span class="nc" id="L2435">      String gold = line.get(CoreAnnotations.GoldAnswerAnnotation.class);</span>
<span class="nc" id="L2436">      String guess = line.get(whichClassToCompare);</span>

<span class="nc bnc" id="L2438" title="All 4 branches missed.">      if (gold == null || guess == null)</span>
<span class="nc" id="L2439">        return false;</span>

<span class="nc bnc" id="L2441" title="All 6 branches missed.">      if (lastGold != null &amp;&amp; !lastGold.equals(gold) &amp;&amp; !lastGold.equals(background)) {</span>
<span class="nc bnc" id="L2442" title="All 6 branches missed.">        if (lastGuess.equals(lastGold) &amp;&amp; !lastGuess.equals(guess) &amp;&amp; goldIndex == guessIndex) {</span>
<span class="nc" id="L2443">          wordTP.incrementCount(str);</span>
<span class="nc" id="L2444">          entityTP.incrementCount(lastGold, 1.0);</span>
        } else {
          // System.out.println(&quot;false negative: &quot; + str);
<span class="nc" id="L2447">          wordFN.incrementCount(str);</span>
<span class="nc" id="L2448">          entityFN.incrementCount(lastGold, 1.0);</span>
<span class="nc" id="L2449">          str = &quot;&quot;;</span>

        }
      }

<span class="nc bnc" id="L2454" title="All 6 branches missed.">      if (lastGuess != null &amp;&amp; !lastGuess.equals(guess) &amp;&amp; !lastGuess.equals(background)) {</span>
<span class="nc bnc" id="L2455" title="All 8 branches missed.">        if (lastGuess.equals(lastGold) &amp;&amp; !lastGuess.equals(guess) &amp;&amp; goldIndex == guessIndex &amp;&amp; !lastGold.equals(gold)) {</span>
          // correct guesses already tallied
          // str = &quot;&quot;;
          // only need to tally false positives
        } else {
          // System.out.println(&quot;false positive: &quot; + str);
<span class="nc" id="L2461">          entityFP.incrementCount(lastGuess, 1.0);</span>
<span class="nc" id="L2462">          wordFP.incrementCount(str);</span>
        }
<span class="nc" id="L2464">        str = &quot;&quot;;</span>
      }

<span class="nc bnc" id="L2467" title="All 8 branches missed.">      if (lastGuess != null &amp;&amp; lastGold != null &amp;&amp; lastGold.equals(background) &amp;&amp; lastGuess.equals(background)) {</span>
<span class="nc" id="L2468">        str = &quot;&quot;;</span>
      }

<span class="nc bnc" id="L2471" title="All 4 branches missed.">      if (lastGold == null || !lastGold.equals(gold)) {</span>
<span class="nc" id="L2472">        lastGold = gold;</span>
<span class="nc" id="L2473">        goldIndex = index;</span>
      }

<span class="nc bnc" id="L2476" title="All 4 branches missed.">      if (lastGuess == null || !lastGuess.equals(guess)) {</span>
<span class="nc" id="L2477">        lastGuess = guess;</span>
<span class="nc" id="L2478">        guessIndex = index;</span>
      }

<span class="nc" id="L2481">      ++index;</span>
<span class="nc bnc" id="L2482" title="All 2 branches missed.">      if (str.isEmpty())</span>
<span class="nc" id="L2483">        str = line.word();</span>
      else
<span class="nc" id="L2485">        str += &quot; &quot; + line.word();</span>
<span class="nc" id="L2486">    }</span>

    // We also have to account for entities at the very end of the
    // document, since the above logic only occurs when we see
    // something that tells us an entity has ended
<span class="nc bnc" id="L2491" title="All 4 branches missed.">    if (lastGold != null &amp;&amp; !lastGold.equals(background)) {</span>
<span class="nc bnc" id="L2492" title="All 4 branches missed.">      if (lastGold.equals(lastGuess) &amp;&amp; goldIndex == guessIndex) {</span>
<span class="nc" id="L2493">        entityTP.incrementCount(lastGold, 1.0);</span>
<span class="nc" id="L2494">        wordTP.incrementCount(str);</span>
      } else {
<span class="nc" id="L2496">        entityFN.incrementCount(lastGold, 1.0);</span>
<span class="nc" id="L2497">        wordFN.incrementCount(str);</span>
      }
<span class="nc" id="L2499">      str = &quot;&quot;;</span>
    }
<span class="nc bnc" id="L2501" title="All 4 branches missed.">    if (lastGuess != null &amp;&amp; !lastGuess.equals(background)) {</span>
<span class="nc bnc" id="L2502" title="All 4 branches missed.">      if (lastGold.equals(lastGuess) &amp;&amp; goldIndex == guessIndex) {</span>
        // correct guesses already tallied
      } else {
<span class="nc" id="L2505">        entityFP.incrementCount(lastGuess, 1.0);</span>
<span class="nc" id="L2506">        wordFP.incrementCount(str);</span>
      }
<span class="nc" id="L2508">      str = &quot;&quot;;</span>
    }
<span class="nc" id="L2510">    return true;</span>
  }


  /**
   * Count the successes and failures of the model on the given document
   * ***token-based***. Fills numbers in to counters for true positives, false
   * positives, and false negatives, and also keeps track of the entities seen. &lt;br&gt;
   * Returns false if we ever encounter null for gold or guess.
   *
   * this currently is only for testing one label at a time
   */
  public static void countResultsPerToken(List&lt;CoreLabel&gt; doc, Counter&lt;String&gt; entityTP, Counter&lt;String&gt; entityFP, Counter&lt;String&gt; entityFN,
      String background, Counter&lt;String&gt; wordTP, Counter&lt;String&gt; wordTN, Counter&lt;String&gt; wordFP, Counter&lt;String&gt; wordFN,
      Class&lt;? extends TypesafeMap.Key&lt;String&gt;&gt; whichClassToCompare) {

<span class="nc" id="L2526">    IOBUtils.countEntityResults(doc, entityTP, entityFP, entityFN, background);</span>

    // int index = 0;
    // int goldIndex = 0, guessIndex = 0;
    // String lastGold = background, lastGuess = background;
    // As we go through the document, there are two events we might be
    // interested in. One is when a gold entity ends, and the other
    // is when a guessed entity ends. If the gold and guessed
    // entities end at the same time, started at the same time, and
    // match entity type, we have a true positive. Otherwise we
    // either have a false positive or a false negative.
<span class="nc bnc" id="L2537" title="All 2 branches missed.">    for (CoreLabel line : doc) {</span>

<span class="nc" id="L2539">      String gold = line.get(GoldAnswerAnnotation.class);</span>
<span class="nc" id="L2540">      String guess = line.get(whichClassToCompare);</span>

<span class="nc bnc" id="L2542" title="All 4 branches missed.">      assert (gold != null) : &quot;gold is null&quot;;</span>
<span class="nc bnc" id="L2543" title="All 4 branches missed.">      assert(guess != null) : &quot;guess is null&quot;;</span>


<span class="nc bnc" id="L2546" title="All 4 branches missed.">      if (gold.equals(guess) &amp;&amp; !gold.equalsIgnoreCase(background)) {</span>
<span class="nc" id="L2547">        entityTP.incrementCount(gold);</span>
<span class="nc" id="L2548">        wordTP.incrementCount(line.word());</span>
<span class="nc bnc" id="L2549" title="All 6 branches missed.">      } else if (!gold.equals(guess) &amp;&amp; !gold.equalsIgnoreCase(background) &amp;&amp; guess.equalsIgnoreCase(background)) {</span>
<span class="nc" id="L2550">        entityFN.incrementCount(gold);</span>
<span class="nc" id="L2551">        wordFN.incrementCount(line.word());</span>

<span class="nc bnc" id="L2553" title="All 6 branches missed.">      } else if (!gold.equals(guess) &amp;&amp; !guess.equalsIgnoreCase(background) &amp;&amp; gold.equalsIgnoreCase(background)) {</span>
<span class="nc" id="L2554">        wordFP.incrementCount(line.word());</span>
<span class="nc" id="L2555">        entityFP.incrementCount(guess);</span>
<span class="nc bnc" id="L2556" title="All 4 branches missed.">      } else if (gold.equals(guess) &amp;&amp; !gold.equalsIgnoreCase(background)) {</span>
<span class="nc" id="L2557">        wordTN.incrementCount(line.word());</span>
<span class="nc bnc" id="L2558" title="All 4 branches missed.">      } else if (!(gold.equalsIgnoreCase(background) &amp;&amp; guess.equalsIgnoreCase(background)))</span>
<span class="nc" id="L2559">        throw new RuntimeException(&quot;don't know reached here. not meant for more than one entity label: &quot; + gold + &quot; and &quot; + guess);</span>

<span class="nc" id="L2561">    }</span>

<span class="nc" id="L2563">  }</span>

  public static void countResults(List&lt;CoreLabel&gt; doc, Counter&lt;String&gt; entityTP, Counter&lt;String&gt; entityFP, Counter&lt;String&gt; entityFN,
      String background, Counter&lt;String&gt; wordTP, Counter&lt;String&gt; wordTN, Counter&lt;String&gt; wordFP, Counter&lt;String&gt; wordFN,
      Class&lt;? extends TypesafeMap.Key&lt;String&gt;&gt; whichClassToCompare, boolean evalPerEntity) {
<span class="nc bnc" id="L2568" title="All 2 branches missed.">    if (evalPerEntity) {</span>
<span class="nc" id="L2569">      countResultsPerEntity(doc, entityTP, entityFP, entityFN, background, wordTP, wordTN, wordFP, wordFN, whichClassToCompare);</span>
    } else {
<span class="nc" id="L2571">      countResultsPerToken(doc, entityTP, entityFP, entityFN, background, wordTP, wordTN, wordFP, wordFN, whichClassToCompare);</span>
    }
<span class="nc" id="L2573">  }</span>

  private void writeLabelDataSents(Map&lt;String, DataInstance&gt; sents, BufferedWriter writer) throws IOException {
<span class="nc bnc" id="L2576" title="All 2 branches missed.">    for (Entry&lt;String, DataInstance&gt; sent : sents.entrySet()) {</span>
<span class="nc" id="L2577">      writer.write(sent.getKey() + &quot;\t&quot;);</span>

<span class="nc" id="L2579">      Map&lt;String, Boolean&gt; lastWordLabeled = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L2580" title="All 2 branches missed.">      for (String label : constVars.getLabels()) {</span>
<span class="nc" id="L2581">        lastWordLabeled.put(label, false);</span>
<span class="nc" id="L2582">      }</span>

<span class="nc bnc" id="L2584" title="All 2 branches missed.">      for (CoreLabel s : sent.getValue().getTokens()) {</span>
<span class="nc" id="L2585">        String str = &quot;&quot;;</span>
        //write them in reverse order
<span class="nc" id="L2587">        List&lt;String&gt; listEndedLabels = new ArrayList&lt;&gt;();</span>
        //to first finish labels before starting
<span class="nc" id="L2589">        List&lt;String&gt; startingLabels = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L2591" title="All 2 branches missed.">        for (Entry&lt;String, Class&lt;? extends TypesafeMap.Key&lt;String&gt;&gt;&gt; as : constVars.getAnswerClass().entrySet()) {</span>
<span class="nc" id="L2592">          String label = as.getKey();</span>
<span class="nc" id="L2593">          boolean lastwordlabeled = lastWordLabeled.get(label);</span>
<span class="nc bnc" id="L2594" title="All 2 branches missed.">          if (s.get(as.getValue()).equals(label)) {</span>
<span class="nc bnc" id="L2595" title="All 2 branches missed.">            if (!lastwordlabeled) {</span>
<span class="nc" id="L2596">              startingLabels.add(label);</span>
            }
<span class="nc" id="L2598">            lastWordLabeled.put(label, true);</span>
          } else {
<span class="nc bnc" id="L2600" title="All 2 branches missed.">            if (lastwordlabeled) {</span>
<span class="nc" id="L2601">              listEndedLabels.add(label);</span>
            }
<span class="nc" id="L2603">            lastWordLabeled.put(label, false);</span>
          }
<span class="nc" id="L2605">        }</span>
<span class="nc bnc" id="L2606" title="All 2 branches missed.">        for(int i = listEndedLabels.size() -1 ; i &gt;=0; i--)</span>
<span class="nc" id="L2607">          str += &quot; &lt;/&quot; + listEndedLabels.get(i) + &quot;&gt;&quot;;</span>
<span class="nc bnc" id="L2608" title="All 2 branches missed.">        for(String label : startingLabels){</span>
<span class="nc" id="L2609">          str += &quot; &lt;&quot; + label + &quot;&gt; &quot;;</span>
<span class="nc" id="L2610">        }</span>
<span class="nc" id="L2611">        str += &quot; &quot; + s.word();</span>
<span class="nc" id="L2612">        writer.write(str.trim() + &quot; &quot;);</span>
<span class="nc" id="L2613">      }</span>
<span class="nc" id="L2614">      writer.write(&quot;\n&quot;);</span>
<span class="nc" id="L2615">    }</span>

<span class="nc" id="L2617">  }</span>

  public void writeLabeledData(String outFile) throws IOException, ClassNotFoundException {
<span class="nc" id="L2620">    BufferedWriter writer = new BufferedWriter(new FileWriter(outFile));</span>

<span class="nc" id="L2622">    ConstantsAndVariables.DataSentsIterator sentsIter = new ConstantsAndVariables.DataSentsIterator(constVars.batchProcessSents);</span>
<span class="nc bnc" id="L2623" title="All 2 branches missed.">    while(sentsIter.hasNext()){</span>
<span class="nc" id="L2624">      Pair&lt;Map&lt;String, DataInstance&gt;, File&gt; sentsf = sentsIter.next();</span>
<span class="nc" id="L2625">      this.writeLabelDataSents(sentsf.first(), writer);</span>
<span class="nc" id="L2626">    }</span>
<span class="nc" id="L2627">    writer.close();</span>
<span class="nc" id="L2628">  }</span>

  static public void writeColumnOutput(String outFile, boolean batchProcessSents, Map&lt;String, Class&lt;? extends TypesafeMap.Key&lt;String&gt;&gt;&gt; answerclasses) throws IOException, ClassNotFoundException {
<span class="nc" id="L2631">    BufferedWriter writer = new BufferedWriter(new FileWriter(outFile));</span>

<span class="nc" id="L2633">    ConstantsAndVariables.DataSentsIterator sentsIter = new ConstantsAndVariables.DataSentsIterator(batchProcessSents);</span>
<span class="nc bnc" id="L2634" title="All 2 branches missed.">    while(sentsIter.hasNext()){</span>
<span class="nc" id="L2635">      Pair&lt;Map&lt;String, DataInstance&gt;, File&gt; sentsf = sentsIter.next();</span>
<span class="nc" id="L2636">      writeColumnOutputSents(sentsf.first(), writer, answerclasses);</span>
<span class="nc" id="L2637">    }</span>
<span class="nc" id="L2638">    writer.close();</span>
<span class="nc" id="L2639">  }</span>

  private static void writeColumnOutputSents(Map&lt;String, DataInstance&gt; sents, BufferedWriter writer, Map&lt;String, Class&lt;? extends TypesafeMap.Key&lt;String&gt;&gt;&gt; answerclasses) throws IOException {
<span class="nc bnc" id="L2642" title="All 2 branches missed.">    for (Entry&lt;String, DataInstance&gt; sent : sents.entrySet()) {</span>

<span class="nc" id="L2644">      writer.write(&quot;\n\n&quot; + sent.getKey() + &quot;\n&quot;);</span>

<span class="nc bnc" id="L2646" title="All 2 branches missed.">      for (CoreLabel s : sent.getValue().getTokens()) {</span>
<span class="nc" id="L2647">        writer.write(s.word()+&quot;\t&quot;);</span>
<span class="nc" id="L2648">        Set&lt;String&gt; labels = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L2649" title="All 2 branches missed.">        for (Entry&lt;String, Class&lt;? extends TypesafeMap.Key&lt;String&gt;&gt;&gt; as : answerclasses.entrySet()) {</span>
<span class="nc" id="L2650">          String label = as.getKey();</span>
<span class="nc bnc" id="L2651" title="All 2 branches missed.">          if (s.get(as.getValue()).equals(label)) {</span>
<span class="nc" id="L2652">            labels.add(label);</span>
          }
<span class="nc" id="L2654">        }</span>
<span class="nc bnc" id="L2655" title="All 2 branches missed.">        if(labels.isEmpty())</span>
<span class="nc" id="L2656">          writer.write(&quot;O\n&quot;);</span>
        else
<span class="nc" id="L2658">          writer.write(StringUtils.join(labels,&quot;,&quot;)+&quot;\n&quot;);</span>
<span class="nc" id="L2659">      }</span>
<span class="nc" id="L2660">      writer.write(&quot;\n&quot;);</span>
<span class="nc" id="L2661">    }</span>
<span class="nc" id="L2662">  }</span>

  // public Map&lt;String, DataInstance&gt; loadJavaNLPAnnotatorLabeledFile(String
  // labeledFile, Properties props) throws FileNotFoundException {
  // System.out.println(&quot;Loading evaluate file &quot; + labeledFile);
  // Map&lt;String, DataInstance&gt; sents = new HashMap&lt;String,
  // DataInstance&gt;();
  // JavaNLPAnnotatorReaderAndWriter j = new JavaNLPAnnotatorReaderAndWriter();
  // j.init(props);
  // Iterator&lt;DataInstance&gt; iter = j.getIterator(new BufferedReader(new
  // FileReader(labeledFile)));
  // int i = 0;
  // while (iter.hasNext()) {
  // i++;
  // DataInstance s = iter.next();
  // String id = s.get(0).get(CoreAnnotations.DocIDAnnotation.class);
  // if (id == null) {
  // id = Integer.toString(i);
  // }
  // sents.put(id, s);
  // }
  // System.out.println(&quot;Read &quot; + sents.size() + &quot; eval sentences&quot;);
  // return sents;
  // }

  // private void evaluate(String label, Map&lt;String, DataInstance&gt; sents)
  // throws IOException, InterruptedException, ExecutionException {
  // Redwood.log(Redwood.DBG, &quot;labeling &quot; + learnedWords.get(label));
  // CollectionValuedMap&lt;String, Integer&gt; tokensMatchedPatterns = new
  // CollectionValuedMap&lt;String, Integer&gt;();
  //
  // if (restrictToMatched) {
  // if (!alreadySetUp)
  // setUp();
  // List&lt;String&gt; keyset = new ArrayList&lt;String&gt;(sents.keySet());
  // int num = 0;
  // if (constVars.numThreads == 1)
  // num = keyset.size();
  // else
  // num = keyset.size() / (constVars.numThreads - 1);
  // ExecutorService executor = Executors
  // .newFixedThreadPool(constVars.numThreads);
  // // Redwood.log(ConstantsAndVariables.minimaldebug, &quot;keyset size is &quot; +
  // // keyset.size());
  // List&lt;Future&lt;Pair&lt;TwoDimensionalCounter&lt;Pair&lt;String, String&gt;,
  // SurfaceE&gt;, CollectionValuedMap&lt;String, Integer&gt;&gt;&gt;&gt; list = new
  // ArrayList&lt;Future&lt;Pair&lt;TwoDimensionalCounter&lt;Pair&lt;String, String&gt;,
  // SurfaceE&gt;, CollectionValuedMap&lt;String, Integer&gt;&gt;&gt;&gt;();
  // for (int i = 0; i &lt; constVars.numThreads; i++) {
  // // Redwood.log(ConstantsAndVariables.minimaldebug, &quot;assigning from &quot; + i *
  // // num + &quot; till &quot; + Math.min(keyset.size(), (i + 1) * num));
  //
  // Callable&lt;Pair&lt;TwoDimensionalCounter&lt;Pair&lt;String, String&gt;, SurfaceE&gt;,
  // CollectionValuedMap&lt;String, Integer&gt;&gt;&gt; task = null;
  // task = new ApplyPatterns(keyset.subList(i * num,
  // Math.min(keyset.size(), (i + 1) * num)),
  // this.learnedPatterns.get(label), constVars.commonEngWords,
  // usePatternResultAsLabel, this.learnedWords.get(label).keySet(),
  // restrictToMatched, label,
  // constVars.removeStopWordsFromSelectedPhrases,
  // constVars.removePhrasesWithStopWords, constVars);
  // Future&lt;Pair&lt;TwoDimensionalCounter&lt;Pair&lt;String, String&gt;, SurfaceE&gt;,
  // CollectionValuedMap&lt;String, Integer&gt;&gt;&gt; submit = executor
  // .submit(task);
  // list.add(submit);
  // }
  // for (Future&lt;Pair&lt;TwoDimensionalCounter&lt;Pair&lt;String, String&gt;,
  // SurfaceE&gt;, CollectionValuedMap&lt;String, Integer&gt;&gt;&gt; future : list) {
  // Pair&lt;TwoDimensionalCounter&lt;Pair&lt;String, String&gt;, SurfaceE&gt;,
  // CollectionValuedMap&lt;String, Integer&gt;&gt; res = future
  // .get();
  // tokensMatchedPatterns.addAll(res.second());
  // }
  // executor.shutdown();
  // }
  //
  // this.labelWords(label, sents, this.learnedWords.get(label).keySet(),
  // this.learnedPatterns.get(label).keySet(), null, tokensMatchedPatterns);
  // Counter&lt;String&gt; entityTP = new ClassicCounter&lt;String&gt;();
  // Counter&lt;String&gt; entityFP = new ClassicCounter&lt;String&gt;();
  // Counter&lt;String&gt; entityFN = new ClassicCounter&lt;String&gt;();
  // for (Entry&lt;String, DataInstance&gt; sent : sents.entrySet()) {
  // for (CoreLabel l : sent.getValue()) {
  // if (l.containsKey(constVars.answerClass.get(label))
  // &amp;&amp; l.get(constVars.answerClass.get(label)) != null)
  // l.set(CoreAnnotations.AnswerAnnotation.class,
  // l.get(constVars.answerClass.get(label)).toString());
  // if (!l.containsKey(CoreAnnotations.AnswerAnnotation.class)
  // || l.get(CoreAnnotations.AnswerAnnotation.class) == null) {
  // l.set(CoreAnnotations.AnswerAnnotation.class,
  // SeqClassifierFlags.DEFAULT_BACKGROUND_SYMBOL);
  //
  // }
  //
  // }
  // CRFClassifier.countResults(sent.getValue(), entityTP, entityFP, entityFN,
  // SeqClassifierFlags.DEFAULT_BACKGROUND_SYMBOL);
  // }
  //
  // Counter&lt;String&gt; precision = Counters.division(entityTP,
  // Counters.add(entityTP, entityFP));
  // Counter&lt;String&gt; recall = Counters.division(entityTP,
  // Counters.add(entityTP, entityFN));
  // Counter&lt;String&gt; fscore = Counters.getFCounter(precision, recall, 1.0);
  // System.out.println(&quot;Precision: &quot; + precision);
  // System.out.println(&quot;Recall: &quot; + recall);
  // System.out.println(&quot;FScore: &quot; + fscore);
  // }

  public void evaluate(Map&lt;String, DataInstance&gt; testSentences, boolean evalPerEntity) throws IOException {

<span class="nc bnc" id="L2773" title="All 2 branches missed.">    for (Entry&lt;String, Class&lt;? extends Key&lt;String&gt;&gt;&gt; anscl : constVars.getAnswerClass().entrySet()) {</span>
<span class="nc" id="L2774">      String label = anscl.getKey();</span>
<span class="nc" id="L2775">      Counter&lt;String&gt; entityTP = new ClassicCounter&lt;&gt;();</span>
<span class="nc" id="L2776">      Counter&lt;String&gt; entityFP = new ClassicCounter&lt;&gt;();</span>
<span class="nc" id="L2777">      Counter&lt;String&gt; entityFN = new ClassicCounter&lt;&gt;();</span>

<span class="nc" id="L2779">      Counter&lt;String&gt; wordTP = new ClassicCounter&lt;&gt;();</span>
<span class="nc" id="L2780">      Counter&lt;String&gt; wordTN = new ClassicCounter&lt;&gt;();</span>
<span class="nc" id="L2781">      Counter&lt;String&gt; wordFP = new ClassicCounter&lt;&gt;();</span>
<span class="nc" id="L2782">      Counter&lt;String&gt; wordFN = new ClassicCounter&lt;&gt;();</span>

<span class="nc bnc" id="L2784" title="All 2 branches missed.">      for (Entry&lt;String, DataInstance&gt; docEn : testSentences.entrySet()) {</span>
<span class="nc" id="L2785">        DataInstance doc = docEn.getValue();</span>
<span class="nc" id="L2786">        List&lt;CoreLabel&gt; doceval = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L2787" title="All 2 branches missed.">        for (CoreLabel l : doc.getTokens()) {</span>
<span class="nc" id="L2788">          CoreLabel l2 = new CoreLabel();</span>
<span class="nc" id="L2789">          l2.setWord(l.word());</span>

<span class="nc bnc" id="L2791" title="All 2 branches missed.">          if (l.get(anscl.getValue()).equals(label)) {</span>
<span class="nc" id="L2792">            l2.set(CoreAnnotations.AnswerAnnotation.class, label);</span>
          } else
<span class="nc" id="L2794">            l2.set(CoreAnnotations.AnswerAnnotation.class, constVars.backgroundSymbol);</span>

          // If the gold label is not the label we are calculating the scores
          // for, set it to the background symbol
<span class="nc bnc" id="L2798" title="All 2 branches missed.">          if (!l.get(CoreAnnotations.GoldAnswerAnnotation.class).equals(label)) {</span>
<span class="nc" id="L2799">            l2.set(CoreAnnotations.GoldAnswerAnnotation.class, constVars.backgroundSymbol);</span>
          } else
<span class="nc" id="L2801">            l2.set(CoreAnnotations.GoldAnswerAnnotation.class, label);</span>
<span class="nc" id="L2802">          doceval.add(l2);</span>
<span class="nc" id="L2803">        }</span>

<span class="nc" id="L2805">        countResults(doceval, entityTP, entityFP, entityFN, constVars.backgroundSymbol, wordTP, wordTN, wordFP, wordFN,</span>
            CoreAnnotations.AnswerAnnotation.class, evalPerEntity); //
<span class="nc" id="L2807">      }</span>
<span class="nc" id="L2808">      System.out.println(&quot;False Positives: &quot; + Counters.toSortedString(wordFP, wordFP.size(), &quot;%s:%.2f&quot;, &quot;;&quot;));</span>
<span class="nc" id="L2809">      System.out.println(&quot;False Negatives: &quot; + Counters.toSortedString(wordFN, wordFN.size(), &quot;%s:%.2f&quot;, &quot;;&quot;));</span>

<span class="nc" id="L2811">      Redwood.log(Redwood.DBG, &quot;\nFor label &quot; + label + &quot; True Positives: &quot; + entityTP + &quot;\tFalse Positives: &quot; + entityFP + &quot;\tFalse Negatives: &quot;</span>
          + entityFN);
<span class="nc" id="L2813">      Counter&lt;String&gt; precision = Counters.division(entityTP, Counters.add(entityTP, entityFP));</span>
<span class="nc" id="L2814">      Counter&lt;String&gt; recall = Counters.division(entityTP, Counters.add(entityTP, entityFN));</span>
<span class="nc" id="L2815">      Redwood.log(ConstantsAndVariables.minimaldebug, &quot;\nFor label &quot; + label + &quot; Precision: &quot; + precision + &quot;, Recall: &quot; + recall + &quot;, F1 score:  &quot;</span>
<span class="nc" id="L2816">          + FScore(precision, recall, 1));</span>
      // Redwood.log(ConstantsAndVariables.minimaldebug, &quot;Total: &quot; +
      // Counters.add(entityFP, entityTP));
<span class="nc" id="L2819">    }</span>

<span class="nc" id="L2821">  }</span>

  public static &lt;D&gt; Counter&lt;D&gt; FScore(Counter&lt;D&gt; precision, Counter&lt;D&gt; recall, double beta) {
<span class="nc" id="L2824">    double betasq = beta * beta;</span>
<span class="nc" id="L2825">    return Counters.divisionNonNaN(Counters.scale(Counters.product(precision, recall), (1 + betasq)),</span>
<span class="nc" id="L2826">        (Counters.add(Counters.scale(precision, betasq), recall)));</span>
  }

  private static List&lt;File&gt; getAllFiles(String file) {

<span class="nc" id="L2831">    List&lt;File&gt; allFiles = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L2832" title="All 2 branches missed.">    for (String tokfile : file.split(&quot;[,;]&quot;)) {</span>
<span class="nc" id="L2833">      File filef = new File(tokfile);</span>
<span class="nc bnc" id="L2834" title="All 2 branches missed.">      if (filef.isDirectory()) {</span>
<span class="nc" id="L2835">        Redwood.log(Redwood.DBG, &quot;Will read from directory &quot; + filef);</span>
<span class="nc" id="L2836">        String path = &quot;.*&quot;;</span>
<span class="nc" id="L2837">        File dir = filef;</span>
<span class="nc bnc" id="L2838" title="All 2 branches missed.">        for (File f : IOUtils.iterFilesRecursive(dir, java.util.regex.Pattern.compile(path))) {</span>
<span class="nc" id="L2839">          Redwood.log(ConstantsAndVariables.extremedebug, &quot;Will read from file &quot; + f);</span>
<span class="nc" id="L2840">          allFiles.add(f);</span>
<span class="nc" id="L2841">        }</span>
<span class="nc" id="L2842">      } else {</span>
<span class="nc bnc" id="L2843" title="All 2 branches missed.">        if (filef.exists()) {</span>
<span class="nc" id="L2844">          Redwood.log(Redwood.DBG, &quot;Will read from file &quot; + filef);</span>
<span class="nc" id="L2845">          allFiles.add(filef);</span>
        } else {
<span class="nc" id="L2847">          Redwood.log(Redwood.DBG, &quot;trying to read from file &quot; + filef);</span>
          //Is this a pattern?
<span class="nc" id="L2849">          RegExFileFilter fileFilter = new RegExFileFilter(java.util.regex.Pattern.compile(filef.getName()));</span>
<span class="nc" id="L2850">          File dir = new File(tokfile.substring(0, tokfile.lastIndexOf(&quot;/&quot;)));</span>
<span class="nc" id="L2851">          File[] files = dir.listFiles(fileFilter);</span>
<span class="nc" id="L2852">          allFiles.addAll(Arrays.asList(files));</span>
        }
      }


    }

<span class="nc" id="L2859">    return allFiles;</span>
  }

  private Pair&lt;Double, Double&gt; getPrecisionRecall(String label, Map&lt;String, Boolean&gt; goldWords4Label) {
<span class="nc" id="L2863">    Set&lt;CandidatePhrase&gt; learnedWords = constVars.getLearnedWords(label).keySet();</span>
<span class="nc" id="L2864">    int numcorrect = 0, numincorrect = 0;</span>
<span class="nc" id="L2865">    int numgoldcorrect = 0;</span>
<span class="nc bnc" id="L2866" title="All 2 branches missed.">    for (Entry&lt;String, Boolean&gt; en : goldWords4Label.entrySet()) {</span>
<span class="nc bnc" id="L2867" title="All 2 branches missed.">      if (en.getValue())</span>
<span class="nc" id="L2868">        numgoldcorrect++;</span>
<span class="nc" id="L2869">    }</span>
<span class="nc" id="L2870">    Set&lt;String&gt; assumedNeg = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L2871" title="All 2 branches missed.">    for (CandidatePhrase e : learnedWords) {</span>
<span class="nc bnc" id="L2872" title="All 2 branches missed.">      if (!goldWords4Label.containsKey(e.getPhrase())) {</span>
<span class="nc" id="L2873">        assumedNeg.add(e.getPhrase());</span>

<span class="nc" id="L2875">        numincorrect++;</span>
<span class="nc" id="L2876">        continue;</span>
      }
<span class="nc bnc" id="L2878" title="All 2 branches missed.">      if (goldWords4Label.get(e.getPhrase())) {</span>
<span class="nc" id="L2879">        numcorrect++;</span>
      } else
<span class="nc" id="L2881">        numincorrect++;</span>
<span class="nc" id="L2882">    }</span>

<span class="nc bnc" id="L2884" title="All 2 branches missed.">    if (!assumedNeg.isEmpty())</span>
<span class="nc" id="L2885">      log.info(&quot;\nGold entity list does not contain words &quot; + assumedNeg + &quot; for label &quot; + label + &quot;. *****Assuming them as negative.******&quot;);</span>

<span class="nc" id="L2887">    double precision = numcorrect / (double) (numcorrect + numincorrect);</span>
<span class="nc" id="L2888">    double recall = numcorrect / (double) (numgoldcorrect);</span>
<span class="nc" id="L2889">    return new Pair&lt;&gt;(precision, recall);</span>
  }

  private static double FScore(double precision, double recall, double beta) {
<span class="nc" id="L2893">    double betasq = beta * beta;</span>
<span class="nc" id="L2894">    return (1 + betasq) * precision * recall / (betasq * precision + recall);</span>
  }

  public Set&lt;String&gt; getNonBackgroundLabels(CoreLabel l){
<span class="nc" id="L2898">    Set&lt;String&gt; labels = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L2899" title="All 2 branches missed.">    for(Map.Entry&lt;String, Class&lt;? extends Key&lt;String&gt;&gt;&gt; en: constVars.getAnswerClass().entrySet()){</span>
<span class="nc bnc" id="L2900" title="All 2 branches missed.">      if(!l.get(en.getValue()).equals(constVars.backgroundSymbol)){</span>
<span class="nc" id="L2901">        labels.add(en.getKey());</span>
      }
<span class="nc" id="L2903">    }</span>
<span class="nc" id="L2904">    return labels;</span>
  }

  public static Map&lt;String, Set&lt;CandidatePhrase&gt;&gt; readSeedWordsFromJSONString(String str){
<span class="nc" id="L2908">    Map&lt;String, Set&lt;CandidatePhrase&gt;&gt; seedWords  = new HashMap&lt;&gt;();</span>
<span class="nc" id="L2909">    JsonReader jsonReader = Json.createReader(new StringReader(str));</span>
<span class="nc" id="L2910">    JsonObject obj = jsonReader.readObject();</span>

<span class="nc" id="L2912">    jsonReader.close();</span>
<span class="nc bnc" id="L2913" title="All 2 branches missed.">    for (String o : obj.keySet()){</span>
<span class="nc" id="L2914">      seedWords.put(o, new HashSet&lt;&gt;());</span>
<span class="nc" id="L2915">      JsonArray arr  = obj.getJsonArray(o);</span>
<span class="nc bnc" id="L2916" title="All 2 branches missed.">      for(JsonValue v: arr)</span>
<span class="nc" id="L2917">        seedWords.get(o).add(CandidatePhrase.createOrGet(v.toString()));</span>
<span class="nc" id="L2918">    }</span>
<span class="nc" id="L2919">    return seedWords;</span>
  }

  public static Map&lt;String, Set&lt;CandidatePhrase&gt;&gt; readSeedWords(Properties props) {
<span class="nc" id="L2923">    String seedWordsFile = props.getProperty(&quot;seedWordsFiles&quot;);</span>
<span class="nc bnc" id="L2924" title="All 2 branches missed.">    if(seedWordsFile != null)</span>
<span class="nc" id="L2925">      return readSeedWords(seedWordsFile);</span>
    else{
<span class="nc" id="L2927">      Redwood.log(Redwood.FORCE,&quot;NO SEED WORDS FILES PROVIDED!!&quot;);</span>
<span class="nc" id="L2928">    return Collections.emptyMap();</span>
    }
  }

  public static Map&lt;String, Set&lt;CandidatePhrase&gt;&gt; readSeedWords(String seedWordsFiles){
<span class="nc" id="L2933">    Map&lt;String, Set&lt;CandidatePhrase&gt;&gt; seedWords  = new HashMap&lt;&gt;();</span>


<span class="nc bnc" id="L2936" title="All 2 branches missed.">    if (seedWordsFiles == null) {</span>
<span class="nc" id="L2937">      throw new RuntimeException(</span>
        &quot;Needs both seedWordsFiles and file parameters to run this class!\nseedWordsFiles has format: label1,filewithlistofwords1;label2,filewithlistofwords2;...&quot;);
    }
<span class="nc bnc" id="L2940" title="All 2 branches missed.">    for (String seedFile : seedWordsFiles.split(&quot;;&quot;)) {</span>
<span class="nc" id="L2941">      String[] t = seedFile.split(&quot;,&quot;);</span>
<span class="nc" id="L2942">      String label = t[0];</span>
<span class="nc" id="L2943">      Set&lt;CandidatePhrase&gt; seedWords4Label = new HashSet&lt;&gt;();</span>

<span class="nc bnc" id="L2945" title="All 2 branches missed.">      for(int i = 1; i &lt; t.length; i++){</span>
<span class="nc" id="L2946">        String seedWordsFile = t[i];</span>
<span class="nc bnc" id="L2947" title="All 2 branches missed.">        for(File fin: ConstantsAndVariables.listFileIncludingItself(seedWordsFile)){</span>
<span class="nc" id="L2948">            Redwood.log(Redwood.DBG, &quot;Reading seed words from &quot; + fin + &quot; for label &quot; + label);</span>
<span class="nc bnc" id="L2949" title="All 2 branches missed.">            for (String line : IOUtils.readLines(fin)) {</span>
<span class="nc" id="L2950">              line = line.trim();</span>
<span class="nc bnc" id="L2951" title="All 4 branches missed.">              if (line.isEmpty() || line.startsWith(&quot;#&quot;)) {</span>
<span class="nc" id="L2952">                continue;</span>
              }
<span class="nc" id="L2954">              line = line.split(&quot;\t&quot;)[0];</span>
<span class="nc" id="L2955">              seedWords4Label.add(CandidatePhrase.createOrGet(line));</span>
<span class="nc" id="L2956">            }</span>
<span class="nc" id="L2957">          }</span>
      }

<span class="nc" id="L2960">      seedWords.put(label, seedWords4Label);</span>
<span class="nc" id="L2961">      Redwood.log(ConstantsAndVariables.minimaldebug, &quot;Number of seed words for label &quot; + label + &quot; is &quot; + seedWords4Label.size());</span>
    }
<span class="nc" id="L2963">    return seedWords;</span>
  }

  void removeLabelings(String label, Collection&lt;String&gt; removeLabeledPhrases){
    //TODO: write this up when appropriate
<span class="nc" id="L2968">  }</span>

<span class="fc" id="L2970">  static Class[] printOptionClass = {String.class, Boolean.class, Integer.class, Long.class, Double.class, Float.class};</span>
  public Map&lt;String, String&gt; getAllOptions(){
<span class="nc" id="L2972">    Map&lt;String, String&gt; values = new HashMap&lt;&gt;();</span>
<span class="nc" id="L2973">    props.forEach((x, y) -&gt; values.put(x.toString(), y.toString()));</span>
<span class="nc" id="L2974">    values.putAll(constVars.getAllOptions());</span>
    //StringBuilder sb = new StringBuilder();

    Class&lt;?&gt; thisClass;
    try {
<span class="nc" id="L2979">      thisClass = Class.forName(this.getClass().getName());</span>

<span class="nc" id="L2981">      Field[] aClassFields = thisClass.getDeclaredFields();</span>
      //sb.append(this.getClass().getSimpleName() + &quot; [ &quot;);
<span class="nc bnc" id="L2983" title="All 2 branches missed.">      for(Field f : aClassFields){</span>
<span class="nc bnc" id="L2984" title="All 4 branches missed.">        if(f.getGenericType().getClass().isPrimitive() || Arrays.binarySearch(printOptionClass, f.getType().getClass()) &gt;= 0){</span>
<span class="nc" id="L2985">          String fName = f.getName();</span>
<span class="nc" id="L2986">          Object fvalue = f.get(this);</span>
<span class="nc bnc" id="L2987" title="All 2 branches missed.">          values.put(fName, fvalue == null?&quot;null&quot;:fvalue.toString());</span>
        //sb.append(&quot;(&quot; + f.getType() + &quot;) &quot; + fName + &quot; = &quot; + f.get(this) + &quot;, &quot;);
        }
      }

<span class="nc" id="L2992">    } catch (Exception e) {</span>
<span class="nc" id="L2993">      log.warn(e);</span>
<span class="nc" id="L2994">    }</span>

<span class="nc" id="L2996">    return values;</span>
  }

<span class="nc" id="L2999">  public static class Flags {</span>
<span class="nc" id="L3000">    static public String useTargetParserParentRestriction = &quot;useTargetParserParentRestriction&quot;;</span>
<span class="nc" id="L3001">    public static String useTargetNERRestriction = &quot;useTargetNERRestriction&quot;;</span>
<span class="nc" id="L3002">    public static String posModelPath = &quot;posModelPath&quot;;</span>
<span class="nc" id="L3003">    public static String numThreads = &quot;numThreads&quot;;</span>
<span class="nc" id="L3004">    public static String patternType = &quot;patternType&quot;;</span>
<span class="nc" id="L3005">    public static String numIterationsOfSavedPatternsToLoad = &quot;numIterationsOfSavedPatternsToLoad&quot;;</span>
<span class="nc" id="L3006">    public static String patternsWordsDir = &quot;patternsWordsDir&quot;;</span>
<span class="nc" id="L3007">    public static String loadModelForLabels = &quot;loadModelForLabels&quot;;</span>
  }

  public static Pair&lt;Map&lt;String, DataInstance&gt;,Map&lt;String, DataInstance&gt;&gt; processSents(Properties props, Set&lt;String&gt; labels) throws IOException, ExecutionException, InterruptedException, ClassNotFoundException {
<span class="nc" id="L3011">    String fileFormat = props.getProperty(&quot;fileFormat&quot;);</span>
<span class="nc" id="L3012">    Map&lt;String, DataInstance&gt; sents = null;</span>
<span class="nc" id="L3013">    boolean batchProcessSents = Boolean.parseBoolean(props.getProperty(&quot;batchProcessSents&quot;, &quot;false&quot;));</span>
<span class="nc" id="L3014">    int numMaxSentencesPerBatchFile = Integer.parseInt(props.getProperty(&quot;numMaxSentencesPerBatchFile&quot;, String.valueOf(Integer.MAX_VALUE)));</span>

    //works only for non-batch processing!
<span class="nc" id="L3017">    boolean preserveSentenceSequence = Boolean.parseBoolean(props.getProperty(&quot;preserveSentenceSequence&quot;,&quot;false&quot;));</span>

<span class="nc bnc" id="L3019" title="All 2 branches missed.">    if (!batchProcessSents){</span>
<span class="nc bnc" id="L3020" title="All 2 branches missed.">      if(preserveSentenceSequence)</span>
<span class="nc" id="L3021">        sents = new LinkedHashMap&lt;&gt;();</span>
      else
<span class="nc" id="L3023">        sents = new HashMap&lt;&gt;();</span>

    }
    else {
<span class="nc" id="L3027">      Data.sentsFiles = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L3028">      Data.sentId2File = new ConcurrentHashMap&lt;&gt;();</span>
    }

<span class="nc" id="L3031">    String file = props.getProperty(&quot;file&quot;);</span>

<span class="nc" id="L3033">    String posModelPath = props.getProperty(&quot;posModelPath&quot;);</span>
<span class="nc" id="L3034">    boolean lowercase = Boolean.parseBoolean(props.getProperty(&quot;lowercaseText&quot;));</span>
<span class="nc" id="L3035">    boolean useTargetNERRestriction = Boolean.parseBoolean(props.getProperty(&quot;useTargetNERRestriction&quot;));</span>
<span class="nc" id="L3036">    boolean useTargetParserParentRestriction = Boolean.parseBoolean(props.getProperty(Flags.useTargetParserParentRestriction));</span>
<span class="nc" id="L3037">    boolean useContextNERRestriction = Boolean.parseBoolean(props.getProperty(&quot;useContextNERRestriction&quot;));</span>
<span class="nc" id="L3038">    boolean addEvalSentsToTrain = Boolean.parseBoolean(props.getProperty(&quot;addEvalSentsToTrain&quot;,&quot;true&quot;));</span>
<span class="nc" id="L3039">    String evalFileWithGoldLabels = props.getProperty(&quot;evalFileWithGoldLabels&quot;);</span>

<span class="nc bnc" id="L3041" title="All 6 branches missed.">    if (file == null &amp;&amp; (evalFileWithGoldLabels == null || addEvalSentsToTrain == false)) {</span>
<span class="nc" id="L3042">      throw new RuntimeException(&quot;No training data! file is &quot; + file + &quot; and evalFileWithGoldLabels is &quot; + evalFileWithGoldLabels</span>
        + &quot; and addEvalSentsToTrain is &quot; + addEvalSentsToTrain);
    }

<span class="nc bnc" id="L3046" title="All 2 branches missed.">    if(props.getProperty(Flags.patternType) == null)</span>
<span class="nc" id="L3047">      throw new RuntimeException(&quot;PattenrType not specified. Options are SURFACE and DEP&quot;);</span>

<span class="nc" id="L3049">    PatternFactory.PatternType patternType = PatternFactory.PatternType.valueOf(props.getProperty(Flags.patternType));</span>

    // Read training file
<span class="nc bnc" id="L3052" title="All 2 branches missed.">    if (file != null) {</span>
<span class="nc" id="L3053">      String saveSentencesSerDirstr = props.getProperty(&quot;saveSentencesSerDir&quot;);</span>
<span class="nc" id="L3054">      File saveSentencesSerDir = null;</span>
<span class="nc bnc" id="L3055" title="All 2 branches missed.">      if (saveSentencesSerDirstr != null) {</span>
<span class="nc" id="L3056">        saveSentencesSerDir = new File(saveSentencesSerDirstr);</span>

<span class="nc bnc" id="L3058" title="All 4 branches missed.">        if(saveSentencesSerDir.exists() &amp;&amp; !fileFormat.equalsIgnoreCase(&quot;ser&quot;))</span>
<span class="nc" id="L3059">          IOUtils.deleteDirRecursively(saveSentencesSerDir);</span>

<span class="nc" id="L3061">        IOUtils.ensureDir(saveSentencesSerDir);</span>
      }

<span class="nc" id="L3064">      String systemdir = System.getProperty(&quot;java.io.tmpdir&quot;);</span>
<span class="nc" id="L3065">      File tempSaveSentencesDir = File.createTempFile(&quot;sents&quot;, &quot;.tmp&quot;, new File(systemdir));</span>
<span class="nc" id="L3066">      tempSaveSentencesDir.deleteOnExit();</span>
<span class="nc" id="L3067">      tempSaveSentencesDir.delete();</span>
<span class="nc" id="L3068">      tempSaveSentencesDir.mkdir();</span>


<span class="nc" id="L3071">      int numFilesTillNow = 0;</span>
<span class="nc bnc" id="L3072" title="All 6 branches missed.">      if (fileFormat == null || fileFormat.equalsIgnoreCase(&quot;text&quot;) || fileFormat.equalsIgnoreCase(&quot;txt&quot;)) {</span>

        Map&lt;String, DataInstance&gt; sentsthis ;
<span class="nc bnc" id="L3075" title="All 2 branches missed.">        if(preserveSentenceSequence)</span>
<span class="nc" id="L3076">          sentsthis = new LinkedHashMap&lt;&gt;();</span>
        else
<span class="nc" id="L3078">          sentsthis = new HashMap&lt;&gt;();</span>

<span class="nc bnc" id="L3080" title="All 2 branches missed.">        for (File f : GetPatternsFromDataMultiClass.getAllFiles(file)) {</span>
<span class="nc" id="L3081">          Redwood.log(Redwood.DBG, &quot;Annotating text in &quot; + f);</span>

          //String text = IOUtils.stringFromFile(f.getAbsolutePath());

<span class="nc" id="L3085">          Iterator&lt;String&gt; reader = IOUtils.readLines(f).iterator();</span>
<span class="nc bnc" id="L3086" title="All 2 branches missed.">          while(reader.hasNext()){</span>
<span class="nc bnc" id="L3087" title="All 4 branches missed.">            numFilesTillNow = tokenize(reader, posModelPath, lowercase, useTargetNERRestriction || useContextNERRestriction, f.getName() + &quot;-&quot; + numFilesTillNow+&quot;-&quot;,</span>
<span class="nc bnc" id="L3088" title="All 2 branches missed.">              useTargetParserParentRestriction, props.getProperty(Flags.numThreads), batchProcessSents, numMaxSentencesPerBatchFile,</span>
              saveSentencesSerDir == null? tempSaveSentencesDir : saveSentencesSerDir, sentsthis, numFilesTillNow, patternType);
          }

<span class="nc bnc" id="L3092" title="All 2 branches missed.">          if (!batchProcessSents) {</span>
<span class="nc" id="L3093">            sents.putAll(sentsthis);</span>
          }
<span class="nc" id="L3095">        }</span>

<span class="nc bnc" id="L3097" title="All 2 branches missed.">        if (!batchProcessSents) {</span>
//          for(Map.Entry&lt;String, DataInstance&gt; d: sents.entrySet()){
//            for(CoreLabel l : d.getValue().getTokens()){
//              for(String label: labels) {
//                if(l.containsKey(PatternsAnnotations.LongestMatchedPhraseForEachLabel.class)){
//                  CandidatePhrase p = l.get(PatternsAnnotations.LongestMatchedPhraseForEachLabel.class).get(label);
//                }
//              }
//            }
//          }

<span class="nc bnc" id="L3108" title="All 2 branches missed.">          String outfilename= (saveSentencesSerDir == null ? tempSaveSentencesDir : saveSentencesSerDir) + &quot;/sents_&quot; + numFilesTillNow;</span>
<span class="nc bnc" id="L3109" title="All 2 branches missed.">          if(saveSentencesSerDir != null)</span>
<span class="nc" id="L3110">            Data.inMemorySaveFileLocation = outfilename;</span>

<span class="nc" id="L3112">          Redwood.log(Redwood.FORCE, &quot;Saving sentences in &quot; + outfilename);</span>
<span class="nc" id="L3113">          IOUtils.writeObjectToFile(sents, outfilename);</span>
        }
<span class="nc bnc" id="L3115" title="All 2 branches missed.">      } else if (fileFormat.equalsIgnoreCase(&quot;ser&quot;)) {</span>
<span class="nc bnc" id="L3116" title="All 2 branches missed.">        for (File f : GetPatternsFromDataMultiClass.getAllFiles(file)) {</span>
<span class="nc" id="L3117">          Redwood.log(Redwood.DBG, &quot;reading from ser file &quot; + f);</span>
<span class="nc bnc" id="L3118" title="All 2 branches missed.">          if (!batchProcessSents)</span>
<span class="nc" id="L3119">            sents.putAll((Map&lt;String, DataInstance&gt;) IOUtils.readObjectFromFile(f));</span>
          else{
<span class="nc" id="L3121">            File newf = new File(tempSaveSentencesDir.getAbsolutePath() + &quot;/&quot; + f.getAbsolutePath().replaceAll(java.util.regex.Pattern.quote(&quot;/&quot;), &quot;_&quot;));</span>
<span class="nc" id="L3122">            IOUtils.cp(f, newf);</span>
<span class="nc" id="L3123">            Data.sentsFiles.add(newf);</span>
          }
<span class="nc" id="L3125">        }</span>
      } else {
<span class="nc" id="L3127">        throw new RuntimeException(</span>
          &quot;Cannot identify the file format. Valid values are text (or txt) and ser, where the serialized file is of the type Map&lt;String, DataInstance&gt;.&quot;);
      }
    }

<span class="nc" id="L3132">    Map&lt;String, DataInstance&gt; evalsents = new HashMap&lt;&gt;();</span>

<span class="nc" id="L3134">    boolean evaluate = Boolean.parseBoolean(props.getProperty(&quot;evaluate&quot;));</span>

    // Read Evaluation File
<span class="nc bnc" id="L3137" title="All 2 branches missed.">    if (evaluate) {</span>
<span class="nc bnc" id="L3138" title="All 2 branches missed.">      if (evalFileWithGoldLabels != null) {</span>

<span class="nc" id="L3140">        String saveEvalSentencesSerFile = props.getProperty(&quot;saveEvalSentencesSerFile&quot;);</span>
<span class="nc" id="L3141">        File saveEvalSentencesSerFileFile = null;</span>
<span class="nc bnc" id="L3142" title="All 2 branches missed.">        if (saveEvalSentencesSerFile == null) {</span>
<span class="nc" id="L3143">          String systemdir = System.getProperty(&quot;java.io.tmpdir&quot;);</span>
<span class="nc" id="L3144">          saveEvalSentencesSerFileFile = File.createTempFile(&quot;evalsents&quot;, &quot;.tmp&quot;, new File(systemdir));</span>
<span class="nc" id="L3145">        } else</span>
<span class="nc" id="L3146">          saveEvalSentencesSerFileFile = new File(saveEvalSentencesSerFile);</span>

<span class="nc" id="L3148">        Map setClassForTheseLabels = new HashMap&lt;String, Class&gt;();</span>
        //boolean splitOnPunct = Boolean.parseBoolean(props.getProperty(&quot;splitOnPunct&quot;, &quot;true&quot;));
<span class="nc" id="L3150">        List&lt;File&gt; allFiles = GetPatternsFromDataMultiClass.getAllFiles(evalFileWithGoldLabels);</span>
<span class="nc" id="L3151">        int numFile = 0;</span>
<span class="nc" id="L3152">        String evalFileFormat = props.getProperty(&quot;evalFileFormat&quot;);</span>
<span class="nc bnc" id="L3153" title="All 8 branches missed.">        if (evalFileFormat == null || evalFileFormat.equalsIgnoreCase(&quot;text&quot;) || evalFileFormat.equalsIgnoreCase(&quot;txt&quot;) || evalFileFormat.startsWith(&quot;text&quot;)) {</span>
<span class="nc bnc" id="L3154" title="All 2 branches missed.">          for (File f : allFiles) {</span>
<span class="nc" id="L3155">            numFile++;</span>
<span class="nc" id="L3156">            Redwood.log(Redwood.DBG, &quot;Annotating text in &quot; + f + &quot;. Num file &quot; + numFile);</span>
<span class="nc bnc" id="L3157" title="All 2 branches missed.">            if(evalFileFormat.equalsIgnoreCase(&quot;textCoNLLStyle&quot;)){</span>
<span class="nc" id="L3158">              Map&lt;String, DataInstance&gt; sentsEval = AnnotatedTextReader.parseColumnFile(new BufferedReader(new FileReader(f)), labels, setClassForTheseLabels, true, f.getName());</span>
<span class="nc" id="L3159">              evalsents.putAll(runPOSNERParseOnTokens(sentsEval, props));</span>
<span class="nc" id="L3160">            } else{</span>
<span class="nc" id="L3161">              List&lt;CoreMap&gt; sentsCMs = AnnotatedTextReader.parseFile(new BufferedReader(new FileReader(f)), labels,</span>
<span class="nc" id="L3162">                setClassForTheseLabels, true, f.getName());</span>
<span class="nc bnc" id="L3163" title="All 4 branches missed.">              evalsents.putAll(runPOSNEROnTokens(sentsCMs, posModelPath, useTargetNERRestriction || useContextNERRestriction, &quot;&quot;,</span>
<span class="nc" id="L3164">                useTargetParserParentRestriction, props.getProperty(Flags.numThreads), patternType));</span>
            }
<span class="nc" id="L3166">          }</span>

<span class="nc bnc" id="L3168" title="All 2 branches missed.">        } else if (fileFormat.equalsIgnoreCase(&quot;ser&quot;)) {</span>
<span class="nc bnc" id="L3169" title="All 2 branches missed.">          for (File f : allFiles) {</span>
<span class="nc" id="L3170">            evalsents.putAll((Map&lt;? extends String, ? extends DataInstance&gt;) IOUtils.readObjectFromFile(f));</span>
<span class="nc" id="L3171">          }</span>
        }
<span class="nc bnc" id="L3173" title="All 2 branches missed.">        if (addEvalSentsToTrain) {</span>
<span class="nc" id="L3174">          Redwood.log(Redwood.DBG, &quot;Adding &quot; + evalsents.size() + &quot; eval sents to the training set&quot;);</span>
        }

<span class="nc" id="L3177">        IOUtils.writeObjectToFile(evalsents, saveEvalSentencesSerFileFile);</span>

<span class="nc bnc" id="L3179" title="All 2 branches missed.">        if (batchProcessSents) {</span>

<span class="nc" id="L3181">          Data.sentsFiles.add(saveEvalSentencesSerFileFile);</span>

<span class="nc bnc" id="L3183" title="All 2 branches missed.">          for(String k: evalsents.keySet())</span>
<span class="nc" id="L3184">            Data.sentId2File.put(k, saveEvalSentencesSerFileFile);</span>
        } else
<span class="nc" id="L3186">          sents.putAll(evalsents);</span>
      }
    }
<span class="nc" id="L3189">    return new Pair&lt;Map&lt;String, DataInstance&gt;,Map&lt;String, DataInstance&gt;&gt;(sents, evalsents);</span>
  }

  private void saveModel() throws IOException {
<span class="nc" id="L3193">    String patternsWordsDirValue = props.getProperty(&quot;patternsWordsDir&quot;);</span>
    String patternsWordsDir;
<span class="nc bnc" id="L3195" title="All 2 branches missed.">    if (patternsWordsDirValue.endsWith(&quot;.zip&quot;)) {</span>
<span class="nc" id="L3196">      File temp = File.createTempFile(&quot;patswords&quot;, &quot;dir&quot;);</span>
<span class="nc" id="L3197">      temp.deleteOnExit();</span>
<span class="nc" id="L3198">      temp.delete();</span>
<span class="nc" id="L3199">      temp.mkdirs();</span>
<span class="nc" id="L3200">      patternsWordsDir = temp.getAbsolutePath();</span>
<span class="nc" id="L3201">    } else {</span>
<span class="nc" id="L3202">      patternsWordsDir = patternsWordsDirValue;</span>
    }
<span class="nc" id="L3204">    Redwood.log(Redwood.FORCE, &quot;Saving output in &quot; + patternsWordsDir);</span>

<span class="nc" id="L3206">    IOUtils.ensureDir(new File(patternsWordsDir));</span>
    //writing properties file
<span class="nc" id="L3208">    String outPropertiesFile = patternsWordsDir+&quot;model.properties&quot;;</span>
<span class="nc" id="L3209">    props.store(new BufferedWriter(new FileWriter(outPropertiesFile)), &quot;trained model properties file&quot;);</span>

<span class="nc bnc" id="L3211" title="All 2 branches missed.">    for (String label : constVars.getLabels()) {</span>

<span class="nc" id="L3213">      IOUtils.ensureDir(new File(patternsWordsDir + &quot;/&quot; + label));</span>

<span class="nc" id="L3215">      BufferedWriter seedW = new BufferedWriter(new FileWriter(patternsWordsDir+&quot;/&quot;+label+&quot;/seedwords.txt&quot;));</span>

<span class="nc bnc" id="L3217" title="All 2 branches missed.">      for(CandidatePhrase p : constVars.getSeedLabelDictionary().get(label)){</span>
<span class="nc" id="L3218">        seedW.write(p.getPhrase()+&quot;\n&quot;);</span>
<span class="nc" id="L3219">      }</span>
<span class="nc" id="L3220">      seedW.close();</span>

<span class="nc" id="L3222">      Map&lt;Integer, Counter&lt;E&gt;&gt; pats = getLearnedPatternsEachIter(label);</span>
<span class="nc" id="L3223">      IOUtils.writeObjectToFile(pats, patternsWordsDir + &quot;/&quot; + label + &quot;/patternsEachIter.ser&quot;);</span>


<span class="nc" id="L3226">      BufferedWriter w = new BufferedWriter(new FileWriter(patternsWordsDir + &quot;/&quot; + label + &quot;/phrases.txt&quot;));</span>
<span class="nc" id="L3227">      writeWordsToFile(constVars.getLearnedWordsEachIter(label), w);</span>

      //Write env
<span class="nc" id="L3230">      writeClassesInEnv(constVars.env, ConstantsAndVariables.globalEnv, patternsWordsDir + &quot;/env.txt&quot;);</span>

      //Write the token mapping
<span class="nc bnc" id="L3233" title="All 2 branches missed.">      if (constVars.patternType.equals(PatternFactory.PatternType.SURFACE))</span>
<span class="nc" id="L3234">        IOUtils.writeStringToFile(Token.toStringClass2KeyMapping(), patternsWordsDir + &quot;/tokenenv.txt&quot;, &quot;utf8&quot;);</span>

<span class="nc" id="L3236">      w.close();</span>
<span class="nc" id="L3237">    }</span>
//    if (patternsWordsDirValue.endsWith(&quot;.zip&quot;)) {
//      Redwood.log(&quot;Saving the zipped model to &quot; + patternsWordsDirValue);
//      zip(patternsWordsDir, patternsWordsDirValue);
//    }
<span class="nc" id="L3242">  }</span>

  private void evaluate(Map&lt;String, DataInstance&gt; evalsents) throws IOException {
<span class="nc bnc" id="L3245" title="All 2 branches missed.">    if(constVars.goldEntitiesEvalFiles !=null) {</span>

<span class="nc bnc" id="L3247" title="All 2 branches missed.">      for (String label : constVars.getLabels()) {</span>
<span class="nc bnc" id="L3248" title="All 2 branches missed.">        if(constVars.goldEntities.containsKey(label)){</span>
<span class="nc" id="L3249">          Pair&lt;Double, Double&gt; pr = getPrecisionRecall(label, constVars.goldEntities.get(label));</span>
<span class="nc" id="L3250">          Redwood.log(ConstantsAndVariables.minimaldebug,</span>
<span class="nc" id="L3251">            &quot;\nFor label &quot; + label + &quot;: Number of gold entities is &quot; + constVars.goldEntities.get(label).size() + &quot;, Precision is &quot; + df.format(pr.first() * 100)</span>
<span class="nc" id="L3252">              + &quot;, Recall is &quot; + df.format(pr.second() * 100) + &quot;, F1 is &quot; + df.format(FScore(pr.first(), pr.second(), 1.0) * 100)</span>
              + &quot;\n\n&quot;);
        }
<span class="nc" id="L3255">      }</span>
    }

<span class="nc bnc" id="L3258" title="All 2 branches missed.">    if(evalsents.size() &gt; 0){</span>
<span class="nc" id="L3259">      boolean evalPerEntity = Boolean.parseBoolean(props.getProperty(&quot;evalPerEntity&quot;, &quot;true&quot;));</span>
<span class="nc" id="L3260">      evaluate(evalsents, evalPerEntity);</span>
    }

<span class="nc bnc" id="L3263" title="All 4 branches missed.">    if (evalsents.size() == 0 &amp;&amp; constVars.goldEntitiesEvalFiles == null)</span>
<span class="nc" id="L3264">      log.info(&quot;No eval sentences or list of gold entities provided to evaluate! Make sure evalFileWithGoldLabels or goldEntitiesEvalFiles is set, or turn off the evaluate flag&quot;);</span>

<span class="nc" id="L3266">  }</span>



  /**
   * Execute the system give a properties file or object. Returns the model created
   * @param props
   */
  public static&lt;E extends Pattern&gt; GetPatternsFromDataMultiClass&lt;E&gt; run(Properties props) throws IOException, ClassNotFoundException, IllegalAccessException, InterruptedException, ExecutionException, InstantiationException, NoSuchMethodException, InvocationTargetException, SQLException {
<span class="nc" id="L3275">    Map&lt;String, Set&lt;CandidatePhrase&gt;&gt; seedWords = readSeedWords(props);</span>

<span class="nc" id="L3277">    Map&lt;String, Class&gt; answerClasses = new HashMap&lt;&gt;();</span>
<span class="nc" id="L3278">    String ansClasses = props.getProperty(&quot;answerClasses&quot;);</span>
<span class="nc bnc" id="L3279" title="All 2 branches missed.">    if (ansClasses != null) {</span>
<span class="nc bnc" id="L3280" title="All 2 branches missed.">      for (String l : ansClasses.split(&quot;;&quot;)) {</span>
<span class="nc" id="L3281">        String[] t = l.split(&quot;,&quot;);</span>
<span class="nc" id="L3282">        String label = t[0];</span>
<span class="nc" id="L3283">        String cl = t[1];</span>
<span class="nc" id="L3284">        Class answerClass = ClassLoader.getSystemClassLoader().loadClass(cl);</span>
<span class="nc" id="L3285">        answerClasses.put(label, answerClass);</span>
      }
    }

    //process all the sentences here!
<span class="nc" id="L3290">    Pair&lt;Map&lt;String, DataInstance&gt;, Map&lt;String, DataInstance&gt;&gt; sentsPair = processSents(props, seedWords.keySet());</span>

<span class="nc" id="L3292">    boolean labelUsingSeedSets = Boolean.parseBoolean(props.getProperty(&quot;labelUsingSeedSets&quot;, &quot;true&quot;));</span>

<span class="nc" id="L3294">    GetPatternsFromDataMultiClass&lt;E&gt; model = new GetPatternsFromDataMultiClass&lt;&gt;(props, sentsPair.first(), seedWords, labelUsingSeedSets);</span>
<span class="nc" id="L3295">    return runNineYards(model, props, sentsPair.second());</span>
  }

  private static&lt;E extends Pattern&gt; GetPatternsFromDataMultiClass&lt;E&gt; runNineYards(GetPatternsFromDataMultiClass&lt;E&gt; model, Properties props, Map&lt;String, DataInstance&gt; evalsents) throws IOException, ClassNotFoundException {

<span class="nc" id="L3300">    ArgumentParser.fillOptions(model, props);</span>

    // If you want to reuse patterns and words learned previously (may be on another dataset etc)
<span class="nc" id="L3303">    boolean loadSavedPatternsWordsDir = Boolean.parseBoolean(props.getProperty(&quot;loadSavedPatternsWordsDir&quot;));</span>


    //#################### Load already save pattersn and phrases
<span class="nc bnc" id="L3307" title="All 2 branches missed.">    if (loadSavedPatternsWordsDir)</span>
<span class="nc" id="L3308">      loadFromSavedPatternsWordsDir(model , props);</span>


<span class="nc bnc" id="L3311" title="All 2 branches missed.">    if (model.constVars.learn) {</span>
<span class="nc" id="L3312">      Map&lt;String, E&gt; p0 = new HashMap&lt;&gt;();</span>
<span class="nc" id="L3313">      Map&lt;String, Counter&lt;CandidatePhrase&gt;&gt; p0Set = new HashMap&lt;&gt;();</span>
<span class="nc" id="L3314">      Map&lt;String, Set&lt;E&gt;&gt; ignorePatterns = new HashMap&lt;&gt;();</span>
<span class="nc" id="L3315">      model.iterateExtractApply(p0, p0Set, ignorePatterns);</span>
    }

    //############ Write Output files
<span class="nc bnc" id="L3319" title="All 2 branches missed.">    if (model.constVars.markedOutputTextFile != null)</span>
<span class="nc" id="L3320">      model.writeLabeledData(model.constVars.markedOutputTextFile);</span>


<span class="nc bnc" id="L3323" title="All 2 branches missed.">    if(model.constVars.columnOutputFile != null)</span>
<span class="nc" id="L3324">      writeColumnOutput(model.constVars.columnOutputFile, model.constVars.batchProcessSents, model.constVars.getAnswerClass());</span>

    //###################### SAVE MODEL
<span class="nc bnc" id="L3327" title="All 2 branches missed.">    if(model.constVars.savePatternsWordsDir)</span>
<span class="nc" id="L3328">      model.saveModel();</span>


    //######## EVALUATE ###########################3
<span class="nc" id="L3332">    boolean evaluate = Boolean.parseBoolean(props.getProperty(&quot;evaluate&quot;));</span>

<span class="nc bnc" id="L3334" title="All 4 branches missed.">    if (evaluate &amp;&amp; evalsents != null) {</span>
<span class="nc" id="L3335">      model.evaluate(evalsents);</span>
    }

<span class="nc bnc" id="L3338" title="All 2 branches missed.">    if(model.constVars.saveInvertedIndex){</span>
<span class="nc" id="L3339">      model.constVars.invertedIndex.saveIndex(model.constVars.invertedIndexDirectory);</span>
    }

<span class="nc bnc" id="L3342" title="All 2 branches missed.">    if(model.constVars.storePatsForEachToken.equals(ConstantsAndVariables.PatternForEachTokenWay.LUCENE)){</span>
<span class="nc" id="L3343">      model.patsForEachToken.close();</span>
    }

<span class="nc" id="L3346">    return model;</span>
  }

<span class="fc" id="L3349">  static int numIterationsLoadedModel = 0;</span>

//  static void unzip(String file, String outputDir) throws IOException {
//    ZipFile zipFile = new ZipFile(file);
//    Enumeration&lt;? extends ZipEntry&gt; entries = zipFile.entries();
//    while (entries.hasMoreElements()) {
//      ZipEntry entry = entries.nextElement();
//      Path entryDestination = new File(outputDir,  entry.getName()).toPath();
//      entryDestination.toFile().getParentFile().mkdirs();
//      if (entry.isDirectory())
//        entryDestination.toFile().mkdirs();
//      else {
//        InputStream in = zipFile.getInputStream(entry);
//        Files.copy(in, entryDestination);
//        in.close();
//      }
//    }
//  }
//
//  static void zip(String directory, String outputFileName) throws IOException {
//    FileOutputStream fos = new FileOutputStream(outputFileName);
//    ZipOutputStream zos = new ZipOutputStream(fos);
//    //level - the compression level (0-9)
//    zos.setLevel(9);
//    addFolder(zos, directory, directory);
//    zos.close();
//  }

  /** copied from http://www.justexample.com/wp/compress-folder-into-zip-file-using-java/ */
    private static void addFolder(ZipOutputStream zos,String folderName,String baseFolderName) throws IOException {
<span class="nc" id="L3379">      File f = new File(folderName);</span>
<span class="nc bnc" id="L3380" title="All 2 branches missed.">      if(f.exists()){</span>

<span class="nc bnc" id="L3382" title="All 2 branches missed.">        if(f.isDirectory()){</span>
<span class="nc bnc" id="L3383" title="All 2 branches missed.">          if(!folderName.equalsIgnoreCase(baseFolderName)){</span>
<span class="nc" id="L3384">            String entryName = folderName.substring(baseFolderName.length()+1,folderName.length()) + File.separatorChar;</span>
<span class="nc" id="L3385">            System.out.println(&quot;Adding folder entry &quot; + entryName);</span>
<span class="nc" id="L3386">            ZipEntry ze= new ZipEntry(entryName);</span>
<span class="nc" id="L3387">            zos.putNextEntry(ze);</span>
          }
<span class="nc" id="L3389">          File[] f2 = f.listFiles();</span>
<span class="nc bnc" id="L3390" title="All 2 branches missed.">          for (File aF2 : f2) {</span>
<span class="nc" id="L3391">            addFolder(zos, aF2.getAbsolutePath(), baseFolderName);</span>
          }
<span class="nc" id="L3393">        }else{</span>
          //add file
          //extract the relative name for entry purpose
<span class="nc" id="L3396">          String entryName = folderName.substring(baseFolderName.length()+1,folderName.length());</span>
<span class="nc" id="L3397">          ZipEntry ze= new ZipEntry(entryName);</span>
<span class="nc" id="L3398">          zos.putNextEntry(ze);</span>
<span class="nc" id="L3399">          FileInputStream in = new FileInputStream(folderName);</span>
          int len;
<span class="nc" id="L3401">          byte[] buffer = new byte[1024];</span>
<span class="nc bnc" id="L3402" title="All 2 branches missed.">          while ((len = in.read(buffer)) &lt; 0) {</span>
<span class="nc" id="L3403">            zos.write(buffer, 0, len);</span>
          }
<span class="nc" id="L3405">          in.close();</span>
<span class="nc" id="L3406">          zos.closeEntry();</span>
<span class="nc" id="L3407">          System.out.println(&quot;OK!&quot;);</span>

<span class="nc" id="L3409">        }</span>
      }else{
<span class="nc" id="L3411">        System.out.println(&quot;File or directory not found &quot; + folderName);</span>
      }

<span class="nc" id="L3414">    }</span>

  public static&lt;E extends Pattern&gt; Map&lt;E, String&gt; loadFromSavedPatternsWordsDir(GetPatternsFromDataMultiClass&lt;E&gt; model, Properties props) throws IOException, ClassNotFoundException {

<span class="nc" id="L3418">    boolean labelSentsUsingModel = Boolean.parseBoolean(props.getProperty(&quot;labelSentsUsingModel&quot;,&quot;true&quot;));</span>
<span class="nc" id="L3419">    boolean applyPatsUsingModel = Boolean.parseBoolean(props.getProperty(&quot;applyPatsUsingModel&quot;,&quot;true&quot;));</span>
<span class="nc" id="L3420">    int numIterationsOfSavedPatternsToLoad = Integer.parseInt(props.getProperty(Flags.numIterationsOfSavedPatternsToLoad,String.valueOf(Integer.MAX_VALUE)));</span>

<span class="nc" id="L3422">    Map&lt;E, String&gt; labelsForPattterns = new HashMap&lt;&gt;();</span>
<span class="nc" id="L3423">    String patternsWordsDirValue = props.getProperty(Flags.patternsWordsDir);</span>
    String patternsWordsDir;
//    if(patternsWordsDirValue.endsWith(&quot;.zip&quot;)){
//      File tempdir = File.createTempFile(&quot;patternswordsdir&quot;,&quot;dir&quot;);
//      tempdir.deleteOnExit();
//      tempdir.delete();
//      tempdir.mkdirs();
//      patternsWordsDir = tempdir.getAbsolutePath();
//      unzip(patternsWordsDirValue, patternsWordsDir);
//    }else
<span class="nc" id="L3433">      patternsWordsDir = patternsWordsDirValue;</span>


<span class="nc" id="L3436">    String sentsOutFile = props.getProperty(&quot;sentsOutFile&quot;);</span>
<span class="nc" id="L3437">    String loadModelForLabels = props.getProperty(Flags.loadModelForLabels);</span>
<span class="nc" id="L3438">    List&lt;String&gt; loadModelForLabelsList = null;</span>
<span class="nc bnc" id="L3439" title="All 2 branches missed.">    if(loadModelForLabels != null)</span>
<span class="nc" id="L3440">      loadModelForLabelsList = Arrays.asList(loadModelForLabels.split(&quot;[,;]&quot;));</span>

<span class="nc bnc" id="L3442" title="All 2 branches missed.">    for (String label : model.constVars.getLabels()) {</span>

<span class="nc bnc" id="L3444" title="All 4 branches missed.">      if(loadModelForLabels != null &amp;&amp; !loadModelForLabelsList.contains(label))</span>
<span class="nc" id="L3445">        continue;</span>

<span class="nc bnc" id="L3447" title="All 4 branches missed.">      assert (new File(patternsWordsDir + &quot;/&quot; + label).exists()) : &quot;Why does the directory &quot; + patternsWordsDir + &quot;/&quot; + label + &quot; not exist?&quot;;</span>


<span class="nc" id="L3450">      readClassesInEnv(patternsWordsDir + &quot;/env.txt&quot;, model.constVars.env, ConstantsAndVariables.globalEnv);</span>

      //Read the token mapping
<span class="nc bnc" id="L3453" title="All 2 branches missed.">      if(model.constVars.patternType.equals(PatternFactory.PatternType.SURFACE))</span>
<span class="nc" id="L3454">        Token.setClass2KeyMapping(new File(patternsWordsDir+&quot;/tokenenv.txt&quot;));</span>

      //Load Patterns
<span class="nc" id="L3457">      File patf = new File(patternsWordsDir + &quot;/&quot; + label + &quot;/patternsEachIter.ser&quot;);</span>
<span class="nc bnc" id="L3458" title="All 2 branches missed.">      if (patf.exists()) {</span>
<span class="nc" id="L3459">        Map&lt;Integer, Counter&lt;E&gt;&gt; patterns = IOUtils.readObjectFromFile(patf);</span>
<span class="nc bnc" id="L3460" title="All 2 branches missed.">        if(numIterationsOfSavedPatternsToLoad &lt; Integer.MAX_VALUE){</span>
<span class="nc" id="L3461">          Set&lt;Integer&gt; toremove = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L3462" title="All 2 branches missed.">          for(Integer i : patterns.keySet()){</span>
<span class="nc bnc" id="L3463" title="All 2 branches missed.">            if(i &gt;= numIterationsOfSavedPatternsToLoad){</span>
<span class="nc" id="L3464">              System.out.println(&quot;Removing patterns from iteration &quot; + i);</span>
<span class="nc" id="L3465">              toremove.add(i);</span>
            }
<span class="nc" id="L3467">          }</span>
<span class="nc bnc" id="L3468" title="All 2 branches missed.">          for(Integer i: toremove)</span>
<span class="nc" id="L3469">            patterns.remove(i);</span>
        }

<span class="nc" id="L3472">        Counter&lt;E&gt; pats = Counters.flatten(patterns);</span>
<span class="nc bnc" id="L3473" title="All 2 branches missed.">        for(E p : pats.keySet()){</span>
<span class="nc" id="L3474">          labelsForPattterns.put(p, label);</span>
<span class="nc" id="L3475">        }</span>

<span class="nc" id="L3477">        numIterationsLoadedModel = Math.max(numIterationsLoadedModel, patterns.size());</span>

<span class="nc" id="L3479">        model.setLearnedPatterns(pats, label);</span>
<span class="nc" id="L3480">        model.setLearnedPatternsEachIter(patterns, label);</span>
<span class="nc" id="L3481">        Redwood.log(Redwood.DBG, &quot;Loaded &quot; + model.getLearnedPatterns().get(label).size() + &quot; patterns from &quot; + patf);</span>
      }

      //Load Words
<span class="nc" id="L3485">      File wordf = new File(patternsWordsDir + &quot;/&quot; + label + &quot;/phrases.txt&quot;);</span>
<span class="nc bnc" id="L3486" title="All 2 branches missed.">      if (wordf.exists()) {</span>
<span class="nc" id="L3487">        TreeMap&lt;Integer, Counter&lt;CandidatePhrase&gt;&gt; words = GetPatternsFromDataMultiClass.readLearnedWordsFromFile(wordf);</span>
<span class="nc" id="L3488">        model.constVars.setLearnedWordsEachIter(words, label);</span>

<span class="nc bnc" id="L3490" title="All 2 branches missed.">        if(numIterationsOfSavedPatternsToLoad &lt; Integer.MAX_VALUE){</span>
<span class="nc" id="L3491">          Set&lt;Integer&gt; toremove = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L3492" title="All 2 branches missed.">          for(Integer i : words.keySet()){</span>
<span class="nc bnc" id="L3493" title="All 2 branches missed.">            if(i &gt;= numIterationsOfSavedPatternsToLoad){</span>
<span class="nc" id="L3494">              System.out.println(&quot;Removing patterns from iteration &quot; + i);</span>
<span class="nc" id="L3495">              toremove.add(i);</span>
            }
<span class="nc" id="L3497">          }</span>
<span class="nc bnc" id="L3498" title="All 2 branches missed.">          for(Integer i: toremove)</span>
<span class="nc" id="L3499">            words.remove(i);</span>
        }

<span class="nc" id="L3502">        numIterationsLoadedModel = Math.max(numIterationsLoadedModel, words.size());</span>

<span class="nc" id="L3504">        Redwood.log(Redwood.DBG, &quot;Loaded &quot; + words.size() + &quot; phrases from &quot; + wordf);</span>
      }


<span class="nc" id="L3508">      CollectionValuedMap&lt;E, Triple&lt;String, Integer, Integer&gt;&gt; matchedTokensByPat = new CollectionValuedMap&lt;&gt;();</span>

<span class="nc" id="L3510">      Iterator&lt;Pair&lt;Map&lt;String, DataInstance&gt;, File&gt;&gt; sentsIter = new ConstantsAndVariables.DataSentsIterator(model.constVars.batchProcessSents);</span>
<span class="nc" id="L3511">      TwoDimensionalCounter&lt;CandidatePhrase, E&gt; wordsandLemmaPatExtracted = new TwoDimensionalCounter&lt;&gt;();</span>
<span class="nc" id="L3512">      Set&lt;CandidatePhrase&gt; alreadyLabeledWords = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L3513" title="All 2 branches missed.">      while(sentsIter.hasNext()){</span>
<span class="nc" id="L3514">        Pair&lt;Map&lt;String, DataInstance&gt;, File&gt; sents = sentsIter.next();</span>
<span class="nc bnc" id="L3515" title="All 2 branches missed.">        if(labelSentsUsingModel){</span>
<span class="nc" id="L3516">          Redwood.log(Redwood.DBG, &quot;labeling sentences from &quot; + sents.second() + &quot; with the already learned words&quot;);</span>
<span class="nc bnc" id="L3517" title="All 4 branches missed.">          assert sents.first() != null : &quot;Why are sents null&quot;;</span>
<span class="nc" id="L3518">          model.labelWords(label, sents.first(), model.constVars.getLearnedWords(label).keySet(), sentsOutFile, matchedTokensByPat);</span>
<span class="nc bnc" id="L3519" title="All 2 branches missed.">          if(sents.second().exists())</span>
<span class="nc" id="L3520">            IOUtils.writeObjectToFile(sents, sents.second());</span>
        }
<span class="nc bnc" id="L3522" title="All 4 branches missed.">        if (model.constVars.restrictToMatched || applyPatsUsingModel) {</span>
<span class="nc" id="L3523">          Redwood.log(Redwood.DBG,&quot;Applying patterns to &quot; + sents.first().size() + &quot; sentences&quot;);</span>
<span class="nc" id="L3524">          model.constVars.invertedIndex.add(sents.first(), true);</span>
<span class="nc" id="L3525">          model.constVars.invertedIndex.add(sents.first(), true);</span>
<span class="nc" id="L3526">          model.scorePhrases.applyPats(model.getLearnedPatterns(label), label, wordsandLemmaPatExtracted, matchedTokensByPat, alreadyLabeledWords);</span>
        }
<span class="nc" id="L3528">      }</span>
<span class="nc" id="L3529">      Counters.addInPlace(model.wordsPatExtracted.get(label), wordsandLemmaPatExtracted);</span>


<span class="nc" id="L3532">      System.out.println(&quot;All Extracted phrases are &quot; + wordsandLemmaPatExtracted.firstKeySet());</span>

<span class="nc" id="L3534">    }</span>
<span class="nc" id="L3535">    System.out.flush();</span>
<span class="nc" id="L3536">    System.err.flush();</span>
<span class="nc" id="L3537">    return labelsForPattterns;</span>
  }

  private void setLearnedPatternsEachIter(Map&lt;Integer, Counter&lt;E&gt;&gt; patterns, String label) {
<span class="nc" id="L3541">     this.learnedPatternsEachIter.put(label, patterns);</span>
<span class="nc" id="L3542">  }</span>

  private static void readClassesInEnv(String s, Map&lt;String, Env&gt; env, Env globalEnv) throws ClassNotFoundException {

<span class="nc bnc" id="L3546" title="All 2 branches missed.">    for(String line: IOUtils.readLines(s)){</span>
<span class="nc" id="L3547">      String[] toks = line.split(&quot;###&quot;);</span>
<span class="nc bnc" id="L3548" title="All 2 branches missed.">      if(toks.length == 3){</span>
<span class="nc" id="L3549">        String label = toks[0];</span>
<span class="nc" id="L3550">        String name = toks[1];</span>
<span class="nc" id="L3551">        Class c = Class.forName(toks[2]);</span>
<span class="nc bnc" id="L3552" title="All 2 branches missed.">        if(!env.containsKey(label))</span>
<span class="nc" id="L3553">          env.put(label, TokenSequencePattern.getNewEnv());</span>
<span class="nc" id="L3554">        env.get(label).bind(name, c);</span>
<span class="nc" id="L3555">      }else</span>
<span class="nc bnc" id="L3556" title="All 2 branches missed.">      if(toks.length ==2){</span>
<span class="nc" id="L3557">        String name = toks[0];</span>
<span class="nc" id="L3558">        Class c = Class.forName(toks[1]);</span>
<span class="nc bnc" id="L3559" title="All 4 branches missed.">        assert c!=null : &quot; Why is name for &quot; + toks[1] + &quot; null&quot;;</span>
<span class="nc" id="L3560">        globalEnv.bind(name, c);</span>
<span class="nc" id="L3561">      }else</span>
<span class="nc" id="L3562">        throw new RuntimeException(&quot;Ill formed env file!&quot;);</span>
<span class="nc" id="L3563">    }</span>
<span class="nc" id="L3564">  }</span>

  private static void writeClassesInEnv(Map&lt;String, Env&gt; env, Env globalEnv, String file) throws IOException {
<span class="nc" id="L3567">    BufferedWriter w = new BufferedWriter(new FileWriter(file));</span>
<span class="nc bnc" id="L3568" title="All 2 branches missed.">    for(Entry&lt;String, Env&gt; en: env.entrySet()){</span>
<span class="nc bnc" id="L3569" title="All 2 branches missed.">      for(Entry&lt;String, Object&gt; en2: en.getValue().getVariables().entrySet()){</span>
<span class="nc bnc" id="L3570" title="All 2 branches missed.">        if(en2.getValue() instanceof Class)</span>
<span class="nc" id="L3571">          w.write(en.getKey()+&quot;###&quot;+en2.getKey()+&quot;###&quot;+((Class)en2.getValue()).getName()+&quot;\n&quot;);</span>
<span class="nc" id="L3572">      }</span>
<span class="nc" id="L3573">    }</span>
<span class="nc bnc" id="L3574" title="All 2 branches missed.">    for(Entry&lt;String, Object&gt; en2: globalEnv.getVariables().entrySet()){</span>
<span class="nc bnc" id="L3575" title="All 2 branches missed.">      if(en2.getValue() instanceof Class)</span>
<span class="nc" id="L3576">        w.write(en2.getKey()+&quot;###&quot;+ ((Class)en2.getValue()).getName()+&quot;\n&quot;);</span>
<span class="nc" id="L3577">    }</span>
<span class="nc" id="L3578">    w.close();</span>
<span class="nc" id="L3579">  }</span>

  public static String elapsedTime(Date d1, Date d2){
    try{
<span class="fc" id="L3583">    Interval interval = new Interval(d1.getTime(), d2.getTime());</span>
<span class="fc" id="L3584">    Period period = interval.toPeriod();</span>
<span class="fc" id="L3585">    return period.getDays() + &quot; days, &quot; + period.getHours()+&quot; hours, &quot; + period.getMinutes()  +&quot; minutes, &quot; +period.getSeconds()+&quot; seconds&quot;;</span>
<span class="nc" id="L3586">    } catch(java.lang.IllegalArgumentException e) {</span>
<span class="nc" id="L3587">      log.warn(e);</span>
    }
<span class="nc" id="L3589">    return &quot;&quot;;</span>
  }


  public static void main(String[] args) {
    try {
<span class="nc" id="L3595">      Properties props = StringUtils.argsToPropertiesWithResolve(args);</span>
<span class="nc" id="L3596">      GetPatternsFromDataMultiClass.&lt;SurfacePattern&gt;run(props);</span>
<span class="nc" id="L3597">    } catch (OutOfMemoryError e) {</span>
<span class="nc" id="L3598">      System.out.println(&quot;Out of memory! Either change the memory alloted by running as java -mx20g ... for example if you want to allocate 20G. Or consider using batchProcessSents and numMaxSentencesPerBatchFile flags&quot;);</span>
<span class="nc" id="L3599">      log.warn(e);</span>
<span class="nc" id="L3600">    } catch (Exception e) {</span>
<span class="nc" id="L3601">      log.warn(e);</span>
<span class="nc" id="L3602">    }</span>
<span class="nc" id="L3603">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>