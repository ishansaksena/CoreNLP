<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ConcatVectorTableProto.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.loglinear.model.proto</a> &gt; <span class="el_source">ConcatVectorTableProto.java</span></div><h1>ConcatVectorTableProto.java</h1><pre class="source lang-java linenums">// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ConcatVectorTable.proto

package edu.stanford.nlp.loglinear.model.proto;

import com.google.protobuf.CodedOutputStream;

public final class ConcatVectorTableProto {
<span class="nc" id="L9">  private ConcatVectorTableProto() {}</span>
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
<span class="nc" id="L12">  }</span>
  public interface ConcatVectorTableOrBuilder extends
      // @@protoc_insertion_point(interface_extends:edu.stanford.nlp.loglinear.model.proto.ConcatVectorTable)
      com.google.protobuf.MessageOrBuilder {

    /**
     * &lt;code&gt;repeated int32 dimensionSize = 1;&lt;/code&gt;
     */
    java.util.List&lt;java.lang.Integer&gt; getDimensionSizeList();
    /**
     * &lt;code&gt;repeated int32 dimensionSize = 1;&lt;/code&gt;
     */
    int getDimensionSizeCount();
    /**
     * &lt;code&gt;repeated int32 dimensionSize = 1;&lt;/code&gt;
     */
    int getDimensionSize(int index);

    /**
     * &lt;code&gt;repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;&lt;/code&gt;
     */
    java.util.List&lt;edu.stanford.nlp.loglinear.model.proto.ConcatVectorProto.ConcatVector&gt; 
        getFactorTableList();
    /**
     * &lt;code&gt;repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;&lt;/code&gt;
     */
    edu.stanford.nlp.loglinear.model.proto.ConcatVectorProto.ConcatVector getFactorTable(int index);
    /**
     * &lt;code&gt;repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;&lt;/code&gt;
     */
    int getFactorTableCount();
    /**
     * &lt;code&gt;repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;&lt;/code&gt;
     */
    java.util.List&lt;? extends edu.stanford.nlp.loglinear.model.proto.ConcatVectorProto.ConcatVectorOrBuilder&gt; 
        getFactorTableOrBuilderList();
    /**
     * &lt;code&gt;repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;&lt;/code&gt;
     */
    edu.stanford.nlp.loglinear.model.proto.ConcatVectorProto.ConcatVectorOrBuilder getFactorTableOrBuilder(
        int index);
  }
  /**
   * Protobuf type {@code edu.stanford.nlp.loglinear.model.proto.ConcatVectorTable}
   */
  public static final class ConcatVectorTable extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:edu.stanford.nlp.loglinear.model.proto.ConcatVectorTable)
      ConcatVectorTableOrBuilder {
    // Use ConcatVectorTable.newBuilder() to construct.
    private ConcatVectorTable(com.google.protobuf.GeneratedMessage.Builder&lt;?&gt; builder) {
<span class="fc" id="L63">      super(builder);</span>
<span class="fc" id="L64">      this.unknownFields = builder.getUnknownFields();</span>
<span class="fc" id="L65">    }</span>
<span class="fc" id="L66">    private ConcatVectorTable(boolean noInit) { this.unknownFields = com.google.protobuf.UnknownFieldSet.getDefaultInstance(); }</span>

    private static final ConcatVectorTable defaultInstance;
    public static ConcatVectorTable getDefaultInstance() {
<span class="fc" id="L70">      return defaultInstance;</span>
    }

    public ConcatVectorTable getDefaultInstanceForType() {
<span class="nc" id="L74">      return defaultInstance;</span>
    }

    private final com.google.protobuf.UnknownFieldSet unknownFields;
    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
        getUnknownFields() {
<span class="fc" id="L81">      return this.unknownFields;</span>
    }
    private ConcatVectorTable(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
<span class="fc" id="L86">        throws com.google.protobuf.InvalidProtocolBufferException {</span>
<span class="fc" id="L87">      initFields();</span>
<span class="fc" id="L88">      int mutable_bitField0_ = 0;</span>
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
<span class="fc" id="L90">          com.google.protobuf.UnknownFieldSet.newBuilder();</span>
      try {
<span class="fc" id="L92">        boolean done = false;</span>
<span class="fc bfc" id="L93" title="All 2 branches covered.">        while (!done) {</span>
<span class="fc" id="L94">          int tag = input.readTag();</span>
<span class="pc bpc" id="L95" title="2 of 5 branches missed.">          switch (tag) {</span>
            case 0:
<span class="fc" id="L97">              done = true;</span>
<span class="fc" id="L98">              break;</span>
            default: {
<span class="nc bnc" id="L100" title="All 2 branches missed.">              if (!parseUnknownField(input, unknownFields,</span>
                                     extensionRegistry, tag)) {
<span class="nc" id="L102">                done = true;</span>
              }
              break;
            }
            case 8: {
<span class="fc bfc" id="L107" title="All 2 branches covered.">              if (!((mutable_bitField0_ &amp; 0x00000001) == 0x00000001)) {</span>
<span class="fc" id="L108">                dimensionSize_ = new java.util.ArrayList&lt;&gt;();</span>
<span class="fc" id="L109">                mutable_bitField0_ |= 0x00000001;</span>
              }
<span class="fc" id="L111">              dimensionSize_.add(input.readInt32());</span>
<span class="fc" id="L112">              break;</span>
            }
            case 10: {
<span class="nc" id="L115">              int length = input.readRawVarint32();</span>
<span class="nc" id="L116">              int limit = input.pushLimit(length);</span>
<span class="nc bnc" id="L117" title="All 4 branches missed.">              if (!((mutable_bitField0_ &amp; 0x00000001) == 0x00000001) &amp;&amp; input.getBytesUntilLimit() &gt; 0) {</span>
<span class="nc" id="L118">                dimensionSize_ = new java.util.ArrayList&lt;&gt;();</span>
<span class="nc" id="L119">                mutable_bitField0_ |= 0x00000001;</span>
              }
<span class="nc bnc" id="L121" title="All 2 branches missed.">              while (input.getBytesUntilLimit() &gt; 0) {</span>
<span class="nc" id="L122">                dimensionSize_.add(input.readInt32());</span>
              }
<span class="nc" id="L124">              input.popLimit(limit);</span>
<span class="nc" id="L125">              break;</span>
            }
            case 18: {
<span class="fc bfc" id="L128" title="All 2 branches covered.">              if (!((mutable_bitField0_ &amp; 0x00000002) == 0x00000002)) {</span>
<span class="fc" id="L129">                factorTable_ = new java.util.ArrayList&lt;&gt;();</span>
<span class="fc" id="L130">                mutable_bitField0_ |= 0x00000002;</span>
              }
<span class="fc" id="L132">              factorTable_.add(input.readMessage(edu.stanford.nlp.loglinear.model.proto.ConcatVectorProto.ConcatVector.PARSER, extensionRegistry));</span>
              break;
            }
          }
<span class="fc" id="L136">        }</span>
<span class="nc" id="L137">      } catch (com.google.protobuf.InvalidProtocolBufferException e) {</span>
<span class="nc" id="L138">        throw e.setUnfinishedMessage(this);</span>
<span class="nc" id="L139">      } catch (java.io.IOException e) {</span>
<span class="nc" id="L140">        throw new com.google.protobuf.InvalidProtocolBufferException(</span>
<span class="nc" id="L141">            e.getMessage()).setUnfinishedMessage(this);</span>
      } finally {
<span class="pc bpc" id="L143" title="3 of 4 branches missed.">        if (((mutable_bitField0_ &amp; 0x00000001) == 0x00000001)) {</span>
<span class="pc" id="L144">          dimensionSize_ = java.util.Collections.unmodifiableList(dimensionSize_);</span>
        }
<span class="pc bpc" id="L146" title="3 of 4 branches missed.">        if (((mutable_bitField0_ &amp; 0x00000002) == 0x00000002)) {</span>
<span class="pc" id="L147">          factorTable_ = java.util.Collections.unmodifiableList(factorTable_);</span>
        }
<span class="pc" id="L149">        this.unknownFields = unknownFields.build();</span>
<span class="pc" id="L150">        makeExtensionsImmutable();</span>
<span class="fc" id="L151">      }</span>
<span class="fc" id="L152">    }</span>
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
<span class="nc" id="L155">      return edu.stanford.nlp.loglinear.model.proto.ConcatVectorTableProto.internal_static_edu_stanford_nlp_loglinear_model_proto_ConcatVectorTable_descriptor;</span>
    }

    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
<span class="nc" id="L160">      return edu.stanford.nlp.loglinear.model.proto.ConcatVectorTableProto.internal_static_edu_stanford_nlp_loglinear_model_proto_ConcatVectorTable_fieldAccessorTable</span>
<span class="nc" id="L161">          .ensureFieldAccessorsInitialized(</span>
              edu.stanford.nlp.loglinear.model.proto.ConcatVectorTableProto.ConcatVectorTable.class, edu.stanford.nlp.loglinear.model.proto.ConcatVectorTableProto.ConcatVectorTable.Builder.class);
    }

<span class="fc" id="L165">    public static com.google.protobuf.Parser&lt;ConcatVectorTable&gt; PARSER =</span>
<span class="fc" id="L166">        new com.google.protobuf.AbstractParser&lt;ConcatVectorTable&gt;() {</span>
      public ConcatVectorTable parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
<span class="fc" id="L171">        return new ConcatVectorTable(input, extensionRegistry);</span>
      }
    };

    @java.lang.Override
    public com.google.protobuf.Parser&lt;ConcatVectorTable&gt; getParserForType() {
<span class="nc" id="L177">      return PARSER;</span>
    }

    public static final int DIMENSIONSIZE_FIELD_NUMBER = 1;
    private java.util.List&lt;java.lang.Integer&gt; dimensionSize_;
    /**
     * &lt;code&gt;repeated int32 dimensionSize = 1;&lt;/code&gt;
     */
    public java.util.List&lt;java.lang.Integer&gt;
        getDimensionSizeList() {
<span class="fc" id="L187">      return dimensionSize_;</span>
    }
    /**
     * &lt;code&gt;repeated int32 dimensionSize = 1;&lt;/code&gt;
     */
    public int getDimensionSizeCount() {
<span class="fc" id="L193">      return dimensionSize_.size();</span>
    }
    /**
     * &lt;code&gt;repeated int32 dimensionSize = 1;&lt;/code&gt;
     */
    public int getDimensionSize(int index) {
<span class="fc" id="L199">      return dimensionSize_.get(index);</span>
    }

    public static final int FACTORTABLE_FIELD_NUMBER = 2;
    private java.util.List&lt;edu.stanford.nlp.loglinear.model.proto.ConcatVectorProto.ConcatVector&gt; factorTable_;
    /**
     * &lt;code&gt;repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;&lt;/code&gt;
     */
    public java.util.List&lt;edu.stanford.nlp.loglinear.model.proto.ConcatVectorProto.ConcatVector&gt; getFactorTableList() {
<span class="nc" id="L208">      return factorTable_;</span>
    }
    /**
     * &lt;code&gt;repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;&lt;/code&gt;
     */
    public java.util.List&lt;? extends edu.stanford.nlp.loglinear.model.proto.ConcatVectorProto.ConcatVectorOrBuilder&gt; 
        getFactorTableOrBuilderList() {
<span class="nc" id="L215">      return factorTable_;</span>
    }
    /**
     * &lt;code&gt;repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;&lt;/code&gt;
     */
    public int getFactorTableCount() {
<span class="fc" id="L221">      return factorTable_.size();</span>
    }
    /**
     * &lt;code&gt;repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;&lt;/code&gt;
     */
    public edu.stanford.nlp.loglinear.model.proto.ConcatVectorProto.ConcatVector getFactorTable(int index) {
<span class="fc" id="L227">      return factorTable_.get(index);</span>
    }
    /**
     * &lt;code&gt;repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;&lt;/code&gt;
     */
    public edu.stanford.nlp.loglinear.model.proto.ConcatVectorProto.ConcatVectorOrBuilder getFactorTableOrBuilder(
        int index) {
<span class="nc" id="L234">      return factorTable_.get(index);</span>
    }

    private void initFields() {
<span class="fc" id="L238">      dimensionSize_ = java.util.Collections.emptyList();</span>
<span class="fc" id="L239">      factorTable_ = java.util.Collections.emptyList();</span>
<span class="fc" id="L240">    }</span>
<span class="fc" id="L241">    private byte memoizedIsInitialized = -1;</span>
    public final boolean isInitialized() {
<span class="fc" id="L243">      byte isInitialized = memoizedIsInitialized;</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">      if (isInitialized == 1) return true;</span>
<span class="pc bpc" id="L245" title="1 of 2 branches missed.">      if (isInitialized == 0) return false;</span>

<span class="fc bfc" id="L247" title="All 2 branches covered.">      for (int i = 0; i &lt; getFactorTableCount(); i++) {</span>
<span class="pc bpc" id="L248" title="1 of 2 branches missed.">        if (!getFactorTable(i).isInitialized()) {</span>
<span class="nc" id="L249">          memoizedIsInitialized = 0;</span>
<span class="nc" id="L250">          return false;</span>
        }
      }
<span class="fc" id="L253">      memoizedIsInitialized = 1;</span>
<span class="fc" id="L254">      return true;</span>
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
<span class="fc" id="L259">      getSerializedSize();</span>
<span class="fc bfc" id="L260" title="All 2 branches covered.">      for (Integer aDimensionSize_ : dimensionSize_) {</span>
<span class="fc" id="L261">        output.writeInt32(1, aDimensionSize_);</span>
<span class="fc" id="L262">      }</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">      for (ConcatVectorProto.ConcatVector aFactorTable_ : factorTable_) {</span>
<span class="fc" id="L264">        output.writeMessage(2, aFactorTable_);</span>
<span class="fc" id="L265">      }</span>
<span class="fc" id="L266">      getUnknownFields().writeTo(output);</span>
<span class="fc" id="L267">    }</span>

<span class="fc" id="L269">    private int memoizedSerializedSize = -1;</span>
    public int getSerializedSize() {
<span class="fc" id="L271">      int size = memoizedSerializedSize;</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">      if (size != -1) return size;</span>

<span class="fc" id="L274">      size = 0;</span>
      {
<span class="fc" id="L276">        int dataSize = 0;</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">        for (Integer aDimensionSize_ : dimensionSize_) {</span>
<span class="fc" id="L278">          dataSize += CodedOutputStream</span>
<span class="fc" id="L279">                  .computeInt32SizeNoTag(aDimensionSize_);</span>
<span class="fc" id="L280">        }</span>
<span class="fc" id="L281">        size += dataSize;</span>
<span class="fc" id="L282">        size += 1 * getDimensionSizeList().size();</span>
      }
<span class="fc bfc" id="L284" title="All 2 branches covered.">      for (ConcatVectorProto.ConcatVector aFactorTable_ : factorTable_) {</span>
<span class="fc" id="L285">        size += CodedOutputStream</span>
<span class="fc" id="L286">                .computeMessageSize(2, aFactorTable_);</span>
<span class="fc" id="L287">      }</span>
<span class="fc" id="L288">      size += getUnknownFields().getSerializedSize();</span>
<span class="fc" id="L289">      memoizedSerializedSize = size;</span>
<span class="fc" id="L290">      return size;</span>
    }

    private static final long serialVersionUID = 0L;
    @java.lang.Override
    protected java.lang.Object writeReplace()
        throws java.io.ObjectStreamException {
<span class="nc" id="L297">      return super.writeReplace();</span>
    }

    public static edu.stanford.nlp.loglinear.model.proto.ConcatVectorTableProto.ConcatVectorTable parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
<span class="nc" id="L303">      return PARSER.parseFrom(data);</span>
    }
    public static edu.stanford.nlp.loglinear.model.proto.ConcatVectorTableProto.ConcatVectorTable parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
<span class="nc" id="L309">      return PARSER.parseFrom(data, extensionRegistry);</span>
    }
    public static edu.stanford.nlp.loglinear.model.proto.ConcatVectorTableProto.ConcatVectorTable parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
<span class="nc" id="L313">      return PARSER.parseFrom(data);</span>
    }
    public static edu.stanford.nlp.loglinear.model.proto.ConcatVectorTableProto.ConcatVectorTable parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
<span class="nc" id="L319">      return PARSER.parseFrom(data, extensionRegistry);</span>
    }
    public static edu.stanford.nlp.loglinear.model.proto.ConcatVectorTableProto.ConcatVectorTable parseFrom(java.io.InputStream input)
        throws java.io.IOException {
<span class="fc" id="L323">      return PARSER.parseFrom(input);</span>
    }
    public static edu.stanford.nlp.loglinear.model.proto.ConcatVectorTableProto.ConcatVectorTable parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
<span class="nc" id="L329">      return PARSER.parseFrom(input, extensionRegistry);</span>
    }
    public static edu.stanford.nlp.loglinear.model.proto.ConcatVectorTableProto.ConcatVectorTable parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
<span class="nc" id="L333">      return PARSER.parseDelimitedFrom(input);</span>
    }
    public static edu.stanford.nlp.loglinear.model.proto.ConcatVectorTableProto.ConcatVectorTable parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
<span class="nc" id="L339">      return PARSER.parseDelimitedFrom(input, extensionRegistry);</span>
    }
    public static edu.stanford.nlp.loglinear.model.proto.ConcatVectorTableProto.ConcatVectorTable parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
<span class="nc" id="L344">      return PARSER.parseFrom(input);</span>
    }
    public static edu.stanford.nlp.loglinear.model.proto.ConcatVectorTableProto.ConcatVectorTable parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
<span class="nc" id="L350">      return PARSER.parseFrom(input, extensionRegistry);</span>
    }

<span class="fc" id="L353">    public static Builder newBuilder() { return Builder.create(); }</span>
<span class="nc" id="L354">    public Builder newBuilderForType() { return newBuilder(); }</span>
    public static Builder newBuilder(edu.stanford.nlp.loglinear.model.proto.ConcatVectorTableProto.ConcatVectorTable prototype) {
<span class="nc" id="L356">      return newBuilder().mergeFrom(prototype);</span>
    }
<span class="nc" id="L358">    public Builder toBuilder() { return newBuilder(this); }</span>

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
<span class="nc" id="L363">      Builder builder = new Builder(parent);</span>
<span class="nc" id="L364">      return builder;</span>
    }
    /**
     * Protobuf type {@code edu.stanford.nlp.loglinear.model.proto.ConcatVectorTable}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder&lt;Builder&gt; implements
        // @@protoc_insertion_point(builder_implements:edu.stanford.nlp.loglinear.model.proto.ConcatVectorTable)
        edu.stanford.nlp.loglinear.model.proto.ConcatVectorTableProto.ConcatVectorTableOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
<span class="nc" id="L375">        return edu.stanford.nlp.loglinear.model.proto.ConcatVectorTableProto.internal_static_edu_stanford_nlp_loglinear_model_proto_ConcatVectorTable_descriptor;</span>
      }

      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
<span class="nc" id="L380">        return edu.stanford.nlp.loglinear.model.proto.ConcatVectorTableProto.internal_static_edu_stanford_nlp_loglinear_model_proto_ConcatVectorTable_fieldAccessorTable</span>
<span class="nc" id="L381">            .ensureFieldAccessorsInitialized(</span>
                edu.stanford.nlp.loglinear.model.proto.ConcatVectorTableProto.ConcatVectorTable.class, edu.stanford.nlp.loglinear.model.proto.ConcatVectorTableProto.ConcatVectorTable.Builder.class);
      }

      // Construct using edu.stanford.nlp.loglinear.model.proto.ConcatVectorTableProto.ConcatVectorTable.newBuilder()
<span class="fc" id="L386">      private Builder() {</span>
<span class="fc" id="L387">        maybeForceBuilderInitialization();</span>
<span class="fc" id="L388">      }</span>

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
<span class="nc" id="L392">        super(parent);</span>
<span class="nc" id="L393">        maybeForceBuilderInitialization();</span>
<span class="nc" id="L394">      }</span>
      private void maybeForceBuilderInitialization() {
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {</span>
<span class="nc" id="L397">          getFactorTableFieldBuilder();</span>
        }
<span class="fc" id="L399">      }</span>
      private static Builder create() {
<span class="fc" id="L401">        return new Builder();</span>
      }

      public Builder clear() {
<span class="nc" id="L405">        super.clear();</span>
<span class="nc" id="L406">        dimensionSize_ = java.util.Collections.emptyList();</span>
<span class="nc" id="L407">        bitField0_ = (bitField0_ &amp; ~0x00000001);</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">        if (factorTableBuilder_ == null) {</span>
<span class="nc" id="L409">          factorTable_ = java.util.Collections.emptyList();</span>
<span class="nc" id="L410">          bitField0_ = (bitField0_ &amp; ~0x00000002);</span>
        } else {
<span class="nc" id="L412">          factorTableBuilder_.clear();</span>
        }
<span class="nc" id="L414">        return this;</span>
      }

      public Builder clone() {
<span class="nc" id="L418">        return create().mergeFrom(buildPartial());</span>
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
<span class="nc" id="L423">        return edu.stanford.nlp.loglinear.model.proto.ConcatVectorTableProto.internal_static_edu_stanford_nlp_loglinear_model_proto_ConcatVectorTable_descriptor;</span>
      }

      public edu.stanford.nlp.loglinear.model.proto.ConcatVectorTableProto.ConcatVectorTable getDefaultInstanceForType() {
<span class="nc" id="L427">        return edu.stanford.nlp.loglinear.model.proto.ConcatVectorTableProto.ConcatVectorTable.getDefaultInstance();</span>
      }

      public edu.stanford.nlp.loglinear.model.proto.ConcatVectorTableProto.ConcatVectorTable build() {
<span class="fc" id="L431">        edu.stanford.nlp.loglinear.model.proto.ConcatVectorTableProto.ConcatVectorTable result = buildPartial();</span>
<span class="pc bpc" id="L432" title="1 of 2 branches missed.">        if (!result.isInitialized()) {</span>
<span class="nc" id="L433">          throw newUninitializedMessageException(result);</span>
        }
<span class="fc" id="L435">        return result;</span>
      }

      public edu.stanford.nlp.loglinear.model.proto.ConcatVectorTableProto.ConcatVectorTable buildPartial() {
<span class="fc" id="L439">        edu.stanford.nlp.loglinear.model.proto.ConcatVectorTableProto.ConcatVectorTable result = new edu.stanford.nlp.loglinear.model.proto.ConcatVectorTableProto.ConcatVectorTable(this);</span>
<span class="fc" id="L440">        int from_bitField0_ = bitField0_;</span>
<span class="pc bpc" id="L441" title="1 of 2 branches missed.">        if (((bitField0_ &amp; 0x00000001) == 0x00000001)) {</span>
<span class="fc" id="L442">          dimensionSize_ = java.util.Collections.unmodifiableList(dimensionSize_);</span>
<span class="fc" id="L443">          bitField0_ = (bitField0_ &amp; ~0x00000001);</span>
        }
<span class="fc" id="L445">        result.dimensionSize_ = dimensionSize_;</span>
<span class="pc bpc" id="L446" title="1 of 2 branches missed.">        if (factorTableBuilder_ == null) {</span>
<span class="pc bpc" id="L447" title="1 of 2 branches missed.">          if (((bitField0_ &amp; 0x00000002) == 0x00000002)) {</span>
<span class="fc" id="L448">            factorTable_ = java.util.Collections.unmodifiableList(factorTable_);</span>
<span class="fc" id="L449">            bitField0_ = (bitField0_ &amp; ~0x00000002);</span>
          }
<span class="fc" id="L451">          result.factorTable_ = factorTable_;</span>
        } else {
<span class="nc" id="L453">          result.factorTable_ = factorTableBuilder_.build();</span>
        }
<span class="fc" id="L455">        onBuilt();</span>
<span class="fc" id="L456">        return result;</span>
      }

      public Builder mergeFrom(com.google.protobuf.Message other) {
<span class="nc bnc" id="L460" title="All 2 branches missed.">        if (other instanceof edu.stanford.nlp.loglinear.model.proto.ConcatVectorTableProto.ConcatVectorTable) {</span>
<span class="nc" id="L461">          return mergeFrom((edu.stanford.nlp.loglinear.model.proto.ConcatVectorTableProto.ConcatVectorTable)other);</span>
        } else {
<span class="nc" id="L463">          super.mergeFrom(other);</span>
<span class="nc" id="L464">          return this;</span>
        }
      }

      public Builder mergeFrom(edu.stanford.nlp.loglinear.model.proto.ConcatVectorTableProto.ConcatVectorTable other) {
<span class="nc bnc" id="L469" title="All 2 branches missed.">        if (other == edu.stanford.nlp.loglinear.model.proto.ConcatVectorTableProto.ConcatVectorTable.getDefaultInstance()) return this;</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">        if (!other.dimensionSize_.isEmpty()) {</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">          if (dimensionSize_.isEmpty()) {</span>
<span class="nc" id="L472">            dimensionSize_ = other.dimensionSize_;</span>
<span class="nc" id="L473">            bitField0_ = (bitField0_ &amp; ~0x00000001);</span>
          } else {
<span class="nc" id="L475">            ensureDimensionSizeIsMutable();</span>
<span class="nc" id="L476">            dimensionSize_.addAll(other.dimensionSize_);</span>
          }
<span class="nc" id="L478">          onChanged();</span>
        }
<span class="nc bnc" id="L480" title="All 2 branches missed.">        if (factorTableBuilder_ == null) {</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">          if (!other.factorTable_.isEmpty()) {</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">            if (factorTable_.isEmpty()) {</span>
<span class="nc" id="L483">              factorTable_ = other.factorTable_;</span>
<span class="nc" id="L484">              bitField0_ = (bitField0_ &amp; ~0x00000002);</span>
            } else {
<span class="nc" id="L486">              ensureFactorTableIsMutable();</span>
<span class="nc" id="L487">              factorTable_.addAll(other.factorTable_);</span>
            }
<span class="nc" id="L489">            onChanged();</span>
          }
        } else {
<span class="nc bnc" id="L492" title="All 2 branches missed.">          if (!other.factorTable_.isEmpty()) {</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">            if (factorTableBuilder_.isEmpty()) {</span>
<span class="nc" id="L494">              factorTableBuilder_.dispose();</span>
<span class="nc" id="L495">              factorTableBuilder_ = null;</span>
<span class="nc" id="L496">              factorTable_ = other.factorTable_;</span>
<span class="nc" id="L497">              bitField0_ = (bitField0_ &amp; ~0x00000002);</span>
<span class="nc" id="L498">              factorTableBuilder_ = </span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?</span>
<span class="nc" id="L500">                   getFactorTableFieldBuilder() : null;</span>
            } else {
<span class="nc" id="L502">              factorTableBuilder_.addAllMessages(other.factorTable_);</span>
            }
          }
        }
<span class="nc" id="L506">        this.mergeUnknownFields(other.getUnknownFields());</span>
<span class="nc" id="L507">        return this;</span>
      }

      public final boolean isInitialized() {
<span class="nc bnc" id="L511" title="All 2 branches missed.">        for (int i = 0; i &lt; getFactorTableCount(); i++) {</span>
<span class="nc bnc" id="L512" title="All 2 branches missed.">          if (!getFactorTable(i).isInitialized()) {</span>
            
<span class="nc" id="L514">            return false;</span>
          }
        }
<span class="nc" id="L517">        return true;</span>
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
<span class="nc" id="L524">        edu.stanford.nlp.loglinear.model.proto.ConcatVectorTableProto.ConcatVectorTable parsedMessage = null;</span>
        try {
<span class="nc" id="L526">          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);</span>
<span class="nc" id="L527">        } catch (com.google.protobuf.InvalidProtocolBufferException e) {</span>
<span class="nc" id="L528">          parsedMessage = (edu.stanford.nlp.loglinear.model.proto.ConcatVectorTableProto.ConcatVectorTable) e.getUnfinishedMessage();</span>
<span class="nc" id="L529">          throw e;</span>
        } finally {
<span class="nc bnc" id="L531" title="All 4 branches missed.">          if (parsedMessage != null) {</span>
<span class="nc" id="L532">            mergeFrom(parsedMessage);</span>
          }
        }
<span class="nc" id="L535">        return this;</span>
      }
      private int bitField0_;

<span class="pc" id="L539">      private java.util.List&lt;java.lang.Integer&gt; dimensionSize_ = java.util.Collections.emptyList();</span>
      private void ensureDimensionSizeIsMutable() {
<span class="fc bfc" id="L541" title="All 2 branches covered.">        if (!((bitField0_ &amp; 0x00000001) == 0x00000001)) {</span>
<span class="fc" id="L542">          dimensionSize_ = new java.util.ArrayList&lt;&gt;(dimensionSize_);</span>
<span class="fc" id="L543">          bitField0_ |= 0x00000001;</span>
         }
<span class="fc" id="L545">      }</span>
      /**
       * &lt;code&gt;repeated int32 dimensionSize = 1;&lt;/code&gt;
       */
      public java.util.List&lt;java.lang.Integer&gt;
          getDimensionSizeList() {
<span class="nc" id="L551">        return java.util.Collections.unmodifiableList(dimensionSize_);</span>
      }
      /**
       * &lt;code&gt;repeated int32 dimensionSize = 1;&lt;/code&gt;
       */
      public int getDimensionSizeCount() {
<span class="nc" id="L557">        return dimensionSize_.size();</span>
      }
      /**
       * &lt;code&gt;repeated int32 dimensionSize = 1;&lt;/code&gt;
       */
      public int getDimensionSize(int index) {
<span class="nc" id="L563">        return dimensionSize_.get(index);</span>
      }
      /**
       * &lt;code&gt;repeated int32 dimensionSize = 1;&lt;/code&gt;
       */
      public Builder setDimensionSize(
          int index, int value) {
<span class="nc" id="L570">        ensureDimensionSizeIsMutable();</span>
<span class="nc" id="L571">        dimensionSize_.set(index, value);</span>
<span class="nc" id="L572">        onChanged();</span>
<span class="nc" id="L573">        return this;</span>
      }
      /**
       * &lt;code&gt;repeated int32 dimensionSize = 1;&lt;/code&gt;
       */
      public Builder addDimensionSize(int value) {
<span class="fc" id="L579">        ensureDimensionSizeIsMutable();</span>
<span class="fc" id="L580">        dimensionSize_.add(value);</span>
<span class="fc" id="L581">        onChanged();</span>
<span class="fc" id="L582">        return this;</span>
      }
      /**
       * &lt;code&gt;repeated int32 dimensionSize = 1;&lt;/code&gt;
       */
      public Builder addAllDimensionSize(
          java.lang.Iterable&lt;? extends java.lang.Integer&gt; values) {
<span class="nc" id="L589">        ensureDimensionSizeIsMutable();</span>
<span class="nc" id="L590">        com.google.protobuf.AbstractMessageLite.Builder.addAll(</span>
            values, dimensionSize_);
<span class="nc" id="L592">        onChanged();</span>
<span class="nc" id="L593">        return this;</span>
      }
      /**
       * &lt;code&gt;repeated int32 dimensionSize = 1;&lt;/code&gt;
       */
      public Builder clearDimensionSize() {
<span class="nc" id="L599">        dimensionSize_ = java.util.Collections.emptyList();</span>
<span class="nc" id="L600">        bitField0_ = (bitField0_ &amp; ~0x00000001);</span>
<span class="nc" id="L601">        onChanged();</span>
<span class="nc" id="L602">        return this;</span>
      }

<span class="pc" id="L605">      private java.util.List&lt;edu.stanford.nlp.loglinear.model.proto.ConcatVectorProto.ConcatVector&gt; factorTable_ =</span>
<span class="pc" id="L606">        java.util.Collections.emptyList();</span>
      private void ensureFactorTableIsMutable() {
<span class="fc bfc" id="L608" title="All 2 branches covered.">        if (!((bitField0_ &amp; 0x00000002) == 0x00000002)) {</span>
<span class="fc" id="L609">          factorTable_ = new java.util.ArrayList&lt;&gt;(factorTable_);</span>
<span class="fc" id="L610">          bitField0_ |= 0x00000002;</span>
         }
<span class="fc" id="L612">      }</span>

      private com.google.protobuf.RepeatedFieldBuilder&lt;
          edu.stanford.nlp.loglinear.model.proto.ConcatVectorProto.ConcatVector, edu.stanford.nlp.loglinear.model.proto.ConcatVectorProto.ConcatVector.Builder, edu.stanford.nlp.loglinear.model.proto.ConcatVectorProto.ConcatVectorOrBuilder&gt; factorTableBuilder_;

      /**
       * &lt;code&gt;repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;&lt;/code&gt;
       */
      public java.util.List&lt;edu.stanford.nlp.loglinear.model.proto.ConcatVectorProto.ConcatVector&gt; getFactorTableList() {
<span class="nc bnc" id="L621" title="All 2 branches missed.">        if (factorTableBuilder_ == null) {</span>
<span class="nc" id="L622">          return java.util.Collections.unmodifiableList(factorTable_);</span>
        } else {
<span class="nc" id="L624">          return factorTableBuilder_.getMessageList();</span>
        }
      }
      /**
       * &lt;code&gt;repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;&lt;/code&gt;
       */
      public int getFactorTableCount() {
<span class="nc bnc" id="L631" title="All 2 branches missed.">        if (factorTableBuilder_ == null) {</span>
<span class="nc" id="L632">          return factorTable_.size();</span>
        } else {
<span class="nc" id="L634">          return factorTableBuilder_.getCount();</span>
        }
      }
      /**
       * &lt;code&gt;repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;&lt;/code&gt;
       */
      public edu.stanford.nlp.loglinear.model.proto.ConcatVectorProto.ConcatVector getFactorTable(int index) {
<span class="nc bnc" id="L641" title="All 2 branches missed.">        if (factorTableBuilder_ == null) {</span>
<span class="nc" id="L642">          return factorTable_.get(index);</span>
        } else {
<span class="nc" id="L644">          return factorTableBuilder_.getMessage(index);</span>
        }
      }
      /**
       * &lt;code&gt;repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;&lt;/code&gt;
       */
      public Builder setFactorTable(
          int index, edu.stanford.nlp.loglinear.model.proto.ConcatVectorProto.ConcatVector value) {
<span class="nc bnc" id="L652" title="All 2 branches missed.">        if (factorTableBuilder_ == null) {</span>
<span class="nc bnc" id="L653" title="All 2 branches missed.">          if (value == null) {</span>
<span class="nc" id="L654">            throw new NullPointerException();</span>
          }
<span class="nc" id="L656">          ensureFactorTableIsMutable();</span>
<span class="nc" id="L657">          factorTable_.set(index, value);</span>
<span class="nc" id="L658">          onChanged();</span>
        } else {
<span class="nc" id="L660">          factorTableBuilder_.setMessage(index, value);</span>
        }
<span class="nc" id="L662">        return this;</span>
      }
      /**
       * &lt;code&gt;repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;&lt;/code&gt;
       */
      public Builder setFactorTable(
          int index, edu.stanford.nlp.loglinear.model.proto.ConcatVectorProto.ConcatVector.Builder builderForValue) {
<span class="nc bnc" id="L669" title="All 2 branches missed.">        if (factorTableBuilder_ == null) {</span>
<span class="nc" id="L670">          ensureFactorTableIsMutable();</span>
<span class="nc" id="L671">          factorTable_.set(index, builderForValue.build());</span>
<span class="nc" id="L672">          onChanged();</span>
        } else {
<span class="nc" id="L674">          factorTableBuilder_.setMessage(index, builderForValue.build());</span>
        }
<span class="nc" id="L676">        return this;</span>
      }
      /**
       * &lt;code&gt;repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;&lt;/code&gt;
       */
      public Builder addFactorTable(edu.stanford.nlp.loglinear.model.proto.ConcatVectorProto.ConcatVector value) {
<span class="nc bnc" id="L682" title="All 2 branches missed.">        if (factorTableBuilder_ == null) {</span>
<span class="nc bnc" id="L683" title="All 2 branches missed.">          if (value == null) {</span>
<span class="nc" id="L684">            throw new NullPointerException();</span>
          }
<span class="nc" id="L686">          ensureFactorTableIsMutable();</span>
<span class="nc" id="L687">          factorTable_.add(value);</span>
<span class="nc" id="L688">          onChanged();</span>
        } else {
<span class="nc" id="L690">          factorTableBuilder_.addMessage(value);</span>
        }
<span class="nc" id="L692">        return this;</span>
      }
      /**
       * &lt;code&gt;repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;&lt;/code&gt;
       */
      public Builder addFactorTable(
          int index, edu.stanford.nlp.loglinear.model.proto.ConcatVectorProto.ConcatVector value) {
<span class="nc bnc" id="L699" title="All 2 branches missed.">        if (factorTableBuilder_ == null) {</span>
<span class="nc bnc" id="L700" title="All 2 branches missed.">          if (value == null) {</span>
<span class="nc" id="L701">            throw new NullPointerException();</span>
          }
<span class="nc" id="L703">          ensureFactorTableIsMutable();</span>
<span class="nc" id="L704">          factorTable_.add(index, value);</span>
<span class="nc" id="L705">          onChanged();</span>
        } else {
<span class="nc" id="L707">          factorTableBuilder_.addMessage(index, value);</span>
        }
<span class="nc" id="L709">        return this;</span>
      }
      /**
       * &lt;code&gt;repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;&lt;/code&gt;
       */
      public Builder addFactorTable(
          edu.stanford.nlp.loglinear.model.proto.ConcatVectorProto.ConcatVector.Builder builderForValue) {
<span class="pc bpc" id="L716" title="1 of 2 branches missed.">        if (factorTableBuilder_ == null) {</span>
<span class="fc" id="L717">          ensureFactorTableIsMutable();</span>
<span class="fc" id="L718">          factorTable_.add(builderForValue.build());</span>
<span class="fc" id="L719">          onChanged();</span>
        } else {
<span class="nc" id="L721">          factorTableBuilder_.addMessage(builderForValue.build());</span>
        }
<span class="fc" id="L723">        return this;</span>
      }
      /**
       * &lt;code&gt;repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;&lt;/code&gt;
       */
      public Builder addFactorTable(
          int index, edu.stanford.nlp.loglinear.model.proto.ConcatVectorProto.ConcatVector.Builder builderForValue) {
<span class="nc bnc" id="L730" title="All 2 branches missed.">        if (factorTableBuilder_ == null) {</span>
<span class="nc" id="L731">          ensureFactorTableIsMutable();</span>
<span class="nc" id="L732">          factorTable_.add(index, builderForValue.build());</span>
<span class="nc" id="L733">          onChanged();</span>
        } else {
<span class="nc" id="L735">          factorTableBuilder_.addMessage(index, builderForValue.build());</span>
        }
<span class="nc" id="L737">        return this;</span>
      }
      /**
       * &lt;code&gt;repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;&lt;/code&gt;
       */
      public Builder addAllFactorTable(
          java.lang.Iterable&lt;? extends edu.stanford.nlp.loglinear.model.proto.ConcatVectorProto.ConcatVector&gt; values) {
<span class="nc bnc" id="L744" title="All 2 branches missed.">        if (factorTableBuilder_ == null) {</span>
<span class="nc" id="L745">          ensureFactorTableIsMutable();</span>
<span class="nc" id="L746">          com.google.protobuf.AbstractMessageLite.Builder.addAll(</span>
              values, factorTable_);
<span class="nc" id="L748">          onChanged();</span>
        } else {
<span class="nc" id="L750">          factorTableBuilder_.addAllMessages(values);</span>
        }
<span class="nc" id="L752">        return this;</span>
      }
      /**
       * &lt;code&gt;repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;&lt;/code&gt;
       */
      public Builder clearFactorTable() {
<span class="nc bnc" id="L758" title="All 2 branches missed.">        if (factorTableBuilder_ == null) {</span>
<span class="nc" id="L759">          factorTable_ = java.util.Collections.emptyList();</span>
<span class="nc" id="L760">          bitField0_ = (bitField0_ &amp; ~0x00000002);</span>
<span class="nc" id="L761">          onChanged();</span>
        } else {
<span class="nc" id="L763">          factorTableBuilder_.clear();</span>
        }
<span class="nc" id="L765">        return this;</span>
      }
      /**
       * &lt;code&gt;repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;&lt;/code&gt;
       */
      public Builder removeFactorTable(int index) {
<span class="nc bnc" id="L771" title="All 2 branches missed.">        if (factorTableBuilder_ == null) {</span>
<span class="nc" id="L772">          ensureFactorTableIsMutable();</span>
<span class="nc" id="L773">          factorTable_.remove(index);</span>
<span class="nc" id="L774">          onChanged();</span>
        } else {
<span class="nc" id="L776">          factorTableBuilder_.remove(index);</span>
        }
<span class="nc" id="L778">        return this;</span>
      }
      /**
       * &lt;code&gt;repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;&lt;/code&gt;
       */
      public edu.stanford.nlp.loglinear.model.proto.ConcatVectorProto.ConcatVector.Builder getFactorTableBuilder(
          int index) {
<span class="nc" id="L785">        return getFactorTableFieldBuilder().getBuilder(index);</span>
      }
      /**
       * &lt;code&gt;repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;&lt;/code&gt;
       */
      public edu.stanford.nlp.loglinear.model.proto.ConcatVectorProto.ConcatVectorOrBuilder getFactorTableOrBuilder(
          int index) {
<span class="nc bnc" id="L792" title="All 2 branches missed.">        if (factorTableBuilder_ == null) {</span>
<span class="nc" id="L793">          return factorTable_.get(index);  } else {</span>
<span class="nc" id="L794">          return factorTableBuilder_.getMessageOrBuilder(index);</span>
        }
      }
      /**
       * &lt;code&gt;repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;&lt;/code&gt;
       */
      public java.util.List&lt;? extends edu.stanford.nlp.loglinear.model.proto.ConcatVectorProto.ConcatVectorOrBuilder&gt; 
           getFactorTableOrBuilderList() {
<span class="nc bnc" id="L802" title="All 2 branches missed.">        if (factorTableBuilder_ != null) {</span>
<span class="nc" id="L803">          return factorTableBuilder_.getMessageOrBuilderList();</span>
        } else {
<span class="nc" id="L805">          return java.util.Collections.unmodifiableList(factorTable_);</span>
        }
      }
      /**
       * &lt;code&gt;repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;&lt;/code&gt;
       */
      public edu.stanford.nlp.loglinear.model.proto.ConcatVectorProto.ConcatVector.Builder addFactorTableBuilder() {
<span class="nc" id="L812">        return getFactorTableFieldBuilder().addBuilder(</span>
<span class="nc" id="L813">            edu.stanford.nlp.loglinear.model.proto.ConcatVectorProto.ConcatVector.getDefaultInstance());</span>
      }
      /**
       * &lt;code&gt;repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;&lt;/code&gt;
       */
      public edu.stanford.nlp.loglinear.model.proto.ConcatVectorProto.ConcatVector.Builder addFactorTableBuilder(
          int index) {
<span class="nc" id="L820">        return getFactorTableFieldBuilder().addBuilder(</span>
<span class="nc" id="L821">            index, edu.stanford.nlp.loglinear.model.proto.ConcatVectorProto.ConcatVector.getDefaultInstance());</span>
      }
      /**
       * &lt;code&gt;repeated .edu.stanford.nlp.loglinear.model.proto.ConcatVector factorTable = 2;&lt;/code&gt;
       */
      public java.util.List&lt;edu.stanford.nlp.loglinear.model.proto.ConcatVectorProto.ConcatVector.Builder&gt; 
           getFactorTableBuilderList() {
<span class="nc" id="L828">        return getFactorTableFieldBuilder().getBuilderList();</span>
      }
      private com.google.protobuf.RepeatedFieldBuilder&lt;
          edu.stanford.nlp.loglinear.model.proto.ConcatVectorProto.ConcatVector, edu.stanford.nlp.loglinear.model.proto.ConcatVectorProto.ConcatVector.Builder, edu.stanford.nlp.loglinear.model.proto.ConcatVectorProto.ConcatVectorOrBuilder&gt; 
          getFactorTableFieldBuilder() {
<span class="nc bnc" id="L833" title="All 2 branches missed.">        if (factorTableBuilder_ == null) {</span>
<span class="nc bnc" id="L834" title="All 2 branches missed.">          factorTableBuilder_ = new com.google.protobuf.RepeatedFieldBuilder&lt;&gt;(</span>
                  factorTable_,
                  ((bitField0_ &amp; 0x00000002) == 0x00000002),
<span class="nc" id="L837">                  getParentForChildren(),</span>
<span class="nc" id="L838">                  isClean());</span>
<span class="nc" id="L839">          factorTable_ = null;</span>
        }
<span class="nc" id="L841">        return factorTableBuilder_;</span>
      }

      // @@protoc_insertion_point(builder_scope:edu.stanford.nlp.loglinear.model.proto.ConcatVectorTable)
    }

    static {
<span class="fc" id="L848">      defaultInstance = new ConcatVectorTable(true);</span>
<span class="fc" id="L849">      defaultInstance.initFields();</span>
<span class="fc" id="L850">    }</span>

    // @@protoc_insertion_point(class_scope:edu.stanford.nlp.loglinear.model.proto.ConcatVectorTable)
  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_edu_stanford_nlp_loglinear_model_proto_ConcatVectorTable_descriptor;
  private static
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_edu_stanford_nlp_loglinear_model_proto_ConcatVectorTable_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
<span class="nc" id="L863">    return descriptor;</span>
  }
  private static com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
<span class="nc" id="L868">    java.lang.String[] descriptorData = {</span>
      &quot;\n\027ConcatVectorTable.proto\022&amp;edu.stanford.&quot; +
      &quot;nlp.loglinear.model.proto\032\022ConcatVector.&quot; +
      &quot;proto\&quot;u\n\021ConcatVectorTable\022\025\n\rdimensionS&quot; +
      &quot;ize\030\001 \003(\005\022I\n\013factorTable\030\002 \003(\01324.edu.sta&quot; +
      &quot;nford.nlp.loglinear.model.proto.ConcatVe&quot; +
      &quot;ctorB@\n&amp;edu.stanford.nlp.loglinear.model&quot; +
      &quot;.protoB\026ConcatVectorTableProto&quot;
    };
<span class="nc" id="L877">    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =</span>
<span class="nc" id="L878">        new com.google.protobuf.Descriptors.FileDescriptor.    InternalDescriptorAssigner() {</span>
          public com.google.protobuf.ExtensionRegistry assignDescriptors(
              com.google.protobuf.Descriptors.FileDescriptor root) {
<span class="nc" id="L881">            descriptor = root;</span>
<span class="nc" id="L882">            return null;</span>
          }
        };
<span class="nc" id="L885">    com.google.protobuf.Descriptors.FileDescriptor</span>
<span class="nc" id="L886">      .internalBuildGeneratedFileFrom(descriptorData,</span>
        new com.google.protobuf.Descriptors.FileDescriptor[] {
<span class="nc" id="L888">          edu.stanford.nlp.loglinear.model.proto.ConcatVectorProto.getDescriptor(),</span>
        }, assigner);
    internal_static_edu_stanford_nlp_loglinear_model_proto_ConcatVectorTable_descriptor =
<span class="nc" id="L891">      getDescriptor().getMessageTypes().get(0);</span>
<span class="nc" id="L892">    internal_static_edu_stanford_nlp_loglinear_model_proto_ConcatVectorTable_fieldAccessorTable = new</span>
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_edu_stanford_nlp_loglinear_model_proto_ConcatVectorTable_descriptor,
        new java.lang.String[] { &quot;DimensionSize&quot;, &quot;FactorTable&quot;, });
<span class="nc" id="L896">    edu.stanford.nlp.loglinear.model.proto.ConcatVectorProto.getDescriptor();</span>
<span class="nc" id="L897">  }</span>

  // @@protoc_insertion_point(outer_class_scope)
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>