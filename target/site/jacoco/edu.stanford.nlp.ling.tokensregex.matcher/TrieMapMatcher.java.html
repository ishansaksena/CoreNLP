<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TrieMapMatcher.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.ling.tokensregex.matcher</a> &gt; <span class="el_source">TrieMapMatcher.java</span></div><h1>TrieMapMatcher.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.ling.tokensregex.matcher;

import edu.stanford.nlp.util.*;

import java.util.*;
import java.util.function.Function;

/**
 * The &lt;code&gt;TrieMapMatcher&lt;/code&gt; provides functions to match against a trie.
 * It can be used to:
 * - Find matches in a document (findAllMatches and findNonOverlapping)
 * - Find approximate matches in a document (findClosestMatches)
 * - Segment a sequence based on entries in the trie (segment)
 *
 * TODO: Have TrieMapMatcher implement a matcher interface
 *
 * @author Angel Chang
 */
public class TrieMapMatcher&lt;K,V&gt; {
  TrieMap&lt;K,V&gt; root;
  TrieMap&lt;K,V&gt; rootWithDelimiter;
  List&lt;K&gt; multimatchDelimiter;

<span class="fc" id="L24">  public TrieMapMatcher(TrieMap&lt;K, V&gt; root) {</span>
<span class="fc" id="L25">    this.root = root;</span>
<span class="fc" id="L26">    this.rootWithDelimiter = root;</span>
<span class="fc" id="L27">  }</span>

<span class="nc" id="L29">  public TrieMapMatcher(TrieMap&lt;K, V&gt; root, List&lt;K&gt; multimatchDelimiter) {</span>
<span class="nc" id="L30">    this.root = root;</span>
<span class="nc" id="L31">    this.multimatchDelimiter = multimatchDelimiter;</span>
<span class="nc bnc" id="L32" title="All 4 branches missed.">    if (multimatchDelimiter != null &amp;&amp; !multimatchDelimiter.isEmpty()) {</span>
      // Create a new root that always starts with the delimiter
<span class="nc" id="L34">      rootWithDelimiter = new TrieMap&lt;&gt;();</span>
<span class="nc" id="L35">      rootWithDelimiter.putChildTrie(multimatchDelimiter, root);</span>
    } else {
<span class="nc" id="L37">      rootWithDelimiter = root;</span>
    }
<span class="nc" id="L39">  }</span>

  /**
   * Given a target sequence, returns the n closes matches (or sequences of matches) from the trie.
   * The cost function used is a exact match cost function (exact match has cost 0, otherwise, cost is 1)
   * @param target Target sequence to match
   * @param n Number of matches to return. The actual number of matches may be less.
   * @return List of approximate matches
   */
  public List&lt;ApproxMatch&lt;K,V&gt;&gt; findClosestMatches(K[] target, int n) {
<span class="fc" id="L49">    return findClosestMatches(Arrays.asList(target), n);</span>
  }

  /**
   * Given a target sequence, returns the n closes matches (or sequences of matches) from the trie.
   * The cost function used is a exact match cost function (exact match has cost 0, otherwise, cost is 1)
   * @param target Target sequence to match
   * @param n Number of matches to return. The actual number of matches may be less.
   * @param multimatch If true, attempt to return matches with sequences of elements from the trie.
   *                   Otherwise, only each match will contain one element from the trie.
   * @param keepAlignments If true, alignment information is returned
   * @return List of approximate matches
   */
  public List&lt;ApproxMatch&lt;K,V&gt;&gt; findClosestMatches(K[] target, int n, boolean multimatch, boolean keepAlignments) {
<span class="fc" id="L63">    return findClosestMatches(Arrays.asList(target), n, multimatch, keepAlignments);</span>
  }

  /**
   * Given a target sequence, returns the n closes matches (or sequences of matches) from the trie
   *  based on the cost function (lower cost mean better match).
   * @param target Target sequence to match
   * @param costFunction Cost function to use
   * @param maxCost Matches with a cost higher than this are discarded
   * @param n Number of matches to return. The actual number of matches may be less.
   * @param multimatch If true, attempt to return matches with sequences of elements from the trie.
   *                   Otherwise, only each match will contain one element from the trie.
   * @param keepAlignments If true, alignment information is returned
   * @return List of approximate matches
   */
  public List&lt;ApproxMatch&lt;K,V&gt;&gt; findClosestMatches(K[] target, MatchCostFunction&lt;K,V&gt; costFunction,
                                                   Double maxCost, int n, boolean multimatch, boolean keepAlignments) {
<span class="nc" id="L80">    return findClosestMatches(Arrays.asList(target), costFunction, maxCost, n, multimatch, keepAlignments);</span>
  }

  /**
   * Given a target sequence, returns the n closes matches (or sequences of matches) from the trie.
   * The cost function used is a exact match cost function (exact match has cost 0, otherwise, cost is 1)
   * @param target Target sequence to match
   * @param n Number of matches to return. The actual number of matches may be less.
   * @return List of approximate matches
   */
  public List&lt;ApproxMatch&lt;K,V&gt;&gt; findClosestMatches(List&lt;K&gt; target, int n) {
<span class="fc" id="L91">    return findClosestMatches(target, TrieMapMatcher.&lt;K,V&gt;defaultCost(), Double.MAX_VALUE, n, false, false);</span>
  }

  /**
   * Given a target sequence, returns the n closes matches (or sequences of matches) from the trie.
   * The cost function used is a exact match cost function (exact match has cost 0, otherwise, cost is 1)
   * @param target Target sequence to match
   * @param n Number of matches to return. The actual number of matches may be less.
   * @param multimatch If true, attempt to return matches with sequences of elements from the trie.
   *                   Otherwise, only each match will contain one element from the trie.
   * @param keepAlignments If true, alignment information is returned
   * @return List of approximate matches
   */
  public List&lt;ApproxMatch&lt;K,V&gt;&gt; findClosestMatches(List&lt;K&gt; target, int n, boolean multimatch, boolean keepAlignments) {
<span class="fc" id="L105">    return findClosestMatches(target, TrieMapMatcher.&lt;K,V&gt;defaultCost(), Double.MAX_VALUE, n, multimatch, keepAlignments);</span>
  }

  /**
   * Given a target sequence, returns the n closes matches (or sequences of matches) from the trie
   *  based on the cost function (lower cost mean better match).
   * @param target Target sequence to match
   * @param costFunction Cost function to use
   * @param maxCost Matches with a cost higher than this are discarded
   * @param n Number of matches to return. The actual number of matches may be less.
   * @param multimatch If true, attempt to return matches with sequences of elements from the trie.
   *                   Otherwise, only each match will contain one element from the trie.
   * @param keepAlignments If true, alignment information is returned
   * @return List of approximate matches
   */
  public List&lt;ApproxMatch&lt;K,V&gt;&gt; findClosestMatches(List&lt;K&gt; target, MatchCostFunction&lt;K,V&gt; costFunction,
                                                   double maxCost, int n, boolean multimatch, boolean keepAlignments) {
<span class="pc bpc" id="L122" title="1 of 2 branches missed.">    if (root.isEmpty()) return null;</span>
<span class="fc" id="L123">    int extra = 3;</span>
    // Find the closest n options to the key in the trie based on the given cost function for substitution
    // matches[i][j] stores the top n partial matches for i elements from the target
    //   and j elements from the partial matches from trie keys

    // At any time, we only keep track of the last two rows
    // (prevMatches (matches[i-1][j]), curMatches (matches[i][j]) that we are working on
<span class="fc" id="L130">    MatchQueue&lt;K,V&gt; best = new MatchQueue&lt;&gt;(n, maxCost);</span>
<span class="fc" id="L131">    List&lt;PartialApproxMatch&lt;K,V&gt;&gt;[] prevMatches = null;</span>
    List&lt;PartialApproxMatch&lt;K,V&gt;&gt;[] curMatches;
<span class="fc bfc" id="L133" title="All 2 branches covered.">    for (int i = 0; i &lt;= target.size(); i++) {</span>
<span class="fc" id="L134">      curMatches = new List[target.size()+1+extra];</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">      for (int j = 0; j &lt;= target.size()+extra; j++) {</span>
<span class="fc bfc" id="L136" title="All 2 branches covered.">        if (j &gt; 0) {</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">          boolean complete = (i == target.size());</span>
          // Try to pick best match from trie
<span class="pc bpc" id="L139" title="1 of 4 branches missed.">          K t = (i &gt; 0 &amp;&amp; i &lt;= target.size())? target.get(i-1):null;</span>
          // Look at the top n choices we saved away and pick n new options
<span class="fc bfc" id="L141" title="All 2 branches covered.">          MatchQueue&lt;K,V&gt; queue = (multimatch)? new MultiMatchQueue&lt;&gt;(n, maxCost): new MatchQueue&lt;&gt;(n, maxCost);</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">          if (i &gt; 0) {</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">            for (PartialApproxMatch&lt;K,V&gt; pam:prevMatches[j-1]) {</span>
<span class="pc bpc" id="L144" title="1 of 2 branches missed.">              if (pam.trie != null) {</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">                if (pam.trie.children != null) {</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">                  for (K k:pam.trie.children.keySet()) {</span>
<span class="fc" id="L147">                    addToQueue(queue, best, costFunction, pam, t, k, multimatch, complete);</span>
<span class="fc" id="L148">                  }</span>
                }
              }
<span class="fc" id="L151">            }</span>
          }
<span class="fc bfc" id="L153" title="All 2 branches covered.">          for (PartialApproxMatch&lt;K,V&gt; pam:curMatches[j-1]) {</span>
<span class="pc bpc" id="L154" title="1 of 2 branches missed.">            if (pam.trie != null) {</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">              if (pam.trie.children != null) {</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">                for (K k:pam.trie.children.keySet()) {</span>
<span class="fc" id="L157">                  addToQueue(queue, best, costFunction, pam, null, k, multimatch, complete);</span>
<span class="fc" id="L158">                }</span>
              }
            }
<span class="fc" id="L161">          }</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">          if (i &gt; 0) {</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">            for (PartialApproxMatch&lt;K,V&gt; pam:prevMatches[j]) {</span>
<span class="fc" id="L164">              addToQueue(queue, best, costFunction, pam, t, null, multimatch, complete);</span>
<span class="fc" id="L165">            }</span>
          }
<span class="fc" id="L167">          curMatches[j] = queue.toSortedList();</span>
<span class="fc" id="L168">        } else {</span>
<span class="fc" id="L169">          curMatches[0] = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">          if (i &gt; 0) {</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">            K t = (i &lt; target.size())? target.get(i-1):null;</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">            for (PartialApproxMatch&lt;K,V&gt; pam:prevMatches[0]) {</span>
<span class="fc" id="L173">              PartialApproxMatch&lt;K,V&gt; npam = pam.withMatch(costFunction, costFunction.cost(t, null, pam.getMatchedLength()), t, null);</span>
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">              if (npam.cost &lt;= maxCost) {</span>
<span class="fc" id="L175">                curMatches[0].add(npam);</span>
              }
<span class="fc" id="L177">            }</span>
<span class="fc" id="L178">          } else {</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">            curMatches[0].add(new PartialApproxMatch&lt;&gt;(0, root, keepAlignments ? target.size() : 0));</span>
          }
        }
//        System.out.println(&quot;i=&quot; + i + &quot;,j=&quot; + j + &quot;,&quot; + matches[i][j]);
      }
<span class="fc" id="L184">      prevMatches = curMatches;</span>
    }
    // Get the best matches
<span class="fc" id="L187">    List&lt;ApproxMatch&lt;K,V&gt;&gt; res = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">    for (PartialApproxMatch&lt;K,V&gt; m:best.toSortedList()) {</span>
<span class="fc" id="L189">      res.add(m.toApproxMatch());</span>
<span class="fc" id="L190">    }</span>
<span class="fc" id="L191">    return res;</span>
  }

  /**
   * Given a sequence to search through (e.g. piece of text would be a sequence of words),
   * finds all matching sub-sequences that matches entries in the trie
   * @param list Sequence to search through
   * @return List of matches
   */
  public List&lt;Match&lt;K,V&gt;&gt; findAllMatches(K ... list) {
<span class="fc" id="L201">    return findAllMatches(Arrays.asList(list));</span>
  }

  /**
   * Given a sequence to search through (e.g. piece of text would be a sequence of words),
   * finds all matching sub-sequences that matches entries in the trie
   * @param list Sequence to search through
   * @return List of matches
   */
  public List&lt;Match&lt;K,V&gt;&gt; findAllMatches(List&lt;K&gt; list) {
<span class="fc" id="L211">    return findAllMatches(list, 0, list.size());</span>
  }

  /**
   * Given a sequence to search through (e.g. piece of text would be a sequence of words),
   * finds all matching sub-sequences that matches entries in the trie
   * @param list Sequence to search through
   * @param start start index to start search at
   * @param end end index (exclusive) to end search at
   * @return List of matches
   */
  public List&lt;Match&lt;K,V&gt;&gt; findAllMatches(List&lt;K&gt; list, int start, int end) {
<span class="fc" id="L223">    List&lt;Match&lt;K,V&gt;&gt; allMatches = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L224">    updateAllMatches(root, allMatches, new ArrayList&lt;&gt;(), list, start, end);</span>
<span class="fc" id="L225">    return allMatches;</span>
  }

  /**
   * Given a sequence to search through (e.g. piece of text would be a sequence of words),
   * finds all non-overlapping matching sub-sequences that matches entries in the trie.
   * Sub-sequences that are longer are preferred, then sub-sequences that starts earlier.
   * @param list Sequence to search through
   * @return List of matches sorted by start position
   */
  public List&lt;Match&lt;K,V&gt;&gt; findNonOverlapping(K ... list) {
<span class="fc" id="L236">    return findNonOverlapping(Arrays.asList(list));</span>
  }

  /**
   * Given a sequence to search through (e.g. piece of text would be a sequence of words),
   * finds all non-overlapping matching sub-sequences that matches entries in the trie.
   * Sub-sequences that are longer are preferred, then sub-sequences that starts earlier.
   * @param list Sequence to search through
   * @return List of matches sorted by start position
   */
  public List&lt;Match&lt;K,V&gt;&gt; findNonOverlapping(List&lt;K&gt; list) {
<span class="fc" id="L247">    return findNonOverlapping(list, 0, list.size());</span>
  }

<span class="fc" id="L250">  public final static Comparator&lt;Match&gt; MATCH_LENGTH_ENDPOINTS_COMPARATOR = Interval.&lt;Match&gt;lengthEndpointsComparator();</span>
<span class="fc" id="L251">  public final static Function&lt;Match, Double&gt; MATCH_LENGTH_SCORER = Interval.&lt;Match&gt;lengthScorer();</span>

  /**
   * Given a sequence to search through (e.g. piece of text would be a sequence of words),
   * finds all non-overlapping matching sub-sequences that matches entries in the trie.
   * Sub-sequences that are longer are preferred, then sub-sequences that starts earlier.
   * @param list Sequence to search through
   * @param start start index to start search at
   * @param end end index (exclusive) to end search at
   * @return List of matches sorted by start position
   */
  public List&lt;Match&lt;K,V&gt;&gt; findNonOverlapping(List&lt;K&gt; list, int start, int end) {
<span class="fc" id="L263">    return findNonOverlapping(list, start, end, MATCH_LENGTH_ENDPOINTS_COMPARATOR);</span>
  }

  /**
   * Given a sequence to search through (e.g. piece of text would be a sequence of words),
   * finds all non-overlapping matching sub-sequences that matches entries in the trie.
   * @param list Sequence to search through
   * @param start start index to start search at
   * @param end end index (exclusive) to end search at
   * @param compareFunc Comparison function to use for evaluating which overlapping sub-sequence to keep.
   *                    Earlier sub-sequences based on the comparison function are favored.
   * @return List of matches sorted by start position
   */
  public List&lt;Match&lt;K,V&gt;&gt; findNonOverlapping(List&lt;K&gt; list, int start, int end, Comparator&lt;? super Match&lt;K,V&gt;&gt; compareFunc) {
<span class="fc" id="L277">    List&lt;Match&lt;K,V&gt;&gt; allMatches = findAllMatches(list, start, end);</span>
<span class="fc" id="L278">    return getNonOverlapping(allMatches, compareFunc);</span>
  }

  /**
   * Given a sequence to search through (e.g. piece of text would be a sequence of words),
   * finds all non-overlapping matching sub-sequences that matches entries in the trie while attempting to maximize the scoreFunc.
   * @param list Sequence to search through
   * @param start start index to start search at
   * @param end end index (exclusive) to end search at
   * @param scoreFunc Scoring function indicating how good the match is
   * @return List of matches sorted by start position
   */
  public List&lt;Match&lt;K,V&gt;&gt; findNonOverlapping(List&lt;K&gt; list, int start, int end, Function&lt;? super Match&lt;K,V&gt;, Double&gt; scoreFunc) {
<span class="fc" id="L291">    List&lt;Match&lt;K,V&gt;&gt; allMatches = findAllMatches(list, start, end);</span>
<span class="fc" id="L292">    return getNonOverlapping(allMatches, scoreFunc);</span>
  }

  /**
   * Segment a sequence into sequence of sub-sequences by attempting to find the longest non-overlapping
   *  sub-sequences.  Non-matched parts will be included as a match with a null value.
   * @param list Sequence to search through
   * @return List of segments (as matches) sorted by start position
   */
  public List&lt;Match&lt;K,V&gt;&gt; segment(K ... list) {
<span class="fc" id="L302">    return segment(Arrays.asList(list));</span>
  }

  /**
   * Segment a sequence into sequence of sub-sequences by attempting to find the longest non-overlapping
   *  sub-sequences.  Non-matched parts will be included as a match with a null value.
   * @param list Sequence to search through
   * @return List of segments (as matches) sorted by start position
   */
  public List&lt;Match&lt;K,V&gt;&gt; segment(List&lt;K&gt; list) {
<span class="fc" id="L312">    return segment(list, 0, list.size());</span>
  }

  /**
   * Segment a sequence into sequence of sub-sequences by attempting to find the longest non-overlapping
   *  sub-sequences.  Non-matched parts will be included as a match with a null value.
   * @param list Sequence to search through
   * @param start start index to start search at
   * @param end end index (exclusive) to end search at
   * @return List of segments (as matches) sorted by start position
   */
  public List&lt;Match&lt;K,V&gt;&gt; segment(List&lt;K&gt; list, int start, int end) {
<span class="fc" id="L324">    return segment(list, start, end, MATCH_LENGTH_SCORER);</span>
  }

  /**
   * Segment a sequence into sequence of sub-sequences by attempting to find the non-overlapping
   *  sub-sequences that comes earlier using the compareFunc.
   * Non-matched parts will be included as a match with a null value.
   * @param list Sequence to search through
   * @param start start index to start search at
   * @param end end index (exclusive) to end search at
   * @param compareFunc Comparison function to use for evaluating which overlapping sub-sequence to keep.
   *                    Earlier sub-sequences based on the comparison function are favored.
   * @return List of segments (as matches) sorted by start position
   */
  public List&lt;Match&lt;K,V&gt;&gt; segment(List&lt;K&gt; list, int start, int end, Comparator&lt;? super Match&lt;K,V&gt;&gt; compareFunc) {
<span class="nc" id="L339">    List&lt;Match&lt;K,V&gt;&gt; nonOverlapping = findNonOverlapping(list, start, end, compareFunc);</span>
<span class="nc" id="L340">    List&lt;Match&lt;K,V&gt;&gt; segments = new ArrayList&lt;&gt;(nonOverlapping.size());</span>
<span class="nc" id="L341">    int last = 0;</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">    for (Match&lt;K,V&gt; match:nonOverlapping) {</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">      if (match.begin &gt; last) {</span>
        // Create empty match and add to segments
<span class="nc" id="L345">        Match&lt;K,V&gt; empty = new Match&lt;&gt;(list.subList(last, match.begin), null, last, match.begin);</span>
<span class="nc" id="L346">        segments.add(empty);</span>
      }
<span class="nc" id="L348">      segments.add(match);</span>
<span class="nc" id="L349">      last = match.end;</span>
<span class="nc" id="L350">    }</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">    if (list.size() &gt; last) {</span>
<span class="nc" id="L352">      Match&lt;K,V&gt; empty = new Match&lt;&gt;(list.subList(last, list.size()), null, last, list.size());</span>
<span class="nc" id="L353">      segments.add(empty);</span>
    }
<span class="nc" id="L355">    return segments;</span>
  }

  /**
   * Segment a sequence into sequence of sub-sequences by attempting to maximize the total score
   * Non-matched parts will be included as a match with a null value.
   * @param list Sequence to search through
   * @param start start index to start search at
   * @param end end index (exclusive) to end search at
   * @param scoreFunc Scoring function indicating how good the match is
   * @return List of segments (as matches) sorted by start position
   */
  public List&lt;Match&lt;K,V&gt;&gt; segment(List&lt;K&gt; list, int start, int end, Function&lt;? super Match&lt;K,V&gt;, Double&gt; scoreFunc) {
<span class="fc" id="L368">    List&lt;Match&lt;K,V&gt;&gt; nonOverlapping = findNonOverlapping(list, start, end, scoreFunc);</span>
<span class="fc" id="L369">    List&lt;Match&lt;K,V&gt;&gt; segments = new ArrayList&lt;&gt;(nonOverlapping.size());</span>
<span class="fc" id="L370">    int last = 0;</span>
<span class="fc bfc" id="L371" title="All 2 branches covered.">    for (Match&lt;K,V&gt; match:nonOverlapping) {</span>
<span class="fc bfc" id="L372" title="All 2 branches covered.">      if (match.begin &gt; last) {</span>
        // Create empty match and add to segments
<span class="fc" id="L374">        Match&lt;K,V&gt; empty = new Match&lt;&gt;(list.subList(last, match.begin), null, last, match.begin);</span>
<span class="fc" id="L375">        segments.add(empty);</span>
      }
<span class="fc" id="L377">      segments.add(match);</span>
<span class="fc" id="L378">      last = match.end;</span>
<span class="fc" id="L379">    }</span>
<span class="pc bpc" id="L380" title="1 of 2 branches missed.">    if (list.size() &gt; last) {</span>
<span class="nc" id="L381">      Match&lt;K,V&gt; empty = new Match&lt;&gt;(list.subList(last, list.size()), null, last, list.size());</span>
<span class="nc" id="L382">      segments.add(empty);</span>
    }
<span class="fc" id="L384">    return segments;</span>
  }

  public List&lt;Match&lt;K,V&gt;&gt; segment(List&lt;K&gt; list, Function&lt;? super Match&lt;K,V&gt;, Double&gt; scoreFunc) {
<span class="nc" id="L388">    return segment(list, 0, list.size(), scoreFunc);</span>
  }

  /**
   * Given a list of matches, returns all non-overlapping matches.
   * Matches that are longer are preferred, then matches that starts earlier.
   * @param allMatches List of matches
   * @return List of matches sorted by start position
   */
  public List&lt;Match&lt;K,V&gt;&gt; getNonOverlapping(List&lt;Match&lt;K,V&gt;&gt; allMatches) {
<span class="nc" id="L398">    return getNonOverlapping(allMatches, MATCH_LENGTH_ENDPOINTS_COMPARATOR);</span>
  }

  /**
   * Given a list of matches, returns all non-overlapping matches.
   * @param allMatches List of matches
   * @param compareFunc Comparison function to use for evaluating which overlapping sub-sequence to keep.
   *                    Earlier sub-sequences based on the comparison function are favored.
   * @return List of matches sorted by start position
   */
  public List&lt;Match&lt;K,V&gt;&gt; getNonOverlapping(List&lt;Match&lt;K,V&gt;&gt; allMatches, Comparator&lt;? super Match&lt;K,V&gt;&gt; compareFunc) {
<span class="pc bpc" id="L409" title="1 of 2 branches missed.">    if (allMatches.size() &gt; 1) {</span>
<span class="fc" id="L410">      List&lt;Match&lt;K,V&gt;&gt; nonOverlapping = IntervalTree.getNonOverlapping(allMatches, compareFunc);</span>
<span class="fc" id="L411">      Collections.sort(nonOverlapping, HasInterval.ENDPOINTS_COMPARATOR);</span>
<span class="fc" id="L412">      return nonOverlapping;</span>
    } else {
<span class="nc" id="L414">      return allMatches;</span>
    }
  }

  public List&lt;Match&lt;K,V&gt;&gt; getNonOverlapping(List&lt;Match&lt;K,V&gt;&gt; allMatches, Function&lt;? super Match&lt;K,V&gt;, Double&gt; scoreFunc) {
<span class="fc" id="L419">    return IntervalTree.getNonOverlappingMaxScore(allMatches, scoreFunc);</span>
  }

  protected void updateAllMatches(TrieMap&lt;K,V&gt; trie, List&lt;Match&lt;K,V&gt;&gt; matches, List&lt;K&gt; matched, List&lt;K&gt; list, int start, int end) {
<span class="fc bfc" id="L423" title="All 2 branches covered.">    for (int i = start; i &lt; end; i++) {</span>
<span class="fc" id="L424">      updateAllMatchesWithStart(trie, matches, matched, list, i, end);</span>
    }
<span class="fc" id="L426">  }</span>
  protected void updateAllMatchesWithStart(TrieMap&lt;K,V&gt; trie, List&lt;Match&lt;K,V&gt;&gt; matches, List&lt;K&gt; matched, List&lt;K&gt; list, int start, int end) {
<span class="pc bpc" id="L428" title="1 of 2 branches missed.">    if (start &gt; end) return;</span>
<span class="pc bpc" id="L429" title="1 of 4 branches missed.">    if (trie.children != null &amp;&amp; start &lt; end) {</span>
<span class="fc" id="L430">      K key = list.get(start);</span>
<span class="fc" id="L431">      TrieMap&lt;K,V&gt; child = trie.children.get(key);</span>
<span class="fc bfc" id="L432" title="All 2 branches covered.">      if (child != null) {</span>
<span class="fc" id="L433">        List&lt;K&gt; p = new ArrayList&lt;&gt;(matched.size() + 1);</span>
<span class="fc" id="L434">        p.addAll(matched);</span>
<span class="fc" id="L435">        p.add(key);</span>
<span class="fc" id="L436">        updateAllMatchesWithStart(child, matches, p, list, start + 1, end);</span>
      }
    }
<span class="fc bfc" id="L439" title="All 2 branches covered.">    if (trie.isLeaf()) {</span>
<span class="fc" id="L440">      matches.add(new Match&lt;&gt;(matched, trie.value, start - matched.size(), start));</span>
    }
<span class="fc" id="L442">  }</span>

  // Helper class for keeping track of partial matches with TrieMatcher
  private static class PartialApproxMatch&lt;K,V&gt; extends ApproxMatch&lt;K,V&gt; {
    TrieMap&lt;K,V&gt; trie;
<span class="fc" id="L447">    int lastMultimatchedMatchedStartIndex = 0;</span>
<span class="fc" id="L448">    int lastMultimatchedOriginalStartIndex = 0;</span>

<span class="fc" id="L450">    private PartialApproxMatch() {}</span>

<span class="fc" id="L452">    private PartialApproxMatch(double cost, TrieMap&lt;K,V&gt; trie, int alignmentLength) {</span>
<span class="fc" id="L453">      this.trie = trie;</span>
<span class="fc" id="L454">      this.cost = cost;</span>
<span class="pc bpc" id="L455" title="1 of 2 branches missed.">      this.value = (trie != null)? this.trie.value:null;</span>
<span class="fc bfc" id="L456" title="All 2 branches covered.">      if (alignmentLength &gt; 0) {</span>
<span class="fc" id="L457">        this.alignments = new Interval[alignmentLength];</span>
      }
<span class="fc" id="L459">    }</span>

    private PartialApproxMatch&lt;K,V&gt; withMatch(MatchCostFunction&lt;K,V&gt; costFunction, double deltaCost, K t, K k) {
<span class="fc" id="L462">      PartialApproxMatch&lt;K,V&gt; res = new PartialApproxMatch&lt;&gt;();</span>
<span class="fc" id="L463">      res.matched = matched;</span>
<span class="fc bfc" id="L464" title="All 2 branches covered.">      if (k != null) {</span>
<span class="fc bfc" id="L465" title="All 2 branches covered.">        if (res.matched == null) {</span>
<span class="fc" id="L466">          res.matched = new ArrayList&lt;&gt;(1);</span>
        } else {
<span class="fc" id="L468">          res.matched = new ArrayList&lt;&gt;(matched.size() + 1);</span>
<span class="fc" id="L469">          res.matched.addAll(matched);</span>
        }
<span class="fc" id="L471">        res.matched.add(k);</span>
      }
<span class="fc" id="L473">      res.begin = begin;</span>
<span class="fc bfc" id="L474" title="All 2 branches covered.">      res.end = (t != null)? end + 1: end;</span>
<span class="fc" id="L475">      res.cost = cost + deltaCost;</span>
<span class="fc bfc" id="L476" title="All 2 branches covered.">      res.trie = (k != null)? trie.getChildTrie(k):trie;</span>
<span class="pc bpc" id="L477" title="1 of 2 branches missed.">      res.value = (res.trie != null)? res.trie.value:null;</span>
<span class="fc" id="L478">      res.multimatches = multimatches;</span>
<span class="fc" id="L479">      res.lastMultimatchedMatchedStartIndex = lastMultimatchedMatchedStartIndex;</span>
<span class="fc" id="L480">      res.lastMultimatchedOriginalStartIndex = lastMultimatchedOriginalStartIndex;</span>
<span class="fc bfc" id="L481" title="All 6 branches covered.">      if (res.lastMultimatchedOriginalStartIndex == end  &amp;&amp; k == null &amp;&amp; t != null) {</span>
<span class="fc" id="L482">        res.lastMultimatchedOriginalStartIndex++;</span>
      }
      // Update alignments
<span class="fc bfc" id="L485" title="All 2 branches covered.">      if (alignments != null) {</span>
<span class="fc" id="L486">        res.alignments = new Interval[alignments.length];</span>
<span class="fc" id="L487">        System.arraycopy(alignments, 0, res.alignments, 0, alignments.length);</span>
<span class="fc bfc" id="L488" title="All 4 branches covered.">        if (k != null &amp;&amp; res.end &gt; 0) {</span>
<span class="fc" id="L489">          int p = res.end-1;</span>
<span class="fc bfc" id="L490" title="All 2 branches covered.">          if (res.alignments[p] == null) {</span>
<span class="fc" id="L491">            res.alignments[p] = Interval.toInterval(res.matched.size()-1, res.matched.size());</span>
          } else {
<span class="fc" id="L493">            res.alignments[p] = Interval.toInterval(res.alignments[p].getBegin(), res.alignments[p].getEnd() + 1);</span>
          }
        }
      }
<span class="fc" id="L497">      return res;</span>
    }

    private ApproxMatch&lt;K,V&gt; toApproxMatch() {
      // Makes a copy of this partial approx match that can be returned to the caller
<span class="fc" id="L502">      return new ApproxMatch&lt;&gt;(matched, value, begin, end, multimatches, cost, alignments);</span>
    }

    private PartialApproxMatch&lt;K,V&gt; withMatch(MatchCostFunction&lt;K,V&gt; costFunction, double deltaCost,
                                              K t, K k, boolean multimatch, TrieMap&lt;K,V&gt; root) {
<span class="fc" id="L507">      PartialApproxMatch&lt;K,V&gt; res = withMatch(costFunction, deltaCost, t, k);</span>
<span class="pc bpc" id="L508" title="3 of 6 branches missed.">      if (multimatch &amp;&amp; res.matched != null &amp;&amp; res.value != null) {</span>
        // Update tracking of matched keys and values for multiple entry matches
<span class="fc bfc" id="L510" title="All 2 branches covered.">        if (res.multimatches == null) {</span>
<span class="fc" id="L511">          res.multimatches = new ArrayList&lt;&gt;(1);</span>
        } else {
<span class="fc" id="L513">          res.multimatches = new ArrayList&lt;&gt;(multimatches.size() + 1);</span>
<span class="fc" id="L514">          res.multimatches.addAll(multimatches);</span>
        }
<span class="fc" id="L516">        List&lt;K&gt; newlyMatched = res.matched.subList(lastMultimatchedMatchedStartIndex, res.matched.size());</span>
<span class="fc" id="L517">        res.multimatches.add(new Match&lt;&gt;(</span>
                newlyMatched,
                res.value,
                lastMultimatchedOriginalStartIndex, res.end
        ));
<span class="fc" id="L522">        res.cost += costFunction.multiMatchDeltaCost(newlyMatched, res.value, multimatches, res.multimatches);</span>
<span class="fc" id="L523">        res.lastMultimatchedMatchedStartIndex = res.matched.size();</span>
<span class="fc" id="L524">        res.lastMultimatchedOriginalStartIndex = res.end;</span>
        // Reset current value/key being matched
<span class="fc" id="L526">        res.trie = root;</span>
      }
<span class="fc" id="L528">      return res;</span>
    }

    @Override
    public boolean equals(Object o) {
<span class="nc bnc" id="L533" title="All 2 branches missed.">      if (this == o) return true;</span>
<span class="nc bnc" id="L534" title="All 4 branches missed.">      if (o == null || getClass() != o.getClass()) return false;</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">      if (!super.equals(o)) return false;</span>

<span class="nc" id="L537">      PartialApproxMatch that = (PartialApproxMatch) o;</span>

<span class="nc bnc" id="L539" title="All 2 branches missed.">      if (lastMultimatchedMatchedStartIndex != that.lastMultimatchedMatchedStartIndex) return false;</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">      if (lastMultimatchedOriginalStartIndex != that.lastMultimatchedOriginalStartIndex) return false;</span>
<span class="nc bnc" id="L541" title="All 6 branches missed.">      if (trie != null ? !trie.equals(that.trie) : that.trie != null) return false;</span>

<span class="nc" id="L543">      return true;</span>
    }

    @Override
    public int hashCode() {
<span class="nc" id="L548">      int result = super.hashCode();</span>
<span class="nc" id="L549">      result = 31 * result + lastMultimatchedMatchedStartIndex;</span>
<span class="nc" id="L550">      result = 31 * result + lastMultimatchedOriginalStartIndex;</span>
<span class="nc" id="L551">      return result;</span>
    }
  }

  private static class MatchQueue&lt;K,V&gt; {
    private final BoundedCostOrderedMap&lt;Match&lt;K,V&gt;, PartialApproxMatch&lt;K,V&gt;&gt; queue;
    protected final int maxSize;
    protected final double maxCost;

<span class="fc" id="L560">    public final Function&lt;PartialApproxMatch&lt;K,V&gt;, Double&gt; MATCH_COST_FUNCTION = in -&gt; in.cost;</span>

<span class="fc" id="L562">    public MatchQueue(int maxSize, double maxCost) {</span>
<span class="fc" id="L563">      this.maxSize = maxSize;</span>
<span class="fc" id="L564">      this.maxCost = maxCost;</span>
<span class="fc" id="L565">      this.queue = new BoundedCostOrderedMap&lt;&gt;(MATCH_COST_FUNCTION, maxSize, maxCost);</span>
<span class="fc" id="L566">    }</span>

    public void add(PartialApproxMatch&lt;K,V&gt; pam) {
<span class="fc" id="L569">      List&lt;Match&lt;K,V&gt;&gt; multiMatchesWithoutOffsets = null;</span>
<span class="fc bfc" id="L570" title="All 2 branches covered.">      if (pam.multimatches != null) {</span>
<span class="fc" id="L571">        multiMatchesWithoutOffsets = new ArrayList&lt;&gt;(pam.multimatches.size());</span>
<span class="fc bfc" id="L572" title="All 2 branches covered.">        for (Match&lt;K,V&gt; m:pam.multimatches) {</span>
<span class="fc" id="L573">          multiMatchesWithoutOffsets.add(new Match&lt;&gt;(m.matched, m.value, 0, 0));</span>
<span class="fc" id="L574">        }</span>
      }
<span class="fc" id="L576">      Match&lt;K,V&gt; m = new MultiMatch&lt;&gt;(pam.matched, pam.value, pam.begin, pam.end, multiMatchesWithoutOffsets);</span>
<span class="fc" id="L577">      queue.put(m, pam);</span>
<span class="fc" id="L578">    }</span>

<span class="fc" id="L580">    public double topCost() { return queue.topCost(); }</span>

<span class="fc" id="L582">    public int size() { return queue.size(); }</span>

<span class="nc" id="L584">    public boolean isEmpty() { return queue.isEmpty(); }</span>

    public List&lt;PartialApproxMatch&lt;K,V&gt;&gt; toSortedList() {
<span class="fc" id="L587">      List&lt;PartialApproxMatch&lt;K,V&gt;&gt; res = queue.valuesList();</span>
<span class="fc" id="L588">      Collections.sort(res, TrieMapMatcher.&lt;K,V&gt;partialMatchComparator());</span>
<span class="fc" id="L589">      return res;</span>
    }
  }

  private static class MultiMatchQueue&lt;K,V&gt; extends MatchQueue&lt;K,V&gt; {
    private final Map&lt;Integer, BoundedCostOrderedMap&lt;Match&lt;K,V&gt;, PartialApproxMatch&lt;K,V&gt;&gt;&gt; multimatchQueues;

    public MultiMatchQueue(int maxSize, double maxCost) {
<span class="fc" id="L597">      super(maxSize, maxCost);</span>
<span class="fc" id="L598">      this.multimatchQueues = new HashMap&lt;&gt;();</span>
<span class="fc" id="L599">    }</span>

    public void add(PartialApproxMatch&lt;K,V&gt; pam) {
<span class="fc" id="L602">      Match&lt;K,V&gt; m = new MultiMatch&lt;&gt;(</span>
              pam.matched, pam.value, pam.begin, pam.end, pam.multimatches);
<span class="fc bfc" id="L604" title="All 2 branches covered.">      Integer key = (pam.multimatches != null)? pam.multimatches.size():0;</span>
<span class="fc bfc" id="L605" title="All 2 branches covered.">      if (pam.value == null) key = key + 1;</span>
<span class="fc" id="L606">      BoundedCostOrderedMap&lt;Match&lt;K,V&gt;, PartialApproxMatch&lt;K,V&gt;&gt; mq = multimatchQueues.get(key);</span>
<span class="fc bfc" id="L607" title="All 2 branches covered.">      if (mq == null) {</span>
<span class="fc" id="L608">        multimatchQueues.put(key, mq = new BoundedCostOrderedMap&lt;&gt;(</span>
                MATCH_COST_FUNCTION, maxSize, maxCost));
      }
<span class="fc" id="L611">      mq.put(m, pam);</span>
<span class="fc" id="L612">    }</span>

    public double topCost() {
<span class="nc" id="L615">      double cost = Double.MIN_VALUE;</span>
<span class="nc bnc" id="L616" title="All 2 branches missed.">      for (BoundedCostOrderedMap&lt;Match&lt;K,V&gt;, PartialApproxMatch&lt;K,V&gt;&gt; q:multimatchQueues.values()) {</span>
<span class="nc bnc" id="L617" title="All 2 branches missed.">        if (q.topCost() &gt; cost) cost = q.topCost();</span>
<span class="nc" id="L618">      }</span>
<span class="nc" id="L619">      return cost;</span>
    }

    public int size() {
<span class="fc" id="L623">      int sz = 0;</span>
<span class="fc bfc" id="L624" title="All 2 branches covered.">      for (BoundedCostOrderedMap&lt;Match&lt;K,V&gt;, PartialApproxMatch&lt;K,V&gt;&gt; q:multimatchQueues.values()) {</span>
<span class="fc" id="L625">        sz += q.size();</span>
<span class="fc" id="L626">      }</span>
<span class="fc" id="L627">      return sz;</span>
    }

    public List&lt;PartialApproxMatch&lt;K,V&gt;&gt; toSortedList() {
<span class="fc" id="L631">      List&lt;PartialApproxMatch&lt;K,V&gt;&gt; all = new ArrayList&lt;&gt;(size());</span>
<span class="fc bfc" id="L632" title="All 2 branches covered.">      for (BoundedCostOrderedMap&lt;Match&lt;K,V&gt;, PartialApproxMatch&lt;K,V&gt;&gt; q:multimatchQueues.values()) {</span>
<span class="fc" id="L633">        all.addAll(q.valuesList());</span>
<span class="fc" id="L634">      }</span>
<span class="fc" id="L635">      Collections.sort(all, TrieMapMatcher.&lt;K,V&gt;partialMatchComparator());</span>
<span class="fc" id="L636">      return all;</span>
    }
  }

  private boolean addToQueue(MatchQueue&lt;K,V&gt; queue,
                             MatchQueue&lt;K,V&gt; best,
                             MatchCostFunction&lt;K,V&gt; costFunction,
                             PartialApproxMatch&lt;K,V&gt; pam, K a, K b,
                             boolean multimatch, boolean complete) {
<span class="fc" id="L645">    double deltaCost = costFunction.cost(a,b,pam.getMatchedLength());</span>
<span class="fc" id="L646">    double newCost = pam.cost + deltaCost;</span>
<span class="pc bpc" id="L647" title="3 of 4 branches missed.">    if (queue.maxCost != Double.MAX_VALUE &amp;&amp; newCost &gt; queue.maxCost) return false;</span>
<span class="fc bfc" id="L648" title="All 4 branches covered.">    if (best.size() &gt;= queue.maxSize &amp;&amp; newCost &gt; best.topCost()) return false;</span>

<span class="fc" id="L650">    PartialApproxMatch&lt;K,V&gt; npam = pam.withMatch(costFunction, deltaCost, a, b);</span>
<span class="pc bpc" id="L651" title="1 of 6 branches missed.">    if (!multimatch || (npam.trie != null &amp;&amp; npam.trie.children != null)) {</span>
<span class="fc bfc" id="L652" title="All 6 branches covered.">      if (!multimatch &amp;&amp; complete &amp;&amp; npam.value != null) {</span>
<span class="fc" id="L653">        best.add(npam);</span>
      }
<span class="fc" id="L655">      queue.add(npam);</span>
    }

<span class="fc bfc" id="L658" title="All 4 branches covered.">    if (multimatch &amp;&amp; npam.value != null) {</span>
<span class="fc" id="L659">      npam = pam.withMatch(costFunction, deltaCost, a, b, multimatch, rootWithDelimiter);</span>
<span class="pc bpc" id="L660" title="1 of 4 branches missed.">      if (complete &amp;&amp; npam.value != null) {</span>
<span class="fc" id="L661">        best.add(npam);</span>
      }
<span class="fc" id="L663">      queue.add(npam);</span>
    }
<span class="fc" id="L665">    return true;</span>
  }

  public static &lt;K,V&gt; MatchCostFunction&lt;K,V&gt; defaultCost() {
<span class="fc" id="L669">    return ErasureUtils.uncheckedCast(DEFAULT_COST);</span>
  }


  public static &lt;K,V&gt; Comparator&lt;PartialApproxMatch&lt;K,V&gt;&gt; partialMatchComparator() {
<span class="fc" id="L674">    return ErasureUtils.uncheckedCast(PARTIAL_MATCH_COMPARATOR);</span>
  }
<span class="fc" id="L676">  private static final MatchCostFunction DEFAULT_COST = new ExactMatchCost();</span>

<span class="fc" id="L678">  private static final Comparator&lt;PartialApproxMatch&gt; PARTIAL_MATCH_COMPARATOR = (o1, o2) -&gt; {</span>
<span class="fc bfc" id="L679" title="All 2 branches covered.">    if (o1.cost == o2.cost) {</span>
<span class="fc bfc" id="L680" title="All 2 branches covered.">      if (o1.matched.size() == o2.matched.size()) {</span>
<span class="fc bfc" id="L681" title="All 2 branches covered.">        int m1 = (o1.multimatches != null)? o1.multimatches.size():0;</span>
<span class="fc bfc" id="L682" title="All 2 branches covered.">        int m2 = (o2.multimatches != null)? o2.multimatches.size():0;</span>
<span class="pc bpc" id="L683" title="1 of 2 branches missed.">        if (m1 == m2) {</span>
<span class="pc bpc" id="L684" title="1 of 2 branches missed.">          if (o1.begin == o2.begin) {</span>
<span class="fc bfc" id="L685" title="All 2 branches covered.">            if (o1.end == o2.end) {</span>
<span class="fc bfc" id="L686" title="All 2 branches covered.">              for (int i = 0; i &lt; o1.matched.size(); i++) {</span>
<span class="fc" id="L687">                Object x1 = o1.matched.get(i);</span>
<span class="fc" id="L688">                Object x2 = o2.matched.get(i);</span>
<span class="pc bpc" id="L689" title="2 of 4 branches missed.">                if (x1 != null &amp;&amp; x2 != null) {</span>
<span class="pc bpc" id="L690" title="1 of 2 branches missed.">                  if (x1 instanceof Comparable) {</span>
<span class="fc" id="L691">                    int comp = ((Comparable) x1).compareTo(x2);</span>
<span class="fc bfc" id="L692" title="All 2 branches covered.">                    if (comp != 0) return comp;</span>
                  }
                }
              }
<span class="pc bpc" id="L696" title="2 of 4 branches missed.">              if (o1.multimatches != null &amp;&amp; o2.multimatches != null) {</span>
<span class="pc bpc" id="L697" title="1 of 2 branches missed.">                for (int i = 0; i &lt; o1.multimatches.size(); i++) {</span>
<span class="fc" id="L698">                  Match mm1 = (Match) o1.multimatches.get(i);</span>
<span class="fc" id="L699">                  Match mm2 = (Match) o2.multimatches.get(i);</span>
<span class="fc" id="L700">                  return mm1.getInterval().compareTo(mm2.getInterval());</span>
                }
              }
<span class="nc" id="L703">              return 0;</span>
            }
<span class="fc bfc" id="L705" title="All 2 branches covered.">            return (o1.end &lt; o2.end)? -1:1;</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">          } else return (o1.begin &lt; o2.begin)? -1:1;</span>
<span class="nc bnc" id="L707" title="All 2 branches missed.">        } else return (m1 &lt; m2)? -1:1;</span>
<span class="pc bpc" id="L708" title="1 of 2 branches missed.">      } else return (o1.matched.size() &lt; o2.matched.size())? -1:1;</span>
<span class="pc bpc" id="L709" title="1 of 2 branches missed.">    } else if (Double.isNaN(o1.cost)) {</span>
<span class="nc" id="L710">      return -1;</span>
<span class="pc bpc" id="L711" title="1 of 2 branches missed.">    } else if (Double.isNaN(o2.cost)) {</span>
<span class="nc" id="L712">      return 1;</span>
<span class="fc bfc" id="L713" title="All 2 branches covered.">    } else return (o1.cost &lt; o2.cost)? -1:1;</span>
  };




}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>