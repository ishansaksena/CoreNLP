<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>InputPanel.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.trees.tregex.gui</a> &gt; <span class="el_source">InputPanel.java</span></div><h1>InputPanel.java</h1><pre class="source lang-java linenums">//Tregex/Tsurgeon, InputPanel - a GUI for tree search and modification
//Copyright (c) 2007-2008 The Board of Trustees of
//The Leland Stanford Junior University. All Rights Reserved.

//This program is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either version 2
//of the License, or (at your option) any later version.

//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.

//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

//This code is a GUI interface to Tregex and Tsurgeon (which were
//written by Rogey Levy and Galen Andrew).

//For more information, bug reports, fixes, contact:
//Christopher Manning
//Dept of Computer Science, Gates 1A
//Stanford CA 94305-9010
//USA
//    Support/Questions: parser-user@lists.stanford.edu
//    Licensing: parser-support@lists.stanford.edu
//http://www-nlp.stanford.edu/software/tregex.shtml

package edu.stanford.nlp.trees.tregex.gui; 
import edu.stanford.nlp.util.logging.Redwood;

import java.awt.Color;
import java.awt.ComponentOrientation;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.BufferedReader;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import javax.swing.*;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;

import edu.stanford.nlp.trees.HeadFinder;
import edu.stanford.nlp.trees.Tree;
import edu.stanford.nlp.trees.TreeVisitor;
import edu.stanford.nlp.trees.tregex.TregexMatcher;
import edu.stanford.nlp.trees.tregex.TregexPattern;
import edu.stanford.nlp.trees.tregex.TregexPatternCompiler;
import edu.stanford.nlp.trees.tregex.tsurgeon.Tsurgeon;
import edu.stanford.nlp.trees.tregex.tsurgeon.TsurgeonPattern;
import edu.stanford.nlp.util.Generics;


/**
 * Class representing the panel that gets input from the user and does (in a thread-safe manner)
 * the computation for finding tree matches and performing tsurgeon operations.  Also displays statistics.
 *
 * @author Anna Rafferty
 */
public class InputPanel extends JPanel implements ActionListener, ChangeListener  {

  /** A logger for this class */
<span class="nc" id="L75">  private static Redwood.RedwoodChannels log = Redwood.channels(InputPanel.class);</span>

  private static final long serialVersionUID = -8219840036914495876L;

  private static InputPanel inputPanel; // = null;

  private JLabel foundStats;
  private JButton findMatches;
  private JButton cancel;
  private JButton help;
  private JTextArea tregexPattern;
  private JComboBox&lt;String&gt; recentTregexPatterns;
  private DefaultComboBoxModel&lt;String&gt; recentTregexPatternsModel;
<span class="nc" id="L88">  private int numRecentPatterns = 5;// we save the last n patterns in our combo box, where n = numRecentPatterns</span>
  private JTextArea tsurgeonScript;
  private TregexPatternCompiler compiler;//this should change only when someone changes the headfinder/basic category finder
  private List&lt;HistoryEntry&gt; historyList;
  private JFrame historyFrame; // = null;
  private JLabel scriptLabel;
  private boolean tsurgeonEnabled; // = false;
  private JButton tsurgeonHelp;
  private JButton cancelTsurgeon;
  private Thread searchThread;
  private JButton historyButton;
  private JProgressBar progressBar;
  private JButton browseButton;

  private JFrame helpFrame;

  private JFrame tsurgeonHelpFrame;

  private JButton runScript;

  public static synchronized InputPanel getInstance() {
<span class="nc bnc" id="L109" title="All 2 branches missed.">    if (inputPanel == null)</span>
<span class="nc" id="L110">      inputPanel = new InputPanel();</span>
<span class="nc" id="L111">    return inputPanel;</span>
  }


<span class="nc" id="L115">  private InputPanel() {</span>
    //data stuff
<span class="nc" id="L117">    compiler = new TregexPatternCompiler();</span>
<span class="nc" id="L118">    historyList = new ArrayList&lt;&gt;();</span>

    //layout/image stuff
<span class="nc" id="L121">    this.setLayout(new GridBagLayout());</span>
<span class="nc" id="L122">    this.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEmptyBorder(),&quot;Search pattern: &quot;));</span>

    //pattern/history area
<span class="nc" id="L125">    JPanel tregexInput = makeTregexPatternArea();</span>

    //buttons
<span class="nc" id="L128">    JPanel buttonBox = makeTregexButtonBox();</span>
<span class="nc" id="L129">    JPanel browseButtonBox = makeBrowseButtonBox();</span>

    //interactive (if set in prefs) tsurgeon pattern
<span class="nc" id="L132">    Box tsurgeonBox = makeTSurgeonScriptArea();</span>

    //tsurgeon buttons
<span class="nc" id="L135">    JPanel tsurgeonButtonBox = makeTSurgeonButtons();</span>

    //enable/disable tsurgeon by default
<span class="nc" id="L138">    enableTsurgeonHelper(tsurgeonEnabled);//helper method used for initial call</span>

    //statistics/status
<span class="nc" id="L141">    JPanel foundStatsBox = makeFoundStatsBox();</span>

    //put it together
<span class="nc" id="L144">    JLabel bigEmptyLabel = new JLabel();</span>
    //bigEmptyLabel.setBorder(BorderFactory.createEtchedBorder());

<span class="nc" id="L147">    GridBagConstraints c = new GridBagConstraints();</span>
<span class="nc" id="L148">    c.fill = GridBagConstraints.BOTH;</span>
<span class="nc" id="L149">    c.gridwidth = GridBagConstraints.REMAINDER;</span>
<span class="nc" id="L150">    c.weightx = 1.0;</span>
<span class="nc" id="L151">    c.weighty = 3.0/12;</span>
<span class="nc" id="L152">    c.gridx = 0;</span>
<span class="nc" id="L153">    c.gridy = 0;</span>
<span class="nc" id="L154">    this.add(tregexInput,c);</span>

<span class="nc" id="L156">    c.weighty = 1.0/12;</span>
<span class="nc" id="L157">    c.gridy = 1;</span>
<span class="nc" id="L158">    this.add(buttonBox,c);</span>

<span class="nc" id="L160">    c.weighty = 1.0/12;</span>
<span class="nc" id="L161">    c.gridy = 2;</span>
<span class="nc" id="L162">    this.add(browseButtonBox,c);</span>

<span class="nc" id="L164">    c.weighty = 0.5/12;</span>
<span class="nc" id="L165">    c.gridy = 3;</span>
<span class="nc" id="L166">    this.add(bigEmptyLabel,c);</span>

<span class="nc" id="L168">    c.weighty = 3.0/12;</span>
<span class="nc" id="L169">    c.gridy = 4;</span>
<span class="nc" id="L170">    c.anchor = GridBagConstraints.SOUTH;</span>
<span class="nc" id="L171">    this.add(tsurgeonBox,c);</span>

<span class="nc" id="L173">    c.weighty = 1.0/12;</span>
<span class="nc" id="L174">    c.gridy = 5;</span>
    //c.gridheight = GridBagConstraints.REMAINDER;
<span class="nc" id="L176">    c.anchor = GridBagConstraints.SOUTH;</span>
<span class="nc" id="L177">    this.add(tsurgeonButtonBox,c);</span>

<span class="nc" id="L179">    c.gridheight = GridBagConstraints.REMAINDER;</span>
<span class="nc" id="L180">    c.weighty = 1.0/12;</span>
<span class="nc" id="L181">    c.gridy = 6;</span>
<span class="nc" id="L182">    this.add(foundStatsBox, c);</span>
<span class="nc" id="L183">  }</span>


  //separated out to make constructor more readable
  private JPanel makeFoundStatsBox() {
<span class="nc" id="L188">    JPanel foundStatsBox = new JPanel();</span>
<span class="nc" id="L189">    foundStatsBox.setLayout(new GridBagLayout());</span>
<span class="nc" id="L190">    Box labelBox = Box.createHorizontalBox();</span>
<span class="nc" id="L191">    foundStats = new JLabel(&quot; &quot;);</span>
<span class="nc" id="L192">    labelBox.add(foundStats);</span>
<span class="nc" id="L193">    historyButton = new JButton(&quot;Statistics&quot;);</span>
<span class="nc" id="L194">    historyButton.setEnabled(false);</span>
<span class="nc" id="L195">    historyButton.addActionListener(this);</span>

<span class="nc" id="L197">    GridBagConstraints c = new GridBagConstraints();</span>
<span class="nc" id="L198">    c.fill = GridBagConstraints.BOTH;</span>
<span class="nc" id="L199">    c.weightx = 1.7;</span>
<span class="nc" id="L200">    foundStatsBox.add(labelBox,c);</span>
<span class="nc" id="L201">    c.weightx = .3;</span>
<span class="nc" id="L202">    c.gridwidth = 1;</span>
<span class="nc" id="L203">    foundStatsBox.add(historyButton);</span>
<span class="nc" id="L204">    return foundStatsBox;</span>

  }

  //separated out to make constructor more readable
  private JPanel makeTSurgeonButtons() {
<span class="nc" id="L210">    JPanel tsurgeonButtonBox = new JPanel();</span>
<span class="nc" id="L211">    tsurgeonButtonBox.setComponentOrientation(ComponentOrientation.RIGHT_TO_LEFT);</span>
<span class="nc" id="L212">    tsurgeonButtonBox.setLayout(new GridBagLayout());</span>
<span class="nc" id="L213">    tsurgeonHelp = new JButton(&quot;Help&quot;);</span>
<span class="nc" id="L214">    tsurgeonHelp.addActionListener(this);</span>
<span class="nc" id="L215">    cancelTsurgeon = new JButton(&quot;Cancel&quot;);</span>
<span class="nc" id="L216">    cancelTsurgeon.addActionListener(this);</span>
<span class="nc" id="L217">    runScript = new JButton(&quot;Run script&quot;);</span>
<span class="nc" id="L218">    runScript.addActionListener(this);</span>

    //make constraints and add in
<span class="nc" id="L221">    GridBagConstraints c = new GridBagConstraints();</span>
<span class="nc" id="L222">    c.anchor = GridBagConstraints.NORTHEAST;</span>
<span class="nc" id="L223">    c.fill = GridBagConstraints.HORIZONTAL;</span>
<span class="nc" id="L224">    tsurgeonButtonBox.add(runScript,c);</span>
<span class="nc" id="L225">    tsurgeonButtonBox.add(cancelTsurgeon,c);</span>
<span class="nc" id="L226">    tsurgeonButtonBox.add(tsurgeonHelp,c);</span>

<span class="nc" id="L228">    c.gridwidth = GridBagConstraints.REMAINDER;</span>
<span class="nc" id="L229">    c.weightx = 1.0;</span>
<span class="nc" id="L230">    c.weighty = 1.0;</span>
<span class="nc" id="L231">    tsurgeonButtonBox.add(new JLabel(), c);</span>


<span class="nc" id="L234">    return tsurgeonButtonBox;</span>
  }
  //separated out to make constructor more readable
  private Box makeTSurgeonScriptArea() {
<span class="nc" id="L238">    Box tsurgeonBox = Box.createHorizontalBox();</span>
<span class="nc" id="L239">    scriptLabel = new JLabel(&quot;Tsurgeon script: &quot;);</span>
<span class="nc" id="L240">    tsurgeonScript = new JTextArea();</span>
<span class="nc" id="L241">    tsurgeonScript.setBorder(BorderFactory.createEmptyBorder());</span>
<span class="nc" id="L242">    tsurgeonScript.setFocusTraversalKeysEnabled(true);</span>
<span class="nc" id="L243">    JScrollPane scriptScroller = new JScrollPane(tsurgeonScript);</span>
<span class="nc" id="L244">    scriptScroller.setBorder(BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.LOWERED));</span>

    //scriptScroller.setEnabled(tsurgeonEnabled);
<span class="nc" id="L247">    tsurgeonBox.add(scriptLabel);</span>
<span class="nc" id="L248">    tsurgeonBox.add(scriptScroller);</span>
    //tsurgeonBox.setBorder(BorderFactory.createEtchedBorder());
<span class="nc" id="L250">    return tsurgeonBox;</span>
  }

  //separated out to make constructor more readable
  private JPanel makeTregexPatternArea() {
    //combo box with recent searches
<span class="nc" id="L256">    recentTregexPatternsModel = new DefaultComboBoxModel&lt;&gt;();</span>
<span class="nc" id="L257">    recentTregexPatterns = new JComboBox&lt;&gt;(recentTregexPatternsModel);</span>
<span class="nc" id="L258">    recentTregexPatterns.setMinimumSize(new Dimension(120, 24));</span>
<span class="nc" id="L259">    recentTregexPatterns.addActionListener(this);</span>

<span class="nc" id="L261">    JLabel recentLabel = new JLabel(&quot;Recent: &quot;);</span>
    //interactive tregex pattern
<span class="nc" id="L263">    JLabel patternLabel = new JLabel(&quot;Pattern: &quot;);</span>
<span class="nc" id="L264">    tregexPattern = new JTextArea();</span>
<span class="nc" id="L265">    tregexPattern.setFocusTraversalKeysEnabled(true);</span>
<span class="nc" id="L266">    tregexPattern.setLineWrap(true);</span>

<span class="nc" id="L268">    JScrollPane patternScroller = new JScrollPane(tregexPattern);</span>
<span class="nc" id="L269">    patternScroller.setBorder(BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.LOWERED));</span>

    //add them into the panel
<span class="nc" id="L272">    JPanel tregexInput = new JPanel();</span>
<span class="nc" id="L273">    tregexInput.setLayout(new GridBagLayout());</span>
<span class="nc" id="L274">    GridBagConstraints c = new GridBagConstraints();</span>
<span class="nc" id="L275">    c.fill = GridBagConstraints.BOTH;</span>
<span class="nc" id="L276">    c.weightx = 1.0;</span>
<span class="nc" id="L277">    c.weighty = 1.0;</span>
<span class="nc" id="L278">    c.gridx = 0;</span>
<span class="nc" id="L279">    c.gridy = 0;</span>
<span class="nc" id="L280">    tregexInput.add(recentLabel, c);</span>
<span class="nc" id="L281">    c.weightx = 12.0;</span>
<span class="nc" id="L282">    c.gridwidth = GridBagConstraints.REMAINDER;</span>
<span class="nc" id="L283">    c.gridx = 1;</span>
<span class="nc" id="L284">    tregexInput.add(recentTregexPatterns, c);</span>
<span class="nc" id="L285">    c.weightx = 1.0;</span>
<span class="nc" id="L286">    c.gridwidth = 1; //reset to default</span>
<span class="nc" id="L287">    c.gridheight = GridBagConstraints.REMAINDER;</span>
<span class="nc" id="L288">    c.gridx = 0;</span>
<span class="nc" id="L289">    c.gridy = 1;</span>
<span class="nc" id="L290">    tregexInput.add(patternLabel,c);</span>
<span class="nc" id="L291">    c.gridx = 1;</span>
<span class="nc" id="L292">    c.weightx = 12.0;</span>
<span class="nc" id="L293">    c.weighty = 2.0;</span>
<span class="nc" id="L294">    c.gridwidth = GridBagConstraints.REMAINDER;</span>
<span class="nc" id="L295">    tregexInput.add(patternScroller,c);</span>
    //tregexInput.setBorder(BorderFactory.createEtchedBorder());

<span class="nc" id="L298">    return tregexInput;</span>
  }

  //separated out to make constructor more readable
  private JPanel makeTregexButtonBox() {
<span class="nc" id="L303">    JPanel buttonBox = new JPanel();</span>
<span class="nc" id="L304">    buttonBox.setComponentOrientation(ComponentOrientation.RIGHT_TO_LEFT);</span>
<span class="nc" id="L305">    buttonBox.setLayout(new GridBagLayout());</span>
    //buttonBox.setBorder(BorderFactory.createEtchedBorder());
<span class="nc" id="L307">    help = new JButton(&quot;Help&quot;);</span>
<span class="nc" id="L308">    help.addActionListener(this);</span>
<span class="nc" id="L309">    cancel = new JButton(&quot;Cancel&quot;);</span>
<span class="nc" id="L310">    cancel.setEnabled(false);</span>
<span class="nc" id="L311">    cancel.addActionListener(this);</span>
<span class="nc" id="L312">    findMatches = new JButton(&quot;Search&quot;);</span>
<span class="nc" id="L313">    findMatches.addActionListener(this);</span>
//  browseButton = new JButton(&quot;Browse Trees&quot;);
//  browseButton.addActionListener(this);
<span class="nc" id="L316">    JLabel emptyLabel = new JLabel();</span>
   // JLabel emptyLabel2 = new JLabel();

<span class="nc" id="L319">    GridBagConstraints buttonConstraints = new GridBagConstraints();</span>
<span class="nc" id="L320">    buttonConstraints.fill = GridBagConstraints.HORIZONTAL;</span>
<span class="nc" id="L321">    buttonBox.add(findMatches,buttonConstraints);</span>
<span class="nc" id="L322">    buttonBox.add(cancel,buttonConstraints);</span>
<span class="nc" id="L323">    buttonBox.add(help,buttonConstraints);</span>

<span class="nc" id="L325">    buttonConstraints.gridwidth = GridBagConstraints.REMAINDER;</span>
<span class="nc" id="L326">    buttonConstraints.weightx = 1.0;</span>
<span class="nc" id="L327">    buttonConstraints.weighty = 1.0;</span>
<span class="nc" id="L328">    buttonBox.add(emptyLabel, buttonConstraints);</span>
//  buttonConstraints.gridwidth = 1;
//  buttonBox.add(browseButton, buttonConstraints);
//  buttonConstraints.gridwidth = GridBagConstraints.REMAINDER;
//  buttonBox.add(emptyLabel2, buttonConstraints);

<span class="nc" id="L334">    return buttonBox;</span>
  }

  private JPanel makeBrowseButtonBox() {
<span class="nc" id="L338">    JPanel buttonBox = new JPanel();</span>
<span class="nc" id="L339">    buttonBox.setComponentOrientation(ComponentOrientation.RIGHT_TO_LEFT);</span>
<span class="nc" id="L340">    buttonBox.setLayout(new GridBagLayout());</span>
<span class="nc" id="L341">    browseButton = new JButton(&quot;Browse Trees&quot;);</span>
<span class="nc" id="L342">    browseButton.addActionListener(this);</span>
<span class="nc" id="L343">    JLabel sizeLabel = new JLabel(&quot;Tree size:&quot;);</span>
<span class="nc" id="L344">    JSlider fontSlider = new JSlider(2, 64, 12);</span>
<span class="nc" id="L345">    fontSlider.addChangeListener(this);</span>
<span class="nc" id="L346">    GridBagConstraints buttonConstraints = new GridBagConstraints();</span>
<span class="nc" id="L347">    buttonConstraints.fill = GridBagConstraints.HORIZONTAL;</span>
<span class="nc" id="L348">    buttonConstraints.weightx = 0.2;</span>
<span class="nc" id="L349">    buttonConstraints.weighty = 0.2;</span>
<span class="nc" id="L350">    buttonBox.add(browseButton,buttonConstraints);</span>
<span class="nc" id="L351">    buttonConstraints.weightx = 0.6;</span>
<span class="nc" id="L352">    buttonBox.add(fontSlider, buttonConstraints);</span>
<span class="nc" id="L353">    buttonConstraints.weightx = 0.2;</span>
<span class="nc" id="L354">    buttonBox.add(sizeLabel, buttonConstraints);</span>
<span class="nc" id="L355">    return buttonBox;</span>
  }


  public void enableTsurgeon(boolean enable) {
<span class="nc bnc" id="L360" title="All 2 branches missed.">    if(tsurgeonEnabled == enable)</span>
<span class="nc" id="L361">      return;//nothing changes</span>
<span class="nc" id="L362">    enableTsurgeonHelper(enable);</span>
<span class="nc" id="L363">  }</span>

  //Doesn't check if tsurgeon is already in this enable state - used by enableTsurgeon and for
  //initially enabling/disabling tsurgeon.
  private void enableTsurgeonHelper(boolean enable) {
<span class="nc" id="L368">    scriptLabel.setEnabled(enable);</span>
<span class="nc" id="L369">    tsurgeonScript.setEnabled(enable);</span>
<span class="nc" id="L370">    tsurgeonHelp.setEnabled(enable);</span>
<span class="nc" id="L371">    cancelTsurgeon.setEnabled(false);//should always be off unless we're running a script</span>
<span class="nc" id="L372">    runScript.setEnabled(enable);</span>
<span class="nc" id="L373">    tsurgeonEnabled = enable;</span>
<span class="nc" id="L374">    TregexGUI.getInstance().setTsurgeonEnabled(enable);</span>
<span class="nc" id="L375">  }</span>

  public List&lt;HistoryEntry&gt; getHistoryList() {
<span class="nc" id="L378">    return historyList;</span>
  }

  public String getHistoryString() {
<span class="nc" id="L382">    StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L383">    sb.append(HistoryEntry.header());</span>
<span class="nc" id="L384">    sb.append('\n');</span>
<span class="nc bnc" id="L385" title="All 2 branches missed.">    for(HistoryEntry e : this.getHistoryList()) {</span>
<span class="nc" id="L386">      sb.append(e.toString());</span>
<span class="nc" id="L387">      sb.append('\n');</span>
<span class="nc" id="L388">    }</span>
<span class="nc" id="L389">    return sb.toString();</span>
  }

  private void addToHistoryList(String pattern, int numTreesMatched, int numMatches) {
<span class="nc bnc" id="L393" title="All 2 branches missed.">    if(!historyButton.isEnabled()) {</span>
<span class="nc" id="L394">      historyButton.setEnabled(true);</span>
<span class="nc" id="L395">      TregexGUI.getInstance().setSaveHistoryEnabled(true);</span>
    }
<span class="nc" id="L397">    historyList.add(new HistoryEntry(pattern, numTreesMatched, numMatches));</span>
<span class="nc" id="L398">  }</span>

  public void setHeadFinder(HeadFinder hf) {
<span class="nc" id="L401">    compiler = new TregexPatternCompiler(hf);</span>
<span class="nc" id="L402">  }</span>

  /**
   * Updates the number of unique trees matched and the number of total trees matched by the last
   * pattern that was searched for.  Thread-safe.
   *
   * @param pattern The pattern
   * @param treeMatches count of unique trees matched by the pattern
   * @param totalMatches count of total matching instances
   */
  public void updateFoundStats(final String pattern, final int treeMatches, final int totalMatches) {
<span class="nc" id="L413">    final String txt = &quot;&lt;html&gt;Match stats: &quot; + treeMatches + &quot; unique trees found with &quot; + totalMatches + &quot; total matches.&lt;/html&gt;&quot;;</span>
<span class="nc" id="L414">    SwingUtilities.invokeLater(() -&gt; {</span>
<span class="nc" id="L415">      foundStats.setPreferredSize(foundStats.getSize());</span>
<span class="nc" id="L416">      foundStats.setText(txt);</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">      if(pattern != null)</span>
<span class="nc" id="L418">        addToHistoryList(pattern, treeMatches, totalMatches);</span>
<span class="nc" id="L419">    });</span>
<span class="nc" id="L420">  }</span>

  public void useProgressBar(boolean useProgressBar) {
<span class="nc bnc" id="L423" title="All 2 branches missed.">    if (useProgressBar) {//make sure we're in progress bar mode</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">      if (progressBar == null) {</span>
<span class="nc" id="L425">        progressBar = new JProgressBar(JProgressBar.HORIZONTAL);</span>
<span class="nc" id="L426">        Container dad = foundStats.getParent();</span>
<span class="nc" id="L427">        useProgressBarHelper(dad, progressBar, foundStats);</span>
<span class="nc" id="L428">      }</span>
    } else {//make sure we're in found stats mode
<span class="nc bnc" id="L430" title="All 2 branches missed.">      if (progressBar != null) {</span>
<span class="nc" id="L431">        Container dad = progressBar.getParent();</span>
<span class="nc" id="L432">        useProgressBarHelper(dad, foundStats, progressBar);</span>
<span class="nc" id="L433">        progressBar = null;</span>
      }

    }
<span class="nc" id="L437">  }</span>

  private static void useProgressBarHelper(Container parent, JComponent add, JComponent remove) {
<span class="nc" id="L440">    GridBagConstraints c = new GridBagConstraints();</span>
<span class="nc" id="L441">    c.fill = GridBagConstraints.BOTH;</span>
<span class="nc" id="L442">    c.weightx = 1.7;</span>
<span class="nc" id="L443">    parent.remove(remove);</span>
<span class="nc" id="L444">    parent.add(add,c);</span>
<span class="nc" id="L445">    parent.validate();</span>
<span class="nc" id="L446">    parent.repaint();</span>
<span class="nc" id="L447">  }</span>

  @Override
  public void actionPerformed(ActionEvent e) {
<span class="nc" id="L451">    Object source = e.getSource();</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">    if (source == findMatches) {</span>
<span class="nc" id="L453">      runSearch();</span>
<span class="nc bnc" id="L454" title="All 2 branches missed.">    } else if (source == cancel) {</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">      if (searchThread != null) {</span>
<span class="nc" id="L456">        searchThread.interrupt();</span>
      }
<span class="nc" id="L458">      cancel.setEnabled(false);</span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">    } else if (source == help) {</span>
<span class="nc" id="L460">      displayHelp();</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">    } else if (source == tsurgeonHelp) {</span>
<span class="nc" id="L462">      displayTsurgeonHelp();</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">    } else if (source == cancelTsurgeon) {</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">      if (searchThread != null) {</span>
<span class="nc" id="L465">        searchThread.interrupt();</span>
      }
<span class="nc" id="L467">      cancelTsurgeon.setEnabled(false);</span>
<span class="nc bnc" id="L468" title="All 2 branches missed.">    } else if (source == runScript) {</span>
<span class="nc" id="L469">      runScript();</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">    } else if (source == recentTregexPatterns) {</span>
<span class="nc" id="L471">      doRecent();</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">    } else if (source == historyButton) {</span>
<span class="nc" id="L473">      showHistory();</span>
<span class="nc bnc" id="L474" title="All 2 branches missed.">    } else if (source == browseButton) {</span>
<span class="nc" id="L475">      runBrowse();</span>
    }
<span class="nc" id="L477">  }</span>

  @Override
  public void stateChanged(ChangeEvent e) {
<span class="nc" id="L481">    JSlider source = (JSlider) e.getSource();</span>
<span class="nc" id="L482">    int fontSize = source.getValue();</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">    if ( ! source.getValueIsAdjusting()) {</span>
<span class="nc" id="L484">      DisplayMatchesPanel.getInstance().setFontSizeRepaint(fontSize);</span>
    }
<span class="nc" id="L486">  }</span>

  private static class TregexGUITableModel extends DefaultTableModel {

    private static final long serialVersionUID = -8095682087502853273L;

    TregexGUITableModel(Object[][] entries, String[] columnNames) {
<span class="nc" id="L493">      super(entries, columnNames);</span>
<span class="nc" id="L494">    }</span>

    @Override
    public boolean isCellEditable(int row, int column) {
<span class="nc" id="L498">      return false;</span>
    }

  }


  private void showHistory() {
<span class="nc bnc" id="L505" title="All 2 branches missed.">    if (historyFrame == null) {</span>
<span class="nc" id="L506">      historyFrame = new JFrame(&quot;Statistics History&quot;);</span>
    } else {
<span class="nc" id="L508">      historyFrame.setVisible(false);</span>
<span class="nc" id="L509">      historyFrame= new JFrame(&quot;Statistics History&quot;);</span>
    }
<span class="nc" id="L511">    historyFrame.setLayout(new GridLayout(1,0));</span>
<span class="nc" id="L512">    Object[][] entries = new Object[historyList.size()][3];</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">    for(int i = 0; i &lt; historyList.size(); i++) {</span>
<span class="nc" id="L514">      entries[i] = historyList.get(i).toArray();</span>
    }
<span class="nc" id="L516">    DefaultTableModel tableModel = new TregexGUITableModel(entries, HistoryEntry.columnNamesArray());</span>
<span class="nc" id="L517">    JTable statTable = new JTable(tableModel);</span>
<span class="nc" id="L518">    DefaultTableCellRenderer dtcr = (DefaultTableCellRenderer) statTable.getDefaultRenderer(String.class);</span>
<span class="nc" id="L519">    dtcr.setHorizontalAlignment(DefaultTableCellRenderer.CENTER);</span>

<span class="nc" id="L521">    JScrollPane scroller = new JScrollPane(statTable);</span>

<span class="nc" id="L523">    historyFrame.add(scroller);</span>
<span class="nc" id="L524">    historyFrame.pack();</span>
<span class="nc" id="L525">    historyFrame.setLocationRelativeTo(TregexGUI.getInstance());</span>
<span class="nc" id="L526">    historyFrame.setBackground(Color.WHITE);</span>
<span class="nc" id="L527">    historyFrame.setVisible(true);</span>
<span class="nc" id="L528">    historyFrame.repaint();</span>

<span class="nc" id="L530">  }</span>

  private void doRecent() {
    //this is called only when a user does something
<span class="nc" id="L534">    Object recent = recentTregexPatternsModel.getSelectedItem();</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">    if (recent != null) {</span>
<span class="nc" id="L536">      String selected = recent.toString();</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">      if (selected.length() != 0) {</span>
<span class="nc" id="L538">        tregexPattern.setText(selected);</span>
      }
    }
<span class="nc" id="L541">  }</span>

  private void runBrowse() {
<span class="nc" id="L544">    this.setPreferredSize(this.getSize());</span>
<span class="nc" id="L545">    Thread browseThread = new Thread() {</span>
      @Override
      public void run() {
<span class="nc" id="L548">        useProgressBar(true);</span>

<span class="nc" id="L550">        final List&lt;TreeFromFile&gt; trees = new ArrayList&lt;&gt;();</span>

        //Go through the treebanks and get all the trees
<span class="nc" id="L553">        List&lt;FileTreeNode&gt; treebanks = FilePanel.getInstance().getActiveTreebanks();</span>

        //Tdiff
<span class="nc bnc" id="L556" title="All 2 branches missed.">        if(TregexGUI.getInstance().isTdiffEnabled())</span>
<span class="nc" id="L557">          treebanks.remove(0); //Remove the reference</span>

<span class="nc" id="L559">        double multiplier = 100.0/treebanks.size();</span>
<span class="nc bnc" id="L560" title="All 2 branches missed.">        for (int i = 0; i &lt; treebanks.size(); i++) {</span>
<span class="nc" id="L561">          FileTreeNode treebank = treebanks.get(i);</span>
<span class="nc" id="L562">          String filename = treebank.getFilename();</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">          for (Tree curTree : treebank.getTreebank()) {</span>
<span class="nc" id="L564">            trees.add(new TreeFromFile(curTree, filename));</span>
<span class="nc" id="L565">          }</span>
<span class="nc" id="L566">          updateProgressBar(multiplier*(i+1));</span>
        }
<span class="nc" id="L568">        SwingUtilities.invokeLater(() -&gt; {</span>
<span class="nc" id="L569">          MatchesPanel.getInstance().setMatches(trees, null);</span>
<span class="nc" id="L570">          MatchesPanel.getInstance().focusOnList();</span>
<span class="nc" id="L571">          useProgressBar(false);</span>
<span class="nc" id="L572">        });//end SwingUtilities.invokeLater</span>

<span class="nc" id="L574">      } //end run</span>
    };//end Thread

<span class="nc" id="L577">    browseThread.start();</span>
<span class="nc" id="L578">  }</span>


  void runSearch() {
<span class="nc" id="L582">    setTregexState(true);</span>
<span class="nc" id="L583">    MatchesPanel.getInstance().removeAllMatches();</span>
<span class="nc" id="L584">    this.setPreferredSize(this.getSize());</span>
<span class="nc" id="L585">    searchThread = new Thread() {</span>
      @Override
      public void run() {
<span class="nc" id="L588">        final String text = tregexPattern.getText().intern();</span>
<span class="nc" id="L589">        SwingUtilities.invokeLater(() -&gt; {</span>
<span class="nc" id="L590">          InputPanel.this.addRecentTregexPattern(text);</span>
<span class="nc" id="L591">          useProgressBar(true);</span>
<span class="nc" id="L592">        });</span>
<span class="nc" id="L593">        final TRegexGUITreeVisitor visitor = getMatchTreeVisitor(text,this);</span>
<span class="nc bnc" id="L594" title="All 2 branches missed.">        if (visitor != null) {</span>

<span class="nc" id="L596">          SwingUtilities.invokeLater(() -&gt; {</span>
<span class="nc" id="L597">            useProgressBar(false);</span>
<span class="nc" id="L598">            updateFoundStats(text, visitor.getMatches().size(), visitor.numUniqueMatches());</span>
            //addToHistoryList(text, visitor.getMatches().size(), visitor.numUniqueMatches());
<span class="nc" id="L600">            MatchesPanel.getInstance().setMatches(visitor.getMatches(), visitor.getMatchedParts());</span>
<span class="nc" id="L601">            MatchesPanel.getInstance().focusOnList();</span>
<span class="nc" id="L602">          });</span>
        }
<span class="nc" id="L604">        SwingUtilities.invokeLater(() -&gt; {</span>
<span class="nc" id="L605">          setTregexState(false);</span>
<span class="nc" id="L606">          InputPanel.this.searchThread = null;</span>
<span class="nc" id="L607">        });</span>

<span class="nc" id="L609">      }</span>
    };
<span class="nc" id="L611">    searchThread.start();</span>

<span class="nc" id="L613">  }</span>

  private void setTregexState(boolean running) {
<span class="nc" id="L616">    cancel.setEnabled(running);</span>
<span class="nc bnc" id="L617" title="All 2 branches missed.">    findMatches.setEnabled(!running);</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">    browseButton.setEnabled(!running);</span>
<span class="nc" id="L619">  }</span>

  //Assumes that it will be called only if Tsurgeon is already enabled
  private void setTsurgeonState(boolean running) {
<span class="nc" id="L623">    cancelTsurgeon.setEnabled(running);</span>
<span class="nc bnc" id="L624" title="All 2 branches missed.">    runScript.setEnabled(!running);</span>
<span class="nc bnc" id="L625" title="All 2 branches missed.">    findMatches.setEnabled(!running);</span>
<span class="nc bnc" id="L626" title="All 2 branches missed.">    browseButton.setEnabled(!running);</span>
<span class="nc" id="L627">  }</span>

  private void runScript() {
<span class="nc" id="L630">    setTsurgeonState(true);</span>
<span class="nc" id="L631">    final String script = tsurgeonScript.getText();</span>

<span class="nc" id="L633">    searchThread = new Thread() {</span>
      @Override
      public void run() {
        try {
<span class="nc" id="L637">          BufferedReader reader = new BufferedReader(new StringReader(script));</span>
<span class="nc" id="L638">          TsurgeonPattern operation = Tsurgeon.getTsurgeonOperationsFromReader(reader);</span>

<span class="nc" id="L640">          final String text = tregexPattern.getText().intern();</span>
<span class="nc" id="L641">          SwingUtilities.invokeLater(() -&gt; {</span>
<span class="nc" id="L642">            InputPanel.this.addRecentTregexPattern(text);</span>
<span class="nc" id="L643">            useProgressBar(true);</span>
<span class="nc" id="L644">          });</span>
<span class="nc" id="L645">          final TRegexGUITreeVisitor visitor = getMatchTreeVisitor(text,this);</span>
<span class="nc bnc" id="L646" title="All 2 branches missed.">          if (visitor == null) return; //means the tregex errored out</span>
<span class="nc bnc" id="L647" title="All 2 branches missed.">          if (this.isInterrupted()) {</span>
<span class="nc" id="L648">            returnToValidState(text, visitor, new ArrayList&lt;&gt;());</span>
<span class="nc" id="L649">            return;</span>
          }
          //log.info(&quot;Running Script with matches: &quot; + visitor.getMatches());
<span class="nc" id="L652">          List&lt;TreeFromFile&gt; trees = visitor.getMatches();</span>
<span class="nc" id="L653">          final List&lt;TreeFromFile&gt; modifiedTrees = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L654" title="All 2 branches missed.">          for (TreeFromFile tff : trees) {</span>
<span class="nc bnc" id="L655" title="All 2 branches missed.">            if (this.isInterrupted()) {</span>
<span class="nc" id="L656">              returnToValidState(text, visitor, trees);</span>
<span class="nc" id="L657">              return;</span>
            }
<span class="nc" id="L659">            Tree modifiedTree = Tsurgeon.processPattern(visitor.getPattern(), operation, tff.getTree());</span>
<span class="nc" id="L660">            modifiedTrees.add(new TreeFromFile(modifiedTree,tff.getFilename().intern()));</span>
<span class="nc" id="L661">          }</span>
<span class="nc" id="L662">          returnToValidState(text, visitor, modifiedTrees);</span>
<span class="nc" id="L663">        } catch (Exception e) {</span>
<span class="nc" id="L664">          doError(&quot;Sorry, there was an error compiling or running the Tsurgeon script.  Please press Help if you need assistance.&quot;, e);</span>
<span class="nc" id="L665">          SwingUtilities.invokeLater(() -&gt; {</span>
<span class="nc" id="L666">            setTregexState(false);</span>
<span class="nc" id="L667">            setTsurgeonState(false);</span>
<span class="nc" id="L668">            InputPanel.this.searchThread = null;</span>
<span class="nc" id="L669">          });</span>
<span class="nc" id="L670">        }</span>
<span class="nc" id="L671">      }</span>
    };
<span class="nc" id="L673">    searchThread.start();</span>
<span class="nc" id="L674">  }</span>

  private void returnToValidState(final String pattern, final TRegexGUITreeVisitor visitor, final List&lt;TreeFromFile&gt; trees) {
<span class="nc" id="L677">    SwingUtilities.invokeLater(() -&gt; {</span>
<span class="nc" id="L678">      int numUniqueMatches = 0;</span>
<span class="nc bnc" id="L679" title="All 2 branches missed.">      if (trees.size() &gt; 0) {</span>
<span class="nc" id="L680">        numUniqueMatches = visitor.numUniqueMatches();</span>
      }
<span class="nc" id="L682">      updateFoundStats(pattern, trees.size(), numUniqueMatches);</span>
<span class="nc" id="L683">      MatchesPanel.getInstance().setMatches(trees, visitor.getMatchedParts());</span>
<span class="nc" id="L684">      useProgressBar(false);</span>
<span class="nc" id="L685">      setTsurgeonState(false);</span>
<span class="nc" id="L686">    });</span>
<span class="nc" id="L687">  }</span>

  public void setScriptAndPattern(String tregexPatternString, String tsurgeonScriptString) {
<span class="nc" id="L690">    this.tregexPattern.setText(tregexPatternString);</span>
<span class="nc" id="L691">    this.tsurgeonScript.setText(tsurgeonScriptString);</span>
<span class="nc" id="L692">  }</span>

  private void addRecentTregexPattern(String pattern) {
    // If pattern already exists, just move it to the top of the list
<span class="nc" id="L696">    int existingIndex = recentTregexPatternsModel.getIndexOf(pattern);</span>
<span class="nc bnc" id="L697" title="All 2 branches missed.">    if (existingIndex != -1) {</span>
<span class="nc" id="L698">      recentTregexPatternsModel.removeElementAt(existingIndex);</span>
<span class="nc" id="L699">      recentTregexPatternsModel.insertElementAt(pattern, 0);</span>
<span class="nc" id="L700">      recentTregexPatterns.setSelectedIndex(0);</span>

<span class="nc" id="L702">      return;</span>
    }

<span class="nc bnc" id="L705" title="All 2 branches missed.">    if(recentTregexPatternsModel.getSize() &gt;= numRecentPatterns) {</span>
<span class="nc" id="L706">      recentTregexPatternsModel.removeElementAt(numRecentPatterns - 1);</span>
    }
<span class="nc" id="L708">    recentTregexPatternsModel.insertElementAt(pattern,0);</span>
<span class="nc" id="L709">    recentTregexPatterns.setSelectedIndex(0);</span>
<span class="nc" id="L710">    recentTregexPatterns.revalidate();</span>
<span class="nc" id="L711">  }</span>

  public void setNumRecentPatterns(int n) {
<span class="nc" id="L714">    numRecentPatterns = n;</span>
    //shrink down the number of recent patterns if necessary
<span class="nc bnc" id="L716" title="All 2 branches missed.">    while(recentTregexPatternsModel.getSize() &gt; n) {</span>
<span class="nc" id="L717">      int lastIndex = recentTregexPatternsModel.getSize() - 1;</span>
<span class="nc" id="L718">      recentTregexPatternsModel.removeElementAt(lastIndex);</span>
<span class="nc" id="L719">    }</span>
<span class="nc" id="L720">  }</span>


  /**
   * Check all active treebanks to find the trees that match the given pattern when interpreted
   * as a tregex pattern.
   *
   * @param patternString string version of the tregex pattern you wish to match
   * @param t The thread we are running on
   * @return tree visitor that contains the trees that were matched as well as the parts of those trees that matched
   */
  private TRegexGUITreeVisitor getMatchTreeVisitor(String patternString, Thread t) {
<span class="nc" id="L732">    TRegexGUITreeVisitor vis = null;</span>
    try {
<span class="nc" id="L734">      TregexPattern pattern = compiler.compile(patternString);</span>
<span class="nc" id="L735">      vis = new TRegexGUITreeVisitor(pattern); //handles);</span>
<span class="nc" id="L736">      List&lt;FileTreeNode&gt; treebanks = FilePanel.getInstance().getActiveTreebanks();</span>
<span class="nc" id="L737">      double multiplier = 100.0/treebanks.size();</span>
<span class="nc" id="L738">      int treebankNum = 1;</span>
<span class="nc bnc" id="L739" title="All 2 branches missed.">      for (FileTreeNode treebank : treebanks) {</span>
<span class="nc bnc" id="L740" title="All 2 branches missed.">        if (t.isInterrupted()) { //get out as quickly as possible if interrupted</span>
<span class="nc" id="L741">          t.interrupt();</span>
          // cdm 2008: I added here resetting the buttons or else it didn't seem to happen; not quite sure this is the right place to do it but.
<span class="nc" id="L743">          SwingUtilities.invokeLater(() -&gt; {</span>
<span class="nc" id="L744">            setTregexState(false);</span>
<span class="nc" id="L745">            InputPanel.this.searchThread = null;</span>
<span class="nc" id="L746">          });</span>
<span class="nc" id="L747">          return vis;</span>
        }
<span class="nc" id="L749">        vis.setFilename(treebank.getFilename().intern());</span>
<span class="nc" id="L750">        treebank.getTreebank().apply(vis);</span>
<span class="nc" id="L751">        updateProgressBar(multiplier*treebankNum++);</span>
<span class="nc" id="L752">      }</span>
<span class="nc" id="L753">    } catch (OutOfMemoryError oome) {</span>
<span class="nc" id="L754">      vis = null;</span>
<span class="nc" id="L755">      doError(&quot;Sorry, search aborted as out of memory.\nTry either running Tregex with more memory or sticking to searches that don't produce thousands of matches.&quot;, oome);</span>
<span class="nc" id="L756">    } catch (Exception e) {</span>
<span class="nc" id="L757">      doError(&quot;Sorry, there was an error compiling or running the Tregex pattern.  Please press Help if you need assistance.&quot;, e);</span>
<span class="nc" id="L758">    }</span>
<span class="nc" id="L759">    return vis;</span>
  }


  /**
   * Called when a pattern cannot be compiled or some other error occurs; resets gui to valid state.
   * Thread safe.
   *
   * @param txt Error message text (friendly text appropriate for users)
   * @param e The exception that caused the problem
   */
  public void doError(final String txt, final Throwable e) {
<span class="nc" id="L771">    SwingUtilities.invokeLater(() -&gt; {</span>
<span class="nc bnc" id="L772" title="All 4 branches missed.">      String extraData = e.getLocalizedMessage() != null ? e.getLocalizedMessage(): (e.getClass() != null) ? e.getClass().toString(): &quot;&quot;;</span>
<span class="nc" id="L773">      JOptionPane.showMessageDialog(InputPanel.this, txt + '\n' + extraData, &quot;Tregex Error&quot;, JOptionPane.ERROR_MESSAGE);</span>
<span class="nc" id="L774">      e.printStackTrace(); // send to stderr for debugging</span>
<span class="nc" id="L775">      useProgressBar(false);</span>
<span class="nc" id="L776">      updateFoundStats(null, 0, 0);</span>
<span class="nc" id="L777">    });</span>
<span class="nc" id="L778">  }</span>

  /**
   * Thread safe way to update how much progress we've made on the search so far
   * @param progress Percentage of the way through that we are.
   */
  public void updateProgressBar(final double progress) {
<span class="nc bnc" id="L785" title="All 2 branches missed.">    if(progressBar == null)</span>
<span class="nc" id="L786">      return;</span>
<span class="nc" id="L787">    SwingUtilities.invokeLater(() -&gt; progressBar.setValue((int) progress));</span>
<span class="nc" id="L788">  }</span>


  /**
   * Simple class for storing history objects that go nicely into a toString for saving
   * @author rafferty
   *
   */
  public static class HistoryEntry {

    private final String pattern;
    private final int numTreesMatched;
    private final int numMatches;

<span class="nc" id="L802">    public HistoryEntry(String pattern, int numTreesMatched, int numMatches) {</span>
<span class="nc" id="L803">      this.pattern = pattern;</span>
<span class="nc" id="L804">      this.numTreesMatched = numTreesMatched;</span>
<span class="nc" id="L805">      this.numMatches = numMatches;</span>
<span class="nc" id="L806">    }</span>

    /**
     * Returns an array with pattern as the first entry, numTreesMatched as the second, and numMatches as the third
     * @return An array with pattern as the first entry, numTreesMatched as the second, and numMatches as the third
     */
    public Object[] toArray() {
<span class="nc" id="L813">      Object[] array = new Object[3];</span>
<span class="nc" id="L814">      array[0] = pattern;</span>
<span class="nc" id="L815">      array[1] = numTreesMatched;</span>
<span class="nc" id="L816">      array[2] = numMatches;</span>
<span class="nc" id="L817">      return array;</span>
    }

    public static String[] columnNamesArray() {
<span class="nc" id="L821">      String[] names = {&quot;Pattern&quot;,&quot;Trees Matched&quot;, &quot;Total Matches&quot;};</span>
<span class="nc" id="L822">      return names;</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L827">      return pattern + '\t' + numTreesMatched + '\t' + numMatches + '\t';</span>
    }

    /**
     * Gets the string header indicating the fields included in a HistoryEntry string representation
     * @return A String header
     */
    public static String header() {
<span class="nc" id="L835">      return &quot;pattern\tnumTreesMatched\tnumMatches&quot;;</span>
    }

  } // end class HistoryEntry


  public static class TRegexGUITreeVisitor implements TreeVisitor {

    private int totalMatches; // = 0;
    private final TregexPattern p;
    private final List&lt;TreeFromFile&gt; matchedTrees;
    private final Map&lt;TreeFromFile,List&lt;Tree&gt;&gt; matchedParts;
<span class="nc" id="L847">    private String filename = &quot;&quot;;</span>


<span class="nc" id="L850">    TRegexGUITreeVisitor(TregexPattern p) { //String[] handles) {</span>
<span class="nc" id="L851">      this.p = p;</span>
      //this.handles = handles;
<span class="nc" id="L853">      matchedTrees = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L854">      matchedParts = Generics.newHashMap();</span>
<span class="nc" id="L855">    }</span>

    public Map&lt;TreeFromFile,List&lt;Tree&gt;&gt; getMatchedParts() {
<span class="nc" id="L858">      return matchedParts;</span>
    }

    public void visitTree(Tree t) {
<span class="nc" id="L862">      int numMatches = 0;</span>
<span class="nc" id="L863">      TregexMatcher match = p.matcher(t);</span>
<span class="nc" id="L864">      List&lt;Tree&gt; matchedPartList = null; // initialize lazily, since usually most trees don't match!</span>
<span class="nc bnc" id="L865" title="All 2 branches missed.">      while (match.find()) {</span>
<span class="nc" id="L866">        Tree curMatch = match.getMatch();</span>
        //System.out.println(&quot;Found match is: &quot; + curMatch);
<span class="nc bnc" id="L868" title="All 2 branches missed.">        if (matchedPartList == null) matchedPartList = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L869">        matchedPartList.add(curMatch);</span>
<span class="nc" id="L870">        numMatches++;</span>
<span class="nc" id="L871">      } // end while match.find()</span>
<span class="nc bnc" id="L872" title="All 2 branches missed.">      if(numMatches &gt; 0) {</span>
<span class="nc" id="L873">        TreeFromFile tff = new TreeFromFile(t, filename);</span>
<span class="nc" id="L874">        matchedTrees.add(tff);</span>
<span class="nc" id="L875">        matchedParts.put(tff,matchedPartList);</span>
<span class="nc" id="L876">        totalMatches += numMatches;</span>
      }
<span class="nc" id="L878">    } // end visitTree</span>

    /**
     * Method for returning the number of matches found in the last tree
     * visited by this tree visitor.
     * @return number of matches found in previous tree
     */
    public int numUniqueMatches() {
<span class="nc" id="L886">      return totalMatches;</span>
    }

    public List&lt;TreeFromFile&gt; getMatches() {
<span class="nc" id="L890">      return matchedTrees;</span>
    }

    public String getFilename() {
<span class="nc" id="L894">      return filename;</span>
    }

    public void setFilename(String curFilename) {
<span class="nc" id="L898">      this.filename = curFilename.intern();</span>
<span class="nc" id="L899">    }</span>

    public TregexPattern getPattern() {
<span class="nc" id="L902">      return p;</span>
    }

  } // end class TRegexTreeVisitor


  private void displayHelp() {
<span class="nc bnc" id="L909" title="All 2 branches missed.">    if (helpFrame != null) {</span>
<span class="nc" id="L910">      helpFrame.setVisible(true);</span>
    } else {
<span class="nc" id="L912">      helpFrame = new JFrame(&quot;Tregex Help...&quot;);</span>
      //JPanel helpPanel = new JPanel();
<span class="nc" id="L914">      JEditorPane helpText = new JEditorPane();</span>
<span class="nc" id="L915">      helpText.setContentType(&quot;text/html&quot;);</span>
      // StringBuffer s = new StringBuffer();
      // s.append(htmlHelp);
<span class="nc" id="L918">      helpText.setText(htmlHelp);</span>
<span class="nc" id="L919">      helpText.setEditable(false);</span>
      //helpPanel.add(helpText);

<span class="nc" id="L922">      JScrollPane scroller = new JScrollPane(helpText);</span>
<span class="nc" id="L923">      helpText.setCaretPosition(0);</span>
<span class="nc" id="L924">      scroller.setPreferredSize(new Dimension(500,500));</span>
<span class="nc" id="L925">      helpFrame.add(scroller);</span>
<span class="nc" id="L926">      helpFrame.pack();</span>
<span class="nc" id="L927">      helpFrame.setBackground(Color.WHITE);</span>
<span class="nc" id="L928">      helpFrame.setVisible(true);</span>
      //helpFrame.repaint();
    }
<span class="nc" id="L931">  }</span>

  private void displayTsurgeonHelp() {
<span class="nc bnc" id="L934" title="All 2 branches missed.">    if(tsurgeonHelpFrame != null) {</span>
<span class="nc" id="L935">      tsurgeonHelpFrame.setVisible(true);</span>
    } else {
<span class="nc" id="L937">      tsurgeonHelpFrame = new JFrame(&quot;TSurgeon Help...&quot;);</span>
<span class="nc" id="L938">      JEditorPane helpText = new JEditorPane();</span>
<span class="nc" id="L939">      helpText.setContentType(&quot;text/html&quot;);</span>
      // StringBuffer s = new StringBuffer();
      // s.append(htmlTsurgeonHelp);
<span class="nc" id="L942">      helpText.setText(htmlTsurgeonHelp);</span>
<span class="nc" id="L943">      helpText.setEditable(false);</span>

<span class="nc" id="L945">      JScrollPane scroller = new JScrollPane(helpText);</span>
<span class="nc" id="L946">      helpText.setCaretPosition(0);</span>
<span class="nc" id="L947">      scroller.setPreferredSize(new Dimension(500,500));</span>
<span class="nc" id="L948">      tsurgeonHelpFrame.add(scroller);</span>
<span class="nc" id="L949">      tsurgeonHelpFrame.pack();</span>
<span class="nc" id="L950">      tsurgeonHelpFrame.setBackground(Color.WHITE);</span>
<span class="nc" id="L951">      tsurgeonHelpFrame.setVisible(true);</span>
    }
<span class="nc" id="L953">  }</span>

  //help text for tsurgeon is basically just the javadoc main comment for tsurgeon
  private static final String htmlTsurgeonHelp = ( &quot;&lt;html&gt;&lt;body&gt;&quot; +
  &quot;&lt;h1&gt;Tsurgeon Script Syntax and Uses&lt;/h1&gt;&lt;p&gt;Tsurgeon is a tool that can modify the trees found by Tregex searches. &quot; +
  &quot; These modifications are specified via a script language, and the script language allows one to, among other&quot; +
  &quot; operations, rename, delete, move, and insert nodes in a tree.  &quot; +
  &quot; For example, if you want to excise an SBARQ node whenever it is the parent of an SQ node, and rename the SQ node &quot; +
  &quot; to S, your input would look like this:&quot; +
  &quot;&lt;p&gt;&quot; +
  &quot;Tregex pattern: &quot; +
  &quot; &lt;blockquote&gt;&quot; +
  &quot; &lt;code&gt;&quot; +
  &quot;    SBARQ=n1 &amp;lt; SQ=n2&lt;br&gt;&lt;/code&gt;&quot; +
  &quot;    &lt;br&gt;&quot; +
  &quot; &lt;/blockquote&gt;&quot; +
  &quot;TSurgeon script: &quot; +
  &quot; &lt;blockquote&gt;&quot; +
  &quot;&lt;code&gt;&quot; +
  &quot;    excise n1 n1 &lt;br&gt;&quot; +
  &quot;    relabel n2 S&quot; +
  &quot; &lt;/code&gt;&quot; +
  &quot; &lt;/blockquote&gt;&quot; +
  &quot; &lt;h2&gt;Legal operation syntax:&lt;/h2&gt;&quot; +
  &quot; &lt;dl&gt;&quot; +
  &quot; &lt;dt&gt;&lt;code&gt;delete &amp;#60;name&amp;#62;+&lt;/code&gt;&lt;/dt&gt;  &lt;dd&gt;Deletes one or more nodes and everything below them, with names that were given in the TregexPattern (e.g., VP=x).&lt;/dd&gt;&quot; +
  &quot; &lt;dt&gt;&lt;code&gt;prune &amp;#60;name&amp;#62;+&lt;/code&gt;&lt;/dt&gt;  &lt;dd&gt;Like delete, but if, after the pruning, the parent has no children anymore, the parent is pruned too.&lt;/dd&gt;&quot; +
  &quot; &lt;dt&gt;&lt;code&gt;excise &amp;#60;name1&amp;#62; &amp;#60;name2&amp;#62;&lt;/code&gt;&lt;/dt&gt;&quot; +
  &quot;   &lt;dd&gt;The name1 node should either dominate or be the same as the name2 node.  This excises out everything from&quot; +
  &quot; name1 to name2 inclusive.  All the children of name2 go into the parent of name1, where name1 was.&lt;/dd&gt;&quot; +
  &quot; &lt;dt&gt;&lt;code&gt;relabel &amp;#60;name&amp;#62; &amp;#60;new-label&amp;#62;&lt;/code&gt;&lt;/dt&gt; &lt;dd&gt;Relabels the node to have the new label.&quot; +
  &quot;    There are three possible forms: &lt;code&gt;relabel nodeX VP&lt;/code&gt; - for changing a node label to an alphanumeric string, &quot; +
  &quot;    &lt;code&gt;relabel nodeX /''/&lt;/code&gt; - for relabeling a node to something that isn't a valid identifier without quoting, and &quot; +
  &quot;    &lt;code&gt;relabel nodeX /^VB(.*)$/verb\\/$1/&lt;/code&gt; - for regular expression based relabeling. In the last case, all matches &quot; +
  &quot;    of the regular expression against the node label are replaced with the replacement String.  This has the semantics of&quot; +
  &quot;    Java/Perl's replaceAll: you may use capturing groups and put them in replacements with $n. Also, as in the example, &quot; +
  &quot;    you can escape a slash in the middle of the second and third forms with \\/ and \\\\.&lt;/dd&gt;&quot; +
  &quot; &lt;dt&gt;&lt;code&gt;insert &amp;#60;name&amp;#62; &amp;#60;position&amp;#62;&lt;/code&gt;&lt;/dt&gt;&quot; +
  &quot; &lt;dt&gt;&lt;code&gt;insert &amp;lt;tree&amp;gt; &amp;#60;position&amp;#62;&lt;/code&gt;&lt;/dt&gt;&lt;dd&gt;Inserts the named node or tree into the position specified. (giving a tree rather than a node is also valid)&lt;/dd&gt;&quot; +
  &quot; &lt;dt&gt;&lt;code&gt;move &amp;#60;name&amp;#62; &amp;#60;position&amp;#62;&lt;/code&gt;&lt;/dt&gt; &lt;dd&gt;moves the named node into the specified position&lt;/dd&gt;&quot; +
  &quot; &lt;dd&gt;&lt;dl&gt;&lt;dt&gt;Right now the  only ways to specify position are:&lt;/dt&gt; &quot; ) +

  &quot;      &lt;dd&gt;&lt;code&gt;$+ &amp;#60;name&amp;#62;&lt;/code&gt;     the left sister of the named node&lt;/dd&gt;&quot; +
  &quot;      &lt;dd&gt;&lt;code&gt;$- &amp;#60;name&amp;#62;&lt;/code&gt;     the right sister of the named node&lt;/dd&gt;&quot; +
  &quot;      &lt;dd&gt;&lt;code&gt;&amp;gt;i&lt;/code&gt; the &lt;i&gt;i&lt;/i&gt;&lt;sup&gt;th&lt;/sup&gt; daughter of the named node&lt;/dd&gt;&quot; +
  &quot;      &lt;dd&gt;&lt;code&gt;&amp;gt;-i&lt;/code&gt; the &lt;i&gt;i&lt;/i&gt;&lt;sup&gt;th&lt;/sup&gt; daughter, counting from the right, of the named node.&lt;/dd&gt;&lt;/dl&gt;&lt;/dd&gt;&quot; +
  &quot; &lt;dt&gt;&lt;code&gt;replace &amp;#60;name1&amp;#62; &amp;#60;tree&amp;#62;&lt;/code&gt;&lt;/dt&gt;&quot; +
  &quot; &lt;dt&gt;&lt;code&gt;replace &amp;#60;name1&amp;#62; &amp;#60;name2&amp;#62;&lt;/code&gt;&lt;/dt&gt; &lt;dd&gt;deletes name1 and inserts a tree or a copy of name2 in its place.&lt;/dd&gt;&quot; +
  &quot; &lt;dt&gt;&lt;code&gt;createSubtree &amp;#60;auxiliary-tree-or-label&amp;#62; &amp;#60;name1&amp;#62; [&amp;#60;name2&amp;#62;]&lt;/code&gt;&lt;/dt&gt;  &lt;dd&gt;Create a subtree out of all the nodes from &lt;code&gt;&amp;#60;name1&amp;#62;&lt;/code&gt; through &lt;code&gt;&amp;#60;name2&amp;#62;&lt;/code&gt;.The subtree is moved to the foot of the given auxiliary tree, and the tree is inserted where the nodes of the subtree used to reside. If a simple label is provided as the first argument, the subtree is given a single parent with a name corresponding to the label. To limit the operation to just one node, elide &lt;code&gt;&amp;#60;name2&amp;#62;&lt;/code&gt;.&lt;/dd&gt;&quot; +
  &quot; &lt;dt&gt;&lt;code&gt;adjoin &amp;#60;auxiliary_tree&amp;#62; &amp;lt;name&amp;gt;&lt;/code&gt;&lt;/dt&gt; &lt;dd&gt;Adjoins the specified auxiliary tree into the named node.  The daughters of the target node will become the daughters of the foot of the auxiliary tree.  (The node &lt;code&gt;name&lt;/code&gt; is no longer accessible.)&lt;/dd&gt;&quot; +
  &quot; &lt;dt&gt;&lt;code&gt;adjoinH &amp;#60;auxiliary_tree&amp;#62; &amp;lt;name&amp;gt;&lt;/code&gt;&lt;/dt&gt; &lt;dd&gt;Similar to adjoin, but preserves the target node and makes it the root of &amp;lt;tree&amp;gt;. (It is still accessible as &lt;code&gt;name&lt;/code&gt;.  The root of the auxiliary tree is ignored.)&lt;/dd&gt;&quot; +
  &quot; &lt;dt&gt;&lt;code&gt;adjoinF &amp;#60;auxiliary_tree&amp;#62; &amp;lt;name&amp;gt;&lt;/code&gt;&lt;/dt&gt; &lt;dd&gt; Similar to adjoin, but preserves the target node and makes it the foot of &amp;lt;tree&amp;gt;.&quot; +
  &quot;  (It is still accessible as &lt;code&gt;name&lt;/code&gt;, and retains its status as parent of its children. The foot of the auxiliary tree is ignored.)&lt;/dd&gt;&quot; +
  &quot; &lt;dt&gt;&lt;code&gt;coindex &amp;#60;name1&amp;#62; &amp;#60;name2&amp;#62; ... &amp;#60;nameM&amp;#62; &lt;/code&gt;&lt;/dt&gt;  &lt;dd&gt;Puts a (Penn Treebank style) coindexation suffix of the form \&quot;-N\&quot; on&quot; +
  &quot;  each of nodes name_1 through name_m.  The value of N will be &quot;+
  &quot;  automatically generated in reference to the existing coindexations &quot; +
  &quot;  in the tree, so that there is never an accidental clash of &quot; +
  &quot;  indices across things that are not meant to be coindexed.&lt;/dd&gt;&quot;+
  &quot; &lt;/dl&gt; &quot; +
  &quot;&lt;h2&gt;Syntax for trees to be inserted or adjoined:&lt;/h2&gt;&quot; +
  &quot;A tree to be adjoined in can be specified with LISP-like &quot; +
  &quot;parenthetical-bracketing tree syntax such as those used for the Penn &quot; +
  &quot;Treebank.  For example, for the NP \&quot;the dog\&quot; to be inserted you might &quot; +
  &quot;use the syntax&quot; +
  &quot;&lt;br&gt;&quot; +
  &quot; &lt;blockquote&gt;&quot; +
  &quot; &lt;code&gt;&quot; +
  &quot;(NP (Det the) (N dog))&quot; +
  &quot; &lt;/code&gt;&quot; +
  &quot;&lt;/blockquote&gt;&quot; +
  &quot;&lt;br&gt;&quot; +
  &quot;That's all that is necessary for a tree to be inserted.  Auxiliary trees &quot; +
  &quot;(a la Tree Adjoining Grammar) must also have exactly one frontier node &quot; +
  &quot;ending in the character \&quot;@\&quot;, which marks it as the \&quot;foot\&quot; node for &quot; +
  &quot;adjunction.  Final instances of the character \&quot;@\&quot; in terminal node labels &quot; +
  &quot;will be removed from the actual label of the tree. &quot; +
  &quot;&lt;p&gt;&quot; +
  &quot;For example, if you wanted to adjoin the adverb \&quot;breathlessly\&quot; into a &quot; +
  &quot;VP, you might specify the following auxiliary tree: &quot; +
  &quot;&lt;br&gt;&quot; +
  &quot; &lt;blockquote&gt;&quot; +
  &quot; &lt;code&gt;&quot; +
  &quot;(VP (Adv breathlessly VP@ )&quot; +
  &quot; &lt;/code&gt;&quot; +
  &quot;&lt;/blockquote&gt;&quot; +
  &quot;&lt;br&gt;&quot; +
  &quot;All other instances of \&quot;@\&quot; in terminal nodes must be escaped (i.e., &quot; +
  &quot;appear as \\@); this escaping will be removed by tsurgeon. &quot; +
  &quot;&lt;p&gt;&quot; +
  &quot;In addition, any node of a tree can be named (the same way as in &quot; +
  &quot;tregex), by appending =&lt;name&gt; to the node label.  That name can be &quot; +
  &quot;referred to by subsequent Tsurgeon operations triggered by the same &quot; +
  &quot;match.  All other instances of \&quot;=\&quot; in node labels must be escaped &quot; +
  &quot;(i.e., appear as \\=); this escaping will be removed by Tsurgeon.  For &quot; +
  &quot;example, if you want to insert an NP trace somewhere and coindex it &quot; +
  &quot;with a node named \&quot;antecedent\&quot; you might say: &quot; +
  &quot;&lt;br&gt;&quot; +
  &quot; &lt;blockquote&gt;&quot; +
  &quot; &lt;code&gt;&quot; +
  &quot;insert (NP (-NONE- *T*=trace)) &lt;node-location&gt;&quot; +
  &quot;&lt;br&gt;&quot;+
  &quot;coindex trace antecedent $ &quot; +
  &quot; &lt;/blockquote&gt;&quot; +
  &quot; &lt;/code&gt;&quot; +
  &quot;&lt;h2&gt;Tips and Tricks&lt;/h2&gt;&quot; +
  &quot;&lt;ol&gt;&quot; +
  &quot;&lt;li&gt;Be aware of how insert and replace work: Both of these operations look for matches again &quot; +
  &quot;after being applied.  This can cause infinite loops if your Tregex pattern continues to match the same &quot; +
  &quot;configuration regardless of how many times you insert your tree.  To avoid this, write Tregex patterns &quot; +
  &quot;that match before but not after an insert or move is applied.  For example, you could specify that the node &quot; +
  &quot;not have an NP right sister in the Tregex match if your insert involved inserting an NP as the right sister &quot; +
  &quot;of the node.&lt;/li&gt;&quot; +
  &quot;&lt;li&gt;Use the cancel button when necessary: If you do end up writing an operation that might have cycles and &quot; +
  &quot;the Tregex GUI seems to be stuck in an infinite loop, press Cancel to stop the operation and recheck your Tregex pattern &quot; +
  &quot;and Tsurgeon commands.&lt;/li&gt;&quot; +
  &quot;&lt;li&gt;Read the README: Three README files were included with this package - README-tregex.txt, README-tsurgeon.txt, &quot; +
  &quot;and README-gui.txt.  The Tsurgeon README includes examples of each operation as well as notes on the specifics of &quot; +
  &quot;writing each type of operation.&lt;/li&gt;&quot; +
  &quot;&lt;/ol&gt;&lt;/body&gt;&lt;/html&gt;&quot;;


  //help text is basically just the javadoc main comment for TregexPattern
  private static final String htmlHelp = ( &quot;&lt;html&gt;&lt;h1&gt;Tregex Pattern Syntax and Uses&lt;/h1&gt;&lt;p&gt;&quot; +
  &quot; Tregex is a program for finding syntactic trees of interest in a collection of parsed sentences &quot; +
  &quot; (a treebank).   For matching, it uses a pattern language for specifying partial syntactic tree configurations. &quot; +
  &quot; For example, the pattern &lt;code&gt;VP &amp;lt; VBD&lt;/code&gt; matches verb phrases headed&quot; +
  &quot; by a past tense verb. &quot; +
  &quot; Using a Tregex pattern, you can find only those trees that match the pattern you're &quot; +
  &quot; looking for. To get started, you first use the &lt;code&gt;File&lt;/code&gt; menu to load a treebank of parsed trees &quot; +
  &quot; (not supplied with Tregex) and then you enter a pattern and press &lt;code&gt;Search&lt;/code&gt;. &quot; +
  &quot; If your Treebank is not in UTF-8/ASCII or not in Penn Treebank format, you should&quot; +
  &quot; also specify the treebank format and encoding under the &lt;code&gt;Preferences&lt;/code&gt; menu item &lt;i&gt;before&lt;/i&gt; loading the treebank. &quot; +
  &quot; &lt;p&gt;&quot; +
  &quot;  The following table shows the symbols that are allowed in the pattern,&quot; +
  &quot; and below there is more information about using these patterns.&quot; +
  &quot;&lt;p&gt; &lt;table border = \&quot;1\&quot;&gt; &lt;tr&gt;&lt;th&gt;Symbol&lt;th&gt;Meaning &quot; +
  &quot; &lt;tr&gt;&lt;td&gt;A &amp;lt;&amp;lt; B &lt;td&gt;A dominates B&quot; +
  &quot; &lt;tr&gt;&lt;td&gt;A &amp;gt;&amp;gt; B &lt;td&gt;A is dominated by B&quot; +
  &quot; &lt;tr&gt;&lt;td&gt;A &amp;lt; B &lt;td&gt;A immediately dominates B&quot; +
  &quot; &lt;tr&gt;&lt;td&gt;A &amp;gt; B &lt;td&gt;A is immediately dominated by B&quot; +
  &quot; &lt;tr&gt;&lt;td&gt;A &amp;#36; B &lt;td&gt;A is a sister of B (and not equal to B)&quot; +
  &quot; &lt;tr&gt;&lt;td&gt;A .. B &lt;td&gt;A precedes B&quot; +
  &quot;&lt;tr&gt;&lt;td&gt;A . B &lt;td&gt;A immediately precedes B&quot; +
  &quot;&lt;tr&gt;&lt;td&gt;A ,, B &lt;td&gt;A follows B&quot; +
  &quot;&lt;tr&gt;&lt;td&gt;A , B &lt;td&gt;A immediately follows B&quot; +
  &quot;&lt;tr&gt;&lt;td&gt;A &amp;lt;&amp;lt;, B &lt;td&gt;B is a leftmost descendant of A&quot; +
  &quot;&lt;tr&gt;&lt;td&gt;A &amp;lt;&amp;lt;- B &lt;td&gt;B is a rightmost descendant of A&quot; +
  &quot;&lt;tr&gt;&lt;td&gt;A &amp;gt;&amp;gt;, B &lt;td&gt;A is a leftmost descendant of B&quot; +
  &quot;&lt;tr&gt;&lt;td&gt;A &amp;gt;&amp;gt;- B &lt;td&gt;A is a rightmost descendant of B&quot; +
  &quot;&lt;tr&gt;&lt;td&gt;A &amp;lt;, B &lt;td&gt;B is the first child of A&quot; +
  &quot;&lt;tr&gt;&lt;td&gt;A &amp;gt;, B &lt;td&gt;A is the first child of B&quot; +
  &quot;&lt;tr&gt;&lt;td&gt;A &amp;lt;- B &lt;td&gt;B is the last child of A&quot; +
  &quot;&lt;tr&gt;&lt;td&gt;A &amp;gt;- B &lt;td&gt;A is the last child of B&quot; +
  &quot;&lt;tr&gt;&lt;td&gt;A &amp;lt;` B &lt;td&gt;B is the last child of A&quot; +
  &quot;&lt;tr&gt;&lt;td&gt;A &amp;gt;` B &lt;td&gt;A is the last child of B&quot; +
  &quot;&lt;tr&gt;&lt;td&gt;A &amp;lt;i B &lt;td&gt;B is the ith child of A (i &gt; 0)&quot; +
  &quot;&lt;tr&gt;&lt;td&gt;A &amp;gt;i B &lt;td&gt;A is the ith child of B (i &gt; 0)&quot; +
  &quot;&lt;tr&gt;&lt;td&gt;A &amp;lt;-i B &lt;td&gt;B is the ith-to-last child of A (i &gt; 0)&quot; +
  &quot;&lt;tr&gt;&lt;td&gt;A &amp;gt;-i B &lt;td&gt;A is the ith-to-last child of B (i &gt; 0)&quot; +
  &quot;&lt;tr&gt;&lt;td&gt;A &amp;lt;: B &lt;td&gt;B is the only child of A&quot; +
  &quot;&lt;tr&gt;&lt;td&gt;A &amp;gt;: B &lt;td&gt;A is the only child of B&quot; +
  &quot;&lt;tr&gt;&lt;td&gt;A &amp;lt;&amp;lt;: B &lt;td&gt;A dominates B via an unbroken chain (length &gt; 0) of unary local trees.&quot; +
  &quot;&lt;tr&gt;&lt;td&gt;A &amp;gt;&amp;gt;: B &lt;td&gt;A is dominated by B via an unbroken chain (length &gt; 0) of unary local trees.&quot; +
  &quot;&lt;tr&gt;&lt;td&gt;A &amp;#36;++ B &lt;td&gt;A is a left sister of B (same as &amp;#36;.. for context-free trees)&quot; +
  &quot;&lt;tr&gt;&lt;td&gt;A &amp;#36;-- B &lt;td&gt;A is a right sister of B (same as &amp;#36;,, for context-free trees)&quot; +
  &quot;&lt;tr&gt;&lt;td&gt;A &amp;#36;+ B &lt;td&gt;A is the immediate left sister of B (same as &amp;#36;. for context-free trees)&quot; +
  &quot;&lt;tr&gt;&lt;td&gt;A &amp;#36;- B &lt;td&gt;A is the immediate right sister of B (same as &amp;#36;, for context-free trees)&quot; +
  &quot;&lt;tr&gt;&lt;td&gt;A &amp;#36;.. B &lt;td&gt;A is a sister of B and precedes B&quot; +
  &quot;&lt;tr&gt;&lt;td&gt;A &amp;#36;,, B &lt;td&gt;A is a sister of B and follows B&quot; +
  &quot;&lt;tr&gt;&lt;td&gt;A &amp;#36;. B &lt;td&gt;A is a sister of B and immediately precedes B&quot; +
  &quot;&lt;tr&gt;&lt;td&gt;A &amp;#36;, B &lt;td&gt;A is a sister of B and immediately follows B&quot; +
  &quot;&lt;tr&gt;&lt;td&gt;A &amp;lt;+(C) B &lt;td&gt;A dominates B via an unbroken chain of (zero or more) nodes matching description C&quot; +
  &quot;&lt;tr&gt;&lt;td&gt;A &amp;gt;+(C) B &lt;td&gt;A is dominated by B via an unbroken chain of (zero or more) nodes matching description C&quot; +
  &quot;&lt;tr&gt;&lt;td&gt;A .+(C) B &lt;td&gt;A precedes B via an unbroken chain of (zero or more) nodes matching description C&quot; +
  &quot;&lt;tr&gt;&lt;td&gt;A ,+(C) B &lt;td&gt;A follows B via an unbroken chain of (zero or more) nodes matching description C&quot; +
  &quot;&lt;tr&gt;&lt;td&gt;A &amp;lt;&amp;lt;&amp;#35; B &lt;td&gt;B is a head of phrase A&quot; +
  &quot;&lt;tr&gt;&lt;td&gt;A &amp;gt;&amp;gt;&amp;#35; B &lt;td&gt;A is a head of phrase B&quot; +
  &quot;&lt;tr&gt;&lt;td&gt;A &amp;lt;&amp;#35; B &lt;td&gt;B is the immediate head of phrase A&quot; +
  &quot;&lt;tr&gt;&lt;td&gt;A &amp;gt;&amp;#35; B &lt;td&gt;A is the immediate head of phrase B&quot; +
  &quot;&lt;tr&gt;&lt;td&gt;A == B &lt;td&gt;A and B are the same node&quot; +
  &quot;&lt;tr&gt;&lt;td&gt;A : B&lt;td&gt;[this is a pattern-segmenting operator that places no constraints on the relationship between A and B]&quot; +
  &quot;&lt;/table&gt;&quot;) +

  (&quot; &lt;p&gt; Node label descriptions (represented by A, B, and C in the table above) &quot; +
  &quot; match either internal nodes or words in a sentence.  They can be plain strings, which much match labels&quot; +
  &quot; exactly, or regular expressions in regular expression slashes: /regex/.&quot; +
  &quot; Literal string matching proceeds as String equality.&quot;+
  &quot; In order to prevent ambiguity with other Tregex symbols, there are some restrictions &quot; +
  &quot; on characters in plain strings: you can use standard&quot; +
  &quot; \&quot;identifiers\&quot; - i.e., strings matching  [a-zA-Z]([a-zA-Z0-9_])* - &quot; +
  &quot; or any non-ASCII character, such as Arabic or Chinese letters.&quot; +
  &quot; If you want to use other symbols, you can do so by using a regular &quot; +
  &quot; expression instead of a string, for example /^,$/ for a comma. &quot; +
  &quot; Note that strings only match a complete node label, while regular expressions match &quot; +
  &quot; if they match anywhere inside the node label. &quot; +
  &quot; A disjunctive list of literal strings can be given separated by '|'.&quot; +
  &quot; The special string '__' (two underscores) can be used to match any&quot; +
  &quot; node.  (WARNING!!  Use of the '__' node description may seriously&quot; +
  &quot; slow down search.)  If a label description is preceded by '@', the&quot; +
  &quot; label will match any node whose &lt;em&gt;basicCategory&lt;/em&gt; matches the&quot; +
  &quot; description.  &lt;em&gt;NB: A single '@' thus scopes over a disjunction&quot; +
  &quot; specified by '|': @NP|VP means things with basic category NP or VP.&quot; +
  &quot; &lt;/em&gt; Label description regular expressions are matched as a Java regex&quot; +
  &quot;  &lt;code&gt;find()&lt;/code&gt;, as in Perl/tgrep;&quot; +
  &quot; you need to specify &lt;code&gt;^&lt;/code&gt; or &lt;code&gt;$&lt;/code&gt; to constrain matches&quot; +
  &quot; to the ends of node labels.&quot; +
  &quot; &lt;p&gt; &quot; +
  &quot; In a chain of relations, all relations are relative to the first node in &quot; +
  &quot; the chain. Nodes can be grouped using parentheses '(' and ')' to change this. &quot; +
  &quot; For example, &lt;code&gt; (S &amp;lt; VP &amp;lt; NP) &lt;/code&gt; means&quot; +
  &quot; \&quot;an S over a VP and also over an NP\&quot;.&quot; +
  &quot; If instead what you want is an S above a VP above an NP, you should write&quot; +
  &quot; \&quot;&lt;code&gt;S &amp;lt; (VP &amp;lt; NP)&lt;/code&gt;\&quot;.&quot; +
  &quot; The expression &lt;code&gt; S &amp;lt; (NP $++ VP) &lt;/code&gt; matches an S&quot; +
  &quot; over an NP, where the NP has a VP as a right sister.&quot;) +

  (&quot; &lt;p&gt;&lt;h3&gt;Boolean relational operators&lt;/h3&gt;&quot; +
  &quot; Relations can be combined using the '&amp;amp;' and '|' operators,&quot; +
  &quot; negated with the '!' operator, and made optional with the '?' operator.  Thus&quot; +
  &quot; &lt;code&gt; (NP &amp;lt; NN | &amp;lt; NNS) &lt;/code&gt; will match an NP node dominating either&quot; +
  &quot; an NN or an NNS.  &lt;code&gt; (NP &amp;gt; S &amp;amp; $++ VP) &lt;/code&gt; matches an NP that&quot; +
  &quot; is both under an S and has a VP as a right sister.&quot; +
  &quot; &lt;p&gt; Relations can be grouped using brackets '[' and ']'.  So the&quot; +
  &quot; expression&quot; +
  &quot; &lt;blockquote&gt;&quot; +
  &quot; &lt;code&gt; NP [&amp;lt; NN | &amp;lt; NNS] &amp;amp; &amp;gt; S &lt;/code&gt;&quot; +
  &quot; &lt;/blockquote&gt;&quot; +
  &quot; matches an NP that (1) dominates either an NN or an NNS, and (2) is under an S.  Without&quot; +
  &quot; brackets, &amp;amp; takes precidence over |, and equivalent operators are&quot; +
  &quot; left-associative.  Also note that &amp;amp; is the default combining operator if the&quot; +
  &quot; operator is omitted in a chain of relations, so that these two patterns are equivalent:&quot; +
  &quot; &lt;blockquote&gt;&quot; +
  &quot; &lt;code&gt; (S &amp;lt; VP &amp;lt; NP) &lt;/code&gt;&lt;br&gt;&quot; +
  &quot; &lt;code&gt; (S &amp;lt; VP &amp;amp; &amp;lt; NP) &lt;/code&gt;&quot; +
  &quot; &lt;/blockquote&gt;&quot; +
  &quot; As another example, &lt;code&gt; (VP &amp;lt; VV | &amp;lt; NP $ NP)&quot; +
  &quot; &lt;/code&gt; can be written explicitly as &lt;code&gt; (VP [&amp;lt; VV | [&amp;lt; NP &amp;amp; $ NP] ] )&quot; +
  &quot; &lt;/code&gt;.&quot; +
  &quot; &lt;p&gt; Relations can be negated with the '!' operator, in which case the&quot; +
  &quot; expression will match only if there is no node satisfying the relation.&quot; +
  &quot; For example &lt;code&gt; (NP !&amp;lt; NNP) &lt;/code&gt; matches only NPs not dominating&quot; +
  &quot; an NNP.  Label descriptions can also be negated with '!': (NP &amp;lt; !NNP|NNS) matches&quot; +
  &quot; NPs dominating some node that is not an NNP or an NNS.&quot; +
  &quot; &lt;p&gt; Relations can be made optional with the '?' operator.  This way the&quot; +
  &quot; expression will match even if the optional relation is not satisfied.  This is useful when used together&quot; +
  &quot;  with node naming (see below).&quot;) +

  &quot; &lt;p&gt;&lt;h3&gt;Basic Categories&lt;/h3&gt;&quot; +
  &quot; In order to consider only the \&quot;basic category\&quot; of a tree label,&quot; +
  &quot; i.e., to ignore functional tags or other annotations on the label,&quot; +
  &quot; prefix that node's description with the @ symbol.  For example&quot; +
  &quot; &lt;code&gt; (@NP &amp;lt; @/NN.?/) &lt;/code&gt;.  By default, the notion of basic category&quot; +
  &quot; works for Penn Treebank tree node labels.  This can only be used for individual nodes;&quot; +
  &quot; if you want all nodes to use the basic category, it would be more efficient&quot; +
  &quot; (for you and Tregex) to use a &lt;code&gt;TreeNormalizer&lt;/code&gt; to remove functional&quot; +
  &quot; tags before passing the tree to the TregexPattern. (In the GUI, a TreeNormalizer&quot; +
  &quot; can be part of the functionality of a TreeReader specified in Preferences.)&quot; +

  &quot; &lt;p&gt;&lt;h3&gt;Segmenting patterns&lt;/h3&gt;&quot; +
  &quot; The \&quot;:\&quot; operator allows you to segment a pattern into two pieces.  This can simplify your pattern writing.&quot; +
  &quot; The semantics is that both patterns must match a tree, but the match of the first pattern&quot; +
  &quot;  is returned as the matching node. For example, the pattern&quot; +
  &quot; &lt;blockquote&gt;&quot; +
  &quot;   S : NP&quot; +
  &quot; &lt;/blockquote&gt;&quot; +
  &quot; matches only those S nodes in trees that also have an NP node (somewhere in&quot; +
  &quot; the tree - it's location with respect to the S is unconstrained).&quot; +

  (&quot; &lt;p&gt;&lt;h3&gt;Naming nodes&lt;/h3&gt;&quot; +
  &quot; Nodes can be given names (a.k.a. handles) using '=', for example, &quot; +
  &quot; &lt;code&gt;ADJP=ap&lt;/code&gt;.  A named node will be stored in a&quot; +
  &quot; map that maps names to nodes so that if a match is found, the node&quot; +
  &quot; corresponding to the named node can be extracted from the map.  For&quot; +
  &quot; example &lt;code&gt; (NP &amp;lt; NNP=name) &lt;/code&gt; will match an NP dominating an NNP.&quot; +
  &quot; Node names have two purposes: they can be referred back to in the Tregex pattern, &quot; +
  &quot; and, programmatically, after a match is found, the map can be queried with the&quot; +
  &quot; name to retrieve the matched node using &lt;code&gt;TregexMatcher#getNode(String s)&lt;/code&gt;&quot; +
  &quot; with argument \&quot;name\&quot; (&lt;it&gt;not&lt;/it&gt; \&quot;=name\&quot;).&quot; +
  &quot; Note that you are not allowed to name a node that is under the scope of a negation operator (the semantics would&quot; +
  &quot; be unclear, since you can't store a node that never gets matched to).&quot; +
  &quot; Trying to do so will cause a &lt;code&gt;ParseException&lt;/code&gt; to be thrown. Named nodes &lt;em&gt;can&lt;/em&gt; be put within the scope of an optionality operator.&quot; +
  &quot; &lt;p&gt;Secondly, named nodes can be referred back to in a Tregex pattern.&quot; +
  &quot; A named node that refers back to a previous named node need not have a node&quot; +
  &quot; description -- this is known as \&quot;backreferencing\&quot;.  In this case, the expression&quot; +
  &quot; will match only when all instances of the same name get matched to the same tree node.&quot; +
  &quot; For example: the pattern&quot; +
  &quot; &lt;blockquote&gt;&quot; +
  &quot; &lt;code&gt; (@NP &amp;lt;, (@NP $+ (/,/ $+ (@NP $+ /,/=comma))) &amp;lt;- =comma) &lt;/code&gt;&quot; +
  &quot; &lt;/blockquote&gt;&quot; +
  &quot; matches only an NP dominating exactly the sequence &lt;code&gt;NP , NP ,&lt;/code&gt;&quot; +
  &quot; - the mother NP cannot have any other daughters. Multiple&quot; +
  &quot; backreferences are allowed.  If the node with no node description does not refer&quot; +
  &quot; to a previously named node, there will be no error; the expression simply will&quot; +
  &quot; not match anything.&quot; +
  &quot; &lt;p&gt; Another way to refer to previously named nodes is with the \&quot;link\&quot; symbol: '~'.&quot; +
  &quot; A link is like a backreference, except that instead of having to be &lt;i&gt;equal to&lt;/i&gt; the&quot; +
  &quot; referred node, the current node only has to match the label of the referred to node.&quot; +
  &quot; A link cannot have a node description, i.e. the '~' symbol must immediately follow a&quot; +
  &quot; relation symbol. For example, the pattern &lt;code&gt;ADJP=cat &amp;lt, ~cat &amp;lt;- ~cat&lt;/code&gt; will&quot; +
  &quot; match all ADJP whose first and last child is also an ADJP. &quot;) +

  (&quot; &lt;p&gt;&lt;h3&gt;Variable Groups&lt;/h3&gt;&quot; +
  &quot; If you write a node description using a regular expression, you can assign its matching groups to variable names.&quot; +
  &quot; If more than one node has a group assigned to the same variable name, then matching will only occur when all such groups&quot; +
  &quot; capture the same string.  This is useful for enforcing coindexation constraints.  The syntax is&quot; +
  &quot; &lt;blockquote&gt;&quot; +
  &quot; &lt;code&gt; / &amp;lt;regex-stuff&amp;gt; /#&amp;lt;group-number&amp;gt;%&amp;lt;variable-name&amp;gt;&lt;/code&gt;&quot; +
  &quot; &lt;/blockquote&gt;&quot; +
  &quot; For example, the following pattern (designed for Penn Treebank trees)&quot; +
  &quot; &lt;blockquote&gt;&quot; +
  &quot; &lt;code&gt; @SBAR &amp;lt; /^WH.*-([0-9]+)$/#1%index &amp;lt;&amp;lt; (__=empty &amp;lt; (/^-NONE-/ &amp;lt; /^\\*T\\*-([0-9]+)$/#1%index)) &lt;/code&gt;&quot; +
  &quot; &lt;/blockquote&gt;&quot; +
  &quot; will match only such that the WH- node under the SBAR is coindexed with the&quot; +
  &quot; trace node that gets the name &lt;code&gt;empty&lt;/code&gt;.&quot;) +

  (&quot;&lt;p&gt;&lt;h3&gt;Comparison with tgrep and tgrep2&lt;/h3&gt;&quot; +
  &quot; Tregex is similar to tgrep and tgrep2.  Tregex supports all the standard operators of tgrep&quot; +
  &quot; (but not alternative symbols), but where the semantics of tgrep2 for those operators&quot; +
  &quot; differs, it follows tgrep2. Tregex implements many of the extensions of tgrep2, such as&quot; +
  &quot; boolean expressions, labeled nodes, segmented patterns, and the ? operator, but not the = and ~ operators,&quot; +
  &quot; macros, nor many of the command-line options, such as for formatted output.  Tregex implements&quot; +
  &quot; some unique additions of its own, such as operators for being the head of, or domination or precedence along a constrained path,&quot; +
  &quot; and the == operator. Another big difference is that tgrep and tgrep2 pre-index treebanks, while tregex iterates&quot; +
  &quot; through them at runtime.  The latter is slower but more flexible.  Two final differences are that tregex has a GUI&quot; +
  &quot; and a companion language Tsurgeon for editing trees.&quot;) +

  (&quot;&lt;p&gt;&lt;h3&gt;Tsurgeon&lt;/h3&gt;&quot; +
  &quot; Tregex has a companion language Tsurgeon for altering trees according to rules.  To use Tsurgeon (and to see&quot; +
  &quot; the help for it), enable Tsurgeon using the &lt;code&gt;Preferences&lt;/code&gt; menu item.&quot; ) +
  &quot;&lt;p&gt;&lt;/html&gt;&quot;;

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>