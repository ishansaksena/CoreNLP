<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TregexPattern.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.trees.tregex</a> &gt; <span class="el_source">TregexPattern.java</span></div><h1>TregexPattern.java</h1><pre class="source lang-java linenums">// TregexPattern -- a Tgrep2-style utility for recognizing patterns in trees.
// Tregex/Tsurgeon Distribution
// Copyright (c) 2003-2008 The Board of Trustees of
// The Leland Stanford Junior University. All Rights Reserved.
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
//
//
// For more information, bug reports, fixes, contact:
//    Christopher Manning
//    Dept of Computer Science, Gates 1A
//    Stanford CA 94305-9010
//    USA
//    Support/Questions: parser-user@lists.stanford.edu
//    Licensing: parser-support@lists.stanford.edu
//    http://www-nlp.stanford.edu/software/tregex.shtml


package edu.stanford.nlp.trees.tregex; 
import edu.stanford.nlp.util.logging.Redwood;

import java.io.*;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import edu.stanford.nlp.io.IOUtils;
import edu.stanford.nlp.ling.StringLabelFactory;
import edu.stanford.nlp.trees.*;
import edu.stanford.nlp.util.ArrayMap;
import edu.stanford.nlp.util.Generics;
import edu.stanford.nlp.util.Pair;
import edu.stanford.nlp.util.StringUtils;
import edu.stanford.nlp.util.Timing;


/**
 * A TregexPattern is a &lt;code&gt;tgrep&lt;/code&gt;-type pattern for matching tree
 * node configurations.  Unlike &lt;code&gt;tgrep&lt;/code&gt; or &lt;code&gt;tgrep2&lt;/code&gt;but like Unix
 * &lt;code&gt;grep&lt;/code&gt;, there is no pre-indexing of the data to be searched.
 * Rather there is a linear scan through the trees where matches are sought.
 * As a result, matching is slower, but a TregexPattern can be applied
 * to an arbitrary set of trees at runtime in a processing pipeline.
 *
 * &lt;p&gt; TregexPattern instances can be matched against instances of the {@link Tree} class.
 * The {@link #main} method can be used to find matching nodes of a treebank from the command line.
 *
 * &lt;p&gt;
 * Currently supported node-node relations and their symbols:
 * &lt;p&gt;
 * &lt;table border = &quot;1&quot;&gt;
 * &lt;tr&gt;&lt;th&gt;Symbol&lt;th&gt;Meaning
 * &lt;tr&gt;&lt;td&gt;A &amp;lt;&amp;lt; B &lt;td&gt;A dominates B
 * &lt;tr&gt;&lt;td&gt;A &amp;gt;&amp;gt; B &lt;td&gt;A is dominated by B
 * &lt;tr&gt;&lt;td&gt;A &amp;lt; B &lt;td&gt;A immediately dominates B
 * &lt;tr&gt;&lt;td&gt;A &amp;gt; B &lt;td&gt;A is immediately dominated by B
 * &lt;tr&gt;&lt;td&gt;A &amp;#36; B &lt;td&gt;A is a sister of B (and not equal to B)
 * &lt;tr&gt;&lt;td&gt;A .. B &lt;td&gt;A precedes B
 * &lt;tr&gt;&lt;td&gt;A . B &lt;td&gt;A immediately precedes B
 * &lt;tr&gt;&lt;td&gt;A ,, B &lt;td&gt;A follows B
 * &lt;tr&gt;&lt;td&gt;A , B &lt;td&gt;A immediately follows B
 * &lt;tr&gt;&lt;td&gt;A &amp;lt;&amp;lt;, B &lt;td&gt;B is a leftmost descendant of A
 * &lt;tr&gt;&lt;td&gt;A &amp;lt;&amp;lt;- B &lt;td&gt;B is a rightmost descendant of A
 * &lt;tr&gt;&lt;td&gt;A &amp;gt;&amp;gt;, B &lt;td&gt;A is a leftmost descendant of B
 * &lt;tr&gt;&lt;td&gt;A &amp;gt;&amp;gt;- B &lt;td&gt;A is a rightmost descendant of B
 * &lt;tr&gt;&lt;td&gt;A &amp;lt;, B &lt;td&gt;B is the first child of A
 * &lt;tr&gt;&lt;td&gt;A &amp;gt;, B &lt;td&gt;A is the first child of B
 * &lt;tr&gt;&lt;td&gt;A &amp;lt;- B &lt;td&gt;B is the last child of A
 * &lt;tr&gt;&lt;td&gt;A &amp;gt;- B &lt;td&gt;A is the last child of B
 * &lt;tr&gt;&lt;td&gt;A &amp;lt;` B &lt;td&gt;B is the last child of A
 * &lt;tr&gt;&lt;td&gt;A &amp;gt;` B &lt;td&gt;A is the last child of B
 * &lt;tr&gt;&lt;td&gt;A &amp;lt;i B &lt;td&gt;B is the ith child of A (i &gt; 0)
 * &lt;tr&gt;&lt;td&gt;A &amp;gt;i B &lt;td&gt;A is the ith child of B (i &gt; 0)
 * &lt;tr&gt;&lt;td&gt;A &amp;lt;-i B &lt;td&gt;B is the ith-to-last child of A (i &gt; 0)
 * &lt;tr&gt;&lt;td&gt;A &amp;gt;-i B &lt;td&gt;A is the ith-to-last child of B (i &gt; 0)
 * &lt;tr&gt;&lt;td&gt;A &amp;lt;: B &lt;td&gt;B is the only child of A
 * &lt;tr&gt;&lt;td&gt;A &amp;gt;: B &lt;td&gt;A is the only child of B
 * &lt;tr&gt;&lt;td&gt;A &amp;lt;&amp;lt;: B &lt;td&gt;A dominates B via an unbroken chain (length &gt; 0) of unary local trees.
 * &lt;tr&gt;&lt;td&gt;A &amp;gt;&amp;gt;: B &lt;td&gt;A is dominated by B via an unbroken chain (length &gt; 0) of unary local trees.
 * &lt;tr&gt;&lt;td&gt;A &amp;#36;++ B &lt;td&gt;A is a left sister of B (same as &amp;#36;.. for context-free trees)
 * &lt;tr&gt;&lt;td&gt;A &amp;#36;-- B &lt;td&gt;A is a right sister of B (same as &amp;#36;,, for context-free trees)
 * &lt;tr&gt;&lt;td&gt;A &amp;#36;+ B &lt;td&gt;A is the immediate left sister of B (same as &amp;#36;. for context-free trees)
 * &lt;tr&gt;&lt;td&gt;A &amp;#36;- B &lt;td&gt;A is the immediate right sister of B (same as &amp;#36;, for context-free trees)
 * &lt;tr&gt;&lt;td&gt;A &amp;#36;.. B &lt;td&gt;A is a sister of B and precedes B
 * &lt;tr&gt;&lt;td&gt;A &amp;#36;,, B &lt;td&gt;A is a sister of B and follows B
 * &lt;tr&gt;&lt;td&gt;A &amp;#36;. B &lt;td&gt;A is a sister of B and immediately precedes B
 * &lt;tr&gt;&lt;td&gt;A &amp;#36;, B &lt;td&gt;A is a sister of B and immediately follows B
 * &lt;tr&gt;&lt;td&gt;A &amp;lt;+(C) B &lt;td&gt;A dominates B via an unbroken chain of (zero or more) nodes matching description C
 * &lt;tr&gt;&lt;td&gt;A &amp;gt;+(C) B &lt;td&gt;A is dominated by B via an unbroken chain of (zero or more) nodes matching description C
 * &lt;tr&gt;&lt;td&gt;A .+(C) B &lt;td&gt;A precedes B via an unbroken chain of (zero or more) nodes matching description C
 * &lt;tr&gt;&lt;td&gt;A ,+(C) B &lt;td&gt;A follows B via an unbroken chain of (zero or more) nodes matching description C
 * &lt;tr&gt;&lt;td&gt;A &amp;lt;&amp;lt;&amp;#35; B &lt;td&gt;B is a head of phrase A
 * &lt;tr&gt;&lt;td&gt;A &amp;gt;&amp;gt;&amp;#35; B &lt;td&gt;A is a head of phrase B
 * &lt;tr&gt;&lt;td&gt;A &amp;lt;&amp;#35; B &lt;td&gt;B is the immediate head of phrase A
 * &lt;tr&gt;&lt;td&gt;A &amp;gt;&amp;#35; B &lt;td&gt;A is the immediate head of phrase B
 * &lt;tr&gt;&lt;td&gt;A == B &lt;td&gt;A and B are the same node
 * &lt;tr&gt;&lt;td&gt;A &amp;lt;= B &lt;td&gt;A and B are the same node or A is the parent of B
 * &lt;tr&gt;&lt;td&gt;A : B&lt;td&gt;[this is a pattern-segmenting operator that places no constraints on the relationship between A and B]
 * &lt;tr&gt;&lt;td&gt;A &amp;lt;... { B ; C ; ... }&lt;td&gt;A has exactly B, C, etc as its subtree, with no other children.
 * &lt;/table&gt;
 * &lt;p&gt; Label descriptions can be literal strings, which much match labels
 * exactly, or regular expressions in regular expression bars: /regex/.
 * Literal string matching proceeds as String equality.
 * In order to prevent ambiguity with other Tregex symbols, ASCII symbols are
 * not allowed in literal strings, and they cannot begin with ASCII digits.
 * (That is literals can be standard &quot;identifiers&quot; matching
 * [a-zA-Z]([a-zA-Z0-9_-])* but also may include letters from other alphabets.)
 * If you want to use other symbols, you can do so by using a regular
 * expression instead of a literal string.
 * A disjunctive list of literal strings can be given separated by '|'.
 * The special string '__' (two underscores) can be used to match any
 * node.  (WARNING!!  Use of the '__' node description may seriously
 * slow down search.)  If a label description is preceded by '@', the
 * label will match any node whose &lt;em&gt;basicCategory&lt;/em&gt; matches the
 * description.  &lt;emph&gt;NB: A single '@' thus scopes over a disjunction
 * specified by '|': @NP|VP means things with basic category NP or VP.
 * &lt;/emph&gt; The basicCategory is defined according to a Function
 * mapping Strings to Strings, as provided by
 * {@link edu.stanford.nlp.trees.AbstractTreebankLanguagePack#getBasicCategoryFunction()}.
 * Label description regular expressions are matched as &lt;code&gt;find()&lt;/code&gt;,
 * as in Perl/tgrep;
 * you need to use &lt;code&gt;^&lt;/code&gt; or &lt;code&gt;$&lt;/code&gt; to constrain matches to
 * the ends of strings.
 * &lt;p/&gt;
 * In a chain of relations, all relations are relative to the first node in
 * the chain. For example, &lt;code&gt; (S &amp;lt; VP &amp;lt; NP) &lt;/code&gt; means
 * &quot;an S over a VP and also over an NP&quot;.
 * If instead what you want is an S above a VP above an NP, you should write
 * &quot;&lt;code&gt;S &amp;lt; (VP &amp;lt; NP)&lt;/code&gt;&quot;.
 * &lt;p&gt; Nodes can be grouped using parentheses '(' and ')'
 * as in &lt;code&gt; S &amp;lt; (NP $++ VP) &lt;/code&gt; to match an S
 * over an NP, where the NP has a VP as a right sister.
 *
 * &lt;h3&gt;Notes on relations&lt;/h3&gt;
 *
 * &lt;p&gt;
 * Node &lt;code&gt;B&lt;/code&gt; &quot;follows&quot; node &lt;code&gt;A&lt;/code&gt; if &lt;code&gt;B&lt;/code&gt;
 * or one of its ancestors is a right sibling of &lt;code&gt;A&lt;/code&gt; or one
 * of its ancestors.  Node &lt;code&gt;B&lt;/code&gt; &quot;immediately follows&quot; node
 * &lt;code&gt;A&lt;/code&gt; if &lt;code&gt;B&lt;/code&gt; follows &lt;code&gt;A&lt;/code&gt; and there
 * is no node &lt;code&gt;C&lt;/code&gt; such that &lt;code&gt;B&lt;/code&gt; follows
 * &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; follows &lt;code&gt;A&lt;/code&gt;.
 *
 * &lt;p&gt;
 * Node &lt;code&gt;A&lt;/code&gt; dominates &lt;code&gt;B&lt;/code&gt; through an unbroken
 * chain of unary local trees only if &lt;code&gt;A&lt;/code&gt; is also
 * unary. &lt;code&gt;(A (B))&lt;/code&gt; is a valid example that matches &lt;code&gt;A
 * &amp;lt;&amp;lt;: B&lt;/code&gt;
 *
 * &lt;p&gt;
 * When specifying that nodes are dominated via an unbroken chain of
 * nodes matching a description &lt;code&gt;C&lt;/code&gt;, the description
 * &lt;code&gt;C&lt;/code&gt; cannot be a full Tregex expression, but only an
 * expression specifying the name of the node.  Negation of this
 * description is allowed.
 *
 * &lt;p&gt;
 * == has the same precedence as the other relations, so the expression
 * &lt;code&gt;A &amp;lt;&amp;lt; B == A &amp;lt;&amp;lt; C&lt;/code&gt; associates as
 * &lt;code&gt;(((A &amp;lt;&amp;lt; B) == A) &amp;lt;&amp;lt; C)&lt;/code&gt;, not as
 * &lt;code&gt;((A &amp;lt;&amp;lt; B) == (A &amp;lt;&amp;lt; C))&lt;/code&gt;.  (Both expressions are
 * equivalent, of course, but this is just an example.)
 *
 * &lt;h3&gt;Boolean relational operators&lt;/h3&gt;
 *
 * &lt;p&gt; Relations can be combined using the '&amp;' and '|' operators,
 * negated with the '!' operator, and made optional with the '?' operator.
 * Thus &lt;code&gt; (NP &lt; NN | &lt; NNS) &lt;/code&gt; will match an NP node dominating either
 * an NN or an NNS.  &lt;code&gt; (NP &gt; S &amp; $++ VP) &lt;/code&gt; matches an NP that
 * is both under an S and has a VP as a right sister.
 * &lt;p&gt;
 * Expressions stop evaluating as soon as the result is known.  For
 * example, if the pattern is &lt;code&gt;NP=a | NNP=b&lt;/code&gt; and the NP
 * matches, then variable &lt;code&gt;b&lt;/code&gt; will not be assigned even if
 * there is an NNP in the tree.
 *
 * &lt;p&gt; Relations can be grouped using brackets '[' and ']'.  So the
 * expression
 *
 * &lt;blockquote&gt;
 * &lt;code&gt; NP [&lt; NN | &lt; NNS] &amp; &gt; S &lt;/code&gt;
 * &lt;/blockquote&gt;
 *
 *  matches an NP that (1) dominates either an NN or an NNS, and (2) is under an S.  Without
 * brackets, &amp;amp; takes precedence over |, and equivalent operators are
 * left-associative.  Also note that &amp;amp; is the default combining operator if the
 * operator is omitted in a chain of relations, so that the two patterns are equivalent:
 *
 * &lt;blockquote&gt;
 * &lt;code&gt; (S &lt; VP &lt; NP) &lt;/code&gt;&lt;br&gt;
 * &lt;code&gt; (S &lt; VP &amp; &lt; NP) &lt;/code&gt;
 * &lt;/blockquote&gt;
 *
 * As another example, &lt;code&gt; (VP &lt; VV | &lt; NP % NP)
 * &lt;/code&gt; can be written explicitly as &lt;code&gt; (VP [&lt; VV | [&lt; NP &amp; % NP] ] )
 * &lt;/code&gt;
 *
 * &lt;p&gt; Relations can be negated with the '!' operator, in which case the
 * expression will match only if there is no node satisfying the relation.
 * For example &lt;code&gt; (NP !&lt; NNP) &lt;/code&gt; matches only NPs not dominating
 * an NNP.  Label descriptions can also be negated with '!': (NP &lt; !NNP|NNS) matches
 * NPs dominating some node that is not an NNP or an NNS.

 * &lt;p&gt; Relations can be made optional with the '?' operator.  This way the
 * expression will match even if the optional relation is not satisfied.  This is useful when used together
 *  with node naming (see below).
 *
 * &lt;p&gt;&lt;h3&gt;Basic Categories&lt;/h3&gt;
 *
 * &lt;p&gt; In order to consider only the &quot;basic category&quot; of a tree label,
 * i.e. to ignore functional tags or other annotations on the label,
 * prefix that node's description with the &amp;#64; symbol.  For example
 * &lt;code&gt; (@NP &lt; @/NN.?/) &lt;/code&gt;  This can only be used for individual nodes;
 * if you want all nodes to use the basic category, it would be more efficient
 * to use a {@link edu.stanford.nlp.trees.TreeNormalizer} to remove functional
 * tags before passing the tree to the TregexPattern.
 *
 * &lt;p&gt;&lt;h3&gt;Segmenting patterns&lt;/h3&gt;
 *
 * &lt;p&gt;The &quot;:&quot; operator allows you to segment a pattern into two pieces.  This can simplify your pattern writing.  For example,
 * the pattern
 *
 * &lt;blockquote&gt;
 *   S : NP
 * &lt;/blockquote&gt;
 *
 * matches only those S nodes in trees that also have an NP node.
 *
 * &lt;p&gt;&lt;h3&gt;Naming nodes&lt;/h3&gt;
 *
 * &lt;p&gt; Nodes can be given names (a.k.a. handles) using '='.  A named node will be stored in a
 * map that maps names to nodes so that if a match is found, the node
 * corresponding to the named node can be extracted from the map.  For
 * example &lt;code&gt; (NP &lt; NNP=name) &lt;/code&gt; will match an NP dominating an NNP
 * and after a match is found, the map can be queried with the
 * name to retreived the matched node using {@link TregexMatcher#getNode(String o)}
 * with (String) argument &quot;name&quot; (&lt;it&gt;not&lt;/it&gt; &quot;=name&quot;).
 * Note that you are not allowed to name a node that is under the scope of a negation operator (the semantics would
 * be unclear, since you can't store a node that never gets matched to).
 * Trying to do so will cause a {@link TregexParseException} to be thrown. Named nodes &lt;it&gt;can be put within the scope of an optionality operator&lt;/it&gt;.
 *
 * &lt;p&gt; Named nodes that refer back to previous named nodes need not have a node
 * description -- this is known as &quot;backreferencing&quot;.  In this case, the expression
 * will match only when all instances of the same name get matched to the same tree node.
 * For example: the pattern
 *
 * &lt;blockquote&gt;
 * &lt;code&gt; (@NP &lt;, (@NP $+ (/,/ $+ (@NP $+ /,/=comma))) &lt;- =comma) &lt;/code&gt;
 * &lt;/blockquote&gt;
 *
 * matches only an NP dominating exactly the four node sequence
 * &lt;code&gt;NP , NP ,&lt;/code&gt; -- the mother NP cannot have any other
 * daughters. Multiple backreferences are allowed.  If the node w/ no
 * node description does not refer to a previously named node, there
 * will be no error, the expression simply will not match anything.
 *
 * &lt;p&gt; Another way to refer to previously named nodes is with the &quot;link&quot; symbol: '~'.
 * A link is like a backreference, except that instead of having to be &lt;i&gt;equal to&lt;/i&gt; the
 * referred node, the current node only has to match the label of the referred to node.
 * A link cannot have a node description, i.e. the '~' symbol must immediately follow a
 * relation symbol.
 *
 * &lt;p&gt;&lt;h3&gt;Customizing headship and basic categories&lt;/h3&gt;
 *
 * &lt;p&gt; The HeadFinder used to determine heads for the head relations &lt;code&gt;&amp;lt;#&lt;/code&gt;, &lt;code&gt;&amp;gt;#&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;#&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;#&lt;/code&gt;, and also
 * the Function mapping from labels to Basic Category tags can be
 * chosen by using a {@link TregexPatternCompiler}.
 *
 * &lt;p&gt;&lt;h3&gt;Variable Groups&lt;/h3&gt;
 *
 * &lt;p&gt; If you write a node description using a regular expression, you can assign its matching groups to variable names.
 * If more than one node has a group assigned to the same variable name, then matching will only occur when all such groups
 * capture the same string.  This is useful for enforcing coindexation constraints.  The syntax is
 *
 * &lt;blockquote&gt;
 * &lt;code&gt; / &amp;lt;regex-stuff&amp;gt; /#&amp;lt;group-number&amp;gt;%&amp;lt;variable-name&amp;gt;&lt;/code&gt;
 * &lt;/blockquote&gt;
 *
 * For example, the pattern (designed for Penn Treebank trees)
 *
 * &lt;blockquote&gt;
 * &lt;code&gt; @SBAR &lt; /^WH.*-([0-9]+)$/#1%index &lt;&lt; (__=empty &lt; (/^-NONE-/ &lt; /^\*T\*-([0-9]+)$/#1%index)) &lt;/code&gt;
 * &lt;/blockquote&gt;
 *
 * will match only such that the WH- node under the SBAR is coindexed with the trace node that gets the name &lt;code&gt;empty&lt;/code&gt;.
 *
 * &lt;p&gt;&lt;h3&gt;Getting Started&lt;/h3&gt;
 *
 * Suppose we want to find all examples of subtrees where the label of
 * the root of the subtree starts with MW.  For example, we want any
 * subtree whose root is labeled MWV, MWN, etc.
 * &lt;br&gt;
 * The first thing to do is figure out what pattern to use.  Since we
 * want to match anything starting with MW, we use the pattern
 * &lt;code&gt;/^MW/&lt;/code&gt;.
 * &lt;br&gt;
 * We then create a pattern, find matches in a given tree, and process
 * those matches as follows:
 * &lt;blockquote&gt;
 * &lt;code&gt;
 *   // Create a reusable pattern object &lt;br&gt;
 *   TregexPattern patternMW = TregexPattern.compile(&quot;/^MW/&quot;); &lt;br&gt;
 *   // Run the pattern on one particular tree &lt;br&gt;
 *   TregexMatcher matcher = patternMW.matcher(tree); &lt;br&gt;
 *   // Iterate over all of the subtrees that matched &lt;br&gt;
 *   while (matcher.findNextMatchingNode()) { &lt;br&gt;
 *   &amp;nbsp;&amp;nbsp;Tree match = matcher.getMatch(); &lt;br&gt;
 *   &amp;nbsp;&amp;nbsp;// do what we want to with the subtree &lt;br&gt;
 *   }
 * &lt;/code&gt;
 * &lt;/blockquote&gt;
 *
 * &lt;p&gt;&lt;h3&gt;Current known bugs/shortcomings:&lt;/h3&gt;
 *
 * &lt;ul&gt;
 *
 * &lt;li&gt; Tregex does not support disjunctions at the root level.  For
 * example, the pattern &lt;code&gt;A | B&lt;/code&gt; will not work.
 *
 * &lt;li&gt; Using multiple variable strings in one regex may not
 * necessarily work.  For example, suppose the first two regex
 * patterns are &lt;code&gt;/(.*)/#1%foo&lt;/code&gt; and
 * &lt;code&gt;/(.*)/#1%bar&lt;/code&gt;.  You might then want to write a pattern
 * that matches the concatenation of these patterns,
 * &lt;code&gt;/(.*)(.*)/#1%foo#2%bar&lt;/code&gt;, but that will not work.
 *
 * &lt;/ul&gt;
 *
 * @author Galen Andrew
 * @author Roger Levy (rog@csli.stanford.edu)
 * @author Anna Rafferty (filter mode)
 * @author John Bauer (extensively tested and bugfixed)
 */
public abstract class TregexPattern implements Serializable  {

  /** A logger for this class */
<span class="fc" id="L349">  private static Redwood.RedwoodChannels log = Redwood.channels(TregexPattern.class);</span>
<span class="fc" id="L350">  private boolean neg = false;</span>
<span class="fc" id="L351">  private boolean opt = false;</span>
  private String patternString;

  void negate() {
<span class="fc" id="L355">    neg = true;</span>
<span class="pc bpc" id="L356" title="1 of 2 branches missed.">    if (opt) {</span>
<span class="nc" id="L357">      throw new RuntimeException(&quot;Node cannot be both negated and optional.&quot;);</span>
    }
<span class="fc" id="L359">  }</span>

  void makeOptional() {
<span class="fc" id="L362">    opt = true;</span>
<span class="pc bpc" id="L363" title="1 of 2 branches missed.">    if (neg) {</span>
<span class="nc" id="L364">      throw new RuntimeException(&quot;Node cannot be both negated and optional.&quot;);</span>
    }
<span class="fc" id="L366">  }</span>

  private void prettyPrint(PrintWriter pw, int indent) {
<span class="nc bnc" id="L369" title="All 2 branches missed.">    for (int i = 0; i &lt; indent; i++) {</span>
<span class="nc" id="L370">      pw.print(&quot;   &quot;);</span>
    }
<span class="nc bnc" id="L372" title="All 2 branches missed.">    if (neg) {</span>
<span class="nc" id="L373">      pw.print('!');</span>
    }
<span class="nc bnc" id="L375" title="All 2 branches missed.">    if (opt) {</span>
<span class="nc" id="L376">      pw.print('?');</span>
    }
<span class="nc" id="L378">    pw.println(localString());</span>
<span class="nc bnc" id="L379" title="All 2 branches missed.">    for (TregexPattern child : getChildren()) {</span>
<span class="nc" id="L380">      child.prettyPrint(pw, indent + 1);</span>
<span class="nc" id="L381">    }</span>
<span class="nc" id="L382">  }</span>

  // package private constructor
<span class="fc" id="L385">  TregexPattern() {</span>
<span class="fc" id="L386">  }</span>

  abstract List&lt;TregexPattern&gt; getChildren();

  abstract String localString();

  boolean isNegated() {
<span class="fc" id="L393">    return neg;</span>
  }

  boolean isOptional() {
<span class="fc" id="L397">    return opt;</span>
  }

  abstract TregexMatcher matcher(Tree root, Tree tree,
                                 IdentityHashMap&lt;Tree, Tree&gt; nodesToParents,
                                 Map&lt;String, Tree&gt; namesToNodes,
                                 VariableStrings variableStrings,
                                 HeadFinder headFinder);

  /**
   * Get a {@link TregexMatcher} for this pattern on this tree.
   *
   * @param t a tree to match on
   * @return a TregexMatcher
   */
  public TregexMatcher matcher(Tree t) {
    // In the assumption that there will usually be very few names in
    // the pattern, we use an ArrayMap instead of a hash map
    // TODO: it would be even more efficient if we set this to be
    // exactly the right size
<span class="fc" id="L417">    return matcher(t, t, null, ArrayMap.&lt;String, Tree&gt;newArrayMap(), new VariableStrings(), null);</span>
  }

  /**
   * Get a {@link TregexMatcher} for this pattern on this tree.  Any Relations which use heads of trees should use the provided HeadFinder.
   *
   * @param t a tree to match on
   * @param headFinder a HeadFinder to use when matching
   * @return a TregexMatcher
   */
  public TregexMatcher matcher(Tree t, HeadFinder headFinder) {
<span class="fc" id="L428">    return matcher(t, t, null, ArrayMap.&lt;String, Tree&gt;newArrayMap(), new VariableStrings(), headFinder);</span>
  }

  /**
   * Creates a pattern from the given string using the default HeadFinder and
   * BasicCategoryFunction.  If you want to use a different HeadFinder or
   * BasicCategoryFunction, use a {@link TregexPatternCompiler} object.
   *
   * @param tregex the pattern string
   * @return a TregexPattern for the string.
   * @throws TregexParseException if the string does not parse
   */
  public static TregexPattern compile(String tregex) {
<span class="fc" id="L441">    return TregexPatternCompiler.defaultCompiler.compile(tregex);</span>
  }

  /**
   * Creates a pattern from the given string using the default HeadFinder and
   * BasicCategoryFunction.  If you want to use a different HeadFinder or
   * BasicCategoryFunction, use a {@link TregexPatternCompiler} object.
   * Rather than throwing an exception when the string does not parse,
   * simply returns null.
   *
   * @param tregex the pattern string
   * @param verbose whether to log errors when the string doesn't parse
   * @return a TregexPattern for the string, or null if the string does not parse.
   */
  public static TregexPattern safeCompile(String tregex, boolean verbose) {
<span class="fc" id="L456">    TregexPattern result = null;</span>
    try {
<span class="fc" id="L458">      result = TregexPatternCompiler.defaultCompiler.compile(tregex);</span>
<span class="nc" id="L459">    } catch (TregexParseException ex) {</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">      if (verbose) {</span>
<span class="nc" id="L461">        log.info(&quot;Could not parse &quot; + tregex + &quot;:&quot;);</span>
<span class="nc" id="L462">        ex.printStackTrace();</span>
      }
<span class="fc" id="L464">    }</span>
<span class="fc" id="L465">    return result;</span>
  }

  public String pattern() {
<span class="nc" id="L469">    return patternString;</span>
  }

  /** Only used by the TregexPatternCompiler to set the pattern. Pseudo-final. */
  void setPatternString(String patternString) {
<span class="fc" id="L474">    this.patternString = patternString;</span>
<span class="fc" id="L475">  }</span>

  /**
   * @return A single-line string representation of the pattern
   */
  @Override
  public abstract String toString();

  /**
   * Print a multi-line representation
   * of the pattern illustrating it's syntax.
   */
  public void prettyPrint(PrintWriter pw) {
<span class="nc" id="L488">    prettyPrint(pw, 0);</span>
<span class="nc" id="L489">  }</span>

  /**
   * Print a multi-line representation
   * of the pattern illustrating it's syntax.
   */
  public void prettyPrint(PrintStream ps) {
<span class="nc" id="L496">    prettyPrint(new PrintWriter(new OutputStreamWriter(ps), true));</span>
<span class="nc" id="L497">  }</span>

  /**
   * Print a multi-line representation of the pattern illustrating
   * it's syntax to System.out.
   */
  public void prettyPrint() {
<span class="nc" id="L504">    prettyPrint(System.out);</span>
<span class="nc" id="L505">  }</span>


<span class="fc" id="L508">  private static final Pattern codePattern = Pattern.compile(&quot;([0-9]+):([0-9]+)&quot;);</span>

  private static void extractSubtrees(List&lt;String&gt; codeStrings, String treeFile) {
<span class="nc" id="L511">    List&lt;Pair&lt;Integer,Integer&gt;&gt; codes = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L512" title="All 2 branches missed.">    for(String s : codeStrings) {</span>
<span class="nc" id="L513">      Matcher m = codePattern.matcher(s);</span>
<span class="nc bnc" id="L514" title="All 2 branches missed.">      if(m.matches())</span>
<span class="nc" id="L515">        codes.add(new Pair&lt;&gt;(Integer.parseInt(m.group(1)), Integer.parseInt(m.group(2))));</span>
      else
<span class="nc" id="L517">        throw new RuntimeException(&quot;Error: illegal node code &quot; + s);</span>
<span class="nc" id="L518">    }</span>
<span class="nc" id="L519">    TreeReaderFactory trf = new TRegexTreeReaderFactory();</span>
<span class="nc" id="L520">    MemoryTreebank treebank = new MemoryTreebank(trf);</span>
<span class="nc" id="L521">    treebank.loadPath(treeFile,null, true);</span>
<span class="nc bnc" id="L522" title="All 2 branches missed.">    for (Pair&lt;Integer,Integer&gt; code : codes) {</span>
<span class="nc" id="L523">      Tree t = treebank.get(code.first()-1);</span>
<span class="nc" id="L524">      t.getNodeNumber(code.second()).pennPrint();</span>
<span class="nc" id="L525">    }</span>
<span class="nc" id="L526">  }</span>

  /**
   * Prints out all matches of a tree pattern on each tree in the path.
   * Usage: &lt;br&gt;&lt;br&gt;&lt;code&gt;
   * java edu.stanford.nlp.trees.tregex.TregexPattern [[-TCwfosnu] [-filter] [-h &amp;lt;node-name&amp;gt;]]* pattern
   *  filepath   &lt;/code&gt;
   *
   * &lt;p&gt;
   * Arguments:&lt;br&gt;
   * &lt;ul&gt;&lt;li&gt;&lt;code&gt;pattern&lt;/code&gt;: the tree
   * pattern which optionally names some set of nodes (i.e., gives it the &quot;handle&quot;) &lt;code&gt;=name&lt;/code&gt; (for some arbitrary
   * string &quot;name&quot;)
   * &lt;li&gt; &lt;code&gt;filepath&lt;/code&gt;: the path to files with trees. If this is a directory, there will be recursive descent and the pattern will be run on all files beneath the specified directory.
   * &lt;/ul&gt;&lt;p&gt;
   * Options:&lt;br&gt;
   * &lt;li&gt; &lt;code&gt;-C&lt;/code&gt; suppresses printing of matches, so only the
   * number of matches is printed.
   * &lt;li&gt; &lt;code&gt;-w&lt;/code&gt; causes the whole of a tree that matches to be printed.
   * &lt;li&gt; &lt;code&gt;-f&lt;/code&gt; causes the filename to be printed.
   * &lt;li&gt; &lt;code&gt;-i &amp;lt;filename&amp;gt;&lt;/code&gt; causes the pattern to be matched to be read from &lt;code&gt;&amp;lt;filename&amp;gt;&lt;/code&gt; rather than the command line.  Don't specify a pattern when this option is used.
   * &lt;li&gt; &lt;code&gt;-o&lt;/code&gt; Specifies that each tree node can be reported only once as the root of a match (by default a node will
   * be printed once for every &lt;em&gt;way&lt;/em&gt; the pattern matches).
   * &lt;li&gt; &lt;code&gt;-s&lt;/code&gt; causes trees to be printed all on one line (by default they are pretty printed).
   * &lt;li&gt; &lt;code&gt;-n&lt;/code&gt; causes the number of the tree in which the match was found to be
   * printed before every match.
   * &lt;li&gt; &lt;code&gt;-u&lt;/code&gt; causes only the label of each matching node to be printed, not complete subtrees.
   * &lt;li&gt; &lt;code&gt;-t&lt;/code&gt; causes only the yield (terminal words) of the selected node to be printed (or the yield of the whole tree, if the &lt;code&gt;-w&lt;/code&gt; option is used).
   * &lt;li&gt; &lt;code&gt;-encoding &amp;lt;charset_encoding&amp;gt;&lt;/code&gt; option allows specification of character encoding of trees..
   * &lt;li&gt; &lt;code&gt;-h &amp;lt;node-handle&amp;gt;&lt;/code&gt; If a &lt;code&gt;-h&lt;/code&gt; option is given, the root tree node will not be printed.  Instead,
   * for each &lt;code&gt;node-handle&lt;/code&gt; specified, the node matched and given that handle will be printed.  Multiple nodes can be printed by using the
   * &lt;code&gt;-h&lt;/code&gt; option multiple times on a single command line.
   * &lt;li&gt; &lt;code&gt;-hf &amp;lt;headfinder-class-name&amp;gt;&lt;/code&gt; use the specified {@link HeadFinder} class to determine headship relations.
   * &lt;li&gt; &lt;code&gt;-hfArg &amp;lt;string&amp;gt;&lt;/code&gt; pass a string argument in to the {@link HeadFinder} class's constructor.  &lt;code&gt;-hfArg&lt;/code&gt; can be used multiple times to pass in multiple arguments.
   * &lt;li&gt; &lt;code&gt;-trf &amp;lt;TreeReaderFactory-class-name&amp;gt;&lt;/code&gt; use the specified {@link TreeReaderFactory} class to read trees from files.
   * &lt;li&gt; &lt;code&gt;-e &amp;lt;extension&amp;gt;&lt;/code&gt; Only attempt to read files with the given extension. If not provided, will attempt to read all files.&lt;/li&gt;
   * &lt;li&gt; &lt;code&gt;-v&lt;/code&gt; print every tree that contains no matches of the specified pattern, but print no matches to the pattern.
   *
   * &lt;li&gt; &lt;code&gt;-x&lt;/code&gt; Instead of the matched subtree, print the matched subtree's identifying number as defined in &lt;tt&gt;tgrep2&lt;/tt&gt;:a
   * unique identifier for the subtree and is in the form s:n, where s is an integer specifying
   * the sentence number in the corpus (starting with 1), and n is an integer giving the order
   * in which the node is encountered in a depth-first search starting with 1 at top node in the
   * sentence tree.
   *
   * &lt;li&gt; &lt;code&gt;-extract &amp;lt;code&amp;gt; &amp;lt;tree-file&amp;gt;&lt;/code&gt; extracts the subtree s:n specified by &lt;tt&gt;code&lt;/tt&gt; from the specified &lt;tt&gt;tree-file&lt;/tt&gt;.  Overrides all other behavior of tregex.  Can't specify multiple encodings etc. yet.
   * &lt;li&gt; &lt;code&gt;-extractFile &amp;lt;code-file&amp;gt; &amp;lt;tree-file&amp;gt;&lt;/code&gt; extracts every subtree specified by the subtree codes in &lt;tt&gt;code-file&lt;/tt&gt;, which must appear exactly one per line, from the specified &lt;tt&gt;tree-file&lt;/tt&gt;.  Overrides all other behavior of tregex. Can't specify multiple encodings etc. yet.
   * &lt;li&gt; &lt;code&gt;-filter&lt;/code&gt; causes this to act as a filter, reading tree input from stdin
   * &lt;li&gt; &lt;code&gt;-T&lt;/code&gt; causes all trees to be printed as processed (for debugging purposes).  Otherwise only matching nodes are printed.
   * &lt;li&gt; &lt;code&gt;-macros &amp;lt;filename&amp;gt;&lt;/code&gt; filename with macro substitutions to use.  file with tab separated lines original-tab-replacement
   *
   * &lt;/ul&gt;
   */
  public static void main(String[] args) throws IOException {
<span class="nc" id="L579">    Timing.startTime();</span>

<span class="nc" id="L581">    StringBuilder treePrintFormats = new StringBuilder();</span>
<span class="nc" id="L582">    String printNonMatchingTreesOption = &quot;-v&quot;;</span>
<span class="nc" id="L583">    String subtreeCodeOption = &quot;-x&quot;;</span>
<span class="nc" id="L584">    String extractSubtreesOption = &quot;-extract&quot;;</span>
<span class="nc" id="L585">    String extractSubtreesFileOption = &quot;-extractFile&quot;;</span>
<span class="nc" id="L586">    String inputFileOption = &quot;-i&quot;;</span>
<span class="nc" id="L587">    String headFinderOption = &quot;-hf&quot;;</span>
<span class="nc" id="L588">    String headFinderArgOption = &quot;-hfArg&quot;;</span>
<span class="nc" id="L589">    String trfOption = &quot;-trf&quot;;</span>
<span class="nc" id="L590">    String extensionOption = &quot;-e&quot;;</span>
<span class="nc" id="L591">    String extension = null;</span>
<span class="nc" id="L592">    String headFinderClassName = null;</span>
<span class="nc" id="L593">    String[] headFinderArgs = StringUtils.EMPTY_STRING_ARRAY;</span>
<span class="nc" id="L594">    String treeReaderFactoryClassName = null;</span>
<span class="nc" id="L595">    String printHandleOption = &quot;-h&quot;;</span>
<span class="nc" id="L596">    String markHandleOption = &quot;-k&quot;;</span>
<span class="nc" id="L597">    String encodingOption = &quot;-encoding&quot;;</span>
<span class="nc" id="L598">    String encoding = &quot;UTF-8&quot;;</span>
<span class="nc" id="L599">    String macroOption = &quot;-macros&quot;;</span>
<span class="nc" id="L600">    String macroFilename = &quot;&quot;;</span>
<span class="nc" id="L601">    String yieldOnly = &quot;-t&quot;;</span>
<span class="nc" id="L602">    String printAllTrees = &quot;-T&quot;;</span>
<span class="nc" id="L603">    String quietMode = &quot;-C&quot;;</span>
<span class="nc" id="L604">    String wholeTreeMode = &quot;-w&quot;;</span>
<span class="nc" id="L605">    String filenameOption = &quot;-f&quot;;</span>
<span class="nc" id="L606">    String oneMatchPerRootNodeMode = &quot;-o&quot;;</span>
<span class="nc" id="L607">    String reportTreeNumbers = &quot;-n&quot;;</span>
<span class="nc" id="L608">    String rootLabelOnly = &quot;-u&quot;;</span>
<span class="nc" id="L609">    String oneLine = &quot;-s&quot;;</span>
<span class="nc" id="L610">    Map&lt;String,Integer&gt; flagMap = Generics.newHashMap();</span>
<span class="nc" id="L611">    flagMap.put(extractSubtreesOption,2);</span>
<span class="nc" id="L612">    flagMap.put(extractSubtreesFileOption,2);</span>
<span class="nc" id="L613">    flagMap.put(subtreeCodeOption,0);</span>
<span class="nc" id="L614">    flagMap.put(printNonMatchingTreesOption,0);</span>
<span class="nc" id="L615">    flagMap.put(encodingOption,1);</span>
<span class="nc" id="L616">    flagMap.put(inputFileOption,1);</span>
<span class="nc" id="L617">    flagMap.put(printHandleOption,1);</span>
<span class="nc" id="L618">    flagMap.put(markHandleOption,2);</span>
<span class="nc" id="L619">    flagMap.put(headFinderOption,1);</span>
<span class="nc" id="L620">    flagMap.put(headFinderArgOption,1);</span>
<span class="nc" id="L621">    flagMap.put(trfOption,1);</span>
<span class="nc" id="L622">    flagMap.put(extensionOption, 1);</span>
<span class="nc" id="L623">    flagMap.put(macroOption, 1);</span>
<span class="nc" id="L624">    flagMap.put(yieldOnly, 0);</span>
<span class="nc" id="L625">    flagMap.put(quietMode, 0);</span>
<span class="nc" id="L626">    flagMap.put(wholeTreeMode, 0);</span>
<span class="nc" id="L627">    flagMap.put(printAllTrees, 0);</span>
<span class="nc" id="L628">    flagMap.put(filenameOption, 0);</span>
<span class="nc" id="L629">    flagMap.put(oneMatchPerRootNodeMode, 0);</span>
<span class="nc" id="L630">    flagMap.put(reportTreeNumbers, 0);</span>
<span class="nc" id="L631">    flagMap.put(rootLabelOnly, 0);</span>
<span class="nc" id="L632">    flagMap.put(oneLine, 0);</span>
<span class="nc" id="L633">    Map&lt;String, String[]&gt; argsMap = StringUtils.argsToMap(args, flagMap);</span>
<span class="nc" id="L634">    args = argsMap.get(null);</span>

<span class="nc bnc" id="L636" title="All 2 branches missed.">    if (argsMap.containsKey(encodingOption)) {</span>
<span class="nc" id="L637">      encoding = argsMap.get(encodingOption)[0];</span>
<span class="nc" id="L638">      log.info(&quot;Encoding set to &quot; + encoding);</span>
    }
<span class="nc" id="L640">    PrintWriter errPW = new PrintWriter(new OutputStreamWriter(System.err, encoding), true);</span>

<span class="nc bnc" id="L642" title="All 2 branches missed.">    if (argsMap.containsKey(extractSubtreesOption)) {</span>
<span class="nc" id="L643">      List&lt;String&gt; subTreeStrings = Collections.singletonList(argsMap.get(extractSubtreesOption)[0]);</span>
<span class="nc" id="L644">      extractSubtrees(subTreeStrings,argsMap.get(extractSubtreesOption)[1]);</span>
<span class="nc" id="L645">      return;</span>
    }
<span class="nc bnc" id="L647" title="All 2 branches missed.">    if (argsMap.containsKey(extractSubtreesFileOption)) {</span>
<span class="nc" id="L648">      List&lt;String&gt; subTreeStrings = Arrays.asList(IOUtils.slurpFile(argsMap.get(extractSubtreesFileOption)[0]).split(&quot;\n|\r|\n\r&quot;));</span>
<span class="nc" id="L649">      extractSubtrees(subTreeStrings,argsMap.get(extractSubtreesFileOption)[0]);</span>
<span class="nc" id="L650">      return;</span>
    }

<span class="nc bnc" id="L653" title="All 2 branches missed.">    if (args.length &lt; 1) {</span>
<span class="nc" id="L654">      errPW.println(&quot;Usage: java edu.stanford.nlp.trees.tregex.TregexPattern [-T] [-C] [-w] [-f] [-o] [-n] [-s] [-filter]  [-hf class] [-trf class] [-h handle]* [-e ext] pattern [filepath]&quot;);</span>
<span class="nc" id="L655">      return;</span>
    }
<span class="nc" id="L657">    String matchString = args[0];</span>

<span class="nc bnc" id="L659" title="All 2 branches missed.">    if (argsMap.containsKey(macroOption)) {</span>
<span class="nc" id="L660">      macroFilename = argsMap.get(macroOption)[0];</span>
    }
<span class="nc bnc" id="L662" title="All 2 branches missed.">    if (argsMap.containsKey(headFinderOption)) {</span>
<span class="nc" id="L663">      headFinderClassName = argsMap.get(headFinderOption)[0];</span>
<span class="nc" id="L664">      errPW.println(&quot;Using head finder &quot; + headFinderClassName + &quot;...&quot;);</span>
    }
<span class="nc bnc" id="L666" title="All 2 branches missed.">    if(argsMap.containsKey(headFinderArgOption)) {</span>
<span class="nc" id="L667">      headFinderArgs = argsMap.get(headFinderArgOption);</span>
    }
<span class="nc bnc" id="L669" title="All 2 branches missed.">    if (argsMap.containsKey(trfOption)) {</span>
<span class="nc" id="L670">      treeReaderFactoryClassName = argsMap.get(trfOption)[0];</span>
<span class="nc" id="L671">      errPW.println(&quot;Using tree reader factory &quot; + treeReaderFactoryClassName + &quot;...&quot;);</span>
    }
<span class="nc bnc" id="L673" title="All 2 branches missed.">    if (argsMap.containsKey(extensionOption)) {</span>
<span class="nc" id="L674">      extension = argsMap.get(extensionOption)[0];</span>
    }
<span class="nc bnc" id="L676" title="All 2 branches missed.">    if (argsMap.containsKey(printAllTrees)) {</span>
<span class="nc" id="L677">      TRegexTreeVisitor.printTree = true;</span>
    }
<span class="nc bnc" id="L679" title="All 2 branches missed.">    if (argsMap.containsKey(inputFileOption)) {</span>
<span class="nc" id="L680">      String inputFile = argsMap.get(inputFileOption)[0];</span>
<span class="nc" id="L681">      matchString = IOUtils.slurpFile(inputFile, encoding);</span>
<span class="nc" id="L682">      String[] newArgs = new String[args.length+1];</span>
<span class="nc" id="L683">      System.arraycopy(args,0,newArgs,1,args.length);</span>
<span class="nc" id="L684">      args = newArgs;</span>
    }
<span class="nc bnc" id="L686" title="All 2 branches missed.">    if (argsMap.containsKey(quietMode)) {</span>
<span class="nc" id="L687">      TRegexTreeVisitor.printMatches = false;</span>
<span class="nc" id="L688">      TRegexTreeVisitor.printNumMatchesToStdOut = true ;</span>

    }
<span class="nc bnc" id="L691" title="All 2 branches missed.">    if (argsMap.containsKey(printNonMatchingTreesOption)) {</span>
<span class="nc" id="L692">      TRegexTreeVisitor.printNonMatchingTrees = true;</span>
    }
<span class="nc bnc" id="L694" title="All 2 branches missed.">    if (argsMap.containsKey(subtreeCodeOption)) {</span>
<span class="nc" id="L695">      TRegexTreeVisitor.printSubtreeCode = true;</span>
<span class="nc" id="L696">      TRegexTreeVisitor.printMatches = false;</span>
    }
<span class="nc bnc" id="L698" title="All 2 branches missed.">    if (argsMap.containsKey(wholeTreeMode)) {</span>
<span class="nc" id="L699">      TRegexTreeVisitor.printWholeTree = true;</span>
    }
<span class="nc bnc" id="L701" title="All 2 branches missed.">    if (argsMap.containsKey(filenameOption)) {</span>
<span class="nc" id="L702">      TRegexTreeVisitor.printFilename = true;</span>
    }
<span class="nc bnc" id="L704" title="All 2 branches missed.">    if(argsMap.containsKey(oneMatchPerRootNodeMode))</span>
<span class="nc" id="L705">      TRegexTreeVisitor.oneMatchPerRootNode = true;</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">    if(argsMap.containsKey(reportTreeNumbers))</span>
<span class="nc" id="L707">      TRegexTreeVisitor.reportTreeNumbers = true;</span>
<span class="nc bnc" id="L708" title="All 2 branches missed.">    if (argsMap.containsKey(rootLabelOnly)) {</span>
<span class="nc" id="L709">      treePrintFormats.append(TreePrint.rootLabelOnlyFormat).append(',');</span>
<span class="nc bnc" id="L710" title="All 2 branches missed.">    } else if (argsMap.containsKey(oneLine)) { // display short form</span>
<span class="nc" id="L711">      treePrintFormats.append(&quot;oneline,&quot;);</span>
<span class="nc bnc" id="L712" title="All 2 branches missed.">    } else if (argsMap.containsKey(yieldOnly)) {</span>
<span class="nc" id="L713">      treePrintFormats.append(&quot;words,&quot;);</span>
    } else {
<span class="nc" id="L715">      treePrintFormats.append(&quot;penn,&quot;);</span>
    }

<span class="nc" id="L718">    HeadFinder hf = new CollinsHeadFinder();</span>
<span class="nc bnc" id="L719" title="All 2 branches missed.">    if(headFinderClassName != null) {</span>
<span class="nc" id="L720">      Class[] hfArgClasses = new Class[headFinderArgs.length];</span>
<span class="nc bnc" id="L721" title="All 2 branches missed.">      for(int i = 0; i &lt; hfArgClasses.length; i++)   hfArgClasses[i] = String.class;</span>
      try {
<span class="nc" id="L723">        hf = (HeadFinder) Class.forName(headFinderClassName).getConstructor(hfArgClasses).newInstance((Object[]) headFinderArgs); // cast to Object[] necessary to avoid varargs-related warning.</span>
      }
<span class="nc" id="L725">      catch(Exception e) { throw new RuntimeException(&quot;Error occurred while constructing HeadFinder: &quot; + e); }</span>
    }

<span class="nc" id="L728">    TRegexTreeVisitor.tp = new TreePrint(treePrintFormats.toString(), new PennTreebankLanguagePack());</span>

    try {
      //TreePattern p = TreePattern.compile(&quot;/^S/ &gt; S=dt $++ '' $-- ``&quot;);
<span class="nc" id="L732">      TregexPatternCompiler tpc = new TregexPatternCompiler(hf);</span>
<span class="nc" id="L733">      Macros.addAllMacros(tpc, macroFilename, encoding);</span>
<span class="nc" id="L734">      TregexPattern p = tpc.compile(matchString);</span>
<span class="nc" id="L735">      errPW.println(&quot;Pattern string:\n&quot; + p.pattern());</span>
<span class="nc" id="L736">      errPW.println(&quot;Parsed representation:&quot;);</span>
<span class="nc" id="L737">      p.prettyPrint(errPW);</span>

<span class="nc" id="L739">      String[] handles = argsMap.get(printHandleOption);</span>
<span class="nc bnc" id="L740" title="All 2 branches missed.">      if (argsMap.containsKey(&quot;-filter&quot;)) {</span>
<span class="nc" id="L741">        TreeReaderFactory trf = getTreeReaderFactory(treeReaderFactoryClassName);</span>
<span class="nc" id="L742">        treebank = new MemoryTreebank(trf, encoding);//has to be in memory since we're not storing it on disk</span>
        //read from stdin
<span class="nc" id="L744">        Reader reader = new BufferedReader(new InputStreamReader(System.in, encoding));</span>
<span class="nc" id="L745">        ((MemoryTreebank) treebank).load(reader);</span>
<span class="nc" id="L746">        reader.close();</span>
<span class="nc bnc" id="L747" title="All 2 branches missed.">      } else if (args.length == 1) {</span>
<span class="nc" id="L748">        errPW.println(&quot;using default tree&quot;);</span>
<span class="nc" id="L749">        TreeReader r = new PennTreeReader(new StringReader(&quot;(VP (VP (VBZ Try) (NP (NP (DT this) (NN wine)) (CC and) (NP (DT these) (NNS snails)))) (PUNCT .))&quot;), new LabeledScoredTreeFactory(new StringLabelFactory()));</span>
<span class="nc" id="L750">        Tree t = r.readTree();</span>
<span class="nc" id="L751">        treebank = new MemoryTreebank();</span>
<span class="nc" id="L752">        treebank.add(t);</span>
<span class="nc" id="L753">      } else {</span>
<span class="nc" id="L754">        int last = args.length - 1;</span>
<span class="nc" id="L755">        errPW.println(&quot;Reading trees from file(s) &quot; + args[last]);</span>
<span class="nc" id="L756">        TreeReaderFactory trf = getTreeReaderFactory(treeReaderFactoryClassName);</span>

<span class="nc" id="L758">        treebank = new DiskTreebank(trf, encoding);</span>
<span class="nc" id="L759">        treebank.loadPath(args[last], extension, true);</span>
      }
<span class="nc" id="L761">      TRegexTreeVisitor vis = new TRegexTreeVisitor(p, handles, encoding);</span>

<span class="nc" id="L763">      treebank.apply(vis);</span>
<span class="nc" id="L764">      Timing.endTime();</span>
<span class="nc bnc" id="L765" title="All 2 branches missed.">      if (TRegexTreeVisitor.printMatches) {</span>
<span class="nc" id="L766">        errPW.println(&quot;There were &quot; + vis.numMatches() + &quot; matches in total.&quot;);</span>
      }
<span class="nc bnc" id="L768" title="All 2 branches missed.">      if (TRegexTreeVisitor.printNumMatchesToStdOut) {</span>
<span class="nc" id="L769">        System.out.println(vis.numMatches());</span>
      }
<span class="nc" id="L771">    } catch (IOException e) {</span>
<span class="nc" id="L772">      e.printStackTrace();</span>
<span class="nc" id="L773">    } catch (TregexParseException e) {</span>
<span class="nc" id="L774">      errPW.println(&quot;Error parsing expression: &quot; + args[0]);</span>
<span class="nc" id="L775">      errPW.println(&quot;Parse exception: &quot; + e.toString());</span>
<span class="nc" id="L776">    }</span>
<span class="nc" id="L777">  }</span>

  private static TreeReaderFactory getTreeReaderFactory(String treeReaderFactoryClassName) {
<span class="nc" id="L780">    TreeReaderFactory trf = new TRegexTreeReaderFactory();</span>
<span class="nc bnc" id="L781" title="All 2 branches missed.">    if (treeReaderFactoryClassName != null) {</span>
      try {
<span class="nc" id="L783">        trf = (TreeReaderFactory) Class.forName(treeReaderFactoryClassName).newInstance();</span>
<span class="nc" id="L784">      } catch(Exception e) {</span>
<span class="nc" id="L785">        throw new RuntimeException(&quot;Error occurred while constructing TreeReaderFactory: &quot; + e);</span>
<span class="nc" id="L786">      }</span>
    }
<span class="nc" id="L788">    return trf;</span>
  }

  private static Treebank treebank; // used by main method, must be accessible

  // not thread-safe, but only used by TregexPattern's main method
  private static class TRegexTreeVisitor implements TreeVisitor {

<span class="nc" id="L796">    private static boolean printNumMatchesToStdOut = false;</span>
<span class="nc" id="L797">    static boolean printNonMatchingTrees = false;</span>
<span class="nc" id="L798">    static boolean printSubtreeCode = false;</span>
<span class="nc" id="L799">    static boolean printTree = false;</span>
<span class="nc" id="L800">    static boolean printWholeTree = false;</span>
<span class="nc" id="L801">    static boolean printMatches = true;</span>
<span class="nc" id="L802">    static boolean printFilename = false;</span>
<span class="nc" id="L803">    static boolean oneMatchPerRootNode = false;</span>
<span class="nc" id="L804">    static boolean reportTreeNumbers = false;</span>

    static TreePrint tp;
    private PrintWriter pw;

<span class="nc" id="L809">    int treeNumber = 0;</span>

    private final TregexPattern p;
    String[] handles;
    int numMatches;

<span class="nc" id="L815">    TRegexTreeVisitor(TregexPattern p, String[] handles, String encoding) {</span>
<span class="nc" id="L816">      this.p = p;</span>
<span class="nc" id="L817">      this.handles = handles;</span>
      try {
<span class="nc" id="L819">        pw = new PrintWriter(new OutputStreamWriter(System.out, encoding),true);</span>
      }
<span class="nc" id="L821">      catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L822">        log.info(&quot;Error -- encoding &quot; + encoding + &quot; is unsupported.  Using platform default PrintWriter instead.&quot;);</span>
<span class="nc" id="L823">        pw = new PrintWriter(System.out,true);</span>
<span class="nc" id="L824">      }</span>
<span class="nc" id="L825">    }</span>

    // todo: add an option to only print each tree once, regardless.  Most useful in conjunction with -w
    public void visitTree(Tree t) {
<span class="nc" id="L829">      treeNumber++;</span>
<span class="nc bnc" id="L830" title="All 2 branches missed.">      if (printTree) {</span>
<span class="nc" id="L831">        pw.print(treeNumber+&quot;:&quot;);</span>
<span class="nc" id="L832">        pw.println(&quot;Next tree read:&quot;);</span>
<span class="nc" id="L833">        tp.printTree(t,pw);</span>
      }
<span class="nc" id="L835">      TregexMatcher match = p.matcher(t);</span>
<span class="nc bnc" id="L836" title="All 2 branches missed.">      if(printNonMatchingTrees) {</span>
<span class="nc bnc" id="L837" title="All 2 branches missed.">        if(match.find())</span>
<span class="nc" id="L838">          numMatches++;</span>
        else
<span class="nc" id="L840">          tp.printTree(t,pw);</span>
<span class="nc" id="L841">        return;</span>
      }
<span class="nc" id="L843">      Tree lastMatchingRootNode = null;</span>
<span class="nc bnc" id="L844" title="All 2 branches missed.">      while (match.find()) {</span>
<span class="nc bnc" id="L845" title="All 2 branches missed.">        if(oneMatchPerRootNode) {</span>
<span class="nc bnc" id="L846" title="All 2 branches missed.">          if(lastMatchingRootNode == match.getMatch())</span>
<span class="nc" id="L847">            continue;</span>
          else
<span class="nc" id="L849">            lastMatchingRootNode = match.getMatch();</span>
        }
<span class="nc" id="L851">        numMatches++;</span>
<span class="nc bnc" id="L852" title="All 4 branches missed.">        if (printFilename &amp;&amp; treebank instanceof DiskTreebank) {</span>
<span class="nc" id="L853">          DiskTreebank dtb = (DiskTreebank) treebank;</span>
<span class="nc" id="L854">          pw.print(&quot;# &quot;);</span>
<span class="nc" id="L855">          pw.println(dtb.getCurrentFilename());</span>
        }
<span class="nc bnc" id="L857" title="All 2 branches missed.">        if(printSubtreeCode) {</span>
<span class="nc" id="L858">          pw.print(treeNumber);</span>
<span class="nc" id="L859">          pw.print(':');</span>
<span class="nc" id="L860">          pw.println(match.getMatch().nodeNumber(t));</span>
        }
<span class="nc bnc" id="L862" title="All 2 branches missed.">        if (printMatches) {</span>
<span class="nc bnc" id="L863" title="All 2 branches missed.">          if(reportTreeNumbers) {</span>
<span class="nc" id="L864">            pw.print(treeNumber);</span>
<span class="nc" id="L865">            pw.print(&quot;: &quot;);</span>
          }
<span class="nc bnc" id="L867" title="All 2 branches missed.">          if (printTree) {</span>
<span class="nc" id="L868">            pw.println(&quot;Found a full match:&quot;);</span>
          }
<span class="nc bnc" id="L870" title="All 2 branches missed.">          if (printWholeTree) {</span>
<span class="nc" id="L871">            tp.printTree(t,pw);</span>
<span class="nc bnc" id="L872" title="All 2 branches missed.">          } else if (handles != null) {</span>
<span class="nc bnc" id="L873" title="All 2 branches missed.">            if (printTree) {</span>
<span class="nc" id="L874">              pw.println(&quot;Here's the node you were interested in:&quot;);</span>
            }
<span class="nc bnc" id="L876" title="All 2 branches missed.">            for (String handle : handles) {</span>
<span class="nc" id="L877">              Tree labeledNode = match.getNode(handle);</span>
<span class="nc bnc" id="L878" title="All 2 branches missed.">              if (labeledNode == null) {</span>
<span class="nc" id="L879">                log.info(&quot;Error!!  There is no matched node \&quot;&quot; + handle + &quot;\&quot;!  Did you specify such a label in the pattern?&quot;);</span>
              } else {
<span class="nc" id="L881">                tp.printTree(labeledNode,pw);</span>
              }
            }
          } else {
<span class="nc" id="L885">            tp.printTree(match.getMatch(),pw);</span>
          }
          // pw.println();  // TreePrint already puts a blank line in
        } // end if (printMatches)
      } // end while match.find()
<span class="nc" id="L890">    } // end visitTree</span>

    public int numMatches() {
<span class="nc" id="L893">      return numMatches;</span>
    }

  } // end class TRegexTreeVisitor

  private static final long serialVersionUID = 5060298043763944913L;


  public static class TRegexTreeReaderFactory implements TreeReaderFactory {

    private final TreeNormalizer tn;

    public TRegexTreeReaderFactory() {
<span class="nc" id="L906">      this(new TreeNormalizer() {</span>
        /**
         *
         */
        private static final long serialVersionUID = -2998972954089638189L;

        @Override
        public String normalizeNonterminal(String str) {
<span class="nc bnc" id="L914" title="All 2 branches missed.">          if (str == null) {</span>
<span class="nc" id="L915">            return &quot;&quot;;</span>
          } else {
<span class="nc" id="L917">            return str;</span>
          }
        }
      });
<span class="nc" id="L921">    }</span>

<span class="nc" id="L923">    public TRegexTreeReaderFactory(TreeNormalizer tn) {</span>
<span class="nc" id="L924">      this.tn = tn;</span>
<span class="nc" id="L925">    }</span>

    public TreeReader newTreeReader(Reader in) {
<span class="nc" id="L928">      return new PennTreeReader(new BufferedReader(in), new LabeledScoredTreeFactory(), tn);</span>
    }

  } // end class TRegexTreeReaderFactory
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>