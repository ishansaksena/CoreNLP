<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Relation.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.trees.tregex</a> &gt; <span class="el_source">Relation.java</span></div><h1>Relation.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.trees.tregex; 
import edu.stanford.nlp.util.logging.Redwood;

import java.io.Serializable;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Stack;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import edu.stanford.nlp.trees.HeadFinder;
import edu.stanford.nlp.trees.Tree;
import edu.stanford.nlp.trees.Trees;
import java.util.function.Function;
import edu.stanford.nlp.util.Generics;
import edu.stanford.nlp.util.IdentityHashSet;
import edu.stanford.nlp.util.Interner;
import edu.stanford.nlp.util.Pair;


/**
 * An abstract base class for relations between tree nodes in tregex. There are
 * two types of subclasses: static anonymous singleton instantiations for
 * relations that do not require arguments, and private subclasses for those
 * with arguments. All invocations should be made through the static factory
 * methods, which insure that there is only a single instance of each relation.
 * Thus == can be used instead of .equals.
 * &lt;p/&gt;
 * If you want to add a new
 * relation, you just have to fill in the definition of satisfies and
 * searchNodeIterator. Also be careful to make the appropriate adjustments to
 * getRelation and SIMPLE_RELATIONS. Finally, if you are using the TregexParser,
 * you need to add the new relation symbol to the list of tokens.
 *
 * @author Galen Andrew
 * @author Roger Levy
 * @author Christopher Manning
 */
abstract class Relation implements Serializable {


  /**
   *
   */
  private static final long serialVersionUID = -1564793674551362909L;

  private final String symbol;

  /** Whether this relationship is satisfied between two trees.
   *
   * @param t1 The tree that is the left operand.
   * @param t2 The tree that is the right operand.
   * @param root The common root of t1 and t2
   * @return Whether this relationship is satisfied.
   */
  abstract boolean satisfies(Tree t1, Tree t2, Tree root, final TregexMatcher matcher);

  /**
   * For a given node, returns an {@link Iterator} over the nodes
   * of the tree containing the node that satisfy the relation.
   *
   * @param t A node in a Tree
   * @param matcher The matcher that nodes have to satisfy
   * @return An Iterator over the nodes
   *     of the root tree that satisfy the relation.
   */
  abstract Iterator&lt;Tree&gt; searchNodeIterator(final Tree t,
                                             final TregexMatcher matcher);

<span class="fc" id="L73">  private static final Pattern parentOfLastChild = Pattern.compile(&quot;(&lt;-|&lt;`)&quot;);</span>

<span class="fc" id="L75">  private static final Pattern lastChildOfParent = Pattern.compile(&quot;(&gt;-|&gt;`)&quot;);</span>

  /**
   * Static factory method for all relations with no arguments. Includes:
   * DOMINATES, DOMINATED_BY, PARENT_OF, CHILD_OF, PRECEDES,
   * IMMEDIATELY_PRECEDES, HAS_LEFTMOST_DESCENDANT, HAS_RIGHTMOST_DESCENDANT,
   * LEFTMOST_DESCENDANT_OF, RIGHTMOST_DESCENDANT_OF, SISTER_OF, LEFT_SISTER_OF,
   * RIGHT_SISTER_OF, IMMEDIATE_LEFT_SISTER_OF, IMMEDIATE_RIGHT_SISTER_OF,
   * HEADS, HEADED_BY, IMMEDIATELY_HEADS, IMMEDIATELY_HEADED_BY, ONLY_CHILD_OF,
   * HAS_ONLY_CHILD, EQUALS
   *
   * @param s The String representation of the relation
   * @return The singleton static relation of the specified type
   * @throws ParseException If bad relation s
   */
  static Relation getRelation(String s,
                              Function&lt;String, String&gt; basicCatFunction,
                              HeadFinder headFinder)
    throws ParseException
  {
<span class="fc bfc" id="L95" title="All 2 branches covered.">    if (SIMPLE_RELATIONS_MAP.containsKey(s))</span>
<span class="fc" id="L96">      return SIMPLE_RELATIONS_MAP.get(s);</span>

    // these are shorthands for relations with arguments
<span class="fc bfc" id="L99" title="All 2 branches covered.">    if (s.equals(&quot;&lt;,&quot;)) {</span>
<span class="fc" id="L100">      return getRelation(&quot;&lt;&quot;, &quot;1&quot;, basicCatFunction, headFinder);</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">    } else if (parentOfLastChild.matcher(s).matches()) {</span>
<span class="fc" id="L102">      return getRelation(&quot;&lt;&quot;, &quot;-1&quot;, basicCatFunction, headFinder);</span>
<span class="fc bfc" id="L103" title="All 2 branches covered.">    } else if (s.equals(&quot;&gt;,&quot;)) {</span>
<span class="fc" id="L104">      return getRelation(&quot;&gt;&quot;, &quot;1&quot;, basicCatFunction, headFinder);</span>
<span class="fc bfc" id="L105" title="All 2 branches covered.">    } else if (lastChildOfParent.matcher(s).matches()) {</span>
<span class="fc" id="L106">      return getRelation(&quot;&gt;&quot;, &quot;-1&quot;, basicCatFunction, headFinder);</span>
    }

    // finally try relations with headFinders
    Relation r;
<span class="pc bpc" id="L111" title="6 of 18 branches missed.">    switch (s) {</span>
      case &quot;&gt;&gt;#&quot;:
<span class="fc" id="L113">        r = new Heads(headFinder);</span>
<span class="fc" id="L114">        break;</span>
      case &quot;&lt;&lt;#&quot;:
<span class="fc" id="L116">        r = new HeadedBy(headFinder);</span>
<span class="fc" id="L117">        break;</span>
      case &quot;&gt;#&quot;:
<span class="fc" id="L119">        r = new ImmediatelyHeads(headFinder);</span>
<span class="fc" id="L120">        break;</span>
      case &quot;&lt;#&quot;:
<span class="fc" id="L122">        r = new ImmediatelyHeadedBy(headFinder);</span>
<span class="fc" id="L123">        break;</span>
      default:
<span class="nc" id="L125">        throw new ParseException(&quot;Unrecognized simple relation &quot; + s);</span>
    }

<span class="fc" id="L128">    return Interner.globalIntern(r);</span>
  }

  /**
   * Static factory method for relations requiring an argument, including
   * HAS_ITH_CHILD, ITH_CHILD_OF, UNBROKEN_CATEGORY_DOMINATES,
   * UNBROKEN_CATEGORY_DOMINATED_BY.
   *
   * @param s The String representation of the relation
   * @param arg The argument to the relation, as a string; could be a node
   *          description or an integer
   * @return The singleton static relation of the specified type with the
   *         specified argument. Uses Interner to insure singleton-ity
   * @throws ParseException If bad relation s
   */
  static Relation getRelation(String s, String arg,
                              Function&lt;String,String&gt; basicCatFunction,
                              HeadFinder headFinder)
    throws ParseException
  {
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">    if (arg == null) {</span>
<span class="nc" id="L149">      return getRelation(s, basicCatFunction, headFinder);</span>
    }
    Relation r;
<span class="pc bpc" id="L152" title="8 of 26 branches missed.">    switch (s) {</span>
      case &quot;&lt;&quot;:
<span class="fc" id="L154">        r = new HasIthChild(Integer.parseInt(arg));</span>
<span class="fc" id="L155">        break;</span>
      case &quot;&gt;&quot;:
<span class="fc" id="L157">        r = new IthChildOf(Integer.parseInt(arg));</span>
<span class="fc" id="L158">        break;</span>
      case &quot;&lt;+&quot;:
<span class="fc" id="L160">        r = new UnbrokenCategoryDominates(arg, basicCatFunction);</span>
<span class="fc" id="L161">        break;</span>
      case &quot;&gt;+&quot;:
<span class="fc" id="L163">        r = new UnbrokenCategoryIsDominatedBy(arg, basicCatFunction);</span>
<span class="fc" id="L164">        break;</span>
      case &quot;.+&quot;:
<span class="fc" id="L166">        r = new UnbrokenCategoryPrecedes(arg, basicCatFunction);</span>
<span class="fc" id="L167">        break;</span>
      case &quot;,+&quot;:
<span class="fc" id="L169">        r = new UnbrokenCategoryFollows(arg, basicCatFunction);</span>
<span class="fc" id="L170">        break;</span>
      default:
<span class="nc" id="L172">        throw new ParseException(&quot;Unrecognized compound relation &quot; + s + ' '</span>
            + arg);
    }
<span class="fc" id="L175">    return Interner.globalIntern(r);</span>
  }

  /**
   * Produce a TregexPattern which represents the given MULTI_RELATION
   * and its children
   */
  static TregexPattern constructMultiRelation(String s, List&lt;DescriptionPattern&gt; children,
                                              Function&lt;String, String&gt; basicCatFunction,
                                              HeadFinder headFinder) throws ParseException {
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">    if (s.equals(&quot;&lt;...&quot;)) {</span>
<span class="fc" id="L186">      List&lt;TregexPattern&gt; newChildren = Generics.newArrayList();</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">      for (int i = 0; i &lt; children.size(); ++i) {</span>
<span class="fc" id="L188">        Relation rel = getRelation(&quot;&lt;&quot;, Integer.toString(i + 1), basicCatFunction, headFinder); </span>
<span class="fc" id="L189">        DescriptionPattern oldChild = children.get(i);</span>
<span class="fc" id="L190">        TregexPattern newChild = new DescriptionPattern(rel, oldChild);</span>
<span class="fc" id="L191">        newChildren.add(newChild);</span>
      }
<span class="fc" id="L193">      Relation rel = getRelation(&quot;&lt;&quot;, Integer.toString(children.size() + 1), basicCatFunction, headFinder);</span>
<span class="fc" id="L194">      TregexPattern noExtraChildren = new DescriptionPattern(rel, false, &quot;__&quot;, null, false, basicCatFunction, Collections.&lt;Pair&lt;Integer,String&gt;&gt;emptyList(), false, null);</span>
<span class="fc" id="L195">      noExtraChildren.negate();</span>
<span class="fc" id="L196">      newChildren.add(noExtraChildren);</span>
<span class="fc" id="L197">      return new CoordinationPattern(newChildren, true);</span>
    } else {
<span class="nc" id="L199">      throw new ParseException(&quot;Unknown multi relation &quot; + s);</span>
    }
  }

<span class="fc" id="L203">  private Relation(String symbol) {</span>
<span class="fc" id="L204">    this.symbol = symbol;</span>
<span class="fc" id="L205">  }</span>

  @Override
  public String toString() {
<span class="nc" id="L209">    return symbol;</span>
  }

  /**
   * This abstract Iterator implements a NULL iterator, but by subclassing and
   * overriding advance and/or initialize, it is an efficient implementation.
   */
  abstract static class SearchNodeIterator implements Iterator&lt;Tree&gt; {
<span class="fc" id="L217">    public SearchNodeIterator() {</span>
<span class="fc" id="L218">      initialize();</span>
<span class="fc" id="L219">    }</span>

    /**
     * This is the next tree to be returned by the iterator, or null if there
     * are no more items.
     */
    Tree next; // = null;

    /**
     * This method must insure that next points to first item, or null if there
     * are no items.
     */
    void initialize() {
<span class="fc" id="L232">      advance();</span>
<span class="fc" id="L233">    }</span>

    /**
     * This method must insure that next points to next item, or null if there
     * are no more items.
     */
    void advance() {
<span class="fc" id="L240">      next = null;</span>
<span class="fc" id="L241">    }</span>

    @Override
    public boolean hasNext() {
<span class="fc bfc" id="L245" title="All 2 branches covered.">      return next != null;</span>
    }

    @Override
    public Tree next() {
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">      if (next == null) {</span>
<span class="nc" id="L251">        throw new NoSuchElementException();</span>
      }
<span class="fc" id="L253">      Tree ret = next;</span>
<span class="fc" id="L254">      advance();</span>
<span class="fc" id="L255">      return ret;</span>
    }

    @Override
    public void remove() {
<span class="nc" id="L260">      throw new UnsupportedOperationException(</span>
          &quot;SearchNodeIterator does not support remove().&quot;);
    }
  }

<span class="fc" id="L265">  static final Relation ROOT = new Relation(&quot;Root&quot;) {  // used in TregexParser</span>

    private static final long serialVersionUID = -8311913236233762612L;

    @Override
    boolean satisfies(Tree t1, Tree t2, Tree root, final TregexMatcher matcher) {
<span class="nc bnc" id="L271" title="All 2 branches missed.">      return t1 == t2;</span>
    }

    @Override
    Iterator&lt;Tree&gt; searchNodeIterator(final Tree t,
                                      final TregexMatcher matcher) {
<span class="fc" id="L277">      return new SearchNodeIterator() {</span>
        @Override
        void initialize() {
<span class="fc" id="L280">          next = t;</span>
<span class="fc" id="L281">        }</span>
      };
    }
  };

<span class="fc" id="L286">  private static final Relation EQUALS = new Relation(&quot;==&quot;) {</span>

    private static final long serialVersionUID = 164629344977943816L;

    @Override
    boolean satisfies(Tree t1, Tree t2, Tree root, final TregexMatcher matcher) {
<span class="nc bnc" id="L292" title="All 2 branches missed.">      return t1 == t2;</span>
    }

    @Override
    Iterator&lt;Tree&gt; searchNodeIterator(final Tree t,
                                      final TregexMatcher matcher) {
<span class="fc" id="L298">      return Collections.singletonList(t).iterator();</span>
    }

  };

  /* this is a &quot;dummy&quot; relation that allows you to segment patterns. */
<span class="fc" id="L304">  private static final Relation PATTERN_SPLITTER = new Relation(&quot;:&quot;) {</span>

    private static final long serialVersionUID = 3409941930361386114L;

    @Override
    boolean satisfies(Tree t1, Tree t2, Tree root, final TregexMatcher matcher) {
<span class="nc" id="L310">      return true;</span>
    }

    @Override
    Iterator&lt;Tree&gt; searchNodeIterator(final Tree t,
                                      final TregexMatcher matcher) {
<span class="fc" id="L316">      return matcher.getRoot().iterator();</span>
    }
  };

<span class="fc" id="L320">  private static final Relation DOMINATES = new Relation(&quot;&lt;&lt;&quot;) {</span>

    private static final long serialVersionUID = -2580199434621268260L;

    @Override
    boolean satisfies(Tree t1, Tree t2, Tree root, final TregexMatcher matcher) {
<span class="nc bnc" id="L326" title="All 4 branches missed.">      return t1 != t2 &amp;&amp; t1.dominates(t2);</span>
    }

    @Override
    Iterator&lt;Tree&gt; searchNodeIterator(final Tree t,
                                      final TregexMatcher matcher) {
<span class="fc" id="L332">      return new SearchNodeIterator() {</span>
        Stack&lt;Tree&gt; searchStack;

        @Override
        public void initialize() {
<span class="fc" id="L337">          searchStack = new Stack&lt;&gt;();</span>
<span class="fc bfc" id="L338" title="All 2 branches covered.">          for (int i = t.numChildren() - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L339">            searchStack.push(t.getChild(i));</span>
          }
<span class="pc bpc" id="L341" title="1 of 2 branches missed.">          if (!searchStack.isEmpty()) {</span>
<span class="fc" id="L342">            advance();</span>
          }
<span class="fc" id="L344">        }</span>

        @Override
        void advance() {
<span class="fc bfc" id="L348" title="All 2 branches covered.">          if (searchStack.isEmpty()) {</span>
<span class="fc" id="L349">            next = null;</span>
          } else {
<span class="fc" id="L351">            next = searchStack.pop();</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">            for (int i = next.numChildren() - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L353">              searchStack.push(next.getChild(i));</span>
            }
          }
<span class="fc" id="L356">        }</span>
      };
    }
  };

<span class="fc" id="L361">  private static final Relation DOMINATED_BY = new Relation(&quot;&gt;&gt;&quot;) {</span>

    private static final long serialVersionUID = 6140614010121387690L;

    @Override
    boolean satisfies(Tree t1, Tree t2, Tree root, final TregexMatcher matcher) {
<span class="nc" id="L367">      return DOMINATES.satisfies(t2, t1, root, matcher);</span>
    }

    @Override
    Iterator&lt;Tree&gt; searchNodeIterator(final Tree t,
                                      final TregexMatcher matcher) {
<span class="fc" id="L373">      return new SearchNodeIterator() {</span>
        @Override
        void initialize() {
<span class="fc" id="L376">          next = matcher.getParent(t);</span>
<span class="fc" id="L377">        }</span>

        @Override
        public void advance() {
<span class="fc" id="L381">          next = matcher.getParent(next);</span>
<span class="fc" id="L382">        }</span>
      };
    }
  };

<span class="fc" id="L387">  private static final Relation PARENT_OF = new Relation(&quot;&lt;&quot;) {</span>

    private static final long serialVersionUID = 9140193735607580808L;

    @Override
    boolean satisfies(Tree t1, Tree t2, Tree root, final TregexMatcher matcher) {
<span class="nc" id="L393">      Tree[] kids = t1.children();</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">      for (Tree kid : kids) {</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">        if (kid == t2) {</span>
<span class="nc" id="L396">          return true;</span>
        }
      }
<span class="nc" id="L399">      return false;</span>
    }

    @Override
    Iterator&lt;Tree&gt; searchNodeIterator(final Tree t,
                                      final TregexMatcher matcher) {
<span class="fc" id="L405">      return new SearchNodeIterator() {</span>
        // subtle bug warning here: if we use 
        //   int nextNum=0;
        // instead, we get the first daughter twice because the
        // assignment occurs after advance() has already been called
        // once by the constructor of SearchNodeIterator.
        int nextNum;

        @Override
        public void advance() {
<span class="fc bfc" id="L415" title="All 2 branches covered.">          if (nextNum &lt; t.numChildren()) {</span>
<span class="fc" id="L416">            next = t.getChild(nextNum);</span>
<span class="fc" id="L417">            nextNum++;</span>
          } else {
<span class="fc" id="L419">            next = null;</span>
          }
<span class="fc" id="L421">        }</span>
      };
    }
  };

<span class="fc" id="L426">  private static final Relation CHILD_OF = new Relation(&quot;&gt;&quot;) {</span>

    private static final long serialVersionUID = 8919710375433372537L;

    @Override
    boolean satisfies(Tree t1, Tree t2, Tree root, final TregexMatcher matcher) {
<span class="nc" id="L432">      return PARENT_OF.satisfies(t2, t1, root, matcher);</span>
    }

    @Override
    Iterator&lt;Tree&gt; searchNodeIterator(final Tree t,
                                      final TregexMatcher matcher) {
<span class="fc" id="L438">      return new SearchNodeIterator() {</span>
        @Override
        void initialize() {
<span class="fc" id="L441">          next = matcher.getParent(t);</span>
<span class="fc" id="L442">        }</span>
      };
    }
  };

<span class="fc" id="L447">  private static final Relation PRECEDES = new Relation(&quot;..&quot;) {</span>

    private static final long serialVersionUID = -9065012389549976867L;

    @Override
    boolean satisfies(Tree t1, Tree t2, Tree root, final TregexMatcher matcher) {
<span class="nc bnc" id="L453" title="All 2 branches missed.">      return Trees.rightEdge(t1, root) &lt;= Trees.leftEdge(t2, root);</span>
    }

    @Override
    Iterator&lt;Tree&gt; searchNodeIterator(final Tree t,
                                      final TregexMatcher matcher) {
<span class="fc" id="L459">      return new SearchNodeIterator() {</span>
        Stack&lt;Tree&gt; searchStack;

        @Override
        public void initialize() {
<span class="fc" id="L464">          searchStack = new Stack&lt;&gt;();</span>
<span class="fc" id="L465">          Tree current = t;</span>
<span class="fc" id="L466">          Tree parent = matcher.getParent(t);</span>
<span class="fc bfc" id="L467" title="All 2 branches covered.">          while (parent != null) {</span>
<span class="fc bfc" id="L468" title="All 2 branches covered.">            for (int i = parent.numChildren() - 1; parent.getChild(i) != current; i--) {</span>
<span class="fc" id="L469">              searchStack.push(parent.getChild(i));</span>
            }
<span class="fc" id="L471">            current = parent;</span>
<span class="fc" id="L472">            parent = matcher.getParent(parent);</span>
          }
<span class="fc" id="L474">          advance();</span>
<span class="fc" id="L475">        }</span>

        @Override
        void advance() {
<span class="fc bfc" id="L479" title="All 2 branches covered.">          if (searchStack.isEmpty()) {</span>
<span class="fc" id="L480">            next = null;</span>
          } else {
<span class="fc" id="L482">            next = searchStack.pop();</span>
<span class="fc bfc" id="L483" title="All 2 branches covered.">            for (int i = next.numChildren() - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L484">              searchStack.push(next.getChild(i));</span>
            }
          }
<span class="fc" id="L487">        }</span>
      };
    }
  };

<span class="fc" id="L492">  private static final Relation IMMEDIATELY_PRECEDES = new Relation(&quot;.&quot;) {</span>

    private static final long serialVersionUID = 3390147676937292768L;

    @Override
    boolean satisfies(Tree t1, Tree t2, Tree root, final TregexMatcher matcher) {
<span class="nc bnc" id="L498" title="All 2 branches missed.">      return Trees.leftEdge(t2, root) == Trees.rightEdge(t1, root);</span>
    }

    @Override
    Iterator&lt;Tree&gt; searchNodeIterator(final Tree t,
                                      final TregexMatcher matcher) {
<span class="fc" id="L504">      return new SearchNodeIterator() {</span>
        @Override
        void initialize() {
          Tree current;
<span class="fc" id="L508">          Tree parent = t;</span>
          do {
<span class="fc" id="L510">            current = parent;</span>
<span class="fc" id="L511">            parent = matcher.getParent(parent);</span>
<span class="fc bfc" id="L512" title="All 2 branches covered.">            if (parent == null) {</span>
<span class="fc" id="L513">              next = null;</span>
<span class="fc" id="L514">              return;</span>
            }
<span class="fc bfc" id="L516" title="All 2 branches covered.">          } while (parent.lastChild() == current);</span>

<span class="pc bpc" id="L518" title="1 of 2 branches missed.">          for (int i = 1, n = parent.numChildren(); i &lt; n; i++) {</span>
<span class="fc bfc" id="L519" title="All 2 branches covered.">            if (parent.getChild(i - 1) == current) {</span>
<span class="fc" id="L520">              next = parent.getChild(i);</span>
<span class="fc" id="L521">              return;</span>
            }
          }
<span class="nc" id="L524">        }</span>

        @Override
        public void advance() {
<span class="fc bfc" id="L528" title="All 2 branches covered.">          if (next.isLeaf()) {</span>
<span class="fc" id="L529">            next = null;</span>
          } else {
<span class="fc" id="L531">            next = next.firstChild();</span>
          }
<span class="fc" id="L533">        }</span>
      };
    }
  };

<span class="fc" id="L538">  private static final Relation FOLLOWS = new Relation(&quot;,,&quot;) {</span>

    private static final long serialVersionUID = -5948063114149496983L;

    @Override
    boolean satisfies(Tree t1, Tree t2, Tree root, final TregexMatcher matcher) {
<span class="nc bnc" id="L544" title="All 2 branches missed.">      return Trees.rightEdge(t2, root) &lt;= Trees.leftEdge(t1, root);</span>
    }

    @Override
    Iterator&lt;Tree&gt; searchNodeIterator(final Tree t,
                                      final TregexMatcher matcher) {
<span class="fc" id="L550">      return new SearchNodeIterator() {</span>
        Stack&lt;Tree&gt; searchStack;

        @Override
        public void initialize() {
<span class="fc" id="L555">          searchStack = new Stack&lt;&gt;();</span>
<span class="fc" id="L556">          Tree current = t;</span>
<span class="fc" id="L557">          Tree parent = matcher.getParent(t);</span>
<span class="fc bfc" id="L558" title="All 2 branches covered.">          while (parent != null) {</span>
<span class="fc bfc" id="L559" title="All 2 branches covered.">            for (int i = 0; parent.getChild(i) != current; i++) {</span>
<span class="fc" id="L560">              searchStack.push(parent.getChild(i));</span>
            }
<span class="fc" id="L562">            current = parent;</span>
<span class="fc" id="L563">            parent = matcher.getParent(parent);</span>
          }
<span class="fc" id="L565">          advance();</span>
<span class="fc" id="L566">        }</span>

        @Override
        void advance() {
<span class="fc bfc" id="L570" title="All 2 branches covered.">          if (searchStack.isEmpty()) {</span>
<span class="fc" id="L571">            next = null;</span>
          } else {
<span class="fc" id="L573">            next = searchStack.pop();</span>
<span class="fc bfc" id="L574" title="All 2 branches covered.">            for (int i = next.numChildren() - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L575">              searchStack.push(next.getChild(i));</span>
            }
          }
<span class="fc" id="L578">        }</span>
      };
    }
  };

<span class="fc" id="L583">  private static final Relation IMMEDIATELY_FOLLOWS = new Relation(&quot;,&quot;) {</span>

    private static final long serialVersionUID = -2895075562891296830L;

    @Override
    boolean satisfies(Tree t1, Tree t2, Tree root, final TregexMatcher matcher) {
<span class="nc bnc" id="L589" title="All 2 branches missed.">      return Trees.leftEdge(t1, root) == Trees.rightEdge(t2, root);</span>
    }

    @Override
    Iterator&lt;Tree&gt; searchNodeIterator(final Tree t,
                                      final TregexMatcher matcher) {
<span class="fc" id="L595">      return new SearchNodeIterator() {</span>
        @Override
        void initialize() {
          Tree current;
<span class="fc" id="L599">          Tree parent = t;</span>
          do {
<span class="fc" id="L601">            current = parent;</span>
<span class="fc" id="L602">            parent = matcher.getParent(parent);</span>
<span class="fc bfc" id="L603" title="All 2 branches covered.">            if (parent == null) {</span>
<span class="fc" id="L604">              next = null;</span>
<span class="fc" id="L605">              return;</span>
            }
<span class="fc bfc" id="L607" title="All 2 branches covered.">          } while (parent.firstChild() == current);</span>

<span class="pc bpc" id="L609" title="1 of 2 branches missed.">          for (int i = 0, n = parent.numChildren() - 1; i &lt; n; i++) {</span>
<span class="fc bfc" id="L610" title="All 2 branches covered.">            if (parent.getChild(i + 1) == current) {</span>
<span class="fc" id="L611">              next = parent.getChild(i);</span>
<span class="fc" id="L612">              return;</span>
            }
          }
<span class="nc" id="L615">        }</span>

        @Override
        public void advance() {
<span class="fc bfc" id="L619" title="All 2 branches covered.">          if (next.isLeaf()) {</span>
<span class="fc" id="L620">            next = null;</span>
          } else {
<span class="fc" id="L622">            next = next.lastChild();</span>
          }
<span class="fc" id="L624">        }</span>
      };
    }
  };

<span class="fc" id="L629">  private static final Relation HAS_LEFTMOST_DESCENDANT = new Relation(&quot;&lt;&lt;,&quot;) {</span>

    private static final long serialVersionUID = -7352081789429366726L;

    @Override
    boolean satisfies(Tree t1, Tree t2, Tree root, final TregexMatcher matcher) {
<span class="nc bnc" id="L635" title="All 2 branches missed.">      if (t1.isLeaf()) {</span>
<span class="nc" id="L636">        return false;</span>
      } else {
<span class="nc bnc" id="L638" title="All 4 branches missed.">        return (t1.children()[0] == t2) || satisfies(t1.children()[0], t2, root, matcher);</span>
      }
    }

    @Override
    Iterator&lt;Tree&gt; searchNodeIterator(final Tree t,
                                      final TregexMatcher matcher) {
<span class="fc" id="L645">      return new SearchNodeIterator() {</span>
        @Override
        void initialize() {
<span class="fc" id="L648">          next = t;</span>
<span class="fc" id="L649">          advance();</span>
<span class="fc" id="L650">        }</span>

        @Override
        public void advance() {
<span class="fc bfc" id="L654" title="All 2 branches covered.">          if (next.isLeaf()) {</span>
<span class="fc" id="L655">            next = null;</span>
          } else {
<span class="fc" id="L657">            next = next.firstChild();</span>
          }
<span class="fc" id="L659">        }</span>
      };
    }
  };

<span class="fc" id="L664">  private static final Relation HAS_RIGHTMOST_DESCENDANT = new Relation(&quot;&lt;&lt;-&quot;) {</span>

    private static final long serialVersionUID = -1405509785337859888L;

    @Override
    boolean satisfies(Tree t1, Tree t2, Tree root, final TregexMatcher matcher) {
<span class="nc bnc" id="L670" title="All 2 branches missed.">      if (t1.isLeaf()) {</span>
<span class="nc" id="L671">        return false;</span>
      } else {
<span class="nc" id="L673">        Tree lastKid = t1.children()[t1.children().length - 1];</span>
<span class="nc bnc" id="L674" title="All 4 branches missed.">        return (lastKid == t2) || satisfies(lastKid, t2, root, matcher);</span>
      }
    }

    @Override
    Iterator&lt;Tree&gt; searchNodeIterator(final Tree t,
                                      final TregexMatcher matcher) {
<span class="fc" id="L681">      return new SearchNodeIterator() {</span>
        @Override
        void initialize() {
<span class="fc" id="L684">          next = t;</span>
<span class="fc" id="L685">          advance();</span>
<span class="fc" id="L686">        }</span>

        @Override
        public void advance() {
<span class="fc bfc" id="L690" title="All 2 branches covered.">          if (next.isLeaf()) {</span>
<span class="fc" id="L691">            next = null;</span>
          } else {
<span class="fc" id="L693">            next = next.lastChild();</span>
          }
<span class="fc" id="L695">        }</span>
      };
    }
  };

<span class="fc" id="L700">  private static final Relation LEFTMOST_DESCENDANT_OF = new Relation(&quot;&gt;&gt;,&quot;) {</span>

    private static final long serialVersionUID = 3103412865783190437L;

    @Override
    boolean satisfies(Tree t1, Tree t2, Tree root, final TregexMatcher matcher) {
<span class="nc" id="L706">      return HAS_LEFTMOST_DESCENDANT.satisfies(t2, t1, root, matcher);</span>
    }

    @Override
    Iterator&lt;Tree&gt; searchNodeIterator(final Tree t,
                                      final TregexMatcher matcher) {
<span class="fc" id="L712">      return new SearchNodeIterator() {</span>
        @Override
        void initialize() {
<span class="fc" id="L715">          next = t;</span>
<span class="fc" id="L716">          advance();</span>
<span class="fc" id="L717">        }</span>

        @Override
        public void advance() {
<span class="fc" id="L721">          Tree last = next;</span>
<span class="fc" id="L722">          next = matcher.getParent(next);</span>
<span class="fc bfc" id="L723" title="All 4 branches covered.">          if (next != null &amp;&amp; next.firstChild() != last) {</span>
<span class="fc" id="L724">            next = null;</span>
          }
<span class="fc" id="L726">        }</span>
      };
    }
  };

<span class="fc" id="L731">  private static final Relation RIGHTMOST_DESCENDANT_OF = new Relation(&quot;&gt;&gt;-&quot;) {</span>

    private static final long serialVersionUID = -2000255467314675477L;

    @Override
    boolean satisfies(Tree t1, Tree t2, Tree root, final TregexMatcher matcher) {
<span class="nc" id="L737">      return HAS_RIGHTMOST_DESCENDANT.satisfies(t2, t1, root, matcher);</span>
    }

    @Override
    Iterator&lt;Tree&gt; searchNodeIterator(final Tree t,
                                      final TregexMatcher matcher) {
<span class="fc" id="L743">      return new SearchNodeIterator() {</span>
        @Override
        void initialize() {
<span class="fc" id="L746">          next = t;</span>
<span class="fc" id="L747">          advance();</span>
<span class="fc" id="L748">        }</span>

        @Override
        public void advance() {
<span class="fc" id="L752">          Tree last = next;</span>
<span class="fc" id="L753">          next = matcher.getParent(next);</span>
<span class="fc bfc" id="L754" title="All 4 branches covered.">          if (next != null &amp;&amp; next.lastChild() != last) {</span>
<span class="fc" id="L755">            next = null;</span>
          }
<span class="fc" id="L757">        }</span>
      };
    }
  };

<span class="fc" id="L762">  private static final Relation SISTER_OF = new Relation(&quot;$&quot;) {</span>

    private static final long serialVersionUID = -3776688096782419004L;

    @Override
    boolean satisfies(Tree t1, Tree t2, Tree root, final TregexMatcher matcher) {
<span class="nc bnc" id="L768" title="All 4 branches missed.">      if (t1 == t2 || t1 == root) {</span>
<span class="nc" id="L769">        return false;</span>
      }
<span class="nc" id="L771">      Tree parent = t1.parent(root);</span>
<span class="nc" id="L772">      return PARENT_OF.satisfies(parent, t2, root, matcher);</span>
    }

    @Override
    Iterator&lt;Tree&gt; searchNodeIterator(final Tree t,
                                      final TregexMatcher matcher) {
<span class="fc" id="L778">      return new SearchNodeIterator() {</span>
        Tree parent;

        int nextNum;

        @Override
        void initialize() {
<span class="fc" id="L785">          parent = matcher.getParent(t);</span>
<span class="fc bfc" id="L786" title="All 2 branches covered.">          if (parent != null) {</span>
<span class="fc" id="L787">            nextNum = 0;</span>
<span class="fc" id="L788">            advance();</span>
          }
<span class="fc" id="L790">        }</span>

        @Override
        public void advance() {
<span class="fc bfc" id="L794" title="All 2 branches covered.">          if (nextNum &lt; parent.numChildren()) {</span>
<span class="fc" id="L795">            next = parent.getChild(nextNum++);</span>
<span class="fc bfc" id="L796" title="All 2 branches covered.">            if (next == t) {</span>
<span class="fc" id="L797">              advance();</span>
            }
          } else {
<span class="fc" id="L800">            next = null;</span>
          }
<span class="fc" id="L802">        }</span>
      };
    }
  };

<span class="fc" id="L807">  private static final Relation LEFT_SISTER_OF = new Relation(&quot;$++&quot;) {</span>

    private static final long serialVersionUID = -4516161080140406862L;

    @Override
    boolean satisfies(Tree t1, Tree t2, Tree root, final TregexMatcher matcher) {
<span class="nc bnc" id="L813" title="All 4 branches missed.">      if (t1 == t2 || t1 == root) {</span>
<span class="nc" id="L814">        return false;</span>
      }
<span class="nc" id="L816">      Tree parent = t1.parent(root);</span>
<span class="nc" id="L817">      Tree[] kids = parent.children();</span>
<span class="nc bnc" id="L818" title="All 2 branches missed.">      for (int i = kids.length - 1; i &gt; 0; i--) {</span>
<span class="nc bnc" id="L819" title="All 2 branches missed.">        if (kids[i] == t1) {</span>
<span class="nc" id="L820">          return false;</span>
        }
<span class="nc bnc" id="L822" title="All 2 branches missed.">        if (kids[i] == t2) {</span>
<span class="nc" id="L823">          return true;</span>
        }
      }
<span class="nc" id="L826">      return false;</span>
    }

    @Override
    Iterator&lt;Tree&gt; searchNodeIterator(final Tree t,
                                      final TregexMatcher matcher) {
<span class="fc" id="L832">      return new SearchNodeIterator() {</span>
        Tree parent;

        int nextNum;

        @Override
        void initialize() {
<span class="fc" id="L839">          parent = matcher.getParent(t);</span>
<span class="fc bfc" id="L840" title="All 2 branches covered.">          if (parent != null) {</span>
<span class="fc" id="L841">            nextNum = parent.numChildren() - 1;</span>
<span class="fc" id="L842">            advance();</span>
          }
<span class="fc" id="L844">        }</span>

        @Override
        public void advance() {
<span class="fc" id="L848">          next = parent.getChild(nextNum--);</span>
<span class="fc bfc" id="L849" title="All 2 branches covered.">          if (next == t) {</span>
<span class="fc" id="L850">            next = null;</span>
          }
<span class="fc" id="L852">        }</span>
      };
    }
  };

<span class="fc" id="L857">  private static final Relation RIGHT_SISTER_OF = new Relation(&quot;$--&quot;) {</span>

    private static final long serialVersionUID = -5880626025192328694L;

    @Override
    boolean satisfies(Tree t1, Tree t2, Tree root, final TregexMatcher matcher) {
<span class="nc" id="L863">      return LEFT_SISTER_OF.satisfies(t2, t1, root, matcher);</span>
    }

    @Override
    Iterator&lt;Tree&gt; searchNodeIterator(final Tree t,
                                      final TregexMatcher matcher) {
<span class="fc" id="L869">      return new SearchNodeIterator() {</span>
        Tree parent;

        int nextNum;

        @Override
        void initialize() {
<span class="fc" id="L876">          parent = matcher.getParent(t);</span>
<span class="fc bfc" id="L877" title="All 2 branches covered.">          if (parent != null) {</span>
<span class="fc" id="L878">            nextNum = 0;</span>
<span class="fc" id="L879">            advance();</span>
          }
<span class="fc" id="L881">        }</span>

        @Override
        public void advance() {
<span class="fc" id="L885">          next = parent.getChild(nextNum++);</span>
<span class="fc bfc" id="L886" title="All 2 branches covered.">          if (next == t) {</span>
<span class="fc" id="L887">            next = null;</span>
          }
<span class="fc" id="L889">        }</span>
      };
    }
  };

<span class="fc" id="L894">  private static final Relation IMMEDIATE_LEFT_SISTER_OF = new Relation(&quot;$+&quot;) {</span>

    private static final long serialVersionUID = 7745237994722126917L;

    @Override
    boolean satisfies(Tree t1, Tree t2, Tree root, final TregexMatcher matcher) {
<span class="nc bnc" id="L900" title="All 4 branches missed.">      if (t1 == t2 || t1 == root) {</span>
<span class="nc" id="L901">        return false;</span>
      }
<span class="nc" id="L903">      Tree[] sisters = t1.parent(root).children();</span>
<span class="nc bnc" id="L904" title="All 2 branches missed.">      for (int i = sisters.length - 1; i &gt; 0; i--) {</span>
<span class="nc bnc" id="L905" title="All 2 branches missed.">        if (sisters[i] == t1) {</span>
<span class="nc" id="L906">          return false;</span>
        }
<span class="nc bnc" id="L908" title="All 2 branches missed.">        if (sisters[i] == t2) {</span>
<span class="nc bnc" id="L909" title="All 2 branches missed.">          return sisters[i - 1] == t1;</span>
        }
      }
<span class="nc" id="L912">      return false;</span>
    }

    @Override
    Iterator&lt;Tree&gt; searchNodeIterator(final Tree t,
                                      final TregexMatcher matcher) {
<span class="fc" id="L918">      return new SearchNodeIterator() {</span>
        @Override
        void initialize() {
<span class="fc bfc" id="L921" title="All 2 branches covered.">          if (t != matcher.getRoot()) {</span>
<span class="fc" id="L922">            Tree parent = matcher.getParent(t);</span>
<span class="fc" id="L923">            int i = 0;</span>
<span class="fc bfc" id="L924" title="All 2 branches covered.">            while (parent.getChild(i) != t) {</span>
<span class="fc" id="L925">              i++;</span>
            }
<span class="fc bfc" id="L927" title="All 2 branches covered.">            if (i + 1 &lt; parent.numChildren()) {</span>
<span class="fc" id="L928">              next = parent.getChild(i + 1);</span>
            }
          }
<span class="fc" id="L931">        }</span>
      };
    }
  };

<span class="fc" id="L936">  private static final Relation IMMEDIATE_RIGHT_SISTER_OF = new Relation(&quot;$-&quot;) {</span>

    private static final long serialVersionUID = -6555264189937531019L;

    @Override
    boolean satisfies(Tree t1, Tree t2, Tree root, final TregexMatcher matcher) {
<span class="nc" id="L942">      return IMMEDIATE_LEFT_SISTER_OF.satisfies(t2, t1, root, matcher);</span>
    }

    @Override
    Iterator&lt;Tree&gt; searchNodeIterator(final Tree t,
                                      final TregexMatcher matcher) {
<span class="fc" id="L948">      return new SearchNodeIterator() {</span>
        @Override
        void initialize() {
<span class="fc bfc" id="L951" title="All 2 branches covered.">          if (t != matcher.getRoot()) {</span>
<span class="fc" id="L952">            Tree parent = matcher.getParent(t);</span>
<span class="fc" id="L953">            int i = 0;</span>
<span class="fc bfc" id="L954" title="All 2 branches covered.">            while (parent.getChild(i) != t) {</span>
<span class="fc" id="L955">              i++;</span>
            }
<span class="fc bfc" id="L957" title="All 2 branches covered.">            if (i &gt; 0) {</span>
<span class="fc" id="L958">              next = parent.getChild(i - 1);</span>
            }
          }
<span class="fc" id="L961">        }</span>
      };
    }
  };

<span class="fc" id="L966">  private static final Relation ONLY_CHILD_OF = new Relation(&quot;&gt;:&quot;) {</span>

    private static final long serialVersionUID = 1719812660770087879L;

    @Override
    boolean satisfies(Tree t1, Tree t2, Tree root, final TregexMatcher matcher) {
<span class="nc bnc" id="L972" title="All 4 branches missed.">      return t2.children().length == 1 &amp;&amp; t2.firstChild() == t1;</span>
    }

    @Override
    Iterator&lt;Tree&gt; searchNodeIterator(final Tree t,
                                      final TregexMatcher matcher) {
<span class="fc" id="L978">      return new SearchNodeIterator() {</span>
        @Override
        void initialize() {
<span class="fc bfc" id="L981" title="All 2 branches covered.">          if (t != matcher.getRoot()) {</span>
<span class="fc" id="L982">            next = matcher.getParent(t);</span>
<span class="fc bfc" id="L983" title="All 2 branches covered.">            if (next.numChildren() != 1) {</span>
<span class="fc" id="L984">              next = null;</span>
            }
          }
<span class="fc" id="L987">        }</span>
      };
    }
  };

<span class="fc" id="L992">  private static final Relation HAS_ONLY_CHILD = new Relation(&quot;&lt;:&quot;) {</span>

    private static final long serialVersionUID = -8776487500849294279L;

    @Override
    boolean satisfies(Tree t1, Tree t2, Tree root, final TregexMatcher matcher) {
<span class="nc bnc" id="L998" title="All 4 branches missed.">      return t1.children().length == 1 &amp;&amp; t1.firstChild() == t2;</span>
    }

    @Override
    Iterator&lt;Tree&gt; searchNodeIterator(final Tree t,
                                      final TregexMatcher matcher) {
<span class="fc" id="L1004">      return new SearchNodeIterator() {</span>
        @Override
        void initialize() {
<span class="fc bfc" id="L1007" title="All 4 branches covered.">          if (!t.isLeaf() &amp;&amp; t.numChildren() == 1) {</span>
<span class="fc" id="L1008">            next = t.firstChild();</span>
          }
<span class="fc" id="L1010">        }</span>
      };
    }
  };

<span class="fc" id="L1015">  private static final Relation UNARY_PATH_ANCESTOR_OF = new Relation(&quot;&lt;&lt;:&quot;) {</span>

    private static final long serialVersionUID = -742912038636163403L;

    @Override
    boolean satisfies(Tree t1, Tree t2, Tree root, final TregexMatcher matcher) {
<span class="nc bnc" id="L1021" title="All 4 branches missed.">      if (t1.isLeaf() || t1.children().length &gt; 1)</span>
<span class="nc" id="L1022">        return false;</span>
<span class="nc" id="L1023">      Tree onlyDtr = t1.children()[0];</span>
<span class="nc bnc" id="L1024" title="All 2 branches missed.">      if (onlyDtr == t2)</span>
<span class="nc" id="L1025">        return true;</span>
      else
<span class="nc" id="L1027">        return satisfies(onlyDtr, t2, root, matcher);</span>
    }

    @Override
    Iterator&lt;Tree&gt; searchNodeIterator(final Tree t,
                                      final TregexMatcher matcher) {
<span class="fc" id="L1033">      return new SearchNodeIterator() {</span>
        Stack&lt;Tree&gt; searchStack;

        @Override
        public void initialize() {
<span class="fc" id="L1038">          searchStack = new Stack&lt;&gt;();</span>
<span class="pc bpc" id="L1039" title="1 of 4 branches missed.">          if (!t.isLeaf() &amp;&amp; t.children().length == 1)</span>
<span class="fc" id="L1040">            searchStack.push(t.getChild(0));</span>
<span class="fc bfc" id="L1041" title="All 2 branches covered.">          if (!searchStack.isEmpty()) {</span>
<span class="fc" id="L1042">            advance();</span>
          }
<span class="fc" id="L1044">        }</span>

        @Override
        void advance() {
<span class="fc bfc" id="L1048" title="All 2 branches covered.">          if (searchStack.isEmpty()) {</span>
<span class="fc" id="L1049">            next = null;</span>
          } else {
<span class="fc" id="L1051">            next = searchStack.pop();</span>
<span class="fc bfc" id="L1052" title="All 4 branches covered.">            if (!next.isLeaf() &amp;&amp; next.children().length == 1)</span>
<span class="fc" id="L1053">              searchStack.push(next.getChild(0));</span>
          }
<span class="fc" id="L1055">        }</span>
      };
    }
  };

<span class="fc" id="L1060">  private static final Relation UNARY_PATH_DESCENDANT_OF = new Relation(&quot;&gt;&gt;:&quot;) {</span>

    private static final long serialVersionUID = 4364021807752979404L;

    @Override
    boolean satisfies(Tree t1, Tree t2, Tree root, final TregexMatcher matcher) {
<span class="nc bnc" id="L1066" title="All 4 branches missed.">      if (t2.isLeaf() || t2.children().length &gt; 1)</span>
<span class="nc" id="L1067">        return false;</span>
<span class="nc" id="L1068">      Tree onlyDtr = t2.children()[0];</span>
<span class="nc bnc" id="L1069" title="All 2 branches missed.">      if (onlyDtr == t1)</span>
<span class="nc" id="L1070">        return true;</span>
      else
<span class="nc" id="L1072">        return satisfies(t1, onlyDtr, root, matcher);</span>
    }

    @Override
    Iterator&lt;Tree&gt; searchNodeIterator(final Tree t,
                                      final TregexMatcher matcher) {
<span class="fc" id="L1078">      return new SearchNodeIterator() {</span>
        Stack&lt;Tree&gt; searchStack;

        @Override
        public void initialize() {
<span class="fc" id="L1083">          searchStack = new Stack&lt;&gt;();</span>
<span class="fc" id="L1084">          Tree parent = matcher.getParent(t);</span>
<span class="pc bpc" id="L1085" title="2 of 4 branches missed.">          if (parent != null &amp;&amp; !parent.isLeaf() &amp;&amp;</span>
<span class="fc bfc" id="L1086" title="All 2 branches covered.">              parent.children().length == 1)</span>
<span class="fc" id="L1087">            searchStack.push(parent);</span>
<span class="fc bfc" id="L1088" title="All 2 branches covered.">          if (!searchStack.isEmpty()) {</span>
<span class="fc" id="L1089">            advance();</span>
          }
<span class="fc" id="L1091">        }</span>

        @Override
        void advance() {
<span class="fc bfc" id="L1095" title="All 2 branches covered.">          if (searchStack.isEmpty()) {</span>
<span class="fc" id="L1096">            next = null;</span>
          } else {
<span class="fc" id="L1098">            next = searchStack.pop();</span>
<span class="fc" id="L1099">            Tree parent = matcher.getParent(next);</span>
<span class="pc bpc" id="L1100" title="1 of 4 branches missed.">            if (parent != null &amp;&amp; !parent.isLeaf() &amp;&amp;</span>
<span class="fc bfc" id="L1101" title="All 2 branches covered.">                parent.children().length == 1)</span>
<span class="fc" id="L1102">              searchStack.push(parent);</span>
          }
<span class="fc" id="L1104">        }</span>
      };
    }
  };

<span class="fc" id="L1109">  private static final Relation PARENT_EQUALS = new Relation(&quot;&lt;=&quot;) {</span>
    private static final long serialVersionUID = 98745298745198245L;

    @Override
    boolean satisfies(Tree t1, Tree t2, Tree root, final TregexMatcher matcher) {
<span class="nc bnc" id="L1114" title="All 2 branches missed.">      if (t1 == t2) {</span>
<span class="nc" id="L1115">        return true;</span>
      }
<span class="nc" id="L1117">      return PARENT_OF.satisfies(t1, t2, root, matcher);</span>
    }

    @Override
    Iterator&lt;Tree&gt; searchNodeIterator(final Tree t,
                                      final TregexMatcher matcher) {
<span class="fc" id="L1123">      return new SearchNodeIterator() {</span>
        int nextNum;
        boolean usedParent;

        @Override
        public void advance() {
<span class="fc bfc" id="L1129" title="All 2 branches covered.">          if (!usedParent) {</span>
<span class="fc" id="L1130">            next = t;</span>
<span class="fc" id="L1131">            usedParent = true;</span>
          } else {
<span class="fc bfc" id="L1133" title="All 2 branches covered.">            if (nextNum &lt; t.numChildren()) {</span>
<span class="fc" id="L1134">              next = t.getChild(nextNum);</span>
<span class="fc" id="L1135">              nextNum++;</span>
            } else {
<span class="fc" id="L1137">              next = null;</span>
            }
          }
<span class="fc" id="L1140">        }</span>
      };
    }
  };

<span class="fc" id="L1145">  private static final Relation[] SIMPLE_RELATIONS = {</span>
      DOMINATES, DOMINATED_BY, PARENT_OF, CHILD_OF, PRECEDES,
      IMMEDIATELY_PRECEDES, FOLLOWS, IMMEDIATELY_FOLLOWS,
          HAS_LEFTMOST_DESCENDANT, HAS_RIGHTMOST_DESCENDANT,
          LEFTMOST_DESCENDANT_OF, RIGHTMOST_DESCENDANT_OF, SISTER_OF,
      LEFT_SISTER_OF, RIGHT_SISTER_OF, IMMEDIATE_LEFT_SISTER_OF,
      IMMEDIATE_RIGHT_SISTER_OF, ONLY_CHILD_OF, HAS_ONLY_CHILD, EQUALS,
      PATTERN_SPLITTER,UNARY_PATH_ANCESTOR_OF, UNARY_PATH_DESCENDANT_OF,
      PARENT_EQUALS };

<span class="fc" id="L1155">  private static final Map&lt;String, Relation&gt; SIMPLE_RELATIONS_MAP = Generics.newHashMap();</span>

  static {
<span class="fc bfc" id="L1158" title="All 2 branches covered.">    for (Relation r : SIMPLE_RELATIONS) {</span>
<span class="fc" id="L1159">      SIMPLE_RELATIONS_MAP.put(r.symbol, r);</span>
    }
<span class="fc" id="L1161">    SIMPLE_RELATIONS_MAP.put(&quot;&lt;&lt;`&quot;, HAS_RIGHTMOST_DESCENDANT);</span>
<span class="fc" id="L1162">    SIMPLE_RELATIONS_MAP.put(&quot;&lt;&lt;,&quot;, HAS_LEFTMOST_DESCENDANT);</span>
<span class="fc" id="L1163">    SIMPLE_RELATIONS_MAP.put(&quot;&gt;&gt;`&quot;, RIGHTMOST_DESCENDANT_OF);</span>
<span class="fc" id="L1164">    SIMPLE_RELATIONS_MAP.put(&quot;&gt;&gt;,&quot;, LEFTMOST_DESCENDANT_OF);</span>
<span class="fc" id="L1165">    SIMPLE_RELATIONS_MAP.put(&quot;$..&quot;, LEFT_SISTER_OF);</span>
<span class="fc" id="L1166">    SIMPLE_RELATIONS_MAP.put(&quot;$,,&quot;, RIGHT_SISTER_OF);</span>
<span class="fc" id="L1167">    SIMPLE_RELATIONS_MAP.put(&quot;$.&quot;, IMMEDIATE_LEFT_SISTER_OF);</span>
<span class="fc" id="L1168">    SIMPLE_RELATIONS_MAP.put(&quot;$,&quot;, IMMEDIATE_RIGHT_SISTER_OF);</span>
<span class="fc" id="L1169">  }</span>

  @Override
  public boolean equals(Object o) {
<span class="pc bpc" id="L1173" title="1 of 2 branches missed.">    if (this == o) {</span>
<span class="nc" id="L1174">      return true;</span>
    }
<span class="pc bpc" id="L1176" title="1 of 2 branches missed.">    if (!(o instanceof Relation)) {</span>
<span class="nc" id="L1177">      return false;</span>
    }

<span class="fc" id="L1180">    final Relation relation = (Relation) o;</span>

<span class="fc" id="L1182">    return symbol.equals(relation.symbol);</span>
  }

  @Override
  public int hashCode() {
<span class="fc" id="L1187">    return symbol.hashCode();</span>
  }


  private static class Heads extends Relation {

    private static final long serialVersionUID = 4681433462932265831L;

    final HeadFinder hf;

    Heads(HeadFinder hf) {
<span class="fc" id="L1198">      super(&quot;&gt;&gt;#&quot;);</span>
<span class="fc" id="L1199">      this.hf = hf;</span>
<span class="fc" id="L1200">    }</span>

    @Override
    boolean satisfies(Tree t1, Tree t2, Tree root, final TregexMatcher matcher) {
<span class="nc bnc" id="L1204" title="All 2 branches missed.">      if (t2.isLeaf()) {</span>
<span class="nc" id="L1205">        return false;</span>
<span class="nc bnc" id="L1206" title="All 2 branches missed.">      } else if (t2.isPreTerminal()) {</span>
<span class="nc bnc" id="L1207" title="All 2 branches missed.">        return (t2.firstChild() == t1);</span>
      } else {
<span class="nc" id="L1209">        HeadFinder headFinder = matcher.getHeadFinder();</span>
<span class="nc bnc" id="L1210" title="All 2 branches missed.">        if (headFinder == null) headFinder = this.hf;</span>
<span class="nc" id="L1211">        Tree head = headFinder.determineHead(t2);</span>
<span class="nc bnc" id="L1212" title="All 2 branches missed.">        if (head == t1) {</span>
<span class="nc" id="L1213">          return true;</span>
        } else {
<span class="nc" id="L1215">          return satisfies(t1, head, root, matcher);</span>
        }
      }
    }

    @Override
    Iterator&lt;Tree&gt; searchNodeIterator(final Tree t,
                                      final TregexMatcher matcher) {
<span class="fc" id="L1223">      return new SearchNodeIterator() {</span>
        @Override
        void initialize() {
<span class="fc" id="L1226">          next = t;</span>
<span class="fc" id="L1227">          advance();</span>
<span class="fc" id="L1228">        }</span>

        @Override
        public void advance() {
<span class="fc" id="L1232">          HeadFinder headFinder = matcher.getHeadFinder();</span>
<span class="fc bfc" id="L1233" title="All 2 branches covered.">          if (headFinder == null) headFinder = hf;</span>

<span class="fc" id="L1235">          Tree last = next;</span>
<span class="fc" id="L1236">          next = matcher.getParent(next);</span>
<span class="fc bfc" id="L1237" title="All 4 branches covered.">          if (next != null &amp;&amp; headFinder.determineHead(next) != last) {</span>
<span class="fc" id="L1238">            next = null;</span>
          }
<span class="fc" id="L1240">        }</span>
      };
    }

    @Override
    public boolean equals(Object o) {
<span class="fc bfc" id="L1246" title="All 2 branches covered.">      if (this == o) {</span>
<span class="fc" id="L1247">        return true;</span>
      }
<span class="pc bpc" id="L1249" title="1 of 2 branches missed.">      if (!(o instanceof Heads)) {</span>
<span class="nc" id="L1250">        return false;</span>
      }
<span class="pc bpc" id="L1252" title="1 of 2 branches missed.">      if (!super.equals(o)) {</span>
<span class="nc" id="L1253">        return false;</span>
      }

<span class="fc" id="L1256">      final Heads heads = (Heads) o;</span>

<span class="pc bpc" id="L1258" title="2 of 6 branches missed.">      if (hf != null ? !hf.equals(heads.hf) : heads.hf != null) {</span>
<span class="nc" id="L1259">        return false;</span>
      }

<span class="fc" id="L1262">      return true;</span>
    }

    @Override
    public int hashCode() {
<span class="fc" id="L1267">      int result = super.hashCode();</span>
<span class="fc bfc" id="L1268" title="All 2 branches covered.">      result = 29 * result + (hf != null ? hf.hashCode() : 0);</span>
<span class="fc" id="L1269">      return result;</span>
    }
  }


  private static class HeadedBy extends Relation {

    private static final long serialVersionUID = 2825997185749055693L;

    private final Heads heads;

    HeadedBy(HeadFinder hf) {
<span class="fc" id="L1281">      super(&quot;&lt;&lt;#&quot;);</span>
<span class="fc" id="L1282">      this.heads = Interner.globalIntern(new Heads(hf));</span>
<span class="fc" id="L1283">    }</span>

    @Override
    boolean satisfies(Tree t1, Tree t2, Tree root, final TregexMatcher matcher) {
<span class="nc" id="L1287">      return heads.satisfies(t2, t1, root, matcher);</span>
    }

    @Override
    Iterator&lt;Tree&gt; searchNodeIterator(final Tree t,
                                      final TregexMatcher matcher) {
<span class="fc" id="L1293">      return new SearchNodeIterator() {</span>
        @Override
        void initialize() {
<span class="fc" id="L1296">          next = t;</span>
<span class="fc" id="L1297">          advance();</span>
<span class="fc" id="L1298">        }</span>

        @Override
        public void advance() {
<span class="fc bfc" id="L1302" title="All 2 branches covered.">          if (next.isLeaf()) {</span>
<span class="fc" id="L1303">            next = null;</span>
          } else {
<span class="fc bfc" id="L1305" title="All 2 branches covered.">            if (matcher.getHeadFinder() != null) {</span>
<span class="fc" id="L1306">              next = matcher.getHeadFinder().determineHead(next);</span>
            } else {
<span class="fc" id="L1308">              next = heads.hf.determineHead(next);</span>
            }
          }
<span class="fc" id="L1311">        }</span>
      };
    }

    @Override
    public boolean equals(Object o) {
<span class="pc bpc" id="L1317" title="1 of 2 branches missed.">      if (this == o) {</span>
<span class="nc" id="L1318">        return true;</span>
      }
<span class="pc bpc" id="L1320" title="1 of 2 branches missed.">      if (!(o instanceof HeadedBy)) {</span>
<span class="nc" id="L1321">        return false;</span>
      }
<span class="pc bpc" id="L1323" title="1 of 2 branches missed.">      if (!super.equals(o)) {</span>
<span class="nc" id="L1324">        return false;</span>
      }

<span class="fc" id="L1327">      final HeadedBy headedBy = (HeadedBy) o;</span>

<span class="pc bpc" id="L1329" title="4 of 6 branches missed.">      if (heads != null ? !heads.equals(headedBy.heads)</span>
          : headedBy.heads != null) {
<span class="nc" id="L1331">        return false;</span>
      }

<span class="fc" id="L1334">      return true;</span>
    }

    @Override
    public int hashCode() {
<span class="fc" id="L1339">      int result = super.hashCode();</span>
<span class="pc bpc" id="L1340" title="1 of 2 branches missed.">      result = 29 * result + (heads != null ? heads.hashCode() : 0);</span>
<span class="fc" id="L1341">      return result;</span>
    }
  }


  private static class ImmediatelyHeads extends Relation {


    private static final long serialVersionUID = 2085410152913894987L;

    private final HeadFinder hf;

    ImmediatelyHeads(HeadFinder hf) {
<span class="fc" id="L1354">      super(&quot;&gt;#&quot;);</span>
<span class="fc" id="L1355">      this.hf = hf;</span>
<span class="fc" id="L1356">    }</span>

    @Override
    boolean satisfies(Tree t1, Tree t2, Tree root, final TregexMatcher matcher) {
<span class="nc bnc" id="L1360" title="All 2 branches missed.">      if (matcher.getHeadFinder() != null) {</span>
<span class="nc bnc" id="L1361" title="All 2 branches missed.">        return matcher.getHeadFinder().determineHead(t2) == t1;</span>
      } else {
<span class="nc bnc" id="L1363" title="All 2 branches missed.">        return hf.determineHead(t2) == t1;</span>
      }
    }

    @Override
    Iterator&lt;Tree&gt; searchNodeIterator(final Tree t,
                                      final TregexMatcher matcher) {
<span class="fc" id="L1370">      return new SearchNodeIterator() {</span>
        @Override
        void initialize() {
<span class="pc bpc" id="L1373" title="1 of 2 branches missed.">          if (t != matcher.getRoot()) {</span>
<span class="fc" id="L1374">            next = matcher.getParent(t);</span>
<span class="fc bfc" id="L1375" title="All 2 branches covered.">            HeadFinder headFinder = matcher.getHeadFinder() == null ? hf : matcher.getHeadFinder();</span>
<span class="fc bfc" id="L1376" title="All 2 branches covered.">            if (headFinder.determineHead(next) != t) {</span>
<span class="fc" id="L1377">              next = null;</span>
            }
          }
<span class="fc" id="L1380">        }</span>
      };
    }

    @Override
    public boolean equals(Object o) {
<span class="fc bfc" id="L1386" title="All 2 branches covered.">      if (this == o) {</span>
<span class="fc" id="L1387">        return true;</span>
      }
<span class="pc bpc" id="L1389" title="1 of 2 branches missed.">      if (!(o instanceof ImmediatelyHeads)) {</span>
<span class="nc" id="L1390">        return false;</span>
      }
<span class="pc bpc" id="L1392" title="1 of 2 branches missed.">      if (!super.equals(o)) {</span>
<span class="nc" id="L1393">        return false;</span>
      }

<span class="fc" id="L1396">      final ImmediatelyHeads immediatelyHeads = (ImmediatelyHeads) o;</span>

<span class="pc bpc" id="L1398" title="2 of 6 branches missed.">      if (hf != null ? !hf.equals(immediatelyHeads.hf) : immediatelyHeads.hf != null) {</span>
<span class="nc" id="L1399">        return false;</span>
      }

<span class="fc" id="L1402">      return true;</span>
    }

    @Override
    public int hashCode() {
<span class="fc" id="L1407">      int result = super.hashCode();</span>
<span class="fc bfc" id="L1408" title="All 2 branches covered.">      result = 29 * result + (hf != null ? hf.hashCode() : 0);</span>
<span class="fc" id="L1409">      return result;</span>
    }
  }


  private static class ImmediatelyHeadedBy extends Relation {

    private static final long serialVersionUID = 5910075663419780905L;

    private final ImmediatelyHeads immediatelyHeads;

    ImmediatelyHeadedBy(HeadFinder hf) {
<span class="fc" id="L1421">      super(&quot;&lt;#&quot;);</span>
<span class="fc" id="L1422">      this.immediatelyHeads = Interner</span>
<span class="fc" id="L1423">          .globalIntern(new ImmediatelyHeads(hf));</span>
<span class="fc" id="L1424">    }</span>

    @Override
    boolean satisfies(Tree t1, Tree t2, Tree root, final TregexMatcher matcher) {
<span class="nc" id="L1428">      return immediatelyHeads.satisfies(t2, t1, root, matcher);</span>
    }

    @Override
    Iterator&lt;Tree&gt; searchNodeIterator(final Tree t,
                                      final TregexMatcher matcher) {
<span class="fc" id="L1434">      return new SearchNodeIterator() {</span>
        @Override
        void initialize() {
<span class="pc bpc" id="L1437" title="1 of 2 branches missed.">          if (!t.isLeaf()) {</span>
<span class="fc bfc" id="L1438" title="All 2 branches covered.">            if (matcher.getHeadFinder() != null) {</span>
<span class="fc" id="L1439">              next = matcher.getHeadFinder().determineHead(t);</span>
            } else {
<span class="fc" id="L1441">              next = immediatelyHeads.hf.determineHead(t);</span>
            }
          }
<span class="fc" id="L1444">        }</span>
      };
    }

    @Override
    public boolean equals(Object o) {
<span class="pc bpc" id="L1450" title="1 of 2 branches missed.">      if (this == o) {</span>
<span class="nc" id="L1451">        return true;</span>
      }
<span class="pc bpc" id="L1453" title="1 of 2 branches missed.">      if (!(o instanceof ImmediatelyHeadedBy)) {</span>
<span class="nc" id="L1454">        return false;</span>
      }
<span class="pc bpc" id="L1456" title="1 of 2 branches missed.">      if (!super.equals(o)) {</span>
<span class="nc" id="L1457">        return false;</span>
      }

<span class="fc" id="L1460">      final ImmediatelyHeadedBy immediatelyHeadedBy = (ImmediatelyHeadedBy) o;</span>

<span class="pc bpc" id="L1462" title="1 of 2 branches missed.">      if (immediatelyHeads != null ? !immediatelyHeads</span>
<span class="pc bpc" id="L1463" title="3 of 4 branches missed.">          .equals(immediatelyHeadedBy.immediatelyHeads)</span>
          : immediatelyHeadedBy.immediatelyHeads != null) {
<span class="nc" id="L1465">        return false;</span>
      }

<span class="fc" id="L1468">      return true;</span>
    }

    @Override
    public int hashCode() {
<span class="fc" id="L1473">      int result = super.hashCode();</span>
<span class="pc bpc" id="L1474" title="1 of 2 branches missed.">      result = 29 * result</span>
<span class="pc" id="L1475">          + (immediatelyHeads != null ? immediatelyHeads.hashCode() : 0);</span>
<span class="fc" id="L1476">      return result;</span>
    }
  }


  private static class IthChildOf extends Relation {

    private static final long serialVersionUID = -1463126827537879633L;

    private final int childNum;

    IthChildOf(int i) {
<span class="fc" id="L1488">      super('&gt;' + String.valueOf(i));</span>
<span class="pc bpc" id="L1489" title="1 of 2 branches missed.">      if (i == 0) {</span>
<span class="nc" id="L1490">        throw new IllegalArgumentException(</span>
            &quot;Error -- no such thing as zeroth child!&quot;);
      } else {
<span class="fc" id="L1493">        childNum = i;</span>
      }
<span class="fc" id="L1495">    }</span>

    @Override
    boolean satisfies(Tree t1, Tree t2, Tree root, final TregexMatcher matcher) {
<span class="nc" id="L1499">      Tree[] kids = t2.children();</span>
<span class="nc bnc" id="L1500" title="All 2 branches missed.">      if (kids.length &lt; Math.abs(childNum)) {</span>
<span class="nc" id="L1501">        return false;</span>
      }
<span class="nc bnc" id="L1503" title="All 4 branches missed.">      if (childNum &gt; 0 &amp;&amp; kids[childNum - 1] == t1) {</span>
<span class="nc" id="L1504">        return true;</span>
      }
<span class="nc bnc" id="L1506" title="All 4 branches missed.">      if (childNum &lt; 0 &amp;&amp; kids[kids.length + childNum] == t1) {</span>
<span class="nc" id="L1507">        return true;</span>
      }
<span class="nc" id="L1509">      return false;</span>
    }

    @Override
    Iterator&lt;Tree&gt; searchNodeIterator(final Tree t,
                                      final TregexMatcher matcher) {
<span class="fc" id="L1515">      return new SearchNodeIterator() {</span>
        @Override
        void initialize() {
<span class="fc bfc" id="L1518" title="All 2 branches covered.">          if (t != matcher.getRoot()) {</span>
<span class="fc" id="L1519">            next = matcher.getParent(t);</span>
<span class="fc bfc" id="L1520" title="All 2 branches covered.">            if (childNum &gt; 0</span>
<span class="fc bfc" id="L1521" title="All 2 branches covered.">                &amp;&amp; (next.numChildren() &lt; childNum || next</span>
<span class="fc bfc" id="L1522" title="All 2 branches covered.">                    .getChild(childNum - 1) != t)</span>
<span class="fc bfc" id="L1523" title="All 2 branches covered.">                || childNum &lt; 0</span>
<span class="fc bfc" id="L1524" title="All 4 branches covered.">                &amp;&amp; (next.numChildren() &lt; -childNum || next.getChild(next</span>
<span class="fc" id="L1525">                    .numChildren()</span>
<span class="fc" id="L1526">                    + childNum) != t)) {</span>
<span class="fc" id="L1527">              next = null;</span>
            }
          }
<span class="fc" id="L1530">        }</span>
      };
    }

    @Override
    public boolean equals(Object o) {
<span class="fc bfc" id="L1536" title="All 2 branches covered.">      if (this == o) {</span>
<span class="fc" id="L1537">        return true;</span>
      }
<span class="pc bpc" id="L1539" title="1 of 2 branches missed.">      if (!(o instanceof IthChildOf)) {</span>
<span class="nc" id="L1540">        return false;</span>
      }

<span class="fc" id="L1543">      final IthChildOf ithChildOf = (IthChildOf) o;</span>

<span class="pc bpc" id="L1545" title="1 of 2 branches missed.">      if (childNum != ithChildOf.childNum) {</span>
<span class="nc" id="L1546">        return false;</span>
      }

<span class="fc" id="L1549">      return true;</span>
    }

    @Override
    public int hashCode() {
<span class="fc" id="L1554">      return childNum;</span>
    }

  }


  private static class HasIthChild extends Relation {

    private static final long serialVersionUID = 3546853729291582806L;

    private final IthChildOf ithChildOf;

    HasIthChild(int i) {
<span class="fc" id="L1567">      super('&lt;' + String.valueOf(i));</span>
<span class="fc" id="L1568">      ithChildOf = Interner.globalIntern(new IthChildOf(i));</span>
<span class="fc" id="L1569">    }</span>

    @Override
    boolean satisfies(Tree t1, Tree t2, Tree root, final TregexMatcher matcher) {
<span class="nc" id="L1573">      return ithChildOf.satisfies(t2, t1, root, matcher);</span>
    }

    @Override
    Iterator&lt;Tree&gt; searchNodeIterator(final Tree t,
                                      final TregexMatcher matcher) {
<span class="fc" id="L1579">      return new SearchNodeIterator() {</span>
        @Override
        void initialize() {
<span class="fc" id="L1582">          int childNum = ithChildOf.childNum;</span>
<span class="fc bfc" id="L1583" title="All 2 branches covered.">          if (t.numChildren() &gt;= Math.abs(childNum)) {</span>
<span class="fc bfc" id="L1584" title="All 2 branches covered.">            if (childNum &gt; 0) {</span>
<span class="fc" id="L1585">              next = t.getChild(childNum - 1);</span>
            } else {
<span class="fc" id="L1587">              next = t.getChild(t.numChildren() + childNum);</span>
            }
          }
<span class="fc" id="L1590">        }</span>
      };
    }

    @Override
    public boolean equals(Object o) {
<span class="pc bpc" id="L1596" title="1 of 2 branches missed.">      if (this == o) {</span>
<span class="nc" id="L1597">        return true;</span>
      }
<span class="pc bpc" id="L1599" title="1 of 2 branches missed.">      if (!(o instanceof HasIthChild)) {</span>
<span class="nc" id="L1600">        return false;</span>
      }
<span class="pc bpc" id="L1602" title="1 of 2 branches missed.">      if (!super.equals(o)) {</span>
<span class="nc" id="L1603">        return false;</span>
      }

<span class="fc" id="L1606">      final HasIthChild hasIthChild = (HasIthChild) o;</span>

<span class="pc bpc" id="L1608" title="4 of 6 branches missed.">      if (ithChildOf != null ? !ithChildOf.equals(hasIthChild.ithChildOf)</span>
          : hasIthChild.ithChildOf != null) {
<span class="nc" id="L1610">        return false;</span>
      }

<span class="fc" id="L1613">      return true;</span>
    }

    @Override
    public int hashCode() {
<span class="fc" id="L1618">      int result = super.hashCode();</span>
<span class="pc bpc" id="L1619" title="1 of 2 branches missed.">      result = 29 * result + (ithChildOf != null ? ithChildOf.hashCode() : 0);</span>
<span class="fc" id="L1620">      return result;</span>
    }
  }




  private static class UnbrokenCategoryDominates extends Relation {

    private static final long serialVersionUID = -4174923168221859262L;

    private final Pattern pattern;
    private final boolean negatedPattern;
    private final boolean basicCat;
    private Function&lt;String, String&gt; basicCatFunction;


    /**
     *
     * @param arg This may have a ! and then maybe a @ and then either an
     *            identifier or regex
     */
    UnbrokenCategoryDominates(String arg,
                              Function&lt;String, String&gt; basicCatFunction) {
<span class="fc" id="L1644">      super(&quot;&lt;+(&quot; + arg + ')');</span>
<span class="fc bfc" id="L1645" title="All 2 branches covered.">      if (arg.startsWith(&quot;!&quot;)) {</span>
<span class="fc" id="L1646">        negatedPattern = true;</span>
<span class="fc" id="L1647">        arg = arg.substring(1);</span>
      } else {
<span class="fc" id="L1649">        negatedPattern = false;</span>
      }
<span class="fc bfc" id="L1651" title="All 2 branches covered.">      if (arg.startsWith(&quot;@&quot;)) {</span>
<span class="fc" id="L1652">        basicCat = true;</span>
<span class="fc" id="L1653">        this.basicCatFunction = basicCatFunction;</span>
<span class="fc" id="L1654">        arg = arg.substring(1);</span>
      } else {
<span class="fc" id="L1656">        basicCat = false;</span>
      }
<span class="fc bfc" id="L1658" title="All 2 branches covered.">      if (arg.matches(&quot;/.*/&quot;)) {</span>
<span class="fc" id="L1659">        pattern = Pattern.compile(arg.substring(1, arg.length() - 1));</span>
<span class="pc bpc" id="L1660" title="1 of 2 branches missed.">      } else if (arg.matches(&quot;__&quot;)) {</span>
<span class="nc" id="L1661">        pattern = Pattern.compile(&quot;^.*$&quot;);</span>
      } else {
<span class="fc" id="L1663">        pattern = Pattern.compile(&quot;^(?:&quot; + arg + &quot;)$&quot;);</span>
      }
<span class="fc" id="L1665">    }</span>

    /** {@inheritDoc} */
    @Override
    boolean satisfies(Tree t1, Tree t2, Tree root, final TregexMatcher matcher) {
<span class="nc bnc" id="L1670" title="All 2 branches missed.">      for (Tree kid : t1.children()) {</span>
<span class="nc bnc" id="L1671" title="All 2 branches missed.">        if (kid == t2) {</span>
<span class="nc" id="L1672">          return true;</span>
        } else {
<span class="nc bnc" id="L1674" title="All 4 branches missed.">          if (pathMatchesNode(kid) &amp;&amp; satisfies(kid, t2, root, matcher)) {</span>
<span class="nc" id="L1675">            return true;</span>
          }
        }
      }
<span class="nc" id="L1679">      return false;</span>
    }

    private boolean pathMatchesNode(Tree node) {
<span class="fc" id="L1683">      String lab = node.value();</span>
      // added this code to not crash if null node, even though there probably should be null nodes in the tree
<span class="pc bpc" id="L1685" title="1 of 2 branches missed.">      if (lab == null) {</span>
        // Say that a null label matches no positive pattern, but any negated patern
<span class="nc" id="L1687">        return negatedPattern;</span>
      } else {
<span class="pc bpc" id="L1689" title="1 of 2 branches missed.">        if (basicCat) {</span>
<span class="nc" id="L1690">          lab = basicCatFunction.apply(lab);</span>
        }
<span class="fc" id="L1692">        Matcher m = pattern.matcher(lab);</span>
<span class="fc bfc" id="L1693" title="All 2 branches covered.">        return m.find() != negatedPattern;</span>
      }
    }

    /** {@inheritDoc} */
    @Override
    Iterator&lt;Tree&gt; searchNodeIterator(final Tree t,
                                      final TregexMatcher matcher) {
<span class="fc" id="L1701">      return new SearchNodeIterator() {</span>
        Stack&lt;Tree&gt; searchStack;

        @Override
        public void initialize() {
<span class="fc" id="L1706">          searchStack = new Stack&lt;&gt;();</span>
<span class="fc bfc" id="L1707" title="All 2 branches covered.">          for (int i = t.numChildren() - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L1708">            searchStack.push(t.getChild(i));</span>
          }
<span class="pc bpc" id="L1710" title="1 of 2 branches missed.">          if (!searchStack.isEmpty()) {</span>
<span class="fc" id="L1711">            advance();</span>
          }
<span class="fc" id="L1713">        }</span>

        @Override
        void advance() {
<span class="fc bfc" id="L1717" title="All 2 branches covered.">          if (searchStack.isEmpty()) {</span>
<span class="fc" id="L1718">            next = null;</span>
          } else {
<span class="fc" id="L1720">            next = searchStack.pop();</span>
<span class="fc bfc" id="L1721" title="All 2 branches covered.">            if (pathMatchesNode(next)) {</span>
<span class="fc bfc" id="L1722" title="All 2 branches covered.">              for (int i = next.numChildren() - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L1723">                searchStack.push(next.getChild(i));</span>
              }
            }
          }
<span class="fc" id="L1727">        }</span>
      };
    }

    @Override
    public boolean equals(Object o) {
<span class="nc bnc" id="L1733" title="All 2 branches missed.">      if (this == o) {</span>
<span class="nc" id="L1734">        return true;</span>
      }
<span class="nc bnc" id="L1736" title="All 2 branches missed.">      if (!(o instanceof UnbrokenCategoryDominates)) {</span>
<span class="nc" id="L1737">        return false;</span>
      }

<span class="nc" id="L1740">      final UnbrokenCategoryDominates unbrokenCategoryDominates = (UnbrokenCategoryDominates) o;</span>

<span class="nc bnc" id="L1742" title="All 2 branches missed.">      if (negatedPattern != unbrokenCategoryDominates.negatedPattern) {</span>
<span class="nc" id="L1743">        return false;</span>
      }
<span class="nc bnc" id="L1745" title="All 2 branches missed.">      if (!pattern.equals(unbrokenCategoryDominates.pattern)) {</span>
<span class="nc" id="L1746">        return false;</span>
      }

<span class="nc" id="L1749">      return true;</span>
    }

    @Override
    public int hashCode() {
      int result;
<span class="fc" id="L1755">      result = pattern.hashCode();</span>
<span class="fc bfc" id="L1756" title="All 2 branches covered.">      result = 29 * result + (negatedPattern ? 1 : 0);</span>
<span class="fc" id="L1757">      return result;</span>
    }

  } // end class UnbrokenCategoryDominates


  private static class UnbrokenCategoryIsDominatedBy extends Relation {

    private static final long serialVersionUID = 2867922828235355129L;

    private final UnbrokenCategoryDominates unbrokenCategoryDominates;

    UnbrokenCategoryIsDominatedBy(String arg,
                                  Function&lt;String, String&gt; basicCatFunction) {
<span class="fc" id="L1771">      super(&quot;&gt;+(&quot; + arg + ')');</span>
<span class="fc" id="L1772">      unbrokenCategoryDominates = Interner</span>
<span class="fc" id="L1773">        .globalIntern((new UnbrokenCategoryDominates(arg, basicCatFunction)));</span>
<span class="fc" id="L1774">    }</span>

    /** {@inheritDoc} */
    @Override
    boolean satisfies(Tree t1, Tree t2, Tree root, final TregexMatcher matcher) {
<span class="nc" id="L1779">      return unbrokenCategoryDominates.satisfies(t2, t1, root, matcher);</span>
    }

    /** {@inheritDoc} */
    @Override
    Iterator&lt;Tree&gt; searchNodeIterator(final Tree t,
                                      final TregexMatcher matcher) {
<span class="fc" id="L1786">      return new SearchNodeIterator() {</span>
        @Override
        void initialize() {
<span class="fc" id="L1789">          next = matcher.getParent(t);</span>
<span class="fc" id="L1790">        }</span>

        @Override
        public void advance() {
<span class="fc bfc" id="L1794" title="All 2 branches covered.">          if (unbrokenCategoryDominates.pathMatchesNode(next)) {</span>
<span class="fc" id="L1795">            next = matcher.getParent(next);</span>
          } else {
<span class="fc" id="L1797">            next = null;</span>
          }
<span class="fc" id="L1799">        }</span>
      };
    }

    @Override
    public boolean equals(Object o) {
<span class="nc bnc" id="L1805" title="All 2 branches missed.">      if (this == o) {</span>
<span class="nc" id="L1806">        return true;</span>
      }
<span class="nc bnc" id="L1808" title="All 2 branches missed.">      if (!(o instanceof UnbrokenCategoryIsDominatedBy)) {</span>
<span class="nc" id="L1809">        return false;</span>
      }
<span class="nc bnc" id="L1811" title="All 2 branches missed.">      if (!super.equals(o)) {</span>
<span class="nc" id="L1812">        return false;</span>
      }

<span class="nc" id="L1815">      final UnbrokenCategoryIsDominatedBy unbrokenCategoryIsDominatedBy = (UnbrokenCategoryIsDominatedBy) o;</span>

<span class="nc" id="L1817">      return unbrokenCategoryDominates.equals(unbrokenCategoryIsDominatedBy.unbrokenCategoryDominates);</span>
    }

    @Override
    public int hashCode() {
<span class="fc" id="L1822">      int result = super.hashCode();</span>
<span class="fc" id="L1823">      result = 29 * result + unbrokenCategoryDominates.hashCode();</span>
<span class="fc" id="L1824">      return result;</span>
    }
  }


  /**
   * Note that this only works properly for context-free trees.
   * Also, the use of initialize and advance is not very efficient just yet.  Finally, each node in the tree
   * is added only once, even if there is more than one unbroken-category precedence path to it.
   *
   */
  private static class UnbrokenCategoryPrecedes extends Relation {

    private static final long serialVersionUID = 6866888667804306111L;

    private final Pattern pattern;
    private final boolean negatedPattern;
    private final boolean basicCat;
    private Function&lt;String, String&gt; basicCatFunction;

    /**
     * @param arg The pattern to match, perhaps preceded by ! and/or @
     */
    UnbrokenCategoryPrecedes(String arg,
                             Function&lt;String, String&gt; basicCatFunction) {
<span class="fc" id="L1849">      super(&quot;.+(&quot; + arg + ')');</span>
<span class="pc bpc" id="L1850" title="1 of 2 branches missed.">      if (arg.startsWith(&quot;!&quot;)) {</span>
<span class="nc" id="L1851">        negatedPattern = true;</span>
<span class="nc" id="L1852">        arg = arg.substring(1);</span>
      } else {
<span class="fc" id="L1854">        negatedPattern = false;</span>
      }
<span class="fc bfc" id="L1856" title="All 2 branches covered.">      if (arg.startsWith(&quot;@&quot;)) {</span>
<span class="fc" id="L1857">        basicCat = true;</span>
<span class="fc" id="L1858">        this.basicCatFunction = basicCatFunction; // todo -- this was missing a this. which must be testable in a unit test!!! Make one</span>
<span class="fc" id="L1859">        arg = arg.substring(1);</span>
      } else {
<span class="fc" id="L1861">        basicCat = false;</span>
      }
<span class="pc bpc" id="L1863" title="1 of 2 branches missed.">      if (arg.matches(&quot;/.*/&quot;)) {</span>
<span class="nc" id="L1864">        pattern = Pattern.compile(arg.substring(1, arg.length() - 1));</span>
<span class="pc bpc" id="L1865" title="1 of 2 branches missed.">      } else if (arg.matches(&quot;__&quot;)) {</span>
<span class="nc" id="L1866">        pattern = Pattern.compile(&quot;^.*$&quot;);</span>
      } else {
<span class="fc" id="L1868">        pattern = Pattern.compile(&quot;^(?:&quot; + arg + &quot;)$&quot;);</span>
      }
<span class="fc" id="L1870">    }</span>

    /** {@inheritDoc} */
    @Override
    boolean satisfies(Tree t1, Tree t2, Tree root, final TregexMatcher matcher) {
<span class="nc" id="L1875">      return true; // shouldn't have to do anything here.</span>
    }

    private boolean pathMatchesNode(Tree node) {
<span class="fc" id="L1879">      String lab = node.value();</span>
      // added this code to not crash if null node, even though there probably should be null nodes in the tree
<span class="pc bpc" id="L1881" title="1 of 2 branches missed.">      if (lab == null) {</span>
        // Say that a null label matches no positive pattern, but any negated pattern
<span class="nc" id="L1883">        return negatedPattern;</span>
      } else {
<span class="fc bfc" id="L1885" title="All 2 branches covered.">        if (basicCat) {</span>
<span class="fc" id="L1886">          lab = basicCatFunction.apply(lab);</span>
        }
<span class="fc" id="L1888">        Matcher m = pattern.matcher(lab);</span>
<span class="fc bfc" id="L1889" title="All 2 branches covered.">        return m.find() != negatedPattern;</span>
      }
    }

    /** {@inheritDoc} */
    @Override
    Iterator&lt;Tree&gt; searchNodeIterator(final Tree t,
                                      final TregexMatcher matcher) {
<span class="fc" id="L1897">      return new SearchNodeIterator() {</span>
        private IdentityHashSet&lt;Tree&gt; nodesToSearch;
        private Stack&lt;Tree&gt; searchStack;

        @Override
        public void initialize() {
<span class="fc" id="L1903">          nodesToSearch = new IdentityHashSet&lt;&gt;();</span>
<span class="fc" id="L1904">          searchStack = new Stack&lt;&gt;();</span>
<span class="fc" id="L1905">          initializeHelper(searchStack, t, matcher.getRoot());</span>
<span class="fc" id="L1906">          advance();</span>
<span class="fc" id="L1907">        }</span>

        private void initializeHelper(Stack&lt;Tree&gt; stack, Tree node, Tree root) {
<span class="pc bpc" id="L1910" title="1 of 2 branches missed.">          if (node==root) {</span>
<span class="nc" id="L1911">            return;</span>
          }
<span class="fc" id="L1913">          Tree parent = matcher.getParent(node);</span>
<span class="fc" id="L1914">          int i = parent.objectIndexOf(node);</span>
<span class="pc bpc" id="L1915" title="3 of 4 branches missed.">          while (i == parent.children().length-1 &amp;&amp; parent != root) {</span>
<span class="nc" id="L1916">            node = parent;</span>
<span class="nc" id="L1917">            parent = matcher.getParent(parent);</span>
<span class="nc" id="L1918">            i = parent.objectIndexOf(node);</span>
          }
          Tree followingNode;
<span class="pc bpc" id="L1921" title="1 of 2 branches missed.">          if (i+1 &lt; parent.children().length) {</span>
<span class="fc" id="L1922">            followingNode = parent.children()[i+1];</span>
          } else {
<span class="nc" id="L1924">            followingNode = null;</span>
          }
<span class="fc bfc" id="L1926" title="All 2 branches covered.">          while (followingNode != null) {</span>
            //log.info(&quot;adding to stack node &quot; + followingNode.toString());
<span class="pc bpc" id="L1928" title="1 of 2 branches missed.">            if (! nodesToSearch.contains(followingNode)) {</span>
<span class="fc" id="L1929">              stack.add(followingNode);</span>
<span class="fc" id="L1930">              nodesToSearch.add(followingNode);</span>
            }
<span class="fc bfc" id="L1932" title="All 2 branches covered.">            if (pathMatchesNode(followingNode)) {</span>
<span class="fc" id="L1933">              initializeHelper(stack, followingNode, root);</span>
            }
<span class="fc bfc" id="L1935" title="All 2 branches covered.">            if (! followingNode.isLeaf()) {</span>
<span class="fc" id="L1936">              followingNode = followingNode.children()[0];</span>
            } else {
<span class="fc" id="L1938">              followingNode = null;</span>
            }
          }
<span class="fc" id="L1941">        }</span>

        @Override
        void advance() {
<span class="fc bfc" id="L1945" title="All 2 branches covered.">          if (searchStack.isEmpty()) {</span>
<span class="fc" id="L1946">            next = null;</span>
          } else {
<span class="fc" id="L1948">            next = searchStack.pop();</span>
          }
<span class="fc" id="L1950">        }</span>
      };
    }
  }


  /**
   * Note that this only works properly for context-free trees.
   * Also, the use of initialize and advance is not very efficient just yet.  Finally, each node in the tree
   * is added only once, even if there is more than one unbroken-category precedence path to it.
   */
  private static class UnbrokenCategoryFollows extends Relation {

    private static final long serialVersionUID = -7890430001297866437L;

    private final Pattern pattern;
    private final boolean negatedPattern;
    private final boolean basicCat;
    private Function&lt;String, String&gt; basicCatFunction;

    /**
     * @param arg The pattern to match, perhaps preceded by ! and/or @
     */
    UnbrokenCategoryFollows(String arg,
                            Function&lt;String, String&gt; basicCatFunction) {
<span class="fc" id="L1975">      super(&quot;,+(&quot; + arg + ')');</span>
<span class="pc bpc" id="L1976" title="1 of 2 branches missed.">      if (arg.startsWith(&quot;!&quot;)) {</span>
<span class="nc" id="L1977">        negatedPattern = true;</span>
<span class="nc" id="L1978">        arg = arg.substring(1);</span>
      } else {
<span class="fc" id="L1980">        negatedPattern = false;</span>
      }
<span class="fc bfc" id="L1982" title="All 2 branches covered.">      if (arg.startsWith(&quot;@&quot;)) {</span>
<span class="fc" id="L1983">        basicCat = true;</span>
<span class="fc" id="L1984">        this.basicCatFunction = basicCatFunction;</span>
<span class="fc" id="L1985">        arg = arg.substring(1);</span>
      } else {
<span class="fc" id="L1987">        basicCat = false;</span>
      }
<span class="fc bfc" id="L1989" title="All 2 branches covered.">      if (arg.matches(&quot;/.*/&quot;)) {</span>
<span class="fc" id="L1990">        pattern = Pattern.compile(arg.substring(1, arg.length() - 1));</span>
<span class="pc bpc" id="L1991" title="1 of 2 branches missed.">      } else if (arg.matches(&quot;__&quot;)) {</span>
<span class="nc" id="L1992">        pattern = Pattern.compile(&quot;^.*$&quot;);</span>
      } else {
<span class="fc" id="L1994">        pattern = Pattern.compile(&quot;^(?:&quot; + arg + &quot;)$&quot;);</span>
      }
<span class="fc" id="L1996">    }</span>

    /** {@inheritDoc} */
    @Override
    boolean satisfies(Tree t1, Tree t2, Tree root, final TregexMatcher matcher) {
<span class="nc" id="L2001">      return true; // shouldn't have to do anything here.</span>
    }

    private boolean pathMatchesNode(Tree node) {
<span class="fc" id="L2005">      String lab = node.value();</span>
      // added this code to not crash if null node, even though there probably should be null nodes in the tree
<span class="pc bpc" id="L2007" title="1 of 2 branches missed.">      if (lab == null) {</span>
        // Say that a null label matches no positive pattern, but any negated pattern
<span class="nc" id="L2009">        return negatedPattern;</span>
      } else {
<span class="fc bfc" id="L2011" title="All 2 branches covered.">        if (basicCat) {</span>
<span class="fc" id="L2012">          lab = basicCatFunction.apply(lab);</span>
        }
<span class="fc" id="L2014">        Matcher m = pattern.matcher(lab);</span>
<span class="fc bfc" id="L2015" title="All 2 branches covered.">        return m.find() != negatedPattern;</span>
      }
    }

    /** {@inheritDoc} */
    @Override
    Iterator&lt;Tree&gt; searchNodeIterator(final Tree t,
                                      final TregexMatcher matcher) {
<span class="fc" id="L2023">      return new SearchNodeIterator() {</span>
        IdentityHashSet&lt;Tree&gt; nodesToSearch;
        Stack&lt;Tree&gt; searchStack;

        @Override
        public void initialize() {
<span class="fc" id="L2029">          nodesToSearch = new IdentityHashSet&lt;&gt;();</span>
<span class="fc" id="L2030">          searchStack = new Stack&lt;&gt;();</span>
<span class="fc" id="L2031">          initializeHelper(searchStack, t, matcher.getRoot());</span>
<span class="fc" id="L2032">          advance();</span>
<span class="fc" id="L2033">        }</span>

        private void initializeHelper(Stack&lt;Tree&gt; stack, Tree node, Tree root) {
<span class="pc bpc" id="L2036" title="1 of 2 branches missed.">          if (node==root) {</span>
<span class="nc" id="L2037">            return;</span>
          }
<span class="fc" id="L2039">          Tree parent = matcher.getParent(node);</span>
<span class="fc" id="L2040">          int i = parent.objectIndexOf(node);</span>
<span class="pc bpc" id="L2041" title="3 of 4 branches missed.">          while (i == 0 &amp;&amp; parent != root) {</span>
<span class="nc" id="L2042">            node = parent;</span>
<span class="nc" id="L2043">            parent = matcher.getParent(parent);</span>
<span class="nc" id="L2044">            i = parent.objectIndexOf(node);</span>
          }
          Tree precedingNode;
<span class="pc bpc" id="L2047" title="1 of 2 branches missed.">          if (i &gt; 0) {</span>
<span class="fc" id="L2048">            precedingNode = parent.children()[i-1];</span>
          } else {
<span class="nc" id="L2050">            precedingNode = null;</span>
          }
<span class="fc bfc" id="L2052" title="All 2 branches covered.">          while (precedingNode != null) {</span>
            //log.info(&quot;adding to stack node &quot; + precedingNode.toString());
<span class="pc bpc" id="L2054" title="1 of 2 branches missed.">            if ( ! nodesToSearch.contains(precedingNode)) {</span>
<span class="fc" id="L2055">              stack.add(precedingNode);</span>
<span class="fc" id="L2056">              nodesToSearch.add(precedingNode);</span>
            }
<span class="fc bfc" id="L2058" title="All 2 branches covered.">            if (pathMatchesNode(precedingNode)) {</span>
<span class="fc" id="L2059">              initializeHelper(stack, precedingNode, root);</span>
            }
<span class="fc bfc" id="L2061" title="All 2 branches covered.">            if (! precedingNode.isLeaf()) {</span>
<span class="fc" id="L2062">              precedingNode = precedingNode.children()[0];</span>
            } else {
<span class="fc" id="L2064">              precedingNode = null;</span>
            }
          }
<span class="fc" id="L2067">        }</span>

        @Override
        void advance() {
<span class="fc bfc" id="L2071" title="All 2 branches covered.">          if (searchStack.isEmpty()) {</span>
<span class="fc" id="L2072">            next = null;</span>
          } else {
<span class="fc" id="L2074">            next = searchStack.pop();</span>
          }
<span class="fc" id="L2076">        }</span>
      };
    }
  }

}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>