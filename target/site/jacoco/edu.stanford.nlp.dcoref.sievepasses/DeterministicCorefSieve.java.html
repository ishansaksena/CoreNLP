<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DeterministicCorefSieve.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.dcoref.sievepasses</a> &gt; <span class="el_source">DeterministicCorefSieve.java</span></div><h1>DeterministicCorefSieve.java</h1><pre class="source lang-java linenums">//
// StanfordCoreNLP -- a suite of NLP tools
// Copyright (c) 2009-2010 The Board of Trustees of
// The Leland Stanford Junior University. All Rights Reserved.
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
//
// For more information, bug reports, fixes, contact:
//    Christopher Manning
//    Dept of Computer Science, Gates 1A
//    Stanford CA 94305-9010
//    USA
//

package edu.stanford.nlp.dcoref.sievepasses;

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.logging.Level;

import edu.stanford.nlp.dcoref.Constants;
import edu.stanford.nlp.dcoref.CorefCluster;
import edu.stanford.nlp.dcoref.Dictionaries;
import edu.stanford.nlp.dcoref.Dictionaries.MentionType;
import edu.stanford.nlp.dcoref.Dictionaries.Number;
import edu.stanford.nlp.dcoref.Dictionaries.Person;
import edu.stanford.nlp.dcoref.Document;
import edu.stanford.nlp.dcoref.Document.DocType;
import edu.stanford.nlp.dcoref.Mention;
import edu.stanford.nlp.dcoref.Rules;
import edu.stanford.nlp.dcoref.Semantics;
import edu.stanford.nlp.dcoref.SieveCoreferenceSystem;
import edu.stanford.nlp.dcoref.SieveOptions;
import edu.stanford.nlp.ling.CoreAnnotations;
import edu.stanford.nlp.trees.Tree;

/**
 *  Base class for a Coref Sieve.
 *  Each sieve extends this class, and set flags for its own options in the constructor.
 *
 *  @author heeyoung
 *  @author mihais
 */
public abstract class DeterministicCorefSieve  {

  public final SieveOptions flags;
  protected Locale lang;

  /** Initialize flagSet */
<span class="nc" id="L68">  public DeterministicCorefSieve() {</span>
<span class="nc" id="L69">    flags = new SieveOptions();</span>
<span class="nc" id="L70">  }</span>

  public void init(Properties props) {
<span class="nc" id="L73">    lang = Locale.forLanguageTag(props.getProperty(Constants.LANGUAGE_PROP, &quot;en&quot;));</span>
<span class="nc" id="L74">  }</span>

<span class="nc" id="L76">  public String flagsToString() { return flags.toString(); }</span>

<span class="nc" id="L78">  public boolean useRoleSkip() { return flags.USE_ROLE_SKIP; }</span>

  /** Skip this mention? (search pruning) */
  public boolean skipThisMention(Document document, Mention m1, CorefCluster c, Dictionaries dict) {
<span class="nc" id="L82">    boolean skip = false;</span>

    // only do for the first mention in its cluster
<span class="nc bnc" id="L85" title="All 12 branches missed.">    if(!flags.USE_EXACTSTRINGMATCH &amp;&amp; !flags.USE_ROLEAPPOSITION &amp;&amp; !flags.USE_PREDICATENOMINATIVES</span>
        &amp;&amp; !flags.USE_ACRONYM &amp;&amp; !flags.USE_APPOSITION &amp;&amp; !flags.USE_RELATIVEPRONOUN
<span class="nc bnc" id="L87" title="All 2 branches missed.">        &amp;&amp; !c.getFirstMention().equals(m1)) {</span>
<span class="nc" id="L88">      return true;</span>
    }

    if(Constants.USE_DISCOURSE_SALIENCE)  {
<span class="nc" id="L92">      SieveCoreferenceSystem.logger.finest(&quot;DOING COREF FOR:\t&quot; + m1.spanToString());</span>
<span class="nc bnc" id="L93" title="All 4 branches missed.">      if(m1.appositions == null &amp;&amp; m1.predicateNominatives == null</span>
<span class="nc bnc" id="L94" title="All 6 branches missed.">          &amp;&amp; (m1.lowercaseNormalizedSpanString().startsWith(&quot;a &quot;) || m1.lowercaseNormalizedSpanString().startsWith(&quot;an &quot;))</span>
          &amp;&amp; !flags.USE_EXACTSTRINGMATCH)  {
<span class="nc" id="L96">        skip = true; // A noun phrase starting with an indefinite article - unlikely to have an antecedent (e.g. &quot;A commission&quot; was set up to .... )</span>
      }
<span class="nc bnc" id="L98" title="All 2 branches missed.">      if(dict.indefinitePronouns.contains(m1.lowercaseNormalizedSpanString()))  {</span>
<span class="nc" id="L99">        skip = true; // An indefinite pronoun - unlikely to have an antecedent (e.g. &quot;Some&quot; say that... )</span>
      }
<span class="nc bnc" id="L101" title="All 2 branches missed.">      for(String indef : dict.indefinitePronouns){</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">        if(m1.lowercaseNormalizedSpanString().startsWith(indef + &quot; &quot;)) {</span>
<span class="nc" id="L103">          skip = true; // A noun phrase starting with an indefinite adjective - unlikely to have an antecedent (e.g. &quot;Another opinion&quot; on the topic is...)</span>
<span class="nc" id="L104">          break;</span>
        }
<span class="nc" id="L106">      }</span>

<span class="nc bnc" id="L108" title="All 2 branches missed.">      if(skip) {</span>
<span class="nc" id="L109">        SieveCoreferenceSystem.logger.finest(&quot;MENTION SKIPPED:\t&quot; + m1.spanToString() + &quot;(&quot; + m1.sentNum + &quot;)&quot;+&quot;\toriginalRef: &quot;+m1.originalRef + &quot; in discourse &quot;+m1.headWord.get(CoreAnnotations.UtteranceAnnotation.class));</span>
      }
    }

<span class="nc" id="L113">    return skip;</span>
  }

  public boolean checkEntityMatch(
          Document document,
          CorefCluster mentionCluster,
          CorefCluster potentialAntecedent,
          Dictionaries dict,
          Set&lt;Mention&gt; roleSet) {
<span class="nc" id="L122">    return false;</span>
  }

  /**
   * Checks if two clusters are coreferent according to our sieve pass constraints.
   *
   * @param document
   * @throws Exception
   */
  public boolean coreferent(Document document, CorefCluster mentionCluster,
      CorefCluster potentialAntecedent,
      Mention mention2,
      Mention ant,
      Dictionaries dict,
      Set&lt;Mention&gt; roleSet,
      Semantics semantics) throws Exception {

<span class="nc" id="L139">    boolean ret = false;</span>
<span class="nc" id="L140">    Mention mention = mentionCluster.getRepresentativeMention();</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">    if (flags.USE_INCOMPATIBLES) {</span>
      // Check our list of incompatible mentions and don't cluster them together
      // Allows definite no's from previous sieves to propagate down
<span class="nc bnc" id="L144" title="All 2 branches missed.">      if (document.isIncompatible(mentionCluster, potentialAntecedent)) {</span>
<span class="nc" id="L145">        SieveCoreferenceSystem.logger.finest(&quot;INCOMPATIBLE clusters: not match: &quot; +ant.spanToString()+&quot;(&quot;+ant.mentionID +</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">                &quot;) :: &quot;+ mention.spanToString()+&quot;(&quot;+mention.mentionID + &quot;) -&gt; &quot;+(mention.goldCorefClusterID!=ant.goldCorefClusterID));</span>
<span class="nc" id="L147">        return false;</span>
      }
    }
<span class="nc bnc" id="L150" title="All 8 branches missed.">    if (flags.DO_PRONOUN &amp;&amp; Math.abs(mention2.sentNum-ant.sentNum) &gt; 3 &amp;&amp;</span>
        mention2.person!=Person.I &amp;&amp; mention2.person!=Person.YOU) {
<span class="nc" id="L152">      return false;</span>
    }
<span class="nc bnc" id="L154" title="All 4 branches missed.">    if (mention2.lowercaseNormalizedSpanString().equals(&quot;this&quot;) &amp;&amp; Math.abs(mention2.sentNum-ant.sentNum) &gt; 3) {</span>
<span class="nc" id="L155">      return false;</span>
    }
<span class="nc bnc" id="L157" title="All 4 branches missed.">    if (mention2.person==Person.YOU &amp;&amp; document.docType==DocType.ARTICLE &amp;&amp;</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">        mention2.headWord.get(CoreAnnotations.SpeakerAnnotation.class).equals(&quot;PER0&quot;)) {</span>
<span class="nc" id="L159">      return false;</span>
    }
<span class="nc bnc" id="L161" title="All 2 branches missed.">    if (document.conllDoc != null) {</span>
<span class="nc bnc" id="L162" title="All 4 branches missed.">      if (ant.generic &amp;&amp; ant.person==Person.YOU) return false;</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">      if (mention2.generic) return false;</span>
    }
<span class="nc bnc" id="L165" title="All 4 branches missed.">    if(mention2.insideIn(ant) || ant.insideIn(mention2)) return false;</span>

<span class="nc bnc" id="L167" title="All 2 branches missed.">    if(flags.USE_DISCOURSEMATCH) {</span>
<span class="nc" id="L168">      String mString = mention.lowercaseNormalizedSpanString();</span>
<span class="nc" id="L169">      String antString = ant.lowercaseNormalizedSpanString();</span>

      // mention and ant both belong to the same speaker cluster
<span class="nc bnc" id="L172" title="All 4 branches missed.">      if (mention.speakerInfo != null &amp;&amp; mention.speakerInfo == ant.speakerInfo) {</span>
<span class="nc" id="L173">        SieveCoreferenceSystem.logger.finest(&quot;discourse match: maps to same speaker: &quot; + mention.spanToString() + &quot;\tmatched\t&quot; + ant.spanToString());</span>
<span class="nc" id="L174">        return true;</span>
      }

      // (I - I) in the same speaker's quotation.
<span class="nc bnc" id="L178" title="All 6 branches missed.">      if (mention.number==Number.SINGULAR &amp;&amp; dict.firstPersonPronouns.contains(mString)</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">          &amp;&amp; ant.number==Number.SINGULAR &amp;&amp; dict.firstPersonPronouns.contains(antString)</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">          &amp;&amp; Rules.entitySameSpeaker(document, mention, ant)){</span>
<span class="nc" id="L181">        SieveCoreferenceSystem.logger.finest(&quot;discourse match: 1st person same speaker: &quot; + mention.spanToString() + &quot;\tmatched\t&quot; + ant.spanToString());</span>
<span class="nc" id="L182">        return true;</span>
      }
      // (speaker - I)
<span class="nc bnc" id="L185" title="All 4 branches missed.">      if ((mention.number==Number.SINGULAR &amp;&amp; dict.firstPersonPronouns.contains(mString))</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">              &amp;&amp; Rules.antecedentIsMentionSpeaker(document, mention, ant, dict)) {</span>
<span class="nc" id="L187">        SieveCoreferenceSystem.logger.finest(&quot;discourse match: 1st person mention speaker match antecedent: &quot; + mention.spanToString() + &quot;\tmatched\t&quot; + ant.spanToString());</span>
<span class="nc bnc" id="L188" title="All 4 branches missed.">        if (mention.speakerInfo == null &amp;&amp; ant.speakerInfo != null) { mention.speakerInfo = ant.speakerInfo; }</span>
<span class="nc" id="L189">        return true;</span>
      }
      // (I - speaker)
<span class="nc bnc" id="L192" title="All 4 branches missed.">      if ((ant.number==Number.SINGULAR &amp;&amp; dict.firstPersonPronouns.contains(antString))</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">              &amp;&amp; Rules.antecedentIsMentionSpeaker(document, ant, mention, dict)) {</span>
<span class="nc" id="L194">        SieveCoreferenceSystem.logger.finest(&quot;discourse match: 1st person antecedent speaker match mention: &quot; + mention.spanToString() + &quot;\tmatched\t&quot; + ant.spanToString());</span>
<span class="nc bnc" id="L195" title="All 4 branches missed.">        if (ant.speakerInfo == null &amp;&amp; mention.speakerInfo != null) { ant.speakerInfo = mention.speakerInfo; }</span>
<span class="nc" id="L196">        return true;</span>
      }
      // Can be iffy if more than two speakers... but still should be okay most of the time
<span class="nc bnc" id="L199" title="All 2 branches missed.">      if (dict.secondPersonPronouns.contains(mString)</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">          &amp;&amp; dict.secondPersonPronouns.contains(antString)</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">          &amp;&amp; Rules.entitySameSpeaker(document, mention, ant)) {</span>
<span class="nc" id="L202">        SieveCoreferenceSystem.logger.finest(&quot;discourse match: 2nd person same speaker: &quot; + mention.spanToString() + &quot;\tmatched\t&quot; + ant.spanToString());</span>
<span class="nc" id="L203">        return true;</span>
      }
      // previous I - you or previous you - I in two person conversation
<span class="nc bnc" id="L206" title="All 8 branches missed.">      if (((mention.person==Person.I &amp;&amp; ant.person==Person.YOU</span>
          || (mention.person==Person.YOU &amp;&amp; ant.person==Person.I))
<span class="nc bnc" id="L208" title="All 4 branches missed.">          &amp;&amp; (mention.headWord.get(CoreAnnotations.UtteranceAnnotation.class)-ant.headWord.get(CoreAnnotations.UtteranceAnnotation.class) == 1)</span>
          &amp;&amp; document.docType==DocType.CONVERSATION)) {
<span class="nc" id="L210">        SieveCoreferenceSystem.logger.finest(&quot;discourse match: between two person: &quot; + mention.spanToString() + &quot;\tmatched\t&quot; + ant.spanToString());</span>
<span class="nc" id="L211">        return true;</span>
      }
<span class="nc bnc" id="L213" title="All 4 branches missed.">      if (dict.reflexivePronouns.contains(mention.headString) &amp;&amp; Rules.entitySubjectObject(mention, ant)){</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">        SieveCoreferenceSystem.logger.finest(&quot;discourse match: reflexive pronoun: &quot; + ant.spanToString() + &quot;(&quot; + ant.mentionID + &quot;) :: &quot; + mention.spanToString() + &quot;(&quot; + mention.mentionID + &quot;) -&gt; &quot; + (mention.goldCorefClusterID == ant.goldCorefClusterID));</span>
<span class="nc" id="L215">        return true;</span>
      }
    }
<span class="nc bnc" id="L218" title="All 8 branches missed.">    if (Constants.USE_DISCOURSE_CONSTRAINTS &amp;&amp; !flags.USE_EXACTSTRINGMATCH &amp;&amp; !flags.USE_RELAXED_EXACTSTRINGMATCH</span>
        &amp;&amp; !flags.USE_APPOSITION &amp;&amp; !flags.USE_WORDS_INCLUSION) {
<span class="nc bnc" id="L220" title="All 2 branches missed.">      for(Mention m : mentionCluster.getCorefMentions()) {</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">        for(Mention a : potentialAntecedent.getCorefMentions()){</span>
          // angelx - not sure about the logic here, disable (code was also refactored from original)
          // vv gabor - re-enabled code (seems to improve performance) vv
<span class="nc bnc" id="L224" title="All 4 branches missed.">          if(m.person!=Person.I &amp;&amp; a.person!=Person.I &amp;&amp;</span>
<span class="nc bnc" id="L225" title="All 4 branches missed.">            (Rules.antecedentIsMentionSpeaker(document, m, a, dict) || Rules.antecedentIsMentionSpeaker(document, a, m, dict))) {</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">            SieveCoreferenceSystem.logger.finest(&quot;Incompatibles: not match(speaker): &quot; +ant.spanToString()+&quot;(&quot;+ant.mentionID + &quot;) :: &quot;+ mention.spanToString()+&quot;(&quot;+mention.mentionID + &quot;) -&gt; &quot;+(mention.goldCorefClusterID!=ant.goldCorefClusterID));</span>
<span class="nc" id="L227">            document.addIncompatible(m, a);</span>
<span class="nc" id="L228">            return false;</span>
          }
          // ^^ end block of code in question ^^
<span class="nc" id="L231">          int dist = Math.abs(m.headWord.get(CoreAnnotations.UtteranceAnnotation.class) - a.headWord.get(CoreAnnotations.UtteranceAnnotation.class));</span>
<span class="nc bnc" id="L232" title="All 6 branches missed.">          if(document.docType!=DocType.ARTICLE &amp;&amp; dist==1 &amp;&amp; !Rules.entitySameSpeaker(document, m, a)) {</span>
<span class="nc" id="L233">            String mSpeaker = document.speakers.get(m.headWord.get(CoreAnnotations.UtteranceAnnotation.class));</span>
<span class="nc" id="L234">            String aSpeaker = document.speakers.get(a.headWord.get(CoreAnnotations.UtteranceAnnotation.class));</span>
<span class="nc bnc" id="L235" title="All 4 branches missed.">            if(m.person==Person.I &amp;&amp; a.person==Person.I) {</span>
<span class="nc" id="L236">              SieveCoreferenceSystem.logger.finest(&quot;Incompatibles: neighbor I: &quot; + ant.spanToString() + &quot;(&quot; + ant.mentionID + &quot;,&quot; + aSpeaker + &quot;) :: &quot;</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">                      + mention.spanToString() + &quot;(&quot; + mention.mentionID + &quot;,&quot; + mSpeaker + &quot;) -&gt; &quot; + (mention.goldCorefClusterID != ant.goldCorefClusterID));</span>
<span class="nc" id="L238">              document.addIncompatible(m, a);</span>
<span class="nc" id="L239">              return false;</span>
            }
<span class="nc bnc" id="L241" title="All 4 branches missed.">            if(m.person==Person.YOU &amp;&amp; a.person==Person.YOU) {</span>
<span class="nc" id="L242">              SieveCoreferenceSystem.logger.finest(&quot;Incompatibles: neighbor YOU: &quot; + ant.spanToString() + &quot;(&quot; + ant.mentionID + &quot;,&quot; + aSpeaker + &quot;) :: &quot;</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">                      + mention.spanToString() + &quot;(&quot; + mention.mentionID + &quot;,&quot; + mSpeaker +  &quot;) -&gt; &quot; + (mention.goldCorefClusterID != ant.goldCorefClusterID));</span>
<span class="nc" id="L244">              document.addIncompatible(m, a);</span>
<span class="nc" id="L245">              return false;</span>
            }
            // This is weak since we can refer to both speakers
<span class="nc bnc" id="L248" title="All 4 branches missed.">            if(m.person==Person.WE &amp;&amp; a.person==Person.WE) {</span>
<span class="nc" id="L249">              SieveCoreferenceSystem.logger.finest(&quot;Incompatibles: neighbor WE: &quot; + ant.spanToString() + &quot;(&quot; + ant.mentionID + &quot;,&quot; + aSpeaker + &quot;) :: &quot;</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">                      + mention.spanToString() + &quot;(&quot; + mention.mentionID + &quot;,&quot; + mSpeaker +  &quot;) -&gt; &quot; + (mention.goldCorefClusterID != ant.goldCorefClusterID));</span>
<span class="nc" id="L251">              document.addIncompatible(m, a);</span>
<span class="nc" id="L252">              return false;</span>
            }
          }
<span class="nc" id="L255">        }</span>
<span class="nc" id="L256">      }</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">      if(document.docType==DocType.ARTICLE) {</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">        for(Mention m : mentionCluster.getCorefMentions()) {</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">          for(Mention a : potentialAntecedent.getCorefMentions()){</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">            if(Rules.entitySubjectObject(m, a)) {</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">              SieveCoreferenceSystem.logger.finest(&quot;Incompatibles: subject-object: &quot;+ant.spanToString()+&quot;(&quot;+ant.mentionID + &quot;) :: &quot;+ mention.spanToString()+&quot;(&quot;+mention.mentionID + &quot;) -&gt; &quot;+(mention.goldCorefClusterID!=ant.goldCorefClusterID));</span>
<span class="nc" id="L262">              document.addIncompatible(m, a);</span>
<span class="nc" id="L263">              return false;</span>
            }
<span class="nc" id="L265">          }</span>
<span class="nc" id="L266">        }</span>
      }
    }

    // Incompatibility constraints - do before match checks
<span class="nc bnc" id="L271" title="All 4 branches missed.">    if(flags.USE_iwithini &amp;&amp; Rules.entityIWithinI(mention, ant, dict)) {</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">      SieveCoreferenceSystem.logger.finest(&quot;Incompatibles: iwithini: &quot;+ant.spanToString()+&quot;(&quot;+ant.mentionID + &quot;) :: &quot;+ mention.spanToString()+&quot;(&quot;+mention.mentionID + &quot;) -&gt; &quot;+(mention.goldCorefClusterID!=ant.goldCorefClusterID));</span>
<span class="nc" id="L273">      document.addIncompatible(mention, ant);</span>
<span class="nc" id="L274">      return false;</span>
    }

    // Match checks
<span class="nc bnc" id="L278" title="All 4 branches missed.">    if(flags.USE_EXACTSTRINGMATCH &amp;&amp; Rules.entityExactStringMatch(mentionCluster, potentialAntecedent, dict, roleSet)){</span>
<span class="nc" id="L279">      return true;</span>
    }
<span class="nc bnc" id="L281" title="All 4 branches missed.">    if (flags.USE_NAME_MATCH &amp;&amp; checkEntityMatch(document, mentionCluster, potentialAntecedent, dict, roleSet)) {</span>
<span class="nc" id="L282">      ret = true;</span>
    }

<span class="nc bnc" id="L285" title="All 4 branches missed.">    if(flags.USE_RELAXED_EXACTSTRINGMATCH &amp;&amp; Rules.entityRelaxedExactStringMatch(mentionCluster, potentialAntecedent, mention, ant, dict, roleSet)){</span>
<span class="nc" id="L286">      return true;</span>
    }
<span class="nc bnc" id="L288" title="All 4 branches missed.">    if(flags.USE_APPOSITION &amp;&amp; Rules.entityIsApposition(mentionCluster, potentialAntecedent, mention, ant)) {</span>
<span class="nc" id="L289">      SieveCoreferenceSystem.logger.finest(&quot;Apposition: &quot; + mention.spanToString() + &quot;\tvs\t&quot; + ant.spanToString());</span>
<span class="nc" id="L290">      return true;</span>
    }
<span class="nc bnc" id="L292" title="All 4 branches missed.">    if(flags.USE_PREDICATENOMINATIVES &amp;&amp; Rules.entityIsPredicateNominatives(mentionCluster, potentialAntecedent, mention, ant)) {</span>
<span class="nc" id="L293">      SieveCoreferenceSystem.logger.finest(&quot;Predicate nominatives: &quot; + mention.spanToString() + &quot;\tvs\t&quot; + ant.spanToString());</span>
<span class="nc" id="L294">      return true;</span>
    }

<span class="nc bnc" id="L297" title="All 4 branches missed.">    if(flags.USE_ACRONYM &amp;&amp; Rules.entityIsAcronym(document, mentionCluster, potentialAntecedent)) {</span>
<span class="nc" id="L298">      SieveCoreferenceSystem.logger.finest(&quot;Acronym: &quot; + mention.spanToString() + &quot;\tvs\t&quot; + ant.spanToString());</span>
<span class="nc" id="L299">      return true;</span>
    }
<span class="nc bnc" id="L301" title="All 4 branches missed.">    if(flags.USE_RELATIVEPRONOUN &amp;&amp; Rules.entityIsRelativePronoun(mention, ant)){</span>
<span class="nc" id="L302">      SieveCoreferenceSystem.logger.finest(&quot;Relative pronoun: &quot; + mention.spanToString() + &quot;\tvs\t&quot; + ant.spanToString());</span>
<span class="nc" id="L303">      return true;</span>
    }
<span class="nc bnc" id="L305" title="All 4 branches missed.">    if(flags.USE_DEMONYM &amp;&amp; mention.isDemonym(ant, dict)){</span>
<span class="nc" id="L306">      SieveCoreferenceSystem.logger.finest(&quot;Demonym: &quot; + mention.spanToString() + &quot;\tvs\t&quot; + ant.spanToString());</span>
<span class="nc" id="L307">      return true;</span>
    }

<span class="nc bnc" id="L310" title="All 6 branches missed.">    if(flags.USE_ROLEAPPOSITION &amp;&amp; lang != Locale.CHINESE &amp;&amp; Rules.entityIsRoleAppositive(mentionCluster, potentialAntecedent, mention, ant, dict)){</span>
<span class="nc" id="L311">      SieveCoreferenceSystem.logger.finest(&quot;Role Appositive: &quot;+mention.spanToString()+&quot;\tvs\t&quot;+ant.spanToString());</span>
<span class="nc" id="L312">      ret = true;</span>
    }
<span class="nc bnc" id="L314" title="All 4 branches missed.">    if(flags.USE_INCLUSION_HEADMATCH &amp;&amp; Rules.entityHeadsAgree(mentionCluster, potentialAntecedent, mention, ant, dict)){</span>
<span class="nc" id="L315">      SieveCoreferenceSystem.logger.finest(&quot;Entity heads agree: &quot;+mention.spanToString()+&quot;\tvs\t&quot;+ant.spanToString());</span>
<span class="nc" id="L316">      ret = true;</span>
    }
<span class="nc bnc" id="L318" title="All 4 branches missed.">    if(flags.USE_RELAXED_HEADMATCH &amp;&amp; Rules.entityRelaxedHeadsAgreeBetweenMentions(mentionCluster, potentialAntecedent, mention, ant) ){</span>
<span class="nc" id="L319">      ret = true;</span>
    }

<span class="nc bnc" id="L322" title="All 6 branches missed.">    if(flags.USE_WORDS_INCLUSION &amp;&amp; ret &amp;&amp; ! Rules.entityWordsIncluded(mentionCluster, potentialAntecedent, mention, ant)) {</span>
<span class="nc" id="L323">      return false;</span>
    }

<span class="nc bnc" id="L326" title="All 6 branches missed.">    if(flags.USE_INCOMPATIBLE_MODIFIER &amp;&amp; ret &amp;&amp; Rules.entityHaveIncompatibleModifier(mentionCluster, potentialAntecedent)) {</span>
<span class="nc" id="L327">      return false;</span>
    }
<span class="nc bnc" id="L329" title="All 6 branches missed.">    if(flags.USE_PROPERHEAD_AT_LAST &amp;&amp; ret &amp;&amp; !Rules.entitySameProperHeadLastWord(mentionCluster, potentialAntecedent, mention, ant)) {</span>
<span class="nc" id="L330">      return false;</span>
    }
<span class="nc bnc" id="L332" title="All 4 branches missed.">    if(flags.USE_ATTRIBUTES_AGREE &amp;&amp; !Rules.entityAttributesAgree(mentionCluster, potentialAntecedent)) {</span>
<span class="nc" id="L333">      return false;</span>
    }
<span class="nc bnc" id="L335" title="All 2 branches missed.">    if(flags.USE_DIFFERENT_LOCATION</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">        &amp;&amp; Rules.entityHaveDifferentLocation(mention, ant, dict)) {</span>
<span class="nc bnc" id="L337" title="All 6 branches missed.">      if(flags.USE_PROPERHEAD_AT_LAST  &amp;&amp; ret &amp;&amp; mention.goldCorefClusterID!=ant.goldCorefClusterID) {</span>
<span class="nc" id="L338">        SieveCoreferenceSystem.logger.finest(&quot;DIFFERENT LOCATION: &quot;+ant.spanToString()+&quot; :: &quot;+mention.spanToString());</span>
      }
<span class="nc" id="L340">      return false;</span>
    }
<span class="nc bnc" id="L342" title="All 2 branches missed.">    if(flags.USE_NUMBER_IN_MENTION</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">        &amp;&amp; Rules.entityNumberInLaterMention(mention, ant)) {</span>
<span class="nc bnc" id="L344" title="All 6 branches missed.">      if(flags.USE_PROPERHEAD_AT_LAST  &amp;&amp; ret &amp;&amp; mention.goldCorefClusterID!=ant.goldCorefClusterID) {</span>
<span class="nc" id="L345">        SieveCoreferenceSystem.logger.finest(&quot;NEW NUMBER : &quot;+ant.spanToString()+&quot; :: &quot;+mention.spanToString());</span>
      }
<span class="nc" id="L347">      return false;</span>
    }
<span class="nc bnc" id="L349" title="All 2 branches missed.">    if(flags.USE_WN_HYPERNYM) {</span>
<span class="nc" id="L350">      Method meth = semantics.wordnet.getClass().getMethod(&quot;checkHypernym&quot;, CorefCluster.class, CorefCluster.class, Mention.class, Mention.class);</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">      if((Boolean) meth.invoke(semantics.wordnet, mentionCluster, potentialAntecedent, mention, ant)) {</span>
<span class="nc" id="L352">        ret = true;</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">      } else if (mention.goldCorefClusterID == ant.goldCorefClusterID</span>
<span class="nc bnc" id="L354" title="All 4 branches missed.">          &amp;&amp; !mention.isPronominal() &amp;&amp; !ant.isPronominal()){</span>
<span class="nc" id="L355">        SieveCoreferenceSystem.logger.finest(&quot;not hypernym in WN&quot;);</span>
<span class="nc" id="L356">        SieveCoreferenceSystem.logger.finest(&quot;False Negatives:: &quot; + ant.spanToString() +&quot; &lt;= &quot;+mention.spanToString());</span>
      }
    }
<span class="nc bnc" id="L359" title="All 2 branches missed.">    if(flags.USE_WN_SYNONYM) {</span>
<span class="nc" id="L360">      Method meth = semantics.wordnet.getClass().getMethod(&quot;checkSynonym&quot;, new Class[]{Mention.class, Mention.class});</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">      if((Boolean) meth.invoke(semantics.wordnet, mention, ant)) {</span>
<span class="nc" id="L362">        ret = true;</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">      } else if (mention.goldCorefClusterID == ant.goldCorefClusterID</span>
<span class="nc bnc" id="L364" title="All 4 branches missed.">          &amp;&amp; !mention.isPronominal() &amp;&amp; !ant.isPronominal()){</span>
<span class="nc" id="L365">        SieveCoreferenceSystem.logger.finest(&quot;not synonym in WN&quot;);</span>
<span class="nc" id="L366">        SieveCoreferenceSystem.logger.finest(&quot;False Negatives:: &quot; + ant.spanToString() +&quot; &lt;= &quot;+mention.spanToString());</span>
      }
    }

    try {
<span class="nc bnc" id="L371" title="All 4 branches missed.">      if(flags.USE_ALIAS &amp;&amp; Rules.entityAlias(mentionCluster, potentialAntecedent, semantics, dict)){</span>
<span class="nc" id="L372">        return true;</span>
      }
<span class="nc" id="L374">    } catch (Exception e) {</span>
<span class="nc" id="L375">      throw new RuntimeException(e);</span>
<span class="nc" id="L376">    }</span>

<span class="nc bnc" id="L378" title="All 4 branches missed.">    if(flags.USE_DISTANCE &amp;&amp; Rules.entityTokenDistance(mention2, ant)){</span>
<span class="nc" id="L379">      return false;</span>
    }

<span class="nc bnc" id="L382" title="All 2 branches missed.">    if(flags.USE_COREF_DICT){</span>

      // Head match
<span class="nc bnc" id="L385" title="All 2 branches missed.">      if(ant.headWord.lemma().equals(mention2.headWord.lemma())) return false;</span>

      // Constraint: ignore pairs commonNoun - properNoun
<span class="nc bnc" id="L388" title="All 2 branches missed.">      if(ant.mentionType != MentionType.PROPER &amp;&amp;</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">         ( mention2.headWord.get(CoreAnnotations.PartOfSpeechAnnotation.class).startsWith(&quot;NNP&quot;)</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">           || !mention2.headWord.word().substring(1).equals(mention2.headWord.word().substring(1).toLowerCase()) ) ) return false;</span>

      // Constraint: ignore plurals
<span class="nc bnc" id="L393" title="All 2 branches missed.">      if(ant.headWord.get(CoreAnnotations.PartOfSpeechAnnotation.class).equals(&quot;NNS&quot;)</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">          &amp;&amp; mention2.headWord.get(CoreAnnotations.PartOfSpeechAnnotation.class).equals(&quot;NNS&quot;)) return false;</span>

      // Constraint: ignore mentions with indefinite determiners
<span class="nc bnc" id="L397" title="All 2 branches missed.">      if(dict.indefinitePronouns.contains(ant.originalSpan.get(0).lemma())</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">          || dict.indefinitePronouns.contains(mention2.originalSpan.get(0).lemma())) return false;</span>

      // Constraint: ignore coordinated mentions
<span class="nc bnc" id="L401" title="All 4 branches missed.">      if(ant.isCoordinated() || mention2.isCoordinated()) return false;</span>

      // Constraint: context incompatibility
<span class="nc bnc" id="L404" title="All 2 branches missed.">      if(Rules.contextIncompatible(mention2, ant, dict)) return false;</span>

      // Constraint: sentence context incompatibility when the mentions are common nouns
<span class="nc bnc" id="L407" title="All 2 branches missed.">      if(Rules.sentenceContextIncompatible(mention2, ant, dict)) return false;</span>

<span class="nc bnc" id="L409" title="All 2 branches missed.">      if(Rules.entityClusterAllCorefDictionary(mentionCluster, potentialAntecedent, dict, 1, 8)) return true;</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">      if(Rules.entityCorefDictionary(mention, ant, dict, 2, 2)) return true;</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">      if(Rules.entityCorefDictionary(mention, ant, dict, 3, 2)) return true;</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">      if(Rules.entityCorefDictionary(mention, ant, dict, 4, 2)) return true;</span>
    }

<span class="nc bnc" id="L415" title="All 2 branches missed.">    if(flags.DO_PRONOUN){</span>
      Mention m;
<span class="nc bnc" id="L417" title="All 4 branches missed.">      if (mention.predicateNominatives!=null &amp;&amp; mention.predicateNominatives.contains(mention2)) {</span>
<span class="nc" id="L418">        m = mention2;</span>
      } else {
<span class="nc" id="L420">        m = mention;</span>
      }

<span class="nc bnc" id="L423" title="All 6 branches missed.">      if((m.isPronominal() || dict.allPronouns.contains(m.toString())) &amp;&amp; Rules.entityAttributesAgree(mentionCluster, potentialAntecedent)){</span>

<span class="nc bnc" id="L425" title="All 4 branches missed.">        if(dict.demonymSet.contains(ant.lowercaseNormalizedSpanString()) &amp;&amp; dict.notOrganizationPRP.contains(m.headString)){</span>
<span class="nc" id="L426">          document.addIncompatible(m, ant);</span>
<span class="nc" id="L427">          return false;</span>
        }
<span class="nc bnc" id="L429" title="All 2 branches missed.">        if(Constants.USE_DISCOURSE_CONSTRAINTS &amp;&amp; Rules.entityPersonDisagree(document, mentionCluster, potentialAntecedent, dict)){</span>
<span class="nc bnc" id="L430" title="All 2 branches missed.">          SieveCoreferenceSystem.logger.finest(&quot;Incompatibles: Person Disagree: &quot;+ant.spanToString()+&quot;(&quot;+ant.mentionID+&quot;) :: &quot;+mention.spanToString()+&quot;(&quot;+mention.mentionID+&quot;) -&gt; &quot;+(mention.goldCorefClusterID!=ant.goldCorefClusterID));</span>
<span class="nc" id="L431">          document.addIncompatible(m, ant);</span>
<span class="nc" id="L432">          return false;</span>
        }
<span class="nc" id="L434">        return true;</span>
      }
    }

<span class="nc" id="L438">    return ret;</span>
  }

  /**
   * Orders the antecedents for the given mention (m1)
   * @param antecedentSentence
   * @param mySentence
   * @param orderedMentions
   * @param orderedMentionsBySentence
   * @param m1
   * @param m1Position
   * @param corefClusters
   * @param dict
   * @return An ordering of potential antecedents depending on same/different sentence, etc.
   */
  public List&lt;Mention&gt; getOrderedAntecedents(
      int antecedentSentence,
      int mySentence,
      List&lt;Mention&gt; orderedMentions,
      List&lt;List&lt;Mention&gt;&gt; orderedMentionsBySentence,
      Mention m1,
      int m1Position,
      Map&lt;Integer, CorefCluster&gt; corefClusters,
      Dictionaries dict) {
<span class="nc" id="L462">    List&lt;Mention&gt; orderedAntecedents = new ArrayList&lt;&gt;();</span>

    // ordering antecedents
<span class="nc bnc" id="L465" title="All 2 branches missed.">    if (antecedentSentence == mySentence) {   // same sentence</span>
<span class="nc" id="L466">      orderedAntecedents.addAll(orderedMentions.subList(0, m1Position));</span>
<span class="nc bnc" id="L467" title="All 4 branches missed.">      if(flags.DO_PRONOUN &amp;&amp; corefClusters.get(m1.corefClusterID).isSinglePronounCluster(dict)) {</span>
<span class="nc" id="L468">        orderedAntecedents = sortMentionsForPronoun(orderedAntecedents, m1, true);</span>
      }
<span class="nc bnc" id="L470" title="All 2 branches missed.">      if(dict.relativePronouns.contains(m1.spanToString())) Collections.reverse(orderedAntecedents);</span>
    } else {    // previous sentence
<span class="nc" id="L472">      orderedAntecedents.addAll(orderedMentionsBySentence.get(antecedentSentence));</span>
    }

<span class="nc" id="L475">    return orderedAntecedents;</span>
  }

  /** Divides a sentence into clauses and sorts the antecedents for pronoun matching. */
  private static List&lt;Mention&gt; sortMentionsForPronoun(List&lt;Mention&gt; l, Mention m1, boolean sameSentence) {
<span class="nc" id="L480">    List&lt;Mention&gt; sorted = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">    if (sameSentence) {</span>
<span class="nc" id="L482">      Tree tree = m1.contextParseTree;</span>
<span class="nc" id="L483">      Tree current = m1.mentionSubTree;</span>
<span class="nc" id="L484">      current = current.parent(tree);</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">      while (current != null) {</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">        if (current.label().value().startsWith(&quot;S&quot;)) {</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">          for (Mention m : l) {</span>
<span class="nc bnc" id="L488" title="All 4 branches missed.">            if (!sorted.contains(m) &amp;&amp; current.dominates(m.mentionSubTree)) {</span>
<span class="nc" id="L489">              sorted.add(m);</span>
            }
<span class="nc" id="L491">          }</span>
        }
<span class="nc" id="L493">        current = current.parent(tree);</span>
      }
<span class="nc bnc" id="L495" title="All 2 branches missed.">      if (SieveCoreferenceSystem.logger.isLoggable(Level.FINEST)) {</span>
<span class="nc bnc" id="L496" title="All 2 branches missed.">        if (l.size()!=sorted.size()) {</span>
<span class="nc" id="L497">          SieveCoreferenceSystem.logger.finest(&quot;sorting failed!!! -&gt; parser error?? \tmentionID: &quot;+m1.mentionID+&quot; &quot; + m1.spanToString());</span>
<span class="nc" id="L498">          sorted = l;</span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">        } else if ( ! l.equals(sorted)) {</span>
<span class="nc" id="L500">          SieveCoreferenceSystem.logger.finest(&quot;sorting succeeded &amp; changed !! \tmentionID: &quot;+m1.mentionID+&quot; &quot; + m1.spanToString());</span>
<span class="nc bnc" id="L501" title="All 2 branches missed.">          for (int i=0; i&lt;l.size(); i++) {</span>
<span class="nc" id="L502">            Mention ml = l.get(i);</span>
<span class="nc" id="L503">            Mention msorted = sorted.get(i);</span>
<span class="nc" id="L504">            SieveCoreferenceSystem.logger.finest(&quot;\t[&quot;+ml.spanToString()+&quot;]\t[&quot;+msorted.spanToString()+&quot;]&quot;);</span>
          }
        } else {
<span class="nc" id="L507">          SieveCoreferenceSystem.logger.finest(&quot;no changed !! \tmentionID: &quot;+m1.mentionID+&quot; &quot; + m1.spanToString());</span>
        }
      }
    }
<span class="nc" id="L511">    return sorted;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>