<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JSONOutputter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.pipeline</a> &gt; <span class="el_source">JSONOutputter.java</span></div><h1>JSONOutputter.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.pipeline;

import edu.stanford.nlp.ie.machinereading.structure.Span;
import edu.stanford.nlp.ie.util.RelationTriple;
import edu.stanford.nlp.io.IOUtils;
import edu.stanford.nlp.io.StringOutputStream;
import edu.stanford.nlp.ling.CoreAnnotations;
import edu.stanford.nlp.ling.IndexedWord;
import edu.stanford.nlp.ling.SentenceUtils;
import edu.stanford.nlp.naturalli.NaturalLogicAnnotations;
import edu.stanford.nlp.neural.rnn.RNNCoreAnnotations;
import edu.stanford.nlp.semgraph.SemanticGraph;
import edu.stanford.nlp.semgraph.SemanticGraphCoreAnnotations;
import edu.stanford.nlp.semgraph.SemanticGraphEdge;
import edu.stanford.nlp.sentiment.SentimentCoreAnnotations;
import edu.stanford.nlp.time.TimeAnnotations;
import edu.stanford.nlp.time.Timex;
import edu.stanford.nlp.trees.Tree;
import edu.stanford.nlp.trees.TreeCoreAnnotations;
import edu.stanford.nlp.trees.TreePrint;
import edu.stanford.nlp.util.CoreMap;
import edu.stanford.nlp.util.Generics;
import edu.stanford.nlp.util.Pair;
import edu.stanford.nlp.util.Pointer;

import java.io.*;
import java.text.DecimalFormat;
import java.util.*;
import java.util.function.Consumer;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import edu.stanford.nlp.coref.CorefCoreAnnotations;

import edu.stanford.nlp.coref.data.CorefChain;

/**
 * Output an Annotation to human readable JSON.
 * This is not a lossless operation; for more strict serialization,
 * see {@link edu.stanford.nlp.pipeline.AnnotationSerializer}; e.g.,
 * {@link edu.stanford.nlp.pipeline.ProtobufAnnotationSerializer}.
 *
 * @author Gabor Angeli
 */
@SuppressWarnings(&quot;unused&quot;)
<span class="fc" id="L46">public class JSONOutputter extends AnnotationOutputter {</span>

  protected static final String INDENT_CHAR = &quot;  &quot;;

  public static String cleanJSON(String s) {
<span class="fc" id="L51">    return s</span>
<span class="fc" id="L52">        .replace(&quot;\\&quot;, &quot;\\\\&quot;)</span>
<span class="fc" id="L53">        .replace(&quot;\b&quot;, &quot;\\b&quot;)</span>
<span class="fc" id="L54">        .replace(&quot;\f&quot;, &quot;\\f&quot;)</span>
<span class="fc" id="L55">        .replace(&quot;\n&quot;, &quot;\\n&quot;)</span>
<span class="fc" id="L56">        .replace(&quot;\r&quot;, &quot;\\r&quot;)</span>
<span class="fc" id="L57">        .replace(&quot;\t&quot;, &quot;\\t&quot;)</span>
<span class="fc" id="L58">        .replace(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;);</span>
  }


  /** {@inheritDoc} */
  @SuppressWarnings(&quot;RedundantCast&quot;)  // It's lying; we need the &quot;redundant&quot; casts (as of 2014-09-08)
  @Override
  public void print(Annotation doc, OutputStream target, Options options) throws IOException {
<span class="fc" id="L66">    PrintWriter writer = new PrintWriter(IOUtils.encodedOutputStreamWriter(target, options.encoding));</span>
<span class="fc" id="L67">    JSONWriter l0 = new JSONWriter(writer, options);</span>

<span class="fc" id="L69">    l0.object(l1 -&gt; {</span>

      // Add annotations attached to a Document
<span class="fc" id="L72">      l1.set(&quot;docId&quot;, doc.get(CoreAnnotations.DocIDAnnotation.class));</span>
<span class="fc" id="L73">      l1.set(&quot;docDate&quot;, doc.get(CoreAnnotations.DocDateAnnotation.class));</span>
<span class="fc" id="L74">      l1.set(&quot;docSourceType&quot;, doc.get(CoreAnnotations.DocSourceTypeAnnotation.class));</span>
<span class="fc" id="L75">      l1.set(&quot;docType&quot;, doc.get(CoreAnnotations.DocTypeAnnotation.class));</span>
<span class="fc" id="L76">      l1.set(&quot;author&quot;, doc.get(CoreAnnotations.AuthorAnnotation.class));</span>
<span class="fc" id="L77">      l1.set(&quot;location&quot;, doc.get(CoreAnnotations.LocationAnnotation.class));</span>
<span class="pc bpc" id="L78" title="1 of 2 branches missed.">      if (options.includeText) {</span>
<span class="nc" id="L79">        l1.set(&quot;text&quot;, doc.get(CoreAnnotations.TextAnnotation.class));</span>
      }

      // Add sentences
<span class="pc bpc" id="L83" title="1 of 2 branches missed.">      if (doc.get(CoreAnnotations.SentencesAnnotation.class) != null) {</span>
<span class="fc" id="L84">        l1.set(&quot;sentences&quot;, doc.get(CoreAnnotations.SentencesAnnotation.class).stream().map(sentence -&gt; (Consumer&lt;Writer&gt;) (Writer l2) -&gt; {</span>
          // Add a single sentence
          // (metadata)
<span class="fc" id="L87">          l2.set(&quot;id&quot;, sentence.get(CoreAnnotations.SentenceIDAnnotation.class));</span>
<span class="fc" id="L88">          l2.set(&quot;index&quot;, sentence.get(CoreAnnotations.SentenceIndexAnnotation.class));</span>
<span class="fc" id="L89">          l2.set(&quot;line&quot;, sentence.get(CoreAnnotations.LineNumberAnnotation.class));</span>
          // (constituency tree)
<span class="fc" id="L91">          StringWriter treeStrWriter = new StringWriter();</span>
<span class="fc" id="L92">          TreePrint treePrinter = options.constituentTreePrinter;</span>
<span class="pc bpc" id="L93" title="1 of 2 branches missed.">          if (treePrinter == AnnotationOutputter.DEFAULT_CONSTITUENT_TREE_PRINTER) {</span>
            // note the '==' -- we're overwriting the default, but only if it was not explicitly set otherwise
<span class="fc" id="L95">            treePrinter = new TreePrint(&quot;oneline&quot;);</span>
          }
<span class="fc" id="L97">          treePrinter.printTree(sentence.get(TreeCoreAnnotations.TreeAnnotation.class), new PrintWriter(treeStrWriter, true));</span>
<span class="fc" id="L98">          String treeStr = treeStrWriter.toString().trim();  // strip the trailing newline</span>
<span class="pc bpc" id="L99" title="1 of 2 branches missed.">          if (!&quot;SENTENCE_SKIPPED_OR_UNPARSABLE&quot;.equals(treeStr)) {</span>
<span class="nc" id="L100">            l2.set(&quot;parse&quot;, treeStr);</span>
          }
          // (dependency trees)
<span class="fc" id="L103">          l2.set(&quot;basicDependencies&quot;, buildDependencyTree(sentence.get(SemanticGraphCoreAnnotations.BasicDependenciesAnnotation.class)));</span>
<span class="fc" id="L104">          l2.set(&quot;enhancedDependencies&quot;, buildDependencyTree(sentence.get(SemanticGraphCoreAnnotations.EnhancedDependenciesAnnotation.class)));</span>
<span class="fc" id="L105">          l2.set(&quot;enhancedPlusPlusDependencies&quot;, buildDependencyTree(sentence.get(SemanticGraphCoreAnnotations.EnhancedPlusPlusDependenciesAnnotation.class)));</span>
          // (sentiment)
<span class="fc" id="L107">          Tree sentimentTree = sentence.get(SentimentCoreAnnotations.SentimentAnnotatedTree.class);</span>
<span class="pc bpc" id="L108" title="1 of 2 branches missed.">          if (sentimentTree != null) {</span>
<span class="nc" id="L109">            int sentiment = RNNCoreAnnotations.getPredictedClass(sentimentTree);</span>
<span class="nc" id="L110">            String sentimentClass = sentence.get(SentimentCoreAnnotations.SentimentClass.class);</span>
<span class="nc" id="L111">            l2.set(&quot;sentimentValue&quot;, Integer.toString(sentiment));</span>
<span class="nc" id="L112">            l2.set(&quot;sentiment&quot;, sentimentClass.replaceAll(&quot; &quot;, &quot;&quot;));</span>
          }
          // (openie)
<span class="fc" id="L115">          Collection&lt;RelationTriple&gt; openIETriples = sentence.get(NaturalLogicAnnotations.RelationTriplesAnnotation.class);</span>
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">          if (openIETriples != null) {</span>
<span class="nc" id="L117">            l2.set(&quot;openie&quot;, openIETriples.stream().map(triple -&gt; (Consumer&lt;Writer&gt;) (Writer tripleWriter) -&gt; {</span>
<span class="nc" id="L118">              tripleWriter.set(&quot;subject&quot;, triple.subjectGloss());</span>
<span class="nc" id="L119">              tripleWriter.set(&quot;subjectSpan&quot;, Span.fromPair(triple.subjectTokenSpan()));</span>
<span class="nc" id="L120">              tripleWriter.set(&quot;relation&quot;, triple.relationGloss());</span>
<span class="nc" id="L121">              tripleWriter.set(&quot;relationSpan&quot;, Span.fromPair(triple.relationTokenSpan()));</span>
<span class="nc" id="L122">              tripleWriter.set(&quot;object&quot;, triple.objectGloss());</span>
<span class="nc" id="L123">              tripleWriter.set(&quot;objectSpan&quot;, Span.fromPair(triple.objectTokenSpan()));</span>
<span class="nc" id="L124">            }));</span>
          }
          // (kbp)
<span class="fc" id="L127">          Collection&lt;RelationTriple&gt; kbpTriples = sentence.get(CoreAnnotations.KBPTriplesAnnotation.class);</span>
<span class="pc bpc" id="L128" title="1 of 2 branches missed.">          if (kbpTriples != null) {</span>
<span class="nc" id="L129">            l2.set(&quot;kbp&quot;, kbpTriples.stream().map(triple -&gt; (Consumer&lt;Writer&gt;) (Writer tripleWriter) -&gt; {</span>
<span class="nc" id="L130">              tripleWriter.set(&quot;subject&quot;, triple.subjectGloss());</span>
<span class="nc" id="L131">              tripleWriter.set(&quot;subjectSpan&quot;, Span.fromPair(triple.subjectTokenSpan()));</span>
<span class="nc" id="L132">              tripleWriter.set(&quot;relation&quot;, triple.relationGloss());</span>
<span class="nc" id="L133">              tripleWriter.set(&quot;relationSpan&quot;, Span.fromPair(triple.relationTokenSpan()));</span>
<span class="nc" id="L134">              tripleWriter.set(&quot;object&quot;, triple.objectGloss());</span>
<span class="nc" id="L135">              tripleWriter.set(&quot;objectSpan&quot;, Span.fromPair(triple.objectTokenSpan()));</span>
<span class="nc" id="L136">            }));</span>
          }

          // (entity mentions)
<span class="pc bpc" id="L140" title="1 of 2 branches missed.">          if (sentence.get(CoreAnnotations.MentionsAnnotation.class) != null) {</span>
<span class="nc" id="L141">            Integer sentTokenBegin = sentence.get(CoreAnnotations.TokenBeginAnnotation.class);</span>
<span class="nc" id="L142">            l2.set(&quot;entitymentions&quot;, sentence.get(CoreAnnotations.MentionsAnnotation.class).stream().map(m -&gt; (Consumer&lt;Writer&gt;) (Writer l3) -&gt; {</span>
<span class="nc" id="L143">              Integer tokenBegin = m.get(CoreAnnotations.TokenBeginAnnotation.class);</span>
<span class="nc" id="L144">              Integer tokenEnd = m.get(CoreAnnotations.TokenEndAnnotation.class);</span>
<span class="nc" id="L145">              l3.set(&quot;docTokenBegin&quot;, tokenBegin);</span>
<span class="nc" id="L146">              l3.set(&quot;docTokenEnd&quot;, tokenEnd);</span>
<span class="nc bnc" id="L147" title="All 4 branches missed.">              if (tokenBegin != null &amp;&amp; sentTokenBegin != null) {</span>
<span class="nc" id="L148">                l3.set(&quot;tokenBegin&quot;, tokenBegin - sentTokenBegin);</span>
              }
<span class="nc bnc" id="L150" title="All 4 branches missed.">              if (tokenEnd != null &amp;&amp; sentTokenBegin != null) {</span>
<span class="nc" id="L151">                l3.set(&quot;tokenEnd&quot;, tokenEnd - sentTokenBegin);</span>
              }
<span class="nc" id="L153">              l3.set(&quot;text&quot;, m.get(CoreAnnotations.TextAnnotation.class));</span>
              //l3.set(&quot;originalText&quot;, m.get(CoreAnnotations.OriginalTextAnnotation.class));
              //l3.set(&quot;lemma&quot;, m.get(CoreAnnotations.LemmaAnnotation.class));
<span class="nc" id="L156">              l3.set(&quot;characterOffsetBegin&quot;, m.get(CoreAnnotations.CharacterOffsetBeginAnnotation.class));</span>
<span class="nc" id="L157">              l3.set(&quot;characterOffsetEnd&quot;, m.get(CoreAnnotations.CharacterOffsetEndAnnotation.class));</span>
              //l3.set(&quot;pos&quot;, m.get(CoreAnnotations.PartOfSpeechAnnotation.class));
<span class="nc" id="L159">              l3.set(&quot;ner&quot;, m.get(CoreAnnotations.NamedEntityTagAnnotation.class));</span>
<span class="nc" id="L160">              l3.set(&quot;normalizedNER&quot;, m.get(CoreAnnotations.NormalizedNamedEntityTagAnnotation.class));</span>
<span class="nc" id="L161">              l3.set(&quot;entitylink&quot;, m.get(CoreAnnotations.WikipediaEntityAnnotation.class));</span>
              // Timex
<span class="nc" id="L163">              Timex time = m.get(TimeAnnotations.TimexAnnotation.class);</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">              if (time != null) {</span>
<span class="nc" id="L165">                Timex.Range range = time.range();</span>
<span class="nc" id="L166">                l3.set(&quot;timex&quot;, (Consumer&lt;Writer&gt;) l4 -&gt; {</span>
<span class="nc" id="L167">                  l4.set(&quot;tid&quot;, time.tid());</span>
<span class="nc" id="L168">                  l4.set(&quot;type&quot;, time.timexType());</span>
<span class="nc" id="L169">                  l4.set(&quot;value&quot;, time.value());</span>
<span class="nc" id="L170">                  l4.set(&quot;altValue&quot;, time.altVal());</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">                  l4.set(&quot;range&quot;, (range != null)? (Consumer&lt;Writer&gt;) l5 -&gt; {</span>
<span class="nc" id="L172">                    l5.set(&quot;begin&quot;, range.begin);</span>
<span class="nc" id="L173">                    l5.set(&quot;end&quot;, range.end);</span>
<span class="nc" id="L174">                    l5.set(&quot;duration&quot;, range.duration);</span>
<span class="nc" id="L175">                  } : null);</span>
<span class="nc" id="L176">                });</span>
              }
<span class="nc" id="L178">            }));</span>
          }

          // (add tokens)
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">          if (sentence.get(CoreAnnotations.TokensAnnotation.class) != null) {</span>
<span class="fc" id="L183">            l2.set(&quot;tokens&quot;, sentence.get(CoreAnnotations.TokensAnnotation.class).stream().map(token -&gt; (Consumer&lt;Writer&gt;) (Writer l3) -&gt; {</span>
              // Add a single token
<span class="fc" id="L185">              l3.set(&quot;index&quot;, token.index());</span>
<span class="fc" id="L186">              l3.set(&quot;word&quot;, token.word());</span>
<span class="fc" id="L187">              l3.set(&quot;originalText&quot;, token.originalText());</span>
<span class="fc" id="L188">              l3.set(&quot;lemma&quot;, token.lemma());</span>
<span class="fc" id="L189">              l3.set(&quot;characterOffsetBegin&quot;, token.beginPosition());</span>
<span class="fc" id="L190">              l3.set(&quot;characterOffsetEnd&quot;, token.endPosition());</span>
<span class="fc" id="L191">              l3.set(&quot;pos&quot;, token.tag());</span>
<span class="fc" id="L192">              l3.set(&quot;ner&quot;, token.ner());</span>
<span class="fc" id="L193">              l3.set(&quot;normalizedNER&quot;, token.get(CoreAnnotations.NormalizedNamedEntityTagAnnotation.class));</span>
<span class="fc" id="L194">              l3.set(&quot;speaker&quot;, token.get(CoreAnnotations.SpeakerAnnotation.class));</span>
<span class="fc" id="L195">              l3.set(&quot;truecase&quot;, token.get(CoreAnnotations.TrueCaseAnnotation.class));</span>
<span class="fc" id="L196">              l3.set(&quot;truecaseText&quot;, token.get(CoreAnnotations.TrueCaseTextAnnotation.class));</span>
<span class="fc" id="L197">              l3.set(&quot;before&quot;, token.get(CoreAnnotations.BeforeAnnotation.class));</span>
<span class="fc" id="L198">              l3.set(&quot;after&quot;, token.get(CoreAnnotations.AfterAnnotation.class));</span>
<span class="fc" id="L199">              l3.set(&quot;entitylink&quot;, token.get(CoreAnnotations.WikipediaEntityAnnotation.class));</span>
              // Timex
<span class="fc" id="L201">              Timex time = token.get(TimeAnnotations.TimexAnnotation.class);</span>
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">              if (time != null) {</span>
<span class="nc" id="L203">                Timex.Range range = time.range();</span>
<span class="nc" id="L204">                l3.set(&quot;timex&quot;, (Consumer&lt;Writer&gt;) l4 -&gt; {</span>
<span class="nc" id="L205">                  l4.set(&quot;tid&quot;, time.tid());</span>
<span class="nc" id="L206">                  l4.set(&quot;type&quot;, time.timexType());</span>
<span class="nc" id="L207">                  l4.set(&quot;value&quot;, time.value());</span>
<span class="nc" id="L208">                  l4.set(&quot;altValue&quot;, time.altVal());</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">                  l4.set(&quot;range&quot;, (range != null)? (Consumer&lt;Writer&gt;) l5 -&gt; {</span>
<span class="nc" id="L210">                    l5.set(&quot;begin&quot;, range.begin);</span>
<span class="nc" id="L211">                    l5.set(&quot;end&quot;, range.end);</span>
<span class="nc" id="L212">                    l5.set(&quot;duration&quot;, range.duration);</span>
<span class="nc" id="L213">                  } : null);</span>
<span class="nc" id="L214">                });</span>
              }
<span class="fc" id="L216">            }));</span>
          }
<span class="fc" id="L218">        }));</span>
      }

      // Add coref values
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">      if (doc.get(CorefCoreAnnotations.CorefChainAnnotation.class) != null) {</span>
<span class="nc" id="L223">        Map&lt;Integer, CorefChain&gt; corefChains =</span>
<span class="nc" id="L224">            doc.get(CorefCoreAnnotations.CorefChainAnnotation.class);</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">        if (corefChains != null) {</span>
<span class="nc" id="L226">          l1.set(&quot;corefs&quot;, (Consumer&lt;Writer&gt;) chainWriter -&gt; {</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">            for (CorefChain chain : corefChains.values()) {</span>
<span class="nc" id="L228">              CorefChain.CorefMention representative = chain.getRepresentativeMention();</span>
<span class="nc" id="L229">              chainWriter.set(Integer.toString(chain.getChainID()), chain.getMentionsInTextualOrder().stream().map(mention -&gt; (Consumer&lt;Writer&gt;) (Writer mentionWriter) -&gt; {</span>
<span class="nc" id="L230">                mentionWriter.set(&quot;id&quot;, mention.mentionID);</span>
<span class="nc" id="L231">                mentionWriter.set(&quot;text&quot;, mention.mentionSpan);</span>
<span class="nc" id="L232">                mentionWriter.set(&quot;type&quot;, mention.mentionType);</span>
<span class="nc" id="L233">                mentionWriter.set(&quot;number&quot;, mention.number);</span>
<span class="nc" id="L234">                mentionWriter.set(&quot;gender&quot;, mention.gender);</span>
<span class="nc" id="L235">                mentionWriter.set(&quot;animacy&quot;, mention.animacy);</span>
<span class="nc" id="L236">                mentionWriter.set(&quot;startIndex&quot;, mention.startIndex);</span>
<span class="nc" id="L237">                mentionWriter.set(&quot;endIndex&quot;, mention.endIndex);</span>
<span class="nc" id="L238">                mentionWriter.set(&quot;headIndex&quot;, mention.headIndex);</span>
<span class="nc" id="L239">                mentionWriter.set(&quot;sentNum&quot;, mention.sentNum);</span>
<span class="nc" id="L240">                mentionWriter.set(&quot;position&quot;, Arrays.stream(mention.position.elems()).boxed().collect(Collectors.toList()));</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">                mentionWriter.set(&quot;isRepresentativeMention&quot;, mention == representative);</span>
<span class="nc" id="L242">              }));</span>
<span class="nc" id="L243">            }</span>
<span class="nc" id="L244">          });</span>
        }
      }

      // quotes
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">      if (doc.get(CoreAnnotations.QuotationsAnnotation.class) != null) {</span>
<span class="nc" id="L250">        List&lt;CoreMap&gt; quotes = QuoteAnnotator.gatherQuotes(doc);</span>
<span class="nc" id="L251">        l1.set(&quot;quotes&quot;, quotes.stream().map(quote -&gt; (Consumer&lt;Writer&gt;) (Writer l2) -&gt; {</span>
<span class="nc" id="L252">            l2.set(&quot;id&quot;, quote.get(CoreAnnotations.QuotationIndexAnnotation.class));</span>
<span class="nc" id="L253">            l2.set(&quot;text&quot;, quote.get(CoreAnnotations.TextAnnotation.class));</span>
<span class="nc" id="L254">            l2.set(&quot;beginIndex&quot;, quote.get(CoreAnnotations.CharacterOffsetBeginAnnotation.class));</span>
<span class="nc" id="L255">            l2.set(&quot;endIndex&quot;, quote.get(CoreAnnotations.CharacterOffsetEndAnnotation.class));</span>
<span class="nc" id="L256">            l2.set(&quot;beginToken&quot;, quote.get(CoreAnnotations.TokenBeginAnnotation.class));</span>
<span class="nc" id="L257">            l2.set(&quot;endToken&quot;, quote.get(CoreAnnotations.TokenEndAnnotation.class));</span>
<span class="nc" id="L258">            l2.set(&quot;beginSentence&quot;, quote.get(CoreAnnotations.SentenceBeginAnnotation.class));</span>
<span class="nc" id="L259">            l2.set(&quot;endSentence&quot;, quote.get(CoreAnnotations.SentenceEndAnnotation.class));</span>
<span class="nc" id="L260">        }));</span>
      }

<span class="fc" id="L263">    });</span>

<span class="fc" id="L265">    l0.writer.flush();  // flush</span>
<span class="fc" id="L266">  }</span>

  /**
   * Convert a dependency graph to a format expected as input to {@link Writer#set(String, Object)}.
   */
  @SuppressWarnings(&quot;RedundantCast&quot;)  // It's lying; we need the &quot;redundant&quot; casts (as of 2014-09-08)
  private static Object buildDependencyTree(SemanticGraph graph) {
<span class="pc bpc" id="L273" title="1 of 2 branches missed.">    if(graph != null) {</span>
<span class="nc" id="L274">      return Stream.concat(</span>
          // Roots
<span class="nc" id="L276">          graph.getRoots().stream().map( (IndexedWord root) -&gt; (Consumer&lt;Writer&gt;) dep -&gt; {</span>
<span class="nc" id="L277">            dep.set(&quot;dep&quot;, &quot;ROOT&quot;);</span>
<span class="nc" id="L278">            dep.set(&quot;governor&quot;, 0);</span>
<span class="nc" id="L279">            dep.set(&quot;governorGloss&quot;, &quot;ROOT&quot;);</span>
<span class="nc" id="L280">            dep.set(&quot;dependent&quot;, root.index());</span>
<span class="nc" id="L281">            dep.set(&quot;dependentGloss&quot;, root.word());</span>
<span class="nc" id="L282">          }),</span>
          // Regular edges
<span class="nc" id="L284">          graph.edgeListSorted().stream().map( (SemanticGraphEdge edge) -&gt; (Consumer&lt;Writer&gt;) (Writer dep) -&gt; {</span>
<span class="nc" id="L285">            dep.set(&quot;dep&quot;, edge.getRelation().toString());</span>
<span class="nc" id="L286">            dep.set(&quot;governor&quot;, edge.getGovernor().index());</span>
<span class="nc" id="L287">            dep.set(&quot;governorGloss&quot;, edge.getGovernor().word());</span>
<span class="nc" id="L288">            dep.set(&quot;dependent&quot;, edge.getDependent().index());</span>
<span class="nc" id="L289">            dep.set(&quot;dependentGloss&quot;, edge.getDependent().word());</span>
<span class="nc" id="L290">          })</span>
      );
    } else {
<span class="fc" id="L293">      return null;</span>
    }
  }

  public static String jsonPrint(Annotation annotation) throws IOException {
<span class="nc" id="L298">    StringOutputStream os = new StringOutputStream();</span>
<span class="nc" id="L299">    new JSONOutputter().print(annotation, os);</span>
<span class="nc" id="L300">    return os.toString();</span>
  }

  public static void jsonPrint(Annotation annotation, OutputStream os) throws IOException {
<span class="nc" id="L304">    new JSONOutputter().print(annotation, os);</span>
<span class="nc" id="L305">  }</span>

  public static void jsonPrint(Annotation annotation, OutputStream os, StanfordCoreNLP pipeline) throws IOException {
<span class="nc" id="L308">    new JSONOutputter().print(annotation, os, pipeline);</span>
<span class="nc" id="L309">  }</span>

  public static void jsonPrint(Annotation annotation, OutputStream os, Options options) throws IOException {
<span class="nc" id="L312">    new JSONOutputter().print(annotation, os, options);</span>
<span class="nc" id="L313">  }</span>


  /**
   * &lt;p&gt;Our very own little JSON writing class.
   * For usage, see the test cases in JSONOutputterTest.&lt;/p&gt;
   *
   * &lt;p&gt;For the love of all that is holy, don't try to write JSON multithreaded.
   * It should go without saying that this is not threadsafe.&lt;/p&gt;
   */
  protected static class JSONWriter {
    private final PrintWriter writer;
    private final Options options;
<span class="fc" id="L326">    private JSONWriter(PrintWriter writer, Options options) {</span>
<span class="fc" id="L327">      this.writer = writer;</span>
<span class="fc" id="L328">      this.options = options;</span>
<span class="fc" id="L329">    }</span>

    @SuppressWarnings({&quot;unchecked&quot;, &quot;UnnecessaryBoxing&quot;})
    private void routeObject(int indent, Object value) {
<span class="fc bfc" id="L333" title="All 2 branches covered.">      if (value instanceof String) {</span>
        // Case: simple string (this is easy!)
<span class="fc" id="L335">        writer.write(&quot;\&quot;&quot;);</span>
<span class="fc" id="L336">        writer.write(cleanJSON(value.toString()));</span>
<span class="fc" id="L337">        writer.write(&quot;\&quot;&quot;);</span>
<span class="fc bfc" id="L338" title="All 2 branches covered.">      } else if (value instanceof Collection) {</span>
        // Case: collection
<span class="fc" id="L340">        writer.write(&quot;[&quot;); newline();</span>
<span class="fc" id="L341">        Iterator&lt;Object&gt; elems = ((Collection&lt;Object&gt;) value).iterator();</span>
<span class="fc bfc" id="L342" title="All 2 branches covered.">        while (elems.hasNext()) {</span>
<span class="fc" id="L343">          indent(indent + 1);</span>
<span class="fc" id="L344">          routeObject(indent + 1, elems.next());</span>
<span class="fc bfc" id="L345" title="All 2 branches covered.">          if (elems.hasNext()) {</span>
<span class="fc" id="L346">            writer.write(&quot;,&quot;);</span>
          }
<span class="fc" id="L348">          newline();</span>
        }
<span class="fc" id="L350">        indent(indent);</span>
<span class="fc" id="L351">        writer.write(&quot;]&quot;);</span>
<span class="pc bpc" id="L352" title="1 of 2 branches missed.">      } else if (value instanceof Enum) {</span>
        // Case: enumeration constant
<span class="nc" id="L354">        writer.write(&quot;\&quot;&quot;);</span>
<span class="nc" id="L355">        writer.write(cleanJSON(((Enum) value).name()));</span>
<span class="nc" id="L356">        writer.write(&quot;\&quot;&quot;);</span>
<span class="pc bpc" id="L357" title="1 of 2 branches missed.">      } else if (value instanceof Pair) {</span>
<span class="nc" id="L358">        routeObject(indent, Arrays.asList(((Pair) value).first, ((Pair) value).second));</span>
<span class="pc bpc" id="L359" title="1 of 2 branches missed.">      } else if (value instanceof Span) {</span>
<span class="nc" id="L360">        writer.write(&quot;[&quot;);</span>
<span class="nc" id="L361">        writer.write(Integer.toString(((Span) value).start()));</span>
<span class="nc" id="L362">        writer.write(&quot;,&quot;); space();</span>
<span class="nc" id="L363">        writer.write(Integer.toString(((Span) value).end()));</span>
<span class="nc" id="L364">        writer.write(&quot;]&quot;);</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">      } else if (value instanceof Consumer) {</span>
<span class="fc" id="L366">        object(indent, (Consumer&lt;Writer&gt;) value);</span>
<span class="fc bfc" id="L367" title="All 2 branches covered.">      } else if (value instanceof Stream) {</span>
<span class="fc" id="L368">        routeObject(indent, ((Stream) value).collect(Collectors.toList()));</span>
<span class="pc bpc" id="L369" title="1 of 2 branches missed.">      } else if (value.getClass().isArray()) {</span>
        // Arrays make life miserable in Java
<span class="nc" id="L371">        Class&lt;?&gt; componentType = value.getClass().getComponentType();</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">        if (componentType.isPrimitive()) {</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">          if (int.class.isAssignableFrom(componentType)) {</span>
<span class="nc" id="L374">            ArrayList&lt;Integer&gt; lst = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">            for (int elem : ((int[]) value)) {</span>
<span class="nc" id="L376">              lst.add(elem);</span>
            }
<span class="nc" id="L378">            routeObject(indent, lst);</span>
<span class="nc bnc" id="L379" title="All 2 branches missed.">          } else if (short.class.isAssignableFrom(componentType)) {</span>
<span class="nc" id="L380">            ArrayList&lt;Short&gt; lst = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">            for (short elem : ((short[]) value)) {</span>
<span class="nc" id="L382">              lst.add(elem);</span>
            }
<span class="nc" id="L384">            routeObject(indent, lst);</span>
<span class="nc bnc" id="L385" title="All 2 branches missed.">          } else if (byte.class.isAssignableFrom(componentType)) {</span>
<span class="nc" id="L386">            ArrayList&lt;Byte&gt; lst = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">            for (byte elem : ((byte[]) value)) {</span>
<span class="nc" id="L388">              lst.add(elem);</span>
            }
<span class="nc" id="L390">            routeObject(indent, lst);</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">          } else if (long.class.isAssignableFrom(componentType)) {</span>
<span class="nc" id="L392">            ArrayList&lt;Long&gt; lst = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">            for (long elem : ((long[]) value)) {</span>
<span class="nc" id="L394">              lst.add(elem);</span>
            }
<span class="nc" id="L396">            routeObject(indent, lst);</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">          } else if (char.class.isAssignableFrom(componentType)) {</span>
<span class="nc" id="L398">            ArrayList&lt;Character&gt; lst = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">            for (char elem : ((char[]) value)) {</span>
<span class="nc" id="L400">              lst.add(elem);</span>
            }
<span class="nc" id="L402">            routeObject(indent, lst);</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">          } else if (float.class.isAssignableFrom(componentType)) {</span>
<span class="nc" id="L404">            ArrayList&lt;Float&gt; lst = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">            for (float elem : ((float[]) value)) {</span>
<span class="nc" id="L406">              lst.add(elem);</span>
            }
<span class="nc" id="L408">            routeObject(indent, lst);</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">          } else if (double.class.isAssignableFrom(componentType)) {</span>
<span class="nc" id="L410">            ArrayList&lt;Double&gt; lst = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">            for (double elem : ((double[]) value)) {</span>
<span class="nc" id="L412">              lst.add(elem);</span>
            }
<span class="nc" id="L414">            routeObject(indent, lst);</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">          } else if (boolean.class.isAssignableFrom(componentType)) {</span>
<span class="nc" id="L416">            ArrayList&lt;Boolean&gt; lst = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">            for (boolean elem : ((boolean[]) value)) {</span>
<span class="nc" id="L418">              lst.add(elem);</span>
            }
<span class="nc" id="L420">            routeObject(indent, lst);</span>
<span class="nc" id="L421">          } else {</span>
<span class="nc" id="L422">            throw new IllegalStateException(&quot;Unhandled primitive type in array: &quot; + componentType);</span>
          }
        } else {
<span class="nc" id="L425">          routeObject(indent, Arrays.asList((Object[]) value));</span>
        }
<span class="pc bpc" id="L427" title="1 of 2 branches missed.">      } else if (value instanceof Integer) {</span>
<span class="fc" id="L428">        writer.write(Integer.toString((Integer) value));</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">      } else if (value instanceof Short) {</span>
<span class="nc" id="L430">        writer.write(Short.toString((Short) value));</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">      } else if (value instanceof Byte) {</span>
<span class="nc" id="L432">        writer.write(Byte.toString((Byte) value));</span>
<span class="nc bnc" id="L433" title="All 2 branches missed.">      } else if (value instanceof Long) {</span>
<span class="nc" id="L434">        writer.write(Long.toString((Long) value));</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">      } else if (value instanceof Character) {</span>
<span class="nc" id="L436">        writer.write(Character.toString((Character) value));</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">      } else if (value instanceof Float) {</span>
<span class="nc" id="L438">        writer.write(new DecimalFormat(&quot;0.#######&quot;).format(value));</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">      } else if (value instanceof Double) {</span>
<span class="nc" id="L440">        writer.write(new DecimalFormat(&quot;0.##############&quot;).format(value));</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">      } else if (value instanceof Boolean) {</span>
<span class="nc" id="L442">        writer.write(Boolean.toString((Boolean) value));</span>
<span class="nc bnc" id="L443" title="All 2 branches missed.">      } else if (int.class.isAssignableFrom(value.getClass())) {</span>
<span class="nc" id="L444">        routeObject(indent, Integer.valueOf((int) value));</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">      } else if (short.class.isAssignableFrom(value.getClass())) {</span>
<span class="nc" id="L446">        routeObject(indent, Short.valueOf((short) value));</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">      } else if (byte.class.isAssignableFrom(value.getClass())) {</span>
<span class="nc" id="L448">        routeObject(indent, Byte.valueOf((byte) value));</span>
<span class="nc bnc" id="L449" title="All 2 branches missed.">      } else if (long.class.isAssignableFrom(value.getClass())) {</span>
<span class="nc" id="L450">        routeObject(indent, Long.valueOf((long) value));</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">      } else if (char.class.isAssignableFrom(value.getClass())) {</span>
<span class="nc" id="L452">        routeObject(indent, Character.valueOf((char) value));</span>
<span class="nc bnc" id="L453" title="All 2 branches missed.">      } else if (float.class.isAssignableFrom(value.getClass())) {</span>
<span class="nc" id="L454">        routeObject(indent, Float.valueOf((float) value));</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">      } else if (double.class.isAssignableFrom(value.getClass())) {</span>
<span class="nc" id="L456">        routeObject(indent, Double.valueOf((double) value));</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">      } else if (boolean.class.isAssignableFrom(value.getClass())) {</span>
<span class="nc" id="L458">        routeObject(indent, Boolean.valueOf((boolean) value));</span>
      } else {
<span class="nc" id="L460">        throw new RuntimeException(&quot;Unknown object to serialize: &quot; + value);</span>
      }
<span class="fc" id="L462">    }</span>

    public void object(int indent, Consumer&lt;Writer&gt; callback) {
<span class="fc" id="L465">      writer.write(&quot;{&quot;);</span>
<span class="fc" id="L466">      final Pointer&lt;Boolean&gt; firstCall = new Pointer&lt;&gt;(true);</span>
<span class="fc" id="L467">      callback.accept((key, value) -&gt; {</span>
<span class="pc bpc" id="L468" title="1 of 4 branches missed.">        if (key != null &amp;&amp; value != null) {</span>
          // First call overhead
<span class="fc bfc" id="L470" title="All 2 branches covered.">          if (!firstCall.dereference().orElse(false)) {</span>
<span class="fc" id="L471">            writer.write(&quot;,&quot;);</span>
          }
<span class="fc" id="L473">          firstCall.set(false);</span>
          // Write the key
<span class="fc" id="L475">          newline();</span>
<span class="fc" id="L476">          indent(indent + 1);</span>
<span class="fc" id="L477">          writer.write(&quot;\&quot;&quot;);</span>
<span class="fc" id="L478">          writer.write(cleanJSON(key));</span>
<span class="fc" id="L479">          writer.write(&quot;\&quot;:&quot;); space();</span>
          // Write the value
<span class="fc" id="L481">          routeObject(indent + 1, value);</span>
        }
<span class="fc" id="L483">      });</span>
<span class="fc" id="L484">      newline(); indent(indent); writer.write(&quot;}&quot;);</span>
<span class="fc" id="L485">    }</span>

    public void object(Consumer&lt;Writer&gt; callback) {
<span class="fc" id="L488">      object(0, callback);</span>
<span class="fc" id="L489">    }</span>

    private void indent(int num) {
<span class="pc bpc" id="L492" title="1 of 2 branches missed.">      if (options.pretty) {</span>
<span class="fc bfc" id="L493" title="All 2 branches covered.">        for (int i = 0; i &lt; num; ++i) {</span>
<span class="fc" id="L494">          writer.write(INDENT_CHAR);</span>
        }
      }
<span class="fc" id="L497">    }</span>

    private void space() {
<span class="pc bpc" id="L500" title="1 of 2 branches missed.">      if (options.pretty) {</span>
<span class="fc" id="L501">        writer.write(&quot; &quot;);</span>
      }
<span class="fc" id="L503">    }</span>

    private void newline() {
<span class="pc bpc" id="L506" title="1 of 2 branches missed.">      if (options.pretty) {</span>
<span class="fc" id="L507">        writer.write(&quot;\n&quot;);</span>
      }
<span class="fc" id="L509">    }</span>

    public static String objectToJSON(Consumer&lt;Writer&gt; callback) {
<span class="fc" id="L512">      OutputStream os = new ByteArrayOutputStream();</span>
<span class="fc" id="L513">      PrintWriter out = new PrintWriter(os);</span>
<span class="fc" id="L514">      new JSONWriter(out, new Options()).object(callback);</span>
<span class="fc" id="L515">      out.close();</span>
<span class="fc" id="L516">      return os.toString();</span>
    }
  }

  /**
   * A tiny little functional interface for writing a (key, value) pair.
   * The key should always be a String, the value can be either a String,
   * a Collection of valid values, or a Callback taking a Writer (this is how
   * we represent objects while creating JSON).
   */
<span class="fc" id="L526">  @FunctionalInterface</span>
  protected interface Writer {
    /**
     * Set a (key, value) pair in a JSON object.
     * Note that if either the key or the value is null, nothing will be set.
     * @param key The key of the object.
     * @param value The value of the object.
     */
    void set(String key, Object value);
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>