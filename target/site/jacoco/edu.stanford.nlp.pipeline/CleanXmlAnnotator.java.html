<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CleanXmlAnnotator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.pipeline</a> &gt; <span class="el_source">CleanXmlAnnotator.java</span></div><h1>CleanXmlAnnotator.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.pipeline;

import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import edu.stanford.nlp.ling.CoreAnnotation;
import edu.stanford.nlp.ling.CoreAnnotations;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.ling.MultiTokenTag;
import edu.stanford.nlp.ling.tokensregex.EnvLookup;
import edu.stanford.nlp.util.*;


/**
 * An annotator which removes all XML tags (as identified by the
 * tokenizer) and possibly selectively keeps the text between them.
 * Can also add sentence-ending markers depending on the XML tag.
 * Note that the removal of tags is done by a finite state tokenizer.
 * Thus, this works for simple, typical XML, or equally for similar
 * SGML or XML tags, but will not work on arbitrarily complicated XML.
 *
 * @author John Bauer
 * @author Angel Chang
 */
public class CleanXmlAnnotator implements Annotator {

  /**
   * A regular expression telling us where to look for tokens
   * we care about
   */
  private final Pattern xmlTagMatcher;

  public static final String DEFAULT_XML_TAGS = &quot;.*&quot;;

  /**
   * This regular expression tells us which tags end a sentence...
   * for example, {@code &lt;p&gt;} would be a great candidate.
   */
  private final Pattern sentenceEndingTagMatcher;

  public static final String DEFAULT_SENTENCE_ENDERS = &quot;&quot;;

  /**
   * This tells us what tags denote single sentences (tokens inside should not be sentence split on)
   */
<span class="fc" id="L47">  private Pattern singleSentenceTagMatcher = null;</span>

<span class="fc" id="L49">  public static final String DEFAULT_SINGLE_SENTENCE_TAGS = null;</span>

  /**
   * This tells us which XML tags wrap document date.
   */
  private final Pattern dateTagMatcher;

  public static final String DEFAULT_DATE_TAGS = &quot;datetime|date&quot;;

  /**
   * This tells us which XML tags wrap document id
   */
  private Pattern docIdTagMatcher;

  public static final String DEFAULT_DOCID_TAGS = &quot;docid&quot;;

  /**
   * This tells us which XML tags wrap document type
   */
  private Pattern docTypeTagMatcher;

  public static final String DEFAULT_DOCTYPE_TAGS = &quot;doctype&quot;;

  /**
   * This tells us when an utterance turn starts
   * (used in dcoref)
   */
<span class="fc" id="L76">  private Pattern utteranceTurnTagMatcher = null;</span>

  public static final String DEFAULT_UTTERANCE_TURN_TAGS = &quot;turn&quot;;

  /**
   * This tells us what the speaker tag is
   * (used in dcoref)
   */
<span class="fc" id="L84">  private Pattern speakerTagMatcher = null;</span>

  public static final String DEFAULT_SPEAKER_TAGS = &quot;speaker&quot;;

  /**
   * A map of document level annotation keys (i.e. docid) along with a pattern
   *  indicating the tag to match, and the attribute to match.
   */
<span class="fc" id="L92">  private final CollectionValuedMap&lt;Class, Pair&lt;Pattern,Pattern&gt;&gt; docAnnotationPatterns = new CollectionValuedMap&lt;&gt;();</span>
  public static final String DEFAULT_DOC_ANNOTATIONS_PATTERNS = &quot;docID=doc[id],doctype=doc[type],docsourcetype=doctype[source]&quot;;

  /**
   * A map of token level annotation keys (i.e. link, speaker) along with a pattern
   *  indicating the tag/attribute to match (tokens that belong to the text enclosed in the specified tag will be annotated).
   */
<span class="fc" id="L99">  private final CollectionValuedMap&lt;Class, Pair&lt;Pattern,Pattern&gt;&gt; tokenAnnotationPatterns = new CollectionValuedMap&lt;&gt;();</span>
<span class="fc" id="L100">  public static final String DEFAULT_TOKEN_ANNOTATIONS_PATTERNS = null;</span>

  /**
   * This tells us what the section tag is
   */
<span class="fc" id="L105">  private Pattern sectionTagMatcher = null;</span>
<span class="fc" id="L106">  public static final String DEFAULT_SECTION_TAGS = null;</span>

  /**
   * This tells us what tokens will be discarded by ssplit
   */
<span class="fc" id="L111">  private Pattern ssplitDiscardTokensMatcher = null;</span>

  /**
   * A map of section level annotation keys (i.e. docid) along with a pattern
   *  indicating the tag to match, and the attribute to match.
   */
<span class="fc" id="L117">  private final CollectionValuedMap&lt;Class, Pair&lt;Pattern,Pattern&gt;&gt; sectionAnnotationPatterns = new CollectionValuedMap&lt;&gt;();</span>
<span class="fc" id="L118">  public static final String DEFAULT_SECTION_ANNOTATIONS_PATTERNS = null;</span>

  /**
   * This setting allows handling of flawed XML.  For example,
   * a lot of the news articles we parse go: &lt;br&gt;
   *  &amp;lt;text&amp;gt; &lt;br&gt;
   *  &amp;lt;turn&amp;gt; &lt;br&gt;
   *  &amp;lt;turn&amp;gt; &lt;br&gt;
   *  &amp;lt;turn&amp;gt; &lt;br&gt;
   *  &amp;lt;/text&amp;gt; &lt;br&gt;
   * ... eg, no closing &amp;lt;/turn&amp;gt; tags.
   */
  private final boolean allowFlawedXml;

  public static final boolean DEFAULT_ALLOW_FLAWS = true;

  public CleanXmlAnnotator() {
<span class="nc" id="L135">    this(DEFAULT_XML_TAGS, DEFAULT_SENTENCE_ENDERS, DEFAULT_DATE_TAGS, DEFAULT_ALLOW_FLAWS);</span>
<span class="nc" id="L136">  }</span>

  public CleanXmlAnnotator(String xmlTagsToRemove,
                           String sentenceEndingTags,
                           String dateTags,
<span class="fc" id="L141">                           boolean allowFlawedXml) {</span>
<span class="fc" id="L142">    this.allowFlawedXml = allowFlawedXml;</span>
<span class="pc bpc" id="L143" title="1 of 2 branches missed.">    if (xmlTagsToRemove != null) {</span>
<span class="fc" id="L144">      xmlTagMatcher = toCaseInsensitivePattern(xmlTagsToRemove);</span>
<span class="pc bpc" id="L145" title="1 of 2 branches missed.">      if (sentenceEndingTags != null &amp;&amp;</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">          sentenceEndingTags.length() &gt; 0) {</span>
<span class="fc" id="L147">        sentenceEndingTagMatcher = toCaseInsensitivePattern(sentenceEndingTags);</span>
      } else {
<span class="fc" id="L149">        sentenceEndingTagMatcher = null;</span>
      }
    } else {
<span class="nc" id="L152">      xmlTagMatcher = null;</span>
<span class="nc" id="L153">      sentenceEndingTagMatcher = null;</span>
    }

<span class="fc" id="L156">    dateTagMatcher = toCaseInsensitivePattern(dateTags);</span>
<span class="fc" id="L157">  }</span>

  private static Pattern toCaseInsensitivePattern(String tags) {
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">    if (tags != null) {</span>
<span class="fc" id="L161">      return Pattern.compile(tags, Pattern.CASE_INSENSITIVE);</span>
    } else {
<span class="nc" id="L163">      return null;</span>
    }
  }

  public void setSsplitDiscardTokensMatcher(String tags) {
<span class="nc" id="L168">    ssplitDiscardTokensMatcher = toCaseInsensitivePattern(tags);</span>
<span class="nc" id="L169">  }</span>

  public void setSingleSentenceTagMatcher(String tags) {
<span class="nc" id="L172">    singleSentenceTagMatcher = toCaseInsensitivePattern(tags);</span>
<span class="nc" id="L173">  }</span>

  public void setDocIdTagMatcher(String docIdTags) {
<span class="nc" id="L176">    docIdTagMatcher = toCaseInsensitivePattern(docIdTags);</span>
<span class="nc" id="L177">  }</span>

  public void setDocTypeTagMatcher(String docTypeTags) {
<span class="nc" id="L180">    docTypeTagMatcher = toCaseInsensitivePattern(docTypeTags);</span>
<span class="nc" id="L181">  }</span>

  public void setSectionTagMatcher(String sectionTags) {
<span class="nc" id="L184">    sectionTagMatcher = toCaseInsensitivePattern(sectionTags);</span>
<span class="nc" id="L185">  }</span>

  public void setDiscourseTags(String utteranceTurnTags, String speakerTags) {
<span class="nc" id="L188">    utteranceTurnTagMatcher = toCaseInsensitivePattern(utteranceTurnTags);</span>
<span class="nc" id="L189">    speakerTagMatcher = toCaseInsensitivePattern(speakerTags);</span>
<span class="nc" id="L190">  }</span>

  public void setDocAnnotationPatterns(String conf) {
<span class="nc" id="L193">    docAnnotationPatterns.clear();</span>
    // Patterns can only be tag attributes
<span class="nc" id="L195">    addAnnotationPatterns(docAnnotationPatterns, conf, true);</span>
<span class="nc" id="L196">  }</span>

  public void setTokenAnnotationPatterns(String conf) {
<span class="nc" id="L199">    tokenAnnotationPatterns.clear();</span>
    // Patterns can only be tag attributes
<span class="nc" id="L201">    addAnnotationPatterns(tokenAnnotationPatterns, conf, true);</span>
<span class="nc" id="L202">  }</span>

  public void setSectionAnnotationPatterns(String conf) {
<span class="nc" id="L205">    sectionAnnotationPatterns.clear();</span>
<span class="nc" id="L206">    addAnnotationPatterns(sectionAnnotationPatterns, conf, false);</span>
<span class="nc" id="L207">  }</span>

<span class="fc" id="L209">  private static final Pattern TAG_ATTR_PATTERN = Pattern.compile(&quot;(.*)\\[(.*)\\]&quot;);</span>
  private static void addAnnotationPatterns(CollectionValuedMap&lt;Class, Pair&lt;Pattern,Pattern&gt;&gt; annotationPatterns, String conf, boolean attrOnly) {
<span class="nc bnc" id="L211" title="All 2 branches missed.">    String[] annoPatternStrings = conf == null ? StringUtils.EMPTY_STRING_ARRAY : conf.trim().split(&quot;\\s*,\\s*&quot;);</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">    for (String annoPatternString:annoPatternStrings) {</span>
<span class="nc" id="L213">      String[] annoPattern = annoPatternString.split(&quot;\\s*=\\s*&quot;, 2);</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">      if (annoPattern.length != 2) {</span>
<span class="nc" id="L215">        throw new IllegalArgumentException(&quot;Invalid annotation to tag pattern: &quot; + annoPatternString);</span>
      }
<span class="nc" id="L217">      String annoKeyString = annoPattern[0];</span>
<span class="nc" id="L218">      String pattern = annoPattern[1];</span>
<span class="nc" id="L219">      Class annoKey = EnvLookup.lookupAnnotationKeyWithClassname(null, annoKeyString);</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">      if (annoKey == null) {</span>
<span class="nc" id="L221">        throw new IllegalArgumentException(&quot;Cannot resolve annotation key &quot; + annoKeyString);</span>
      }
<span class="nc" id="L223">      Matcher m = TAG_ATTR_PATTERN.matcher(pattern);</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">      if (m.matches()) {</span>
<span class="nc" id="L225">        Pattern tagPattern = toCaseInsensitivePattern(m.group(1));</span>
<span class="nc" id="L226">        Pattern attrPattern = toCaseInsensitivePattern(m.group(2));</span>
<span class="nc" id="L227">        annotationPatterns.add(annoKey, Pair.makePair(tagPattern, attrPattern));</span>
<span class="nc" id="L228">      } else {</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">        if (attrOnly) {</span>
          // attribute is require
<span class="nc" id="L231">          throw new IllegalArgumentException(&quot;Invalid tag pattern: &quot; + pattern + &quot; for annotation key &quot; + annoKeyString);</span>
        } else {
<span class="nc" id="L233">          Pattern tagPattern = toCaseInsensitivePattern(pattern);</span>
<span class="nc" id="L234">          annotationPatterns.add(annoKey, Pair.makePair(tagPattern, (Pattern) null));</span>
        }
      }
    }
<span class="nc" id="L238">  }</span>

  @Override
  public void annotate(Annotation annotation) {
<span class="pc bpc" id="L242" title="1 of 2 branches missed.">    if (annotation.containsKey(CoreAnnotations.TokensAnnotation.class)) {</span>
<span class="fc" id="L243">      List&lt;CoreLabel&gt; tokens = annotation.get(CoreAnnotations.TokensAnnotation.class);</span>
<span class="fc" id="L244">      List&lt;CoreLabel&gt; newTokens = process(annotation, tokens);</span>
      // We assume that if someone is using this annotator, they don't
      // want the old tokens any more and get rid of them
<span class="fc" id="L247">      annotation.set(CoreAnnotations.TokensAnnotation.class, newTokens);</span>
    }
<span class="fc" id="L249">  }</span>

  public List&lt;CoreLabel&gt; process(List&lt;CoreLabel&gt; tokens) {
<span class="nc" id="L252">    return process(null, tokens);</span>
  }

  private static String tokensToString(Annotation annotation, List&lt;CoreLabel&gt; tokens) {
<span class="nc bnc" id="L256" title="All 2 branches missed.">    if (tokens.isEmpty()) return &quot;&quot;;</span>
    // Try to get original text back?
<span class="nc bnc" id="L258" title="All 2 branches missed.">    String annotationText = (annotation != null)? annotation.get(CoreAnnotations.TextAnnotation.class) : null;</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">    if (annotationText != null) {</span>
<span class="nc" id="L260">      CoreLabel firstToken = tokens.get(0);</span>
<span class="nc" id="L261">      CoreLabel lastToken = tokens.get(tokens.size() - 1);</span>
<span class="nc" id="L262">      int firstCharOffset = firstToken.get(CoreAnnotations.CharacterOffsetBeginAnnotation.class);</span>
<span class="nc" id="L263">      int lastCharOffset = lastToken.get(CoreAnnotations.CharacterOffsetEndAnnotation.class);</span>
<span class="nc" id="L264">      return annotationText.substring(firstCharOffset, lastCharOffset);</span>
    } else {
<span class="nc" id="L266">      return StringUtils.joinWords(tokens, &quot; &quot;);</span>
    }
  }

  // Annotates CoreMap with information from xml tag

  /**
   * Updates a CoreMap with attributes (or text context) from a tag.
   *
   * @param annotation - Main document level annotation (from which the original text can be extracted)
   * @param cm - CoreMap to annotate
   * @param tag - tag to process
   * @param annotationPatterns - list of annotation patterns to match
   * @param savedTokens - tokens for annotations that are text context of a tag
   * @param toAnnotate - what keys to annotate
   * @return The set of annotations found
   */
  private static Set&lt;Class&gt; annotateWithTag(Annotation annotation,
                                     CoreMap cm,
                                     XMLUtils.XMLTag tag,
                                     CollectionValuedMap&lt;Class, Pair&lt;Pattern,Pattern&gt;&gt; annotationPatterns,
                                     Map&lt;Class, List&lt;CoreLabel&gt;&gt; savedTokens,
                                     Collection&lt;Class&gt; toAnnotate,
                                     Map&lt;Class, Stack&lt;Pair&lt;String, String&gt;&gt;&gt; savedTokenAnnotations) {
<span class="nc" id="L290">    Set&lt;Class&gt; foundAnnotations = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">    if (annotationPatterns == null) { return foundAnnotations; }</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">    if (toAnnotate == null) {</span>
<span class="nc" id="L293">      toAnnotate = annotationPatterns.keySet();</span>
    }
<span class="nc bnc" id="L295" title="All 2 branches missed.">    for (Class key:toAnnotate) {</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">      for (Pair&lt;Pattern,Pattern&gt; pattern: annotationPatterns.get(key)) {</span>
<span class="nc" id="L297">        Pattern tagPattern = pattern.first;</span>
<span class="nc" id="L298">        Pattern attrPattern = pattern.second;</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">        if (tagPattern.matcher(tag.name).matches()) {</span>
<span class="nc" id="L300">          boolean matched = false;</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">          if (attrPattern != null) {</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">            if (tag.attributes != null) {</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">              for (Map.Entry&lt;String,String&gt; entry:tag.attributes.entrySet()) {</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">                if (attrPattern.matcher(entry.getKey()).matches()) {</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">                  if (savedTokenAnnotations != null) {</span>
<span class="nc" id="L306">                    Stack&lt;Pair&lt;String, String&gt;&gt; stack = savedTokenAnnotations.get(key);</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">                    if (stack == null) {</span>
<span class="nc" id="L308">                      savedTokenAnnotations.put(key, stack = new Stack&lt;&gt;());</span>
                    }
<span class="nc" id="L310">                    stack.push(Pair.makePair(tag.name, entry.getValue()));</span>
                  }
<span class="nc" id="L312">                  cm.set(key, entry.getValue());</span>
<span class="nc" id="L313">                  foundAnnotations.add(key);</span>
<span class="nc" id="L314">                  matched = true;</span>
<span class="nc" id="L315">                  break;</span>
                }
<span class="nc" id="L317">              }</span>
            }
<span class="nc bnc" id="L319" title="All 2 branches missed.">            if (savedTokenAnnotations != null) {</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">              if (tag.isEndTag) {</span>
                // tag ended - clear this annotation
<span class="nc" id="L322">                Stack&lt;Pair&lt;String, String&gt;&gt; stack = savedTokenAnnotations.get(key);</span>
<span class="nc bnc" id="L323" title="All 4 branches missed.">                if (stack != null &amp;&amp; !stack.isEmpty()) {</span>
<span class="nc" id="L324">                  Pair&lt;String,String&gt; p = stack.peek();</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">                  if (p.first.equalsIgnoreCase(tag.name)) {</span>
<span class="nc" id="L326">                    stack.pop();</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">                    if (!stack.isEmpty()) {</span>
<span class="nc" id="L328">                      cm.set(key, stack.peek().second);</span>
                    } else {
<span class="nc" id="L330">                      cm.remove(key);</span>
                    }
                  }
                }
<span class="nc" id="L334">              }</span>
            }
<span class="nc bnc" id="L336" title="All 2 branches missed.">          } else if (savedTokens != null) {</span>
<span class="nc bnc" id="L337" title="All 4 branches missed.">            if (tag.isEndTag &amp;&amp; !tag.isSingleTag) {</span>
              // End tag - annotate using saved tokens
<span class="nc" id="L339">              List&lt;CoreLabel&gt; saved = savedTokens.remove(key);</span>
<span class="nc bnc" id="L340" title="All 4 branches missed.">              if (saved != null &amp;&amp; saved.size() &gt; 0) {</span>
<span class="nc" id="L341">                cm.set(key, tokensToString(annotation, saved));</span>
<span class="nc" id="L342">                foundAnnotations.add(key);</span>
<span class="nc" id="L343">                matched = true;</span>
              }
<span class="nc" id="L345">            } else {</span>
              // Start tag
<span class="nc" id="L347">              savedTokens.put(key, new ArrayList&lt;&gt;());</span>
            }
          }
<span class="nc bnc" id="L350" title="All 2 branches missed.">          if (matched) break;</span>
        }
<span class="nc" id="L352">      }</span>
<span class="nc" id="L353">    }</span>
<span class="nc" id="L354">    return foundAnnotations;</span>
  }

  public List&lt;CoreLabel&gt; process(Annotation annotation, List&lt;CoreLabel&gt; tokens) {
    // As we are processing, this stack keeps track of which tags we
    // are currently inside
<span class="fc" id="L360">    Stack&lt;String&gt; enclosingTags = new Stack&lt;&gt;();</span>
    // here we keep track of the current enclosingTags
    // this lets multiple tokens reuse the same tag stack
<span class="fc" id="L363">    List&lt;String&gt; currentTagSet = null;</span>
    // How many matching tags we've seen
<span class="fc" id="L365">    int matchDepth = 0;</span>
    // stores the filtered tags as we go
<span class="fc" id="L367">    List&lt;CoreLabel&gt; newTokens = new ArrayList&lt;&gt;();</span>

    // we use this to store the before &amp; after annotations if the
    // tokens were tokenized for &quot;invertible&quot;
<span class="fc" id="L371">    StringBuilder removedText = new StringBuilder();</span>
    // we keep track of this so we can look at the last tag after
    // we're outside the loop

    // Keeps track of what we still need to doc level annotations
    // we still need to look for
<span class="fc" id="L377">    Set&lt;Class&gt; toAnnotate = new HashSet&lt;&gt;(docAnnotationPatterns.keySet());</span>

<span class="fc" id="L379">    int utteranceIndex = 0;</span>
<span class="fc" id="L380">    boolean inUtterance = false;</span>
<span class="fc" id="L381">    boolean inSpeakerTag = false;</span>
<span class="fc" id="L382">    String currentSpeaker = null;</span>
<span class="fc" id="L383">    List&lt;CoreLabel&gt; speakerTokens = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L384">    List&lt;CoreLabel&gt; docDateTokens = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L385">    List&lt;CoreLabel&gt; docTypeTokens = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L386">    List&lt;CoreLabel&gt; docIdTokens = new ArrayList&lt;&gt;();</span>

    // Local variables for additional per token annotations
<span class="pc bpc" id="L389" title="2 of 4 branches missed.">    CoreMap tokenAnnotations = (tokenAnnotationPatterns != null &amp;&amp; !tokenAnnotationPatterns.isEmpty())? new ArrayCoreMap():null;</span>
<span class="fc" id="L390">    Map&lt;Class, Stack&lt;Pair&lt;String, String&gt;&gt;&gt; savedTokenAnnotations = new ArrayMap&lt;&gt;();</span>

    // Local variable for annotating sections
<span class="fc" id="L393">    XMLUtils.XMLTag sectionStartTag = null;</span>
<span class="fc" id="L394">    CoreLabel sectionStartToken = null;</span>
<span class="fc" id="L395">    CoreMap sectionAnnotations = null;</span>
<span class="fc" id="L396">    Map&lt;Class, List&lt;CoreLabel&gt;&gt; savedTokensForSection = new HashMap&lt;&gt;();</span>

<span class="fc" id="L398">    boolean markSingleSentence = false;</span>
<span class="fc bfc" id="L399" title="All 2 branches covered.">    for (CoreLabel token : tokens) {</span>
<span class="fc" id="L400">      String word = token.word().trim();</span>
<span class="fc" id="L401">      XMLUtils.XMLTag tag = XMLUtils.parseTag(word);</span>

      // If it's not a tag, we do manipulations such as unescaping
<span class="fc bfc" id="L404" title="All 2 branches covered.">      if (tag == null) {</span>
        // TODO: put this into the lexer instead of here
<span class="fc" id="L406">        token.setWord(XMLUtils.unescapeStringForXML(token.word()));</span>
        // TODO: was there another annotation that also represents the word?
<span class="pc bpc" id="L408" title="1 of 4 branches missed.">        if (matchDepth &gt; 0 ||</span>
            xmlTagMatcher == null ||
<span class="fc bfc" id="L410" title="All 2 branches covered.">            xmlTagMatcher.matcher(&quot;&quot;).matches()) {</span>
<span class="fc" id="L411">          newTokens.add(token);</span>
<span class="pc bpc" id="L412" title="1 of 2 branches missed.">          if (inUtterance) {</span>
<span class="nc" id="L413">            token.set(CoreAnnotations.UtteranceAnnotation.class, utteranceIndex);</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">            if (currentSpeaker != null) token.set(CoreAnnotations.SpeakerAnnotation.class, currentSpeaker);</span>
          }
<span class="pc bpc" id="L416" title="1 of 2 branches missed.">          if (markSingleSentence) {</span>
<span class="nc" id="L417">            token.set(CoreAnnotations.ForcedSentenceUntilEndAnnotation.class, true);</span>
<span class="nc" id="L418">            markSingleSentence = false;</span>
          }
<span class="pc bpc" id="L420" title="1 of 2 branches missed.">          if (tokenAnnotations != null) {</span>
<span class="nc" id="L421">            ChunkAnnotationUtils.copyUnsetAnnotations(tokenAnnotations, token);</span>
          }
        }
        // if we removed any text, and the tokens are &quot;invertible&quot; and
        // therefore keep track of their before/after text, append
        // what we removed to the appropriate tokens
<span class="fc bfc" id="L427" title="All 2 branches covered.">        if (removedText.length() &gt; 0) {</span>
<span class="fc" id="L428">          boolean added = false;</span>
<span class="fc" id="L429">          String before = token.get(CoreAnnotations.BeforeAnnotation.class);</span>
<span class="pc bpc" id="L430" title="1 of 2 branches missed.">          if (before != null) {</span>
<span class="fc" id="L431">            token.set(CoreAnnotations.BeforeAnnotation.class, removedText + before);</span>
<span class="fc" id="L432">            added = true;</span>
          }
<span class="pc bpc" id="L434" title="1 of 4 branches missed.">          if (added &amp;&amp; newTokens.size() &gt; 1) {</span>
<span class="fc" id="L435">            CoreLabel previous = newTokens.get(newTokens.size() - 2);</span>
<span class="fc" id="L436">            String after = previous.get(CoreAnnotations.AfterAnnotation.class);</span>
<span class="pc bpc" id="L437" title="1 of 2 branches missed.">            if (after != null)</span>
<span class="fc" id="L438">              previous.set(CoreAnnotations.AfterAnnotation.class, after + removedText);</span>
            else
<span class="nc" id="L440">              previous.set(CoreAnnotations.AfterAnnotation.class, removedText.toString());</span>
          }
<span class="fc" id="L442">          removedText = new StringBuilder();</span>
        }
<span class="fc bfc" id="L444" title="All 2 branches covered.">        if (currentTagSet == null) {</span>
          // We wrap the list in an unmodifiable list because we reuse
          // the same list object many times.  We don't want to
          // let someone modify one list and screw up all the others.
<span class="fc" id="L448">          currentTagSet =</span>
<span class="fc" id="L449">            Collections.unmodifiableList(new ArrayList&lt;&gt;(enclosingTags));</span>
        }
<span class="fc" id="L451">        token.set(CoreAnnotations.XmlContextAnnotation.class, currentTagSet);</span>

        // is this token part of the doc date sequence?
<span class="pc bpc" id="L454" title="1 of 2 branches missed.">        if (dateTagMatcher != null &amp;&amp;</span>
<span class="fc bfc" id="L455" title="All 2 branches covered.">            currentTagSet.size() &gt; 0 &amp;&amp;</span>
<span class="pc bpc" id="L456" title="1 of 2 branches missed.">            dateTagMatcher.matcher(currentTagSet.get(currentTagSet.size() - 1)).matches()) {</span>
<span class="nc" id="L457">          docDateTokens.add(token);</span>
        }

<span class="pc bpc" id="L460" title="1 of 2 branches missed.">        if (docIdTagMatcher != null &amp;&amp;</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">                currentTagSet.size() &gt; 0 &amp;&amp;</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">                docIdTagMatcher.matcher(currentTagSet.get(currentTagSet.size() - 1)).matches()) {</span>
<span class="nc" id="L463">          docIdTokens.add(token);</span>
        }

<span class="pc bpc" id="L466" title="1 of 2 branches missed.">        if (docTypeTagMatcher != null &amp;&amp;</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">                currentTagSet.size() &gt; 0 &amp;&amp;</span>
<span class="nc bnc" id="L468" title="All 2 branches missed.">                docTypeTagMatcher.matcher(currentTagSet.get(currentTagSet.size() - 1)).matches()) {</span>
<span class="nc" id="L469">          docTypeTokens.add(token);</span>
        }

<span class="pc bpc" id="L472" title="1 of 2 branches missed.">        if (inSpeakerTag) {</span>
<span class="nc" id="L473">          speakerTokens.add(token);</span>
        }

<span class="pc bpc" id="L476" title="1 of 2 branches missed.">        if (sectionStartTag != null) {</span>
<span class="nc" id="L477">          boolean okay = true;</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">          if (ssplitDiscardTokensMatcher != null) {</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">            okay = !ssplitDiscardTokensMatcher.matcher(token.word()).matches();</span>
          }
<span class="nc bnc" id="L481" title="All 2 branches missed.">          if (okay) {</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">            if (sectionStartToken == null) {</span>
<span class="nc" id="L483">              sectionStartToken = token;</span>
            }
            // Add tokens to saved section tokens
<span class="nc bnc" id="L486" title="All 2 branches missed.">            for (List&lt;CoreLabel&gt; saved:savedTokensForSection.values()) {</span>
<span class="nc" id="L487">              saved.add(token);</span>
<span class="nc" id="L488">            }</span>
          }
<span class="nc" id="L490">        }</span>

        continue;
      }

      // At this point, we know we have a tag

      // we are removing a token and its associated text...
      // keep track of that
<span class="fc" id="L499">      String currentRemoval = token.get(CoreAnnotations.BeforeAnnotation.class);</span>
<span class="pc bpc" id="L500" title="1 of 2 branches missed.">      if (currentRemoval != null)</span>
<span class="fc" id="L501">        removedText.append(currentRemoval);</span>
<span class="fc" id="L502">      currentRemoval = token.get(CoreAnnotations.OriginalTextAnnotation.class);</span>
<span class="pc bpc" id="L503" title="1 of 2 branches missed.">      if (currentRemoval != null)</span>
<span class="fc" id="L504">        removedText.append(currentRemoval);</span>
<span class="fc bfc" id="L505" title="All 2 branches covered.">      if (token == tokens.get(tokens.size() - 1)) {</span>
<span class="fc" id="L506">        currentRemoval = token.get(CoreAnnotations.AfterAnnotation.class);</span>
<span class="pc bpc" id="L507" title="1 of 2 branches missed.">        if (currentRemoval != null)</span>
<span class="fc" id="L508">          removedText.append(currentRemoval);</span>
      }

      // Process tag

      // Check if we want to annotate anything using the tags's attributes
<span class="pc bpc" id="L514" title="3 of 4 branches missed.">      if (!toAnnotate.isEmpty() &amp;&amp; tag.attributes != null) {</span>
<span class="nc" id="L515">        Set&lt;Class&gt; foundAnnotations = annotateWithTag(annotation, annotation, tag, docAnnotationPatterns, null, toAnnotate, null);</span>
<span class="nc" id="L516">        toAnnotate.removeAll(foundAnnotations);</span>
      }

      // Check if the tag matches a section
<span class="pc bpc" id="L520" title="3 of 4 branches missed.">      if (sectionTagMatcher != null &amp;&amp; sectionTagMatcher.matcher(tag.name).matches()) {</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">        if (tag.isEndTag) {</span>
<span class="nc" id="L522">          annotateWithTag(annotation, sectionAnnotations, tag, sectionAnnotationPatterns, savedTokensForSection, null, null);</span>
<span class="nc bnc" id="L523" title="All 2 branches missed.">          if (sectionStartToken != null) {</span>
<span class="nc" id="L524">            sectionStartToken.set(CoreAnnotations.SectionStartAnnotation.class, sectionAnnotations);</span>
          }
          // Mark previous token as forcing sentence and section end
<span class="nc bnc" id="L527" title="All 2 branches missed.">          if (newTokens.size() &gt; 0) {</span>
<span class="nc" id="L528">            CoreLabel previous = newTokens.get(newTokens.size() - 1);</span>
<span class="nc" id="L529">            previous.set(CoreAnnotations.ForcedSentenceEndAnnotation.class, true);</span>
<span class="nc" id="L530">            previous.set(CoreAnnotations.SectionEndAnnotation.class, sectionStartTag.name);</span>
          }
<span class="nc" id="L532">          savedTokensForSection.clear();</span>
<span class="nc" id="L533">          sectionStartTag = null;</span>
<span class="nc" id="L534">          sectionStartToken = null;</span>
<span class="nc" id="L535">          sectionAnnotations = null;</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">        } else if (!tag.isSingleTag) {</span>
          // Prepare to mark first token with section information
<span class="nc" id="L538">          sectionStartTag = tag;</span>
<span class="nc" id="L539">          sectionAnnotations = new ArrayCoreMap();</span>
<span class="nc" id="L540">          sectionAnnotations.set(CoreAnnotations.SectionAnnotation.class, sectionStartTag.name);</span>
        }
      }
<span class="pc bpc" id="L543" title="1 of 2 branches missed.">      if (sectionStartTag != null) {</span>
        // store away annotations for section
<span class="nc" id="L545">        annotateWithTag(annotation, sectionAnnotations, tag, sectionAnnotationPatterns, savedTokensForSection, null, null);</span>
      }
<span class="pc bpc" id="L547" title="1 of 2 branches missed.">      if (tokenAnnotations != null) {</span>
<span class="nc" id="L548">        annotateWithTag(annotation, tokenAnnotations, tag, tokenAnnotationPatterns, null, null, savedTokenAnnotations);</span>
      }

      // If the tag matches the sentence ending tags, and we have some
      // existing words, mark that word as being somewhere we want
      // to end the sentence.
<span class="fc bfc" id="L554" title="All 2 branches covered.">      if (sentenceEndingTagMatcher != null &amp;&amp;</span>
<span class="fc bfc" id="L555" title="All 2 branches covered.">          sentenceEndingTagMatcher.matcher(tag.name).matches() &amp;&amp;</span>
<span class="fc bfc" id="L556" title="All 2 branches covered.">          newTokens.size() &gt; 0) {</span>
<span class="fc" id="L557">        CoreLabel previous = newTokens.get(newTokens.size() - 1);</span>
<span class="fc" id="L558">        previous.set(CoreAnnotations.ForcedSentenceEndAnnotation.class, true);</span>
      }

<span class="pc bpc" id="L561" title="3 of 4 branches missed.">      if (utteranceTurnTagMatcher != null &amp;&amp; utteranceTurnTagMatcher.matcher(tag.name).matches()) {</span>
<span class="nc bnc" id="L562" title="All 2 branches missed.">        if (newTokens.size() &gt; 0) {</span>
          // Utterance turn is also sentence ending
<span class="nc" id="L564">          CoreLabel previous = newTokens.get(newTokens.size() - 1);</span>
<span class="nc" id="L565">          previous.set(CoreAnnotations.ForcedSentenceEndAnnotation.class, true);</span>
        }
<span class="nc bnc" id="L567" title="All 4 branches missed.">        inUtterance = !(tag.isEndTag || tag.isSingleTag);</span>
<span class="nc bnc" id="L568" title="All 2 branches missed.">        if (inUtterance) {</span>
<span class="nc" id="L569">          utteranceIndex++;</span>
        }
<span class="nc bnc" id="L571" title="All 2 branches missed.">        if (!inUtterance) {</span>
<span class="nc" id="L572">          currentSpeaker = null;</span>
        }
      }

<span class="pc bpc" id="L576" title="3 of 4 branches missed.">      if (speakerTagMatcher != null &amp;&amp; speakerTagMatcher.matcher(tag.name).matches()) {</span>
<span class="nc bnc" id="L577" title="All 2 branches missed.">        if (newTokens.size() &gt; 0) {</span>
          // Speaker is not really part of sentence
<span class="nc" id="L579">          CoreLabel previous = newTokens.get(newTokens.size() - 1);</span>
<span class="nc" id="L580">          previous.set(CoreAnnotations.ForcedSentenceEndAnnotation.class, true);</span>
        }
<span class="nc bnc" id="L582" title="All 4 branches missed.">        inSpeakerTag = !(tag.isEndTag || tag.isSingleTag);</span>
<span class="nc bnc" id="L583" title="All 2 branches missed.">        if (tag.isEndTag) {</span>
<span class="nc" id="L584">          currentSpeaker = tokensToString(annotation, speakerTokens);</span>
<span class="nc" id="L585">          MultiTokenTag.Tag mentionTag = new MultiTokenTag.Tag(currentSpeaker, &quot;Speaker&quot;, speakerTokens.size());</span>
<span class="nc" id="L586">          int i = 0;</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">          for (CoreLabel t:speakerTokens) {</span>
<span class="nc" id="L588">            t.set(CoreAnnotations.SpeakerAnnotation.class, currentSpeaker);</span>
<span class="nc" id="L589">            t.set(CoreAnnotations.MentionTokenAnnotation.class, new MultiTokenTag(mentionTag, i));</span>
<span class="nc" id="L590">            i++;</span>
<span class="nc" id="L591">          }</span>
<span class="nc" id="L592">        } else {</span>
<span class="nc" id="L593">          currentSpeaker = null;</span>
        }
<span class="nc" id="L595">        speakerTokens.clear();</span>
      }

<span class="pc bpc" id="L598" title="3 of 4 branches missed.">      if (singleSentenceTagMatcher != null &amp;&amp; singleSentenceTagMatcher.matcher(tag.name).matches()) {</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">        if (tag.isEndTag) {</span>
          // Mark previous token as forcing sentence end
<span class="nc bnc" id="L601" title="All 2 branches missed.">          if (newTokens.size() &gt; 0) {</span>
<span class="nc" id="L602">            CoreLabel previous = newTokens.get(newTokens.size() - 1);</span>
<span class="nc" id="L603">            previous.set(CoreAnnotations.ForcedSentenceEndAnnotation.class, true);</span>
          }
<span class="nc" id="L605">          markSingleSentence = false;</span>
<span class="nc bnc" id="L606" title="All 2 branches missed.">        } else if (!tag.isSingleTag) {</span>
          // Enforce rest of the tokens to be single token until ForceSentenceEnd is seen
<span class="nc" id="L608">          markSingleSentence = true;</span>
        }
      }

<span class="pc bpc" id="L612" title="1 of 2 branches missed.">      if (xmlTagMatcher == null)</span>
<span class="nc" id="L613">        continue;</span>

<span class="pc bpc" id="L615" title="1 of 2 branches missed.">      if (tag.isSingleTag) {</span>
<span class="nc" id="L616">        continue;</span>
      }
      // at this point, we can't reuse the &quot;currentTagSet&quot; vector
      // any more, since the current tag set has changed
<span class="fc" id="L620">      currentTagSet = null;</span>
<span class="fc bfc" id="L621" title="All 2 branches covered.">      if (tag.isEndTag) {</span>
        while (true) {
<span class="pc bpc" id="L623" title="1 of 2 branches missed.">          if (enclosingTags.isEmpty()) {</span>
<span class="nc" id="L624">            throw new IllegalArgumentException(&quot;Got a close tag &quot; + tag.name +</span>
                                               &quot; which does not match&quot; +
                                               &quot; any open tag&quot;);
          }
<span class="fc" id="L628">          String lastTag = enclosingTags.pop();</span>
<span class="fc bfc" id="L629" title="All 2 branches covered.">          if (xmlTagMatcher.matcher(lastTag).matches()){</span>
<span class="fc" id="L630">            --matchDepth;</span>
          }
<span class="fc bfc" id="L632" title="All 2 branches covered.">          if (lastTag.equals(tag.name))</span>
<span class="fc" id="L633">            break;</span>
<span class="fc bfc" id="L634" title="All 2 branches covered.">          if (!allowFlawedXml)</span>
<span class="fc" id="L635">            throw new IllegalArgumentException(&quot;Mismatched tags... &quot; +</span>
                                               tag.name + &quot; closed a &quot; +
                                               lastTag + &quot; tag.&quot;);
<span class="fc" id="L638">        }</span>
<span class="pc bpc" id="L639" title="1 of 2 branches missed.">        if (matchDepth &lt; 0) {</span>
          // this should be impossible, since we already assert that
          // the tags match up correctly
<span class="nc" id="L642">          throw new AssertionError(&quot;Programming error?  We think there &quot; +</span>
                                   &quot;have been more close tags than open tags&quot;);
        }
      } else {
        // open tag, since all other cases are exhausted
<span class="fc" id="L647">        enclosingTags.push(tag.name);</span>
<span class="fc bfc" id="L648" title="All 2 branches covered.">        if (xmlTagMatcher.matcher(tag.name).matches())</span>
<span class="fc" id="L649">          matchDepth++;</span>
      }
<span class="fc" id="L651">    }</span>

<span class="fc bfc" id="L653" title="All 4 branches covered.">    if (enclosingTags.size() &gt; 0 &amp;&amp; !allowFlawedXml) {</span>
<span class="fc" id="L654">      throw new IllegalArgumentException(&quot;Unclosed tags, starting with &quot; +</span>
<span class="fc" id="L655">                                         enclosingTags.pop());</span>
    }

    // If we ended with a string of xml tokens, that text needs to be
    // appended to the &quot;AfterAnnotation&quot; of one of the tokens...
    // Note that we clear removedText when we see a real token, so
    // if removedText is not empty, that must be because we just
    // dropped an xml tag.  Therefore we ignore that old After
    // annotation, since that text was already absorbed in the Before
    // annotation of the xml tag we threw away
<span class="pc bpc" id="L665" title="1 of 4 branches missed.">    if (newTokens.size() &gt; 0 &amp;&amp; removedText.length() &gt; 0) {</span>
<span class="fc" id="L666">      CoreLabel lastToken = newTokens.get(newTokens.size() - 1);</span>
      // sometimes AfterAnnotation seems to be null even when we are
      // collecting before &amp; after annotations, but OriginalTextAnnotation
      // is only non-null if we are invertible.  Hopefully.
<span class="pc bpc" id="L670" title="1 of 2 branches missed.">      if (lastToken.get(CoreAnnotations.OriginalTextAnnotation.class) != null) {</span>
<span class="fc" id="L671">        lastToken.set(CoreAnnotations.AfterAnnotation.class, removedText.toString());</span>
      }
    }

    // Populate docid, docdate, doctype
<span class="pc bpc" id="L676" title="1 of 2 branches missed.">    if (annotation != null) {</span>
<span class="pc bpc" id="L677" title="1 of 2 branches missed.">      if (!docIdTokens.isEmpty()) {</span>
<span class="nc" id="L678">        String str = tokensToString(annotation, docIdTokens).trim();</span>
<span class="nc" id="L679">        annotation.set(CoreAnnotations.DocIDAnnotation.class, str);</span>
      }
<span class="pc bpc" id="L681" title="1 of 2 branches missed.">      if (!docDateTokens.isEmpty()) {</span>
<span class="nc" id="L682">        String str = tokensToString(annotation, docDateTokens).trim();</span>
<span class="nc" id="L683">        annotation.set(CoreAnnotations.DocDateAnnotation.class, str);</span>
      }
<span class="pc bpc" id="L685" title="1 of 2 branches missed.">      if (!docTypeTokens.isEmpty()) {</span>
<span class="nc" id="L686">        String str = tokensToString(annotation, docTypeTokens).trim();</span>
<span class="nc" id="L687">        annotation.set(CoreAnnotations.DocTypeAnnotation.class, str);</span>
      }
    }

<span class="fc" id="L691">    return newTokens;</span>
  }

  @Override
  public Set&lt;Class&lt;? extends CoreAnnotation&gt;&gt; requires() {
<span class="nc" id="L696">    return Collections.singleton(CoreAnnotations.TokensAnnotation.class);</span>
  }

  @Override
  public Set&lt;Class&lt;? extends CoreAnnotation&gt;&gt; requirementsSatisfied() {
<span class="nc" id="L701">    return Collections.emptySet();</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>