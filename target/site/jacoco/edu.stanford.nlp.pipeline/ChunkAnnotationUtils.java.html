<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ChunkAnnotationUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.pipeline</a> &gt; <span class="el_source">ChunkAnnotationUtils.java</span></div><h1>ChunkAnnotationUtils.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.pipeline;

import edu.stanford.nlp.ling.AnnotationLookup;
import edu.stanford.nlp.ling.CoreAnnotations;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.process.CoreLabelTokenFactory;
import edu.stanford.nlp.process.CoreTokenFactory;
import edu.stanford.nlp.util.*;
import edu.stanford.nlp.util.logging.Redwood;

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Utility functions for annotating chunks
 *
 * @author Angel Chang
 */
<span class="pc bpc" id="L23" title="1 of 2 branches missed.">public class ChunkAnnotationUtils  {</span>

  /** A logger for this class */
<span class="fc" id="L26">  private static final Redwood.RedwoodChannels logger = Redwood.channels(ChunkAnnotationUtils.class);</span>
<span class="fc" id="L27">  private static final CoreLabelTokenFactory tokenFactory = new CoreLabelTokenFactory(true);</span>

<span class="nc" id="L29">  private ChunkAnnotationUtils() {} // static methods</span>

  /**
   * Checks if offsets of doc and sentence matches.
   * @param docAnnotation The document Annotation to analyze
   * @return true if the offsets match, false otherwise
   */
  public static boolean checkOffsets(CoreMap docAnnotation) {
<span class="nc" id="L37">    boolean okay = true;</span>
<span class="nc" id="L38">    String docText = docAnnotation.get(CoreAnnotations.TextAnnotation.class);</span>
<span class="nc" id="L39">    String docId = docAnnotation.get(CoreAnnotations.DocIDAnnotation.class);</span>
<span class="nc" id="L40">    List&lt;CoreLabel&gt; docTokens = docAnnotation.get(CoreAnnotations.TokensAnnotation.class);</span>
<span class="nc" id="L41">    List&lt;CoreMap&gt; sentences = docAnnotation.get(CoreAnnotations.SentencesAnnotation.class);</span>
<span class="nc bnc" id="L42" title="All 2 branches missed.">    for (CoreMap sentence:sentences) {</span>
<span class="nc" id="L43">      String sentText = sentence.get(CoreAnnotations.TextAnnotation.class);</span>
<span class="nc" id="L44">      List&lt;CoreLabel&gt; sentTokens = sentence.get(CoreAnnotations.TokensAnnotation.class);</span>
<span class="nc" id="L45">      int sentBeginChar = sentence.get(CoreAnnotations.CharacterOffsetBeginAnnotation.class);</span>
<span class="nc" id="L46">      int sentEndChar = sentence.get(CoreAnnotations.CharacterOffsetEndAnnotation.class);</span>
<span class="nc" id="L47">      int sentBeginToken = sentence.get(CoreAnnotations.TokenBeginAnnotation.class);</span>
<span class="nc" id="L48">      int sentEndToken = sentence.get(CoreAnnotations.TokenEndAnnotation.class);</span>
<span class="nc" id="L49">      String docTextSpan = docText.substring(sentBeginChar, sentEndChar);</span>
<span class="nc" id="L50">      List&lt;CoreLabel&gt; docTokenSpan = new ArrayList&lt;&gt;(docTokens.subList(sentBeginToken, sentEndToken));</span>
<span class="nc" id="L51">      logger.debug(&quot;Checking Document &quot; + docId + &quot; span (&quot; + sentBeginChar + &quot;,&quot; + sentEndChar + &quot;) &quot;);</span>
<span class="nc bnc" id="L52" title="All 2 branches missed.">      if (!docTextSpan.equals(sentText) ) {</span>
<span class="nc" id="L53">        okay = false;</span>
<span class="nc" id="L54">        logger.debug(&quot;WARNING: Document &quot; + docId + &quot; span does not match sentence&quot;);</span>
<span class="nc" id="L55">        logger.debug(&quot;DocSpanText: &quot; + docTextSpan);</span>
<span class="nc" id="L56">        logger.debug(&quot;SentenceText: &quot; + sentText);</span>
      }
<span class="nc" id="L58">      String sentTokenStr = getTokenText(sentTokens, CoreAnnotations.TextAnnotation.class);</span>
<span class="nc" id="L59">      String docTokenStr = getTokenText(docTokenSpan, CoreAnnotations.TextAnnotation.class);</span>
<span class="nc bnc" id="L60" title="All 2 branches missed.">      if (!docTokenStr.equals(sentTokenStr) ) {</span>
<span class="nc" id="L61">        okay = false;</span>
<span class="nc" id="L62">        logger.debug(&quot;WARNING: Document &quot; + docId + &quot; tokens does not match sentence&quot;);</span>
<span class="nc" id="L63">        logger.debug(&quot;DocSpanTokens: &quot; + docTokenStr);</span>
<span class="nc" id="L64">        logger.debug(&quot;SentenceTokens: &quot; + sentTokenStr);</span>
      }
<span class="nc" id="L66">    }</span>
<span class="nc" id="L67">    return okay;</span>
  }

  /**
   * Fix token offsets of sentences to match those in the document (assumes tokens are shared)
   * sentence token indices may not match document token list if certain html elements are ignored.
   * @param docAnnotation The document Annotation to analyze
   * @return true if fix was okay, false otherwise
   */
  public static boolean fixTokenOffsets(CoreMap docAnnotation) {
<span class="nc" id="L77">    List&lt;CoreLabel&gt; docTokens = docAnnotation.get(CoreAnnotations.TokensAnnotation.class);</span>
<span class="nc" id="L78">    List&lt;CoreMap&gt; sentences = docAnnotation.get(CoreAnnotations.SentencesAnnotation.class);</span>
<span class="nc" id="L79">    int i = 0;</span>
<span class="nc" id="L80">    CoreLabel curDocToken = docTokens.get(0);</span>
<span class="nc bnc" id="L81" title="All 2 branches missed.">    for (CoreMap sentence:sentences) {</span>
<span class="nc" id="L82">      List&lt;CoreLabel&gt; sentTokens = sentence.get(CoreAnnotations.TokensAnnotation.class);</span>
<span class="nc" id="L83">      CoreLabel sentTokenFirst = sentTokens.get(0);</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">      while (curDocToken != sentTokenFirst) {</span>
<span class="nc" id="L85">        i++;</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">        if (i &gt;= docTokens.size()) { return false; }</span>
<span class="nc" id="L87">        curDocToken = docTokens.get(i);</span>
      }
<span class="nc" id="L89">      int sentTokenBegin = i;</span>
<span class="nc" id="L90">      CoreLabel sentTokenLast = sentTokens.get(sentTokens.size()-1);</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">      while (curDocToken != sentTokenLast) {</span>
<span class="nc" id="L92">        i++;</span>
<span class="nc bnc" id="L93" title="All 2 branches missed.">        if (i &gt;= docTokens.size()) { return false; }</span>
<span class="nc" id="L94">        curDocToken = docTokens.get(i);</span>
      }
<span class="nc" id="L96">      int sentTokenEnd = i+1;</span>
<span class="nc" id="L97">      sentence.set(CoreAnnotations.TokenBeginAnnotation.class, sentTokenBegin);</span>
<span class="nc" id="L98">      sentence.set(CoreAnnotations.TokenEndAnnotation.class, sentTokenEnd);</span>
<span class="nc" id="L99">    }</span>
<span class="nc" id="L100">    return true;</span>
  }


  /**
   * Copies annotation over to this CoreMap if not already set.
   */
  public static void copyUnsetAnnotations(CoreMap src, CoreMap dest) {
<span class="nc bnc" id="L108" title="All 2 branches missed.">    for (Class key : src.keySet()) {</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">      if ( ! dest.containsKey(key)) {</span>
<span class="nc" id="L110">        dest.set(key, src.get(key));</span>
      }
<span class="nc" id="L112">    }</span>
<span class="nc" id="L113">  }</span>

  /**
   * Give an list of character offsets for chunk, fix tokenization so tokenization occurs at
   * boundary of chunks.
   * @param docAnnotation
   * @param chunkCharOffsets
   */
  public static boolean fixChunkTokenBoundaries(CoreMap docAnnotation, List&lt;IntPair&gt; chunkCharOffsets) {
    // First identify any tokens that need to be fixed
<span class="nc" id="L123">    String text = docAnnotation.get(CoreAnnotations.TextAnnotation.class);</span>
<span class="nc" id="L124">    List&lt;CoreLabel&gt; tokens = docAnnotation.get(CoreAnnotations.TokensAnnotation.class);</span>
<span class="nc" id="L125">    List&lt;CoreLabel&gt; output = new ArrayList&lt;&gt;(tokens.size());</span>
<span class="nc" id="L126">    int i = 0;</span>
<span class="nc" id="L127">    CoreLabel token = tokens.get(i);</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">    for (IntPair offsets:chunkCharOffsets) {</span>
<span class="nc bnc" id="L129" title="All 4 branches missed.">      assert(token.beginPosition() &gt;= 0);</span>
<span class="nc bnc" id="L130" title="All 4 branches missed.">      assert(token.endPosition() &gt;= 0);</span>
<span class="nc" id="L131">      int offsetBegin = offsets.getSource();</span>
<span class="nc" id="L132">      int offsetEnd = offsets.getTarget();</span>
      // Find tokens where token begins after chunk starts
      // and token ends after chunk starts
<span class="nc bnc" id="L135" title="All 2 branches missed.">      while (offsetBegin &lt; token.get(CoreAnnotations.CharacterOffsetBeginAnnotation.class)</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">              || offsetBegin &gt;= token.get(CoreAnnotations.CharacterOffsetEndAnnotation.class)) {</span>
<span class="nc" id="L137">        output.add(token);</span>
<span class="nc" id="L138">        i++;</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">        if (i &gt;= tokens.size()) { return false; }</span>
<span class="nc" id="L140">        token = tokens.get(i);</span>
      }
      // offsetBegin is now &gt;= token begin and &lt; token end
      // go until we find a token that starts after our chunk has ended
<span class="nc bnc" id="L144" title="All 2 branches missed.">      while (offsetEnd &gt; token.get(CoreAnnotations.CharacterOffsetBeginAnnotation.class)) {</span>
        // Check if chunk includes token
<span class="nc bnc" id="L146" title="All 2 branches missed.">        if (offsetBegin &gt; token.get(CoreAnnotations.CharacterOffsetBeginAnnotation.class)) {</span>
          // Chunk starts in the middle of the token
<span class="nc bnc" id="L148" title="All 2 branches missed.">          if (offsetEnd &lt; token.get(CoreAnnotations.CharacterOffsetEndAnnotation.class)) {</span>
<span class="nc" id="L149">            output.add(tokenFactory.makeToken(text.substring(token.beginPosition(), offsetBegin),</span>
<span class="nc" id="L150">                    token.beginPosition(), offsetBegin-token.beginPosition()));</span>
<span class="nc" id="L151">            output.add(tokenFactory.makeToken(text.substring(offsetBegin,offsetEnd),</span>
                    offsetBegin, offsetEnd-offsetBegin));
<span class="nc" id="L153">            output.add(tokenFactory.makeToken(text.substring(offsetEnd,token.endPosition()),</span>
<span class="nc" id="L154">                    offsetEnd, token.endPosition()-offsetEnd));</span>
          } else {
<span class="nc" id="L156">            output.add(tokenFactory.makeToken(text.substring(token.beginPosition(), offsetBegin),</span>
<span class="nc" id="L157">                    token.beginPosition(), offsetBegin-token.beginPosition()));</span>
<span class="nc" id="L158">            output.add(tokenFactory.makeToken(text.substring(offsetBegin,token.endPosition()),</span>
<span class="nc" id="L159">                    offsetBegin, token.endPosition()-offsetBegin));</span>
          }
<span class="nc bnc" id="L161" title="All 2 branches missed.">        } else if (offsetEnd &lt; token.get(CoreAnnotations.CharacterOffsetEndAnnotation.class)) {</span>
<span class="nc" id="L162">          output.add(tokenFactory.makeToken(text.substring(token.beginPosition(),offsetEnd),</span>
<span class="nc" id="L163">                  token.beginPosition(), offsetEnd-token.beginPosition()));</span>
<span class="nc" id="L164">          output.add(tokenFactory.makeToken(text.substring(offsetEnd,token.endPosition()), offsetEnd,</span>
<span class="nc" id="L165">                  token.endPosition()-offsetEnd));</span>
        } else {
          // success!  chunk contains token
<span class="nc" id="L168">          output.add(token);</span>
        }
<span class="nc" id="L170">        i++;</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">        if (i &gt;= tokens.size()) { return false; }</span>
<span class="nc" id="L172">        token = tokens.get(i);</span>
      }
<span class="nc" id="L174">    }</span>
    // Add rest of the tokens
<span class="nc bnc" id="L176" title="All 2 branches missed.">    for (; i &lt; tokens.size(); i++) {</span>
<span class="nc" id="L177">      token = tokens.get(i);</span>
<span class="nc" id="L178">      output.add(token);</span>
    }
<span class="nc" id="L180">    docAnnotation.set(CoreAnnotations.TokensAnnotation.class, output);</span>
<span class="nc" id="L181">    return true;</span>
  }

  /**
   * Create chunk that is merged from chunkIndexStart to chunkIndexEnd (exclusive).
   * @param chunkList - List of chunks
   * @param origText - Text from which to extract chunk text
   * @param chunkIndexStart - Index of first chunk to merge
   * @param chunkIndexEnd - Index of last chunk to merge (exclusive)
   * @param tokenFactory - factory for creating tokens (if we want to get a merged corelabel instead of something random)
   * @return new merged chunk
   */
  public static CoreMap getMergedChunk(List&lt;? extends CoreMap&gt; chunkList, String origText,
                                       int chunkIndexStart, int chunkIndexEnd, CoreLabelTokenFactory tokenFactory) {
<span class="fc" id="L195">    CoreMap firstChunk = chunkList.get(chunkIndexStart);</span>
<span class="fc" id="L196">    CoreMap lastChunk = chunkList.get(chunkIndexEnd-1);</span>
<span class="fc" id="L197">    int firstCharOffset = firstChunk.get(CoreAnnotations.CharacterOffsetBeginAnnotation.class);</span>
<span class="fc" id="L198">    int lastCharOffset = lastChunk.get(CoreAnnotations.CharacterOffsetEndAnnotation.class);</span>
<span class="fc" id="L199">    int firstTokenIndex = firstChunk.get(CoreAnnotations.TokenBeginAnnotation.class);</span>
<span class="fc" id="L200">    int lastTokenIndex = lastChunk.get(CoreAnnotations.TokenEndAnnotation.class);</span>

<span class="fc" id="L202">    String chunkText = origText.substring(firstCharOffset, lastCharOffset);</span>
    CoreMap newChunk;
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">    if (tokenFactory != null) {</span>
<span class="nc" id="L205">      newChunk = tokenFactory.makeToken(chunkText, firstCharOffset, lastCharOffset);</span>
    } else {
<span class="fc" id="L207">      newChunk = new Annotation(chunkText);</span>
    }

<span class="fc" id="L210">    newChunk.set(CoreAnnotations.CharacterOffsetBeginAnnotation.class, firstCharOffset);</span>
<span class="fc" id="L211">    newChunk.set(CoreAnnotations.CharacterOffsetEndAnnotation.class, lastCharOffset);</span>
<span class="fc" id="L212">    newChunk.set(CoreAnnotations.TokenBeginAnnotation.class, firstTokenIndex);</span>
<span class="fc" id="L213">    newChunk.set(CoreAnnotations.TokenEndAnnotation.class, lastTokenIndex);</span>
<span class="fc" id="L214">    List&lt;CoreLabel&gt; tokens = new ArrayList&lt;&gt;(lastTokenIndex - firstTokenIndex);</span>
<span class="fc bfc" id="L215" title="All 2 branches covered.">    for (int i = chunkIndexStart; i &lt; chunkIndexEnd; i++) {</span>
<span class="fc" id="L216">      CoreMap chunk = chunkList.get(i);</span>
<span class="fc" id="L217">      tokens.addAll(chunk.get(CoreAnnotations.TokensAnnotation.class));</span>
    }
<span class="fc" id="L219">    newChunk.set(CoreAnnotations.TokensAnnotation.class, tokens);</span>
    // TODO: merge other keys into this new chunk ??

<span class="fc" id="L222">    return newChunk;</span>
  }

  /**
   * Create chunk that is merged from chunkIndexStart to chunkIndexEnd (exclusive)
   * @param chunkList - List of chunks
   * @param chunkIndexStart - Index of first chunk to merge
   * @param chunkIndexEnd - Index of last chunk to merge (exclusive)
   * @param aggregators - Aggregators
   * @param tokenFactory - factory for creating tokens (if we want to get a merged corelabel instead of something random)
   * @return new merged chunk
   */
  public static CoreMap getMergedChunk(List&lt;? extends CoreMap&gt; chunkList,
                                       int chunkIndexStart, int chunkIndexEnd,
                                       Map&lt;Class, CoreMapAttributeAggregator&gt; aggregators,
                                       CoreLabelTokenFactory tokenFactory) {
    CoreMap newChunk;
<span class="nc bnc" id="L239" title="All 2 branches missed.">    if (tokenFactory != null) {</span>
<span class="nc" id="L240">      newChunk = tokenFactory.makeToken();</span>
    } else {
<span class="nc" id="L242">      newChunk = new Annotation(&quot;&quot;);</span>
    }
<span class="nc bnc" id="L244" title="All 2 branches missed.">    for (Map.Entry&lt;Class,CoreMapAttributeAggregator&gt; entry:aggregators.entrySet()) {</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">      if (chunkIndexEnd &gt; chunkList.size()) {</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">        assert(false);</span>
      }
<span class="nc" id="L248">      Object value = entry.getValue().aggregate(entry.getKey(), chunkList.subList(chunkIndexStart, chunkIndexEnd));</span>
<span class="nc" id="L249">      newChunk.set(entry.getKey(), value);</span>
<span class="nc" id="L250">    }</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">    if (newChunk instanceof CoreLabel) {</span>
<span class="nc" id="L252">      CoreLabel cl = (CoreLabel) newChunk;</span>
<span class="nc" id="L253">      cl.setValue(cl.word());</span>
<span class="nc" id="L254">      cl.setOriginalText(cl.word());</span>
    }
<span class="nc" id="L256">    return newChunk;</span>
  }

  /**
   * Return chunk offsets
   * @param chunkList - List of chunks
   * @param charStart - character begin offset
   * @param charEnd - character end offset
   * @return chunk offsets
   */
  public static Interval&lt;Integer&gt; getChunkOffsetsUsingCharOffsets(List&lt;? extends CoreMap&gt; chunkList,
                                       int charStart, int charEnd) {
<span class="nc" id="L268">    int chunkStart = 0;</span>
<span class="nc" id="L269">    int chunkEnd = chunkList.size();</span>
    // Find first chunk with start &gt; charStart
<span class="nc bnc" id="L271" title="All 2 branches missed.">    for (int i = 0; i &lt; chunkList.size(); i++) {</span>
<span class="nc" id="L272">      int start = chunkList.get(i).get(CoreAnnotations.CharacterOffsetBeginAnnotation.class);</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">      if (start &gt; charStart) {</span>
<span class="nc" id="L274">        break;</span>
      }
<span class="nc" id="L276">      chunkStart = i;</span>
    }
    // Find first chunk with start &gt;= charEnd
<span class="nc bnc" id="L279" title="All 2 branches missed.">    for (int i = chunkStart; i &lt; chunkList.size(); i++) {</span>
<span class="nc" id="L280">      int start = chunkList.get(i).get(CoreAnnotations.CharacterOffsetBeginAnnotation.class);</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">      if (start &gt;= charEnd) {</span>
<span class="nc" id="L282">        chunkEnd = i;</span>
<span class="nc" id="L283">        break;</span>
      }
    }
<span class="nc" id="L286">    return Interval.toInterval(chunkStart, chunkEnd, Interval.INTERVAL_OPEN_END);</span>
  }


  /**
   * Merge chunks from chunkIndexStart to chunkIndexEnd (exclusive) and replace them in the list.
   * @param chunkList - List of chunks
   * @param origText - Text from which to extract chunk text
   * @param chunkIndexStart - Index of first chunk to merge
   * @param chunkIndexEnd - Index of last chunk to merge (exclusive)
   */
  public static void mergeChunks(List&lt;CoreMap&gt; chunkList, String origText,
                                 int chunkIndexStart, int chunkIndexEnd) {
<span class="fc" id="L299">    CoreMap newChunk = getMergedChunk(chunkList, origText, chunkIndexStart, chunkIndexEnd, null);</span>
<span class="fc" id="L300">    int nChunksToRemove = chunkIndexEnd - chunkIndexStart - 1;</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">    for (int i = 0; i &lt; nChunksToRemove; i++) {</span>
<span class="fc" id="L302">      chunkList.remove(chunkIndexStart);</span>
    }
<span class="fc" id="L304">    chunkList.set(chunkIndexStart, newChunk);</span>
<span class="fc" id="L305">  }</span>

  private static Character getFirstNonWsChar(CoreMap sent) {
<span class="nc" id="L308">    String sentText = sent.get(CoreAnnotations.TextAnnotation.class);</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">    for (int j = 0; j &lt; sentText.length(); j++) {</span>
<span class="nc" id="L310">      char c = sentText.charAt(j);</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">      if (!Character.isWhitespace(c)) {</span>
<span class="nc" id="L312">        return c;</span>
      }
    }
<span class="nc" id="L315">    return null;</span>
  }

  private static Integer getFirstNonWsCharOffset(CoreMap sent, boolean relative) {
<span class="nc" id="L319">    String sentText = sent.get(CoreAnnotations.TextAnnotation.class);</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">    for (int j = 0; j &lt; sentText.length(); j++) {</span>
<span class="nc" id="L321">      char c = sentText.charAt(j);</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">      if (!Character.isWhitespace(c)) {</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">        if (relative) {</span>
<span class="nc" id="L324">          return j;</span>
        } else {
<span class="nc" id="L326">          return j + sent.get(CoreAnnotations.CharacterOffsetBeginAnnotation.class);</span>
        }
      }
    }
<span class="nc" id="L330">    return null;</span>
  }

  private static String getTrimmedText(CoreMap sent) {
<span class="nc" id="L334">    String sentText = sent.get(CoreAnnotations.TextAnnotation.class);</span>
<span class="nc" id="L335">    return sentText.trim();</span>
  }

  /**
   * Give an list of character offsets for chunk, fix sentence splitting
   * so sentences doesn't break the chunks.
   *
   * @param docAnnotation Document with sentences
   * @param chunkCharOffsets ordered pairs of different chunks that should appear in sentences
   * @return true if fix was okay (chunks are in all sentences), false otherwise
   */
  public static boolean fixChunkSentenceBoundaries(CoreMap docAnnotation, List&lt;IntPair&gt; chunkCharOffsets) {
<span class="nc" id="L347">    return fixChunkSentenceBoundaries(docAnnotation, chunkCharOffsets, false, false, false);</span>
  }

  /**
   * Give an list of character offsets for chunk, fix sentence splitting
   * so sentences doesn't break the chunks.
   *
   * @param docAnnotation Document with sentences
   * @param chunkCharOffsets ordered pairs of different chunks that should appear in sentences
   * @param offsetsAreNotSorted Treat each pair of offsets as independent (look through all sentences again)
   * @param extendedFixSentence Do extended sentence fixing based on some heuristics
   * @param moreExtendedFixSentence Do even more extended sentence fixing based on some heuristics
   * @return true if fix was okay (chunks are in all sentences), false otherwise
   */
  public static boolean fixChunkSentenceBoundaries(CoreMap docAnnotation, List&lt;IntPair&gt; chunkCharOffsets,
                                                   boolean offsetsAreNotSorted,
                                                   boolean extendedFixSentence, boolean moreExtendedFixSentence) {
<span class="nc" id="L364">    String text = docAnnotation.get(CoreAnnotations.TextAnnotation.class);</span>
<span class="nc" id="L365">    List&lt;CoreMap&gt; sentences = docAnnotation.get(CoreAnnotations.SentencesAnnotation.class);</span>
<span class="nc bnc" id="L366" title="All 4 branches missed.">    if (sentences == null || sentences.size() == 0) return true;</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">    if (chunkCharOffsets != null) {</span>
<span class="nc" id="L368">      int i = 0;</span>
<span class="nc" id="L369">      CoreMap sentence = sentences.get(i);</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">      for (IntPair offsets:chunkCharOffsets) {</span>
<span class="nc" id="L371">        int offsetBegin = offsets.getSource();</span>
<span class="nc" id="L372">        int offsetEnd = offsets.getTarget();</span>
        // Find sentence where sentence begins after chunk starts
        // and sentence ends after chunk starts
<span class="nc bnc" id="L375" title="All 2 branches missed.">        while (offsetBegin &lt; sentence.get(CoreAnnotations.CharacterOffsetBeginAnnotation.class)</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">                || offsetBegin &gt;= sentence.get(CoreAnnotations.CharacterOffsetEndAnnotation.class)) {</span>
<span class="nc" id="L377">          i++;</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">          if (i &gt;= sentences.size()) { return false; }</span>
<span class="nc" id="L379">          sentence = sentences.get(i);</span>
        }
        // offsetBegin is now &gt;= sentence begin and &lt; sentence end
        // Check if sentence end includes chunk
<span class="nc bnc" id="L383" title="All 2 branches missed.">        if (sentence.get(CoreAnnotations.CharacterOffsetEndAnnotation.class) &gt;= offsetEnd) {</span>
          // success!  sentence contains chunk
        } else {
          // hmm, sentence contains beginning of chunk, but not end
          // Lets find sentence that contains end of chunk and merge sentences
<span class="nc" id="L388">          int startSentIndex = i;</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">          while (offsetEnd &gt; sentence.get(CoreAnnotations.CharacterOffsetEndAnnotation.class)) {</span>
<span class="nc" id="L390">            i++;</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">            if (i &gt;= sentences.size()) { return false; }</span>
<span class="nc" id="L392">            sentence = sentences.get(i);</span>
          }
<span class="nc" id="L394">          Integer firstNonWsCharOffset = getFirstNonWsCharOffset(sentence, false);</span>
<span class="nc bnc" id="L395" title="All 4 branches missed.">          if (firstNonWsCharOffset != null &amp;&amp; firstNonWsCharOffset &gt;= offsetEnd) {</span>
            // Ends before first real character of this sentence, don't include this sentence
<span class="nc" id="L397">            i--;</span>
<span class="nc" id="L398">            sentence = sentences.get(i);</span>
          }
          // Okay, now let's merge sentences from startSendIndex to i (includes i)
<span class="nc" id="L401">          mergeChunks(sentences, text, startSentIndex, i+1);</span>
          // Reset our iterating index i to startSentIndex
<span class="nc" id="L403">          i = startSentIndex;</span>
<span class="nc" id="L404">          sentence = sentences.get(i);</span>
        }
<span class="nc bnc" id="L406" title="All 2 branches missed.">        if (extendedFixSentence) {</span>
          //log.info(&quot;Doing extended fixing of sentence:&quot; + text.substring(offsetBegin,offsetEnd));
<span class="nc bnc" id="L408" title="All 2 branches missed.">          if (i+1 &lt; sentences.size()) {</span>
            // Extended sentence fixing:
            // Check if entity is at the end of this sentence and if next sentence starts with uppercase
            // If not uppercase, merge with next sentence
<span class="nc" id="L412">            boolean entityAtSentEnd = true;</span>
<span class="nc" id="L413">            int sentCharBegin = sentence.get(CoreAnnotations.CharacterOffsetBeginAnnotation.class);</span>
<span class="nc" id="L414">            String sentText = sentence.get(CoreAnnotations.TextAnnotation.class);</span>
<span class="nc" id="L415">            int offsetEndInSentText = offsetEnd - sentCharBegin;</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">            for (int j = offsetEndInSentText; j &lt; sentText.length(); j++) {</span>
<span class="nc" id="L417">              char c = sentText.charAt(j);</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">              if (!Character.isWhitespace(c)) {</span>
<span class="nc" id="L419">                entityAtSentEnd = false;</span>
<span class="nc" id="L420">                break;</span>
              }
            }
<span class="nc" id="L423">            boolean doMerge = false;</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">            if (entityAtSentEnd) {</span>
<span class="nc" id="L425">              CoreMap nextSentence = sentences.get(i+1);</span>
<span class="nc" id="L426">              Character c = getFirstNonWsChar(nextSentence);</span>
<span class="nc bnc" id="L427" title="All 2 branches missed.">              if (c != null) {</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">                doMerge = !Character.isUpperCase(c);</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">                if (!doMerge) {</span>
<span class="nc" id="L430">                  logger.debug(&quot;No merge: c is '&quot; + c + &quot;'&quot;);</span>
                }
              } else {
<span class="nc" id="L433">                logger.debug(&quot;No merge: no char&quot;);</span>
              }
<span class="nc" id="L435">            } else {</span>
<span class="nc" id="L436">              logger.debug(&quot;No merge: entity not at end&quot;);</span>
            }
<span class="nc bnc" id="L438" title="All 2 branches missed.">            if (doMerge) {</span>
<span class="nc" id="L439">              logger.debug(&quot;Merge chunks&quot;);</span>
<span class="nc" id="L440">              mergeChunks(sentences, text, i, i+2);</span>
            }
          }
        }
<span class="nc bnc" id="L444" title="All 2 branches missed.">        if (offsetsAreNotSorted) {</span>
<span class="nc" id="L445">          i = 0;</span>
        }
<span class="nc" id="L447">        sentence = sentences.get(i);</span>
<span class="nc" id="L448">      }</span>
    }
    // Do a bit more sentence fixing
<span class="nc bnc" id="L451" title="All 2 branches missed.">    if (moreExtendedFixSentence) {</span>
<span class="nc" id="L452">      int i = 0;</span>
<span class="nc bnc" id="L453" title="All 2 branches missed.">      while (i+1 &lt; sentences.size()) {</span>
<span class="nc" id="L454">        boolean doMerge = false;</span>
<span class="nc" id="L455">        CoreMap sentence = sentences.get(i);</span>
<span class="nc" id="L456">        CoreMap nextSentence = sentences.get(i+1);</span>
<span class="nc" id="L457">        String sentTrimmedText = getTrimmedText(sentence);</span>
<span class="nc" id="L458">        String nextSentTrimmedText = getTrimmedText(nextSentence);</span>
<span class="nc bnc" id="L459" title="All 4 branches missed.">        if (sentTrimmedText.length() &lt;= 1 || nextSentTrimmedText.length() &lt;= 1) {</span>
          // Merge
<span class="nc" id="L461">          doMerge = true;</span>
        } else {
 //         List&lt;CoreLabel&gt; sentTokens = sentence.get(CoreAnnotations.TokensAnnotation.class);
 //         CoreLabel lastSentToken = sentTokens.get(sentTokens.size()-1);
<span class="nc" id="L465">          Character c = getFirstNonWsChar(nextSentence);</span>
 //         List&lt;CoreLabel&gt; nextSentTokens = nextSentence.get(CoreAnnotations.TokensAnnotation.class);
<span class="nc bnc" id="L467" title="All 4 branches missed.">          if (c != null &amp;&amp; !Character.isUpperCase(c)) {</span>
<span class="nc bnc" id="L468" title="All 4 branches missed.">            if (c == ',' || (Character.isLowerCase(c))) {</span>
<span class="nc" id="L469">              doMerge = true;</span>
            }
          }
        }
<span class="nc bnc" id="L473" title="All 2 branches missed.">        if (doMerge) {</span>
<span class="nc" id="L474">          mergeChunks(sentences, text, i, i+2);</span>
        } else {
<span class="nc" id="L476">          i++;</span>
        }
<span class="nc" id="L478">      }</span>
    }
    // Set sentence indices
<span class="nc bnc" id="L481" title="All 2 branches missed.">    for (int i = 0; i &lt; sentences.size(); i++) {</span>
<span class="nc" id="L482">      CoreMap sentence = sentences.get(i);</span>
<span class="nc" id="L483">      sentence.set(CoreAnnotations.SentenceIndexAnnotation.class, i);</span>
    }
<span class="nc" id="L485">    return true;</span>
  }

  /**
   * Annotates a CoreMap representing a chunk with basic chunk information.
   *   CharacterOffsetBeginAnnotation - set to CharacterOffsetBeginAnnotation of first token in chunk
   *   CharacterOffsetEndAnnotation - set to CharacterOffsetEndAnnotation of last token in chunk
   *   TokensAnnotation - List of tokens in this chunk
   *   TokenBeginAnnotation - Index of first token in chunk (index in original list of tokens)
   *                          tokenStartIndex + totalTokenOffset
   *   TokenEndAnnotation - Index of last token in chunk (index in original list of tokens)
   *                          tokenEndIndex + totalTokenOffset
   * @param chunk - CoreMap to be annotated
   * @param tokens - List of tokens to look for chunks
   * @param tokenStartIndex - Index (relative to current list of tokens) at which this chunk starts
   * @param tokenEndIndex - Index (relative to current list of tokens) at which this chunk ends (not inclusive)
   * @param totalTokenOffset - Index of tokens to offset by
   */
  public static void annotateChunk(CoreMap chunk,
                                   List&lt;CoreLabel&gt; tokens, int tokenStartIndex, int tokenEndIndex,  int totalTokenOffset) {
<span class="nc" id="L505">    List&lt;CoreLabel&gt; chunkTokens = new ArrayList&lt;&gt;(tokens.subList(tokenStartIndex, tokenEndIndex));</span>
<span class="nc" id="L506">    chunk.set(CoreAnnotations.CharacterOffsetBeginAnnotation.class,</span>
<span class="nc" id="L507">            chunkTokens.get(0).get(CoreAnnotations.CharacterOffsetBeginAnnotation.class));</span>
<span class="nc" id="L508">    chunk.set(CoreAnnotations.CharacterOffsetEndAnnotation.class,</span>
<span class="nc" id="L509">            chunkTokens.get(chunkTokens.size()-1).get(CoreAnnotations.CharacterOffsetEndAnnotation.class));</span>
<span class="nc" id="L510">    chunk.set(CoreAnnotations.TokensAnnotation.class, chunkTokens);</span>
<span class="nc" id="L511">    chunk.set(CoreAnnotations.TokenBeginAnnotation.class, tokenStartIndex+totalTokenOffset);</span>
<span class="nc" id="L512">    chunk.set(CoreAnnotations.TokenEndAnnotation.class, tokenEndIndex+totalTokenOffset);</span>
<span class="nc" id="L513">  }</span>

  public static String getTokenText(List&lt;? extends CoreMap&gt; tokens, Class tokenTextKey) {
<span class="fc" id="L516">    return getTokenText(tokens, tokenTextKey, &quot; &quot;);</span>
  }

  public static String getTokenText(List&lt;? extends CoreMap&gt; tokens, Class tokenTextKey, String delimiter) {
<span class="fc" id="L520">    StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L521">    int prevEndIndex = -1;</span>
<span class="fc bfc" id="L522" title="All 2 branches covered.">    for (CoreMap cm:tokens) {</span>
<span class="fc" id="L523">      Object obj = cm.get(tokenTextKey);</span>
<span class="fc bfc" id="L524" title="All 2 branches covered.">      boolean includeDelimiter = sb.length() &gt; 0;</span>
<span class="pc bpc" id="L525" title="1 of 2 branches missed.">      if (cm.containsKey(CoreAnnotations.CharacterOffsetBeginAnnotation.class) &amp;&amp;</span>
<span class="nc bnc" id="L526" title="All 2 branches missed.">        cm.containsKey(CoreAnnotations.CharacterOffsetEndAnnotation.class)) {</span>
<span class="nc" id="L527">        int beginIndex = cm.get(CoreAnnotations.CharacterOffsetBeginAnnotation.class);</span>
<span class="nc" id="L528">        int endIndex = cm.get(CoreAnnotations.CharacterOffsetEndAnnotation.class);</span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">        if (prevEndIndex == beginIndex) {</span>
          // No spaces
<span class="nc" id="L531">          includeDelimiter = false;</span>
        }
<span class="nc" id="L533">        prevEndIndex = endIndex;</span>
      }
<span class="pc bpc" id="L535" title="1 of 2 branches missed.">      if (obj != null) {</span>
<span class="fc bfc" id="L536" title="All 2 branches covered.">        if (includeDelimiter) {</span>
<span class="fc" id="L537">          sb.append(delimiter);</span>
        }
<span class="fc" id="L539">        sb.append(obj);</span>
      }
<span class="fc" id="L541">    }</span>
<span class="fc" id="L542">    return sb.toString();</span>
  }

  /**
   * Annotates a CoreMap representing a chunk with text information
   *   TextAnnotation - String representing tokens in this chunks (token text separated by space)
   * @param chunk - CoreMap to be annotated
   * @param tokenTextKey - Key to use to find the token text
   */
  public static void annotateChunkText(CoreMap chunk, Class tokenTextKey) {
<span class="nc" id="L552">    List&lt;CoreLabel&gt; chunkTokens = chunk.get(CoreAnnotations.TokensAnnotation.class);</span>
<span class="nc" id="L553">    String text = getTokenText(chunkTokens, tokenTextKey);</span>
<span class="nc" id="L554">    chunk.set(CoreAnnotations.TextAnnotation.class, text);</span>
<span class="nc" id="L555">  }</span>

  public static boolean hasCharacterOffsets(CoreMap chunk) {
<span class="nc bnc" id="L558" title="All 2 branches missed.">    return chunk.get(CoreAnnotations.CharacterOffsetBeginAnnotation.class) != null &amp;&amp;</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">            chunk.get(CoreAnnotations.CharacterOffsetEndAnnotation.class) != null;</span>
  }

  /**
   * Annotates a CoreMap representing a chunk with text information
   *   TextAnnotation - String extracted from the origAnnotation using character offset information for this chunk
   * @param chunk - CoreMap to be annotated
   * @param origAnnotation - Annotation from which to extract the text for this chunk
   */
  public static boolean annotateChunkText(CoreMap chunk, CoreMap origAnnotation) {
<span class="nc" id="L569">    String annoText = origAnnotation.get(CoreAnnotations.TextAnnotation.class);</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">    if (annoText == null) return false;</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">    if (!hasCharacterOffsets(chunk)) return false;</span>
<span class="nc" id="L572">    Integer annoBeginCharOffset = origAnnotation.get(CoreAnnotations.CharacterOffsetBeginAnnotation.class);</span>
<span class="nc bnc" id="L573" title="All 2 branches missed.">    if (annoBeginCharOffset == null) { annoBeginCharOffset = 0; }</span>
<span class="nc" id="L574">    int chunkBeginCharOffset = chunk.get(CoreAnnotations.CharacterOffsetBeginAnnotation.class) - annoBeginCharOffset;</span>
<span class="nc" id="L575">    int chunkEndCharOffset = chunk.get(CoreAnnotations.CharacterOffsetEndAnnotation.class) - annoBeginCharOffset;</span>
<span class="nc bnc" id="L576" title="All 2 branches missed.">    if (chunkBeginCharOffset &lt; 0) {</span>
<span class="nc" id="L577">      logger.debug(&quot;Adjusting begin char offset from &quot; + chunkBeginCharOffset + &quot; to 0&quot;);</span>
<span class="nc" id="L578">      logger.debug(&quot;Chunk begin offset: &quot; + chunk.get(CoreAnnotations.CharacterOffsetBeginAnnotation.class) +</span>
        &quot;, Source text begin offset &quot; + annoBeginCharOffset);
<span class="nc" id="L580">      chunkBeginCharOffset = 0;</span>
    }
<span class="nc bnc" id="L582" title="All 2 branches missed.">    if (chunkBeginCharOffset &gt; annoText.length()) {</span>
<span class="nc" id="L583">      logger.debug(&quot;Adjusting begin char offset from &quot; + chunkBeginCharOffset + &quot; to &quot; + annoText.length());</span>
<span class="nc" id="L584">      logger.debug(&quot;Chunk begin offset: &quot; + chunk.get(CoreAnnotations.CharacterOffsetBeginAnnotation.class) +</span>
        &quot;, Source text begin offset &quot; + annoBeginCharOffset);
<span class="nc" id="L586">      chunkBeginCharOffset = annoText.length();</span>
    }
<span class="nc bnc" id="L588" title="All 2 branches missed.">    if (chunkEndCharOffset &lt; 0) {</span>
<span class="nc" id="L589">      logger.debug(&quot;Adjusting end char offset from &quot; + chunkEndCharOffset + &quot; to 0&quot;);</span>
<span class="nc" id="L590">      logger.debug(&quot;Chunk end offset: &quot; + chunk.get(CoreAnnotations.CharacterOffsetEndAnnotation.class) +</span>
        &quot;, Source text begin offset &quot; + annoBeginCharOffset);
<span class="nc" id="L592">      chunkEndCharOffset = 0;</span>
    }
<span class="nc bnc" id="L594" title="All 2 branches missed.">    if (chunkEndCharOffset &gt; annoText.length()) {</span>
<span class="nc" id="L595">      logger.debug(&quot;Adjusting end char offset from &quot; + chunkEndCharOffset + &quot; to &quot; + annoText.length());</span>
<span class="nc" id="L596">      logger.debug(&quot;Chunk end offset: &quot; + chunk.get(CoreAnnotations.CharacterOffsetEndAnnotation.class) +</span>
        &quot;, Source text begin offset &quot; + annoBeginCharOffset);
<span class="nc" id="L598">      chunkEndCharOffset = annoText.length();</span>
    }
<span class="nc bnc" id="L600" title="All 2 branches missed.">    if (chunkEndCharOffset &lt; chunkBeginCharOffset) {</span>
<span class="nc" id="L601">      logger.debug(&quot;Adjusting end char offset from &quot; + chunkEndCharOffset + &quot; to &quot; + chunkBeginCharOffset);</span>
<span class="nc" id="L602">      logger.debug(&quot;Chunk end offset: &quot; + chunk.get(CoreAnnotations.CharacterOffsetEndAnnotation.class) +</span>
        &quot;, Source text begin offset &quot; + annoBeginCharOffset);
<span class="nc" id="L604">      chunkEndCharOffset = chunkBeginCharOffset;</span>
    }
<span class="nc" id="L606">    String chunkText = annoText.substring(chunkBeginCharOffset, chunkEndCharOffset);</span>
<span class="nc" id="L607">    chunk.set(CoreAnnotations.TextAnnotation.class, chunkText);</span>
<span class="nc" id="L608">    return true;</span>
  }

  /**
   * Annotates tokens in chunk.
   * @param chunk - CoreMap representing chunk (should have TextAnnotation and TokensAnnotation)
   * @param tokenChunkKey - If not null, each token is annotated with the chunk using this key
   * @param tokenLabelKey - If not null, each token is annotated with the text associated with the chunk using this key
   */
  public static void annotateChunkTokens(CoreMap chunk, Class tokenChunkKey, Class tokenLabelKey) {
<span class="nc" id="L618">    List&lt;CoreLabel&gt; chunkTokens = chunk.get(CoreAnnotations.TokensAnnotation.class);</span>
<span class="nc bnc" id="L619" title="All 2 branches missed.">    if (tokenLabelKey != null) {</span>
<span class="nc" id="L620">      String text = chunk.get(CoreAnnotations.TextAnnotation.class);</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">      for (CoreLabel t: chunkTokens) {</span>
<span class="nc" id="L622">        t.set(tokenLabelKey, text);</span>
<span class="nc" id="L623">      }</span>
    }
<span class="nc bnc" id="L625" title="All 2 branches missed.">    if (tokenChunkKey != null) {</span>
<span class="nc bnc" id="L626" title="All 2 branches missed.">      for (CoreLabel t: chunkTokens) {</span>
<span class="nc" id="L627">        t.set(tokenChunkKey, chunk);</span>
<span class="nc" id="L628">      }</span>
    }
<span class="nc" id="L630">  }</span>

  /**
   * Create a new chunk Annotation with basic chunk information.
   *   CharacterOffsetBeginAnnotation - set to CharacterOffsetBeginAnnotation of first token in chunk
   *   CharacterOffsetEndAnnotation - set to CharacterOffsetEndAnnotation of last token in chunk
   *   TokensAnnotation - List of tokens in this chunk
   *   TokenBeginAnnotation - Index of first token in chunk (index in original list of tokens)
   *                          tokenStartIndex + totalTokenOffset
   *   TokenEndAnnotation - Index of last token in chunk (index in original list of tokens)
   *                          tokenEndIndex + totalTokenOffset
   * @param tokens - List of tokens to look for chunks
   * @param tokenStartIndex - Index (relative to current list of tokens) at which this chunk starts
   * @param tokenEndIndex - Index (relative to current list of tokens) at which this chunk ends (not inclusive)
   * @param totalTokenOffset - Index of tokens to offset by
   * @return Annotation representing new chunk
   */
  public static Annotation getAnnotatedChunk(List&lt;CoreLabel&gt; tokens, int tokenStartIndex, int tokenEndIndex, int totalTokenOffset) {
<span class="nc" id="L648">    Annotation chunk = new Annotation(&quot;&quot;);</span>
<span class="nc" id="L649">    annotateChunk(chunk, tokens, tokenStartIndex, tokenEndIndex, totalTokenOffset);</span>
<span class="nc" id="L650">    return chunk;</span>
  }

  /**
   * Create a new chunk Annotation with basic chunk information.
   *   CharacterOffsetBeginAnnotation - set to CharacterOffsetBeginAnnotation of first token in chunk
   *   CharacterOffsetEndAnnotation - set to CharacterOffsetEndAnnotation of last token in chunk
   *   TokensAnnotation - List of tokens in this chunk
   *   TokenBeginAnnotation - Index of first token in chunk (index in original list of tokens)
   *                          tokenStartIndex + totalTokenOffset
   *   TokenEndAnnotation - Index of last token in chunk (index in original list of tokens)
   *                          tokenEndIndex + totalTokenOffset
   *   TextAnnotation - String extracted from the origAnnotation using character offset information for this chunk
   * @param tokens - List of tokens to look for chunks
   * @param tokenStartIndex - Index (relative to current list of tokens) at which this chunk starts
   * @param tokenEndIndex - Index (relative to current list of tokens) at which this chunk ends (not inclusive)
   * @param totalTokenOffset - Index of tokens to offset by
   * @param tokenChunkKey - If not null, each token is annotated with the chunk using this key
   * @param tokenTextKey - Key to use to find the token text
   * @param tokenLabelKey - If not null, each token is annotated with the text associated with the chunk using this key
   * @return Annotation representing new chunk
   */
  public static Annotation getAnnotatedChunk(List&lt;CoreLabel&gt; tokens, int tokenStartIndex, int tokenEndIndex, int totalTokenOffset,
                                             Class tokenChunkKey, Class tokenTextKey,  Class tokenLabelKey) {
<span class="nc" id="L674">    Annotation chunk = getAnnotatedChunk(tokens, tokenStartIndex, tokenEndIndex, totalTokenOffset);</span>
<span class="nc" id="L675">    annotateChunkText(chunk, tokenTextKey);</span>
<span class="nc" id="L676">    annotateChunkTokens(chunk, tokenChunkKey, tokenLabelKey);</span>
<span class="nc" id="L677">    return chunk;</span>
  }

  /**
   * Create a new chunk Annotation with basic chunk information
   *   CharacterOffsetBeginAnnotation - set to CharacterOffsetBeginAnnotation of first token in chunk
   *   CharacterOffsetEndAnnotation - set to CharacterOffsetEndAnnotation of last token in chunk
   *   TokensAnnotation - List of tokens in this chunk
   *   TokenBeginAnnotation - Index of first token in chunk (index in original list of tokens)
   *                          tokenStartIndex + annotation's TokenBeginAnnotation
   *   TokenEndAnnotation - Index of last token in chunk (index in original list of tokens)
   *                          tokenEndIndex + annotation's TokenBeginAnnotation
   *   TextAnnotation - String extracted from the origAnnotation using character offset information for this chunk
   * @param annotation - Annotation from which to extract the text for this chunk
   * @param tokenStartIndex - Index (relative to current list of tokens) at which this chunk starts
   * @param tokenEndIndex - Index (relative to current list of tokens) at which this chunk ends (not inclusive)
   * @return Annotation representing new chunk
   */
  public static Annotation getAnnotatedChunk(CoreMap annotation, int tokenStartIndex, int tokenEndIndex) {
<span class="nc" id="L696">    Integer annoTokenBegin = annotation.get(CoreAnnotations.TokenBeginAnnotation.class);</span>
<span class="nc bnc" id="L697" title="All 2 branches missed.">    if (annoTokenBegin == null) { annoTokenBegin = 0; }</span>
<span class="nc" id="L698">    List&lt;CoreLabel&gt; tokens = annotation.get(CoreAnnotations.TokensAnnotation.class);</span>
<span class="nc" id="L699">    Annotation chunk = getAnnotatedChunk(tokens, tokenStartIndex, tokenEndIndex, annoTokenBegin);</span>
<span class="nc" id="L700">    boolean annotatedTextFromCharOffsets = annotateChunkText(chunk, annotation);</span>
<span class="nc bnc" id="L701" title="All 2 branches missed.">    if (!annotatedTextFromCharOffsets) {</span>
      // Use tokens to get text annotation
<span class="nc" id="L703">      annotateChunkText(chunk, CoreAnnotations.TextAnnotation.class);</span>
    }
<span class="nc" id="L705">    return chunk;</span>
  }

  /**
   * Create a new chunk Annotation with basic chunk information
   *   CharacterOffsetBeginAnnotation - set to CharacterOffsetBeginAnnotation of first token in chunk
   *   CharacterOffsetEndAnnotation - set to CharacterOffsetEndAnnotation of last token in chunk
   *   TokensAnnotation - List of tokens in this chunk
   *   TokenBeginAnnotation - Index of first token in chunk (index in original list of tokens)
   *                          tokenStartIndex + annotation's TokenBeginAnnotation
   *   TokenEndAnnotation - Index of last token in chunk (index in original list of tokens)
   *                          tokenEndIndex + annotation's TokenBeginAnnotation
   *   TextAnnotation - String extracted from the origAnnotation using character offset information for this chunk
   * @param annotation - Annotation from which to extract the text for this chunk
   * @param tokenStartIndex - Index (relative to current list of tokens) at which this chunk starts
   * @param tokenEndIndex - Index (relative to current list of tokens) at which this chunk ends (not inclusive)
   * @param tokenChunkKey - If not null, each token is annotated with the chunk using this key
   * @param tokenLabelKey - If not null, each token is annotated with the text associated with the chunk using this key
   * @return Annotation representing new chunk
   */
  public static Annotation getAnnotatedChunk(CoreMap annotation, int tokenStartIndex, int tokenEndIndex,
                                             Class tokenChunkKey, Class tokenLabelKey) {
<span class="nc" id="L727">    Annotation chunk = getAnnotatedChunk(annotation, tokenStartIndex, tokenEndIndex);</span>
<span class="nc" id="L728">    annotateChunkTokens(chunk, tokenChunkKey, tokenLabelKey);</span>
<span class="nc" id="L729">    return chunk;</span>
  }

  /** Returns a chunk annotation based on char offsets.
   *
   * @param annotation Annotation from which to extract the text for this chunk
   * @param charOffsetStart Start character offset
   * @param charOffsetEnd End (not inclusive) character offset
   * @return An Annotation representing the new chunk. Or {@code null} if no chunk matches offsets.
   */
  public static CoreMap getAnnotatedChunkUsingCharOffsets(CoreMap annotation, int charOffsetStart, int charOffsetEnd) {
    // TODO: make more efficient search
<span class="nc" id="L741">    List&lt;CoreMap&gt; cm = getAnnotatedChunksUsingSortedCharOffsets(annotation,</span>
<span class="nc" id="L742">            CollectionUtils.makeList(new IntPair(charOffsetStart, charOffsetEnd)));</span>
<span class="nc bnc" id="L743" title="All 2 branches missed.">    if ( ! cm.isEmpty()) {</span>
<span class="nc" id="L744">      return cm.get(0);</span>
    } else {
<span class="nc" id="L746">      return null;</span>
    }
  }

  public static List&lt;CoreMap&gt; getAnnotatedChunksUsingSortedCharOffsets(
          CoreMap annotation, List&lt;IntPair&gt; charOffsets) {
<span class="nc" id="L752">    return getAnnotatedChunksUsingSortedCharOffsets(annotation, charOffsets, true, null, null, true);</span>
  }

  /**
   * Create a list of new chunk Annotation with basic chunk information.
   *   CharacterOffsetBeginAnnotation - set to CharacterOffsetBeginAnnotation of first token in chunk
   *   CharacterOffsetEndAnnotation - set to CharacterOffsetEndAnnotation of last token in chunk
   *   TokensAnnotation - List of tokens in this chunk
   *   TokenBeginAnnotation - Index of first token in chunk (index in original list of tokens)
   *                          tokenStartIndex + annotation's TokenBeginAnnotation
   *   TokenEndAnnotation - Index of last token in chunk (index in original list of tokens)
   *                          tokenEndIndex + annotation's TokenBeginAnnotation
   *   TextAnnotation - String extracted from the origAnnotation using character offset information for this chunk
   *
   * @param annotation Annotation from which to extract the text for this chunk
   * @param charOffsets - List of start and end (not inclusive) character offsets
   *                      Note: assume char offsets are sorted and non-overlapping!!!
   * @param charOffsetIsRelative - Whether the character offsets are relative to the current annotation or absolute offsets
   * @param tokenChunkKey - If not null, each token is annotated with the chunk using this key
   * @param tokenLabelKey - If not null, each token is annotated with the text associated with the chunk using this key
   * @param allowPartialTokens - Whether to allow partial tokens or not
   * @return List of Annotation representing new chunks; may be empty never null
   */
  public static List&lt;CoreMap&gt; getAnnotatedChunksUsingSortedCharOffsets(
          CoreMap annotation, List&lt;IntPair&gt; charOffsets, boolean charOffsetIsRelative,
          Class tokenChunkKey, Class tokenLabelKey, boolean allowPartialTokens) {
<span class="nc" id="L778">    String annoText = annotation.get(CoreAnnotations.TextAnnotation.class);</span>
<span class="nc" id="L779">    List&lt;CoreMap&gt; chunks = new ArrayList&lt;&gt;(charOffsets.size());</span>
<span class="nc" id="L780">    List&lt;CoreLabel&gt; annoTokens = annotation.get(CoreAnnotations.TokensAnnotation.class);</span>
<span class="nc" id="L781">    Integer annoCharBegin = annotation.get(CoreAnnotations.CharacterOffsetBeginAnnotation.class);</span>
<span class="nc bnc" id="L782" title="All 2 branches missed.">    if (annoCharBegin == null) { annoCharBegin = 0; }</span>
<span class="nc" id="L783">    Integer annoTokenBegin = annotation.get(CoreAnnotations.TokenBeginAnnotation.class);</span>
<span class="nc bnc" id="L784" title="All 2 branches missed.">    if (annoTokenBegin == null) { annoTokenBegin = 0; }</span>
<span class="nc" id="L785">    int i = 0;</span>
<span class="nc bnc" id="L786" title="All 2 branches missed.">    for (IntPair p:charOffsets) {</span>
<span class="nc bnc" id="L787" title="All 2 branches missed.">      int beginRelCharOffset = charOffsetIsRelative? p.getSource():p.getSource()-annoCharBegin;</span>
<span class="nc bnc" id="L788" title="All 2 branches missed.">      int endRelCharOffset = charOffsetIsRelative? p.getTarget():p.getTarget()-annoCharBegin;</span>
<span class="nc" id="L789">      int beginCharOffset = beginRelCharOffset + annoCharBegin;</span>
<span class="nc" id="L790">      int endCharOffset = endRelCharOffset + annoCharBegin;</span>
<span class="nc bnc" id="L791" title="All 2 branches missed.">      if (beginRelCharOffset &gt;= annoText.length()) { break; }</span>
<span class="nc bnc" id="L792" title="All 2 branches missed.">      if (endRelCharOffset &gt; annoText.length()) { endRelCharOffset = annoText.length(); }</span>
<span class="nc bnc" id="L793" title="All 2 branches missed.">      if (allowPartialTokens) {</span>
<span class="nc bnc" id="L794" title="All 4 branches missed.">        while (i &lt; annoTokens.size() &amp;&amp; annoTokens.get(i).endPosition() &lt;= beginCharOffset) {</span>
<span class="nc" id="L795">          i++;</span>
        }
      } else {
<span class="nc bnc" id="L798" title="All 4 branches missed.">        while (i &lt; annoTokens.size() &amp;&amp; annoTokens.get(i).beginPosition() &lt; beginCharOffset) {</span>
<span class="nc" id="L799">          i++;</span>
        }
      }
<span class="nc bnc" id="L802" title="All 2 branches missed.">      if (i &gt;= annoTokens.size()) break;</span>
<span class="nc" id="L803">      int tokenBegin = i;</span>
<span class="nc" id="L804">      int j = i;</span>
<span class="nc bnc" id="L805" title="All 2 branches missed.">      if (allowPartialTokens) {</span>
<span class="nc bnc" id="L806" title="All 4 branches missed.">        while (j &lt; annoTokens.size() &amp;&amp; annoTokens.get(j).beginPosition() &lt; endCharOffset) {</span>
<span class="nc" id="L807">          j++;</span>
        }
      } else {
<span class="nc bnc" id="L810" title="All 4 branches missed.">        while (j &lt; annoTokens.size() &amp;&amp; annoTokens.get(j).endPosition() &lt;= endCharOffset) {</span>
<span class="nc bnc" id="L811" title="All 4 branches missed.">          assert(annoTokens.get(j).beginPosition() &gt;= beginCharOffset);</span>
<span class="nc" id="L812">          j++;</span>
        }
      }
<span class="nc" id="L815">      int tokenEnd = j;</span>

<span class="nc" id="L817">      List&lt;CoreLabel&gt; chunkTokens = new ArrayList&lt;&gt;(annoTokens.subList(tokenBegin, tokenEnd));</span>
<span class="nc" id="L818">      String chunkText = annoText.substring(beginRelCharOffset, endRelCharOffset);</span>
<span class="nc" id="L819">      Annotation chunk = new Annotation(chunkText);</span>
<span class="nc" id="L820">      chunk.set(CoreAnnotations.CharacterOffsetBeginAnnotation.class, beginCharOffset);</span>
<span class="nc" id="L821">      chunk.set(CoreAnnotations.CharacterOffsetEndAnnotation.class, endCharOffset);</span>
<span class="nc" id="L822">      chunk.set(CoreAnnotations.TokensAnnotation.class, chunkTokens);</span>
<span class="nc" id="L823">      chunk.set(CoreAnnotations.TokenBeginAnnotation.class, tokenBegin + annoTokenBegin);</span>
<span class="nc" id="L824">      chunk.set(CoreAnnotations.TokenEndAnnotation.class, tokenEnd + annoTokenBegin);</span>
<span class="nc" id="L825">      annotateChunkTokens(chunk, tokenChunkKey, tokenLabelKey);</span>
<span class="nc" id="L826">      chunks.add(chunk);</span>
<span class="nc bnc" id="L827" title="All 2 branches missed.">      if (j &gt;= annoTokens.size()) break;</span>
<span class="nc" id="L828">    }</span>
<span class="nc bnc" id="L829" title="All 2 branches missed.">    if (chunks.size() != charOffsets.size()) {</span>
<span class="nc" id="L830">      logger.warning(&quot;WARNING: Only &quot; + chunks.size() + &quot;/&quot; + charOffsets.size()</span>
              + &quot; chunks found.  Check if offsets are sorted/nonoverlapping&quot;);
    }
<span class="nc" id="L833">    return chunks;</span>
  }

  public static void annotateChunk(CoreMap annotation, Class newAnnotationKey,
                                   Class aggrKey, CoreMapAttributeAggregator aggregator) {
<span class="nc" id="L838">    Object v = aggregator.aggregate(aggrKey, annotation.get(CoreAnnotations.TokensAnnotation.class));</span>
<span class="nc" id="L839">    annotation.set(newAnnotationKey, v);</span>
<span class="nc" id="L840">  }</span>

  public static void annotateChunk(CoreMap chunk, Map&lt;String,String&gt; attributes) {
<span class="nc bnc" id="L843" title="All 2 branches missed.">    for (Map.Entry&lt;String, String&gt; entry : attributes.entrySet()) {</span>
<span class="nc" id="L844">      String key = entry.getKey();</span>
<span class="nc" id="L845">      String value = entry.getValue();</span>
<span class="nc" id="L846">      Class coreKeyClass = AnnotationLookup.toCoreKey(key);</span>
<span class="nc bnc" id="L847" title="All 2 branches missed.">      if (key != null) {</span>
<span class="nc bnc" id="L848" title="All 2 branches missed.">        if (value != null)  {</span>
          try {
<span class="nc" id="L850">            Class valueClass = AnnotationLookup.getValueType(coreKeyClass);</span>
<span class="nc bnc" id="L851" title="All 2 branches missed.">            if (valueClass == String.class) {</span>
<span class="nc" id="L852">              chunk.set(coreKeyClass, value);</span>
            } else {
<span class="nc" id="L854">             Method valueOfMethod = valueClass.getMethod(&quot;valueOf&quot;, String.class);</span>
<span class="nc bnc" id="L855" title="All 2 branches missed.">              if (valueOfMethod != null) {</span>
<span class="nc" id="L856">                chunk.set(coreKeyClass, valueOfMethod.invoke(valueClass, value));</span>
              }
            }
<span class="nc" id="L859">          } catch (Exception ex) {</span>
<span class="nc" id="L860">            throw new RuntimeException(&quot;Unable to annotate attribute &quot; + key, ex);</span>
<span class="nc" id="L861">          }</span>
        } else {
<span class="nc" id="L863">          chunk.set(coreKeyClass, null);</span>
        }
      } else {
<span class="nc" id="L866">        throw new UnsupportedOperationException(&quot;Unknown null attribute.&quot;);</span>
      }
<span class="nc" id="L868">    }</span>
<span class="nc" id="L869">  }</span>

  public static void annotateChunks(List&lt;? extends CoreMap&gt; chunks, int start, int end, Map&lt;String,String&gt; attributes) {
<span class="nc bnc" id="L872" title="All 2 branches missed.">    for (int i = start; i &lt; end; i++) {</span>
<span class="nc" id="L873">      annotateChunk(chunks.get(i), attributes);</span>
    }
<span class="nc" id="L875">  }</span>

  public static void annotateChunks(List&lt;? extends CoreMap&gt; chunks, Map&lt;String,String&gt; attributes) {
<span class="nc bnc" id="L878" title="All 2 branches missed.">    for (CoreMap chunk:chunks) {</span>
<span class="nc" id="L879">      annotateChunk(chunk, attributes);</span>
<span class="nc" id="L880">    }</span>
<span class="nc" id="L881">  }</span>

  public static &lt;T extends CoreMap&gt; T createCoreMap(CoreMap cm, String text, int start, int end,
                                                    CoreTokenFactory&lt;T&gt; factory) {
<span class="nc bnc" id="L885" title="All 2 branches missed.">    if (end &gt; start) {</span>
<span class="nc" id="L886">      T token = factory.makeToken();</span>
<span class="nc" id="L887">      Integer cmCharStart = cm.get(CoreAnnotations.CharacterOffsetBeginAnnotation.class);</span>
<span class="nc bnc" id="L888" title="All 2 branches missed.">      if (cmCharStart == null) cmCharStart = 0;</span>
<span class="nc" id="L889">      String tokenText = text.substring(start, end);</span>
<span class="nc" id="L890">      token.set(CoreAnnotations.TextAnnotation.class, tokenText);</span>
<span class="nc bnc" id="L891" title="All 2 branches missed.">      if (token instanceof CoreLabel) {</span>
<span class="nc" id="L892">        token.set(CoreAnnotations.ValueAnnotation.class, tokenText);</span>
      }
<span class="nc" id="L894">      token.set(CoreAnnotations.CharacterOffsetBeginAnnotation.class, cmCharStart + start);</span>
<span class="nc" id="L895">      token.set(CoreAnnotations.CharacterOffsetEndAnnotation.class, cmCharStart + end);</span>
<span class="nc" id="L896">      return token;</span>
    } else {
<span class="nc" id="L898">      return null;</span>
    }
  }

  public static &lt;T extends CoreMap&gt; void appendCoreMap(List&lt;T&gt; res,
                                                       CoreMap cm, String text, int start, int end,
                                                       CoreTokenFactory&lt;T&gt; factory) {
<span class="nc" id="L905">    T scm = createCoreMap(cm, text, start, end, factory);</span>
<span class="nc bnc" id="L906" title="All 2 branches missed.">    if (scm != null) {</span>
<span class="nc" id="L907">      res.add(scm);</span>
    }
<span class="nc" id="L909">  }</span>

  public static &lt;T extends CoreMap&gt; List&lt;T&gt; splitCoreMap(Pattern p, boolean includeMatched,
                                                         CoreMap cm, CoreTokenFactory&lt;T&gt; factory) {
<span class="nc" id="L913">    List&lt;T&gt; res = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L914">    String text = cm.get(CoreAnnotations.TextAnnotation.class);</span>
<span class="nc" id="L915">    Matcher m = p.matcher(text);</span>
<span class="nc" id="L916">    int index = 0;</span>
<span class="nc bnc" id="L917" title="All 2 branches missed.">    while (m.find()) {</span>
<span class="nc" id="L918">      int start = m.start();</span>
<span class="nc" id="L919">      int end = m.end();</span>
      // Include characters from index to m.start()
<span class="nc" id="L921">      appendCoreMap(res, cm, text, index, start, factory);</span>
      // Include matched pattern
<span class="nc bnc" id="L923" title="All 2 branches missed.">      if (includeMatched) {</span>
<span class="nc" id="L924">        appendCoreMap(res, cm, text, start, end, factory);</span>
      }
<span class="nc" id="L926">      index = end;</span>
<span class="nc" id="L927">    }</span>
<span class="nc" id="L928">    appendCoreMap(res, cm, text, index, text.length(), factory);</span>
<span class="nc" id="L929">    return res;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>