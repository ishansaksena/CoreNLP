<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TransducerGraph.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.fsm</a> &gt; <span class="el_source">TransducerGraph.java</span></div><h1>TransducerGraph.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.fsm; 
import edu.stanford.nlp.util.logging.Redwood;

import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.Set;

import edu.stanford.nlp.stats.ClassicCounter;
import edu.stanford.nlp.trees.TreebankLanguagePack;
import edu.stanford.nlp.util.Generics;
import edu.stanford.nlp.util.Maps;
import edu.stanford.nlp.util.Pair;
import edu.stanford.nlp.util.StringUtils;

/**
 * TransducerGraph represents a deterministic finite state automaton
 * without epsilon transitions.
 *
 * @author Teg Grenager
 * @version 11/02/03
 */
// TODO: needs some work to make type-safe.
// (In several places, it takes an Object and does instanceof to see what
// it is, or assumes one of the alphabets is a Double, etc....)
public class TransducerGraph implements Cloneable  {

  /** A logger for this class */
<span class="nc" id="L34">  private static Redwood.RedwoodChannels log = Redwood.channels(TransducerGraph.class);</span>

  public static final String EPSILON_INPUT = &quot;EPSILON&quot;;

  private static final String DEFAULT_START_NODE = &quot;START&quot;;

<span class="nc" id="L40">  private static final Random r = new Random();</span>

  // internal data structures
  private final Set&lt;Arc&gt; arcs;
  private final Map&lt;Object, Set&lt;Arc&gt;&gt; arcsBySource;
  private final Map&lt;Object, Set&lt;Arc&gt;&gt; arcsByTarget;
  private final Map&lt;Object, Set&lt;Arc&gt;&gt; arcsByInput;
  private Map&lt;Pair&lt;Object, Object&gt;, Arc&gt; arcsBySourceAndInput;
  private Map&lt;Object, Set&lt;Arc&gt;&gt; arcsByTargetAndInput;
  private Object startNode;
  private Set endNodes;
<span class="nc" id="L51">  private boolean checkDeterminism = false;</span>

  public void setDeterminism(boolean checkDeterminism) {
<span class="nc" id="L54">    this.checkDeterminism = checkDeterminism;</span>
<span class="nc" id="L55">  }</span>

<span class="nc" id="L57">  public TransducerGraph() {</span>
<span class="nc" id="L58">    arcs = Generics.newHashSet();</span>
<span class="nc" id="L59">    arcsBySource = Generics.newHashMap();</span>
<span class="nc" id="L60">    arcsByTarget = Generics.newHashMap();</span>
<span class="nc" id="L61">    arcsByInput = Generics.newHashMap();</span>
<span class="nc" id="L62">    arcsBySourceAndInput = Generics.newHashMap();</span>
<span class="nc" id="L63">    arcsByTargetAndInput = Generics.newHashMap();</span>
<span class="nc" id="L64">    endNodes = Generics.newHashSet();</span>
<span class="nc" id="L65">    setStartNode(DEFAULT_START_NODE);</span>
<span class="nc" id="L66">  }</span>

  public TransducerGraph(TransducerGraph other) {
<span class="nc" id="L69">    this(other, (ArcProcessor) null);</span>
<span class="nc" id="L70">  }</span>

  public TransducerGraph(TransducerGraph other, ArcProcessor arcProcessor) {
<span class="nc" id="L73">    this(other.getArcs(), other.getStartNode(), other.getEndNodes(), arcProcessor, null);</span>
<span class="nc" id="L74">  }</span>

  public TransducerGraph(TransducerGraph other, NodeProcessor nodeProcessor) {
<span class="nc" id="L77">    this(other.getArcs(), other.getStartNode(), other.getEndNodes(), null, nodeProcessor);</span>
<span class="nc" id="L78">  }</span>

  public TransducerGraph(Set&lt;Arc&gt; newArcs, Object startNode, Set endNodes, ArcProcessor arcProcessor, NodeProcessor nodeProcessor) {
<span class="nc" id="L81">    this();</span>
<span class="nc" id="L82">    ArcProcessor arcProcessor2 = null;</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">    if (nodeProcessor != null) {</span>
<span class="nc" id="L84">      arcProcessor2 = new NodeProcessorWrappingArcProcessor(nodeProcessor);</span>
    }
<span class="nc bnc" id="L86" title="All 2 branches missed.">    for (Arc a : newArcs) {</span>
<span class="nc" id="L87">      a = new Arc(a); // make a copy</span>
<span class="nc bnc" id="L88" title="All 2 branches missed.">      if (arcProcessor != null) {</span>
<span class="nc" id="L89">        a = arcProcessor.processArc(a);</span>
      }
<span class="nc bnc" id="L91" title="All 2 branches missed.">      if (arcProcessor2 != null) {</span>
<span class="nc" id="L92">        a = arcProcessor2.processArc(a);</span>
      }
<span class="nc" id="L94">      addArc(a);</span>
<span class="nc" id="L95">    }</span>
<span class="nc bnc" id="L96" title="All 2 branches missed.">    if (nodeProcessor != null) {</span>
<span class="nc" id="L97">      this.startNode = nodeProcessor.processNode(startNode);</span>
    } else {
<span class="nc" id="L99">      this.startNode = startNode;</span>
    }
<span class="nc bnc" id="L101" title="All 2 branches missed.">    if (nodeProcessor != null) {</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">      if (endNodes != null) {</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">        for (Object o : endNodes) {</span>
<span class="nc" id="L104">          this.endNodes.add(nodeProcessor.processNode(o));</span>
<span class="nc" id="L105">        }</span>
      }
    } else {
<span class="nc bnc" id="L108" title="All 2 branches missed.">      if (endNodes != null) {</span>
<span class="nc" id="L109">        this.endNodes.addAll(endNodes);</span>
      }
    }
<span class="nc" id="L112">  }</span>

  /**
   * Uses the Arcs newArcs.
   */
  public TransducerGraph(Set&lt;Arc&gt; newArcs) {
<span class="nc" id="L118">    this(newArcs, null, null, null, null);</span>
<span class="nc" id="L119">  }</span>

  @Override
  public TransducerGraph clone() throws CloneNotSupportedException {
<span class="nc" id="L123">    super.clone();</span>
<span class="nc" id="L124">    TransducerGraph result = new TransducerGraph(this, (ArcProcessor) null);</span>
<span class="nc" id="L125">    return result;</span>
  }

  public Set&lt;Arc&gt; getArcs() {
<span class="nc" id="L129">    return arcs;</span>
  }

  /**
   * Just does union of keysets of maps.
   */
  public Set getNodes() {
<span class="nc" id="L136">    Set result = Generics.newHashSet();</span>
<span class="nc" id="L137">    result.addAll(arcsBySource.keySet());</span>
<span class="nc" id="L138">    result.addAll(arcsByTarget.keySet());</span>
<span class="nc" id="L139">    return result;</span>
  }

  public Set getInputs() {
<span class="nc" id="L143">    return arcsByInput.keySet();</span>
  }

  public void setStartNode(Object o) {
<span class="nc" id="L147">    startNode = o;</span>
<span class="nc" id="L148">  }</span>

  public void setEndNode(Object o) {
    //System.out.println(this + &quot; setting endNode to &quot; + o);
<span class="nc" id="L152">    endNodes.add(o);</span>
<span class="nc" id="L153">  }</span>

  public Object getStartNode() {
<span class="nc" id="L156">    return startNode;</span>
  }

  public Set getEndNodes() {
    //System.out.println(this + &quot; getting endNode &quot; + endNode);
<span class="nc" id="L161">    return endNodes;</span>
  }

  /**
   * Returns a Set of type TransducerGraph.Arc.
   */
  public Set&lt;Arc&gt; getArcsByInput(Object node) {
<span class="nc" id="L168">    return ensure(arcsByInput.get(node));</span>
  }

  /**
   * Returns a Set of type TransducerGraph.Arc.
   */
  public Set&lt;Arc&gt; getArcsBySource(Object node) {
<span class="nc" id="L175">    return ensure(arcsBySource.get(node));</span>
  }

  private static Set&lt;Arc&gt; ensure(Set&lt;Arc&gt; s) {
<span class="nc bnc" id="L179" title="All 2 branches missed.">    if (s == null) {</span>
<span class="nc" id="L180">      return Collections.emptySet();</span>
    }
<span class="nc" id="L182">    return s;</span>
  }

  /**
   * Returns a Set of type TransducerGraph.Arc.
   */
  public Set&lt;Arc&gt; getArcsByTarget(Object node) {
<span class="nc" id="L189">    return ensure(arcsByTarget.get(node));</span>
  }

  /**
   * Can only be one because automaton is deterministic.
   */
  public Arc getArcBySourceAndInput(Object node, Object input) {
<span class="nc" id="L196">    return arcsBySourceAndInput.get(Generics.newPair(node, input));</span>
  }

  /**
   * Returns a Set of type TransducerGraph.Arc.
   */
  public Set&lt;Arc&gt; getArcsByTargetAndInput(Object node, Object input) {
<span class="nc" id="L203">    return ensure(arcsByTargetAndInput.get(Generics.newPair(node, input)));</span>
  }

  /**
   * Slow implementation.
   */
  public Arc getArc(Object source, Object target) {
<span class="nc" id="L210">    Set arcsFromSource = arcsBySource.get(source);</span>
<span class="nc" id="L211">    Set arcsToTarget = arcsByTarget.get(target);</span>
<span class="nc" id="L212">    Set result = Generics.newHashSet();</span>
<span class="nc" id="L213">    result.addAll(arcsFromSource);</span>
<span class="nc" id="L214">    result.retainAll(arcsToTarget); // intersection</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">    if (result.size() &lt; 1) {</span>
<span class="nc" id="L216">      return null;</span>
    }
<span class="nc bnc" id="L218" title="All 2 branches missed.">    if (result.size() &gt; 1) {</span>
<span class="nc" id="L219">      throw new RuntimeException(&quot;Problem in TransducerGraph data structures.&quot;);</span>
    }
    // get the only member
<span class="nc" id="L222">    Iterator iterator = result.iterator();</span>
<span class="nc" id="L223">    return (Arc) iterator.next();</span>
  }

  /**
   * @return true if and only if it created a new Arc and added it to the graph.
   */
  public boolean addArc(Object source, Object target, Object input, Object output) {
<span class="nc" id="L230">    Arc a = new Arc(source, target, input, output);</span>
<span class="nc" id="L231">    return addArc(a);</span>
  }

  /**
   * @return true if and only if it added Arc a to the graph.
   *         determinism.
   */
  protected boolean addArc(Arc a) {
<span class="nc" id="L239">    Object source = a.getSourceNode();</span>
<span class="nc" id="L240">    Object target = a.getTargetNode();</span>
<span class="nc" id="L241">    Object input = a.getInput();</span>
<span class="nc bnc" id="L242" title="All 6 branches missed.">    if (source == null || target == null || input == null) {</span>
<span class="nc" id="L243">      return false;</span>
    }
    // add to data structures
<span class="nc bnc" id="L246" title="All 2 branches missed.">    if (arcs.contains(a)) {</span>
<span class="nc" id="L247">      return false;</span>
    }
    // it's new, so add to the rest of the data structures
    // add to source and input map
<span class="nc" id="L251">    Pair p = Generics.newPair(source, input);</span>
<span class="nc bnc" id="L252" title="All 4 branches missed.">    if (arcsBySourceAndInput.containsKey(p) &amp;&amp; checkDeterminism) {</span>
<span class="nc" id="L253">      throw new RuntimeException(&quot;Creating nondeterminism while inserting arc &quot; + a + &quot; because it already has arc &quot; + arcsBySourceAndInput.get(p) + checkDeterminism);</span>
    }
<span class="nc" id="L255">    arcsBySourceAndInput.put(p, a);</span>
<span class="nc" id="L256">    Maps.putIntoValueHashSet(arcsBySource, source, a);</span>
<span class="nc" id="L257">    p = Generics.newPair(target, input);</span>
<span class="nc" id="L258">    Maps.putIntoValueHashSet(arcsByTargetAndInput, p, a);</span>
<span class="nc" id="L259">    Maps.putIntoValueHashSet(arcsByTarget, target, a);</span>
<span class="nc" id="L260">    Maps.putIntoValueHashSet(arcsByInput, input, a);</span>
    // add to arcs
<span class="nc" id="L262">    arcs.add(a);</span>
<span class="nc" id="L263">    return true;</span>
  }

  public boolean removeArc(Arc a) {
<span class="nc" id="L267">    Object source = a.getSourceNode();</span>
<span class="nc" id="L268">    Object target = a.getTargetNode();</span>
<span class="nc" id="L269">    Object input = a.getInput();</span>
    // remove from arcs
<span class="nc bnc" id="L271" title="All 2 branches missed.">    if (!arcs.remove(a)) {</span>
<span class="nc" id="L272">      return false;</span>
    }
    // remove from arcsBySourceAndInput
<span class="nc" id="L275">    Pair p = Generics.newPair(source, input);</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">    if (!arcsBySourceAndInput.containsKey(p)) {</span>
<span class="nc" id="L277">      return false;</span>
    }
<span class="nc" id="L279">    arcsBySourceAndInput.remove(p);</span>
    // remove from arcsBySource
<span class="nc" id="L281">    Set&lt;Arc&gt; s = arcsBySource.get(source);</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">    if (s == null) {</span>
<span class="nc" id="L283">      return false;</span>
    }
<span class="nc bnc" id="L285" title="All 2 branches missed.">    if (!s.remove(a)) {</span>
<span class="nc" id="L286">      return false;</span>
    }
    // remove from arcsByTargetAndInput
<span class="nc" id="L289">    p = Generics.newPair(target, input);</span>
<span class="nc" id="L290">    s = arcsByTargetAndInput.get(p);</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">    if (s == null) {</span>
<span class="nc" id="L292">      return false;</span>
    }
<span class="nc bnc" id="L294" title="All 2 branches missed.">    if (!s.remove(a)) {</span>
<span class="nc" id="L295">      return false;</span>
    }
    // remove from arcsByTarget
<span class="nc" id="L298">    s = arcsByTarget.get(target);</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">    if (s == null) {</span>
<span class="nc" id="L300">      return false;</span>
    }
<span class="nc" id="L302">    s = arcsByInput.get(input);</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">    if (s == null) {</span>
<span class="nc" id="L304">      return false;</span>
    }
<span class="nc bnc" id="L306" title="All 2 branches missed.">    if (!s.remove(a)) {</span>
<span class="nc" id="L307">      return false;</span>
    }
<span class="nc" id="L309">    return true;</span>
  }

  public boolean canAddArc(Object source, Object target, Object input, Object output) {
<span class="nc" id="L313">    Arc a = new Arc(source, target, input, output);</span>
<span class="nc bnc" id="L314" title="All 2 branches missed.">    if (arcs.contains(a)) // inexpensive check</span>
    {
<span class="nc" id="L316">      return false;</span>
    }
<span class="nc" id="L318">    Pair p = Generics.newPair(source, input);</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">    return !arcsBySourceAndInput.containsKey(p); // expensive check</span>
  }

  /** An arc in a finite state transducer.
   *
   *  @param &lt;NODE&gt; The type of the nodes that an Arc links
   *  @param &lt;IN&gt; The type of the input language of the transducer
   *  @param &lt;OUT&gt; The type of the output language of the transducer
   */
  public static class Arc&lt;NODE, IN, OUT&gt; {

    private NODE sourceNode;
    private NODE targetNode;
    private IN input;
    private OUT output;

    public NODE getSourceNode() {
<span class="nc" id="L336">      return sourceNode;</span>
    }

    public NODE getTargetNode() {
<span class="nc" id="L340">      return targetNode;</span>
    }

    public IN getInput() {
<span class="nc" id="L344">      return input;</span>
    }

    public OUT getOutput() {
<span class="nc" id="L348">      return output;</span>
    }

    public void setSourceNode(NODE o) {
<span class="nc" id="L352">      sourceNode = o;</span>
<span class="nc" id="L353">    }</span>

    public void setTargetNode(NODE o) {
<span class="nc" id="L356">      targetNode = o;</span>
<span class="nc" id="L357">    }</span>

    public void setInput(IN o) {
<span class="nc" id="L360">      input = o;</span>
<span class="nc" id="L361">    }</span>

    public void setOutput(OUT o) {
<span class="nc" id="L364">      output = o;</span>
<span class="nc" id="L365">    }</span>

    @Override
    public int hashCode() {
<span class="nc" id="L369">      return sourceNode.hashCode() ^ (targetNode.hashCode() &lt;&lt; 16) ^ (input.hashCode() &lt;&lt; 16);</span>
    }

    @Override
    public boolean equals(Object o) {
<span class="nc bnc" id="L374" title="All 2 branches missed.">      if (o == this) {</span>
<span class="nc" id="L375">        return true;</span>
      }
<span class="nc bnc" id="L377" title="All 2 branches missed.">      if (!(o instanceof Arc)) {</span>
<span class="nc" id="L378">        return false;</span>
      }
<span class="nc" id="L380">      Arc a = (Arc) o;</span>
<span class="nc bnc" id="L381" title="All 18 branches missed.">      return ((sourceNode == null ? a.sourceNode == null : sourceNode.equals(a.sourceNode)) &amp;&amp; (targetNode == null ? a.targetNode == null : targetNode.equals(a.targetNode)) &amp;&amp; (input == null ? a.input == null : input.equals(a.input)));</span>
    }

    // makes a copy of Arc a
    protected Arc(Arc&lt;NODE,IN,OUT&gt; a) {
<span class="nc" id="L386">      this(a.getSourceNode(), a.getTargetNode(), a.getInput(), a.getOutput());</span>
<span class="nc" id="L387">    }</span>

    protected Arc(NODE sourceNode, NODE targetNode) {
<span class="nc" id="L390">      this(sourceNode, targetNode, null, null);</span>
<span class="nc" id="L391">    }</span>

    protected Arc(NODE sourceNode, NODE targetNode, IN input) {
<span class="nc" id="L394">      this(sourceNode, targetNode, input, null);</span>
<span class="nc" id="L395">    }</span>

<span class="nc" id="L397">    protected Arc(NODE sourceNode, NODE targetNode, IN input, OUT output) {</span>
<span class="nc" id="L398">      this.sourceNode = sourceNode;</span>
<span class="nc" id="L399">      this.targetNode = targetNode;</span>
<span class="nc" id="L400">      this.input = input;</span>
<span class="nc" id="L401">      this.output = output;</span>
<span class="nc" id="L402">    }</span>

    @Override
    public String toString() {
<span class="nc" id="L406">      return sourceNode + &quot; --&gt; &quot; + targetNode + &quot; (&quot; + input + &quot; : &quot; + output + &quot;)&quot;;</span>
    }

  } // end static class Arc


  public static interface ArcProcessor {
    /**
     * Modifies Arc a.
     */
    public Arc processArc(Arc a);
  }

<span class="nc" id="L419">  public static class OutputCombiningProcessor implements ArcProcessor {</span>
    @Override
    public Arc processArc(Arc a) {
<span class="nc" id="L422">      a = new Arc(a);</span>
<span class="nc" id="L423">      a.setInput(Generics.newPair(a.getInput(), a.getOutput()));</span>
<span class="nc" id="L424">      a.setOutput(null);</span>
<span class="nc" id="L425">      return a;</span>
    }
  }

<span class="nc" id="L429">  public static class InputSplittingProcessor implements ArcProcessor {</span>
    @Override
    public Arc processArc(Arc a) {
<span class="nc" id="L432">      a = new Arc(a);</span>
<span class="nc" id="L433">      Pair p = (Pair) a.getInput();</span>
<span class="nc" id="L434">      a.setInput(p.first);</span>
<span class="nc" id="L435">      a.setOutput(p.second);</span>
<span class="nc" id="L436">      return a;</span>
    }
  }

  public static class NodeProcessorWrappingArcProcessor implements ArcProcessor {
    private final NodeProcessor nodeProcessor;

<span class="nc" id="L443">    public NodeProcessorWrappingArcProcessor(NodeProcessor nodeProcessor) {</span>
<span class="nc" id="L444">      this.nodeProcessor = nodeProcessor;</span>
<span class="nc" id="L445">    }</span>

    @Override
    public Arc processArc(Arc a) {
<span class="nc" id="L449">      a = new Arc(a);</span>
<span class="nc" id="L450">      a.setSourceNode(nodeProcessor.processNode(a.getSourceNode()));</span>
<span class="nc" id="L451">      a.setTargetNode(nodeProcessor.processNode(a.getTargetNode()));</span>
<span class="nc" id="L452">      return a;</span>
    }
  }

  public static interface NodeProcessor {
    public Object processNode(Object node);
  }

  public static class SetToStringNodeProcessor implements NodeProcessor {
    private TreebankLanguagePack tlp;

<span class="nc" id="L463">    public SetToStringNodeProcessor(TreebankLanguagePack tlp) {</span>
<span class="nc" id="L464">      this.tlp = tlp;</span>
<span class="nc" id="L465">    }</span>

    @Override
    public Object processNode(Object node) {
<span class="nc" id="L469">      Set s = null;</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">      if (node instanceof Set) {</span>
<span class="nc" id="L471">        s = (Set) node;</span>
      } else {
<span class="nc bnc" id="L473" title="All 2 branches missed.">        if (node instanceof Block) {</span>
<span class="nc" id="L474">          Block b = (Block) node;</span>
<span class="nc" id="L475">          s = b.getMembers();</span>
<span class="nc" id="L476">        } else {</span>
<span class="nc" id="L477">          throw new RuntimeException(&quot;Unexpected node class&quot;);</span>
        }
      }
<span class="nc" id="L480">      Object sampleNode = s.iterator().next();</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">      if (s.size() == 1) {</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">        if (sampleNode instanceof Block) {</span>
<span class="nc" id="L483">          return processNode(sampleNode);</span>
        } else {
<span class="nc" id="L485">          return sampleNode;</span>
        }
      }
      // nope there's a set of things
<span class="nc bnc" id="L489" title="All 2 branches missed.">      if (sampleNode instanceof String) {</span>
<span class="nc" id="L490">        String str = (String) sampleNode;</span>
<span class="nc bnc" id="L491" title="All 2 branches missed.">        if (str.charAt(0) != '@') {</span>
          // passive category...
<span class="nc" id="L493">          return tlp.basicCategory(str) + &quot;-&quot; + s.hashCode(); // TODO remove b/c there could be collisions</span>
          //          return tlp.basicCategory(str) + &quot;-&quot; + System.identityHashCode(s);
        }
      }
<span class="nc" id="L497">      return &quot;@NodeSet-&quot; + s.hashCode(); // TODO remove b/c there could be collisions</span>
      //      return sampleNode.toString();
    }
  }

<span class="nc" id="L502">  public static class ObjectToSetNodeProcessor implements NodeProcessor {</span>
    @Override
    public Object processNode(Object node) {
<span class="nc" id="L505">      return Collections.singleton(node);</span>
    }
  }

  public static interface GraphProcessor {
    public TransducerGraph processGraph(TransducerGraph g);
  }


  public static class NormalizingGraphProcessor implements GraphProcessor {
<span class="nc" id="L515">    boolean forward = true;</span>

<span class="nc" id="L517">    public NormalizingGraphProcessor(boolean forwardNormalization) {</span>
<span class="nc" id="L518">      this.forward = forwardNormalization;</span>
<span class="nc" id="L519">    }</span>

    public TransducerGraph processGraph(TransducerGraph g) {
<span class="nc" id="L522">      g = new TransducerGraph(g);</span>
<span class="nc" id="L523">      Set nodes = g.getNodes();</span>
<span class="nc bnc" id="L524" title="All 2 branches missed.">      for (Object node : nodes) {</span>
<span class="nc" id="L525">        Set&lt;Arc&gt; myArcs = null;</span>
<span class="nc bnc" id="L526" title="All 2 branches missed.">        if (forward) {</span>
<span class="nc" id="L527">          myArcs = g.getArcsBySource(node);</span>
        } else {
<span class="nc" id="L529">          myArcs = g.getArcsByTarget(node);</span>
        }
        // compute a total
<span class="nc" id="L532">        double total = 0.0;</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">        for (Arc a : myArcs) {</span>
<span class="nc" id="L534">          total += ((Double) a.getOutput()).doubleValue();</span>
<span class="nc" id="L535">        }</span>
        // divide each by total
<span class="nc bnc" id="L537" title="All 2 branches missed.">        for (Arc a : myArcs) {</span>
<span class="nc" id="L538">          a.setOutput(new Double(Math.log(((Double) a.getOutput()).doubleValue() / total)));</span>
<span class="nc" id="L539">        }</span>
<span class="nc" id="L540">      }</span>
<span class="nc" id="L541">      return g;</span>
    }
  }

  @Override
  public String toString() {
<span class="nc" id="L547">    StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L548">    depthFirstSearch(true, sb);</span>
<span class="nc" id="L549">    return sb.toString();</span>
  }


<span class="nc" id="L553">  private boolean dotWeightInverted = false;</span>

  private void setDotWeightingInverted(boolean inverted) {
<span class="nc" id="L556">    dotWeightInverted = true;</span>
<span class="nc" id="L557">  }</span>

  public String asDOTString() {
<span class="nc" id="L560">    NumberFormat nf = NumberFormat.getNumberInstance();</span>
<span class="nc" id="L561">    nf.setMaximumFractionDigits(3);</span>
<span class="nc" id="L562">    nf.setMinimumFractionDigits(1);</span>
<span class="nc" id="L563">    StringBuilder result = new StringBuilder();</span>
<span class="nc" id="L564">    Set nodes = getNodes();</span>
<span class="nc" id="L565">    result.append(&quot;digraph G {\n&quot;);</span>
    //    result.append(&quot;page = \&quot;8.5,11\&quot;;\n&quot;);
    //    result.append(&quot;margin = \&quot;0.25\&quot;;\n&quot;);
    // Heuristic number of pages
<span class="nc" id="L569">    int sz = arcs.size();</span>
<span class="nc" id="L570">    int ht = 105;</span>
<span class="nc" id="L571">    int mag = 250;</span>
<span class="nc bnc" id="L572" title="All 2 branches missed.">    while (sz &gt; mag) {</span>
<span class="nc" id="L573">      ht += 105;</span>
<span class="nc" id="L574">      mag *= 2;</span>
    }
<span class="nc" id="L576">    int wd = 8;</span>
<span class="nc" id="L577">    mag = 500;</span>
<span class="nc bnc" id="L578" title="All 2 branches missed.">    while (sz &gt; mag) {</span>
<span class="nc" id="L579">      wd += 8;</span>
<span class="nc" id="L580">      mag *= 4;</span>
    }
<span class="nc" id="L582">    double htd = ht / 10.0;</span>
<span class="nc" id="L583">    result.append(&quot;size = \&quot;&quot; + wd + &quot;,&quot; + htd + &quot;\&quot;;\n&quot;);</span>
<span class="nc" id="L584">    result.append(&quot;graph [rankdir = \&quot;LR\&quot;];\n&quot;);</span>
<span class="nc" id="L585">    result.append(&quot;graph [ranksep = \&quot;0.2\&quot;];\n&quot;);</span>
<span class="nc bnc" id="L586" title="All 2 branches missed.">    for (Object node : nodes) {</span>
<span class="nc" id="L587">      String cleanString = StringUtils.fileNameClean(node.toString());</span>
<span class="nc" id="L588">      result.append(cleanString);</span>
<span class="nc" id="L589">      result.append(&quot; [ &quot;);</span>
      //      if (getEndNodes().contains(node)) {
      //        result.append(&quot;label=\&quot;&quot; + node.toString() + &quot;\&quot;, style=filled, &quot;);
      //      } else
<span class="nc" id="L593">      result.append(&quot;label=\&quot;&quot; + node.toString() + &quot;\&quot;&quot;);</span>
<span class="nc" id="L594">      result.append(&quot;height=\&quot;0.3\&quot;, width=\&quot;0.3\&quot;&quot;);</span>
<span class="nc" id="L595">      result.append(&quot; ];\n&quot;);</span>
<span class="nc bnc" id="L596" title="All 2 branches missed.">      for (Arc arc : getArcsBySource(node)) {</span>
<span class="nc" id="L597">        result.append(StringUtils.fileNameClean(arc.getSourceNode().toString()));</span>
<span class="nc" id="L598">        result.append(&quot; -&gt; &quot;);</span>
<span class="nc" id="L599">        result.append(StringUtils.fileNameClean(arc.getTargetNode().toString()));</span>
<span class="nc" id="L600">        result.append(&quot; [ &quot;);</span>
<span class="nc" id="L601">        result.append(&quot;label=\&quot;&quot;);</span>
<span class="nc" id="L602">        result.append(arc.getInput());</span>
<span class="nc" id="L603">        result.append(&quot; : &quot;);</span>
        // result.append(arc.getOutput());
<span class="nc" id="L605">        Object output = arc.getOutput();</span>
<span class="nc" id="L606">        String wt = &quot;&quot;;</span>
<span class="nc bnc" id="L607" title="All 2 branches missed.">        if (output instanceof Number) {</span>
<span class="nc" id="L608">          double dd = ((Number) output).doubleValue();</span>
<span class="nc bnc" id="L609" title="All 2 branches missed.">          if (dd == -0.0d) {</span>
<span class="nc" id="L610">            result.append(nf.format(0.0d));</span>
          } else {
<span class="nc" id="L612">            result.append(nf.format(output));</span>
          }
          int weight;
<span class="nc bnc" id="L615" title="All 2 branches missed.">          if (dotWeightInverted) {</span>
<span class="nc" id="L616">            weight = (int) (20.0 - dd);</span>
          } else {
<span class="nc" id="L618">            weight = (int) dd;</span>
          }
<span class="nc bnc" id="L620" title="All 2 branches missed.">          if (weight &gt; 0) {</span>
<span class="nc" id="L621">            wt = &quot;, weight = \&quot;&quot; + weight + &quot;\&quot;&quot;;</span>
          }
<span class="nc bnc" id="L623" title="All 8 branches missed.">          if (dotWeightInverted &amp;&amp; dd &lt;= 2.0 || (!dotWeightInverted) &amp;&amp; dd &gt;= 20.0) {</span>
<span class="nc" id="L624">            wt += &quot;, style=bold&quot;;</span>
          }
<span class="nc" id="L626">        } else {</span>
<span class="nc" id="L627">          result.append(output);</span>
        }
<span class="nc" id="L629">        result.append(&quot;\&quot;&quot;);</span>
<span class="nc" id="L630">        result.append(wt);</span>
        // result.append(&quot;fontsize = 14 &quot;);
<span class="nc bnc" id="L632" title="All 2 branches missed.">        if (arc.getInput().toString().equals(&quot;EPSILON&quot;)) {</span>
<span class="nc" id="L633">          result.append(&quot;, style = \&quot;dashed\&quot; &quot;);</span>
        } else {
<span class="nc" id="L635">          result.append(&quot;, style = \&quot;solid\&quot; &quot;);</span>
        }
        // result.append(&quot;, weight = \&quot;&quot; + arc.getOutput() + &quot;\&quot; &quot;);
<span class="nc" id="L638">        result.append(&quot;];\n&quot;);</span>
<span class="nc" id="L639">      }</span>
<span class="nc" id="L640">    }</span>
<span class="nc" id="L641">    result.append(&quot;}\n&quot;);</span>
<span class="nc" id="L642">    return result.toString();</span>
  }

  public double inFlow(Object node) {
<span class="nc" id="L646">    Set&lt;Arc&gt; arcs = getArcsByTarget(node);</span>
<span class="nc" id="L647">    return sumOutputs(arcs);</span>
  }

  public double outFlow(Object node) {
<span class="nc" id="L651">    Set&lt;Arc&gt; arcs = getArcsBySource(node);</span>
<span class="nc" id="L652">    return sumOutputs(arcs);</span>
  }

  private static double sumOutputs(Set&lt;Arc&gt; arcs) {
<span class="nc" id="L656">    double sum = 0.0;</span>
<span class="nc bnc" id="L657" title="All 2 branches missed.">    for (Arc arc : arcs) {</span>
<span class="nc" id="L658">      sum += ((Double) arc.getOutput()).doubleValue();</span>
<span class="nc" id="L659">    }</span>
<span class="nc" id="L660">    return sum;</span>
  }

  private double getSourceTotal(Object node) {
<span class="nc" id="L664">    double result = 0.0;</span>
<span class="nc" id="L665">    Set&lt;Arc&gt; arcs = getArcsBySource(node);</span>
<span class="nc bnc" id="L666" title="All 2 branches missed.">    if (arcs.isEmpty()) {</span>
<span class="nc" id="L667">      log.info(&quot;No outbound arcs from node.&quot;);</span>
<span class="nc" id="L668">      return result;</span>
    }
<span class="nc bnc" id="L670" title="All 2 branches missed.">    for (Arc arc : arcs) {</span>
<span class="nc" id="L671">      result += ((Double) arc.getOutput()).doubleValue();</span>
<span class="nc" id="L672">    }</span>
<span class="nc" id="L673">    return result;</span>
  }

  /**
   * For testing only.  Doubles combined by addition.
   */
  public double getOutputOfPathInGraph(List path) {
<span class="nc" id="L680">    double score = 0.0;</span>
<span class="nc" id="L681">    Object node = getStartNode();</span>
<span class="nc bnc" id="L682" title="All 2 branches missed.">    for (Object input : path) {</span>
<span class="nc" id="L683">      Arc arc = getArcBySourceAndInput(node, input); // next input in path</span>
<span class="nc bnc" id="L684" title="All 2 branches missed.">      if (arc == null) {</span>
<span class="nc" id="L685">        System.out.println(&quot; NOT ACCEPTED :&quot; + path);</span>
<span class="nc" id="L686">        return Double.NEGATIVE_INFINITY;</span>
      }
<span class="nc" id="L688">      score += ((Double) arc.getOutput()).doubleValue();</span>
<span class="nc" id="L689">      node = arc.getTargetNode();</span>
<span class="nc" id="L690">    }</span>
<span class="nc" id="L691">    return score;</span>
  }

  /**
   * for testing only. doubles combined by addition.
   */
  public List sampleUniformPathFromGraph() {
<span class="nc" id="L698">    List list = new ArrayList();</span>
<span class="nc" id="L699">    Object node = this.getStartNode();</span>
<span class="nc" id="L700">    Set endNodes = this.getEndNodes();</span>
<span class="nc bnc" id="L701" title="All 2 branches missed.">    while (!endNodes.contains(node)) {</span>
<span class="nc" id="L702">      List&lt;Arc&gt; arcs = new ArrayList&lt;&gt;(this.getArcsBySource(node));</span>
<span class="nc" id="L703">      TransducerGraph.Arc arc = arcs.get(r.nextInt(arcs.size()));</span>
<span class="nc" id="L704">      list.add(arc.getInput());</span>
<span class="nc" id="L705">      node = arc.getTargetNode();</span>
<span class="nc" id="L706">    }</span>
<span class="nc" id="L707">    return list;</span>
  }

  private Map&lt;List, Double&gt; samplePathsFromGraph(int numPaths) {
<span class="nc" id="L711">    Map&lt;List, Double&gt; result = Generics.newHashMap();</span>
<span class="nc bnc" id="L712" title="All 2 branches missed.">    for (int i = 0; i &lt; numPaths; i++) {</span>
<span class="nc" id="L713">      List l = sampleUniformPathFromGraph();</span>
<span class="nc" id="L714">      result.put(l, new Double(getOutputOfPathInGraph(l)));</span>
    }
<span class="nc" id="L716">    return result;</span>
  }

  /**
   * For testing only.
   */
  private static void printPathOutputs(List&lt;List&gt; pathList, TransducerGraph graph, boolean printPaths) {
<span class="nc" id="L723">    int i = 0;</span>
<span class="nc bnc" id="L724" title="All 2 branches missed.">    for (List path : pathList) {</span>
<span class="nc bnc" id="L725" title="All 2 branches missed.">      if (printPaths) {</span>
<span class="nc bnc" id="L726" title="All 2 branches missed.">        for (Object aPath : path) {</span>
<span class="nc" id="L727">          System.out.print(aPath + &quot; &quot;);</span>
<span class="nc" id="L728">        }</span>
      } else {
<span class="nc" id="L730">        System.out.print(i++ + &quot; &quot;);</span>
      }
<span class="nc" id="L732">      System.out.print(&quot;output: &quot; + graph.getOutputOfPathInGraph(path));</span>
<span class="nc" id="L733">      System.out.println();</span>
<span class="nc" id="L734">    }</span>
<span class="nc" id="L735">  }</span>

  /**
   * For testing only.
   */
  public List&lt;Double&gt; getPathOutputs(List&lt;List&gt; pathList) {
<span class="nc" id="L741">    List&lt;Double&gt; outputList = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L742" title="All 2 branches missed.">    for (List path : pathList) {</span>
<span class="nc" id="L743">      outputList.add(new Double(getOutputOfPathInGraph(path)));</span>
<span class="nc" id="L744">    }</span>
<span class="nc" id="L745">    return outputList;</span>
  }

  public static boolean testGraphPaths(TransducerGraph sourceGraph, TransducerGraph testGraph, int numPaths) {
<span class="nc bnc" id="L749" title="All 2 branches missed.">    for (int i = 0; i &lt; numPaths; i++) {</span>
<span class="nc" id="L750">      List path = sourceGraph.sampleUniformPathFromGraph();</span>
<span class="nc" id="L751">      double score = sourceGraph.getOutputOfPathInGraph(path);</span>
<span class="nc" id="L752">      double newScore = testGraph.getOutputOfPathInGraph(path);</span>
<span class="nc bnc" id="L753" title="All 2 branches missed.">      if ((score - newScore) / (score + newScore) &gt; 1e-10) {</span>
<span class="nc" id="L754">        System.out.println(&quot;Problem: &quot; + score + &quot; vs. &quot; + newScore + &quot; on &quot; + path);</span>
<span class="nc" id="L755">        return false;</span>
      }
    }
<span class="nc" id="L758">    return true;</span>
  }


  /**
   * For testing only.  Doubles combined by multiplication.
   */
  private boolean canAddPath(List path) {
<span class="nc" id="L766">    Object node = this.getStartNode();</span>
<span class="nc bnc" id="L767" title="All 2 branches missed.">    for (int j = 0; j &lt; path.size() - 1; j++) {</span>
<span class="nc" id="L768">      Object input = path.get(j);</span>
<span class="nc" id="L769">      Arc arc = this.getArcBySourceAndInput(node, input); // next input in path</span>
<span class="nc bnc" id="L770" title="All 2 branches missed.">      if (arc == null) {</span>
<span class="nc" id="L771">        return true;</span>
      }
<span class="nc" id="L773">      node = arc.getTargetNode();</span>
    }
<span class="nc" id="L775">    Object input = path.get(path.size() - 1); // last element</span>
<span class="nc" id="L776">    Arc arc = this.getArcBySourceAndInput(node, input); // next input in path</span>
<span class="nc bnc" id="L777" title="All 2 branches missed.">    if (arc == null) {</span>
<span class="nc" id="L778">      return true;</span>
    } else {
<span class="nc" id="L780">      return getEndNodes().contains(arc.getTargetNode());</span>
    }
  }

  /**
   * If markovOrder is zero, we always transition back to the start state
   * If markovOrder is negative, we assume that it is infinite
   */
  public static TransducerGraph createGraphFromPaths(List paths, int markovOrder) {
<span class="nc" id="L789">    ClassicCounter pathCounter = new ClassicCounter();</span>
<span class="nc bnc" id="L790" title="All 2 branches missed.">    for (Object o : paths) {</span>
<span class="nc" id="L791">      pathCounter.incrementCount(o);</span>
<span class="nc" id="L792">    }</span>
<span class="nc" id="L793">    return createGraphFromPaths(pathCounter, markovOrder);</span>
  }

  public static &lt;T&gt; TransducerGraph createGraphFromPaths(ClassicCounter&lt;List&lt;T&gt;&gt; pathCounter, int markovOrder) {
<span class="nc" id="L797">    TransducerGraph graph = new TransducerGraph(); // empty</span>
<span class="nc bnc" id="L798" title="All 2 branches missed.">    for (List&lt;T&gt; path : pathCounter.keySet()) {</span>
<span class="nc" id="L799">      double count = pathCounter.getCount(path);</span>
<span class="nc" id="L800">      addOnePathToGraph(path, count, markovOrder, graph);</span>
<span class="nc" id="L801">    }</span>
<span class="nc" id="L802">    return graph;</span>
  }

  // assumes that the path already has EPSILON as the last element.
  public static void addOnePathToGraph(List path, double count, int markovOrder, TransducerGraph graph) {
<span class="nc" id="L807">    Object source = graph.getStartNode();</span>
<span class="nc bnc" id="L808" title="All 2 branches missed.">    for (int j = 0; j &lt; path.size(); j++) {</span>
<span class="nc" id="L809">      Object input = path.get(j);</span>
<span class="nc" id="L810">      Arc a = graph.getArcBySourceAndInput(source, input);</span>
<span class="nc bnc" id="L811" title="All 2 branches missed.">      if (a != null) {</span>
        // increment the arc weight
<span class="nc" id="L813">        a.output = new Double(((Double) a.output).doubleValue() + count);</span>
      } else {
        Object target;
<span class="nc bnc" id="L816" title="All 2 branches missed.">        if (input.equals(TransducerGraph.EPSILON_INPUT)) {</span>
<span class="nc" id="L817">          target = &quot;END&quot;; // to ensure they all share the same end node</span>
<span class="nc bnc" id="L818" title="All 2 branches missed.">        } else if (markovOrder == 0) {</span>
          // we all transition back to the same state
<span class="nc" id="L820">          target = source;</span>
<span class="nc bnc" id="L821" title="All 2 branches missed.">        } else if (markovOrder &gt; 0) {</span>
          // the state is described by the partial history
<span class="nc bnc" id="L823" title="All 2 branches missed.">          target = path.subList((j &lt; markovOrder ? 0 : j - markovOrder + 1), j + 1);</span>
        } else {
          // the state is described by the full history
<span class="nc" id="L826">          target = path.subList(0, j + 1);</span>
        }
<span class="nc" id="L828">        Double output = new Double(count);</span>
<span class="nc" id="L829">        a = new Arc(source, target, input, output);</span>
<span class="nc" id="L830">        graph.addArc(a);</span>
      }
<span class="nc" id="L832">      source = a.getTargetNode();</span>
    }
<span class="nc" id="L834">    graph.setEndNode(source);</span>
<span class="nc" id="L835">  }</span>

  /**
   * For testing only. All paths will be added to pathList as Lists.
   * // generate a bunch of paths through the graph with the input alphabet
   * // and create new nodes for each one.
   */
  public static TransducerGraph createRandomGraph(int numPaths, int pathLengthMean, double pathLengthVariance, int numInputs, List pathList) {
    // compute the path length. Draw from a normal distribution
<span class="nc" id="L844">    int pathLength = (int) (r.nextGaussian() * pathLengthVariance + pathLengthMean);</span>
<span class="nc bnc" id="L845" title="All 2 branches missed.">    for (int i = 0; i &lt; numPaths; i++) {</span>
      // make a path
<span class="nc" id="L847">      List path = new ArrayList();</span>
<span class="nc bnc" id="L848" title="All 2 branches missed.">      for (int j = 0; j &lt; pathLength; j++) {</span>
<span class="nc" id="L849">        String input = Integer.toString(r.nextInt(numInputs));</span>
<span class="nc" id="L850">        path.add(input);</span>
      }
      // TODO: createRandomPaths had the following difference:
      // we're done, add one more arc to get to the endNode.
      //input = TransducerGraph.EPSILON_INPUT;
      //path.add(input);
<span class="nc" id="L856">      pathList.add(path);</span>
    }
<span class="nc" id="L858">    return createGraphFromPaths(pathList, -1);</span>
  }

  public static List createRandomPaths(int numPaths, int pathLengthMean, double pathLengthVariance, int numInputs) {
<span class="nc" id="L862">    List pathList = new ArrayList();</span>
    // make a bunch of paths, randomly
    // compute the path length. Draw from a normal distribution
<span class="nc" id="L865">    int pathLength = (int) (r.nextGaussian() * pathLengthVariance + pathLengthMean);</span>
<span class="nc bnc" id="L866" title="All 2 branches missed.">    for (int i = 0; i &lt; numPaths; i++) {</span>
      // make a path
<span class="nc" id="L868">      List&lt;String&gt; path = new ArrayList&lt;&gt;();</span>
      String input;
<span class="nc bnc" id="L870" title="All 2 branches missed.">      for (int j = 0; j &lt; pathLength; j++) {</span>
<span class="nc" id="L871">        input = Integer.toString(r.nextInt(numInputs));</span>
<span class="nc" id="L872">        path.add(input);</span>
      }
      // we're done, add one more arc to get to the endNode.
<span class="nc" id="L875">      input = TransducerGraph.EPSILON_INPUT;</span>
<span class="nc" id="L876">      path.add(input);</span>
<span class="nc" id="L877">      pathList.add(path);</span>
    }
<span class="nc" id="L879">    return pathList;</span>
  }

  public void depthFirstSearch(boolean forward, StringBuilder b) {
<span class="nc bnc" id="L883" title="All 2 branches missed.">    if (forward) {</span>
<span class="nc" id="L884">      depthFirstSearchHelper(getStartNode(), new HashSet(), 0, true, b);</span>
    } else {
<span class="nc bnc" id="L886" title="All 2 branches missed.">      for (Object o : getEndNodes()) {</span>
<span class="nc" id="L887">        depthFirstSearchHelper(o, new HashSet(), 0, false, b);</span>
<span class="nc" id="L888">      }</span>
    }
<span class="nc" id="L890">  }</span>

  /**
   * For testing only.
   */
  private void depthFirstSearchHelper(Object node, Set marked, int level, boolean forward, StringBuilder b) {
<span class="nc bnc" id="L896" title="All 2 branches missed.">    if (marked.contains(node)) {</span>
<span class="nc" id="L897">      return;</span>
    }
<span class="nc" id="L899">    marked.add(node);</span>
    Set&lt;Arc&gt; arcs;
<span class="nc bnc" id="L901" title="All 2 branches missed.">    if (forward) {</span>
<span class="nc" id="L902">      arcs = this.getArcsBySource(node);</span>
    } else {
<span class="nc" id="L904">      arcs = this.getArcsByTarget(node);</span>
    }
<span class="nc bnc" id="L906" title="All 2 branches missed.">    if (arcs == null) {</span>
<span class="nc" id="L907">      return;</span>
    }
<span class="nc bnc" id="L909" title="All 2 branches missed.">    for (Arc newArc : arcs) {</span>
      // print it out
<span class="nc bnc" id="L911" title="All 2 branches missed.">      for (int i = 0; i &lt; level; i++) {</span>
<span class="nc" id="L912">        b.append(&quot;  &quot;);</span>
      }
<span class="nc bnc" id="L914" title="All 2 branches missed.">      if (getEndNodes().contains(newArc.getTargetNode())) {</span>
<span class="nc" id="L915">        b.append(newArc + &quot; END\n&quot;);</span>
      } else {
<span class="nc" id="L917">        b.append(newArc + &quot;\n&quot;);</span>
      }
<span class="nc bnc" id="L919" title="All 2 branches missed.">      if (forward) {</span>
<span class="nc" id="L920">        depthFirstSearchHelper(newArc.getTargetNode(), marked, level + 1, forward, b);</span>
      } else {
<span class="nc" id="L922">        depthFirstSearchHelper(newArc.getSourceNode(), marked, level + 1, forward, b);</span>
      }
<span class="nc" id="L924">    }</span>
<span class="nc" id="L925">  }</span>

  /**
   * For testing only.
   */
  public static void main(String[] args) {
<span class="nc" id="L931">    List pathList = new ArrayList();</span>
<span class="nc" id="L932">    TransducerGraph graph = createRandomGraph(1000, 10, 0.0, 10, pathList);</span>
<span class="nc" id="L933">    System.out.println(&quot;Done creating random graph&quot;);</span>
<span class="nc" id="L934">    printPathOutputs(pathList, graph, true);</span>
<span class="nc" id="L935">    System.out.println(&quot;Depth first search from start node&quot;);</span>
<span class="nc" id="L936">    StringBuilder b = new StringBuilder();</span>
<span class="nc" id="L937">    graph.depthFirstSearch(true, b);</span>
<span class="nc" id="L938">    System.out.println(b.toString());</span>
<span class="nc" id="L939">    b = new StringBuilder();</span>
<span class="nc" id="L940">    System.out.println(&quot;Depth first search back from end node&quot;);</span>
<span class="nc" id="L941">    graph.depthFirstSearch(false, b);</span>
<span class="nc" id="L942">    System.out.println(b.toString());</span>
<span class="nc" id="L943">  }</span>

}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>