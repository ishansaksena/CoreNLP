<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ExtractorFramesRare.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.tagger.maxent</a> &gt; <span class="el_source">ExtractorFramesRare.java</span></div><h1>ExtractorFramesRare.java</h1><pre class="source lang-java linenums">// ExtractorFramesRare -- StanfordMaxEnt, A Maximum Entropy Toolkit
// Copyright (c) 2002-2008 The Board of Trustees of
// Leland Stanford Junior University. All rights reserved.

//This program is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either version 2
//of the License, or (at your option) any later version.

//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.

//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

//For more information, bug reports, fixes, contact:
//Christopher Manning
//Dept of Computer Science, Gates 1A
//Stanford CA 94305-9010
//USA
//    Support/Questions: java-nlp-user@lists.stanford.edu
//    Licensing: java-nlp-support@lists.stanford.edu
//http://www-nlp.stanford.edu/software/tagger.shtml

package edu.stanford.nlp.tagger.maxent;

import edu.stanford.nlp.international.french.FrenchUnknownWordSignatures;
import edu.stanford.nlp.international.spanish.SpanishUnknownWordSignatures;
import edu.stanford.nlp.international.spanish.SpanishVerbStripper;
import edu.stanford.nlp.util.Generics;
import edu.stanford.nlp.util.StringUtils;

import java.util.*;


/**
 * This class contains feature extractors for the MaxentTagger that are only
 * applied to rare (low frequency/unknown) words.
 * The following options are supported:
 * &lt;table&gt;
 * &lt;tr&gt;&lt;td&gt;Name&lt;/td&gt;&lt;td&gt;Args&lt;/td&gt;&lt;td&gt;Effect&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;wordshapes&lt;/td&gt;&lt;td&gt;left, right&lt;/td&gt;
 *     &lt;td&gt;Word shape features, e.g., transform Foo5 into Xxx#
 *         (not exactly like that, but that general idea).
 *         Creates individual features for each word left ... right.
 *         If just one argument wordshapes(-2) is given, then end is taken as 0.
  *        If left is not less than or equal to right, no features are made.
 *         Fairly English-specific.&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;unicodeshapes&lt;/td&gt;&lt;td&gt;left, right&lt;/td&gt;
 *     &lt;td&gt;Same thing, but works for unicode characters generally.&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;unicodeshapeconjunction&lt;/td&gt;&lt;td&gt;left, right&lt;/td&gt;
 *     &lt;td&gt;Instead of individual word shape features, combines several
 *         word shapes into one feature.&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;suffix&lt;/td&gt;&lt;td&gt;length, position&lt;/td&gt;
 *     &lt;td&gt;Features for suffixes of the word position.  One feature for
 *         each suffix of length 1 ... length.&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;prefix&lt;/td&gt;&lt;td&gt;length, position&lt;/td&gt;
 *     &lt;td&gt;Features for prefixes of the word position.  One feature for
 *         each prefix of length 1 ... length.&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;prefixsuffix&lt;/td&gt;&lt;td&gt;length&lt;/td&gt;
 *     &lt;td&gt;Features for concatenated prefix and suffix.  One feature for
 *         each of length 1 ... length.&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;capitalizationsuffix&lt;/td&gt;&lt;td&gt;length&lt;/td&gt;
 *     &lt;td&gt;Current word only.  Combines character suffixes up to size length with a
 *         binary value for whether the word contains any capital letters.&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;distsim&lt;/td&gt;&lt;td&gt;filename, left, right&lt;/td&gt;
 *     &lt;td&gt;Individual features for each position left ... right.
 *         Compares that word with the dictionary in filename.&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;distsimconjunction&lt;/td&gt;&lt;td&gt;filename, left, right&lt;/td&gt;
 *     &lt;td&gt;A concatenation of distsim features from left ... right.&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;
 * Also available are the macros &quot;naacl2003unknowns&quot;,
 * &quot;lnaacl2003unknowns&quot;, and &quot;naacl2003conjunctions&quot;.
 * naacl2003unknowns and lnaacl2003unknowns include suffix extractors
 * and extractors for specific word shape features, such as containing
 * or not containing a digit.
 * &lt;br&gt;
 * The macro &quot;frenchunknowns&quot; is a macro for five extractors specific
 * to French, which test the end of the word to see if it matches
 * common suffixes for various POS classes and plural words.  Adding
 * this experiment did not improve accuracy over the regular
 * naacl2003unknowns extractor macro, though.
 * &lt;br&gt;
 * @author Kristina Toutanova
 * @author Christopher Manning
 * @author Michel Galley
 * @version 2.0
 */
public class ExtractorFramesRare {

  /**
   * Last 1-4 characters of word
   */
<span class="fc" id="L97">  private static final Extractor cWordSuff1 = new ExtractorWordSuff(1, 0);</span>
<span class="fc" id="L98">  private static final Extractor cWordSuff2 = new ExtractorWordSuff(2, 0);</span>
<span class="fc" id="L99">  private static final Extractor cWordSuff3 = new ExtractorWordSuff(3, 0);</span>
<span class="fc" id="L100">  private static final Extractor cWordSuff4 = new ExtractorWordSuff(4, 0);</span>

  /**
   * &quot;1&quot; iff word contains 1 or more upper case characters (somewhere)
   */
<span class="fc" id="L105">  private static final Extractor cWordUppCase = new ExtractorUCase();</span>

  /**
   * &quot;1&quot; iff word contains 1 or more digit characters (somewhere)
   */
<span class="fc" id="L110">  private static final Extractor cWordNumber = new ExtractorCNumber();</span>

  /**
   * &quot;1&quot; iff word contains 1 or more dash characters (somewhere)
   */
<span class="fc" id="L115">  private static final Extractor cWordDash = new ExtractorDash();</span>

  /**
   * &quot;1&quot; if token has no lower case letters
   */
<span class="fc" id="L120">  private static final Extractor cNoLower = new ExtractorAllCap();</span>

  /**
   * &quot;1&quot; if token has only upper case letters
   */
<span class="fc" id="L125">  private static final Extractor cAllCapitalized = new ExtractorAllCapitalized();</span>

  /**
   * &quot;1&quot; if capitalized and one of following 3 words is Inc., Co., or Corp.
   */
<span class="fc" id="L130">  private static final Extractor cCompany = new CompanyNameDetector();</span>

  /**
   * &quot;1&quot; if capitalized and one of following 3 words is Inc., Co.,
   * Corp., or similar words
   */
<span class="fc" id="L136">  private static final Extractor cCaselessCompany =</span>
    new CaselessCompanyNameDetector();

  /**
   * &quot;1&quot; if word contains letter, digit, and dash, in any position and case
   */
<span class="fc" id="L142">  private static final Extractor cLetterDigitDash = new ExtractorLetterDigitDash();</span>

  /**
   * &quot;1&quot; if word contains uppercase letter, digit, and dash
   */
<span class="fc" id="L147">  private static final Extractor cUpperDigitDash = new ExtractorUpperDigitDash();</span>

  /**
   * Distance to lowercase word.  Used by another extractor....
   */
<span class="fc" id="L152">  private static final Extractor cCapDist = new ExtractorCapDistLC();</span>


<span class="fc" id="L155">  private static final Extractor[] eFrames_motley_naacl2003 = { cWordUppCase, cWordNumber, cWordDash, cNoLower, cLetterDigitDash, cCompany, cAllCapitalized, cUpperDigitDash};</span>
<span class="fc" id="L156">  private static final Extractor[] eFrames_motley_naacl2003_left = { cWordUppCase, cWordNumber, cWordDash, cNoLower, cLetterDigitDash, cAllCapitalized, cUpperDigitDash};</span>

<span class="fc" id="L158">  private static final Extractor[] eFrames_motley_caseless_naacl2003 = { cWordNumber, cWordDash, cLetterDigitDash, cCaselessCompany};</span>

  /**
   * Whether it has a typical French noun suffix.
   */
<span class="fc" id="L163">  private static final ExtractorFrenchNounSuffix cWordFrenchNounSuffix =</span>
    new ExtractorFrenchNounSuffix();

  /**
   * Whether it has a typical French adverb suffix.
   */
<span class="fc" id="L169">  private static final ExtractorFrenchAdvSuffix cWordFrenchAdvSuffix =</span>
    new ExtractorFrenchAdvSuffix();

  /**
   * Whether it has a typical French verb suffix.
   */
<span class="fc" id="L175">  private static final ExtractorFrenchVerbSuffix cWordFrenchVerbSuffix =</span>
    new ExtractorFrenchVerbSuffix();

  /**
   * Whether it has a typical French adjective suffix.
   */
<span class="fc" id="L181">  private static final ExtractorFrenchAdjSuffix cWordFrenchAdjSuffix =</span>
    new ExtractorFrenchAdjSuffix();

  /**
   * Whether it has a typical French plural suffix.
   */
<span class="fc" id="L187">  private static final ExtractorFrenchPluralSuffix cWordFrenchPluralSuffix =</span>
    new ExtractorFrenchPluralSuffix();

<span class="fc" id="L190">  private static final Extractor[] french_unknown_extractors = { cWordFrenchNounSuffix, cWordFrenchAdvSuffix, cWordFrenchVerbSuffix, cWordFrenchAdjSuffix, cWordFrenchPluralSuffix };</span>

  /**
   * Extracts Spanish gender patterns.
   */
<span class="fc" id="L195">  private static final ExtractorSpanishGender cWordSpanishGender =</span>
    new ExtractorSpanishGender();

  /**
   * Matches conditional-tense verb suffixes.
   */
<span class="fc" id="L201">  private static final ExtractorSpanishConditionalSuffix cWordSpanishConditionalSuffix =</span>
    new ExtractorSpanishConditionalSuffix();

  /**
   * Matches imperfect-tense verb suffixes (-er, -ir verbs).
   */
<span class="fc" id="L207">  private static final ExtractorSpanishImperfectErIrSuffix cWordSpanishImperfectErIrSuffix =</span>
    new ExtractorSpanishImperfectErIrSuffix();

<span class="fc" id="L210">  private static final Extractor[] spanish_unknown_extractors = {</span>
    cWordSpanishGender, cWordSpanishConditionalSuffix,
    cWordSpanishImperfectErIrSuffix
  };


<span class="nc" id="L216">  private ExtractorFramesRare() {</span>
<span class="nc" id="L217">  }</span>

  /**
   * Adds a few specific extractors needed by both &quot;naacl2003unknowns&quot;
   * and &quot;lnaacl2003unknowns&quot;.
   */
  private static void getNaaclExtractors(ArrayList&lt;Extractor&gt; extrs) {
<span class="nc" id="L224">    extrs.add(new ExtractorStartSentenceCap());</span>
<span class="nc" id="L225">    extrs.add(new ExtractorMidSentenceCapC());</span>
<span class="nc" id="L226">    extrs.add(new ExtractorMidSentenceCap());</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">    for (int i = 1; i &lt;= 10; i++) {</span>
<span class="nc" id="L228">      extrs.add(new ExtractorWordSuff(i, 0));</span>
    }
<span class="nc bnc" id="L230" title="All 2 branches missed.">    for (int i = 1; i &lt;= 10; i++) {</span>
<span class="nc" id="L231">      extrs.add(new ExtractorWordPref(i, 0));</span>
    }
<span class="nc" id="L233">  }</span>

  /**
   * Adds a few specific extractors needed by &quot;naacl2003unknowns&quot; in a
   * caseless form.
   */
  private static void getCaselessNaaclExtractors(ArrayList&lt;Extractor&gt; extrs) {
<span class="nc bnc" id="L240" title="All 2 branches missed.">    for (int i = 1; i &lt;= 10; i++) {</span>
<span class="nc" id="L241">      extrs.add(new ExtractorWordSuff(i, 0));</span>
    }
<span class="nc bnc" id="L243" title="All 2 branches missed.">    for (int i = 1; i &lt;= 10; i++) {</span>
<span class="nc" id="L244">      extrs.add(new ExtractorWordPref(i, 0));</span>
    }
<span class="nc" id="L246">  }</span>


  /** Get an array of rare word feature Extractor identified by a name.
   *  Note: Names used here must also be known in getExtractorFrames, so we
   *  can appropriately add error messages.  So if you add a keyword here,
   *  add it there as one to be ignored, too. (In the next iteration, this
   *  class and ExtractorFrames should probably just be combined).
   *
   *  @param identifier Describes a set of extractors for rare word features
   *  @return A set of extractors for rare word features
   */
  protected static Extractor[] getExtractorFramesRare(String identifier, TTags ttags) {
<span class="fc" id="L259">    ArrayList&lt;Extractor&gt; extrs = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L260">    List&lt;String&gt; args = StringUtils.valueSplit(identifier, &quot;[a-zA-Z0-9]*(?:\\([^)]*\\))?&quot;, &quot;\\s*,\\s*&quot;);</span>

<span class="fc bfc" id="L262" title="All 2 branches covered.">    for (String arg : args) {</span>
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">      if (&quot;naacl2003unknowns&quot;.equalsIgnoreCase(arg)) {</span>
<span class="nc" id="L264">        extrs.addAll(Arrays.asList(eFrames_motley_naacl2003));</span>
<span class="nc" id="L265">        getNaaclExtractors(extrs);</span>
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">      } else if ((&quot;lnaacl2003unknowns&quot;).equalsIgnoreCase(arg)) {</span>
<span class="nc" id="L267">        extrs.addAll(Arrays.asList(eFrames_motley_naacl2003_left));</span>
<span class="nc" id="L268">        getNaaclExtractors(extrs);</span>
<span class="pc bpc" id="L269" title="1 of 2 branches missed.">      } else if (&quot;caselessnaacl2003unknowns&quot;.equalsIgnoreCase(arg)) {</span>
<span class="nc" id="L270">        extrs.addAll(Arrays.asList(eFrames_motley_caseless_naacl2003));</span>
<span class="nc" id="L271">        getCaselessNaaclExtractors(extrs);</span>
        // TODO: test this next one
<span class="pc bpc" id="L273" title="1 of 2 branches missed.">      } else if (&quot;naacl2003conjunctions&quot;.equalsIgnoreCase(arg)) {</span>
<span class="nc" id="L274">        extrs.addAll(Arrays.asList(naacl2003Conjunctions()));</span>
<span class="pc bpc" id="L275" title="1 of 2 branches missed.">      } else if (&quot;frenchunknowns&quot;.equalsIgnoreCase(arg)) {</span>
<span class="nc" id="L276">        extrs.addAll(Arrays.asList(french_unknown_extractors));</span>
<span class="pc bpc" id="L277" title="1 of 2 branches missed.">      } else if (arg.startsWith(&quot;wordshapes(&quot;)) {</span>
<span class="nc" id="L278">        int lWindow = Extractor.getParenthesizedNum(arg, 1);</span>
<span class="nc" id="L279">        int rWindow = Extractor.getParenthesizedNum(arg, 2);</span>
<span class="nc" id="L280">        String wsc = Extractor.getParenthesizedArg(arg, 3);</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">        if (wsc == null) {</span>
<span class="nc" id="L282">          wsc = &quot;chris2&quot;;</span>
        }
<span class="nc bnc" id="L284" title="All 2 branches missed.">        for (int i = lWindow; i &lt;= rWindow; i++) {</span>
<span class="nc" id="L285">          extrs.add(new ExtractorWordShapeClassifier(i, wsc));</span>
        }
<span class="pc bpc" id="L287" title="1 of 2 branches missed.">      } else if (arg.startsWith(&quot;wordshapeconjunction(&quot;)) {</span>
<span class="nc" id="L288">        int lWindow = Extractor.getParenthesizedNum(arg, 1);</span>
<span class="nc" id="L289">        int rWindow = Extractor.getParenthesizedNum(arg, 2);</span>
<span class="nc" id="L290">        String wsc = Extractor.getParenthesizedArg(arg, 3);</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">        if (wsc == null) {</span>
<span class="nc" id="L292">          wsc = &quot;chris2&quot;;</span>
        }
<span class="nc bnc" id="L294" title="All 2 branches missed.">        for (int i = lWindow; i &lt;= rWindow; i++) {</span>
<span class="nc" id="L295">          extrs.add(new ExtractorWordShapeConjunction(lWindow, rWindow, wsc));</span>
        }
<span class="pc bpc" id="L297" title="1 of 2 branches missed.">      } else if (arg.startsWith(&quot;unicodeshapes(&quot;)) {</span>
<span class="nc" id="L298">        int lWindow = Extractor.getParenthesizedNum(arg, 1);</span>
<span class="nc" id="L299">        int rWindow = Extractor.getParenthesizedNum(arg, 2);</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">        for (int i = lWindow; i &lt;= rWindow; i++) {</span>
<span class="nc" id="L301">          extrs.add(new ExtractorWordShapeClassifier(i, &quot;chris4&quot;));</span>
        }
<span class="pc bpc" id="L303" title="1 of 2 branches missed.">      } else if (arg.startsWith(&quot;unicodeshapeconjunction(&quot;)) {</span>
<span class="nc" id="L304">        int lWindow = Extractor.getParenthesizedNum(arg, 1);</span>
<span class="nc" id="L305">        int rWindow = Extractor.getParenthesizedNum(arg, 2);</span>
<span class="nc" id="L306">        extrs.add(new ExtractorWordShapeConjunction(lWindow, rWindow, &quot;chris4&quot;));</span>
<span class="pc bpc" id="L307" title="1 of 2 branches missed.">      } else if (arg.startsWith(&quot;chinesedictionaryfeatures(&quot;)) {</span>
<span class="nc" id="L308">        throw new RuntimeException(&quot;These features are no longer supported.&quot; +</span>
                                   &quot;  The paths and data files associated &quot; +
                                   &quot;with this material are out of date, and &quot; +
                                   &quot;the classes used are not thread-safe.  &quot; +
                                   &quot;Those problems would need to be fixed &quot; +
                                   &quot;to use this feature.&quot;);
        //String path = Extractor.getParenthesizedArg(arg, 1);
        //// Default nlp location for these features is: /u/nlp/data/pos-tagger/dictionary
        //int lWindow = Extractor.getParenthesizedNum(arg, 2);
        //int rWindow = Extractor.getParenthesizedNum(arg, 3);
        //// First set up the dictionary prefix for the Chinese dictionaries
        //ASBCDict.setPathPrefix(path);
        //for (int i = lWindow; i &lt;= rWindow; i++) {
        //  extrs.addAll(Arrays.asList(ctbPreFeatures(i)));
        //  extrs.addAll(Arrays.asList(ctbSufFeatures(i)));
        //  extrs.addAll(Arrays.asList(ctbUnkDictFeatures(i)));
        //  extrs.addAll(Arrays.asList(asbcUnkFeatures(i)));
        //}
      // No longer add prefix suffix features, now that you can more flexibly add them separately.
      // } else if (&quot;generic&quot;.equalsIgnoreCase(arg)) {
      //   // does prefix and suffix up to 6 grams
      //   for (int i = 1; i &lt;= 6; i++) {
      //     extrs.add(new ExtractorCWordSuff(i));
      //     extrs.add(new ExtractorCWordPref(i));
      //   }
<span class="pc bpc" id="L333" title="1 of 2 branches missed.">      } else if (arg.equalsIgnoreCase(&quot;motleyUnknown&quot;)) {  // This is naacl2003unknown minus prefix and suffix features.</span>
<span class="nc" id="L334">        extrs.addAll(Arrays.asList(eFrames_motley_naacl2003));</span>
<span class="pc bpc" id="L335" title="1 of 2 branches missed.">      } else if (arg.startsWith(&quot;suffix(&quot;)) {</span>
<span class="nc" id="L336">        int max = Extractor.getParenthesizedNum(arg, 1);</span>
        // will conveniently be 0 if not specified
<span class="nc" id="L338">        int position = Extractor.getParenthesizedNum(arg, 2);</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">        for (int i = 1; i &lt;= max; i++) {</span>
<span class="nc" id="L340">          extrs.add(new ExtractorWordSuff(i, position));</span>
        }
<span class="pc bpc" id="L342" title="1 of 2 branches missed.">      } else if (arg.startsWith(&quot;prefix(&quot;)) {</span>
<span class="nc" id="L343">        int max = Extractor.getParenthesizedNum(arg, 1);</span>
        // will conveniently be 0 if not specified
<span class="nc" id="L345">        int position = Extractor.getParenthesizedNum(arg, 2);</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">        for (int i = 1; i &lt;= max; i++) {</span>
<span class="nc" id="L347">          extrs.add(new ExtractorWordPref(i, position));</span>
        }
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">      } else if (arg.startsWith(&quot;prefixsuffix(&quot;)) {</span>
<span class="nc" id="L350">        int max = Extractor.getParenthesizedNum(arg, 1);</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">        for (int i = 1; i &lt;= max; i++) {</span>
<span class="nc" id="L352">          extrs.add(new ExtractorsConjunction(new ExtractorWordPref(i, 0),</span>
                                              new ExtractorWordSuff(i, 0)));
        }
<span class="pc bpc" id="L355" title="1 of 2 branches missed.">      } else if (arg.startsWith(&quot;capitalizationsuffix(&quot;)) {</span>
<span class="nc" id="L356">        int max = Extractor.getParenthesizedNum(arg, 1);</span>
<span class="nc bnc" id="L357" title="All 2 branches missed.">        for (int i = 1; i &lt;= max; i++) {</span>
<span class="nc" id="L358">          extrs.add(new ExtractorsConjunction(cWordUppCase, new ExtractorWordSuff(i,0)));</span>
        }
<span class="pc bpc" id="L360" title="1 of 2 branches missed.">      } else if (arg.startsWith(&quot;distsim(&quot;)) {</span>
<span class="nc" id="L361">        String path = Extractor.getParenthesizedArg(arg, 1);</span>
        // traditional nlp filesystem location is: /u/nlp/data/pos_tags_are_useless/egw.bnc.200.pruned
<span class="nc" id="L363">        int lWindow = Extractor.getParenthesizedNum(arg, 2);</span>
<span class="nc" id="L364">        int rWindow = Extractor.getParenthesizedNum(arg, 3);</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">        for (int i = lWindow; i &lt;= rWindow; i++) {</span>
<span class="nc" id="L366">          extrs.add(new ExtractorDistsim(path, i));</span>
        }
<span class="pc bpc" id="L368" title="1 of 2 branches missed.">      } else if (arg.startsWith(&quot;distsimconjunction(&quot;)) {</span>
<span class="nc" id="L369">        String path = Extractor.getParenthesizedArg(arg, 1);</span>
<span class="nc" id="L370">        int lWindow = Extractor.getParenthesizedNum(arg, 2);</span>
<span class="nc" id="L371">        int rWindow = Extractor.getParenthesizedNum(arg, 3);</span>
<span class="nc" id="L372">        extrs.add(new ExtractorDistsimConjunction(path, lWindow, rWindow));</span>
<span class="pc bpc" id="L373" title="1 of 2 branches missed.">      } else if (arg.equalsIgnoreCase(&quot;lctagfeatures&quot;)) {</span>
<span class="nc" id="L374">        extrs.addAll(Arrays.asList(lcTagFeatures(ttags)));</span>
      }
<span class="fc" id="L376">    }</span>

<span class="fc" id="L378">    return extrs.toArray(new Extractor[extrs.size()]);</span>
  }


  /**
   * This provides the conjunction of various features as rare words features.
   *
   * @return An array of feature conjunctions
   */
  private static Extractor[] naacl2003Conjunctions() {
<span class="nc" id="L388">    Extractor[] newW = new Extractor[24];</span>
    //add them manually ....
<span class="nc" id="L390">    newW[0] = new ExtractorsConjunction(cWordUppCase, cWordSuff1);</span>
<span class="nc" id="L391">    newW[1] = new ExtractorsConjunction(cWordUppCase, cWordSuff2);</span>
<span class="nc" id="L392">    newW[2] = new ExtractorsConjunction(cWordUppCase, cWordSuff3);</span>
<span class="nc" id="L393">    newW[3] = new ExtractorsConjunction(cWordUppCase, cWordSuff4);</span>

<span class="nc" id="L395">    newW[4] = new ExtractorsConjunction(cNoLower, cWordSuff1);</span>
<span class="nc" id="L396">    newW[5] = new ExtractorsConjunction(cNoLower, cWordSuff2);</span>
<span class="nc" id="L397">    newW[6] = new ExtractorsConjunction(cNoLower, cWordSuff3);</span>
<span class="nc" id="L398">    newW[7] = new ExtractorsConjunction(cNoLower, cWordSuff4);</span>

<span class="nc" id="L400">    Extractor cMidSentence = new ExtractorMidSentenceCap();</span>
<span class="nc" id="L401">    newW[8] = new ExtractorsConjunction(cMidSentence, cWordSuff1);</span>
<span class="nc" id="L402">    newW[9] = new ExtractorsConjunction(cMidSentence, cWordSuff2);</span>
<span class="nc" id="L403">    newW[10] = new ExtractorsConjunction(cMidSentence, cWordSuff3);</span>
<span class="nc" id="L404">    newW[11] = new ExtractorsConjunction(cMidSentence, cWordSuff4);</span>

<span class="nc" id="L406">    Extractor cWordStartUCase = new ExtractorStartSentenceCap();</span>
<span class="nc" id="L407">    newW[12] = new ExtractorsConjunction(cWordStartUCase, cWordSuff1);</span>
<span class="nc" id="L408">    newW[13] = new ExtractorsConjunction(cWordStartUCase, cWordSuff2);</span>
<span class="nc" id="L409">    newW[14] = new ExtractorsConjunction(cWordStartUCase, cWordSuff3);</span>
<span class="nc" id="L410">    newW[15] = new ExtractorsConjunction(cWordStartUCase, cWordSuff4);</span>

<span class="nc" id="L412">    Extractor cWordMidUCase = new ExtractorMidSentenceCapC();</span>
<span class="nc" id="L413">    newW[16] = new ExtractorsConjunction(cWordMidUCase, cWordSuff1);</span>
<span class="nc" id="L414">    newW[17] = new ExtractorsConjunction(cWordMidUCase, cWordSuff2);</span>
<span class="nc" id="L415">    newW[18] = new ExtractorsConjunction(cWordMidUCase, cWordSuff3);</span>
<span class="nc" id="L416">    newW[19] = new ExtractorsConjunction(cWordMidUCase, cWordSuff4);</span>

<span class="nc" id="L418">    newW[20] = new ExtractorsConjunction(cCapDist, cWordSuff1);</span>
<span class="nc" id="L419">    newW[21] = new ExtractorsConjunction(cCapDist, cWordSuff2);</span>
<span class="nc" id="L420">    newW[22] = new ExtractorsConjunction(cCapDist, cWordSuff3);</span>
<span class="nc" id="L421">    newW[23] = new ExtractorsConjunction(cCapDist, cWordSuff4);</span>

<span class="nc" id="L423">    return newW;</span>
  }


  private static Extractor[] lcTagFeatures(TTags ttags) {
<span class="nc" id="L428">    Extractor[] newE = new Extractor[ttags.getSize()];</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">    for (int i = 0; i &lt; ttags.getSize(); i++) {</span>
<span class="nc" id="L430">      String tag = ttags.getTag(i);</span>
<span class="nc" id="L431">      newE[i] = new ExtractorCapLCSeen(tag);</span>
    }
<span class="nc" id="L433">    return newE;</span>
  }


  /* private ExtractorFramesRare() {
    // this is now a statics only class!
  } */

  /*
    ArrayList&lt;Extractor&gt; v = new ArrayList&lt;Extractor&gt;();
    GlobalHolder.ySize = GlobalHolder.tags.getSize();
    for (int i = 1; i &lt; 5; i++) {
      for (int y = 0; y &lt; GlobalHolder.tags.getSize(); y++) {
        if (!GlobalHolder.tags.isClosed(GlobalHolder.tags.getTag(y))) {
          ExtractorMorpho extr = new ExtractorMorpho(i, y);
          v.add(extr);
        }// if open
      }
    }// for i

    for (int y = 0; y &lt; GlobalHolder.ySize; y++) {
      for (int y1 = 0; y1 &lt; GlobalHolder.ySize; y1++) {
        if (!GlobalHolder.tags.isClosed(GlobalHolder.tags.getTag(y)) &amp;&amp; (!GlobalHolder.tags.isClosed(GlobalHolder.tags.getTag(y)))) {
          ExtractorMorpho extr = new ExtractorMorpho(5, y, y1);
          v.add(extr);
        }// if open
      }
    }
    int vSize = v.size();
    Extractor[] eFramestemp = new Extractor[eFrames.length + vSize];
    System.arraycopy(eFrames, 0, eFramestemp, 0, eFrames.length);
    for (int i = 0; i &lt; vSize; i++) {
      eFramestemp[i + eFrames.length] = v.get(i);
    }
    eFrames = eFramestemp;
     */

  private static Extractor[] ctbPreFeatures(int n) {
<span class="nc" id="L471">    String[] tagsets = {&quot;AD&quot;, &quot;AS&quot;, &quot;BA&quot;, &quot;CC&quot;, &quot;CD&quot;, &quot;CS&quot;, &quot;DEC&quot;, &quot;DEG&quot;, &quot;DER&quot;, &quot;DEV&quot;, &quot;DT&quot;, &quot;ETC&quot;, &quot;FW&quot;, &quot;IJ&quot;, &quot;JJ&quot;, &quot;LB&quot;, &quot;LC&quot;, &quot;M&quot;, &quot;MSP&quot;, &quot;NN&quot;, &quot;NP&quot;, &quot;NR&quot;, &quot;NT&quot;, &quot;OD&quot;, &quot;P&quot;, &quot;PN&quot;, &quot;PU&quot;, &quot;SB&quot;, &quot;SP&quot;, &quot;VA&quot;, &quot;VC&quot;, &quot;VE&quot;, &quot;VV&quot; };</span>
<span class="nc" id="L472">    Extractor[] newW = new Extractor[tagsets.length];</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">    for (int k = 0; k &lt; tagsets.length; k++) {</span>
<span class="nc" id="L474">      newW[k] = new CtbPreDetector(tagsets[k], n);</span>
    }
<span class="nc" id="L476">    return newW;</span>
  } // end ctbPreFeatures


  private static Extractor[] ctbSufFeatures(int n) {
<span class="nc" id="L481">    String[] tagsets = {&quot;AD&quot;, &quot;AS&quot;, &quot;BA&quot;, &quot;CC&quot;, &quot;CD&quot;, &quot;CS&quot;, &quot;DEC&quot;, &quot;DEG&quot;, &quot;DER&quot;, &quot;DEV&quot;, &quot;DT&quot;, &quot;ETC&quot;, &quot;FW&quot;, &quot;IJ&quot;, &quot;JJ&quot;, &quot;LB&quot;, &quot;LC&quot;, &quot;M&quot;, &quot;MSP&quot;, &quot;NN&quot;, &quot;NP&quot;, &quot;NR&quot;, &quot;NT&quot;, &quot;OD&quot;, &quot;P&quot;, &quot;PN&quot;, &quot;PU&quot;, &quot;SB&quot;, &quot;SP&quot;, &quot;VA&quot;, &quot;VC&quot;, &quot;VE&quot;, &quot;VV&quot; };</span>
<span class="nc" id="L482">    Extractor[] newW=new Extractor[tagsets.length];</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">    for(int k=0;k&lt;tagsets.length;k++){</span>
<span class="nc" id="L484">      newW[k] = new CtbSufDetector(tagsets[k], n);</span>
    }
<span class="nc" id="L486">    return newW;</span>
  } // end ctbSuffFeatures

  /*
  public static Extractor[] asbcPreFeatures(int n) {
    String[] tagsets = {&quot;A&quot;, &quot;Caa&quot;, &quot;Cab&quot;, &quot;Cba&quot;, &quot;Cbb&quot;, &quot;D&quot;, &quot;DE&quot;, &quot;DK&quot;, &quot;Da&quot;, &quot;Dd&quot;, &quot;De&quot;, &quot;Des&quot;, &quot;Dfa&quot;, &quot;Dfb&quot;, &quot;Di&quot;, &quot;Dk&quot;, &quot;FW&quot;, &quot;I&quot;, &quot; Na&quot;, &quot;Nb&quot;, &quot; Nc&quot;, &quot;Ncb&quot;, &quot;Ncd&quot;, &quot; Nd&quot;, &quot;Neaq&quot;, &quot;Nep&quot;, &quot;Neqa&quot;, &quot;Neqb&quot;, &quot;Nes&quot;, &quot;Neu&quot;, &quot;Nf&quot;, &quot;Ng&quot;, &quot;Nh&quot;, &quot;P&quot;, &quot;PU&quot;, &quot;SHI&quot;, &quot;T&quot;, &quot;VA&quot;, &quot;VAC&quot;, &quot;VB&quot;, &quot;VC&quot;, &quot;VCL&quot;, &quot;VD&quot;, &quot;VE&quot;, &quot;VF&quot;, &quot;VG&quot;, &quot;VH&quot;, &quot;VHC&quot;, &quot;VI&quot;, &quot;VJ&quot;, &quot;VK&quot;, &quot;VL&quot;, &quot;V_2&quot; };
    Extractor[] newW=new Extractor[tagsets.length];
    for(int k=0;k&lt;tagsets.length;k++){
      newW[k] = new ASBCPreDetector(tagsets[k], n);
    }
    return newW;
  }

  public static Extractor[] asbcSufFeatures(int n) {
    String[] tagsets = {&quot;A&quot;, &quot;Caa&quot;, &quot;Cab&quot;, &quot;Cba&quot;, &quot;Cbb&quot;, &quot;D&quot;, &quot;DE&quot;, &quot;DK&quot;, &quot;Da&quot;, &quot;Dd&quot;, &quot;De&quot;, &quot;Des&quot;, &quot;Dfa&quot;, &quot;Dfb&quot;, &quot;Di&quot;, &quot;Dk&quot;, &quot;FW&quot;, &quot;I&quot;, &quot; Na&quot;, &quot;Nb&quot;, &quot; Nc&quot;, &quot;Ncb&quot;, &quot;Ncd&quot;, &quot; Nd&quot;, &quot;Neaq&quot;, &quot;Nep&quot;, &quot;Neqa&quot;, &quot;Neqb&quot;, &quot;Nes&quot;, &quot;Neu&quot;, &quot;Nf&quot;, &quot;Ng&quot;, &quot;Nh&quot;, &quot;P&quot;, &quot;PU&quot;, &quot;SHI&quot;, &quot;T&quot;, &quot;VA&quot;, &quot;VAC&quot;, &quot;VB&quot;, &quot;VC&quot;, &quot;VCL&quot;, &quot;VD&quot;, &quot;VE&quot;, &quot;VF&quot;, &quot;VG&quot;, &quot;VH&quot;, &quot;VHC&quot;, &quot;VI&quot;, &quot;VJ&quot;, &quot;VK&quot;, &quot;VL&quot;, &quot;V_2&quot;  };
    Extractor[] newW=new Extractor[tagsets.length];
    for(int k=0;k&lt;tagsets.length;k++){
      newW[k] = new ASBCSufDetector(tagsets[k], n);
    }
    return newW;
  }
  */

  private static Extractor[] asbcUnkFeatures(int n) {
<span class="nc" id="L510">    String[] tagsets = {&quot;A&quot;, &quot;Caa&quot;, &quot;Cab&quot;, &quot;Cba&quot;, &quot;Cbb&quot;, &quot;D&quot;, &quot;DE&quot;, &quot;DK&quot;, &quot;Da&quot;, &quot;Dd&quot;, &quot;De&quot;, &quot;Des&quot;, &quot;Dfa&quot;, &quot;Dfb&quot;, &quot;Di&quot;, &quot;Dk&quot;, &quot;FW&quot;, &quot;I&quot;, &quot; Na&quot;, &quot;Nb&quot;, &quot; Nc&quot;, &quot;Ncb&quot;, &quot;Ncd&quot;, &quot; Nd&quot;, &quot;Neaq&quot;, &quot;Nep&quot;, &quot;Neqa&quot;, &quot;Neqb&quot;, &quot;Nes&quot;, &quot;Neu&quot;, &quot;Nf&quot;, &quot;Ng&quot;, &quot;Nh&quot;, &quot;P&quot;, &quot;PU&quot;, &quot;SHI&quot;, &quot;T&quot;, &quot;VA&quot;, &quot;VAC&quot;, &quot;VB&quot;, &quot;VC&quot;, &quot;VCL&quot;, &quot;VD&quot;, &quot;VE&quot;, &quot;VF&quot;, &quot;VG&quot;, &quot;VH&quot;, &quot;VHC&quot;, &quot;VI&quot;, &quot;VJ&quot;, &quot;VK&quot;, &quot;VL&quot;, &quot;V_2&quot;  };</span>

<span class="nc" id="L512">    Extractor[] newW=new Extractor[tagsets.length];</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">    for(int k=0;k&lt;tagsets.length;k++){</span>
<span class="nc" id="L514">      newW[k] = new ASBCunkDetector(tagsets[k], n);</span>
    }
<span class="nc" id="L516">    return newW;</span>
  }


  private static Extractor[] ctbUnkDictFeatures(int n) {
<span class="nc" id="L521">    String[] tagsets = {&quot;A&quot;, &quot;Caa&quot;, &quot;Cab&quot;, &quot;Cba&quot;, &quot;Cbb&quot;, &quot;D&quot;, &quot;DE&quot;, &quot;DK&quot;, &quot;Da&quot;, &quot;Dd&quot;, &quot;De&quot;, &quot;Des&quot;, &quot;Dfa&quot;, &quot;Dfb&quot;, &quot;Di&quot;, &quot;Dk&quot;, &quot;FW&quot;, &quot;I&quot;, &quot; Na&quot;, &quot;Nb&quot;, &quot; Nc&quot;, &quot;Ncb&quot;, &quot;Ncd&quot;, &quot; Nd&quot;, &quot;Neaq&quot;, &quot;Nep&quot;, &quot;Neqa&quot;, &quot;Neqb&quot;, &quot;Nes&quot;, &quot;Neu&quot;, &quot;Nf&quot;, &quot;Ng&quot;, &quot;Nh&quot;, &quot;P&quot;, &quot;PU&quot;, &quot;SHI&quot;, &quot;T&quot;, &quot;VA&quot;, &quot;VAC&quot;, &quot;VB&quot;, &quot;VC&quot;, &quot;VCL&quot;, &quot;VD&quot;, &quot;VE&quot;, &quot;VF&quot;, &quot;VG&quot;, &quot;VH&quot;, &quot;VHC&quot;, &quot;VI&quot;, &quot;VJ&quot;, &quot;VK&quot;, &quot;VL&quot;, &quot;V_2&quot;  };</span>

<span class="nc" id="L523">    Extractor[] newW=new Extractor[tagsets.length];</span>
<span class="nc bnc" id="L524" title="All 2 branches missed.">    for(int k=0;k&lt;tagsets.length;k++){</span>
<span class="nc" id="L525">      newW[k] = new CTBunkDictDetector(tagsets[k], n);</span>
    }
<span class="nc" id="L527">    return newW;</span>
  }

} // end class ExtractorFramesRare


/**
 * Superclass for rare word feature frames.  Provides some common functions.
 * Designed to be extended.
 */
class RareExtractor extends Extractor {

  static final String naTag = &quot;NA&quot;;

  RareExtractor() {
<span class="fc" id="L542">    super();</span>
<span class="fc" id="L543">  }</span>

  RareExtractor(int position) {
<span class="nc" id="L546">    super(position, false);</span>
<span class="nc" id="L547">  }</span>

  static boolean startsUpperCase(String s) {
<span class="nc bnc" id="L550" title="All 4 branches missed.">    if (s == null || s.length() == 0) {</span>
<span class="nc" id="L551">      return false;</span>
    }
<span class="nc" id="L553">    char ch = s.charAt(0);</span>
<span class="nc" id="L554">    return Character.isUpperCase(ch);</span>
  }

  /**
   * A string is lowercase if it starts with a lowercase letter
   * such as one from a to z.
   * Should we include numbers?
   * @param s The String to check
   * @return If its first character is lower case
   */
  protected static boolean startsLowerCase(String s) {
<span class="nc bnc" id="L565" title="All 2 branches missed.">    if (s == null) {</span>
<span class="nc" id="L566">      return false;</span>
    }
<span class="nc" id="L568">    char ch = s.charAt(0);</span>
<span class="nc" id="L569">    return Character.isLowerCase(ch);</span>
  }

  protected static boolean containsDash(String s) {
<span class="nc bnc" id="L573" title="All 4 branches missed.">    return s != null &amp;&amp; s.indexOf('-') &gt;= 0;</span>
  }

  protected static boolean containsNumber(String s) {
<span class="nc bnc" id="L577" title="All 2 branches missed.">    if (s == null) {</span>
<span class="nc" id="L578">      return false;</span>
    }
<span class="nc bnc" id="L580" title="All 2 branches missed.">    for (int i = 0, len = s.length(); i &lt; len; i++) {</span>
<span class="nc bnc" id="L581" title="All 2 branches missed.">      if (Character.isDigit(s.charAt(i))) {</span>
<span class="nc" id="L582">        return true;</span>
      }
    }
<span class="nc" id="L585">    return false;</span>
  }

  protected static boolean containsLetter(String s) {
<span class="nc bnc" id="L589" title="All 2 branches missed.">    if (s == null) {</span>
<span class="nc" id="L590">      return false;</span>
    }
<span class="nc bnc" id="L592" title="All 2 branches missed.">    for (int i = 0, len = s.length(); i &lt; len; i++) {</span>
<span class="nc bnc" id="L593" title="All 2 branches missed.">      if (Character.isLetter(s.charAt(i))) {</span>
<span class="nc" id="L594">        return true;</span>
      }
    }
<span class="nc" id="L597">    return false;</span>
  }

  protected static boolean containsUpperCase(String s) {
<span class="nc bnc" id="L601" title="All 2 branches missed.">    if (s == null) {</span>
<span class="nc" id="L602">      return false;</span>
    }
<span class="nc bnc" id="L604" title="All 2 branches missed.">    for (int i = 0, len = s.length(); i &lt; len; i++) {</span>
<span class="nc bnc" id="L605" title="All 2 branches missed.">      if (Character.isUpperCase(s.charAt(i))) {</span>
<span class="nc" id="L606">        return true;</span>
      }
    }
<span class="nc" id="L609">    return false;</span>
  }

  protected static boolean allUpperCase(String s) {
<span class="nc bnc" id="L613" title="All 2 branches missed.">    if (s == null) {</span>
<span class="nc" id="L614">      return false;</span>
    }
<span class="nc bnc" id="L616" title="All 2 branches missed.">    for (int i = 0, len = s.length(); i &lt; len; i++) {</span>
<span class="nc bnc" id="L617" title="All 2 branches missed.">      if (!Character.isUpperCase(s.charAt(i))) {</span>
<span class="nc" id="L618">        return false;</span>
      }
    }
<span class="nc" id="L621">    return true;</span>
  }

  static boolean noneLowerCase(String s) {
<span class="nc bnc" id="L625" title="All 2 branches missed.">    if (s == null) {</span>
<span class="nc" id="L626">      return false;</span>
    }
<span class="nc bnc" id="L628" title="All 2 branches missed.">    for (int i = 0, len = s.length(); i &lt; len; i++) {</span>
<span class="nc bnc" id="L629" title="All 2 branches missed.">      if (Character.isLowerCase(s.charAt(i))) {</span>
<span class="nc" id="L630">        return false;</span>
      }
    }
<span class="nc" id="L633">    return true;</span>
  }

  private static final long serialVersionUID = -7682607870855426599L;

} // end class RareExtractor


/** English-specific crude company name NER. */
class CompanyNameDetector extends RareExtractor {

  static final int COMPANY_NAME_WINDOW = 3;

  final Set&lt;String&gt; companyNameEnds;

<span class="fc" id="L648">  public CompanyNameDetector() {</span>
<span class="fc" id="L649">    companyNameEnds = Generics.newHashSet();</span>
<span class="fc" id="L650">    companyNameEnds.add(&quot;Company&quot;);</span>
<span class="fc" id="L651">    companyNameEnds.add(&quot;COMPANY&quot;);</span>
<span class="fc" id="L652">    companyNameEnds.add(&quot;Co.&quot;);</span>
<span class="fc" id="L653">    companyNameEnds.add(&quot;Co&quot;);  // at end of sentence in PTB</span>
<span class="fc" id="L654">    companyNameEnds.add(&quot;Cos.&quot;);</span>
<span class="fc" id="L655">    companyNameEnds.add(&quot;CO.&quot;);</span>
<span class="fc" id="L656">    companyNameEnds.add(&quot;COS.&quot;);</span>
<span class="fc" id="L657">    companyNameEnds.add(&quot;Corporation&quot;);</span>
<span class="fc" id="L658">    companyNameEnds.add(&quot;CORPORATION&quot;);</span>
<span class="fc" id="L659">    companyNameEnds.add(&quot;Corp.&quot;);</span>
<span class="fc" id="L660">    companyNameEnds.add(&quot;Corp&quot;); // at end of sentence in PTB</span>
<span class="fc" id="L661">    companyNameEnds.add(&quot;CORP.&quot;);</span>
<span class="fc" id="L662">    companyNameEnds.add(&quot;Incorporated&quot;);</span>
<span class="fc" id="L663">    companyNameEnds.add(&quot;INCORPORATED&quot;);</span>
<span class="fc" id="L664">    companyNameEnds.add(&quot;Inc.&quot;);</span>
<span class="fc" id="L665">    companyNameEnds.add(&quot;Inc&quot;); // at end of sentence in PTB</span>
<span class="fc" id="L666">    companyNameEnds.add(&quot;INC.&quot;);</span>
<span class="fc" id="L667">    companyNameEnds.add(&quot;Association&quot;);</span>
<span class="fc" id="L668">    companyNameEnds.add(&quot;ASSOCIATION&quot;);</span>
<span class="fc" id="L669">    companyNameEnds.add(&quot;Assn&quot;);</span>
<span class="fc" id="L670">    companyNameEnds.add(&quot;ASSN&quot;);</span>
<span class="fc" id="L671">    companyNameEnds.add(&quot;Limited&quot;);</span>
<span class="fc" id="L672">    companyNameEnds.add(&quot;LIMITED&quot;);</span>
<span class="fc" id="L673">    companyNameEnds.add(&quot;Ltd.&quot;);</span>
<span class="fc" id="L674">    companyNameEnds.add(&quot;LTD.&quot;);</span>
<span class="fc" id="L675">    companyNameEnds.add(&quot;L.P.&quot;);</span>
    // companyNameEnds.add(&quot;PLC&quot;); // Other thing added at same time.
<span class="fc" id="L677">  }</span>

  private boolean companyNameEnd(String s) {
<span class="nc" id="L680">    return companyNameEnds.contains(s);</span>
  }

  @Override
  String extract(History h, PairsHolder pH) {
<span class="nc" id="L685">    String s = pH.getWord(h, 0);</span>
<span class="nc bnc" id="L686" title="All 2 branches missed.">    if ( ! startsUpperCase(s)) {</span>
<span class="nc" id="L687">      return &quot;0&quot;;</span>
    }
<span class="nc bnc" id="L689" title="All 2 branches missed.">    for (int i = 0; i &lt;= COMPANY_NAME_WINDOW; i++) {</span>
<span class="nc" id="L690">      String s1 = pH.getWord(h, i);</span>
<span class="nc bnc" id="L691" title="All 2 branches missed.">      if (companyNameEnd(s1)) {</span>
<span class="nc" id="L692">        return &quot;1&quot;;</span>
      }
    }
<span class="nc" id="L695">    return &quot;0&quot;;</span>
  }

<span class="nc" id="L698">  @Override public boolean isLocal() { return false; }</span>
<span class="nc" id="L699">  @Override public boolean isDynamic() { return false; }</span>

  private static final long serialVersionUID = 21L;

} // end class CompanyNameDetector



class CaselessCompanyNameDetector extends RareExtractor {
  private final Set&lt;String&gt; companyNameEnds;

<span class="fc" id="L710">  public CaselessCompanyNameDetector() {</span>
<span class="fc" id="L711">    companyNameEnds = Generics.newHashSet();</span>
<span class="fc" id="L712">    CompanyNameDetector cased = new CompanyNameDetector();</span>
<span class="fc bfc" id="L713" title="All 2 branches covered.">    for (String name : cased.companyNameEnds) {</span>
<span class="fc" id="L714">      companyNameEnds.add(name.toLowerCase());</span>
<span class="fc" id="L715">    }</span>
<span class="fc" id="L716">  }</span>

  private boolean companyNameEnd(String s) {
<span class="nc" id="L719">    return companyNameEnds.contains(s);</span>
  }

  @Override
  String extract(History h, PairsHolder pH) {
<span class="nc" id="L724">    String s = pH.getWord(h, 0);</span>

<span class="nc bnc" id="L726" title="All 2 branches missed.">    for (int i = 0; i &lt;= CompanyNameDetector.COMPANY_NAME_WINDOW; i++) {</span>
<span class="nc" id="L727">      String s1 = pH.getWord(h, i);</span>
<span class="nc bnc" id="L728" title="All 2 branches missed.">      if (companyNameEnd(s1)) {</span>
<span class="nc" id="L729">        return &quot;1&quot;;</span>
      }
    }
<span class="nc" id="L732">    return &quot;0&quot;;</span>
  }

<span class="nc" id="L735">  @Override public boolean isLocal() { return false; }</span>
<span class="nc" id="L736">  @Override public boolean isDynamic() { return false; }</span>

  private static final long serialVersionUID = 21L;
}


class ExtractorUCase extends RareExtractor {

<span class="fc" id="L744">  public ExtractorUCase() {</span>
<span class="fc" id="L745">  }</span>

  @Override
  String extract(History h, PairsHolder pH) {
<span class="nc" id="L749">    String s = pH.getWord(h, 0);</span>
<span class="nc bnc" id="L750" title="All 2 branches missed.">    if (containsUpperCase(s)) {</span>
<span class="nc" id="L751">      return &quot;1&quot;;</span>
    }
<span class="nc" id="L753">    return &quot;0&quot;;</span>
  }

<span class="nc" id="L756">  @Override public boolean isLocal() { return true; }</span>
<span class="nc" id="L757">  @Override public boolean isDynamic() { return false; }</span>

  private static final long serialVersionUID = 22L;

}


class ExtractorLetterDigitDash extends RareExtractor {

<span class="fc" id="L766">  public ExtractorLetterDigitDash() {</span>
<span class="fc" id="L767">  }</span>

  @Override
  String extract(History h, PairsHolder pH) {
<span class="nc" id="L771">    String s = pH.getWord(h, 0);</span>
<span class="nc bnc" id="L772" title="All 6 branches missed.">    if (containsLetter(s) &amp;&amp; containsDash(s) &amp;&amp; containsNumber(s)) {</span>
<span class="nc" id="L773">      return &quot;1&quot;;</span>
    }
<span class="nc" id="L775">    return &quot;0&quot;;</span>
  }

<span class="nc" id="L778">  @Override public boolean isLocal() { return true; }</span>
<span class="nc" id="L779">  @Override public boolean isDynamic() { return false; }</span>

  private static final long serialVersionUID = 23;

}


class ExtractorUpperDigitDash extends RareExtractor {

<span class="fc" id="L788">  public ExtractorUpperDigitDash() {</span>
<span class="fc" id="L789">  }</span>

  @Override
  String extract(History h, PairsHolder pH) {
<span class="nc" id="L793">    String s = pH.getWord(h, 0);</span>
<span class="nc bnc" id="L794" title="All 6 branches missed.">    if (containsUpperCase(s) &amp;&amp; containsDash(s) &amp;&amp; containsNumber(s)) {</span>
<span class="nc" id="L795">      return &quot;1&quot;;</span>
    }
<span class="nc" id="L797">    return &quot;0&quot;;</span>
  }

<span class="nc" id="L800">  @Override public boolean isLocal() { return true; }</span>
<span class="nc" id="L801">  @Override public boolean isDynamic() { return false; }</span>

  private static final long serialVersionUID = 33L;

}


/** This requires the 3 character classes in order.  This was worse than ExtractorLetterDigitDash (Oct 2009) */
class ExtractorLetterDashDigit extends RareExtractor {

<span class="nc" id="L811">  public ExtractorLetterDashDigit() {</span>
<span class="nc" id="L812">  }</span>

  @Override
  String extract(History h, PairsHolder pH) {
<span class="nc" id="L816">    String s = pH.getWord(h, 0);</span>
<span class="nc bnc" id="L817" title="All 2 branches missed.">    if (s == null) return &quot;0&quot;;</span>
<span class="nc" id="L818">    boolean seenLetter = false;</span>
<span class="nc" id="L819">    boolean seenDash = false;</span>
<span class="nc" id="L820">    boolean seenNumber = false;</span>
<span class="nc bnc" id="L821" title="All 2 branches missed.">    for (int i = 0, len = s.length(); i &lt; len; i++) {</span>
<span class="nc" id="L822">      char ch = s.charAt(i);</span>
<span class="nc bnc" id="L823" title="All 2 branches missed.">      if (Character.isLetter(ch)) {</span>
<span class="nc" id="L824">        seenLetter = true;</span>
<span class="nc bnc" id="L825" title="All 4 branches missed.">      } else if (seenLetter &amp;&amp; ch == '-') {</span>
<span class="nc" id="L826">        seenDash = true;</span>
<span class="nc bnc" id="L827" title="All 4 branches missed.">      } else if (seenDash &amp;&amp; Character.isDigit(ch)) {</span>
<span class="nc" id="L828">        seenNumber = true;</span>
<span class="nc" id="L829">        break;</span>
      }
    }
<span class="nc bnc" id="L832" title="All 2 branches missed.">    if (seenNumber) {</span>
<span class="nc" id="L833">      return &quot;1&quot;;</span>
    }
<span class="nc" id="L835">    return &quot;0&quot;;</span>
  }

<span class="nc" id="L838">  @Override public boolean isLocal() { return true; }</span>
<span class="nc" id="L839">  @Override public boolean isDynamic() { return false; }</span>

  private static final long serialVersionUID = 33L;

}


/**
 * creates features which are true if the current word is all caps
 * and the distance to the first lowercase word to the left is dist
 * the distance is 1 for adjacent, 2 for one across, 3 for ... and so on.
 * infinity if no capitalized word (we hit the start of sentence or '')
 */
class ExtractorCapDistLC extends RareExtractor {

<span class="fc" id="L854">  boolean verbose = false;</span>

<span class="fc" id="L856">  public ExtractorCapDistLC() {</span>
<span class="fc" id="L857">  }</span>

  @Override
  String extract(History h, PairsHolder pH) {
<span class="nc" id="L861">    String word = pH.getWord(h, 0);</span>
    String ret;
<span class="nc bnc" id="L863" title="All 2 branches missed.">    if (!startsUpperCase(word)) {</span>
<span class="nc bnc" id="L864" title="All 2 branches missed.">      if (verbose) {</span>
<span class="nc" id="L865">        System.out.println(&quot;did not apply because not start with upper case&quot;);</span>
      }
<span class="nc" id="L867">      return &quot;0&quot;;</span>
    }
<span class="nc bnc" id="L869" title="All 2 branches missed.">    if (allUpperCase(word)) {</span>
<span class="nc" id="L870">      ret = &quot;all:&quot;;</span>
    } else {
<span class="nc" id="L872">      ret = &quot;start&quot;;</span>
    }

    //now find the distance
<span class="nc" id="L876">    int current = -1;</span>
<span class="nc" id="L877">    int distance = 1;</span>

    while (true) {
<span class="nc" id="L880">      String prevWord = pH.getWord(h, current);</span>
<span class="nc bnc" id="L881" title="All 2 branches missed.">      if (startsLowerCase(prevWord)) {</span>
<span class="nc bnc" id="L882" title="All 2 branches missed.">        if (verbose) {</span>
<span class="nc" id="L883">          System.out.println(&quot;returning &quot; + (ret + current) + &quot;for &quot; + word + ' ' + prevWord);</span>
        }
<span class="nc" id="L885">        return ret + distance;</span>
      }
<span class="nc bnc" id="L887" title="All 4 branches missed.">      if (prevWord.equals(naTag) || prevWord.equals(&quot;``&quot;)) {</span>
<span class="nc bnc" id="L888" title="All 2 branches missed.">        if (verbose) {</span>
<span class="nc" id="L889">          System.out.println(&quot;returning &quot; + ret + &quot;infinity for &quot; + word + ' ' + prevWord);</span>
        }
<span class="nc" id="L891">        return ret + &quot;infinity&quot;;</span>
      }
<span class="nc" id="L893">      current--;</span>
<span class="nc" id="L894">      distance++;</span>
<span class="nc" id="L895">    }</span>
  }

<span class="nc" id="L898">  @Override public boolean isDynamic() { return false; }</span>
<span class="nc" id="L899">  @Override public boolean isLocal() { return false; }</span>

  private static final long serialVersionUID = 34L;

}


/**
 * This feature applies when the word is capitalized
 * and the previous lower case is infinity
 * and the lower cased version of it has occured 2 or more times with tag t
 * false if the word was not seen.
 * create features only for tags that are the same as the tag t
 */
class ExtractorCapLCSeen extends RareExtractor {

  final String tag;
<span class="nc" id="L916">  int cutoff = 1;</span>
<span class="nc" id="L917">  private final Extractor cCapDist = new ExtractorCapDistLC();</span>

  private transient Dictionary dict;

<span class="nc" id="L921">  ExtractorCapLCSeen(String tag) {</span>
<span class="nc" id="L922">    this.tag = tag;</span>
<span class="nc" id="L923">  }</span>

  @Override
  protected void setGlobalHolder(MaxentTagger tagger) {
<span class="nc" id="L927">    this.dict = tagger.dict;</span>
<span class="nc" id="L928">  }</span>


  @Override
  public boolean precondition(String tag1) {
<span class="nc" id="L933">    return tag.equals(tag1);</span>
  }

  @Override
  String extract(History h, PairsHolder pH) {
<span class="nc" id="L938">    String res = cCapDist.extract(h, pH);</span>
<span class="nc bnc" id="L939" title="All 2 branches missed.">    if (res.equals(&quot;0&quot;)) {</span>
<span class="nc" id="L940">      return res;</span>
    }
    //otherwise it is capitalized
<span class="nc" id="L943">    String word = pH.getWord(h, 0);</span>
<span class="nc bnc" id="L944" title="All 2 branches missed.">    if (dict.getCount(word, tag) &gt; cutoff) {</span>
<span class="nc" id="L945">      return res + tag;</span>
    } else {
<span class="nc" id="L947">      return &quot;0&quot;;</span>
    }
  }

<span class="nc" id="L951">  @Override public boolean isLocal() { return false; }</span>
<span class="nc" id="L952">  @Override public boolean isDynamic() { return false; }</span>

  private static final long serialVersionUID = 35L;

}


/**
 * &quot;1&quot; if not first word of sentence and _some_ letter is uppercase
 */
class ExtractorMidSentenceCap extends RareExtractor {

<span class="nc" id="L964">  public ExtractorMidSentenceCap() {</span>
<span class="nc" id="L965">  }</span>

  @Override
  String extract(History h, PairsHolder pH) {
<span class="nc" id="L969">    String prevTag = pH.getTag(h, -1);</span>
<span class="nc bnc" id="L970" title="All 2 branches missed.">    if(prevTag == null) { return &quot;0&quot;; }</span>
<span class="nc bnc" id="L971" title="All 2 branches missed.">    if (prevTag.equals(naTag)) {</span>
<span class="nc" id="L972">      return &quot;0&quot;;</span>
    }
<span class="nc" id="L974">    String s = pH.getWord(h, 0);</span>
<span class="nc bnc" id="L975" title="All 2 branches missed.">    if (containsUpperCase(s)) {</span>
<span class="nc" id="L976">      return &quot;1&quot;;</span>
    }
<span class="nc" id="L978">    return &quot;0&quot;;</span>
  }

  private static final long serialVersionUID = 24L;

<span class="nc" id="L983">  @Override public boolean isLocal() { return false; }</span>
<span class="nc" id="L984">  @Override public boolean isDynamic() { return true; }</span>
}


/**
 * &quot;0&quot; if not 1st word of sentence or not upper case, or lowercased version
 * not in dictionary.  Else first tag of word lowercased.
 */
class ExtractorStartSentenceCap extends RareExtractor {

  private transient Dictionary dict;

<span class="nc" id="L996">  public ExtractorStartSentenceCap() {</span>
<span class="nc" id="L997">  }</span>

  @Override
  protected void setGlobalHolder(MaxentTagger tagger) {
<span class="nc" id="L1001">    this.dict = tagger.dict;</span>
<span class="nc" id="L1002">  }</span>

  @Override
  String extract(History h, PairsHolder pH) {
<span class="nc" id="L1006">    String prevTag = pH.getTag(h, -1);</span>
<span class="nc bnc" id="L1007" title="All 2 branches missed.">    if(prevTag == null) { return zeroSt; }</span>
<span class="nc bnc" id="L1008" title="All 2 branches missed.">    if (!prevTag.equals(naTag)) {</span>
<span class="nc" id="L1009">      return zeroSt;</span>
    }
<span class="nc" id="L1011">    String s = pH.getWord(h, 0);</span>
<span class="nc bnc" id="L1012" title="All 2 branches missed.">    if (startsUpperCase(s)) {</span>
<span class="nc" id="L1013">      String s1 = s.toLowerCase();</span>
<span class="nc bnc" id="L1014" title="All 2 branches missed.">      if (dict.isUnknown(s1)) {</span>
<span class="nc" id="L1015">        return zeroSt;</span>
      }
<span class="nc" id="L1017">      return dict.getFirstTag(s1);</span>
    }
<span class="nc" id="L1019">    return zeroSt;</span>
  }

  private static final long serialVersionUID = 25L;

<span class="nc" id="L1024">  @Override public boolean isLocal() { return false; }</span>
<span class="nc" id="L1025">  @Override public boolean isDynamic() { return true; }</span>
}


/**
 * &quot;0&quot; if first word of sentence or not first letter uppercase or if
 * lowercase version isn't in dictionary.  Otherwise first tag of lowercase
 * equivalent.
 */
class ExtractorMidSentenceCapC extends RareExtractor {

  private transient Dictionary dict;

<span class="nc" id="L1038">  public ExtractorMidSentenceCapC() {</span>
<span class="nc" id="L1039">  }</span>

  @Override
  protected void setGlobalHolder(MaxentTagger tagger) {
<span class="nc" id="L1043">    this.dict = tagger.dict;</span>
<span class="nc" id="L1044">  }</span>

  @Override
  String extract(History h, PairsHolder pH) {
<span class="nc" id="L1048">    String prevTag = pH.getTag(h, -1);</span>
<span class="nc bnc" id="L1049" title="All 2 branches missed.">    if (prevTag == null) { return zeroSt; }</span>
<span class="nc bnc" id="L1050" title="All 2 branches missed.">    if (prevTag.equals(naTag)) {</span>
<span class="nc" id="L1051">      return zeroSt;</span>
    }
<span class="nc" id="L1053">    String s = pH.getWord(h, 0);</span>
<span class="nc bnc" id="L1054" title="All 2 branches missed.">    if (startsUpperCase(s)) {</span>
<span class="nc" id="L1055">      String s1 = s.toLowerCase();</span>
<span class="nc bnc" id="L1056" title="All 2 branches missed.">      if (dict.isUnknown(s1)) {</span>
<span class="nc" id="L1057">        return zeroSt;</span>
      }
<span class="nc" id="L1059">      return dict.getFirstTag(s1);</span>
    }
<span class="nc" id="L1061">    return zeroSt;</span>
  }

  private static final long serialVersionUID = 26L;

<span class="nc" id="L1066">  @Override public boolean isLocal() { return false; }</span>
<span class="nc" id="L1067">  @Override public boolean isDynamic() { return true; }</span>
}


class ExtractorCapC extends RareExtractor {

  private transient Dictionary dict;

<span class="nc" id="L1075">  public ExtractorCapC() {</span>
<span class="nc" id="L1076">  }</span>

  @Override
  protected void setGlobalHolder(MaxentTagger tagger) {
<span class="nc" id="L1080">    this.dict = tagger.dict;</span>
<span class="nc" id="L1081">  }</span>

  @Override
  String extract(History h, PairsHolder pH) {
<span class="nc" id="L1085">    String s = pH.getWord(h, 0);</span>
<span class="nc bnc" id="L1086" title="All 2 branches missed.">    if (startsUpperCase(s)) {</span>
<span class="nc" id="L1087">      String s1 = s.toLowerCase();</span>
<span class="nc bnc" id="L1088" title="All 2 branches missed.">      if (dict.isUnknown(s1)) {</span>
<span class="nc" id="L1089">        return zeroSt;</span>
      }
<span class="nc" id="L1091">      return dict.getFirstTag(s1);</span>
    }
<span class="nc" id="L1093">    return zeroSt;</span>
  }

  private static final long serialVersionUID = 26L;

<span class="nc" id="L1098">  @Override public boolean isLocal() { return true; }</span>
<span class="nc" id="L1099">  @Override public boolean isDynamic() { return false; }</span>
}

// TODO: the next time we have to rebuild the tagger files anyway, we
// should change this class's name to something like
// &quot;ExtractorNoLowercase&quot; to distinguish it from
// ExtractorAllCapitalized
class ExtractorAllCap extends RareExtractor {

<span class="fc" id="L1108">  public ExtractorAllCap() {</span>
<span class="fc" id="L1109">  }</span>

  @Override
  String extract(History h, PairsHolder pH) {
<span class="nc" id="L1113">    String s = pH.getWord(h, 0);</span>
<span class="nc bnc" id="L1114" title="All 2 branches missed.">    if (noneLowerCase(s)) {</span>
<span class="nc" id="L1115">      return &quot;1&quot;;</span>
    }
<span class="nc" id="L1117">    return &quot;0&quot;;</span>
  }

  private static final long serialVersionUID = 27L;

<span class="nc" id="L1122">  @Override public boolean isLocal() { return true; }</span>
<span class="nc" id="L1123">  @Override public boolean isDynamic() { return false; }</span>
}


class ExtractorAllCapitalized extends RareExtractor {

<span class="fc" id="L1129">  public ExtractorAllCapitalized() {</span>
<span class="fc" id="L1130">  }</span>

  @Override
  String extract(History h, PairsHolder pH) {
<span class="nc" id="L1134">    String s = pH.getWord(h, 0);</span>
<span class="nc bnc" id="L1135" title="All 2 branches missed.">    if (allUpperCase(s)) {</span>
<span class="nc" id="L1136">      return &quot;1&quot;;</span>
    }
<span class="nc" id="L1138">    return &quot;0&quot;;</span>
  }

  private static final long serialVersionUID = 32L;

<span class="nc" id="L1143">  @Override public boolean isLocal() { return true; }</span>
<span class="nc" id="L1144">  @Override public boolean isDynamic() { return false; }</span>
}


class ExtractorCNumber extends RareExtractor {

<span class="fc" id="L1150">  public ExtractorCNumber() {</span>
<span class="fc" id="L1151">  }</span>

  @Override
  String extract(History h, PairsHolder pH) {
<span class="nc" id="L1155">    String s = pH.getWord(h, 0);</span>
<span class="nc bnc" id="L1156" title="All 2 branches missed.">    if (containsNumber(s)) {</span>
<span class="nc" id="L1157">      return &quot;1&quot;;</span>
    }
<span class="nc" id="L1159">    return &quot;0&quot;;</span>
  }

  private static final long serialVersionUID = 28L;

<span class="nc" id="L1164">  @Override public boolean isLocal() { return true; }</span>
<span class="nc" id="L1165">  @Override public boolean isDynamic() { return false; }</span>
}


class ExtractorDash extends RareExtractor {

<span class="fc" id="L1171">  public ExtractorDash() {</span>
<span class="fc" id="L1172">  }</span>

  @Override
  String extract(History h, PairsHolder pH) {
<span class="nc" id="L1176">    String s = pH.getWord(h, 0);</span>
<span class="nc bnc" id="L1177" title="All 2 branches missed.">    if (containsDash(s)) {</span>
<span class="nc" id="L1178">      return &quot;1&quot;;</span>
    }
<span class="nc" id="L1180">    return &quot;0&quot;;</span>
  }

<span class="nc" id="L1183">  @Override public boolean isLocal() { return true; }</span>
<span class="nc" id="L1184">  @Override public boolean isDynamic() { return false; }</span>

  private static final long serialVersionUID = 29L;
}


class ExtractorWordSuff extends RareExtractor {

  // todo [cdm 2013]: position field in this class could be deleted and use super's position. But will break
  private final int num, position;

<span class="fc" id="L1195">  ExtractorWordSuff(int num, int position) {</span>
<span class="fc" id="L1196">    this.num = num;</span>
<span class="fc" id="L1197">    this.position = position;</span>
<span class="fc" id="L1198">  }</span>

  @Override
  String extract(History h, PairsHolder pH) {
    // String word = TestSentence.toNice(pH.getWord(h, 0));
<span class="nc" id="L1203">    String word = pH.getWord(h, position);</span>
<span class="nc bnc" id="L1204" title="All 2 branches missed.">    if (word.length() &lt; num) {</span>
<span class="nc" id="L1205">      return &quot;######&quot;;</span>
    }
<span class="nc" id="L1207">    return word.substring(word.length() - num);</span>
  }

  private static final long serialVersionUID = 724767436530L;

  @Override
  public String toString() {
<span class="nc" id="L1214">    return StringUtils.getShortClassName(this) + &quot;(len&quot; + num + &quot;,w&quot; + position + &quot;)&quot;;</span>
  }

<span class="nc bnc" id="L1217" title="All 2 branches missed.">  @Override public boolean isLocal() { return (position == 0); }</span>
<span class="nc" id="L1218">  @Override public boolean isDynamic() { return false; }</span>

}


class ExtractorWordPref extends RareExtractor {

  // todo [cdm 2013]: position field in this class could be deleted and use super's position. But will break
  private final int num, position;

<span class="nc" id="L1228">  ExtractorWordPref(int num, int position) {</span>
<span class="nc" id="L1229">    this.num = num;</span>
<span class="nc" id="L1230">    this.position = position;</span>
<span class="nc" id="L1231">  }</span>

  @Override
  String extract(History h, PairsHolder pH) {
    // String word = TestSentence.toNice(pH.getWord(h, 0));
<span class="nc" id="L1236">    String word = pH.getWord(h, position);</span>
<span class="nc bnc" id="L1237" title="All 2 branches missed.">    if (word.length() &lt; num) {</span>
<span class="nc" id="L1238">      return &quot;######&quot;;</span>
    } else {
<span class="nc" id="L1240">      return word.substring(0, num);</span>
    }
  }

  private static final long serialVersionUID = 724767436531L;

  @Override
  public String toString() {
<span class="nc" id="L1248">    return StringUtils.getShortClassName(this) + &quot;(len&quot; + num + &quot;,w&quot; + position + &quot;)&quot;;</span>
  }

<span class="nc bnc" id="L1251" title="All 2 branches missed.">  @Override public boolean isLocal() { return (position == 0); }</span>
<span class="nc" id="L1252">  @Override public boolean isDynamic() { return false; }</span>
} // end class ExtractorWordPref


class ExtractorsConjunction extends RareExtractor {

  private final Extractor extractor1;
  private final Extractor extractor2;

  volatile boolean isLocal, isDynamic;

<span class="nc" id="L1263">  ExtractorsConjunction(Extractor e1, Extractor e2) {</span>
<span class="nc" id="L1264">    extractor1 = e1;</span>
<span class="nc" id="L1265">    extractor2 = e2;</span>
<span class="nc bnc" id="L1266" title="All 4 branches missed.">    isLocal = e1.isLocal() &amp;&amp; e2.isLocal();</span>
<span class="nc bnc" id="L1267" title="All 4 branches missed.">    isDynamic = e1.isDynamic() || e2.isDynamic();</span>
<span class="nc" id="L1268">  }</span>

  @Override
  protected void setGlobalHolder(MaxentTagger tagger) {
<span class="nc" id="L1272">    extractor1.setGlobalHolder(tagger);</span>
<span class="nc" id="L1273">    extractor2.setGlobalHolder(tagger);</span>
<span class="nc" id="L1274">  }</span>

  @Override
  String extract(History h, PairsHolder pH) {
<span class="nc" id="L1278">    String ex1 = extractor1.extract(h, pH);</span>
<span class="nc bnc" id="L1279" title="All 2 branches missed.">    if (ex1.equals(zeroSt)) {</span>
<span class="nc" id="L1280">      return zeroSt;</span>
    }
<span class="nc" id="L1282">    String ex2 = extractor2.extract(h, pH);</span>
<span class="nc bnc" id="L1283" title="All 2 branches missed.">    if (ex2.equals(zeroSt)) {</span>
<span class="nc" id="L1284">      return zeroSt;</span>
    }
<span class="nc" id="L1286">    return ex1 + ':' + ex2;</span>
  }

  private static final long serialVersionUID = 36L;

<span class="nc" id="L1291">  @Override public boolean isLocal() { return isLocal; }</span>
<span class="nc" id="L1292">  @Override public boolean isDynamic() { return isDynamic; }</span>

  @Override
  public String toString() {
<span class="nc" id="L1296">    return StringUtils.getShortClassName(this) + '(' + extractor1 + ',' + extractor2 + ')';</span>
  }


}


class PluralAcronymDetector extends RareExtractor {

<span class="nc" id="L1305">  public PluralAcronymDetector() {</span>
<span class="nc" id="L1306">  }</span>

  private static boolean pluralAcronym(String s) {
<span class="nc" id="L1309">    int len = s.length();</span>
<span class="nc" id="L1310">    len--;</span>
<span class="nc bnc" id="L1311" title="All 2 branches missed.">    if (s.charAt(len) != 's') {</span>
<span class="nc" id="L1312">      return false;</span>
    }
<span class="nc bnc" id="L1314" title="All 2 branches missed.">    for (int i = 0; i &lt; len; i++) {</span>
<span class="nc bnc" id="L1315" title="All 2 branches missed.">      if (!Character.isUpperCase(s.charAt(i))) {</span>
<span class="nc" id="L1316">        return false;</span>
      }
    }
<span class="nc" id="L1319">    return true;</span>
  }

  @Override
  String extract(History h, PairsHolder pH) {
<span class="nc" id="L1324">    String s = pH.getWord(h, 0);</span>
<span class="nc bnc" id="L1325" title="All 2 branches missed.">    if (pluralAcronym(s)) {</span>
<span class="nc" id="L1326">      return &quot;1&quot;;</span>
    }
<span class="nc" id="L1328">    return &quot;0&quot;;</span>
  }

  private static final long serialVersionUID = 33L;

<span class="nc" id="L1333">  @Override public boolean isLocal() { return true; }</span>
<span class="nc" id="L1334">  @Override public boolean isDynamic() { return false; }</span>

}


class CtbPreDetector extends RareExtractor {

  private String t1;

  CtbPreDetector(String t2, int n2) {
<span class="nc" id="L1344">    super(n2);</span>
<span class="nc" id="L1345">    t1=t2;</span>
<span class="nc" id="L1346">  }</span>

  @Override
  String extract(History h, PairsHolder pH) {
<span class="nc" id="L1350">    String s = TestSentence.toNice(pH.getWord(h, position));</span>

<span class="nc bnc" id="L1352" title="All 4 branches missed.">    if (!s.equals(&quot;&quot;) &amp;&amp; CtbDict.getTagPre(t1, s.substring(0, 1)).equals(&quot;1&quot;))</span>
<span class="nc" id="L1353">      return &quot;1:&quot;+t1;</span>
<span class="nc" id="L1354">    return &quot;0:&quot;+t1;</span>
  }

  private static final long serialVersionUID = 43L;

  @Override
  public String toString() {
<span class="nc" id="L1361">    return super.toString() + &quot; tag=&quot; + t1;</span>
  }

<span class="nc" id="L1364">  @Override public boolean isLocal() { return false; }</span>
<span class="nc" id="L1365">  @Override public boolean isDynamic() { return false; }</span>

} // end class ctbPreDetector


class CtbSufDetector extends RareExtractor {

  private String t1;

  CtbSufDetector(String t2, int n2) {
<span class="nc" id="L1375">    super(n2);</span>
<span class="nc" id="L1376">    t1=t2;</span>
<span class="nc" id="L1377">  }</span>

  @Override
  String extract(History h, PairsHolder pH) {
<span class="nc" id="L1381">    String s=TestSentence.toNice(pH.getWord(h, position));</span>

<span class="nc bnc" id="L1383" title="All 4 branches missed.">    if(!s.equals(&quot;&quot;) &amp;&amp; CtbDict.getTagSuf(t1, s.substring(s.length()-1, s.length())).equals(&quot;1&quot;))</span>
<span class="nc" id="L1384">      return &quot;1:&quot;+t1;</span>
<span class="nc" id="L1385">    return &quot;0:&quot;+t1;</span>
  }

  private static final long serialVersionUID = 44L;

<span class="nc" id="L1390">  @Override public boolean isLocal() { return false; }</span>
<span class="nc" id="L1391">  @Override public boolean isDynamic() { return false; }</span>

  @Override
  public String toString() {
<span class="nc" id="L1395">    return super.toString() + &quot; tag=&quot; + t1;</span>
  }

} // end class ctbPreDetector

/*
class ASBCPreDetector extends RareExtractor {
  private String t1;
  private int n1;
  public ASBCPreDetector(String t2, int n2) {
    t1=t2;
    n1=n2;
  }

  @Override
  String extract(History h, PairsHolder pH) {
    String s=TestSentence.toNice(pH.get(h,n1,false));

    if(!s.equals(&quot;&quot;) &amp;&amp; ASBCDict.getTagPre(t1, s.substring(0, 1)).equals(&quot;1&quot;))
      return &quot;1:&quot;+t1;
    return &quot;0:&quot;+t1;
  }
  private static final long serialVersionUID = 53L;
} // end class ASBCPreDetector

class ASBCSufDetector extends RareExtractor {
  private String t1;
  private int n1;
  public ASBCSufDetector(String t2, int n2) {
    t1=t2;
    n1=n2;
  }

  @Override
  String extract(History h, PairsHolder pH) {
    String s=TestSentence.toNice(pH.get(h,n1,false));
    if (!s.equals(&quot;&quot;) &amp;&amp; ASBCDict.getTagSuf(t1, s.substring(s.length()-1, s.length())).equals(&quot;1&quot;))
      return &quot;1:&quot;+t1;
    return &quot;0:&quot;+t1;
  }
  private static final long serialVersionUID = 54L;
} // end class ASBCPreDetector
*/

class ASBCunkDetector extends RareExtractor {

  private String t1;
  private int n1;

<span class="nc" id="L1444">  ASBCunkDetector(String t2, int n2) {</span>
<span class="nc" id="L1445">    t1=t2;</span>
<span class="nc" id="L1446">    n1=n2;</span>
<span class="nc" id="L1447">  }</span>

  @Override
  String extract(History h, PairsHolder pH) {
<span class="nc" id="L1451">    String s=TestSentence.toNice(pH.getWord(h,n1));</span>

<span class="nc bnc" id="L1453" title="All 2 branches missed.">    if (ASBCunkDict.getTag(t1, s).equals(&quot;1&quot;))</span>
<span class="nc" id="L1454">      return &quot;1:&quot;+t1;</span>
<span class="nc" id="L1455">    return &quot;0:&quot;+t1;</span>
  }

  private static final long serialVersionUID = 57L;

<span class="nc" id="L1460">  @Override public boolean isLocal() { return false; }</span>
<span class="nc" id="L1461">  @Override public boolean isDynamic() { return false; }</span>

} // end class ASBCunkDetector

class CTBunkDictDetector extends RareExtractor {

  private String t1;
  private int n1;

<span class="nc" id="L1470">  CTBunkDictDetector(String t2, int n2) {</span>
<span class="nc" id="L1471">    t1=t2;</span>
<span class="nc" id="L1472">    n1=n2;</span>
<span class="nc" id="L1473">  }</span>

  @Override
  String extract(History h, PairsHolder pH) {
<span class="nc" id="L1477">    String s=TestSentence.toNice(pH.getWord(h,n1));</span>

<span class="nc bnc" id="L1479" title="All 2 branches missed.">    if (CTBunkDict.getTag(t1, s).equals(&quot;1&quot;))</span>
<span class="nc" id="L1480">      return &quot;1:&quot;+t1;</span>
<span class="nc" id="L1481">    return &quot;0:&quot;+t1;</span>
  }

  private static final long serialVersionUID = 80L;

<span class="nc" id="L1486">  @Override public boolean isLocal() { return false; }</span>
<span class="nc" id="L1487">  @Override public boolean isDynamic() { return false; }</span>

} // end class CTBunkDictDetector


<span class="fc" id="L1492">abstract class CWordBooleanExtractor extends RareExtractor {</span>
  @Override
  String extract(History h, PairsHolder pH) {
<span class="nc" id="L1495">    String cword = pH.getWord(h, 0);</span>
<span class="nc bnc" id="L1496" title="All 2 branches missed.">    return extractFeature(cword) ? &quot;1&quot; : &quot;0&quot;;</span>
  }

  abstract boolean extractFeature(String cword);

<span class="nc" id="L1501">  @Override public boolean isLocal() { return true; }</span>
<span class="nc" id="L1502">  @Override public boolean isDynamic() { return false; }</span>
}


<span class="fc" id="L1506">class ExtractorFrenchNounSuffix extends CWordBooleanExtractor {</span>

  private static final long serialVersionUID = 848772358776880060L;

  @Override
  boolean extractFeature(String cword) {
<span class="nc" id="L1512">    return FrenchUnknownWordSignatures.hasNounSuffix(cword);</span>
  }
}


<span class="fc" id="L1517">class ExtractorFrenchAdvSuffix extends CWordBooleanExtractor {</span>

  private static final long serialVersionUID = 9141591417435848689L;

  @Override
  boolean extractFeature(String cword) {
<span class="nc" id="L1523">    return FrenchUnknownWordSignatures.hasAdvSuffix(cword);</span>
  }
}


<span class="fc" id="L1528">class ExtractorFrenchVerbSuffix extends CWordBooleanExtractor {</span>

  private static final long serialVersionUID = -1762307766086637191L;

  @Override
  boolean extractFeature(String cword) {
<span class="nc" id="L1534">    return FrenchUnknownWordSignatures.hasVerbSuffix(cword);</span>
  }
}


<span class="fc" id="L1539">class ExtractorFrenchAdjSuffix extends CWordBooleanExtractor {</span>

  private static final long serialVersionUID = -5838046941039275411L;

  @Override
  boolean extractFeature(String cword) {
<span class="nc" id="L1545">    return FrenchUnknownWordSignatures.hasAdjSuffix(cword);</span>
  }
}


<span class="fc" id="L1550">class ExtractorFrenchPluralSuffix extends CWordBooleanExtractor {</span>

  private static final long serialVersionUID = 1139695807527192176L;

  @Override
  boolean extractFeature(String cword) {
<span class="nc" id="L1556">    return FrenchUnknownWordSignatures.hasPossiblePlural(cword);</span>
  }
}


<span class="fc" id="L1561">class ExtractorSpanishGender extends RareExtractor {</span>

  private static final long serialVersionUID = -7359312929174070404L;

  @Override
  String extract(History h, PairsHolder pH) {
<span class="nc" id="L1567">    String cword = pH.getWord(h, 0);</span>
<span class="nc bnc" id="L1568" title="All 2 branches missed.">    if (SpanishUnknownWordSignatures.hasMasculineSuffix(cword))</span>
<span class="nc" id="L1569">      return &quot;m&quot;;</span>
<span class="nc bnc" id="L1570" title="All 2 branches missed.">    else if (SpanishUnknownWordSignatures.hasFeminineSuffix(cword))</span>
<span class="nc" id="L1571">      return &quot;f&quot;;</span>
    else
<span class="nc" id="L1573">      return &quot;&quot;;</span>
  }
}


<span class="fc" id="L1578">class ExtractorSpanishConditionalSuffix extends CWordBooleanExtractor {</span>

  private static final long serialVersionUID = 4383251116043848632L;

  @Override
  boolean extractFeature(String cword) {
<span class="nc" id="L1584">    return SpanishUnknownWordSignatures.hasConditionalSuffix(cword);</span>
  }
}


<span class="fc" id="L1589">class ExtractorSpanishImperfectErIrSuffix extends CWordBooleanExtractor {</span>

  private static final long serialVersionUID = -5804047931816433075L;

  @Override
  boolean extractFeature(String cword) {
<span class="nc" id="L1595">    return SpanishUnknownWordSignatures.hasImperfectErIrSuffix(cword);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>