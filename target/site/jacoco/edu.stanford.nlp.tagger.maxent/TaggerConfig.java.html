<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TaggerConfig.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.tagger.maxent</a> &gt; <span class="el_source">TaggerConfig.java</span></div><h1>TaggerConfig.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.tagger.maxent; 
import edu.stanford.nlp.util.logging.Redwood;

import edu.stanford.nlp.util.StringUtils;

import java.io.*;
import java.util.Map;
import java.util.Properties;

import edu.stanford.nlp.io.IOUtils;
import edu.stanford.nlp.io.RuntimeIOException;
import edu.stanford.nlp.util.Generics;

/**
 * Reads and stores configuration information for a POS tagger.
 *
 * &lt;i&gt;Implementation note:&lt;/i&gt; To add a new parameter: (1) define a default
 * String value, (2) add it to defaultValues map, (3) add line to constructor,
 * (4) add getter method, (5) add to dump() method, (6) add to printGenProps()
 * method, (7) add to class javadoc of MaxentTagger.
 *
 *  @author William Morgan
 *  @author Anna Rafferty
 *  @author Michel Galley
 */
public class TaggerConfig extends Properties /* Inherits implementation of Serializable! */  {

  /** A logger for this class */
<span class="nc" id="L29">  private static Redwood.RedwoodChannels log = Redwood.channels(TaggerConfig.class);</span>

  private static final long serialVersionUID = -4136407850147157497L;

<span class="nc" id="L33">  public enum Mode {</span>
<span class="nc" id="L34">    TRAIN, TEST, TAG, DUMP</span>
  }

  /* defaults. sentenceDelimiter might be null; the others all have non-null values. */
  public static final String
  SEARCH = &quot;qn&quot;,
  TAG_SEPARATOR = &quot;/&quot;,
  TOKENIZE = &quot;true&quot;,
  DEBUG = &quot;false&quot;,
  ITERATIONS = &quot;100&quot;,
  ARCH = &quot;&quot;,
  WORD_FUNCTION = &quot;&quot;,
  RARE_WORD_THRESH = &quot;5&quot;,
  MIN_FEATURE_THRESH = &quot;5&quot;,
  CUR_WORD_MIN_FEATURE_THRESH = &quot;2&quot;,
  RARE_WORD_MIN_FEATURE_THRESH = &quot;10&quot;,
  VERY_COMMON_WORD_THRESH = &quot;250&quot;,
  OCCURRING_TAGS_ONLY = &quot;false&quot;,
  POSSIBLE_TAGS_ONLY = &quot;false&quot;,
<span class="nc" id="L53">  SIGMA_SQUARED = String.valueOf(0.5),</span>
  ENCODING = &quot;UTF-8&quot;,
  LEARN_CLOSED_CLASS = &quot;false&quot;,
  CLOSED_CLASS_THRESHOLD = &quot;40&quot;,
  VERBOSE = &quot;false&quot;,
  VERBOSE_RESULTS = &quot;true&quot;,
  SGML = &quot;false&quot;,
  LANG = &quot;&quot;,
  TOKENIZER_FACTORY = &quot;&quot;,
  XML_INPUT = &quot;&quot;,
  TAG_INSIDE = &quot;&quot;,
  APPROXIMATE = &quot;-1.0&quot;,
  TOKENIZER_OPTIONS = &quot;&quot;,
  DEFAULT_REG_L1 = &quot;1.0&quot;,
  OUTPUT_FILE = &quot;&quot;,
  OUTPUT_FORMAT = &quot;slashTags&quot;,
  OUTPUT_FORMAT_OPTIONS = &quot;&quot;,
  NTHREADS = &quot;1&quot;;

  public static final String ENCODING_PROPERTY = &quot;encoding&quot;,
  TAG_SEPARATOR_PROPERTY = &quot;tagSeparator&quot;;


<span class="nc" id="L76">  private static final Map&lt;String, String&gt; defaultValues = Generics.newHashMap();</span>
  static {
<span class="nc" id="L78">    defaultValues.put(&quot;arch&quot;, ARCH);</span>
<span class="nc" id="L79">    defaultValues.put(&quot;wordFunction&quot;, WORD_FUNCTION);</span>
<span class="nc" id="L80">    defaultValues.put(&quot;closedClassTags&quot;, &quot;&quot;);</span>
<span class="nc" id="L81">    defaultValues.put(&quot;closedClassTagThreshold&quot;, CLOSED_CLASS_THRESHOLD);</span>
<span class="nc" id="L82">    defaultValues.put(&quot;search&quot;, SEARCH);</span>
<span class="nc" id="L83">    defaultValues.put(TAG_SEPARATOR_PROPERTY, TAG_SEPARATOR);</span>
<span class="nc" id="L84">    defaultValues.put(&quot;tokenize&quot;, TOKENIZE);</span>
<span class="nc" id="L85">    defaultValues.put(&quot;debug&quot;, DEBUG);</span>
<span class="nc" id="L86">    defaultValues.put(&quot;iterations&quot;, ITERATIONS);</span>
<span class="nc" id="L87">    defaultValues.put(&quot;rareWordThresh&quot;, RARE_WORD_THRESH);</span>
<span class="nc" id="L88">    defaultValues.put(&quot;minFeatureThresh&quot;, MIN_FEATURE_THRESH);</span>
<span class="nc" id="L89">    defaultValues.put(&quot;curWordMinFeatureThresh&quot;, CUR_WORD_MIN_FEATURE_THRESH);</span>
<span class="nc" id="L90">    defaultValues.put(&quot;rareWordMinFeatureThresh&quot;, RARE_WORD_MIN_FEATURE_THRESH);</span>
<span class="nc" id="L91">    defaultValues.put(&quot;veryCommonWordThresh&quot;, VERY_COMMON_WORD_THRESH);</span>
<span class="nc" id="L92">    defaultValues.put(&quot;occurringTagsOnly&quot;, OCCURRING_TAGS_ONLY);</span>
<span class="nc" id="L93">    defaultValues.put(&quot;possibleTagsOnly&quot;, POSSIBLE_TAGS_ONLY);</span>
<span class="nc" id="L94">    defaultValues.put(&quot;sigmaSquared&quot;, SIGMA_SQUARED);</span>
<span class="nc" id="L95">    defaultValues.put(ENCODING_PROPERTY, ENCODING);</span>
<span class="nc" id="L96">    defaultValues.put(&quot;learnClosedClassTags&quot;, LEARN_CLOSED_CLASS);</span>
<span class="nc" id="L97">    defaultValues.put(&quot;verbose&quot;, VERBOSE);</span>
<span class="nc" id="L98">    defaultValues.put(&quot;verboseResults&quot;, VERBOSE_RESULTS);</span>
<span class="nc" id="L99">    defaultValues.put(&quot;openClassTags&quot;, &quot;&quot;);</span>
<span class="nc" id="L100">    defaultValues.put(&quot;lang&quot;, LANG);</span>
<span class="nc" id="L101">    defaultValues.put(&quot;tokenizerFactory&quot;, TOKENIZER_FACTORY);</span>
<span class="nc" id="L102">    defaultValues.put(&quot;xmlInput&quot;, XML_INPUT);</span>
<span class="nc" id="L103">    defaultValues.put(&quot;tagInside&quot;, TAG_INSIDE);</span>
<span class="nc" id="L104">    defaultValues.put(&quot;sgml&quot;, SGML);</span>
<span class="nc" id="L105">    defaultValues.put(&quot;approximate&quot;, APPROXIMATE);</span>
<span class="nc" id="L106">    defaultValues.put(&quot;tokenizerOptions&quot;, TOKENIZER_OPTIONS);</span>
<span class="nc" id="L107">    defaultValues.put(&quot;regL1&quot;, DEFAULT_REG_L1);</span>
<span class="nc" id="L108">    defaultValues.put(&quot;outputFile&quot;, OUTPUT_FILE);</span>
<span class="nc" id="L109">    defaultValues.put(&quot;outputFormat&quot;, OUTPUT_FORMAT);</span>
<span class="nc" id="L110">    defaultValues.put(&quot;outputFormatOptions&quot;, OUTPUT_FORMAT_OPTIONS);</span>
<span class="nc" id="L111">    defaultValues.put(&quot;nthreads&quot;, NTHREADS);</span>
<span class="nc" id="L112">  }</span>

  /**
   * This constructor is just for creating an instance with default values.
   * Used internally.
   */
  private TaggerConfig() {
<span class="nc" id="L119">    super();</span>
<span class="nc" id="L120">    this.putAll(defaultValues);</span>
<span class="nc" id="L121">  }</span>

  /**
   * We force you to pass in a TaggerConfig rather than any other
   * superclass so that we know the arg error checking has already occurred
   */
  public TaggerConfig(TaggerConfig old) {
<span class="nc" id="L128">    super(old);</span>
<span class="nc" id="L129">  }</span>

  public TaggerConfig(String... args) {
<span class="nc" id="L132">    this(StringUtils.argsToProperties(args));</span>
<span class="nc" id="L133">  }</span>

  public TaggerConfig(Properties props) {
    // load up the default properties
<span class="nc" id="L137">    this();</span>

    /* Try and use the default properties from the model */
    // Properties modelProps = new Properties();
    // TaggerConfig oldConfig = new TaggerConfig(); // loads default values in oldConfig
<span class="nc bnc" id="L142" title="All 2 branches missed.">    if (! props.containsKey(&quot;trainFile&quot;)) {</span>
<span class="nc" id="L143">      String name = props.getProperty(&quot;model&quot;);</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">      if (name == null) {</span>
<span class="nc" id="L145">        name = props.getProperty(&quot;dump&quot;);</span>
      }
<span class="nc bnc" id="L147" title="All 2 branches missed.">      if (name != null) {</span>
        try {
<span class="nc" id="L149">          log.info(&quot;Loading default properties from tagger &quot; + name);</span>
<span class="nc" id="L150">          DataInputStream in = new DataInputStream(IOUtils.getInputStreamFromURLOrClasspathOrFileSystem(name));</span>
<span class="nc" id="L151">          this.putAll(TaggerConfig.readConfig(in)); // overwrites defaults with any serialized values.</span>
<span class="nc" id="L152">          in.close();</span>
<span class="nc" id="L153">        } catch (Exception e) {</span>
<span class="nc" id="L154">          throw new RuntimeIOException(&quot;No such trained tagger config file found: &quot; + name);</span>
<span class="nc" id="L155">        }</span>
      }
    }

<span class="nc" id="L159">    setProperties(props);</span>
<span class="nc" id="L160">  }</span>

  public void setProperties(Properties props) {
<span class="nc bnc" id="L163" title="All 2 branches missed.">    if (props.getProperty(&quot;&quot;) != null) {</span>
<span class="nc" id="L164">      throw new RuntimeException(&quot;unknown argument(s): \&quot;&quot; + props.getProperty(&quot;&quot;) + '\&quot;');</span>
    }

<span class="nc bnc" id="L167" title="All 2 branches missed.">    if (props.getProperty(&quot;genprops&quot;) != null) {</span>
<span class="nc" id="L168">      printGenProps(System.out);</span>
<span class="nc" id="L169">      System.exit(0);</span>
    }

<span class="nc bnc" id="L172" title="All 4 branches missed.">    if (props.containsKey(&quot;mode&quot;) &amp;&amp; props.containsKey(&quot;file&quot;)) {</span>
<span class="nc" id="L173">      this.setProperty(&quot;mode&quot;, props.getProperty(&quot;mode&quot;));</span>
<span class="nc" id="L174">      this.setProperty(&quot;file&quot;, props.getProperty(&quot;file&quot;));</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">    } else if (props.containsKey(&quot;trainFile&quot;)) {</span>
      //Training mode
<span class="nc" id="L177">      this.setProperty(&quot;mode&quot;, Mode.TRAIN.toString());</span>
<span class="nc" id="L178">      this.setProperty(&quot;file&quot;, props.getProperty(&quot;trainFile&quot;, &quot;&quot;).trim());</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">    } else if (props.containsKey(&quot;testFile&quot;)) {</span>
      //Testing mode
<span class="nc" id="L181">      this.setProperty(&quot;mode&quot;, Mode.TEST.toString());</span>
<span class="nc" id="L182">      this.setProperty(&quot;file&quot;, props.getProperty(&quot;testFile&quot;, &quot;&quot;).trim());</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">    } else if (props.containsKey(&quot;textFile&quot;)) {</span>
      //Tagging mode
<span class="nc" id="L185">      this.setProperty(&quot;mode&quot;, Mode.TAG.toString());</span>
<span class="nc" id="L186">      this.setProperty(&quot;file&quot;, props.getProperty(&quot;textFile&quot;, &quot;&quot;).trim());</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">    } else if (props.containsKey(&quot;dump&quot;)) {</span>
<span class="nc" id="L188">      this.setProperty(&quot;mode&quot;, Mode.DUMP.toString());</span>
      // this.setProperty(&quot;file&quot;, props.getProperty(&quot;dump&quot;).trim());
<span class="nc" id="L190">      props.setProperty(&quot;model&quot;, props.getProperty(&quot;dump&quot;).trim());</span>
    } else {
<span class="nc" id="L192">      this.setProperty(&quot;mode&quot;, Mode.TAG.toString());</span>
<span class="nc" id="L193">      this.setProperty(&quot;file&quot;, &quot;stdin&quot;);</span>
    }
    //for any mode other than train, we load a classifier, which means we load a config - model always needs to be specified
    //on command line/in props file
    //Get the path to the model (or the path where you'd like to save the model); this is necessary for training, testing, and tagging
<span class="nc" id="L198">    this.setProperty(&quot;model&quot;, props.getProperty(&quot;model&quot;, this.getProperty(&quot;model&quot;, &quot;&quot;)).trim());</span>
<span class="nc bnc" id="L199" title="All 4 branches missed.">    if ( ! (this.getMode() == Mode.DUMP) &amp;&amp; this.getProperty(&quot;model&quot;).equals(&quot;&quot;)) {</span>
<span class="nc" id="L200">      throw new RuntimeException(&quot;'model' parameter must be specified&quot;);</span>
    }

<span class="nc" id="L203">    this.setProperty(&quot;search&quot;, props.getProperty(&quot;search&quot;, this.getProperty(&quot;search&quot;)).trim().toLowerCase());</span>
<span class="nc" id="L204">    String srch = this.getProperty(&quot;search&quot;);</span>
<span class="nc bnc" id="L205" title="All 10 branches missed.">    if ( ! (srch.equals(&quot;cg&quot;) || srch.equals(&quot;iis&quot;) || srch.equals(&quot;owlqn&quot;) || srch.equals(&quot;qn&quot;) || srch.equals(&quot;owlqn2&quot;))) {</span>
<span class="nc" id="L206">      throw new RuntimeException(&quot;'search' must be one of 'iis', 'cg', 'qn' or 'owlqn' or 'owlqn2': &quot; + srch);</span>
    }

<span class="nc" id="L209">    this.setProperty(&quot;sigmaSquared&quot;, props.getProperty(&quot;sigmaSquared&quot;, this.getProperty(&quot;sigmaSquared&quot;)));</span>

<span class="nc" id="L211">    this.setProperty(TAG_SEPARATOR_PROPERTY, props.getProperty(TAG_SEPARATOR_PROPERTY, this.getProperty(TAG_SEPARATOR_PROPERTY)));</span>

<span class="nc" id="L213">    this.setProperty(&quot;iterations&quot;, props.getProperty(&quot;iterations&quot;, this.getProperty(&quot;iterations&quot;)));</span>
<span class="nc" id="L214">    this.setProperty(&quot;rareWordThresh&quot;, props.getProperty(&quot;rareWordThresh&quot;, this.getProperty(&quot;rareWordThresh&quot;)));</span>
<span class="nc" id="L215">    this.setProperty(&quot;minFeatureThresh&quot;, props.getProperty(&quot;minFeatureThresh&quot;, this.getProperty(&quot;minFeatureThresh&quot;)));</span>
<span class="nc" id="L216">    this.setProperty(&quot;curWordMinFeatureThresh&quot;, props.getProperty(&quot;curWordMinFeatureThresh&quot;, this.getProperty(&quot;curWordMinFeatureThresh&quot;)));</span>
<span class="nc" id="L217">    this.setProperty(&quot;rareWordMinFeatureThresh&quot;, props.getProperty(&quot;rareWordMinFeatureThresh&quot;, this.getProperty(&quot;rareWordMinFeatureThresh&quot;)));</span>
<span class="nc" id="L218">    this.setProperty(&quot;veryCommonWordThresh&quot;, props.getProperty(&quot;veryCommonWordThresh&quot;, this.getProperty(&quot;veryCommonWordThresh&quot;)));</span>
<span class="nc" id="L219">    this.setProperty(&quot;occurringTagsOnly&quot;, props.getProperty(&quot;occurringTagsOnly&quot;, this.getProperty(&quot;occurringTagsOnly&quot;, OCCURRING_TAGS_ONLY)));</span>
<span class="nc" id="L220">    this.setProperty(&quot;possibleTagsOnly&quot;, props.getProperty(&quot;possibleTagsOnly&quot;, this.getProperty(&quot;possibleTagsOnly&quot;)));</span>

<span class="nc" id="L222">    this.setProperty(&quot;lang&quot;, props.getProperty(&quot;lang&quot;, this.getProperty(&quot;lang&quot;)));</span>

<span class="nc" id="L224">    this.setProperty(&quot;openClassTags&quot;, props.getProperty(&quot;openClassTags&quot;, this.getProperty(&quot;openClassTags&quot;)).trim());</span>
<span class="nc" id="L225">    this.setProperty(&quot;closedClassTags&quot;, props.getProperty(&quot;closedClassTags&quot;, this.getProperty(&quot;closedClassTags&quot;)).trim());</span>

<span class="nc" id="L227">    this.setProperty(&quot;learnClosedClassTags&quot;, props.getProperty(&quot;learnClosedClassTags&quot;, this.getProperty(&quot;learnClosedClassTags&quot;)));</span>

<span class="nc" id="L229">    this.setProperty(&quot;closedClassTagThreshold&quot;, props.getProperty(&quot;closedClassTagThreshold&quot;, this.getProperty(&quot;closedClassTagThreshold&quot;)));</span>

<span class="nc" id="L231">    this.setProperty(&quot;arch&quot;, props.getProperty(&quot;arch&quot;, this.getProperty(&quot;arch&quot;)));</span>
<span class="nc bnc" id="L232" title="All 4 branches missed.">    if (this.getMode() == Mode.TRAIN &amp;&amp; this.getProperty(&quot;arch&quot;).equals(&quot;&quot;)) {</span>
<span class="nc" id="L233">      throw new IllegalArgumentException(&quot;No architecture specified; &quot; +</span>
                                         &quot;set the -arch flag with &quot; +
                                         &quot;the features to be used&quot;);
    }

<span class="nc" id="L238">    this.setProperty(&quot;wordFunction&quot;, props.getProperty(&quot;wordFunction&quot;, this.getProperty(&quot;wordFunction&quot;, WORD_FUNCTION)));</span>

<span class="nc" id="L240">    this.setProperty(&quot;tokenize&quot;, props.getProperty(&quot;tokenize&quot;, this.getProperty(&quot;tokenize&quot;)));</span>
<span class="nc" id="L241">    this.setProperty(&quot;tokenizerFactory&quot;, props.getProperty(&quot;tokenizerFactory&quot;, this.getProperty(&quot;tokenizerFactory&quot;)));</span>

<span class="nc" id="L243">    this.setProperty(&quot;debugPrefix&quot;, props.getProperty(&quot;debugPrefix&quot;, this.getProperty(&quot;debugPrefix&quot;, &quot;&quot;)));</span>
<span class="nc" id="L244">    this.setProperty(&quot;debug&quot;, props.getProperty(&quot;debug&quot;, DEBUG));</span>

<span class="nc" id="L246">    this.setProperty(ENCODING_PROPERTY, props.getProperty(ENCODING_PROPERTY, this.getProperty(ENCODING_PROPERTY)));</span>
<span class="nc" id="L247">    this.setProperty(&quot;sgml&quot;, props.getProperty(&quot;sgml&quot;, this.getProperty(&quot;sgml&quot;)));</span>
<span class="nc" id="L248">    this.setProperty(&quot;verbose&quot;, props.getProperty(&quot;verbose&quot;, this.getProperty(&quot;verbose&quot;)));</span>
<span class="nc" id="L249">    this.setProperty(&quot;verboseResults&quot;, props.getProperty(&quot;verboseResults&quot;, this.getProperty(&quot;verboseResults&quot;)));</span>

<span class="nc" id="L251">    this.setProperty(&quot;regL1&quot;, props.getProperty(&quot;regL1&quot;, this.getProperty(&quot;regL1&quot;)));</span>

    //this is a property that is stored (not like the general properties)
<span class="nc" id="L254">    this.setProperty(&quot;xmlInput&quot;, props.getProperty(&quot;xmlInput&quot;, this.getProperty(&quot;xmlInput&quot;)).trim());</span>

<span class="nc" id="L256">    this.setProperty(&quot;tagInside&quot;, props.getProperty(&quot;tagInside&quot;, this.getProperty(&quot;tagInside&quot;))); //this isn't something we save from time to time</span>
<span class="nc" id="L257">    this.setProperty(&quot;approximate&quot;, props.getProperty(&quot;approximate&quot;, this.getProperty(&quot;approximate&quot;))); //this isn't something we save from time to time</span>
<span class="nc" id="L258">    this.setProperty(&quot;tokenizerOptions&quot;, props.getProperty(&quot;tokenizerOptions&quot;, this.getProperty(&quot;tokenizerOptions&quot;))); //this isn't something we save from time to time</span>
<span class="nc" id="L259">    this.setProperty(&quot;outputFile&quot;, props.getProperty(&quot;outputFile&quot;, this.getProperty(&quot;outputFile&quot;)).trim()); //this isn't something we save from time to time</span>
<span class="nc" id="L260">    this.setProperty(&quot;outputFormat&quot;, props.getProperty(&quot;outputFormat&quot;, this.getProperty(&quot;outputFormat&quot;)).trim()); //this isn't something we save from time to time</span>
<span class="nc" id="L261">    this.setProperty(&quot;outputFormatOptions&quot;, props.getProperty(&quot;outputFormatOptions&quot;, this.getProperty(&quot;outputFormatOptions&quot;)).trim()); //this isn't something we save from time to time</span>
<span class="nc" id="L262">    this.setProperty(&quot;nthreads&quot;, props.getProperty(&quot;nthreads&quot;, this.getProperty(&quot;nthreads&quot;, NTHREADS)).trim());</span>
<span class="nc" id="L263">    String sentenceDelimiter = props.getProperty(&quot;sentenceDelimiter&quot;, this.getProperty(&quot;sentenceDelimiter&quot;));</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">    if (sentenceDelimiter != null) {</span>
      // this isn't something we save from time to time.
      // It is only relevant when tagging text files.
      // In fact, we let this one be null, as it really is useful to
      // let the null value represent no sentence delimiter.
<span class="nc" id="L269">      this.setProperty(&quot;sentenceDelimiter&quot;, sentenceDelimiter);</span>
    }
<span class="nc" id="L271">  }</span>


<span class="nc" id="L274">  public String getModel() { return getProperty(&quot;model&quot;); }</span>

<span class="nc" id="L276">  public String getFile() { return getProperty(&quot;file&quot;); }</span>

<span class="nc" id="L278">  public String getOutputFile() { return getProperty(&quot;outputFile&quot;); }</span>

<span class="nc" id="L280">  public String getOutputFormat() { return getProperty(&quot;outputFormat&quot;); }</span>

<span class="nc" id="L282">  public String[] getOutputOptions() { return getProperty(&quot;outputFormatOptions&quot;).split(&quot;\\s*,\\s*&quot;); }</span>

  public boolean getOutputVerbosity() {
<span class="nc" id="L285">    return getOutputOptionsContains(&quot;verbose&quot;);</span>
  }

  public boolean getOutputLemmas() {
<span class="nc" id="L289">    return getOutputOptionsContains(&quot;lemmatize&quot;);</span>
  }

  public boolean keepEmptySentences() {
<span class="nc" id="L293">    return getOutputOptionsContains(&quot;keepEmptySentences&quot;);    </span>
  }

  public boolean getOutputOptionsContains(String sought) {
<span class="nc" id="L297">    String[] options = getOutputOptions();</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">    for (String option : options) {</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">      if (option.equals(sought)) {</span>
<span class="nc" id="L300">        return true;</span>
      }
    }
<span class="nc" id="L303">    return false;</span>
  }

<span class="nc" id="L306">  public String getSearch() { return getProperty(&quot;search&quot;); }</span>

<span class="nc" id="L308">  public double getSigmaSquared() { return Double.parseDouble(getProperty(&quot;sigmaSquared&quot;)); }</span>

<span class="nc" id="L310">  public int getIterations() { return Integer.parseInt(getProperty(&quot;iterations&quot;)); }</span>

<span class="nc" id="L312">  public int getRareWordThresh() { return Integer.parseInt(getProperty(&quot;rareWordThresh&quot;)); }</span>

<span class="nc" id="L314">  public int getMinFeatureThresh() { return Integer.parseInt(getProperty(&quot;minFeatureThresh&quot;)); }</span>

<span class="nc" id="L316">  public int getCurWordMinFeatureThresh() { return Integer.parseInt(getProperty(&quot;curWordMinFeatureThresh&quot;)); }</span>

<span class="nc" id="L318">  public int getRareWordMinFeatureThresh() { return Integer.parseInt(getProperty(&quot;rareWordMinFeatureThresh&quot;)); }</span>

<span class="nc" id="L320">  public int getVeryCommonWordThresh() { return Integer.parseInt(getProperty(&quot;veryCommonWordThresh&quot;)); }</span>

<span class="nc" id="L322">  public boolean occurringTagsOnly() { return Boolean.parseBoolean(getProperty(&quot;occurringTagsOnly&quot;)); }</span>

<span class="nc" id="L324">  public boolean possibleTagsOnly() { return Boolean.parseBoolean(getProperty(&quot;possibleTagsOnly&quot;)); }</span>

<span class="nc" id="L326">  public String getLang() { return getProperty(&quot;lang&quot;); }</span>

  public String[] getOpenClassTags() {
<span class="nc" id="L329">    return wsvStringToStringArray(getProperty(&quot;openClassTags&quot;));</span>
  }

  public String[] getClosedClassTags() {
<span class="nc" id="L333">    return wsvStringToStringArray(getProperty(&quot;closedClassTags&quot;));</span>
  }

  private static String[] wsvStringToStringArray(String str) {
<span class="nc bnc" id="L337" title="All 4 branches missed.">    if (str == null || str.equals(&quot;&quot;)) {</span>
<span class="nc" id="L338">      return StringUtils.EMPTY_STRING_ARRAY;</span>
    } else {
<span class="nc" id="L340">      return str.split(&quot;\\s+&quot;);</span>
    }
  }

<span class="nc" id="L344">  public boolean getLearnClosedClassTags() { return Boolean.parseBoolean(getProperty(&quot;learnClosedClassTags&quot;)); }</span>

<span class="nc" id="L346">  public int getClosedTagThreshold() { return Integer.parseInt(getProperty(&quot;closedClassTagThreshold&quot;)); }</span>

<span class="nc" id="L348">  public String getArch() { return getProperty(&quot;arch&quot;); }</span>

<span class="nc" id="L350">  public String getWordFunction() { return getProperty(&quot;wordFunction&quot;); }</span>

<span class="nc" id="L352">  public boolean getDebug() { return Boolean.parseBoolean(getProperty(&quot;debug&quot;)); }</span>

<span class="nc" id="L354">  public String getDebugPrefix() { return getProperty(&quot;debugPrefix&quot;); }</span>

<span class="nc" id="L356">  public String getTokenizerFactory() { return getProperty(&quot;tokenizerFactory&quot;); }</span>

<span class="nc" id="L358">  public static String getDefaultTagSeparator() { return TAG_SEPARATOR; }</span>

<span class="nc" id="L360">  public final String getTagSeparator() { return getProperty(TAG_SEPARATOR_PROPERTY); }</span>

<span class="nc" id="L362">  public boolean getTokenize() { return Boolean.parseBoolean(getProperty(&quot;tokenize&quot;)); }</span>

<span class="nc" id="L364">  public String getEncoding() { return getProperty(ENCODING_PROPERTY); }</span>

<span class="nc" id="L366">  public double getRegL1() { return Double.parseDouble(getProperty(&quot;regL1&quot;)); }</span>

  public String[] getXMLInput() {
<span class="nc" id="L369">    return wsvStringToStringArray(getProperty(&quot;xmlInput&quot;));</span>
  }

<span class="nc" id="L372">  public boolean getVerbose() { return Boolean.parseBoolean(getProperty(&quot;verbose&quot;)); }</span>

<span class="nc" id="L374">  public boolean getVerboseResults() { return Boolean.parseBoolean(getProperty(&quot;verboseResults&quot;)); }</span>

<span class="nc" id="L376">  public boolean getSGML() { return Boolean.parseBoolean(getProperty(&quot;sgml&quot;)); }</span>

<span class="nc" id="L378">  public int getNThreads() { return Integer.parseInt(getProperty(&quot;nthreads&quot;)); }</span>


  /** Return a regex of XML elements to tag inside of.  This may return an
   *  empty String, but never null.
   *
   * @return A regex of XML elements to tag inside of
   */
  public String getTagInside() {
<span class="nc" id="L387">    String str = getProperty(&quot;tagInside&quot;);</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">    if (str == null) {</span>
<span class="nc" id="L389">      return &quot;&quot;;</span>
    }
<span class="nc" id="L391">    return str;</span>
  }

<span class="nc" id="L394">  public String getTokenizerOptions() { return getProperty(&quot;tokenizerOptions&quot;); }</span>

  public boolean getTokenizerInvertible() {
<span class="nc" id="L397">    String tokenizerOptions = getTokenizerOptions();</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">    if (tokenizerOptions != null &amp;&amp;</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">        tokenizerOptions.matches(&quot;(^|.*,)invertible=true&quot;))</span>
<span class="nc" id="L400">      return true;</span>
<span class="nc bnc" id="L401" title="All 4 branches missed.">    return getOutputVerbosity() || getOutputLemmas();</span>
  }

  /**
   * Returns a default score to be used for each tag that is incompatible with
   * the current word (e.g., the tag CC for the word &quot;apple&quot;). Using a default
   * score may slightly decrease performance for some languages (e.g., Chinese and
   * German), but allows the tagger to run considerably faster (since the computation
   * of the normalization term Z requires much less feature extraction). This approximation
   * does not decrease performance in English (on the WSJ). If this function returns
   * 0.0, the tagger will compute exact scores.
   *
   * @return default score
   */
  public double getDefaultScore() {
<span class="nc" id="L416">    String approx = getProperty(&quot;approximate&quot;);</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">    if (&quot;false&quot;.equalsIgnoreCase(approx)) {</span>
<span class="nc" id="L418">      return -1.0;</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">    } else if (&quot;true&quot;.equalsIgnoreCase(approx)) {</span>
<span class="nc" id="L420">      return 1.0;</span>
    } else {
<span class="nc" id="L422">      return Double.parseDouble(approx);</span>
    }
  }


<span class="nc" id="L427">  public void dump() { dump(new PrintWriter(System.err)); }</span>

  public void dump(PrintStream stream) {
<span class="nc" id="L430">    PrintWriter pw = new PrintWriter(stream);</span>
<span class="nc" id="L431">    dump(pw);</span>
<span class="nc" id="L432">  }</span>

  private void dump(PrintWriter pw) {
<span class="nc" id="L435">    pw.println(&quot;                   model = &quot; + getProperty(&quot;model&quot;));</span>
<span class="nc" id="L436">    pw.println(&quot;                    arch = &quot; + getProperty(&quot;arch&quot;));</span>
<span class="nc" id="L437">    pw.println(&quot;            wordFunction = &quot; + getProperty(&quot;wordFunction&quot;));</span>
<span class="nc bnc" id="L438" title="All 4 branches missed.">    if (this.getMode() == Mode.TRAIN || this.getMode() == Mode.DUMP) {</span>
<span class="nc" id="L439">      pw.println(&quot;               trainFile = &quot; + getProperty(&quot;file&quot;));</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">    } else if (this.getMode() == Mode.TAG) {</span>
<span class="nc" id="L441">      pw.println(&quot;                textFile = &quot; + getProperty(&quot;file&quot;));</span>
<span class="nc bnc" id="L442" title="All 2 branches missed.">    } else if (this.getMode() == Mode.TEST) {</span>
<span class="nc" id="L443">      pw.println(&quot;                testFile = &quot; + getProperty(&quot;file&quot;));</span>
    }

<span class="nc" id="L446">    pw.println(&quot;         closedClassTags = &quot; + getProperty(&quot;closedClassTags&quot;));</span>
<span class="nc" id="L447">    pw.println(&quot; closedClassTagThreshold = &quot; + getProperty(&quot;closedClassTagThreshold&quot;));</span>
<span class="nc" id="L448">    pw.println(&quot; curWordMinFeatureThresh = &quot; + getProperty(&quot;curWordMinFeatureThresh&quot;));</span>
<span class="nc" id="L449">    pw.println(&quot;                   debug = &quot; + getProperty(&quot;debug&quot;));</span>
<span class="nc" id="L450">    pw.println(&quot;             debugPrefix = &quot; + getProperty(&quot;debugPrefix&quot;));</span>
<span class="nc" id="L451">    pw.println(&quot;            &quot; + TAG_SEPARATOR_PROPERTY + &quot; = &quot; +</span>
<span class="nc" id="L452">               getProperty(TAG_SEPARATOR_PROPERTY));</span>
<span class="nc" id="L453">    pw.println(&quot;                &quot; + ENCODING_PROPERTY + &quot; = &quot; +</span>
<span class="nc" id="L454">               getProperty(ENCODING_PROPERTY));</span>
<span class="nc" id="L455">    pw.println(&quot;              iterations = &quot; + getProperty(&quot;iterations&quot;));</span>
<span class="nc" id="L456">    pw.println(&quot;                    lang = &quot; + getProperty(&quot;lang&quot;));</span>
<span class="nc" id="L457">    pw.println(&quot;    learnClosedClassTags = &quot; + getProperty(&quot;learnClosedClassTags&quot;));</span>
<span class="nc" id="L458">    pw.println(&quot;        minFeatureThresh = &quot; + getProperty(&quot;minFeatureThresh&quot;));</span>
<span class="nc" id="L459">    pw.println(&quot;           openClassTags = &quot; + getProperty(&quot;openClassTags&quot;));</span>
<span class="nc" id="L460">    pw.println(&quot;rareWordMinFeatureThresh = &quot; + getProperty(&quot;rareWordMinFeatureThresh&quot;));</span>
<span class="nc" id="L461">    pw.println(&quot;          rareWordThresh = &quot; + getProperty(&quot;rareWordThresh&quot;));</span>
<span class="nc" id="L462">    pw.println(&quot;                  search = &quot; + getProperty(&quot;search&quot;));</span>
<span class="nc" id="L463">    pw.println(&quot;                    sgml = &quot; + getProperty(&quot;sgml&quot;));</span>
<span class="nc" id="L464">    pw.println(&quot;            sigmaSquared = &quot; + getProperty(&quot;sigmaSquared&quot;));</span>
<span class="nc" id="L465">    pw.println(&quot;                   regL1 = &quot; + getProperty(&quot;regL1&quot;));</span>
<span class="nc" id="L466">    pw.println(&quot;               tagInside = &quot; + getProperty(&quot;tagInside&quot;));</span>
<span class="nc" id="L467">    pw.println(&quot;                tokenize = &quot; + getProperty(&quot;tokenize&quot;));</span>
<span class="nc" id="L468">    pw.println(&quot;        tokenizerFactory = &quot; + getProperty(&quot;tokenizerFactory&quot;));</span>
<span class="nc" id="L469">    pw.println(&quot;        tokenizerOptions = &quot; + getProperty(&quot;tokenizerOptions&quot;));</span>
<span class="nc" id="L470">    pw.println(&quot;                 verbose = &quot; + getProperty(&quot;verbose&quot;));</span>
<span class="nc" id="L471">    pw.println(&quot;          verboseResults = &quot; + getProperty(&quot;verboseResults&quot;));</span>
<span class="nc" id="L472">    pw.println(&quot;    veryCommonWordThresh = &quot; + getProperty(&quot;veryCommonWordThresh&quot;));</span>
<span class="nc" id="L473">    pw.println(&quot;                xmlInput = &quot; + getProperty(&quot;xmlInput&quot;));</span>
<span class="nc" id="L474">    pw.println(&quot;              outputFile = &quot; + getProperty(&quot;outputFile&quot;));</span>
<span class="nc" id="L475">    pw.println(&quot;            outputFormat = &quot; + getProperty(&quot;outputFormat&quot;));</span>
<span class="nc" id="L476">    pw.println(&quot;     outputFormatOptions = &quot; + getProperty(&quot;outputFormatOptions&quot;));</span>
<span class="nc" id="L477">    pw.println(&quot;                nthreads = &quot; + getProperty(&quot;nthreads&quot;));</span>
<span class="nc" id="L478">    pw.flush();</span>
<span class="nc" id="L479">  }</span>

  @Override
  public String toString() {
<span class="nc" id="L483">    StringWriter sw = new StringWriter(200);</span>
<span class="nc" id="L484">    PrintWriter pw = new PrintWriter(sw);</span>
<span class="nc" id="L485">    dump(pw);</span>
<span class="nc" id="L486">    return sw.toString();</span>
  }

  /**
   * This returns the sentence delimiter used when tokenizing text
   * using the tokenizer requested in this config.  In general, it is
   * assumed the tokenizer doesn't need a sentence delimiter.... If you
   * use the whitespace tokenizer, though, a newline breaks sentences.
   *
   * @return A null String unless tokenize is false and then the String
   */
  public String getSentenceDelimiter() {
<span class="nc" id="L498">    String delimiter = getProperty(&quot;sentenceDelimiter&quot;);</span>
<span class="nc bnc" id="L499" title="All 4 branches missed.">    if (delimiter == null &amp;&amp; !getTokenize()) {</span>
<span class="nc" id="L500">      delimiter = &quot;\n&quot;;</span>
    }
<span class="nc" id="L502">    return delimiter;</span>
  }

  /**
   * Returns whether or not we should use stdin for reading when
   * tagging data.  For now, this returns true iff the filename given
   * was &quot;stdin&quot;.
   * (TODO: kind of ugly)
   */
  public boolean useStdin() {
<span class="nc" id="L512">    return getFile().trim().equalsIgnoreCase(&quot;stdin&quot;);</span>
  }

  /**
   * Prints out the automatically generated props file - in its own
   * method to make code above easier to read
   */
  private static void printGenProps(PrintStream out) {
<span class="nc" id="L520">    out.println(&quot;## Sample properties file for maxent tagger. This file is used for three main&quot;);</span>
<span class="nc" id="L521">    out.println(&quot;## operations: training, testing, and tagging. It may also be used to dump&quot;);</span>
<span class="nc" id="L522">    out.println(&quot;## the contents of a model.&quot;);</span>
<span class="nc" id="L523">    out.println(&quot;## To train or test a model, or to tag something, run:&quot;);</span>
<span class="nc" id="L524">    out.println(&quot;##   java edu.stanford.nlp.tagger.maxent.MaxentTagger -prop &lt;properties file&gt;&quot;);</span>
<span class="nc" id="L525">    out.println(&quot;## Arguments can be overridden on the commandline, e.g.:&quot;);</span>
<span class="nc" id="L526">    out.println(&quot;##   java ....MaxentTagger -prop &lt;properties file&gt; -testFile /other/file &quot;);</span>
<span class="nc" id="L527">    out.println();</span>

<span class="nc" id="L529">    out.println(&quot;# Model file name (created at train time; used at tag and test time)&quot;);</span>
<span class="nc" id="L530">    out.println(&quot;# (you can leave this blank and specify it on the commandline with -model)&quot;);</span>
<span class="nc" id="L531">    out.println(&quot;# model = &quot;);</span>
<span class="nc" id="L532">    out.println();</span>

<span class="nc" id="L534">    out.println(&quot;# Path to file to be operated on (trained from, tested against, or tagged)&quot;);</span>
<span class="nc" id="L535">    out.println(&quot;# Specify -textFile &lt;filename&gt; to tag text in the given file, -trainFile &lt;filename&gt; to&quot;);</span>
<span class="nc" id="L536">    out.println(&quot;# to train a model using data in the given file, or -testFile &lt;filename&gt; to test your&quot;);</span>
<span class="nc" id="L537">    out.println(&quot;# model using data in the given file.  Alternatively, you may specify&quot;);</span>
<span class="nc" id="L538">    out.println(&quot;# -dump &lt;filename&gt; to dump the parameters stored in a model or &quot;);</span>
<span class="nc" id="L539">    out.println(&quot;# -convertToSingleFile &lt;filename&gt; to save an old, multi-file model (specified as -model)&quot;);</span>
<span class="nc" id="L540">    out.println(&quot;# to the new single file format.  The new model will be saved in the file filename.&quot;);</span>
<span class="nc" id="L541">    out.println(&quot;# If you choose to convert an old file, you must specify &quot;);</span>
<span class="nc" id="L542">    out.println(&quot;# the correct 'arch' parameter used to create the original model.&quot;);</span>
<span class="nc" id="L543">    out.println(&quot;# trainFile = &quot;);</span>
<span class="nc" id="L544">    out.println();</span>

<span class="nc" id="L546">    out.println(&quot;# Path to outputFile to write tagged output to.&quot;);</span>
<span class="nc" id="L547">    out.println(&quot;# If empty, stdout is used.&quot;);</span>
<span class="nc" id="L548">    out.println(&quot;# outputFile = &quot; + OUTPUT_FILE);</span>
<span class="nc" id="L549">    out.println();</span>

<span class="nc" id="L551">    out.println(&quot;# Output format. One of: slashTags (default), xml, or tsv&quot;);</span>
<span class="nc" id="L552">    out.println(&quot;# outputFormat = &quot; + OUTPUT_FORMAT);</span>
<span class="nc" id="L553">    out.println();</span>

<span class="nc" id="L555">    out.println(&quot;# Output format options. Comma separated list.&quot;);</span>
<span class="nc" id="L556">    out.println(&quot;# currently \&quot;lemmatize\&quot; and \&quot;keepEmptySentences\&quot; are supported.&quot;);</span>
<span class="nc" id="L557">    out.println(&quot;# outputFormatOptions = &quot; + OUTPUT_FORMAT_OPTIONS);</span>
<span class="nc" id="L558">    out.println();</span>

<span class="nc" id="L560">    out.println(&quot;# Tag separator character that separates word and pos tags&quot;);</span>
<span class="nc" id="L561">    out.println(&quot;# (for both training and test data) and used for&quot;);</span>
<span class="nc" id="L562">    out.println(&quot;# separating words and tags in slashTags format output.&quot;);</span>
<span class="nc" id="L563">    out.println(&quot;# tagSeparator = &quot; + TAG_SEPARATOR);</span>
<span class="nc" id="L564">    out.println();</span>

<span class="nc" id="L566">    out.println(&quot;# Encoding format in which files are stored.  If left blank, UTF-8 is assumed.&quot;);</span>
<span class="nc" id="L567">    out.println(&quot;# encoding = &quot; + ENCODING);</span>
<span class="nc" id="L568">    out.println();</span>

<span class="nc" id="L570">    out.println(&quot;# A couple flags for controlling the amount of output:&quot;);</span>
<span class="nc" id="L571">    out.println(&quot;# - print extra debugging information:&quot;);</span>
<span class="nc" id="L572">    out.println(&quot;# verbose = &quot; + VERBOSE);</span>
<span class="nc" id="L573">    out.println(&quot;# - print intermediate results:&quot;);</span>
<span class="nc" id="L574">    out.println(&quot;# verboseResults = &quot; + VERBOSE_RESULTS);</span>

<span class="nc" id="L576">    out.println(&quot;######### parameters for tag and test operations #########&quot;);</span>
<span class="nc" id="L577">    out.println();</span>

<span class="nc" id="L579">    out.println(&quot;# Class to use for tokenization. Default blank value means Penn Treebank&quot;);</span>
<span class="nc" id="L580">    out.println(&quot;# tokenization.  If you'd like to just assume that tokenization has been done,&quot;);</span>
<span class="nc" id="L581">    out.println(&quot;# and the input is whitespace-tokenized, use&quot;);</span>
<span class="nc" id="L582">    out.println(&quot;# edu.stanford.nlp.process.WhitespaceTokenizer or set tokenize to false.&quot;);</span>
<span class="nc" id="L583">    out.println(&quot;# tokenizerFactory = &quot;);</span>
<span class="nc" id="L584">    out.println();</span>

<span class="nc" id="L586">    out.println(&quot;# Options to the tokenizer.  A comma separated list.&quot;);</span>
<span class="nc" id="L587">    out.println(&quot;# This depends on what the tokenizer supports.&quot;);</span>
<span class="nc" id="L588">    out.println(&quot;# For PTBTokenizer, you might try options like americanize=false&quot;);</span>
<span class="nc" id="L589">    out.println(&quot;# or asciiQuotes (for German!).&quot;);</span>
<span class="nc" id="L590">    out.println(&quot;# tokenizerOptions = &quot;);</span>
<span class="nc" id="L591">    out.println();</span>
<span class="nc" id="L592">    out.println(&quot;# Whether to tokenize text for tag and test operations. Default is true.&quot;);</span>
<span class="nc" id="L593">    out.println(&quot;# If false, your text must already be whitespace tokenized.&quot;);</span>
<span class="nc" id="L594">    out.println(&quot;# tokenize = &quot; + TOKENIZE);</span>
<span class="nc" id="L595">    out.println();</span>

<span class="nc" id="L597">    out.println(&quot;# Write debugging information (words, top words, unknown words). Useful for&quot;);</span>
<span class="nc" id="L598">    out.println(&quot;# error analysis. Default is false.&quot;);</span>
<span class="nc" id="L599">    out.println(&quot;# debug = &quot;+ DEBUG);</span>
<span class="nc" id="L600">    out.println();</span>

<span class="nc" id="L602">    out.println(&quot;# Prefix for debugging output (if debug == true). Default is to use the&quot;);</span>
<span class="nc" id="L603">    out.println(&quot;# filename from 'file'&quot;);</span>
<span class="nc" id="L604">    out.println(&quot;# debugPrefix = &quot;);</span>
<span class="nc" id="L605">    out.println();</span>

<span class="nc" id="L607">    out.println(&quot;######### parameters for training  #########&quot;);</span>
<span class="nc" id="L608">    out.println();</span>

<span class="nc" id="L610">    out.println(&quot;# model architecture: This is one or more comma separated strings, which&quot;);</span>
<span class="nc" id="L611">    out.println(&quot;# specify which extractors to use. Some of them take one or more integer&quot;);</span>
<span class="nc" id="L612">    out.println(&quot;# or string &quot;);</span>
<span class="nc" id="L613">    out.println(&quot;# (file path) arguments in parentheses, written as m, n, and s below:&quot;);</span>
<span class="nc" id="L614">    out.println(&quot;# 'left3words', 'left5words', 'bidirectional', 'bidirectional5words',&quot;);</span>
<span class="nc" id="L615">    out.println(&quot;# 'generic', 'sighan2005', 'german', 'words(m,n)', 'wordshapes(m,n)',&quot;);</span>
<span class="nc" id="L616">    out.println(&quot;# 'biwords(m,n)', 'lowercasewords(m,n)', 'vbn(n)', distsimconjunction(s,m,n)',&quot;);</span>
<span class="nc" id="L617">    out.println(&quot;# 'naacl2003unknowns', 'naacl2003conjunctions', 'distsim(s,m,n)',&quot;);</span>
<span class="nc" id="L618">    out.println(&quot;# 'suffix(n)', 'prefix(n)', 'prefixsuffix(n)', 'capitalizationsuffix(n)',&quot;);</span>
<span class="nc" id="L619">    out.println(&quot;# 'wordshapes(m,n)', 'unicodeshapes(m,n)', 'unicodeshapeconjunction(m,n)',&quot;);</span>
<span class="nc" id="L620">    out.println(&quot;# 'lctagfeatures', 'order(k)', 'chinesedictionaryfeatures(s)'.&quot;);</span>
<span class="nc" id="L621">    out.println(&quot;# These keywords determines the features extracted.  'generic' is language independent.&quot;);</span>
<span class="nc" id="L622">    out.println(&quot;# distsim: Distributional similarity classes can be an added source of information&quot;);</span>
<span class="nc" id="L623">    out.println(&quot;# about your words. An English distsim file is included, or you can use your own.&quot;);</span>
<span class="nc" id="L624">    out.println(&quot;# arch = &quot;);</span>
<span class="nc" id="L625">    out.println();</span>
<span class="nc" id="L626">    out.println(&quot;# 'wordFunction'.  A function applied to the text before training or tagging.&quot;);</span>
<span class="nc" id="L627">    out.println(&quot;# For example, edu.stanford.nlp.util.LowercaseFunction&quot;);</span>
<span class="nc" id="L628">    out.println(&quot;# This function turns all the words into lowercase&quot;);</span>
<span class="nc" id="L629">    out.println(&quot;# The function must implement java.util.function.Function&lt;String, String&gt;&quot;);</span>
<span class="nc" id="L630">    out.println(&quot;# Blank means no preprocessing function&quot;);</span>
<span class="nc" id="L631">    out.println(&quot;# wordFunction = &quot;);</span>
<span class="nc" id="L632">    out.println();</span>


<span class="nc" id="L635">    out.println(&quot;# 'language'.  This is really the tag set which is used for the&quot;);</span>
<span class="nc" id="L636">    out.println(&quot;# list of open-class tags, and perhaps deterministic  tag&quot;);</span>
<span class="nc" id="L637">    out.println(&quot;# expansion). Currently we have 'english', 'arabic', 'german', 'chinese'&quot;);</span>
<span class="nc" id="L638">    out.println(&quot;# or 'polish' predefined. For your own language, you can specify &quot;);</span>
<span class="nc" id="L639">    out.println(&quot;# the same information via openClassTags or closedClassTags below&quot;);</span>
<span class="nc" id="L640">    out.println(&quot;# (only ONE of these three options may be specified). &quot;);</span>
<span class="nc" id="L641">    out.println(&quot;# 'english' means UPenn English treebank tags. 'german' is STTS&quot;);</span>
<span class="nc" id="L642">    out.println(&quot;# 'chinese' is CTB, and Arabic is an expanded Bies mapping from the ATB&quot;);</span>
<span class="nc" id="L643">    out.println(&quot;# 'polish' means some tags that some guy on the internet once used. &quot;);</span>
<span class="nc" id="L644">    out.println(&quot;# See the TTags class for more information.&quot;);</span>
<span class="nc" id="L645">    out.println(&quot;# lang = &quot;);</span>
<span class="nc" id="L646">    out.println();</span>

<span class="nc" id="L648">    out.println(&quot;# a space-delimited list of open-class parts of speech&quot;);</span>
<span class="nc" id="L649">    out.println(&quot;# alternatively, you can specify language above to use a pre-defined list or specify the closed class tags (below)&quot;);</span>
<span class="nc" id="L650">    out.println(&quot;# openClassTags = &quot;);</span>
<span class="nc" id="L651">    out.println();</span>

<span class="nc" id="L653">    out.println(&quot;# a space-delimited list of closed-class parts of speech&quot;);</span>
<span class="nc" id="L654">    out.println(&quot;# alternatively, you can specify language above to use a pre-defined list or specify the open class tags (above)&quot;);</span>
<span class="nc" id="L655">    out.println(&quot;# closedClassTags = &quot;);</span>
<span class="nc" id="L656">    out.println();</span>

<span class="nc" id="L658">    out.println(&quot;# A boolean indicating whether you would like the trained model to set POS tags as closed&quot;);</span>
<span class="nc" id="L659">    out.println(&quot;# based on their frequency in training; default is false.  The frequency threshold can be set below. &quot;);</span>
<span class="nc" id="L660">    out.println(&quot;# This option is ignored if any of {openClassTags, closedClassTags, lang} are specified.&quot;);</span>
<span class="nc" id="L661">    out.println(&quot;# learnClosedClassTags = &quot;);</span>
<span class="nc" id="L662">    out.println();</span>

<span class="nc" id="L664">    out.println(&quot;# Used only if learnClosedClassTags=true.  Tags that have fewer tokens than this threshold are&quot;);</span>
<span class="nc" id="L665">    out.println(&quot;# considered closed in the trained model.&quot;);</span>
<span class="nc" id="L666">    out.println(&quot;# closedClassTagThreshold = &quot;);</span>
<span class="nc" id="L667">    out.println();</span>

<span class="nc" id="L669">    out.println(&quot;# search method for optimization. Normally use the default 'qn'. choices: 'qn' (quasi-Newton),&quot;);</span>
<span class="nc" id="L670">    out.println(&quot;# 'cg' (conjugate gradient, 'owlqn' (L1 regularization) or 'iis' (improved iterative scaling)&quot;);</span>
<span class="nc" id="L671">    out.println(&quot;# search = &quot; + SEARCH);</span>
<span class="nc" id="L672">    out.println();</span>

<span class="nc" id="L674">    out.println(&quot;# for conjugate gradient or quasi-Newton search, sigma-squared smoothing/regularization&quot;);</span>
<span class="nc" id="L675">    out.println(&quot;# parameter. if left blank, the default is 0.5, which is usually okay&quot;);</span>
<span class="nc" id="L676">    out.println(&quot;# sigmaSquared = &quot; + SIGMA_SQUARED);</span>
<span class="nc" id="L677">    out.println();</span>

<span class="nc" id="L679">    out.println(&quot;# for OWLQN search, regularization&quot;);</span>
<span class="nc" id="L680">    out.println(&quot;# parameter. if left blank, the default is 1.0, which is usually okay&quot;);</span>
<span class="nc" id="L681">    out.println(&quot;# regL1 = &quot; + DEFAULT_REG_L1);</span>
<span class="nc" id="L682">    out.println();</span>

<span class="nc" id="L684">    out.println(&quot;# For improved iterative scaling, the number of iterations, otherwise ignored&quot;);</span>
<span class="nc" id="L685">    out.println(&quot;# iterations = &quot; + ITERATIONS);</span>
<span class="nc" id="L686">    out.println();</span>

<span class="nc" id="L688">    out.println(&quot;# rare word threshold. words that occur less than this number of&quot;);</span>
<span class="nc" id="L689">    out.println(&quot;# times are considered rare words.&quot;);</span>
<span class="nc" id="L690">    out.println(&quot;# rareWordThresh = &quot; + RARE_WORD_THRESH);</span>
<span class="nc" id="L691">    out.println();</span>

<span class="nc" id="L693">    out.println(&quot;# minimum feature threshold. features whose history appears less&quot;);</span>
<span class="nc" id="L694">    out.println(&quot;# than this number of times are ignored.&quot;);</span>
<span class="nc" id="L695">    out.println(&quot;# minFeatureThresh = &quot; + MIN_FEATURE_THRESH);</span>
<span class="nc" id="L696">    out.println();</span>

<span class="nc" id="L698">    out.println(&quot;# current word feature threshold. words that occur more than this&quot;);</span>
<span class="nc" id="L699">    out.println(&quot;# number of times will generate features with all of their occurring&quot;);</span>
<span class="nc" id="L700">    out.println(&quot;# tags.&quot;);</span>
<span class="nc" id="L701">    out.println(&quot;# curWordMinFeatureThresh = &quot; + CUR_WORD_MIN_FEATURE_THRESH);</span>
<span class="nc" id="L702">    out.println();</span>

<span class="nc" id="L704">    out.println(&quot;# rare word minimum feature threshold. features of rare words whose histories&quot;);</span>
<span class="nc" id="L705">    out.println(&quot;# appear less than this times will be ignored.&quot;);</span>
<span class="nc" id="L706">    out.println(&quot;# rareWordMinFeatureThresh = &quot; + RARE_WORD_MIN_FEATURE_THRESH);</span>
<span class="nc" id="L707">    out.println();</span>

<span class="nc" id="L709">    out.println(&quot;# very common word threshold. words that occur more than this number of&quot;);</span>
<span class="nc" id="L710">    out.println(&quot;# times will form an equivalence class by themselves. ignored unless&quot;);</span>
<span class="nc" id="L711">    out.println(&quot;# you are using equivalence classes.&quot;);</span>
<span class="nc" id="L712">    out.println(&quot;# veryCommonWordThresh = &quot; + VERY_COMMON_WORD_THRESH);</span>
<span class="nc" id="L713">    out.println();</span>

<span class="nc" id="L715">    out.println(&quot;# sgml = &quot;);</span>
<span class="nc" id="L716">    out.println(&quot;# tagInside = &quot;);</span>
<span class="nc" id="L717">    out.println();</span>

<span class="nc" id="L719">    out.println(&quot;# testFile and textFile can use multiple threads to process text.&quot;);</span>
<span class="nc" id="L720">    out.println(&quot;# nthreads = &quot; + NTHREADS);</span>
<span class="nc" id="L721">  }</span>

  public Mode getMode() {
<span class="nc bnc" id="L724" title="All 2 branches missed.">    if (!containsKey(&quot;mode&quot;)) {</span>
<span class="nc" id="L725">      return null;</span>
    }
<span class="nc" id="L727">    return Mode.valueOf(getProperty(&quot;mode&quot;));</span>
  }


  /** Serialize the TaggerConfig.
   *
   * @param os Where to write this TaggerConfig
   * @throws IOException If any IO problems
   */
  public void saveConfig(OutputStream os) throws IOException {
<span class="nc" id="L737">    ObjectOutputStream out = new ObjectOutputStream(os);</span>
<span class="nc" id="L738">    out.writeObject(this);</span>
<span class="nc" id="L739">  }</span>


  /** Read in a TaggerConfig.
   *
   * @param stream Where to read from
   * @return The TaggerConfig
   * @throws IOException Misc IOError
   * @throws ClassNotFoundException Class error
   */
  public static TaggerConfig readConfig(DataInputStream stream)
    throws IOException, ClassNotFoundException
  {
<span class="nc" id="L752">    ObjectInputStream in = new ObjectInputStream(stream);</span>
<span class="nc" id="L753">    return (TaggerConfig) in.readObject();</span>
  }


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>