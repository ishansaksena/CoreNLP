<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TestSentence.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.tagger.maxent</a> &gt; <span class="el_source">TestSentence.java</span></div><h1>TestSentence.java</h1><pre class="source lang-java linenums">// MaxentTagger -- StanfordMaxEnt, A Maximum Entropy Toolkit
// Copyright (c) 2002-2016 Leland Stanford Junior University

// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

// For more information, bug reports, fixes, contact:
// Christopher Manning
// Dept of Computer Science, Gates 2A
// Stanford CA 94305-9020
// USA
// Support/Questions: stanford-nlp on SO or java-nlp-user@lists.stanford.edu
// Licensing: java-nlp-support@lists.stanford.edu
// http://nlp.stanford.edu/software/tagger.html

package edu.stanford.nlp.tagger.maxent;

import edu.stanford.nlp.io.EncodingPrintWriter;
import edu.stanford.nlp.io.PrintFile;
import edu.stanford.nlp.ling.*;
import edu.stanford.nlp.ling.SentenceUtils;
import edu.stanford.nlp.math.ArrayMath;
import edu.stanford.nlp.math.SloppyMath;
import edu.stanford.nlp.sequences.BestSequenceFinder;
import edu.stanford.nlp.sequences.ExactBestSequenceFinder;
import edu.stanford.nlp.sequences.SequenceModel;
import edu.stanford.nlp.tagger.common.Tagger;
import edu.stanford.nlp.util.*;
import edu.stanford.nlp.util.logging.Redwood;

import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.util.*;
import java.text.NumberFormat;
import java.text.DecimalFormat;


/**
 * @author Kristina Toutanova
 * @author Michel Galley
 * @version 1.0
 */
<span class="nc bnc" id="L56" title="All 2 branches missed.">public class TestSentence implements SequenceModel  {</span>

  /** A logger for this class */
<span class="nc" id="L59">  private static Redwood.RedwoodChannels log = Redwood.channels(TestSentence.class);</span>

  protected final boolean VERBOSE;
  protected static final String naTag = &quot;NA&quot;;
<span class="nc" id="L63">  private static final String[] naTagArr = { naTag };</span>
  protected static final boolean DBG = false;
  protected static final int kBestSize = 1;

  protected final String tagSeparator;
  protected final String encoding;
<span class="nc" id="L69">  protected final PairsHolder pairs = new PairsHolder();</span>
  protected List&lt;String&gt; sent;
  private List&lt;String&gt; originalTags;
  // origWords is only set when run with a list of HasWords; when run
  // with a list of strings, this will be null
  protected List&lt;HasWord&gt; origWords;
  protected int size; // TODO this always has the value of sent.size(). Remove it? [cdm 2008]
  // protected double[][][] probabilities;
  private String[] correctTags;
  protected String[] finalTags;
  int numRight;
  int numWrong;
  int numUnknown;
  int numWrongUnknown;
  private int endSizePairs; // = 0;

  private volatile History history;
<span class="nc" id="L86">  private volatile Map&lt;String,double[]&gt; localScores = Generics.newHashMap();</span>
  private volatile double[][] localContextScores;

  protected final MaxentTagger maxentTagger;

<span class="nc" id="L91">  public TestSentence(MaxentTagger maxentTagger) {</span>
<span class="nc bnc" id="L92" title="All 4 branches missed.">    assert(maxentTagger != null);</span>
<span class="nc bnc" id="L93" title="All 4 branches missed.">    assert(maxentTagger.getLambdaSolve() != null);</span>
<span class="nc" id="L94">    this.maxentTagger = maxentTagger;</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">    if (maxentTagger.config != null) {</span>
<span class="nc" id="L96">      tagSeparator = maxentTagger.config.getTagSeparator();</span>
<span class="nc" id="L97">      encoding = maxentTagger.config.getEncoding();</span>
<span class="nc" id="L98">      VERBOSE = maxentTagger.config.getVerbose();</span>
    } else {
<span class="nc" id="L100">      tagSeparator = TaggerConfig.getDefaultTagSeparator();</span>
<span class="nc" id="L101">      encoding = &quot;utf-8&quot;;</span>
<span class="nc" id="L102">      VERBOSE = false;</span>
    }
<span class="nc" id="L104">    history = new History(pairs, maxentTagger.extractors);</span>
<span class="nc" id="L105">  }</span>

  public void setCorrectTags(List&lt;? extends HasTag&gt; sentence) {
<span class="nc" id="L108">    int len = sentence.size();</span>
<span class="nc" id="L109">    correctTags = new String[len];</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">    for (int i = 0; i &lt; len; i++) {</span>
<span class="nc" id="L111">      correctTags[i] = sentence.get(i).tag();</span>
    }
<span class="nc" id="L113">  }</span>

  /**
   * Tags the sentence s by running maxent model.  Returns a sentence (List) of
   * TaggedWord objects.
   *
   * @param s Input sentence (List).  This isn't changed.
   * @return Tagged sentence
   */
  public ArrayList&lt;TaggedWord&gt; tagSentence(List&lt;? extends HasWord&gt; s,
                                           boolean reuseTags) {
<span class="nc" id="L124">    this.origWords = new ArrayList&lt;&gt;(s);</span>
<span class="nc" id="L125">    int sz = s.size();</span>
<span class="nc" id="L126">    this.sent = new ArrayList&lt;&gt;(sz + 1);</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">    for (HasWord value1 : s) {</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">      if (maxentTagger.wordFunction != null) {</span>
<span class="nc" id="L129">        sent.add(maxentTagger.wordFunction.apply(value1.word()));</span>
      } else {
<span class="nc" id="L131">        sent.add(value1.word());</span>
      }
<span class="nc" id="L133">    }</span>
<span class="nc" id="L134">    sent.add(Tagger.EOS_WORD);</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">    if (reuseTags) {</span>
<span class="nc" id="L136">      this.originalTags = new ArrayList&lt;&gt;(sz + 1);</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">      for (HasWord value : s) {</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">        if (value instanceof HasTag) {</span>
<span class="nc" id="L139">          originalTags.add(((HasTag) value).tag());</span>
        } else {
<span class="nc" id="L141">          originalTags.add(null);</span>
        }
<span class="nc" id="L143">      }</span>
<span class="nc" id="L144">      originalTags.add(Tagger.EOS_TAG);</span>
    }
<span class="nc" id="L146">    size = sz + 1;</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">    if (VERBOSE) {</span>
<span class="nc" id="L148">      log.info(&quot;Sentence is &quot; + SentenceUtils.listToString(sent, false, tagSeparator));</span>
    }
<span class="nc" id="L150">    init();</span>
<span class="nc" id="L151">    ArrayList&lt;TaggedWord&gt; result = testTagInference();</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">    if (maxentTagger.wordFunction != null) {</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">      for (int j = 0; j &lt; sz; ++j) {</span>
<span class="nc" id="L154">        result.get(j).setWord(s.get(j).word());</span>
      }
    }
<span class="nc" id="L157">    return result;</span>
  }


  protected void revert(int prevSize) {
<span class="nc" id="L162">    endSizePairs = prevSize;</span>
<span class="nc" id="L163">  }</span>

  protected void init() {
    //the eos are assumed already there
<span class="nc" id="L167">    localContextScores = new double[size][];</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">    for (int i = 0; i &lt; size - 1; i++) {</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">      if (maxentTagger.dict.isUnknown(sent.get(i))) {</span>
<span class="nc" id="L170">        numUnknown++;</span>
      }
    }
<span class="nc" id="L173">  }</span>

  /**
   * Returns a string representation of the sentence.
   * @return tagged sentence
   */
  String getTaggedNice() {
<span class="nc" id="L180">    StringBuilder sb = new StringBuilder();</span>
    // size - 1 means to exclude the EOS (end of string) symbol
<span class="nc bnc" id="L182" title="All 2 branches missed.">    for (int i = 0; i &lt; size - 1; i++) {</span>
<span class="nc" id="L183">      sb.append(toNice(sent.get(i))).append(tagSeparator).append(toNice(finalTags[i]));</span>
<span class="nc" id="L184">      sb.append(' ');</span>
    }
<span class="nc" id="L186">    return sb.toString();</span>
  }


  ArrayList&lt;TaggedWord&gt; getTaggedSentence() {
    final boolean hasOffset;
<span class="nc bnc" id="L192" title="All 6 branches missed.">    hasOffset = origWords != null &amp;&amp; origWords.size() &gt; 0 &amp;&amp; (origWords.get(0) instanceof HasOffset);</span>
<span class="nc" id="L193">    ArrayList&lt;TaggedWord&gt; taggedSentence = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">    for (int j = 0; j &lt; size - 1; j++) {</span>
<span class="nc" id="L195">      String tag = finalTags[j];</span>
<span class="nc" id="L196">      TaggedWord w = new TaggedWord(sent.get(j), tag);</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">      if (hasOffset) {</span>
<span class="nc" id="L198">        HasOffset offset = (HasOffset) origWords.get(j);</span>
<span class="nc" id="L199">        w.setBeginPosition(offset.beginPosition());</span>
<span class="nc" id="L200">        w.setEndPosition(offset.endPosition());</span>
      }
<span class="nc" id="L202">      taggedSentence.add(w);</span>
    }
<span class="nc" id="L204">    return taggedSentence;</span>
  }

  static String toNice(String s) {
<span class="nc bnc" id="L208" title="All 2 branches missed.">    if (s == null) {</span>
<span class="nc" id="L209">      return naTag;</span>
    } else {
<span class="nc" id="L211">      return s;</span>
    }
  }

  /** calculateProbs puts log probs of taggings in the probabilities array.
   *
   *  @param probabilities Array with indices sent size, k best size, numTags
   */
  protected void calculateProbs(double[][][] probabilities) {
<span class="nc" id="L220">    ArrayUtils.fill(probabilities, Double.NEGATIVE_INFINITY);</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">    for (int hyp = 0; hyp &lt; kBestSize; hyp++) {</span>
      // put the whole thing in pairs, give its beginning and end
<span class="nc" id="L223">      pairs.setSize(size);</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">      for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L225">        pairs.setWord(i,sent.get(i));</span>
<span class="nc" id="L226">        pairs.setTag(i,finalTags[i]);</span>
        //pairs.add(new WordTag(sent.get(i),finalTags[i]));
        // TODO: if kBestSize &gt; 1, use KBestSequenceFinder and save
        // k-best hypotheses into finalTags:
        //pairs.setTag(i,finalTags[i]);
      }
<span class="nc" id="L232">      int start = endSizePairs;</span>
<span class="nc" id="L233">      int end = endSizePairs + size - 1;</span>
<span class="nc" id="L234">      endSizePairs = endSizePairs + size;</span>
      // iterate over the sentence
<span class="nc bnc" id="L236" title="All 2 branches missed.">      for (int current = 0; current &lt; size; current++) {</span>
<span class="nc" id="L237">        History h = new History(start, end, current + start, pairs, maxentTagger.extractors);</span>
<span class="nc" id="L238">        String[] tags = stringTagsAt(h.current - h.start + leftWindow());</span>
<span class="nc" id="L239">        double[] probs = getHistories(tags, h);</span>
<span class="nc" id="L240">        ArrayMath.logNormalize(probs);</span>

        // log.info(&quot;word: &quot; + pairs.getWord(current));
        // log.info(&quot;tags: &quot; + Arrays.asList(tags));
        // log.info(&quot;probs: &quot; + ArrayMath.toString(probs));

<span class="nc bnc" id="L246" title="All 2 branches missed.">        for (int j = 0; j &lt; tags.length; j++) {</span>
          // score the j-th tag
<span class="nc" id="L248">          String tag = tags[j];</span>
<span class="nc" id="L249">          boolean approximate = maxentTagger.hasApproximateScoring();</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">          int tagindex = approximate ? maxentTagger.tags.getIndex(tag) : j;</span>
          // log.info(&quot;Mapped from j=&quot;+ j + &quot; &quot; + tag + &quot; to &quot; + tagindex);
<span class="nc" id="L252">          probabilities[current][hyp][tagindex] = probs[j];</span>
        }
      } // for current
    } // for hyp
    // clean up the stuff in PairsHolder (added by cdm in Aug 2008)
<span class="nc" id="L257">    revert(0);</span>
<span class="nc" id="L258">  } // end calculateProbs()</span>


  /** Write the tagging and note any errors (if pf != null) and accumulate
   *  global statistics.
   *
   *  @param finalTags Chosen tags for sentence
   *  @param pf File to write tagged output to (can be null, then no output;
   *               at present it is non-null iff the debug property is set)
   */
  protected void writeTagsAndErrors(String[] finalTags, PrintFile pf, boolean verboseResults) {
<span class="nc" id="L269">    StringWriter sw = new StringWriter(200);</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">    for (int i = 0; i &lt; correctTags.length; i++) {</span>
<span class="nc" id="L271">      sw.write(toNice(sent.get(i)));</span>
<span class="nc" id="L272">      sw.write(tagSeparator);</span>
<span class="nc" id="L273">      sw.write(finalTags[i]);</span>
<span class="nc" id="L274">      sw.write(' ');</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">      if (pf != null) {</span>
<span class="nc" id="L276">        pf.print(toNice(sent.get(i)));</span>
<span class="nc" id="L277">        pf.print(tagSeparator);</span>
<span class="nc" id="L278">        pf.print(finalTags[i]);</span>
      }
<span class="nc bnc" id="L280" title="All 2 branches missed.">      if ((correctTags[i]).equals(finalTags[i])) {</span>
<span class="nc" id="L281">        numRight++;</span>
      } else {
<span class="nc" id="L283">        numWrong++;</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">        if (pf != null) pf.print('|' + correctTags[i]);</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">        if (verboseResults) {</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">          EncodingPrintWriter.err.println((maxentTagger.dict.isUnknown(sent.get(i)) ? &quot;Unk&quot; : &quot;&quot;) + &quot;Word: &quot; + sent.get(i) + &quot;; correct: &quot; + correctTags[i] + &quot;; guessed: &quot; + finalTags[i], encoding);</span>
        }

<span class="nc bnc" id="L289" title="All 2 branches missed.">        if (maxentTagger.dict.isUnknown(sent.get(i))) {</span>
<span class="nc" id="L290">          numWrongUnknown++;</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">          if (pf != null) pf.print(&quot;*&quot;);</span>
        }// if
      }// else
<span class="nc bnc" id="L294" title="All 2 branches missed.">      if (pf != null) pf.print(' ');</span>
    }// for
<span class="nc bnc" id="L296" title="All 2 branches missed.">    if (pf != null) pf.println();</span>

<span class="nc bnc" id="L298" title="All 2 branches missed.">    if (verboseResults) {</span>
      PrintWriter pw;
      try {
<span class="nc" id="L301">        pw = new PrintWriter(new OutputStreamWriter(System.out, encoding), true);</span>
<span class="nc" id="L302">      } catch (UnsupportedEncodingException uee) {</span>
<span class="nc" id="L303">        pw = new PrintWriter(new OutputStreamWriter(System.out), true);</span>
<span class="nc" id="L304">      }</span>
<span class="nc" id="L305">      pw.println(sw);</span>
    }
<span class="nc" id="L307">  }</span>

  /**
   * Update a confusion matrix with the errors from this sentence.
   *
   * @param finalTags Chosen tags for sentence
   * @param confusionMatrix Confusion matrix to write to
   */
  protected void updateConfusionMatrix(String[] finalTags,
                                       ConfusionMatrix&lt;String&gt; confusionMatrix) {
<span class="nc bnc" id="L317" title="All 2 branches missed.">    for (int i = 0; i &lt; correctTags.length; i++)</span>
<span class="nc" id="L318">      confusionMatrix.add(finalTags[i], correctTags[i]);</span>
<span class="nc" id="L319">  }</span>


  /**
   * Test using (exact Viterbi) TagInference.
   *
   * @return The tagged sentence
   */
  private ArrayList&lt;TaggedWord&gt; testTagInference() {
<span class="nc" id="L328">    runTagInference();</span>
<span class="nc" id="L329">    return getTaggedSentence();</span>
  }

  private void runTagInference() {
<span class="nc" id="L333">    this.initializeScorer();</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">    if (Thread.interrupted()) {  // Allow interrupting</span>
<span class="nc" id="L335">      throw new RuntimeInterruptedException();</span>
    }

<span class="nc" id="L338">    BestSequenceFinder ti = new ExactBestSequenceFinder();</span>
      //new BeamBestSequenceFinder(50);
      //new KBestSequenceFinder()
<span class="nc" id="L341">    int[] bestTags = ti.bestSequence(this);</span>
<span class="nc" id="L342">    finalTags = new String[bestTags.length];</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">    for (int j = 0; j &lt; size; j++) {</span>
<span class="nc" id="L344">      finalTags[j] = maxentTagger.tags.getTag(bestTags[j + leftWindow()]);</span>
    }

<span class="nc bnc" id="L347" title="All 2 branches missed.">    if (Thread.interrupted()) {  // Allow interrupting</span>
<span class="nc" id="L348">      throw new RuntimeInterruptedException();</span>
    }
<span class="nc" id="L350">    cleanUpScorer();</span>
<span class="nc" id="L351">  }</span>


  // This is used for Dan's tag inference methods.
  // current is the actual word number + leftW
  private void setHistory(int current, History h, int[] tags) {
    //writes over the tags in the last thing in pairs

<span class="nc" id="L359">    int left = leftWindow();</span>
<span class="nc" id="L360">    int right = rightWindow();</span>

<span class="nc bnc" id="L362" title="All 2 branches missed.">    for (int j = current - left; j &lt;= current + right; j++) {</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">      if (j &lt; left) {</span>
<span class="nc" id="L364">        continue;</span>
      } //but shouldn't happen
<span class="nc bnc" id="L366" title="All 2 branches missed.">      if (j &gt;= size + left) {</span>
<span class="nc" id="L367">        break;</span>
      } //but shouldn't happen
<span class="nc" id="L369">      h.setTag(j - left, maxentTagger.tags.getTag(tags[j]));</span>
    }
<span class="nc" id="L371">  }</span>

  // do initializations for the TagScorer interface
  protected void initializeScorer() {
<span class="nc" id="L375">    pairs.setSize(size);</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">    for (int i = 0; i &lt; size; i++)</span>
<span class="nc" id="L377">      pairs.setWord(i,sent.get(i));</span>
<span class="nc" id="L378">    endSizePairs += size;</span>
<span class="nc" id="L379">  }</span>


  /**
   * clean-up after the scorer
   */
  protected void cleanUpScorer() {
<span class="nc" id="L386">    revert(0);</span>
<span class="nc" id="L387">  }</span>

  // This scores the current assignment in PairsHolder at
  // current position h.current (returns normalized scores)
  private double[] getScores(History h) {
<span class="nc bnc" id="L392" title="All 2 branches missed.">    if (maxentTagger.hasApproximateScoring()) {</span>
<span class="nc" id="L393">      return getApproximateScores(h);</span>
    }
<span class="nc" id="L395">    return getExactScores(h);</span>
  }

  private double[] getExactScores(History h) {
<span class="nc" id="L399">    String[] tags = stringTagsAt(h.current - h.start + leftWindow());</span>
<span class="nc" id="L400">    double[] histories = getHistories(tags, h); // log score for each tag</span>
<span class="nc" id="L401">    ArrayMath.logNormalize(histories);</span>
<span class="nc" id="L402">    double[] scores = new double[tags.length];</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">    for (int j = 0; j &lt; tags.length; j++) {</span>
      // score the j-th tag
<span class="nc" id="L405">      String tag = tags[j];</span>
<span class="nc" id="L406">      int tagindex = maxentTagger.tags.getIndex(tag);</span>
<span class="nc" id="L407">      scores[j] = histories[tagindex];</span>
    }
<span class="nc" id="L409">    return scores;</span>
  }

  // In this method, each tag that is incompatible with the current word
  // (e.g., apple_CC) gets a default (constant) score instead of its exact score.
  // The scores of all other tags are computed exactly.
  private double[] getApproximateScores(History h) {
<span class="nc" id="L416">    String[] tags = stringTagsAt(h.current - h.start + leftWindow());</span>
<span class="nc" id="L417">    double[] scores = getHistories(tags, h); // log score for each active tag, unnormalized</span>

    // Number of tags that get assigned a default score:
<span class="nc" id="L420">    int nDefault = maxentTagger.ySize - tags.length;</span>
<span class="nc" id="L421">    double logScore = ArrayMath.logSum(scores);</span>
<span class="nc" id="L422">    double logScoreInactiveTags = maxentTagger.getInactiveTagDefaultScore(nDefault);</span>
<span class="nc" id="L423">    double logTotal = SloppyMath.logAdd(logScore, logScoreInactiveTags);</span>
<span class="nc" id="L424">    ArrayMath.addInPlace(scores, -logTotal);</span>

<span class="nc" id="L426">    return scores;</span>
  }

  // This precomputes scores of local features (localScores).
  protected double[] getHistories(String[] tags, History h) {
<span class="nc" id="L431">    boolean rare = maxentTagger.isRare(ExtractorFrames.cWord.extract(h));</span>
<span class="nc" id="L432">    Extractors ex = maxentTagger.extractors, exR = maxentTagger.extractorsRare;</span>
<span class="nc" id="L433">    String w = pairs.getWord(h.current);</span>
    double[] lS, lcS;
<span class="nc" id="L435">    lS = localScores.get(w);</span>
<span class="nc bnc" id="L436" title="All 2 branches missed.">    if (lS == null) {</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">      lS = getHistories(tags, h, ex.local, rare ? exR.local : null);</span>
<span class="nc" id="L438">      localScores.put(w,lS);</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">    } else if (lS.length != tags.length) {</span>
      // This case can occur when a word was given a specific forced
      // tag, and then later it shows up without the forced tag.
      // TODO: if a word is given a forced tag, we should always get
      // its features rather than use the cache, just in case the tag
      // given is not the same tag as before
<span class="nc bnc" id="L445" title="All 2 branches missed.">      lS = getHistories(tags, h, ex.local, rare ? exR.local : null);</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">      if (tags.length &gt; 1) {</span>
<span class="nc" id="L447">        localScores.put(w,lS);</span>
      }
    }
<span class="nc bnc" id="L450" title="All 2 branches missed.">    if((lcS = localContextScores[h.current]) == null) {</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">      lcS = getHistories(tags, h, ex.localContext, rare ? exR.localContext : null);</span>
<span class="nc" id="L452">      localContextScores[h.current] = lcS;</span>
<span class="nc" id="L453">      ArrayMath.pairwiseAddInPlace(lcS,lS);</span>
    }
<span class="nc bnc" id="L455" title="All 2 branches missed.">    double[] totalS = getHistories(tags, h, ex.dynamic, rare ? exR.dynamic : null);</span>
<span class="nc" id="L456">    ArrayMath.pairwiseAddInPlace(totalS,lcS);</span>
<span class="nc" id="L457">    return totalS;</span>
  }

  private double[] getHistories(String[] tags, History h, List&lt;Pair&lt;Integer,Extractor&gt;&gt; extractors, List&lt;Pair&lt;Integer,Extractor&gt;&gt; extractorsRare) {
<span class="nc bnc" id="L461" title="All 2 branches missed.">    if(maxentTagger.hasApproximateScoring())</span>
<span class="nc" id="L462">      return getApproximateHistories(tags, h, extractors, extractorsRare);</span>
<span class="nc" id="L463">    return getExactHistories(h, extractors, extractorsRare);</span>
  }

  private double[] getExactHistories(History h, List&lt;Pair&lt;Integer,Extractor&gt;&gt; extractors, List&lt;Pair&lt;Integer,Extractor&gt;&gt; extractorsRare) {
<span class="nc" id="L467">    double[] scores = new double[maxentTagger.ySize];</span>
<span class="nc" id="L468">    int szCommon = maxentTagger.extractors.size();</span>

<span class="nc bnc" id="L470" title="All 2 branches missed.">    for (Pair&lt;Integer,Extractor&gt; e : extractors) {</span>
<span class="nc" id="L471">      int kf = e.first();</span>
<span class="nc" id="L472">      Extractor ex = e.second();</span>
<span class="nc" id="L473">      String val = ex.extract(h);</span>
<span class="nc" id="L474">      int[] fAssociations = maxentTagger.fAssociations.get(kf).get(val);</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">      if (fAssociations != null) {</span>
<span class="nc bnc" id="L476" title="All 2 branches missed.">        for (int i = 0; i &lt; maxentTagger.ySize; i++) {</span>
<span class="nc" id="L477">          int fNum = fAssociations[i];</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">          if (fNum &gt; -1) {</span>
<span class="nc" id="L479">            scores[i] += maxentTagger.getLambdaSolve().lambda[fNum];</span>
          }
        }
      }
<span class="nc" id="L483">    }</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">    if (extractorsRare != null) {</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">      for (Pair&lt;Integer,Extractor&gt; e : extractorsRare) {</span>
<span class="nc" id="L486">        int kf = e.first();</span>
<span class="nc" id="L487">        Extractor ex = e.second();</span>
<span class="nc" id="L488">        String val = ex.extract(h);</span>
<span class="nc" id="L489">        int[] fAssociations = maxentTagger.fAssociations.get(kf+szCommon).get(val);</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">        if (fAssociations != null) {</span>
<span class="nc bnc" id="L491" title="All 2 branches missed.">          for (int i = 0; i &lt; maxentTagger.ySize; i++) {</span>
<span class="nc" id="L492">            int fNum = fAssociations[i];</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">            if (fNum &gt; -1) {</span>
<span class="nc" id="L494">              scores[i] += maxentTagger.getLambdaSolve().lambda[fNum];</span>
            }
          }
        }
<span class="nc" id="L498">      }</span>
    }
<span class="nc" id="L500">    return scores;</span>
  }

  // todo [cdm 2016]: Could this be sped up a bit by caching lambda array, extracting method for shared code?
  // todo [cdm 2016]: Also it's allocating java.util.ArrayList$Itr for for loop - why can't it just random access array?
  /** Returns an unnormalized score (in log space) for each tag. */
  private double[] getApproximateHistories(String[] tags, History h, List&lt;Pair&lt;Integer,Extractor&gt;&gt; extractors, List&lt;Pair&lt;Integer,Extractor&gt;&gt; extractorsRare) {

<span class="nc" id="L508">    double[] scores = new double[tags.length];</span>
<span class="nc" id="L509">    int szCommon = maxentTagger.extractors.size();</span>

<span class="nc bnc" id="L511" title="All 2 branches missed.">    for (Pair&lt;Integer,Extractor&gt; e : extractors) {</span>
<span class="nc" id="L512">      int kf = e.first();</span>
<span class="nc" id="L513">      Extractor ex = e.second();</span>
<span class="nc" id="L514">      String val = ex.extract(h);</span>
<span class="nc" id="L515">      int[] fAssociations = maxentTagger.fAssociations.get(kf).get(val);</span>
<span class="nc bnc" id="L516" title="All 2 branches missed.">      if (fAssociations != null) {</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">        for (int j = 0; j &lt; tags.length; j++) {</span>
<span class="nc" id="L518">          String tag = tags[j];</span>
<span class="nc" id="L519">          int tagIndex = maxentTagger.tags.getIndex(tag);</span>
<span class="nc" id="L520">          int fNum = fAssociations[tagIndex];</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">          if (fNum &gt; -1) {</span>
<span class="nc" id="L522">            scores[j] += maxentTagger.getLambdaSolve().lambda[fNum];</span>
          }
        }
      }
<span class="nc" id="L526">    }</span>
<span class="nc bnc" id="L527" title="All 2 branches missed.">    if (extractorsRare != null) {</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">      for (Pair&lt;Integer,Extractor&gt; e : extractorsRare) {</span>
<span class="nc" id="L529">        int kf = e.first();</span>
<span class="nc" id="L530">        Extractor ex = e.second();</span>
<span class="nc" id="L531">        String val = ex.extract(h);</span>
<span class="nc" id="L532">        int[] fAssociations = maxentTagger.fAssociations.get(szCommon+kf).get(val);</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">        if (fAssociations != null) {</span>
<span class="nc bnc" id="L534" title="All 2 branches missed.">          for (int j = 0; j &lt; tags.length; j++) {</span>
<span class="nc" id="L535">            String tag = tags[j];</span>
<span class="nc" id="L536">            int tagIndex = maxentTagger.tags.getIndex(tag);</span>
<span class="nc" id="L537">            int fNum = fAssociations[tagIndex];</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">            if (fNum &gt; -1) {</span>
<span class="nc" id="L539">              scores[j] += maxentTagger.getLambdaSolve().lambda[fNum];</span>
            }
          }
        }
<span class="nc" id="L543">      }</span>
    }
<span class="nc" id="L545">    return scores;</span>
  }


  /**
   * This method should be called after the sentence has been tagged.
   * For every unknown word, this method prints the 3 most probable tags
   * to the file pfu.
   *
   * @param numSent The sentence number
   * @param pfu The file to print the probable tags to
   */
  void printUnknown(int numSent, PrintFile pfu) {
<span class="nc" id="L558">    NumberFormat nf = new DecimalFormat(&quot;0.0000&quot;);</span>
<span class="nc" id="L559">    int numTags = maxentTagger.numTags();</span>
<span class="nc" id="L560">    double[][][] probabilities = new double[size][kBestSize][numTags];</span>
<span class="nc" id="L561">    calculateProbs(probabilities);</span>
<span class="nc bnc" id="L562" title="All 2 branches missed.">    for (int current = 0; current &lt; size; current++) {</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">      if (maxentTagger.dict.isUnknown(sent.get(current))) {</span>
<span class="nc" id="L564">        pfu.print(sent.get(current));</span>
<span class="nc" id="L565">        pfu.print(':');</span>
<span class="nc" id="L566">        pfu.print(numSent);</span>
<span class="nc" id="L567">        double[] probs = new double[3];</span>
<span class="nc" id="L568">        String[] tag3 = new String[3];</span>
<span class="nc" id="L569">        getTop3(probabilities, current, probs, tag3);</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">        for (int i = 0; i &lt; 3; i++) {</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">          if (probs[i] &gt; Double.NEGATIVE_INFINITY) {</span>
<span class="nc" id="L572">            pfu.print('\t');</span>
<span class="nc" id="L573">            pfu.print(tag3[i]);</span>
<span class="nc" id="L574">            pfu.print(' ');</span>
<span class="nc" id="L575">            pfu.print(nf.format(Math.exp(probs[i])));</span>
          }
        }
        int rank;
<span class="nc" id="L579">        String correctTag = toNice(this.correctTags[current]);</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">        for (rank = 0; rank &lt; 3; rank++) {</span>
<span class="nc bnc" id="L581" title="All 2 branches missed.">          if (correctTag.equals(tag3[rank])) {</span>
<span class="nc" id="L582">            break;</span>
          } //if
        }
<span class="nc" id="L585">        pfu.print('\t');</span>
<span class="nc bnc" id="L586" title="All 4 branches missed.">        switch (rank) {</span>
          case 0:
<span class="nc" id="L588">            pfu.print(&quot;Correct&quot;);</span>
<span class="nc" id="L589">            break;</span>
          case 1:
<span class="nc" id="L591">            pfu.print(&quot;2nd&quot;);</span>
<span class="nc" id="L592">            break;</span>
          case 2:
<span class="nc" id="L594">            pfu.print(&quot;3rd&quot;);</span>
<span class="nc" id="L595">            break;</span>
          default:
<span class="nc" id="L597">            pfu.print(&quot;Not top 3&quot;);</span>
        }
<span class="nc" id="L599">        pfu.println();</span>
      }// if
    }// for
<span class="nc" id="L602">  }</span>

  // This method should be called after a sentence has been tagged.
  // For every word token, this method prints the 3 most probable tags
  // to the file pfu except for
  void printTop(PrintFile pfu) {
<span class="nc" id="L608">    NumberFormat nf = new DecimalFormat(&quot;0.0000&quot;);</span>
<span class="nc" id="L609">    int numTags = maxentTagger.numTags();</span>
<span class="nc" id="L610">    double[][][] probabilities = new double[size][kBestSize][numTags];</span>
<span class="nc" id="L611">    calculateProbs(probabilities);</span>

<span class="nc bnc" id="L613" title="All 2 branches missed.">    for (int current = 0; current &lt; correctTags.length; current++) {</span>
<span class="nc" id="L614">      pfu.print(sent.get(current));</span>
<span class="nc" id="L615">      double[] probs = new double[3];</span>
<span class="nc" id="L616">      String[] tag3 = new String[3];</span>
<span class="nc" id="L617">      getTop3(probabilities, current, probs, tag3);</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">      for (int i = 0; i &lt; 3; i++) {</span>
<span class="nc bnc" id="L619" title="All 2 branches missed.">        if (probs[i] &gt; Double.NEGATIVE_INFINITY) {</span>
<span class="nc" id="L620">          pfu.print('\t');</span>
<span class="nc" id="L621">          pfu.print(tag3[i]);</span>
<span class="nc" id="L622">          pfu.print(' ');</span>
<span class="nc" id="L623">          pfu.print(nf.format(Math.exp(probs[i])));</span>
        }
      }
      int rank;
<span class="nc" id="L627">      String correctTag = toNice(this.correctTags[current]);</span>
<span class="nc bnc" id="L628" title="All 2 branches missed.">      for (rank = 0; rank &lt; 3; rank++) {</span>
<span class="nc bnc" id="L629" title="All 2 branches missed.">        if (correctTag.equals(tag3[rank])) {</span>
<span class="nc" id="L630">          break;</span>
        } //if
      }
<span class="nc" id="L633">      pfu.print('\t');</span>
<span class="nc bnc" id="L634" title="All 4 branches missed.">      switch (rank) {</span>
      case 0:
<span class="nc" id="L636">        pfu.print(&quot;Correct&quot;);</span>
<span class="nc" id="L637">        break;</span>
      case 1:
<span class="nc" id="L639">        pfu.print(&quot;2nd&quot;);</span>
<span class="nc" id="L640">        break;</span>
      case 2:
<span class="nc" id="L642">        pfu.print(&quot;3rd&quot;);</span>
<span class="nc" id="L643">        break;</span>
      default:
<span class="nc" id="L645">        pfu.print(&quot;Not top 3&quot;);</span>
      }
<span class="nc" id="L647">      pfu.println();</span>
    } // for
<span class="nc" id="L649">  }</span>

  /** probs and tags should be passed in as arrays of size 3!
   *  If probs[i] == Double.NEGATIVE_INFINITY, then the entry should be ignored.
   */
  private void getTop3(double[][][] probabilities, int current, double[] probs, String[] tags) {
<span class="nc" id="L655">    int[] topIds = new int[3];</span>
<span class="nc" id="L656">    double[] probTags = probabilities[current][0];</span>
<span class="nc" id="L657">    Arrays.fill(probs, Double.NEGATIVE_INFINITY);</span>
<span class="nc bnc" id="L658" title="All 2 branches missed.">    for (int i = 0; i &lt; probTags.length; i++) {</span>
<span class="nc bnc" id="L659" title="All 2 branches missed.">      if (probTags[i] &gt; probs[0]) {</span>
<span class="nc" id="L660">        probs[2] = probs[1];</span>
<span class="nc" id="L661">        probs[1] = probs[0];</span>
<span class="nc" id="L662">        probs[0] = probTags[i];</span>
<span class="nc" id="L663">        topIds[2] = topIds[1];</span>
<span class="nc" id="L664">        topIds[1] = topIds[0];</span>
<span class="nc" id="L665">        topIds[0] = i;</span>
<span class="nc bnc" id="L666" title="All 2 branches missed.">      } else if (probTags[i] &gt; probs[1]) {</span>
<span class="nc" id="L667">        probs[2] = probs[1];</span>
<span class="nc" id="L668">        probs[1] = probTags[i];</span>
<span class="nc" id="L669">        topIds[2] = topIds[1];</span>
<span class="nc" id="L670">        topIds[1] = i;</span>
<span class="nc bnc" id="L671" title="All 2 branches missed.">      } else if (probTags[i] &gt; probs[2]) {</span>
<span class="nc" id="L672">        probs[2] = probTags[i];</span>
<span class="nc" id="L673">        topIds[2] = i;</span>
      }
    }
<span class="nc bnc" id="L676" title="All 2 branches missed.">    for (int j = 0; j &lt; 3; j++) {</span>
<span class="nc" id="L677">      tags[j] = toNice(maxentTagger.tags.getTag(topIds[j]));</span>
    }
<span class="nc" id="L679">  }</span>

  /*
   * Implementation of the TagScorer interface follows
   */

  @Override
  public int length() {
<span class="nc" id="L687">    return sent.size();</span>
  }

  @Override
  public int leftWindow() {
<span class="nc" id="L692">    return maxentTagger.leftContext; //hard-code for now</span>
  }

  @Override
  public int rightWindow() {
<span class="nc" id="L697">    return maxentTagger.rightContext; //hard code for now</span>
  }


  @Override
  public int[] getPossibleValues(int pos) {
<span class="nc" id="L703">    String[] arr1 = stringTagsAt(pos);</span>
<span class="nc" id="L704">    int[] arr = new int[arr1.length];</span>
<span class="nc bnc" id="L705" title="All 2 branches missed.">    for (int i = 0; i &lt; arr.length; i++) {</span>
<span class="nc" id="L706">      arr[i] = maxentTagger.tags.getIndex(arr1[i]);</span>
    }

<span class="nc" id="L709">    return arr;</span>
  }

  @Override
  public double scoreOf(int[] tags, int pos) {
<span class="nc" id="L714">    double[] scores = scoresOf(tags, pos);</span>
<span class="nc" id="L715">    double score = Double.NEGATIVE_INFINITY;</span>
<span class="nc" id="L716">    int[] pv = getPossibleValues(pos);</span>
<span class="nc bnc" id="L717" title="All 2 branches missed.">    for (int i = 0; i &lt; scores.length; i++) {</span>
<span class="nc bnc" id="L718" title="All 2 branches missed.">      if (pv[i] == tags[pos]) {</span>
<span class="nc" id="L719">        score = scores[i];</span>
      }
    }
<span class="nc" id="L722">    return score;</span>
  }

  @Override
  public double scoreOf(int[] sequence) {
<span class="nc" id="L727">    throw new UnsupportedOperationException();</span>
  }

  @Override
  public double[] scoresOf(int[] tags, int pos) {
    if (DBG) {
      log.info(&quot;scoresOf(): length of tags is &quot; + tags.length + &quot;; position is &quot; + pos + &quot;; endSizePairs = &quot; + endSizePairs + &quot;; size is &quot; + size + &quot;; leftWindow is &quot; + leftWindow());
      log.info(&quot;  History h = new History(&quot; + (endSizePairs - size) + &quot;, &quot; + (endSizePairs - 1) + &quot;, &quot; + (endSizePairs - size + pos - leftWindow()) + &quot;)&quot;);
    }
<span class="nc" id="L736">    history.init(endSizePairs - size, endSizePairs - 1, endSizePairs - size + pos - leftWindow());</span>
<span class="nc" id="L737">    setHistory(pos, history, tags);</span>
<span class="nc" id="L738">    return getScores(history);</span>
  }

  // todo [cdm 2013]: Tagging could be sped up quite a bit here if we cached int arrays of tags by index, not Strings
  protected String[] stringTagsAt(int pos) {
<span class="nc bnc" id="L743" title="All 4 branches missed.">    if ((pos &lt; leftWindow()) || (pos &gt;= size + leftWindow())) {</span>
<span class="nc" id="L744">      return naTagArr;</span>
    }

    String[] arr1;
<span class="nc bnc" id="L748" title="All 4 branches missed.">    if (originalTags != null &amp;&amp; originalTags.get(pos - leftWindow()) != null) {</span>
<span class="nc" id="L749">      arr1 = new String[1];</span>
<span class="nc" id="L750">      arr1[0] = originalTags.get(pos - leftWindow());</span>
<span class="nc" id="L751">      return arr1;</span>
    }

<span class="nc" id="L754">    String word = sent.get(pos - leftWindow());</span>
<span class="nc bnc" id="L755" title="All 2 branches missed.">    if (maxentTagger.dict.isUnknown(word)) {</span>
<span class="nc" id="L756">      Set&lt;String&gt; open = maxentTagger.tags.getOpenTags();  // todo: really want array of String or int here</span>
<span class="nc" id="L757">      arr1 = open.toArray(new String[open.size()]);</span>
<span class="nc" id="L758">    } else {</span>
<span class="nc" id="L759">      arr1 = maxentTagger.dict.getTags(word);</span>
    }
<span class="nc" id="L761">    arr1 = maxentTagger.tags.deterministicallyExpandTags(arr1);</span>
<span class="nc" id="L762">    return arr1;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>