<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ExtractorFrames.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.tagger.maxent</a> &gt; <span class="el_source">ExtractorFrames.java</span></div><h1>ExtractorFrames.java</h1><pre class="source lang-java linenums">//ExtractorFrames -- StanfordMaxEnt, A Maximum Entropy Toolkit
//Copyright (c) 2002-2011 Leland Stanford Junior University


//This program is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either version 2
//of the License, or (at your option) any later version.

//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.

//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

//For more information, bug reports, fixes, contact:
//Christopher Manning
//Dept of Computer Science, Gates 1A
//Stanford CA 94305-9010
//USA
//    Support/Questions: java-nlp-user@lists.stanford.edu
//    Licensing: java-nlp-support@lists.stanford.edu
//http://www-nlp.stanford.edu/software/tagger.shtml


package edu.stanford.nlp.tagger.maxent;
import edu.stanford.nlp.util.logging.Redwood;

import edu.stanford.nlp.process.WordShapeClassifier;
import edu.stanford.nlp.util.StringUtils;

import java.util.*;


/**
 * This class contains the basic feature extractors used for all words and
 * tag sequences (and interaction terms) for the MaxentTagger, but not the
 * feature extractors explicitly targeting generalization for rare or unknown
 * words.
 * The following options are supported:
 * &lt;table&gt;
 * &lt;tr&gt;&lt;td&gt;Name&lt;/td&gt;&lt;td&gt;Args&lt;/td&gt;&lt;td&gt;Effect&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;words&lt;/td&gt;&lt;td&gt;begin, end&lt;/td&gt;
 *     &lt;td&gt;Individual features for words begin ... end.
 *     If just one argument words(-2) is given, then end is taken as 0. If
 *     begin is not less than or equal to end, no features are made.&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;tags&lt;/td&gt;&lt;td&gt;begin, end&lt;/td&gt;
 *     &lt;td&gt;Individual features for tags begin ... end&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;biword&lt;/td&gt;&lt;td&gt;w1, w2&lt;/td&gt;
 *     &lt;td&gt;One feature for the pair of words w1, w2&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;biwords&lt;/td&gt;&lt;td&gt;begin, end&lt;/td&gt;
 *     &lt;td&gt;One feature for each sequential pair of words
 *         from begin to end&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;twoTags&lt;/td&gt;&lt;td&gt;t1, t2&lt;/td&gt;
 *     &lt;td&gt;One feature for the pair of tags t1, t2&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;lowercasewords&lt;/td&gt;&lt;td&gt;begin, end&lt;/td&gt;
 *     &lt;td&gt;One feature for each word begin ... end, lowercased&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;order&lt;/td&gt;&lt;td&gt;left, right&lt;/td&gt;
 *     &lt;td&gt;A feature for tags left through 0 and a feature for
 *         tags 0 through right.  Lower order left and right features are
 *         also added.
 *         This gets very expensive for higher order terms.&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;wordTag&lt;/td&gt;&lt;td&gt;w, t&lt;/td&gt;
 *     &lt;td&gt;A feature combining word w and tag t.&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;wordTwoTags&lt;/td&gt;&lt;td&gt;w, t1, t2&lt;/td&gt;
 *     &lt;td&gt;A feature combining word w and tags t1, t2.&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;threeTags&lt;/td&gt;&lt;td&gt;t1, t2, t3&lt;/td&gt;
 *     &lt;td&gt;A feature combining tags t1, t2, t3.&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;vbn&lt;/td&gt;&lt;td&gt;length&lt;/td&gt;
 *     &lt;td&gt;A feature that looks at the left length words for something that
 *         appears to be a VBN (in English) without looking at the actual tags.
 *         It is zeroeth order, as it does not look at the tag predictions.
 *         It also is never used, since it doesn't seem to help.&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;allwordshapes&lt;/td&gt;&lt;td&gt;left, right&lt;/td&gt;
 *     &lt;td&gt;Word shape features, eg transform Foo5 into Xxx#
 *         (not exactly like that, but that general idea).
 *         Creates individual features for each word left ... right.
 *         Compare with the feature &quot;wordshapes&quot; in ExtractorFramesRare,
 *         which is only applied to rare words. Fairly English-specific.
 *         Slightly increases accuracy.&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;allunicodeshapes&lt;/td&gt;&lt;td&gt;left, right&lt;/td&gt;
 *     &lt;td&gt;Same thing, but works for unicode characters more generally.&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;td&gt;allunicodeshapeconjunction&lt;/td&gt;&lt;td&gt;left, right&lt;/td&gt;
 *     &lt;td&gt;Instead of individual word shape features, combines several
 *         word shapes into one feature.&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;
 *
 * See {@link ExtractorFramesRare} for more options.
 * &lt;br&gt;
 * There are also macro features:
 * &lt;br&gt;
 * left3words = words(-1,1),order(2) &lt;br&gt;
 * left5words = words(-2,2),order(2) &lt;br&gt;
 * generic = words(-1,1),order(2),biwords(-1,0),wordTag(0,-1) &lt;br&gt;
 * bidirectional5words =
 *   words(-2,2),order(-2,2),twoTags(-1,1),
 *   wordTag(0,-1),wordTag(0,1),biwords(-1,1) &lt;br&gt;
 * bidirectional =
 *   words(-1,1),order(-2,2),twoTags(-1,1),
 *   wordTag(0,-1),wordTag(0,1),biwords(-1,1) &lt;br&gt;
 * german = some random stuff &lt;br&gt;
 * sighan2005 = some other random stuff &lt;br&gt;
 * The left3words architectures are faster, but slightly less
 * accurate, than the bidirectional architectures.
 * 'naacl2003unknowns' was our traditional set of unknown word
 * features, but you can now specify features more flexibility via the
 * various other supported keywords.
 * &lt;br&gt;
 * @author Kristina Toutanova
 * @author Michel Galley
 * @version 1.0
 */
public class ExtractorFrames  {

  /** A logger for this class */
<span class="fc" id="L119">  private static Redwood.RedwoodChannels log = Redwood.channels(ExtractorFrames.class);</span>

  // all features are implicitly conjoined with the current tag
<span class="fc" id="L122">  static final Extractor cWord = new Extractor(0, false);</span>
<span class="fc" id="L123">  private static final Extractor prevWord = new Extractor(-1, false);</span>
<span class="fc" id="L124">  private static final Extractor prevTag = new Extractor(-1, true);</span>
  // prev tag and current word!
<span class="fc" id="L126">  private static final Extractor prevTagWord = new ExtractorWordTag(0, -1);</span>

<span class="fc" id="L128">  private static final Extractor prevWord2 = new Extractor(-2,false);</span>
<span class="fc" id="L129">  private static final Extractor prevTwoTag = new Extractor(-2,true);</span>
<span class="fc" id="L130">  private static final Extractor nextWord = new Extractor(1, false);</span>
<span class="fc" id="L131">  private static final Extractor nextWord2 = new Extractor(2,false);</span>
<span class="fc" id="L132">  private static final Extractor nextTag = new Extractor(1, true);</span>


  // features for 2005 SIGHAN tagger
<span class="fc" id="L136">  private static final Extractor[] eFrames_sighan2005 = { cWord, prevWord, prevWord2, nextWord, nextWord2, prevTag, prevTwoTag, new ExtractorContinuousTagConjunction(-2) };</span>

  // features for a german-language bidirectional tagger
<span class="fc" id="L139">  private static final Extractor[] eFrames_german ={ cWord, prevWord, nextWord, nextTag,</span>
      prevTag, new ExtractorContinuousTagConjunction(-2), prevTagWord, new ExtractorTwoWords(-1,0) };

  /**
   * This class is not meant to be instantiated.
   */
<span class="nc" id="L145">  private ExtractorFrames() {</span>
<span class="nc" id="L146">  }</span>


  protected static Extractor[] getExtractorFrames(String arch) {
    // handle some traditional macro options
    // left3words: a simple trigram CMM tagger (similar to the baseline EMNLP 2000 tagger)
    // left5words: a simple trigram CMM tagger, like left3words, with 5 word context
    // generic: our standard multilingual CMM baseline

<span class="fc" id="L155">    arch = arch.replaceAll(&quot;left3words&quot;, &quot;words(-1,1),order(2)&quot;);</span>
<span class="fc" id="L156">    arch = arch.replaceAll(&quot;left5words&quot;, &quot;words(-2,2),order(2)&quot;);</span>
<span class="fc" id="L157">    arch = arch.replaceAll(&quot;generic&quot;, &quot;words(-1,1),order(2),biwords(-1,0),wordTag(0,-1)&quot;);</span>
<span class="fc" id="L158">    arch = arch.replaceAll(&quot;bidirectional5words&quot;, &quot;words(-2,2),order(-2,2),twoTags(-1,1),wordTag(0,-1),wordTag(0,1),biwords(-1,1)&quot;);</span>
<span class="fc" id="L159">    arch = arch.replaceAll(&quot;bidirectional&quot;, &quot;words(-1,1),order(-2,2),twoTags(-1,1),wordTag(0,-1),wordTag(0,1),biwords(-1,1)&quot;);</span>

<span class="fc" id="L161">    ArrayList&lt;Extractor&gt; extrs = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L162">    List&lt;String&gt; args = StringUtils.valueSplit(arch, &quot;[a-zA-Z0-9]*(?:\\([^)]*\\))?&quot;, &quot;\\s*,\\s*&quot;);</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">    for (String arg : args) {</span>
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">      if (arg.equals(&quot;sighan2005&quot;)) {</span>
<span class="nc" id="L165">        extrs.addAll(Arrays.asList(eFrames_sighan2005));</span>
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">      } else if (arg.equalsIgnoreCase(&quot;german&quot;)) {</span>
<span class="nc" id="L167">        extrs.addAll(Arrays.asList(eFrames_german));</span>
<span class="fc bfc" id="L168" title="All 2 branches covered.">      } else if (arg.startsWith(&quot;words(&quot;)) {</span>
        // non-sequence features with just a certain number of words to the
        // left and right; e.g., words(-2,2) or words(-2,-1)
<span class="fc" id="L171">        int lWindow = Extractor.getParenthesizedNum(arg, 1);</span>
<span class="fc" id="L172">        int rWindow = Extractor.getParenthesizedNum(arg, 2);</span>
<span class="fc bfc" id="L173" title="All 2 branches covered.">        for (int i = lWindow; i &lt;= rWindow; i++) {</span>
<span class="fc" id="L174">          extrs.add(new Extractor(i, false));</span>
        }
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">      } else if (arg.startsWith(&quot;tags(&quot;)) {</span>
        // non-sequence features with just a certain number of words to the
        // left and right; e.g., tags(-2,2) or tags(-2,-1)
<span class="nc" id="L179">        int lWindow = Extractor.getParenthesizedNum(arg, 1);</span>
<span class="nc" id="L180">        int rWindow = Extractor.getParenthesizedNum(arg, 2);</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">        for (int i = lWindow; i &lt;= rWindow; i++) {</span>
<span class="nc" id="L182">          extrs.add(new Extractor(i, true));</span>
        }
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">      } else if (arg.startsWith(&quot;biwords(&quot;)) {</span>
        // non-sequence features of word pairs.
        // biwords(-2,1) would give you 3 extractors for w-2w-1, w-1,w0, w0w1
<span class="nc" id="L187">        int lWindow = Extractor.getParenthesizedNum(arg, 1);</span>
<span class="nc" id="L188">        int rWindow = Extractor.getParenthesizedNum(arg, 2);</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">        for (int i = lWindow; i &lt; rWindow; i++) {</span>
<span class="nc" id="L190">          extrs.add(new ExtractorTwoWords(i));</span>
        }
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">      } else if (arg.startsWith(&quot;biword(&quot;)) {</span>
        // non-sequence feature of a word pair.
        // biwords(-2,1) would give you 1 extractor for w-2, w+1
<span class="nc" id="L195">        int left = Extractor.getParenthesizedNum(arg, 1);</span>
<span class="nc" id="L196">        int right = Extractor.getParenthesizedNum(arg, 2);</span>
<span class="nc" id="L197">        extrs.add(new ExtractorTwoWords(left, right));</span>
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">      } else if (arg.startsWith(&quot;twoTags(&quot;)) {</span>
        // non-sequence feature of a tag pair.
        // twoTags(-2,1) would give you 1 extractor for t-2, t+1
<span class="nc" id="L201">        int left = Extractor.getParenthesizedNum(arg, 1);</span>
<span class="nc" id="L202">        int right = Extractor.getParenthesizedNum(arg, 2);</span>
<span class="nc" id="L203">        extrs.add(new ExtractorTwoTags(left, right));</span>
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">      } else if (arg.startsWith(&quot;lowercasewords(&quot;)) {</span>
        // non-sequence features with just a certain number of lowercase words
        // to the left and right
<span class="nc" id="L207">        int lWindow = Extractor.getParenthesizedNum(arg, 1);</span>
<span class="nc" id="L208">        int rWindow = Extractor.getParenthesizedNum(arg, 2);</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">        for (int i = lWindow; i &lt;= rWindow; i++) {</span>
<span class="nc" id="L210">          extrs.add(new ExtractorWordLowerCase(i));</span>
        }
<span class="pc bpc" id="L212" title="1 of 2 branches missed.">      } else if (arg.startsWith(&quot;order(&quot;)) {</span>
        // anything like order(2), order(-4), order(0,3), or
        // order(-2,1) are okay.
<span class="fc" id="L215">        int leftOrder = Extractor.getParenthesizedNum(arg, 1);</span>
<span class="fc" id="L216">        int rightOrder = Extractor.getParenthesizedNum(arg, 2);</span>
<span class="pc bpc" id="L217" title="1 of 2 branches missed.">        if (leftOrder &gt; 0) { leftOrder = -leftOrder; }</span>
<span class="pc bpc" id="L218" title="1 of 2 branches missed.">	if (rightOrder &lt; 0) { throw new IllegalArgumentException(&quot;Right order must be non-negative, not &quot; + rightOrder); }</span>
        // cdm 2009: We only add successively higher order tag k-grams
        // ending adjacent to t0.  Adding lower order features at a distance
        // appears not to help (Dec 2009). But they can now be added with tags().

<span class="fc bfc" id="L223" title="All 2 branches covered.">        for (int idx = leftOrder ; idx &lt;= rightOrder; idx++) {</span>
<span class="fc bfc" id="L224" title="All 2 branches covered.">          if (idx == 0) {</span>
            // do nothing
<span class="pc bpc" id="L226" title="1 of 4 branches missed.">          } else if (idx == -1 || idx == 1) {</span>
<span class="fc" id="L227">            extrs.add(new Extractor(idx, true));</span>
          } else {
<span class="fc" id="L229">            extrs.add(new ExtractorContinuousTagConjunction(idx));</span>
          }
        }
<span class="pc bnc" id="L232" title="All 2 branches missed.">      } else if (arg.startsWith(&quot;wordTag(&quot;)) {</span>
        // sequence feature of a word and a tag: wordTag(-1,1)
<span class="nc" id="L234">        int posW = Extractor.getParenthesizedNum(arg, 1);</span>
<span class="nc" id="L235">        int posT = Extractor.getParenthesizedNum(arg, 2);</span>
<span class="nc" id="L236">        extrs.add(new ExtractorWordTag(posW, posT));</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">      } else if (arg.startsWith(&quot;wordTwoTags(&quot;)) {</span>
<span class="nc" id="L238">        int word = Extractor.getParenthesizedNum(arg, 1);</span>
<span class="nc" id="L239">        int tag1 = Extractor.getParenthesizedNum(arg, 2);</span>
<span class="nc" id="L240">        int tag2 = Extractor.getParenthesizedNum(arg, 3);</span>
<span class="nc" id="L241">        extrs.add(new ExtractorWordTwoTags(word,tag1,tag2));</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">      } else if (arg.startsWith(&quot;threeTags(&quot;)) {</span>
<span class="nc" id="L243">        int pos1 = Extractor.getParenthesizedNum(arg, 1);</span>
<span class="nc" id="L244">        int pos2 = Extractor.getParenthesizedNum(arg, 2);</span>
<span class="nc" id="L245">        int pos3 = Extractor.getParenthesizedNum(arg, 3);</span>
<span class="nc" id="L246">        extrs.add(new ExtractorThreeTags(pos1,pos2,pos3));</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">      } else if (arg.startsWith(&quot;vbn(&quot;)) {</span>
<span class="nc" id="L248">        int order = Extractor.getParenthesizedNum(arg, 1);</span>
<span class="nc" id="L249">        extrs.add(new ExtractorVerbalVBNZero(order));</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">      } else if (arg.startsWith(&quot;allwordshapes(&quot;)) {</span>
<span class="nc" id="L251">        int lWindow = Extractor.getParenthesizedNum(arg, 1);</span>
<span class="nc" id="L252">        int rWindow = Extractor.getParenthesizedNum(arg, 2);</span>
<span class="nc" id="L253">        String wsc = Extractor.getParenthesizedArg(arg, 3);</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">        if (wsc == null) {</span>
<span class="nc" id="L255">          wsc = &quot;chris2&quot;;</span>
        }
<span class="nc bnc" id="L257" title="All 2 branches missed.">        for (int i = lWindow; i &lt;= rWindow; i++) {</span>
<span class="nc" id="L258">          extrs.add(new ExtractorWordShapeClassifier(i, wsc));</span>
        }
<span class="nc bnc" id="L260" title="All 2 branches missed.">      } else if (arg.startsWith(&quot;allwordshapeconjunction(&quot;)) {</span>
<span class="nc" id="L261">        int lWindow = Extractor.getParenthesizedNum(arg, 1);</span>
<span class="nc" id="L262">        int rWindow = Extractor.getParenthesizedNum(arg, 2);</span>
<span class="nc" id="L263">        String wsc = Extractor.getParenthesizedArg(arg, 3);</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">        if (wsc == null) {</span>
<span class="nc" id="L265">          wsc = &quot;chris2&quot;;</span>
        }
<span class="nc" id="L267">        extrs.add(new ExtractorWordShapeConjunction(lWindow, rWindow, wsc));</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">      } else if (arg.startsWith(&quot;allunicodeshapes(&quot;)) {</span>
<span class="nc" id="L269">        int lWindow = Extractor.getParenthesizedNum(arg, 1);</span>
<span class="nc" id="L270">        int rWindow = Extractor.getParenthesizedNum(arg, 2);</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">        for (int i = lWindow; i &lt;= rWindow; i++) {</span>
<span class="nc" id="L272">          extrs.add(new ExtractorWordShapeClassifier(i, &quot;chris4&quot;));</span>
        }
<span class="nc bnc" id="L274" title="All 2 branches missed.">      } else if (arg.startsWith(&quot;allunicodeshapeconjunction(&quot;)) {</span>
<span class="nc" id="L275">        int lWindow = Extractor.getParenthesizedNum(arg, 1);</span>
<span class="nc" id="L276">        int rWindow = Extractor.getParenthesizedNum(arg, 2);</span>
<span class="nc" id="L277">        extrs.add(new ExtractorWordShapeConjunction(lWindow, rWindow, &quot;chris4&quot;));</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">      } else if (arg.equalsIgnoreCase(&quot;spanishauxiliaries&quot;)) {</span>
<span class="nc" id="L279">        extrs.add(new ExtractorSpanishAuxiliaryTag());</span>
<span class="nc" id="L280">        extrs.add(new ExtractorSpanishSemiauxiliaryTag());</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">      } else if (arg.equalsIgnoreCase(&quot;naacl2003unknowns&quot;) ||</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">                 arg.equalsIgnoreCase(&quot;lnaacl2003unknowns&quot;) ||</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">                 arg.equalsIgnoreCase(&quot;caselessnaacl2003unknowns&quot;) ||</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">                 arg.equalsIgnoreCase(&quot;naacl2003conjunctions&quot;) ||</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">                 arg.equalsIgnoreCase(&quot;frenchunknowns&quot;) ||</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">                 arg.equalsIgnoreCase(&quot;spanishunknowns&quot;) ||</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">                 arg.startsWith(&quot;wordshapes(&quot;) ||</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">                 arg.startsWith(&quot;wordshapeconjunction(&quot;) ||</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">                 arg.equalsIgnoreCase(&quot;motleyUnknown&quot;) ||</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">                 arg.startsWith(&quot;suffix(&quot;) ||</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">                 arg.startsWith(&quot;prefix(&quot;) ||</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">                 arg.startsWith(&quot;prefixsuffix&quot;) ||</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">                 arg.startsWith(&quot;capitalizationsuffix(&quot;) ||</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">                 arg.startsWith(&quot;distsim(&quot;) ||</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">                 arg.startsWith(&quot;distsimconjunction(&quot;) ||</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">                 arg.equalsIgnoreCase(&quot;lctagfeatures&quot;) ||</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">                 arg.startsWith(&quot;unicodeshapes(&quot;) ||</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">                 arg.startsWith(&quot;chinesedictionaryfeatures(&quot;) ||</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">                 arg.startsWith(&quot;unicodeshapeconjunction(&quot;)) {</span>
        // okay; known unknown keyword
      } else {
<span class="nc" id="L302">        log.info(&quot;Unrecognized ExtractorFrames identifier (ignored): &quot; + arg);</span>
      }
<span class="fc" id="L304">    } // end for</span>
<span class="fc" id="L305">    return extrs.toArray(new Extractor[extrs.size()]);</span>
  }


  /**
   * This extractor extracts a word and tag in conjunction.
   */
  static class ExtractorWordTag extends Extractor {

    private static final long serialVersionUID = 3L;

    private final int wordPosition;
    public ExtractorWordTag(int posW, int posT) {
<span class="fc" id="L318">      super(posT, true);</span>
<span class="fc" id="L319">      wordPosition = posW;</span>
<span class="fc" id="L320">    }</span>

    @Override
    String extract(History h, PairsHolder pH) {
<span class="nc" id="L324">      return pH.getTag(h, position) + '!' + pH.getWord(h, wordPosition);</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L329">      return (getClass().getName() + &quot;(w&quot; + wordPosition +</span>
              &quot;,t&quot; + position + ')');
    }
  }


  /**
   * The word in lower-cased version.
   * Always uses Locale.ENGLISH.
   */
  static class ExtractorWordLowerCase extends Extractor {

    private static final long serialVersionUID = -7847524200422095441L;

    public ExtractorWordLowerCase(int position) {
<span class="nc" id="L344">      super(position, false);</span>
<span class="nc" id="L345">    }</span>

    @Override
      String extract(History h, PairsHolder pH) {
<span class="nc" id="L349">      return pH.getWord(h, position).toLowerCase(Locale.ENGLISH);</span>
    }

  }

  /**
   * The current word if it is capitalized, zero otherwise.
   * Always uses Locale.ENGLISH.
   */
<span class="nc" id="L358">  static class ExtractorCWordCapCase extends Extractor {</span>

    private static final long serialVersionUID = -2393096135964969744L;

    @Override
      String extract(History h, PairsHolder pH) {
<span class="nc" id="L364">      String cw = pH.getWord(h, 0);</span>
<span class="nc" id="L365">      String lk = cw.toLowerCase(Locale.ENGLISH);</span>
<span class="nc bnc" id="L366" title="All 2 branches missed.">      if (lk.equals(cw)) {</span>
<span class="nc" id="L367">        return zeroSt;</span>
      }
<span class="nc" id="L369">      return cw;</span>
    }

<span class="nc" id="L372">    @Override public boolean isLocal() { return true; }</span>
<span class="nc" id="L373">    @Override public boolean isDynamic() { return false; }</span>
  }


  /**
   * This extractor extracts two words in conjunction.
   * The one argument constructor gives you leftPosition and
   * leftPosition+1, but with the two argument constructor,
   * they can be any pair of word positions.
   */
  static class ExtractorTwoWords extends Extractor {

    private static final long serialVersionUID = -1034112287022504917L;

    private final int leftPosition;
    private final int rightPosition;

    public ExtractorTwoWords(int leftPosition) {
<span class="nc" id="L391">      this(leftPosition, leftPosition+1);</span>
<span class="nc" id="L392">    }</span>

    public ExtractorTwoWords(int position1, int position2) {
<span class="fc" id="L395">      super(0, false);</span>
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">      if (position1 &gt; position2) {</span>
<span class="nc" id="L397">        leftPosition = position1;</span>
<span class="nc" id="L398">        rightPosition = position2;</span>
      } else {
<span class="fc" id="L400">        leftPosition = position2;</span>
<span class="fc" id="L401">        rightPosition = position1;</span>
      }
<span class="fc" id="L403">    }</span>

    @Override
      String extract(History h, PairsHolder pH) {
      // I ran a bunch of timing tests that seem to indicate it is
      // cheaper to simply add string + char + string than use a
      // StringBuilder or go through the StringBuildMemoizer -horatio
<span class="nc" id="L410">      return pH.getWord(h, leftPosition) + '!' + pH.getWord(h, rightPosition);</span>
    }

<span class="nc" id="L413">    @Override public boolean isLocal() { return false; }</span>

    // isDynamic --&gt; false, but no need to override


    @Override
    public String toString() {
<span class="nc" id="L420">      return (getClass().getName() + &quot;(w&quot; + leftPosition +</span>
              &quot;,w&quot; + rightPosition + ')');
    }
  }



  /**
   * This extractor extracts two tags in conjunction.
   * The one argument constructor gives you leftPosition and
   * leftPosition+1, but with the two argument constructor,
   * they can be any pair of tag positions.
   */
  static class ExtractorTwoTags extends Extractor {

    private static final long serialVersionUID = -7342144764725605134L;

    private final int leftPosition;
    private final int rightPosition;
    private final int leftContext, rightContext;

<span class="nc" id="L441">    public ExtractorTwoTags(int position1, int position2) {</span>
<span class="nc" id="L442">      leftPosition = Math.min(position1, position2);</span>
<span class="nc" id="L443">      rightPosition = Math.max(position1, position2);</span>

<span class="nc" id="L445">      leftContext = -Math.min(leftPosition, 0);</span>
<span class="nc" id="L446">      rightContext = Math.max(rightPosition, 0);</span>
<span class="nc" id="L447">    }</span>

    @Override
    public int rightContext() {
<span class="nc" id="L451">      return rightContext;</span>
    }

    @Override
    public int leftContext() {
<span class="nc" id="L456">      return leftContext;</span>
    }

    @Override
    String extract(History h, PairsHolder pH) {
      // I ran a bunch of timing tests that seem to indicate it is
      // cheaper to simply add string + char + string than use a
      // StringBuilder or go through the StringBuildMemoizer -horatio
<span class="nc" id="L464">      return pH.getTag(h, leftPosition) + '!' + pH.getTag(h, rightPosition);</span>
    }

<span class="nc" id="L467">    @Override public boolean isLocal() { return false; }</span>
<span class="nc" id="L468">    @Override public boolean isDynamic() { return true; }</span>

    @Override
    public String toString() {
<span class="nc" id="L472">      return (getClass().getName() + &quot;(t&quot; + leftPosition +</span>
              &quot;,t&quot; + rightPosition + ')');
    }
  }


  /**
   * This extractor extracts two words and a tag in conjunction.
   */
  static class ExtractorTwoWordsTag extends Extractor {

    private static final long serialVersionUID = 277004119652781188L;

    private final int leftWord, rightWord, tag;
    private final int rightContext, leftContext;

<span class="nc" id="L488">    public ExtractorTwoWordsTag(int leftWord, int rightWord, int tag) {</span>
<span class="nc" id="L489">      this.leftWord = Math.min(leftWord, rightWord);</span>
<span class="nc" id="L490">      this.rightWord = Math.max(leftWord, rightWord);</span>
<span class="nc" id="L491">      this.tag = tag;</span>

<span class="nc" id="L493">      this.rightContext = Math.max(tag, 0);</span>
<span class="nc" id="L494">      this.leftContext = -Math.min(tag, 0);</span>
<span class="nc" id="L495">    }</span>

    @Override
    public int rightContext() {
<span class="nc" id="L499">      return rightContext;</span>
    }

    @Override
    public int leftContext() {
<span class="nc" id="L504">      return leftContext;</span>
    }

    @Override
      String extract(History h, PairsHolder pH) {
<span class="nc" id="L509">      return (pH.getWord(h, leftWord) + '!' + pH.getTag(h, tag) + '!' +</span>
<span class="nc" id="L510">              pH.getWord(h, rightWord));</span>
    }

<span class="nc" id="L513">    @Override public boolean isLocal() { return false; }</span>
<span class="nc" id="L514">    @Override public boolean isDynamic() { return true; }</span>

    @Override
    public String toString() {
<span class="nc" id="L518">      return (getClass().getName() + &quot;(w&quot; + leftWord +</span>
              &quot;,t&quot; + tag + &quot;,w&quot; + rightWord + ')');
    }
  }



  /**
   * This extractor extracts several contiguous tags only on one side of position 0.
   * E.g., use constructor argument -3 for an order 3 predictor on the left.
   * isLocal=false, isDynamic=true (through super call)
   */
  static class ExtractorContinuousTagConjunction extends Extractor {

    private static final long serialVersionUID = 3;

    public ExtractorContinuousTagConjunction(int maxPosition) {
<span class="fc" id="L535">      super(maxPosition, true);</span>
<span class="fc" id="L536">    }</span>

    @Override
    String extract(History h, PairsHolder pH) {
<span class="fc" id="L540">      StringBuilder sb = new StringBuilder();</span>
<span class="pc bpc" id="L541" title="1 of 2 branches missed.">      if (position &lt; 0) {</span>
<span class="fc bfc" id="L542" title="All 2 branches covered.">        for (int idx = position; idx &lt; 0; idx++) {</span>
<span class="fc bfc" id="L543" title="All 2 branches covered.">          if (idx != position) {</span>
<span class="fc" id="L544">            sb.append('!');</span>
          }
<span class="fc" id="L546">          sb.append(pH.getTag(h, idx));</span>
        }
      } else {
<span class="nc bnc" id="L549" title="All 2 branches missed.">        for (int idx = position; idx &gt; 0; idx--) {</span>
<span class="nc bnc" id="L550" title="All 2 branches missed.">          if (idx != position) {</span>
<span class="nc" id="L551">            sb.append('!');</span>
          }
<span class="nc" id="L553">          sb.append(pH.getTag(h, idx));</span>
        }
      }
<span class="fc" id="L556">      return sb.toString();</span>
    }

  }


  /**
   * This extractor extracts three tags.
   */
  static class ExtractorThreeTags extends Extractor {

    private static final long serialVersionUID = 8563584394721620568L;

    private int position1;
    private int position2;
    private int position3;

<span class="nc" id="L573">    public ExtractorThreeTags(int position1, int position2, int position3) {</span>
      // bubblesort them!
      int x;
<span class="nc bnc" id="L576" title="All 2 branches missed.">      if (position1 &gt; position2) {</span>
<span class="nc" id="L577">        x = position2;</span>
<span class="nc" id="L578">        position2 = position1;</span>
<span class="nc" id="L579">        position1 = x;</span>
      }
<span class="nc bnc" id="L581" title="All 2 branches missed.">      if (position2 &gt; position3) {</span>
<span class="nc" id="L582">        x = position3;</span>
<span class="nc" id="L583">        position3 = position2;</span>
<span class="nc" id="L584">        position2 = x;</span>
      }
<span class="nc bnc" id="L586" title="All 2 branches missed.">      if (position1 &gt; position2) {</span>
<span class="nc" id="L587">        x = position2;</span>
<span class="nc" id="L588">        position2 = position1;</span>
<span class="nc" id="L589">        position1 = x;</span>
      }
<span class="nc" id="L591">      this.position1 = position1;</span>
<span class="nc" id="L592">      this.position2 = position2;</span>
<span class="nc" id="L593">      this.position3 = position3;</span>
<span class="nc" id="L594">    }</span>

    @Override
      public int rightContext() {
<span class="nc bnc" id="L598" title="All 2 branches missed.">      if (position3 &gt; 0) {</span>
<span class="nc" id="L599">        return position3;</span>
      } else {
<span class="nc" id="L601">        return 0;</span>
      }
    }

    @Override
      public int leftContext() {
<span class="nc bnc" id="L607" title="All 2 branches missed.">      if (position1 &lt; 0) {</span>
<span class="nc" id="L608">        return -position1;</span>
      } else {
<span class="nc" id="L610">        return 0;</span>
      }
    }

    @Override
      String extract(History h, PairsHolder pH) {
<span class="nc" id="L616">      return pH.getTag(h, position1) + '!' + pH.getTag(h, position2) + '!' + pH.getTag(h, position3);</span>
    }

<span class="nc" id="L619">    @Override public boolean isLocal() { return false; }</span>
<span class="nc" id="L620">    @Override public boolean isDynamic() { return true; }</span>

    @Override
    public String toString() {
<span class="nc" id="L624">      return (getClass().getName() + &quot;(t&quot; + position1 +</span>
              &quot;,t&quot; + position2 + &quot;,t&quot; + position3 + ')');
    }
  }


  /**
   * This extractor extracts two tags and the a word in conjunction.
   */
  static class ExtractorWordTwoTags extends Extractor {

    private static final long serialVersionUID = -4942654091455804176L;

    // We sort so that position1 &lt;= position2 and then rely on that.
    private int position1;
    private int position2;
    private int word;

<span class="nc" id="L642">    public ExtractorWordTwoTags(int word, int position1, int position2) {</span>
<span class="nc bnc" id="L643" title="All 2 branches missed.">      if (position1 &lt; position2) {</span>
<span class="nc" id="L644">        this.position1 = position1;</span>
<span class="nc" id="L645">        this.position2 = position1;</span>
      } else {
<span class="nc" id="L647">        this.position1 = position2;</span>
<span class="nc" id="L648">        this.position2 = position1;</span>
      }
<span class="nc" id="L650">      this.word = word;</span>
<span class="nc" id="L651">    }</span>

    @Override
      public int leftContext() {
<span class="nc bnc" id="L655" title="All 2 branches missed.">      if (position1 &lt; 0) {</span>
<span class="nc" id="L656">        return  -position1;</span>
      } else {
<span class="nc" id="L658">        return 0;</span>
      }
    }

    @Override
      public int rightContext() {
<span class="nc bnc" id="L664" title="All 2 branches missed.">      if (position2 &gt; 0) {</span>
<span class="nc" id="L665">        return position2;</span>
      } else {
<span class="nc" id="L667">        return 0;</span>
      }
    }

    @Override
      String extract(History h, PairsHolder pH) {
<span class="nc" id="L673">      return pH.getTag(h, position1) + '!' + pH.getWord(h, word) + '!' + pH.getTag(h, position2);</span>
    }

<span class="nc" id="L676">    @Override public boolean isLocal() { return false; }</span>
<span class="nc" id="L677">    @Override public boolean isDynamic() { return true; }</span>

    @Override
    public String toString() {
<span class="nc" id="L681">      return (getClass().getName() + &quot;(t&quot; + position1 +</span>
              &quot;,t&quot; + position2 + &quot;,w&quot; + word + ')');
    }
  }


} // end class ExtractorFrames


class ExtractorWordShapeClassifier extends Extractor {

  private final int wordShaper;
  private final String name;

  // This cache speeds things up a little bit.  I used
  // -Xrunhprof:cpu=samples,interval=1 when using the &quot;distsim&quot; tagger
  // on the training set to measure roughly how much time was spent in
  // this method.  I concluded that with the cache, 1.24% of the time
  // is spent here, and without the cache, 1.26% of the time is spent
  // here.  This is a very small savings, which would be even smaller
  // if we make the cache thread safe.  It turns out that, as written,
  // the cache is not thread safe for various reasons.  In particular,
  // it assumes only one wordshape classifier is ever used, which
  // might not be true even with just one tagger, and has an even
  // higher chance of not being true if there are multiple taggers.
  // Furthermore, access to the cache should really be synchronized
  // regardless.  The easiest solution is to comment out the cache and
  // note that if you want to bring it back, make it a map from wsc to
  // cache rather than just a single cache.  -- horatio
  //private static final Map&lt;String, String&gt; shapes =
  //  Generics.newHashMap();
  // --- should be:
  //private static final Map&lt;String, Map&lt;String, String&gt;&gt; ...

  ExtractorWordShapeClassifier(int position, String wsc) {
<span class="nc" id="L716">    super(position, false);</span>
<span class="nc" id="L717">    wordShaper = WordShapeClassifier.lookupShaper(wsc);</span>
<span class="nc" id="L718">    name = &quot;ExtractorWordShapeClassifier(&quot; + position+ ',' + wsc + ')';</span>
<span class="nc" id="L719">  }</span>

  @Override
  String extract(History h, PairsHolder pH) {
<span class="nc" id="L723">    String s = super.extract(h, pH);</span>
<span class="nc" id="L724">    String shape = WordShapeClassifier.wordShape(s, wordShaper);</span>
<span class="nc" id="L725">    return shape;</span>
  }

  private static final long serialVersionUID = 101L;

  @Override
  public String toString() {
<span class="nc" id="L732">    return name;</span>
  }

<span class="nc bnc" id="L735" title="All 2 branches missed.">  @Override public boolean isLocal() { return position == 0; }</span>
<span class="nc" id="L736">  @Override public boolean isDynamic() { return false; }</span>
}


/**
 * This extractor extracts a conjunction of word shapes.
 */
class ExtractorWordShapeConjunction extends Extractor {

  private static final long serialVersionUID = -49L;

  private final int wordShaper;
  private final int left;
  private final int right;
  private final String name;

  ExtractorWordShapeConjunction(int left, int right, String wsc) {
<span class="nc" id="L753">    super();</span>
<span class="nc" id="L754">    this.left = left;</span>
<span class="nc" id="L755">    this.right = right;</span>
<span class="nc" id="L756">    wordShaper = WordShapeClassifier.lookupShaper(wsc);</span>
<span class="nc" id="L757">    name = &quot;ExtractorWordShapeConjunction(&quot; + left + ',' + right + ',' + wsc + ')';</span>
<span class="nc" id="L758">  }</span>

  @Override
  String extract(History h, PairsHolder pH) {
<span class="nc" id="L762">    StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L763" title="All 2 branches missed.">    for (int j = left; j &lt;= right; j++) {</span>
<span class="nc" id="L764">      String s = pH.getWord(h, j);</span>
<span class="nc" id="L765">      sb.append(WordShapeClassifier.wordShape(s, wordShaper));</span>
<span class="nc bnc" id="L766" title="All 2 branches missed.">      if (j &lt; right) {</span>
<span class="nc" id="L767">        sb.append('|');</span>
      }
    }
<span class="nc" id="L770">    return sb.toString();</span>
  }

  @Override
  public String toString() {
<span class="nc" id="L775">    return name;</span>
  }

<span class="nc" id="L778">  @Override public boolean isLocal() { return false; }</span>
<span class="nc" id="L779">  @Override public boolean isDynamic() { return false; }</span>

}


/**
 * Extracts a boolean indicating whether the given word is preceded by
 * an auxiliary verb.
 */
class ExtractorSpanishAuxiliaryTag extends Extractor {

  private static final long serialVersionUID = -3352770856914897103L;

  public ExtractorSpanishAuxiliaryTag() {
<span class="nc" id="L793">    super(-1, true);</span>
<span class="nc" id="L794">  }</span>

  @Override
  String extract(History h, PairsHolder pH) {
<span class="nc" id="L798">    String tag = super.extract(h, pH);</span>
<span class="nc bnc" id="L799" title="All 4 branches missed.">    boolean isAux = tag.length() &gt;= 2 &amp;&amp; tag.substring(0, 2).equals(&quot;va&quot;);</span>

<span class="nc bnc" id="L801" title="All 2 branches missed.">    return isAux ? &quot;1&quot; : &quot;0&quot;;</span>
  }

  @Override
  public String toString() {
<span class="nc" id="L806">    return &quot;ExtractorSpanishAuxiliaryTag&quot;;</span>
  }

}


/**
 * Extracts a boolean indicating whether the given word is preceded by
 * a semi-auxiliary verb.
 */
class ExtractorSpanishSemiauxiliaryTag extends Extractor {

  private static final long serialVersionUID = -164942945521643734L;

  public ExtractorSpanishSemiauxiliaryTag() {
<span class="nc" id="L821">    super(-1, true);</span>
<span class="nc" id="L822">  }</span>

  @Override
  String extract(History h, PairsHolder pH) {
<span class="nc" id="L826">    String tag = super.extract(h, pH);</span>
<span class="nc bnc" id="L827" title="All 4 branches missed.">    boolean isSemiAux = tag.length() &gt;= 2 &amp;&amp; tag.substring(0, 2).equals(&quot;vs&quot;);</span>

<span class="nc bnc" id="L829" title="All 2 branches missed.">    return isSemiAux ? &quot;1&quot; : &quot;0&quot;;</span>
  }

  @Override
  public String toString() {
<span class="nc" id="L834">    return &quot;ExtractorSpanishSemiauxiliaryTag&quot;;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>