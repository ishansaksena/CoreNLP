<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IOUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.io</a> &gt; <span class="el_source">IOUtils.java</span></div><h1>IOUtils.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.io;

import edu.stanford.nlp.util.*;
import edu.stanford.nlp.util.logging.Redwood;

import java.io.*;
import java.lang.reflect.InvocationTargetException;
import java.net.InetAddress;
import java.net.SocketTimeoutException;
import java.net.URL;
import java.net.URLConnection;
import java.nio.channels.FileChannel;
import java.util.*;
import java.util.function.Consumer;
import java.util.regex.Pattern;
import java.util.zip.GZIPInputStream;
import java.util.zip.GZIPOutputStream;


/**
 * Helper Class for various I/O related things.
 *
 * @author Kayur Patel
 * @author Teg Grenager
 * @author Christopher Manning
 */

<span class="pc bpc" id="L28" title="1 of 2 branches missed.">public class IOUtils  {</span>

  private static final int SLURP_BUFFER_SIZE = 16384;

<span class="fc" id="L32">  public static final String eolChar = System.lineSeparator();  // todo: Inline</span>
  public static final String defaultEncoding = &quot;utf-8&quot;;

  /** A logger for this class */
<span class="fc" id="L36">  private static final Redwood.RedwoodChannels logger = Redwood.channels(IOUtils.class);</span>

  // A class of static methods
<span class="nc" id="L39">  private IOUtils() { }</span>

  /**
   * Write object to a file with the specified name.  The file is silently gzipped if the filename ends with .gz.
   *
   * @param o Object to be written to file
   * @param filename Name of the temp file
   * @throws IOException If can't write file.
   * @return File containing the object
   */
  public static File writeObjectToFile(Object o, String filename)
          throws IOException {
<span class="nc" id="L51">    return writeObjectToFile(o, new File(filename));</span>
  }

  /**
   * Write an object to a specified File.  The file is silently gzipped if the filename ends with .gz.
   *
   * @param o Object to be written to file
   * @param file The temp File
   * @throws IOException If File cannot be written
   * @return File containing the object
   */
  public static File writeObjectToFile(Object o, File file) throws IOException {
<span class="fc" id="L63">    return writeObjectToFile(o, file, false);</span>
  }

  /**
   * Write an object to a specified File. The file is silently gzipped if the filename ends with .gz.
   *
   * @param o Object to be written to file
   * @param file The temp File
   * @param append If true, append to this file instead of overwriting it
   * @throws IOException If File cannot be written
   * @return File containing the object
   */
  public static File writeObjectToFile(Object o, File file, boolean append) throws IOException {
    // file.createNewFile(); // cdm may 2005: does nothing needed
<span class="fc" id="L77">    OutputStream os = new FileOutputStream(file, append);</span>
<span class="pc bpc" id="L78" title="1 of 2 branches missed.">    if (file.getName().endsWith(&quot;.gz&quot;)) {</span>
<span class="nc" id="L79">      os = new GZIPOutputStream(os);</span>
    }
<span class="fc" id="L81">    os = new BufferedOutputStream(os);</span>
<span class="fc" id="L82">    ObjectOutputStream oos = new ObjectOutputStream(os);</span>
<span class="fc" id="L83">    oos.writeObject(o);</span>
<span class="fc" id="L84">    oos.close();</span>
<span class="fc" id="L85">    return file;</span>
  }

  /**
   * Write object to a file with the specified name.
   *
   * @param o Object to be written to file
   * @param filename Name of the temp file
   * @return File containing the object, or null if an exception was caught
   */
  public static File writeObjectToFileNoExceptions(Object o, String filename) {
<span class="nc" id="L96">    File file = null;</span>
<span class="nc" id="L97">    ObjectOutputStream oos = null;</span>
    try {
<span class="nc" id="L99">      file = new File(filename);</span>
      // file.createNewFile(); // cdm may 2005: does nothing needed
<span class="nc" id="L101">      oos = new ObjectOutputStream(new BufferedOutputStream(</span>
              new GZIPOutputStream(new FileOutputStream(file))));
<span class="nc" id="L103">      oos.writeObject(o);</span>
<span class="nc" id="L104">      oos.close();</span>
<span class="nc" id="L105">    } catch (Exception e) {</span>
<span class="nc" id="L106">      logger.err(throwableToStackTrace(e));</span>
    } finally {
<span class="nc" id="L108">      closeIgnoringExceptions(oos);</span>
<span class="nc" id="L109">    }</span>
<span class="nc" id="L110">    return file;</span>
  }

  /**
   * Write object to temp file which is destroyed when the program exits.
   *
   * @param o Object to be written to file
   * @param filename Name of the temp file
   * @throws IOException If file cannot be written
   * @return File containing the object
   */
  public static File writeObjectToTempFile(Object o, String filename)
          throws IOException {
<span class="nc" id="L123">    File file = File.createTempFile(filename, &quot;.tmp&quot;);</span>
<span class="nc" id="L124">    file.deleteOnExit();</span>
<span class="nc" id="L125">    writeObjectToFile(o, file);</span>
<span class="nc" id="L126">    return file;</span>
  }

  /**
   * Write object to a temp file and ignore exceptions.
   *
   * @param o Object to be written to file
   * @param filename Name of the temp file
   * @return File containing the object
   */
  public static File writeObjectToTempFileNoExceptions(Object o, String filename) {
    try {
<span class="nc" id="L138">      return writeObjectToTempFile(o, filename);</span>
<span class="nc" id="L139">    } catch (Exception e) {</span>
<span class="nc" id="L140">      logger.error(&quot;Error writing object to file &quot; + filename);</span>
<span class="nc" id="L141">      logger.err(throwableToStackTrace(e));</span>
<span class="nc" id="L142">      return null;</span>
    }
  }

  private static OutputStream getBufferedOutputStream(String path) throws IOException {
<span class="fc" id="L147">    OutputStream os = new BufferedOutputStream(new FileOutputStream(path));</span>
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">    if (path.endsWith(&quot;.gz&quot;)) {</span>
<span class="nc" id="L149">      os = new GZIPOutputStream(os);</span>
    }
<span class="fc" id="L151">    return os;</span>
  }

  //++ todo [cdm, Aug 2012]: Do we need the below methods? They're kind of weird in unnecessarily bypassing using a Writer.

  /**
   * Writes a string to a file.
   *
   * @param contents The string to write
   * @param path The file path
   * @param encoding The encoding to encode in
   * @throws IOException In case of failure
   */
  public static void writeStringToFile(String contents, String path, String encoding) throws IOException {
<span class="fc" id="L165">    OutputStream writer = getBufferedOutputStream(path);</span>
<span class="fc" id="L166">    writer.write(contents.getBytes(encoding));</span>
<span class="fc" id="L167">    writer.close();</span>
<span class="fc" id="L168">  }</span>

  /**
   * Writes a string to a file, squashing exceptions
   *
   * @param contents The string to write
   * @param path The file path
   * @param encoding The encoding to encode in
   * */
  public static void writeStringToFileNoExceptions(String contents, String path, String encoding) {
<span class="nc" id="L178">    OutputStream writer = null;</span>
    try{
<span class="nc bnc" id="L180" title="All 2 branches missed.">      if (path.endsWith(&quot;.gz&quot;)) {</span>
<span class="nc" id="L181">        writer = new GZIPOutputStream(new FileOutputStream(path));</span>
      } else {
<span class="nc" id="L183">        writer = new BufferedOutputStream(new FileOutputStream(path));</span>
      }
<span class="nc" id="L185">      writer.write(contents.getBytes(encoding));</span>
<span class="nc" id="L186">    } catch (Exception e) {</span>
<span class="nc" id="L187">      logger.err(throwableToStackTrace(e));</span>
    } finally {
<span class="nc" id="L189">      closeIgnoringExceptions(writer);</span>
<span class="nc" id="L190">    }</span>
<span class="nc" id="L191">  }</span>

  /**
   * Writes a string to a temporary file
   *
   * @param contents The string to write
   * @param path The file path
   * @param encoding The encoding to encode in
   * @throws IOException In case of failure
   * @return The File written to
   */
  public static File writeStringToTempFile(String contents, String path, String encoding) throws IOException {
    OutputStream writer;
<span class="nc" id="L204">    File tmp = File.createTempFile(path,&quot;.tmp&quot;);</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">    if (path.endsWith(&quot;.gz&quot;)) {</span>
<span class="nc" id="L206">      writer = new GZIPOutputStream(new FileOutputStream(tmp));</span>
    } else {
<span class="nc" id="L208">      writer = new BufferedOutputStream(new FileOutputStream(tmp));</span>
    }
<span class="nc" id="L210">    writer.write(contents.getBytes(encoding));</span>
<span class="nc" id="L211">    return tmp;</span>
  }

  /**
   * Writes a string to a temporary file, as UTF-8
   *
   * @param contents The string to write
   * @param path The file path
   * @throws IOException In case of failure
   */
  public static void writeStringToTempFile(String contents, String path) throws IOException {
<span class="nc" id="L222">    writeStringToTempFile(contents, path, &quot;UTF-8&quot;);</span>
<span class="nc" id="L223">  }</span>

  /**
   * Writes a string to a temporary file, squashing exceptions
   *
   * @param contents The string to write
   * @param path The file path
   * @param encoding The encoding to encode in
   * @return The File that was written to
   */
  public static File writeStringToTempFileNoExceptions(String contents, String path, String encoding) {
<span class="nc" id="L234">    OutputStream writer = null;</span>
<span class="nc" id="L235">    File tmp = null;</span>
    try {
<span class="nc" id="L237">      tmp = File.createTempFile(path,&quot;.tmp&quot;);</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">      if (path.endsWith(&quot;.gz&quot;)) {</span>
<span class="nc" id="L239">        writer = new GZIPOutputStream(new FileOutputStream(tmp));</span>
      } else {
<span class="nc" id="L241">        writer = new BufferedOutputStream(new FileOutputStream(tmp));</span>
      }
<span class="nc" id="L243">      writer.write(contents.getBytes(encoding));</span>
<span class="nc" id="L244">    } catch (Exception e) {</span>
<span class="nc" id="L245">      logger.err(throwableToStackTrace(e));</span>
    } finally {
<span class="nc" id="L247">      closeIgnoringExceptions(writer);</span>
<span class="nc" id="L248">    }</span>
<span class="nc" id="L249">    return tmp;</span>
  }

  /**
   * Writes a string to a temporary file with UTF-8 encoding, squashing exceptions
   *
   * @param contents The string to write
   * @param path The file path
   */
  public static void writeStringToTempFileNoExceptions(String contents, String path) {
<span class="nc" id="L259">    writeStringToTempFileNoExceptions(contents, path, &quot;UTF-8&quot;);</span>
<span class="nc" id="L260">  }</span>

  //-- todo [cdm, Aug 2012]: Do we need the below methods? They're kind of weird in unnecessarily bypassing using a Writer.


  // todo [cdm, Sep 2013]: Can we remove this next method and its friends? (Weird in silently gzipping, overlaps other functionality.)
  /**
   * Read an object from a stored file. It is silently ungzipped, regardless of name.
   *
   * @param file The file pointing to the object to be retrieved
   * @throws IOException If file cannot be read
   * @throws ClassNotFoundException If reading serialized object fails
   * @return The object read from the file.
   */
  public static &lt;T&gt; T readObjectFromFile(File file) throws IOException,
      ClassNotFoundException {
    try {
<span class="nc" id="L277">      ObjectInputStream ois = new ObjectInputStream(new BufferedInputStream(</span>
          new GZIPInputStream(new FileInputStream(file))));
<span class="nc" id="L279">      Object o = ois.readObject();</span>
<span class="nc" id="L280">      ois.close();</span>
<span class="nc" id="L281">      return ErasureUtils.uncheckedCast(o);</span>
<span class="fc" id="L282">    } catch (java.util.zip.ZipException e) {</span>
<span class="fc" id="L283">      ObjectInputStream ois = new ObjectInputStream(new BufferedInputStream(</span>
          new FileInputStream(file)));
<span class="fc" id="L285">      Object o = ois.readObject();</span>
<span class="fc" id="L286">      ois.close();</span>
<span class="fc" id="L287">      return ErasureUtils.uncheckedCast(o);</span>
    }
  }

  public static DataInputStream getDataInputStream(String filenameUrlOrClassPath) throws IOException {
<span class="fc" id="L292">    return new DataInputStream(getInputStreamFromURLOrClasspathOrFileSystem(filenameUrlOrClassPath));</span>
  }

  public static DataOutputStream getDataOutputStream(String filename) throws IOException {
<span class="fc" id="L296">    return new DataOutputStream(getBufferedOutputStream((filename)));</span>
  }

  /**
   * Read an object from a stored file.  The file can be anything obtained
   * via a URL, the filesystem, or the classpath (eg in a jar file).
   *
   * @param filename The file pointing to the object to be retrieved
   * @throws IOException If file cannot be read
   * @throws ClassNotFoundException If reading serialized object fails
   * @return The object read from the file.
   */
  public static &lt;T&gt; T readObjectFromURLOrClasspathOrFileSystem(String filename) throws IOException, ClassNotFoundException {
<span class="nc" id="L309">    ObjectInputStream ois = new ObjectInputStream(getInputStreamFromURLOrClasspathOrFileSystem(filename));</span>
<span class="nc" id="L310">    Object o = ois.readObject();</span>
<span class="nc" id="L311">    ois.close();</span>
<span class="nc" id="L312">    return ErasureUtils.uncheckedCast(o);</span>
  }

  public static &lt;T&gt; T readObjectAnnouncingTimingFromURLOrClasspathOrFileSystem(Redwood.RedwoodChannels log, String msg, String path) {
    T obj;
    try {
<span class="nc" id="L318">      Timing timing = new Timing();</span>
<span class="nc" id="L319">      obj = IOUtils.readObjectFromURLOrClasspathOrFileSystem(path);</span>
<span class="nc" id="L320">      log.info(msg + ' ' + path + &quot; ... done [&quot; + timing.toSecondsString() + &quot; sec].&quot;);</span>
<span class="nc" id="L321">    } catch (IOException | ClassNotFoundException e) {</span>
<span class="nc" id="L322">      throw new RuntimeIOException(e);</span>
<span class="nc" id="L323">    }</span>
<span class="nc" id="L324">    return obj;</span>
  }

  public static &lt;T&gt; T readObjectFromObjectStream(ObjectInputStream ois) throws IOException,
          ClassNotFoundException {
<span class="fc" id="L329">    Object o = ois.readObject();</span>
<span class="fc" id="L330">    return ErasureUtils.uncheckedCast(o);</span>
  }

  /**
   * Read an object from a stored file.
   *
   * @param filename The filename of the object to be retrieved
   * @throws IOException If file cannot be read
   * @throws ClassNotFoundException If reading serialized object fails
   * @return The object read from the file.
   */
  public static &lt;T&gt; T readObjectFromFile(String filename) throws IOException,
          ClassNotFoundException {
<span class="nc" id="L343">    return ErasureUtils.uncheckedCast(readObjectFromFile(new File(filename)));</span>
  }

  /**
   * Read an object from a stored file without throwing exceptions.
   *
   * @param file The file pointing to the object to be retrieved
   * @return The object read from the file, or null if an exception occurred.
   */
  public static &lt;T&gt; T readObjectFromFileNoExceptions(File file) {
<span class="nc" id="L353">    Object o = null;</span>
    try {
<span class="nc" id="L355">      ObjectInputStream ois = new ObjectInputStream(new BufferedInputStream(</span>
              new GZIPInputStream(new FileInputStream(file))));
<span class="nc" id="L357">      o = ois.readObject();</span>
<span class="nc" id="L358">      ois.close();</span>
<span class="nc" id="L359">    } catch (IOException | ClassNotFoundException e) {</span>
<span class="nc" id="L360">      logger.err(throwableToStackTrace(e));</span>
<span class="nc" id="L361">    }</span>
<span class="nc" id="L362">    return ErasureUtils.uncheckedCast(o);</span>
  }

  public static int lineCount(String textFileOrUrl) throws IOException {
<span class="nc" id="L366">    BufferedReader r = readerFromString(textFileOrUrl);</span>
<span class="nc" id="L367">    int numLines = 0;</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">    while (r.readLine() != null) {</span>
<span class="nc" id="L369">      numLines++;</span>
    }
<span class="nc" id="L371">    return numLines;</span>
  }

  public static ObjectOutputStream writeStreamFromString(String serializePath)
          throws IOException {
    ObjectOutputStream oos;
<span class="pc bpc" id="L377" title="1 of 2 branches missed.">    if (serializePath.endsWith(&quot;.gz&quot;)) {</span>
<span class="nc" id="L378">      oos = new ObjectOutputStream(new BufferedOutputStream(</span>
              new GZIPOutputStream(new FileOutputStream(serializePath))));
    } else {
<span class="fc" id="L381">      oos = new ObjectOutputStream(new BufferedOutputStream(</span>
              new FileOutputStream(serializePath)));
    }

<span class="fc" id="L385">    return oos;</span>
  }

  /**
   * Returns an ObjectInputStream reading from any of a URL, a CLASSPATH resource, or a file.
   * The CLASSPATH takes priority over the file system.
   * This stream is buffered and, if necessary, gunzipped.
   *
   * @param filenameOrUrl The String specifying the URL/resource/file to load
   * @return An ObjectInputStream for loading a resource
   * @throws RuntimeIOException On any IO error
   * @throws NullPointerException Input parameter is null
   */
  public static ObjectInputStream readStreamFromString(String filenameOrUrl)
          throws IOException {
<span class="fc" id="L400">    InputStream is = getInputStreamFromURLOrClasspathOrFileSystem(filenameOrUrl);</span>
<span class="fc" id="L401">    return new ObjectInputStream(is);</span>
  }

  /**
   * Locates this file either in the CLASSPATH or in the file system. The CLASSPATH takes priority.
   * Note that this method uses the ClassLoader methods, so that classpath resources must be specified as
   * absolute resource paths without a leading &quot;/&quot;.
   *
   * @param name The file or resource name
   * @throws FileNotFoundException If the file does not exist
   * @return The InputStream of name, or null if not found
   */
  private static InputStream findStreamInClasspathOrFileSystem(String name) throws FileNotFoundException {
    // ms 10-04-2010:
    // - even though this may look like a regular file, it may be a path inside a jar in the CLASSPATH
    // - check for this first. This takes precedence over the file system.
<span class="fc" id="L417">    InputStream is = IOUtils.class.getClassLoader().getResourceAsStream(name);</span>
    // windows File.separator is \, but getting resources only works with /
<span class="pc bpc" id="L419" title="1 of 2 branches missed.">    if (is == null) {</span>
<span class="fc" id="L420">      is = IOUtils.class.getClassLoader().getResourceAsStream(name.replaceAll(&quot;\\\\&quot;, &quot;/&quot;));</span>
      // Classpath doesn't like double slashes (e.g., /home/user//foo.txt)
<span class="pc bpc" id="L422" title="1 of 2 branches missed.">      if (is == null) {</span>
<span class="fc" id="L423">        is = IOUtils.class.getClassLoader().getResourceAsStream(name.replaceAll(&quot;\\\\&quot;, &quot;/&quot;).replaceAll(&quot;/+&quot;, &quot;/&quot;));</span>
      }
    }
    // if not found in the CLASSPATH, load from the file system
<span class="pc bpc" id="L427" title="1 of 2 branches missed.">    if (is == null) {</span>
<span class="fc" id="L428">      is = new FileInputStream(name);</span>
    }
<span class="fc" id="L430">    return is;</span>
  }

  /**
   * Check if this path exists either in the classpath or on the filesystem.
   *
   * @param name The file or resource name.
   * @return true if a call to {@link IOUtils#getBufferedReaderFromClasspathOrFileSystem(String)} would return a valid stream.
   */
  public static boolean existsInClasspathOrFileSystem(String name) {
<span class="nc" id="L440">    InputStream is = IOUtils.class.getClassLoader().getResourceAsStream(name);</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">    if (is == null) {</span>
<span class="nc" id="L442">      is = IOUtils.class.getClassLoader().getResourceAsStream(name.replaceAll(&quot;\\\\&quot;, &quot;/&quot;));</span>
<span class="nc bnc" id="L443" title="All 2 branches missed.">      if (is == null) {</span>
<span class="nc" id="L444">        is = IOUtils.class.getClassLoader().getResourceAsStream(name.replaceAll(&quot;\\\\&quot;, &quot;/&quot;).replaceAll(&quot;/+&quot;, &quot;/&quot;));</span>
      }
    }
<span class="nc bnc" id="L447" title="All 4 branches missed.">    return is != null || new File(name).exists();</span>
  }

  /**
   * Locates this file either using the given URL, or in the CLASSPATH, or in the file system
   * The CLASSPATH takes priority over the file system!
   * This stream is buffered and gunzipped (if necessary).
   *
   * @param textFileOrUrl The String specifying the URL/resource/file to load
   * @return An InputStream for loading a resource
   * @throws IOException On any IO error
   * @throws NullPointerException Input parameter is null
   */
  public static InputStream getInputStreamFromURLOrClasspathOrFileSystem(String textFileOrUrl)
          throws IOException, NullPointerException {
    InputStream in;
<span class="pc bpc" id="L463" title="1 of 2 branches missed.">    if (textFileOrUrl == null) {</span>
<span class="nc" id="L464">      throw new NullPointerException(&quot;Attempt to open file with null name&quot;);</span>
<span class="pc bpc" id="L465" title="1 of 2 branches missed.">    } else if (textFileOrUrl.matches(&quot;https?://.*&quot;)) {</span>
<span class="nc" id="L466">      URL u = new URL(textFileOrUrl);</span>
<span class="nc" id="L467">      URLConnection uc = u.openConnection();</span>
<span class="nc" id="L468">      in = uc.getInputStream();</span>
<span class="nc" id="L469">    } else {</span>
      try {
<span class="fc" id="L471">        in = findStreamInClasspathOrFileSystem(textFileOrUrl);</span>
<span class="nc" id="L472">      } catch (FileNotFoundException e) {</span>
        try {
          // Maybe this happens to be some other format of URL?
<span class="nc" id="L475">          URL u = new URL(textFileOrUrl);</span>
<span class="nc" id="L476">          URLConnection uc = u.openConnection();</span>
<span class="nc" id="L477">          in = uc.getInputStream();</span>
<span class="nc" id="L478">        } catch (IOException e2) {</span>
          // Don't make the original exception a cause, since it is usually bogus
<span class="nc" id="L480">          throw new IOException(&quot;Unable to open \&quot;&quot; +</span>
                  textFileOrUrl + &quot;\&quot; as &quot; + &quot;class path, filename or URL&quot;); // , e2);
<span class="nc" id="L482">        }</span>
<span class="fc" id="L483">      }</span>
    }

    // If it is a GZIP stream then ungzip it
<span class="fc bfc" id="L487" title="All 2 branches covered.">    if (textFileOrUrl.endsWith(&quot;.gz&quot;)) {</span>
      try {
<span class="fc" id="L489">        in = new GZIPInputStream(in);</span>
<span class="nc" id="L490">      } catch (Exception e) {</span>
<span class="nc" id="L491">        throw new RuntimeIOException(&quot;Resource or file looks like a gzip file, but is not: &quot; + textFileOrUrl, e);</span>
<span class="fc" id="L492">      }</span>
    }

    // buffer this stream.  even gzip streams benefit from buffering,
    // such as for the shift reduce parser [cdm 2016: I think this is only because default buffer is small; see below]
<span class="fc" id="L497">    in = new BufferedInputStream(in);</span>

<span class="fc" id="L499">    return in;</span>
  }


  // todo [cdm 2015]: I think GZIPInputStream has its own buffer and so we don't need to buffer in that case.
  // todo: Though it's default size is 512 bytes so need to make 8K in constructor. Or else buffering outside gzip is faster
  // todo: final InputStream is = new GZIPInputStream( new FileInputStream( file ), 65536 );
  /**
   * Quietly opens a File. If the file ends with a &quot;.gz&quot; extension,
   * automatically opens a GZIPInputStream to wrap the constructed
   * FileInputStream.
   */
  public static InputStream inputStreamFromFile(File file) throws RuntimeIOException {
    try {
<span class="fc" id="L513">      InputStream is = new BufferedInputStream(new FileInputStream(file));</span>
<span class="pc bpc" id="L514" title="1 of 2 branches missed.">      if (file.getName().endsWith(&quot;.gz&quot;)) {</span>
<span class="nc" id="L515">        is = new GZIPInputStream(is);</span>
      }
<span class="fc" id="L517">      return is;</span>
<span class="nc" id="L518">    } catch (IOException e) {</span>
<span class="nc" id="L519">      throw new RuntimeIOException(e);</span>
    }
  }


  /**
   * Open a BufferedReader to a File. If the file's getName() ends in .gz,
   * it is interpreted as a gzipped file (and uncompressed). The file is then
   * interpreted as a utf-8 text file.
   *
   * @param file What to read from
   * @return The BufferedReader
   * @throws RuntimeIOException If there is an I/O problem
   */
  public static BufferedReader readerFromFile(File file) {
<span class="nc" id="L534">    InputStream is = null;</span>
    try {
<span class="nc" id="L536">      is = inputStreamFromFile(file);</span>
<span class="nc" id="L537">      return new BufferedReader(new InputStreamReader(is, &quot;UTF-8&quot;));</span>
<span class="nc" id="L538">    } catch (IOException ioe) {</span>
<span class="nc" id="L539">      IOUtils.closeIgnoringExceptions(is);</span>
<span class="nc" id="L540">      throw new RuntimeIOException(ioe);</span>
    }
  }


  // todo [cdm 2014]: get rid of this method, using other methods. This will change the semantics to null meaning UTF-8, but that seems better in 2015.
  /**
   * Open a BufferedReader to a File. If the file's getName() ends in .gz,
   * it is interpreted as a gzipped file (and uncompressed). The file is then
   * turned into a BufferedReader with the given encoding.
   * If the encoding passed in is null, then the system default encoding is used.
   *
   * @param file What to read from
   * @param encoding What charset to use. A null String is interpreted as platform default encoding
   * @return The BufferedReader
   * @throws RuntimeIOException If there is an I/O problem
   */
  public static BufferedReader readerFromFile(File file, String encoding) {
<span class="nc" id="L558">    InputStream is = null;</span>
    try {
<span class="nc" id="L560">      is = inputStreamFromFile(file);</span>
<span class="nc bnc" id="L561" title="All 2 branches missed.">      if (encoding == null) {</span>
<span class="nc" id="L562">        return new BufferedReader(new InputStreamReader(is));</span>
      } else {
<span class="nc" id="L564">        return new BufferedReader(new InputStreamReader(is, encoding));</span>
      }
<span class="nc" id="L566">    } catch (IOException ioe) {</span>
<span class="nc" id="L567">      IOUtils.closeIgnoringExceptions(is);</span>
<span class="nc" id="L568">      throw new RuntimeIOException(ioe);</span>
    }
  }


  /**
   * Open a BufferedReader on stdin. Use the user's default encoding.
   *
   * @return The BufferedReader
   */
  public static BufferedReader readerFromStdin() {
<span class="nc" id="L579">    return new BufferedReader(new InputStreamReader(System.in));</span>
  }

  /**
   * Open a BufferedReader on stdin. Use the specified character encoding.
   *
   * @param encoding CharSet encoding. Maybe be null, in which case the
   *         platform default encoding is used
   * @return The BufferedReader
   * @throws IOException If there is an I/O problem
   */
  public static BufferedReader readerFromStdin(String encoding) throws IOException {
<span class="nc bnc" id="L591" title="All 2 branches missed.">    if (encoding == null) {</span>
<span class="nc" id="L592">      return new BufferedReader(new InputStreamReader(System.in));</span>
    }
<span class="nc" id="L594">    return new BufferedReader(new InputStreamReader(System.in, encoding));</span>
  }


  // TODO [cdm 2015]: Should we rename these methods. Sort of misleading: They really read files, resources, etc. specified by a String
  /**
   * Open a BufferedReader to a file, class path entry or URL specified by a String name.
   * If the String starts with https?://, then it is first tried as a URL. It
   * is next tried as a resource on the CLASSPATH, and then it is tried
   * as a local file. Finally, it is then tried again in case it is some network-available
   * file accessible by URL. If the String ends in .gz, it
   * is interpreted as a gzipped file (and uncompressed). The file is then
   * interpreted as a utf-8 text file.
   * Note that this method uses the ClassLoader methods, so that classpath resources must be specified as
   * absolute resource paths without a leading &quot;/&quot;.
   *
   * @param textFileOrUrl What to read from
   * @return The BufferedReader
   * @throws IOException If there is an I/O problem
   */
  public static BufferedReader readerFromString(String textFileOrUrl)
          throws IOException {
<span class="fc" id="L616">    return new BufferedReader(new InputStreamReader(</span>
<span class="fc" id="L617">            getInputStreamFromURLOrClasspathOrFileSystem(textFileOrUrl), &quot;UTF-8&quot;));</span>
  }

  /**
   * Open a BufferedReader to a file or URL specified by a String name. If the
   * String starts with https?://, then it is first tried as a URL, otherwise it
   * is next tried as a resource on the CLASSPATH, and then finally it is tried
   * as a local file or other network-available file . If the String ends in .gz, it
   * is interpreted as a gzipped file (and uncompressed), else it is interpreted as
   * a regular text file in the given encoding.
   * If the encoding passed in is null, then the system default encoding is used.
   *
   * @param textFileOrUrl What to read from
   * @param encoding CharSet encoding. Maybe be null, in which case the
   *         platform default encoding is used
   * @return The BufferedReader
   * @throws IOException If there is an I/O problem
   */
  public static BufferedReader readerFromString(String textFileOrUrl,
                                                String encoding) throws IOException {
<span class="fc" id="L637">    InputStream is = getInputStreamFromURLOrClasspathOrFileSystem(textFileOrUrl);</span>
<span class="pc bpc" id="L638" title="1 of 2 branches missed.">    if (encoding == null) {</span>
<span class="nc" id="L639">      return new BufferedReader(new InputStreamReader(is));</span>
    }
<span class="fc" id="L641">    return new BufferedReader(new InputStreamReader(is, encoding));</span>
  }

  /**
   * Returns an Iterable of the lines in the file.
   *
   * The file reader will be closed when the iterator is exhausted. IO errors
   * will throw an (unchecked) RuntimeIOException
   *
   * @param path The file whose lines are to be read.
   * @return An Iterable containing the lines from the file.
   */
  public static Iterable&lt;String&gt; readLines(String path) {
<span class="fc" id="L654">    return readLines(path, null);</span>
  }

  /**
   * Returns an Iterable of the lines in the file.
   *
   * The file reader will be closed when the iterator is exhausted. IO errors
   * will throw an (unchecked) RuntimeIOException
   *
   * @param path The file whose lines are to be read.
   * @param encoding The encoding to use when reading lines.
   * @return An Iterable containing the lines from the file.
   */
  public static Iterable&lt;String&gt; readLines(String path, String encoding) {
<span class="fc" id="L668">    return new GetLinesIterable(path, null, encoding);</span>
  }

  /**
   * Returns an Iterable of the lines in the file.
   *
   * The file reader will be closed when the iterator is exhausted.
   *
   * @param file The file whose lines are to be read.
   * @return An Iterable containing the lines from the file.
   */
  public static Iterable&lt;String&gt; readLines(final File file) {
<span class="fc" id="L680">    return readLines(file, null, null);</span>
  }

  /**
   * Returns an Iterable of the lines in the file.
   *
   * The file reader will be closed when the iterator is exhausted.
   *
   * @param file The file whose lines are to be read.
   * @param fileInputStreamWrapper
   *          The class to wrap the InputStream with, e.g. GZIPInputStream. Note
   *          that the class must have a constructor that accepts an
   *          InputStream.
   * @return An Iterable containing the lines from the file.
   */
  public static Iterable&lt;String&gt; readLines(final File file,
                                           final Class&lt;? extends InputStream&gt; fileInputStreamWrapper) {
<span class="fc" id="L697">    return readLines(file, fileInputStreamWrapper, null);</span>
  }

  /**
   * Returns an Iterable of the lines in the file, wrapping the generated
   * FileInputStream with an instance of the supplied class. IO errors will
   * throw an (unchecked) RuntimeIOException
   *
   * @param file The file whose lines are to be read.
   * @param fileInputStreamWrapper
   *          The class to wrap the InputStream with, e.g. GZIPInputStream. Note
   *          that the class must have a constructor that accepts an
   *          InputStream.
   * @param encoding The encoding to use when reading lines.
   * @return An Iterable containing the lines from the file.
   */
  public static Iterable&lt;String&gt; readLines(final File file,
                                           final Class&lt;? extends InputStream&gt; fileInputStreamWrapper,
                                           final String encoding) {
<span class="fc" id="L716">    return new GetLinesIterable(file, fileInputStreamWrapper, encoding);</span>
  }

  static class GetLinesIterable implements Iterable&lt;String&gt; {
    final File file;
    final String path;
    final Class&lt;? extends InputStream&gt; fileInputStreamWrapper;
    final String encoding;

    // TODO: better programming style would be to make this two
    // separate classes, but we don't expect to make more versions of
    // this class anyway
    GetLinesIterable(final File file,
                     final Class&lt;? extends InputStream&gt; fileInputStreamWrapper,
<span class="fc" id="L730">                     final String encoding) {</span>
<span class="fc" id="L731">      this.file = file;</span>
<span class="fc" id="L732">      this.path = null;</span>
<span class="fc" id="L733">      this.fileInputStreamWrapper = fileInputStreamWrapper;</span>
<span class="fc" id="L734">      this.encoding = encoding;</span>
<span class="fc" id="L735">    }</span>

    GetLinesIterable(final String path,
                     final Class&lt;? extends InputStream&gt; fileInputStreamWrapper,
<span class="fc" id="L739">                     final String encoding) {</span>
<span class="fc" id="L740">      this.file = null;</span>
<span class="fc" id="L741">      this.path = path;</span>
<span class="fc" id="L742">      this.fileInputStreamWrapper = fileInputStreamWrapper;</span>
<span class="fc" id="L743">      this.encoding = encoding;</span>
<span class="fc" id="L744">    }</span>

    private InputStream getStream() throws IOException {
<span class="fc bfc" id="L747" title="All 2 branches covered.">      if (file != null) {</span>
<span class="fc" id="L748">        return inputStreamFromFile(file);</span>
<span class="pc bpc" id="L749" title="1 of 2 branches missed.">      } else if (path != null) {</span>
<span class="fc" id="L750">        return getInputStreamFromURLOrClasspathOrFileSystem(path);</span>
      } else {
<span class="nc" id="L752">        throw new AssertionError(&quot;No known path to read&quot;);</span>
      }
    }

    @Override
    public Iterator&lt;String&gt; iterator() {
<span class="fc" id="L758">      return new Iterator&lt;String&gt;() {</span>

<span class="fc" id="L760">        protected final BufferedReader reader = this.getReader();</span>
<span class="fc" id="L761">        protected String line = this.getLine();</span>

        @Override
        public boolean hasNext() {
<span class="fc bfc" id="L765" title="All 2 branches covered.">          return this.line != null;</span>
        }

        @Override
        public String next() {
<span class="fc" id="L770">          String nextLine = this.line;</span>
<span class="pc bpc" id="L771" title="1 of 2 branches missed.">          if (nextLine == null) {</span>
<span class="nc" id="L772">            throw new NoSuchElementException();</span>
          }
<span class="fc" id="L774">          line = getLine();</span>
<span class="fc" id="L775">          return nextLine;</span>
        }

        protected String getLine() {
          try {
<span class="fc" id="L780">            String result = this.reader.readLine();</span>
<span class="fc bfc" id="L781" title="All 2 branches covered.">            if (result == null) {</span>
<span class="fc" id="L782">              this.reader.close();</span>
            }
<span class="fc" id="L784">            return result;</span>
<span class="nc" id="L785">          } catch (IOException e) {</span>
<span class="nc" id="L786">            throw new RuntimeIOException(e);</span>
          }
        }

        protected BufferedReader getReader() {
          try {
<span class="fc" id="L792">            InputStream stream = getStream();</span>
<span class="fc bfc" id="L793" title="All 2 branches covered.">            if (fileInputStreamWrapper != null) {</span>
<span class="fc" id="L794">              stream = fileInputStreamWrapper.getConstructor(InputStream.class).newInstance(stream);</span>
            }
<span class="pc bpc" id="L796" title="1 of 2 branches missed.">            if (encoding == null) {</span>
<span class="fc" id="L797">              return new BufferedReader(new InputStreamReader(stream));</span>
            } else {
<span class="nc" id="L799">              return new BufferedReader(new InputStreamReader(stream, encoding));</span>
            }
<span class="nc" id="L801">          } catch (Exception e) {</span>
<span class="nc" id="L802">            throw new RuntimeIOException(e);</span>
          }
        }

        @Override
        public void remove() {
<span class="nc" id="L808">          throw new UnsupportedOperationException();</span>
        }
      };
    }

  } // end static class GetLinesIterable

  /**
   * Given a reader, returns the lines from the reader as an Iterable.
   *
   * @param r  input reader
   * @param includeEol whether to keep eol-characters in the returned strings
   * @return iterable of lines (as strings)
   */
  public static Iterable&lt;String&gt; getLineIterable( Reader r, boolean includeEol) {
<span class="nc bnc" id="L823" title="All 2 branches missed.">    if (includeEol) {</span>
<span class="nc" id="L824">      return new EolPreservingLineReaderIterable(r);</span>
    } else {
<span class="nc bnc" id="L826" title="All 2 branches missed.">      return new LineReaderIterable( (r instanceof BufferedReader)? (BufferedReader) r:new BufferedReader(r) );</span>
    }
  }

  public static Iterable&lt;String&gt; getLineIterable( Reader r, int bufferSize, boolean includeEol) {
<span class="fc bfc" id="L831" title="All 2 branches covered.">    if (includeEol) {</span>
<span class="fc" id="L832">      return new EolPreservingLineReaderIterable(r, bufferSize);</span>
    } else {
<span class="pc bpc" id="L834" title="1 of 2 branches missed.">      return new LineReaderIterable( (r instanceof BufferedReader)? (BufferedReader) r:new BufferedReader(r, bufferSize) );</span>
    }
  }

  /**
   * Line iterator that uses BufferedReader.readLine()
   * EOL-characters are automatically discarded and not included in the strings returns
   */
  private static final class LineReaderIterable implements Iterable&lt;String&gt;
  {
    private final BufferedReader reader;

    private LineReaderIterable( BufferedReader reader )
<span class="fc" id="L847">    {</span>
<span class="fc" id="L848">      this.reader = reader;</span>
<span class="fc" id="L849">    }</span>
    @Override
    public Iterator&lt;String&gt; iterator()
    {
<span class="fc" id="L853">      return new Iterator&lt;String&gt;() {</span>
<span class="fc" id="L854">        private String next = getNext();</span>

        private String getNext() {
          try {
<span class="fc" id="L858">            return reader.readLine();</span>
<span class="nc" id="L859">          } catch (IOException ex) {</span>
<span class="nc" id="L860">            throw new RuntimeIOException(ex);</span>
          }
        }

        @Override
        public boolean hasNext()
        {
<span class="fc bfc" id="L867" title="All 2 branches covered.">          return this.next != null;</span>
        }
        @Override
        public String next()
        {
<span class="fc" id="L872">          String nextLine = this.next;</span>
<span class="pc bpc" id="L873" title="1 of 2 branches missed.">          if (nextLine == null) {</span>
<span class="nc" id="L874">            throw new NoSuchElementException();</span>
          }
<span class="fc" id="L876">          next = getNext();</span>
<span class="fc" id="L877">          return nextLine;</span>
        }

        @Override
        public void remove()
        {
<span class="nc" id="L883">          throw new UnsupportedOperationException();</span>
        }
      };
    }
  }

  /**
   * Line iterator that preserves the eol-character exactly as read from reader.
   * Line endings are: \r\n,\n,\r
   * Lines returns by this iterator will include the eol-characters
   **/
  private static final class EolPreservingLineReaderIterable implements Iterable&lt;String&gt; {

    private final Reader reader;
    private final int bufferSize;

    private EolPreservingLineReaderIterable( Reader reader )
    {
<span class="nc" id="L901">      this(reader, SLURP_BUFFER_SIZE);</span>
<span class="nc" id="L902">    }</span>
<span class="fc" id="L903">    private EolPreservingLineReaderIterable( Reader reader, int bufferSize ) {</span>
<span class="fc" id="L904">      this.reader = reader;</span>
<span class="fc" id="L905">      this.bufferSize = bufferSize;</span>
<span class="fc" id="L906">    }</span>

    @Override
    public Iterator&lt;String&gt; iterator() {
<span class="fc" id="L910">      return new Iterator&lt;String&gt;() {</span>
        private String next;
<span class="fc" id="L912">        private boolean done = false;</span>

<span class="fc" id="L914">        private StringBuilder sb = new StringBuilder(80);</span>
<span class="fc" id="L915">        private char[] charBuffer = new char[bufferSize];</span>
<span class="fc" id="L916">        private int charBufferPos = -1;</span>
<span class="fc" id="L917">        private int charsInBuffer = 0;</span>
<span class="fc" id="L918">        boolean lastWasLF = false;</span>

        private String getNext() {
          try {
            while (true) {
<span class="fc bfc" id="L923" title="All 2 branches covered.">              if (charBufferPos &lt; 0) {</span>
<span class="fc" id="L924">                charsInBuffer = reader.read(charBuffer);</span>
<span class="fc bfc" id="L925" title="All 2 branches covered.">                if (charsInBuffer &lt; 0) {</span>
                  // No more!!!
<span class="fc bfc" id="L927" title="All 2 branches covered.">                  if (sb.length() &gt; 0) {</span>
<span class="fc" id="L928">                    String line = sb.toString();</span>
                    // resets the buffer
<span class="fc" id="L930">                    sb.setLength(0);</span>
<span class="fc" id="L931">                    return line;</span>
                  } else {
<span class="fc" id="L933">                    return null;</span>
                  }
                }
<span class="fc" id="L936">                charBufferPos = 0;</span>
              }

<span class="fc" id="L939">              boolean eolReached = copyUntilEol();</span>
<span class="fc bfc" id="L940" title="All 2 branches covered.">              if (eolReached) {</span>
                // eol reached
<span class="fc" id="L942">                String line = sb.toString();</span>
                // resets the buffer
<span class="fc" id="L944">                sb.setLength(0);</span>
<span class="fc" id="L945">                return line;</span>
              }
<span class="fc" id="L947">            }</span>
<span class="nc" id="L948">          } catch (IOException ex) {</span>
<span class="nc" id="L949">            throw new RuntimeIOException(ex);</span>
          }
        }

        private boolean copyUntilEol() {
<span class="fc bfc" id="L954" title="All 2 branches covered.">          for (int i = charBufferPos; i &lt; charsInBuffer; i++) {</span>
<span class="fc bfc" id="L955" title="All 2 branches covered.">            if (charBuffer[i] == '\n') {</span>
              // line end
              // copy into our string builder
<span class="fc" id="L958">              sb.append(charBuffer, charBufferPos, i - charBufferPos + 1);</span>
              // advance character buffer pos
<span class="fc" id="L960">              charBufferPos = i+1;</span>
<span class="fc" id="L961">              lastWasLF = false;</span>
<span class="fc" id="L962">              return true; // end of line reached</span>
<span class="fc bfc" id="L963" title="All 2 branches covered.">            } else if (lastWasLF) {</span>
              // not a '\n' here - still need to terminate line (but don't include current character)
<span class="pc bpc" id="L965" title="1 of 2 branches missed.">              if (i &gt; charBufferPos) {</span>
<span class="fc" id="L966">                sb.append(charBuffer, charBufferPos, i - charBufferPos);</span>
                // advance character buffer pos
<span class="fc" id="L968">                charBufferPos = i;</span>
<span class="fc" id="L969">                lastWasLF = false;</span>
<span class="fc" id="L970">                return true; // end of line reached</span>
              }
            }
<span class="fc bfc" id="L973" title="All 2 branches covered.">            lastWasLF = (charBuffer[i] == '\r');</span>
          }
<span class="fc" id="L975">          sb.append(charBuffer, charBufferPos, charsInBuffer - charBufferPos);</span>
          // reset character buffer pos
<span class="fc" id="L977">          charBufferPos = -1;</span>
<span class="fc" id="L978">          return false;</span>
        }

        @Override
        public boolean hasNext()
        {
<span class="pc bpc" id="L984" title="1 of 2 branches missed.">          if (done) return false;</span>
<span class="fc bfc" id="L985" title="All 2 branches covered.">          if (next == null) {</span>
<span class="fc" id="L986">            next = getNext();</span>
          }
<span class="fc bfc" id="L988" title="All 2 branches covered.">          if (next == null) {</span>
<span class="fc" id="L989">            done = true;</span>
          }
<span class="fc bfc" id="L991" title="All 2 branches covered.">          return !done;</span>
        }

        @Override
        public String next()
        {
<span class="pc bpc" id="L997" title="1 of 2 branches missed.">          if (!hasNext()) { throw new NoSuchElementException(); }</span>
<span class="fc" id="L998">          String res = next;</span>
<span class="fc" id="L999">          next = null;</span>
<span class="fc" id="L1000">          return res;</span>
        }

        @Override
        public void remove()
        {
<span class="nc" id="L1006">          throw new UnsupportedOperationException();</span>
        }
      };
    } // end iterator()

  } // end static class EolPreservingLineReaderIterable

  /**
   * Provides an implementation of closing a file for use in a finally block so
   * you can correctly close a file without even more exception handling stuff.
   * From a suggestion in a talk by Josh Bloch. Calling close() will flush().
   *
   * @param c The IO resource to close (e.g., a Stream/Reader)
   */
  public static void closeIgnoringExceptions(Closeable c) {
<span class="pc bpc" id="L1021" title="1 of 2 branches missed.">    if (c != null) {</span>
      try {
<span class="fc" id="L1023">        c.close();</span>
<span class="nc" id="L1024">      } catch (IOException ioe) {</span>
        // ignore
<span class="fc" id="L1026">      }</span>
    }
<span class="fc" id="L1028">  }</span>

  /**
   * Iterate over all the files in the directory, recursively.
   *
   * @param dir The root directory.
   * @return All files within the directory.
   */
  public static Iterable&lt;File&gt; iterFilesRecursive(final File dir) {
<span class="fc" id="L1037">    return iterFilesRecursive(dir, (Pattern) null);</span>
  }

  /**
   * Iterate over all the files in the directory, recursively.
   *
   * @param dir The root directory.
   * @param ext A string that must be at the end of all files (e.g. &quot;.txt&quot;)
   * @return All files within the directory ending in the given extension.
   */
  public static Iterable&lt;File&gt; iterFilesRecursive(final File dir,
                                                  final String ext) {
<span class="fc" id="L1049">    return iterFilesRecursive(dir, Pattern.compile(Pattern.quote(ext) + &quot;$&quot;));</span>
  }

  /**
   * Iterate over all the files in the directory, recursively.
   *
   * @param dir The root directory.
   * @param pattern A regular expression that the file path must match. This uses
   *          Matcher.find(), so use ^ and $ to specify endpoints.
   * @return All files within the directory.
   */
  public static Iterable&lt;File&gt; iterFilesRecursive(final File dir,
                                                  final Pattern pattern) {
<span class="fc" id="L1062">    return new Iterable&lt;File&gt;() {</span>
      public Iterator&lt;File&gt; iterator() {
<span class="fc" id="L1064">        return new AbstractIterator&lt;File&gt;() {</span>
<span class="fc" id="L1065">          private final Queue&lt;File&gt; files = new LinkedList&lt;&gt;(Collections</span>
<span class="fc" id="L1066">                  .singleton(dir));</span>
<span class="fc" id="L1067">          private File file = this.findNext();</span>

          @Override
          public boolean hasNext() {
<span class="fc bfc" id="L1071" title="All 2 branches covered.">            return this.file != null;</span>
          }

          @Override
          public File next() {
<span class="fc" id="L1076">            File result = this.file;</span>
<span class="pc bpc" id="L1077" title="1 of 2 branches missed.">            if (result == null) {</span>
<span class="nc" id="L1078">              throw new NoSuchElementException();</span>
            }
<span class="fc" id="L1080">            this.file = this.findNext();</span>
<span class="fc" id="L1081">            return result;</span>
          }

          private File findNext() {
<span class="fc" id="L1085">            File next = null;</span>
<span class="fc bfc" id="L1086" title="All 4 branches covered.">            while (!this.files.isEmpty() &amp;&amp; next == null) {</span>
<span class="fc" id="L1087">              next = this.files.remove();</span>
<span class="fc bfc" id="L1088" title="All 2 branches covered.">              if (next.isDirectory()) {</span>
<span class="fc" id="L1089">                files.addAll(Arrays.asList(next.listFiles()));</span>
<span class="fc" id="L1090">                next = null;</span>
<span class="fc bfc" id="L1091" title="All 2 branches covered.">              } else if (pattern != null) {</span>
<span class="fc bfc" id="L1092" title="All 2 branches covered.">                if (!pattern.matcher(next.getPath()).find()) {</span>
<span class="fc" id="L1093">                  next = null;</span>
                }
              }
            }
<span class="fc" id="L1097">            return next;</span>
          }
        };
      }
    };
  }

  /**
   * Returns all the text in the given File as a single String.
   * If the file's name ends in .gz, it is assumed to be gzipped and is silently uncompressed.
   */
  public static String slurpFile(File file) throws IOException {
<span class="fc" id="L1109">    return slurpFile(file, null);</span>
  }

  /**
   * Returns all the text in the given File as a single String.
   * If the file's name ends in .gz, it is assumed to be gzipped and is silently uncompressed.
   *
   * @param file The file to read from
   * @param encoding The character encoding to assume.  This may be null, and
   *       the platform default character encoding is used.
   */
  public static String slurpFile(File file, String encoding) throws IOException {
<span class="fc" id="L1121">    return IOUtils.slurpReader(IOUtils.encodedInputStreamReader(</span>
<span class="fc" id="L1122">            inputStreamFromFile(file), encoding));</span>
  }

  /**
   * Returns all the text in the given File as a single String.
   */
  public static String slurpGZippedFile(String filename) throws IOException {
<span class="nc" id="L1129">    Reader r = encodedInputStreamReader(new GZIPInputStream(new FileInputStream(</span>
            filename)), null);
<span class="nc" id="L1131">    return IOUtils.slurpReader(r);</span>
  }

  /**
   * Returns all the text in the given File as a single String.
   */
  public static String slurpGZippedFile(File file) throws IOException {
<span class="nc" id="L1138">    Reader r = encodedInputStreamReader(new GZIPInputStream(new FileInputStream(</span>
            file)), null);
<span class="nc" id="L1140">    return IOUtils.slurpReader(r);</span>
  }

  /**
   * Returns all the text in the given file with the given encoding.
   * The string may be empty, if the file is empty.
   */
  public static String slurpFile(String filename, String encoding)
          throws IOException {
<span class="fc" id="L1149">    Reader r = readerFromString(filename, encoding);</span>
<span class="fc" id="L1150">    return IOUtils.slurpReader(r);</span>
  }

  /**
   * Returns all the text in the given file with the given
   * encoding. If the file cannot be read (non-existent, etc.), then
   * the method throws an unchecked RuntimeIOException.  If the caller
   * is willing to tolerate missing files, they should catch that
   * exception.
   */
  public static String slurpFileNoExceptions(String filename, String encoding) {
    try {
<span class="nc" id="L1162">      return slurpFile(filename, encoding);</span>
<span class="nc" id="L1163">    } catch (IOException e) {</span>
<span class="nc" id="L1164">      throw new RuntimeIOException(&quot;slurpFile IO problem&quot;, e);</span>
    }
  }

  /**
   * Returns all the text in the given file
   *
   * @return The text in the file.
   */
  public static String slurpFile(String filename) throws IOException {
<span class="fc" id="L1174">    return slurpFile(filename, defaultEncoding);</span>
  }

  /**
   * Returns all the text at the given URL.
   */
  public static String slurpURLNoExceptions(URL u, String encoding) {
    try {
<span class="nc" id="L1182">      return IOUtils.slurpURL(u, encoding);</span>
<span class="nc" id="L1183">    } catch (Exception e) {</span>
<span class="nc" id="L1184">      logger.err(throwableToStackTrace(e));</span>
<span class="nc" id="L1185">      return null;</span>
    }
  }

  /**
   * Returns all the text at the given URL.
   */
  public static String slurpURL(URL u, String encoding) throws IOException {
<span class="nc" id="L1193">    String lineSeparator = System.lineSeparator();</span>
<span class="nc" id="L1194">    URLConnection uc = u.openConnection();</span>
<span class="nc" id="L1195">    uc.setReadTimeout(30000);</span>
    InputStream is;
    try {
<span class="nc" id="L1198">      is = uc.getInputStream();</span>
<span class="nc" id="L1199">    } catch (SocketTimeoutException e) {</span>
<span class="nc" id="L1200">      logger.error(&quot;Socket time out; returning empty string.&quot;);</span>
<span class="nc" id="L1201">      logger.err(throwableToStackTrace(e));</span>
<span class="nc" id="L1202">      return &quot;&quot;;</span>
<span class="nc" id="L1203">    }</span>
<span class="nc" id="L1204">    BufferedReader br = new BufferedReader(new InputStreamReader(is, encoding));</span>
<span class="nc" id="L1205">    StringBuilder buff = new StringBuilder(SLURP_BUFFER_SIZE); // make biggish</span>
<span class="nc bnc" id="L1206" title="All 2 branches missed.">    for (String temp; (temp = br.readLine()) != null; ) {</span>
<span class="nc" id="L1207">      buff.append(temp);</span>
<span class="nc" id="L1208">      buff.append(lineSeparator);</span>
    }
<span class="nc" id="L1210">    br.close();</span>
<span class="nc" id="L1211">    return buff.toString();</span>
  }

  public static String getUrlEncoding(URLConnection connection) {
<span class="nc" id="L1215">    String contentType = connection.getContentType();</span>
<span class="nc" id="L1216">    String[] values = contentType.split(&quot;;&quot;);</span>
<span class="nc" id="L1217">    String charset = defaultEncoding;  // might or might not be right....</span>

<span class="nc bnc" id="L1219" title="All 2 branches missed.">    for (String value : values) {</span>
<span class="nc" id="L1220">      value = value.trim();</span>
<span class="nc bnc" id="L1221" title="All 2 branches missed.">      if (value.toLowerCase(Locale.ENGLISH).startsWith(&quot;charset=&quot;)) {</span>
<span class="nc" id="L1222">        charset = value.substring(&quot;charset=&quot;.length());</span>
      }
    }
<span class="nc" id="L1225">    return charset;</span>
  }


  /**
   * Returns all the text at the given URL.
   */
  public static String slurpURL(URL u) throws IOException {
<span class="nc" id="L1233">    String lineSeparator = System.getProperty(&quot;line.separator&quot;);</span>
<span class="nc" id="L1234">    URLConnection uc = u.openConnection();</span>
<span class="nc" id="L1235">    String encoding = getUrlEncoding(uc);</span>
<span class="nc" id="L1236">    InputStream is = uc.getInputStream();</span>
<span class="nc" id="L1237">    BufferedReader br = new BufferedReader(new InputStreamReader(is, encoding));</span>
<span class="nc" id="L1238">    StringBuilder buff = new StringBuilder(SLURP_BUFFER_SIZE); // make biggish</span>
<span class="nc bnc" id="L1239" title="All 2 branches missed.">    for (String temp; (temp = br.readLine()) != null; ) {</span>
<span class="nc" id="L1240">      buff.append(temp);</span>
<span class="nc" id="L1241">      buff.append(lineSeparator);</span>
    }
<span class="nc" id="L1243">    br.close();</span>
<span class="nc" id="L1244">    return buff.toString();</span>
  }

  /**
   * Returns all the text at the given URL.
   */
  public static String slurpURLNoExceptions(URL u) {
    try {
<span class="nc" id="L1252">      return slurpURL(u);</span>
<span class="nc" id="L1253">    } catch (Exception e) {</span>
<span class="nc" id="L1254">      logger.err(throwableToStackTrace(e));</span>
<span class="nc" id="L1255">      return null;</span>
    }
  }

  /**
   * Returns all the text at the given URL.
   */
  public static String slurpURL(String path) throws Exception {
<span class="nc" id="L1263">    return slurpURL(new URL(path));</span>
  }

  /**
   * Returns all the text at the given URL. If the file cannot be read
   * (non-existent, etc.), then and only then the method returns
   * {@code null}.
   */
  public static String slurpURLNoExceptions(String path) {
    try {
<span class="nc" id="L1273">      return slurpURL(path);</span>
<span class="nc" id="L1274">    } catch (Exception e) {</span>
<span class="nc" id="L1275">      logger.err(throwableToStackTrace(e));</span>
<span class="nc" id="L1276">      return null;</span>
    }
  }

  /**
   * Returns all the text in the given file with the given
   * encoding. If the file cannot be read (non-existent, etc.), then
   * the method throws an unchecked RuntimeIOException.  If the caller
   * is willing to tolerate missing files, they should catch that
   * exception.
   */
  public static String slurpFileNoExceptions(File file) {
    try {
<span class="nc" id="L1289">      return IOUtils.slurpReader(encodedInputStreamReader(new FileInputStream(file), null));</span>
<span class="nc" id="L1290">    } catch (IOException e) {</span>
<span class="nc" id="L1291">      throw new RuntimeIOException(e);</span>
    }
  }

  /**
   * Returns all the text in the given file with the given
   * encoding. If the file cannot be read (non-existent, etc.), then
   * the method throws an unchecked RuntimeIOException.  If the caller
   * is willing to tolerate missing files, they should catch that
   * exception.
   */
  public static String slurpFileNoExceptions(String filename) {
    try {
<span class="nc" id="L1304">      return slurpFile(filename);</span>
<span class="nc" id="L1305">    } catch (IOException e) {</span>
<span class="nc" id="L1306">      throw new RuntimeIOException(e);</span>
    }
  }

  /**
   * Returns all the text from the given Reader.
   * Closes the Reader when done.
   *
   * @return The text in the file.
   */
  public static String slurpReader(Reader reader) {
<span class="fc" id="L1317">    StringBuilder buff = new StringBuilder();</span>
    try {
<span class="fc" id="L1319">      char[] chars = new char[SLURP_BUFFER_SIZE];</span>
<span class="fc" id="L1320">      BufferedReader r = new BufferedReader(reader);</span>
      while (true) {
<span class="fc" id="L1322">        int amountRead = r.read(chars, 0, SLURP_BUFFER_SIZE);</span>
<span class="fc bfc" id="L1323" title="All 2 branches covered.">        if (amountRead &lt; 0) {</span>
<span class="fc" id="L1324">          break;</span>
        }
<span class="fc" id="L1326">        buff.append(chars, 0, amountRead);</span>
<span class="fc" id="L1327">      }</span>
<span class="fc" id="L1328">      r.close();</span>
<span class="nc" id="L1329">    } catch (Exception e) {</span>
<span class="nc" id="L1330">      throw new RuntimeIOException(&quot;slurpReader IO problem&quot;, e);</span>
<span class="fc" id="L1331">    }</span>
<span class="fc" id="L1332">    return buff.toString();</span>
  }

  /**
   * Read the contents of an input stream, decoding it according to the given character encoding.
   * @param input The input stream to read from
   * @return The String representation of that input stream
   */
  public static String slurpInputStream(InputStream input, String encoding) throws IOException {
<span class="nc" id="L1341">    return slurpReader(encodedInputStreamReader(input, encoding));</span>
  }

  /**
   * Send all bytes from the input stream to the output stream.
   *
   * @param input The input bytes.
   * @param output Where the bytes should be written.
   */
  public static void writeStreamToStream(InputStream input, OutputStream output)
          throws IOException {
<span class="nc" id="L1352">    byte[] buffer = new byte[4096];</span>
    while (true) {
<span class="nc" id="L1354">      int len = input.read(buffer);</span>
<span class="nc bnc" id="L1355" title="All 2 branches missed.">      if (len == -1) {</span>
<span class="nc" id="L1356">        break;</span>
      }
<span class="nc" id="L1358">      output.write(buffer, 0, len);</span>
<span class="nc" id="L1359">    }</span>
<span class="nc" id="L1360">  }</span>

  /**
   * Read in a CSV formatted file with a header row.
   *
   * @param path - path to CSV file
   * @param quoteChar - character for enclosing strings, defaults to &quot;
   * @param escapeChar - character for escaping quotes appearing in quoted strings; defaults to &quot; (i.e. &quot;&quot; is used for &quot; inside quotes, consistent with Excel)
   * @return a list of maps representing the rows of the csv. The maps' keys are the header strings and their values are the row contents
   * @throws IOException If any IO problem
   */
  public static List&lt;Map&lt;String,String&gt;&gt; readCSVWithHeader(String path, char quoteChar, char escapeChar) throws IOException {
<span class="nc" id="L1372">    String[] labels = null;</span>
<span class="nc" id="L1373">    List&lt;Map&lt;String,String&gt;&gt; rows = Generics.newArrayList();</span>
<span class="nc bnc" id="L1374" title="All 2 branches missed.">    for (String line : IOUtils.readLines(path)) {</span>
      // logger.info(&quot;Splitting &quot;+line);
<span class="nc bnc" id="L1376" title="All 2 branches missed.">      if (labels == null) {</span>
<span class="nc" id="L1377">        labels = StringUtils.splitOnCharWithQuoting(line,',','&quot;',escapeChar);</span>
      } else {
<span class="nc" id="L1379">        String[] cells = StringUtils.splitOnCharWithQuoting(line,',',quoteChar,escapeChar);</span>
<span class="nc bnc" id="L1380" title="All 4 branches missed.">        assert(cells.length == labels.length);</span>
<span class="nc" id="L1381">        Map&lt;String,String&gt; cellMap = Generics.newHashMap();</span>
<span class="nc bnc" id="L1382" title="All 2 branches missed.">        for (int i=0; i&lt;labels.length; i++) cellMap.put(labels[i],cells[i]);</span>
<span class="nc" id="L1383">        rows.add(cellMap);</span>
      }
<span class="nc" id="L1385">    }</span>
<span class="nc" id="L1386">    return rows;</span>
  }
  public static List&lt;Map&lt;String,String&gt;&gt; readCSVWithHeader(String path) throws IOException {
<span class="nc" id="L1389">    return readCSVWithHeader(path, '&quot;', '&quot;');</span>
  }

  /**
   * Read a CSV file character by character. Allows for multi-line CSV files (in quotes), but
   * is less flexible and likely slower than readCSVWithHeader()
   * @param csvContents The char[] array corresponding to the contents of the file
   * @param numColumns The number of columns in the file (for verification, primarily)
   * @return A list of lines in the file
   */
  public static LinkedList&lt;String[]&gt; readCSVStrictly(char[] csvContents, int numColumns){
    //--Variables
<span class="nc" id="L1401">    StringBuilder[] buffer = new StringBuilder[numColumns];</span>
<span class="nc" id="L1402">    buffer[0] = new StringBuilder();</span>
<span class="nc" id="L1403">    LinkedList&lt;String[]&gt; lines = new LinkedList&lt;&gt;();</span>
    //--State
<span class="nc" id="L1405">    boolean inQuotes = false;</span>
<span class="nc" id="L1406">    boolean nextIsEscaped = false;</span>
<span class="nc" id="L1407">    int columnI = 0;</span>
    //--Read
<span class="nc bnc" id="L1409" title="All 2 branches missed.">    for(int offset=0; offset&lt;csvContents.length; offset++){</span>
<span class="nc bnc" id="L1410" title="All 2 branches missed.">      if(nextIsEscaped){</span>
<span class="nc" id="L1411">        buffer[columnI].append(csvContents[offset]);</span>
<span class="nc" id="L1412">        nextIsEscaped = false;</span>
      } else {
<span class="nc bnc" id="L1414" title="All 5 branches missed.">        switch(csvContents[offset]){</span>
          case '&quot;':
            //(case: quotes)
<span class="nc bnc" id="L1417" title="All 2 branches missed.">            inQuotes = !inQuotes;</span>
<span class="nc" id="L1418">            break;</span>
          case ',':
            //(case: field separator)
<span class="nc bnc" id="L1421" title="All 2 branches missed.">            if(inQuotes){</span>
<span class="nc" id="L1422">              buffer[columnI].append(',');</span>
            } else {
<span class="nc" id="L1424">              columnI += 1;</span>
<span class="nc bnc" id="L1425" title="All 2 branches missed.">              if(columnI &gt;= numColumns){</span>
<span class="nc" id="L1426">                throw new IllegalArgumentException(&quot;Too many columns: &quot;+columnI+&quot;/&quot;+numColumns+&quot; (offset: &quot; + offset + &quot;)&quot;);</span>
              }
<span class="nc" id="L1428">              buffer[columnI] = new StringBuilder();</span>
            }
<span class="nc" id="L1430">            break;</span>
          case '\n':
            //(case: newline)
<span class="nc bnc" id="L1433" title="All 2 branches missed.">            if(inQuotes){</span>
<span class="nc" id="L1434">              buffer[columnI].append('\n');</span>
            } else {
              //((error checks))
<span class="nc bnc" id="L1437" title="All 2 branches missed.">              if(columnI != numColumns-1){</span>
<span class="nc" id="L1438">                throw new IllegalArgumentException(&quot;Too few columns: &quot;+columnI+&quot;/&quot;+numColumns+&quot; (offset: &quot; + offset + &quot;)&quot;);</span>
              }
              //((create line))
<span class="nc" id="L1441">              String[] rtn = new String[buffer.length];</span>
<span class="nc bnc" id="L1442" title="All 2 branches missed.">              for(int i=0; i&lt;buffer.length; i++){ rtn[i] = buffer[i].toString(); }</span>
<span class="nc" id="L1443">              lines.add(rtn);</span>
              //((update state))
<span class="nc" id="L1445">              columnI = 0;</span>
<span class="nc" id="L1446">              buffer[columnI] = new StringBuilder();</span>
            }
<span class="nc" id="L1448">            break;</span>
          case '\\':
<span class="nc" id="L1450">            nextIsEscaped = true;</span>
<span class="nc" id="L1451">            break;</span>
          default:
<span class="nc" id="L1453">            buffer[columnI].append(csvContents[offset]);</span>
        }
      }
    }
    //--Return
<span class="nc" id="L1458">    return lines;</span>
  }

  public static LinkedList&lt;String[]&gt; readCSVStrictly(String filename, int numColumns) throws IOException {
<span class="nc" id="L1462">    return readCSVStrictly(slurpFile(filename).toCharArray(), numColumns);</span>
  }

  /**
   * Get a input file stream (automatically gunzip/bunzip2 depending on file extension)
   * @param filename Name of file to open
   * @return Input stream that can be used to read from the file
   * @throws IOException if there are exceptions opening the file
   */
  public static InputStream getFileInputStream(String filename) throws IOException {
<span class="nc" id="L1472">    InputStream in = new FileInputStream(filename);</span>
<span class="nc bnc" id="L1473" title="All 2 branches missed.">    if (filename.endsWith(&quot;.gz&quot;)) {</span>
<span class="nc" id="L1474">      in = new GZIPInputStream(in);</span>
<span class="nc bnc" id="L1475" title="All 2 branches missed.">    } else if (filename.endsWith(&quot;.bz2&quot;)) {</span>
      //in = new CBZip2InputStream(in);
<span class="nc" id="L1477">      in = getBZip2PipedInputStream(filename);</span>
    }
<span class="nc" id="L1479">    return in;</span>
  }

  /**
   * Get a output file stream (automatically gzip/bzip2 depending on file extension)
   * @param filename Name of file to open
   * @return Output stream that can be used to write to the file
   * @throws IOException if there are exceptions opening the file
   */
  public static OutputStream getFileOutputStream(String filename) throws IOException {
<span class="fc" id="L1489">    OutputStream out = new FileOutputStream(filename);</span>
<span class="pc bpc" id="L1490" title="1 of 2 branches missed.">    if (filename.endsWith(&quot;.gz&quot;)) {</span>
<span class="fc" id="L1491">      out = new GZIPOutputStream(out);</span>
<span class="nc bnc" id="L1492" title="All 2 branches missed.">    } else if (filename.endsWith(&quot;.bz2&quot;)) {</span>
      //out = new CBZip2OutputStream(out);
<span class="nc" id="L1494">      out = getBZip2PipedOutputStream(filename);</span>
    }
<span class="fc" id="L1496">    return out;</span>
  }

  public static OutputStream getFileOutputStream(String filename, boolean append) throws IOException {
<span class="nc" id="L1500">    OutputStream out = new FileOutputStream(filename, append);</span>
<span class="nc bnc" id="L1501" title="All 2 branches missed.">    if (filename.endsWith(&quot;.gz&quot;)) {</span>
<span class="nc" id="L1502">      out = new GZIPOutputStream(out);</span>
<span class="nc bnc" id="L1503" title="All 2 branches missed.">    } else if (filename.endsWith(&quot;.bz2&quot;)) {</span>
      //out = new CBZip2OutputStream(out);
<span class="nc" id="L1505">      out = getBZip2PipedOutputStream(filename);</span>
    }
<span class="nc" id="L1507">    return out;</span>
  }

  /** @deprecated Just call readerFromString(filename) */
  @Deprecated
  public static BufferedReader getBufferedFileReader(String filename) throws IOException {
<span class="nc" id="L1513">    return readerFromString(filename, defaultEncoding);</span>
  }

  /** @deprecated Just call readerFromString(filename) */
  @Deprecated
  public static BufferedReader getBufferedReaderFromClasspathOrFileSystem(String filename) throws IOException {
<span class="nc" id="L1519">    return readerFromString(filename, defaultEncoding);</span>
  }

  public static PrintWriter getPrintWriter(File textFile) throws IOException {
<span class="nc" id="L1523">    return getPrintWriter(textFile, null);</span>
  }

  public static PrintWriter getPrintWriter(File textFile, String encoding) throws IOException {
<span class="nc" id="L1527">    File f = textFile.getAbsoluteFile();</span>
<span class="nc bnc" id="L1528" title="All 2 branches missed.">    if (encoding == null) {</span>
<span class="nc" id="L1529">      encoding = defaultEncoding;</span>
    }
<span class="nc" id="L1531">    return new PrintWriter(new BufferedWriter(new OutputStreamWriter(new FileOutputStream(f), encoding)), true);</span>
  }

  public static PrintWriter getPrintWriter(String filename) throws IOException {
<span class="fc" id="L1535">    return getPrintWriter(filename, defaultEncoding);</span>
  }

  public static PrintWriter getPrintWriterIgnoringExceptions(String filename) {
    try {
<span class="nc" id="L1540">      return getPrintWriter(filename, defaultEncoding);</span>
<span class="nc" id="L1541">    } catch (IOException ioe) {</span>
<span class="nc" id="L1542">      return null;</span>
    }
  }

  public static PrintWriter getPrintWriterOrDie(String filename) {
    try {
<span class="nc" id="L1548">      return getPrintWriter(filename, defaultEncoding);</span>
<span class="nc" id="L1549">    } catch (IOException ioe) {</span>
<span class="nc" id="L1550">      throw new RuntimeIOException(ioe);</span>
    }
  }

  public static PrintWriter getPrintWriter(String filename, String encoding) throws IOException {
<span class="fc" id="L1555">    OutputStream out = getFileOutputStream(filename);</span>
<span class="pc bpc" id="L1556" title="1 of 2 branches missed.">    if (encoding == null) {</span>
<span class="nc" id="L1557">      encoding = defaultEncoding;</span>
    }
<span class="fc" id="L1559">    return new PrintWriter(new BufferedWriter(new OutputStreamWriter(out, encoding)), true);</span>
  }

  public static InputStream getBZip2PipedInputStream(String filename) throws IOException {
<span class="nc" id="L1563">    String bzcat = System.getProperty(&quot;bzcat&quot;, &quot;bzcat&quot;);</span>
<span class="nc" id="L1564">    Runtime rt = Runtime.getRuntime();</span>
<span class="nc" id="L1565">    String cmd = bzcat + &quot; &quot; + filename;</span>
    //log.info(&quot;getBZip2PipedInputStream: Running command: &quot;+cmd);
<span class="nc" id="L1567">    Process p = rt.exec(cmd);</span>
<span class="nc" id="L1568">    Writer errWriter = new BufferedWriter(new OutputStreamWriter(System.err));</span>
<span class="nc" id="L1569">    StreamGobbler errGobbler = new StreamGobbler(p.getErrorStream(), errWriter);</span>
<span class="nc" id="L1570">    errGobbler.start();</span>
<span class="nc" id="L1571">    return p.getInputStream();</span>
  }

  public static OutputStream getBZip2PipedOutputStream(String filename) throws IOException {
<span class="nc" id="L1575">    return new BZip2PipedOutputStream(filename);</span>
  }

<span class="fc" id="L1578">  private static final Pattern tab = Pattern.compile(&quot;\t&quot;);</span>
  /**
   * Read column as set
   * @param infile - filename
   * @param field  index of field to read
   * @return a set of the entries in column field
   * @throws IOException
   */
  public static Set&lt;String&gt; readColumnSet(String infile, int field) throws IOException {
<span class="nc" id="L1587">    BufferedReader br = IOUtils.getBufferedFileReader(infile);</span>

<span class="nc" id="L1589">    Set&lt;String&gt; set = Generics.newHashSet();</span>
<span class="nc bnc" id="L1590" title="All 2 branches missed.">    for (String line; (line = br.readLine()) != null; ) {</span>
<span class="nc" id="L1591">      line = line.trim();</span>
<span class="nc bnc" id="L1592" title="All 2 branches missed.">      if (line.length() &gt; 0) {</span>
<span class="nc bnc" id="L1593" title="All 2 branches missed.">        if (field &lt; 0) {</span>
<span class="nc" id="L1594">          set.add(line);</span>
        } else {
<span class="nc" id="L1596">          String[] fields = tab.split(line);</span>
<span class="nc bnc" id="L1597" title="All 2 branches missed.">          if (field &lt; fields.length) {</span>
<span class="nc" id="L1598">            set.add(fields[field]);</span>
          }
<span class="nc" id="L1600">        }</span>
      }
    }
<span class="nc" id="L1603">    br.close();</span>
<span class="nc" id="L1604">    return set;</span>
  }

  public static &lt;C&gt; List&lt;C&gt; readObjectFromColumns(Class objClass, String filename, String[] fieldNames, String delimiter)
          throws IOException, InstantiationException, IllegalAccessException,
          NoSuchFieldException, NoSuchMethodException, InvocationTargetException
  {
<span class="nc" id="L1611">    Pattern delimiterPattern = Pattern.compile(delimiter);</span>
<span class="nc" id="L1612">    List&lt;C&gt; list = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1613">    BufferedReader br = IOUtils.getBufferedFileReader(filename);</span>
<span class="nc bnc" id="L1614" title="All 2 branches missed.">    for (String line; (line = br.readLine()) != null; ) {</span>
<span class="nc" id="L1615">      line = line.trim();</span>
<span class="nc bnc" id="L1616" title="All 2 branches missed.">      if (line.length() &gt; 0) {</span>
<span class="nc" id="L1617">        C item = StringUtils.columnStringToObject(objClass, line, delimiterPattern, fieldNames);</span>
<span class="nc" id="L1618">        list.add(item);</span>
<span class="nc" id="L1619">      }</span>
    }
<span class="nc" id="L1621">    br.close();</span>
<span class="nc" id="L1622">    return list;</span>
  }

  public static Map&lt;String,String&gt; readMap(String filename) throws IOException {
<span class="nc" id="L1626">    Map&lt;String,String&gt; map = Generics.newHashMap();</span>
    try {
<span class="nc" id="L1628">      BufferedReader br = IOUtils.getBufferedFileReader(filename);</span>

<span class="nc bnc" id="L1630" title="All 2 branches missed.">      for (String line; (line = br.readLine()) != null; ) {</span>
<span class="nc" id="L1631">        String[] fields = tab.split(line,2);</span>
<span class="nc" id="L1632">        map.put(fields[0], fields[1]);</span>
<span class="nc" id="L1633">      }</span>
<span class="nc" id="L1634">      br.close();</span>
<span class="nc" id="L1635">    } catch (IOException ex) {</span>
<span class="nc" id="L1636">      throw new RuntimeException(ex);</span>
<span class="nc" id="L1637">    }</span>
<span class="nc" id="L1638">    return map;</span>
  }


  /**
   * Returns the contents of a file as a single string.  The string may be
   * empty, if the file is empty.  If there is an IOException, it is caught
   * and null is returned.
   */
  public static String stringFromFile(String filename) {
<span class="nc" id="L1648">    return stringFromFile(filename, defaultEncoding);</span>
  }

  /**
   * Returns the contents of a file as a single string.  The string may be
   * empty, if the file is empty.  If there is an IOException, it is caught
   * and null is returned.  Encoding can also be specified.
   */
  // todo: This is same as slurpFile (!)
  public static String stringFromFile(String filename, String encoding) {
    try {
<span class="nc" id="L1659">      StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L1660">      BufferedReader in = new BufferedReader(new EncodingFileReader(filename,encoding));</span>
      String line;
<span class="nc bnc" id="L1662" title="All 2 branches missed.">      while ((line = in.readLine()) != null) {</span>
<span class="nc" id="L1663">        sb.append(line);</span>
<span class="nc" id="L1664">        sb.append(eolChar);</span>
      }
<span class="nc" id="L1666">      in.close();</span>
<span class="nc" id="L1667">      return sb.toString();</span>
    }
<span class="nc" id="L1669">    catch (IOException e) {</span>
<span class="nc" id="L1670">      logger.err(throwableToStackTrace(e));</span>
<span class="nc" id="L1671">      return null;</span>
    }
  }


  /**
   * Returns the contents of a file as a list of strings.  The list may be
   * empty, if the file is empty.  If there is an IOException, it is caught
   * and null is returned.
   */
  public static List&lt;String&gt; linesFromFile(String filename) {
<span class="nc" id="L1682">    return linesFromFile(filename, defaultEncoding);</span>
  }

  /**
   * Returns the contents of a file as a list of strings.  The list may be
   * empty, if the file is empty.  If there is an IOException, it is caught
   * and null is returned. Encoding can also be specified
   */
  public static List&lt;String&gt; linesFromFile(String filename,String encoding) {
<span class="nc" id="L1691">    return linesFromFile(filename, encoding, false);</span>
  }

  public static List&lt;String&gt; linesFromFile(String filename,String encoding, boolean ignoreHeader) {
    try {
<span class="nc" id="L1696">      List&lt;String&gt; lines = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1697">      BufferedReader in = readerFromString(filename, encoding);</span>
      String line;
<span class="nc" id="L1699">      int i = 0;</span>
<span class="nc bnc" id="L1700" title="All 2 branches missed.">      while ((line = in.readLine()) != null) {</span>
<span class="nc" id="L1701">        i++;</span>
<span class="nc bnc" id="L1702" title="All 4 branches missed.">        if(ignoreHeader &amp;&amp; i == 1)</span>
<span class="nc" id="L1703">          continue;</span>
<span class="nc" id="L1704">        lines.add(line);</span>
      }
<span class="nc" id="L1706">      in.close();</span>
<span class="nc" id="L1707">      return lines;</span>
    }
<span class="nc" id="L1709">    catch (IOException e) {</span>
<span class="nc" id="L1710">      logger.err(throwableToStackTrace(e));</span>
<span class="nc" id="L1711">      return null;</span>
    }
  }


  /**
   * A JavaNLP specific convenience routine for obtaining the current
   * scratch directory for the machine you're currently running on.
   */
  public static File getJNLPLocalScratch()  {
    try {
<span class="nc" id="L1722">      String machineName = InetAddress.getLocalHost().getHostName().split(&quot;\\.&quot;)[0];</span>
<span class="nc" id="L1723">      String username = System.getProperty(&quot;user.name&quot;);</span>
<span class="nc" id="L1724">      return new File(&quot;/&quot;+machineName+&quot;/scr1/&quot;+username);</span>
<span class="nc" id="L1725">    } catch (Exception e) {</span>
<span class="nc" id="L1726">      return new File(&quot;./scr/&quot;); // default scratch</span>
    }
  }

  /**
   * Given a filepath, makes sure a directory exists there.  If not, creates and returns it.
   * Same as ENSURE-DIRECTORY in CL.
   *
   * @param tgtDir The directory that you wish to ensure exists
   * @throws IOException If directory can't be created, is an existing file, or for other reasons
   */
  public static File ensureDir(File tgtDir) throws IOException {
<span class="nc bnc" id="L1738" title="All 2 branches missed.">    if (tgtDir.exists()) {</span>
<span class="nc bnc" id="L1739" title="All 2 branches missed.">      if (tgtDir.isDirectory()) {</span>
<span class="nc" id="L1740">        return tgtDir;</span>
      } else {
<span class="nc" id="L1742">        throw new IOException(&quot;Could not create directory &quot;+tgtDir.getAbsolutePath()+&quot;, as a file already exists at that path.&quot;);</span>
      }
    } else {
<span class="nc bnc" id="L1745" title="All 2 branches missed.">      if ( ! tgtDir.mkdirs()) {</span>
<span class="nc" id="L1746">        throw new IOException(&quot;Could not create directory &quot;+tgtDir.getAbsolutePath());</span>
      }
<span class="nc" id="L1748">      return tgtDir;</span>
    }
  }

  /**
   * Given a filepath, delete all files in the directory recursively
   * @param dir Directory from which to delete files
   * @return {@code true} if the deletion is successful, {@code false} otherwise
   */
  public static boolean deleteDirRecursively(File dir) {
<span class="nc bnc" id="L1758" title="All 2 branches missed.">    if (dir.isDirectory()) {</span>
<span class="nc bnc" id="L1759" title="All 2 branches missed.">      for (File f : dir.listFiles()) {</span>
<span class="nc" id="L1760">        boolean success = deleteDirRecursively(f);</span>
<span class="nc bnc" id="L1761" title="All 2 branches missed.">        if (!success)</span>
<span class="nc" id="L1762">          return false;</span>
      }
    }
<span class="nc" id="L1765">    return dir.delete();</span>
  }

  public static String getExtension(String fileName) {
<span class="nc bnc" id="L1769" title="All 2 branches missed.">    if(!fileName.contains(&quot;.&quot;))</span>
<span class="nc" id="L1770">      return null;</span>
<span class="nc" id="L1771">    int idx = fileName.lastIndexOf('.');</span>
<span class="nc" id="L1772">    return fileName.substring(idx+1);</span>
  }


  /** Create a Reader with an explicit encoding around an InputStream.
   *  This static method will treat null as meaning to use the platform default,
   *  unlike the Java library methods that disallow a null encoding.
   *
   *  @param stream An InputStream
   *  @param encoding A charset encoding
   *  @return A Reader
   *  @throws IOException If any IO problem
   */
  public static Reader encodedInputStreamReader(InputStream stream, String encoding) throws IOException {
    // InputStreamReader doesn't allow encoding to be null;
<span class="pc bpc" id="L1787" title="1 of 2 branches missed.">    if (encoding == null) {</span>
<span class="fc" id="L1788">      return new InputStreamReader(stream);</span>
    } else {
<span class="nc" id="L1790">      return new InputStreamReader(stream, encoding);</span>
    }
  }


  /** Create a Reader with an explicit encoding around an InputStream.
   *  This static method will treat null as meaning to use the platform default,
   *  unlike the Java library methods that disallow a null encoding.
   *
   *  @param stream An InputStream
   *  @param encoding A charset encoding
   *  @return A Reader
   *  @throws IOException If any IO problem
   */
  public static Writer encodedOutputStreamWriter(OutputStream stream, String encoding) throws IOException {
    // OutputStreamWriter doesn't allow encoding to be null;
<span class="pc bpc" id="L1806" title="1 of 2 branches missed.">    if (encoding == null) {</span>
<span class="nc" id="L1807">      return new OutputStreamWriter(stream);</span>
    } else {
<span class="fc" id="L1809">      return new OutputStreamWriter(stream, encoding);</span>
    }
  }


  /** Create a Reader with an explicit encoding around an InputStream.
   *  This static method will treat null as meaning to use the platform default,
   *  unlike the Java library methods that disallow a null encoding.
   *
   *  @param stream An InputStream
   *  @param encoding A charset encoding
   *  @param autoFlush Whether to make an autoflushing Writer
   *  @return A Reader
   *  @throws IOException If any IO problem
   */
  public static PrintWriter encodedOutputStreamPrintWriter(OutputStream stream,
                                                           String encoding, boolean autoFlush) throws IOException {
    // PrintWriter doesn't allow encoding to be null; or to have charset and flush
<span class="nc bnc" id="L1827" title="All 2 branches missed.">    if (encoding == null) {</span>
<span class="nc" id="L1828">      return new PrintWriter(stream, autoFlush);</span>
    } else {
<span class="nc" id="L1830">      return new PrintWriter(new OutputStreamWriter(stream, encoding), autoFlush);</span>
    }
  }


  /**
   * A raw file copy function -- this is not public since no error checks are made as to the
   * consistency of the file being copied. Use instead:
   * @see IOUtils#cp(java.io.File, java.io.File, boolean)
   * @param source The source file. This is guaranteed to exist, and is guaranteed to be a file.
   * @param target The target file.
   * @throws IOException Throws an exception if the copy fails.
   */
  private static void copyFile(File source, File target) throws IOException {
<span class="fc" id="L1844">    FileChannel sourceChannel = new FileInputStream( source ).getChannel();</span>
<span class="fc" id="L1845">    FileChannel targetChannel = new FileOutputStream( target ).getChannel();</span>

    // allow for the case that it doesn't all transfer in one go (though it probably does for a file cp)
<span class="fc" id="L1848">    long pos = 0;</span>
<span class="fc" id="L1849">    long toCopy = sourceChannel.size();</span>
<span class="fc bfc" id="L1850" title="All 2 branches covered.">    while (toCopy &gt; 0) {</span>
<span class="fc" id="L1851">      long bytes = sourceChannel.transferTo(pos, toCopy, targetChannel);</span>
<span class="fc" id="L1852">      pos += bytes;</span>
<span class="fc" id="L1853">      toCopy -= bytes;</span>
<span class="fc" id="L1854">    }</span>

<span class="fc" id="L1856">    sourceChannel.close();</span>
<span class="fc" id="L1857">    targetChannel.close();</span>
<span class="fc" id="L1858">  }</span>


  /**
   * &lt;p&gt;An implementation of cp, as close to the Unix command as possible.
   * Both directories and files are valid for either the source or the target;
   * if the target exists, the semantics of Unix cp are [intended to be] obeyed.&lt;/p&gt;
   *
   * @param source The source file or directory.
   * @param target The target to write this file or directory to.
   * @param recursive If true, recursively copy directory contents
   * @throws IOException If either the copy fails (standard IO Exception), or the command is invalid
   *                     (e.g., copying a directory without the recursive flag)
   */
  public static void cp(File source, File target, boolean recursive) throws IOException {
    // Error checks
<span class="pc bpc" id="L1874" title="1 of 4 branches missed.">    if (source.isDirectory() &amp;&amp; !recursive) {</span>
      // cp a b -- a is a directory
<span class="nc" id="L1876">      throw new IOException(&quot;cp: omitting directory: &quot; + source);</span>
    }
<span class="pc bpc" id="L1878" title="1 of 2 branches missed.">    if (!target.getParentFile().exists()) {</span>
      // cp a b/c/d/e -- b/c/d doesn't exist
<span class="nc" id="L1880">      throw new IOException(&quot;cp: cannot copy to directory: &quot; + recursive + &quot; (parent doesn't exist)&quot;);</span>
    }
<span class="pc bpc" id="L1882" title="1 of 2 branches missed.">    if (!target.getParentFile().isDirectory()) {</span>
      // cp a b/c/d/e -- b/c/d is a regular file
<span class="nc" id="L1884">      throw new IOException(&quot;cp: cannot copy to directory: &quot; + recursive + &quot; (parent isn't a directory)&quot;);</span>
    }
    // Get true target
    File trueTarget;
<span class="fc bfc" id="L1888" title="All 4 branches covered.">    if (target.exists() &amp;&amp; target.isDirectory()) {</span>
<span class="fc" id="L1889">      trueTarget = new File(target.getPath() + File.separator + source.getName());</span>
    } else {
<span class="fc" id="L1891">      trueTarget = target;</span>
    }
    // Copy
<span class="fc bfc" id="L1894" title="All 2 branches covered.">    if (source.isFile()) {</span>
      // Case: copying a file
<span class="fc" id="L1896">      copyFile(source, trueTarget);</span>
<span class="pc bpc" id="L1897" title="1 of 2 branches missed.">    } else if (source.isDirectory()) {</span>
      // Case: copying a directory
<span class="fc" id="L1899">      File[] children = source.listFiles();</span>
<span class="pc bpc" id="L1900" title="1 of 2 branches missed.">      if (children == null) { throw new IOException(&quot;cp: could not list files in source: &quot; + source); }</span>

<span class="fc bfc" id="L1902" title="All 2 branches covered.">      if (target.exists()) {</span>
        // Case: cp -r a b -- b exists
<span class="pc bpc" id="L1904" title="1 of 2 branches missed.">        if (!target.isDirectory()) {</span>
          // cp -r a b -- b is a regular file
<span class="nc" id="L1906">          throw new IOException(&quot;cp: cannot copy directory into regular file: &quot; + target);</span>
        }
<span class="pc bpc" id="L1908" title="3 of 4 branches missed.">        if (trueTarget.exists() &amp;&amp; !trueTarget.isDirectory()) {</span>
          // cp -r a b -- b/a is not a directory
<span class="nc" id="L1910">          throw new IOException(&quot;cp: overwriting a file with a directory: &quot; + trueTarget);</span>
        }
<span class="pc bpc" id="L1912" title="2 of 4 branches missed.">        if (!trueTarget.exists() &amp;&amp; !trueTarget.mkdir()) {</span>
          // cp -r a b -- b/a cannot be created
<span class="nc" id="L1914">          throw new IOException(&quot;cp: could not create directory: &quot; + trueTarget);</span>
        }
      } else {
        // Case: cp -r a b -- b does not exist
<span class="pc bpc" id="L1918" title="2 of 4 branches missed.">        assert trueTarget == target;</span>
<span class="pc bpc" id="L1919" title="1 of 2 branches missed.">        if (!trueTarget.mkdir()) {</span>
          // cp -r a b -- cannot create b as a directory
<span class="nc" id="L1921">          throw new IOException(&quot;cp: could not create target directory: &quot; + trueTarget);</span>
        }
      }
      // Actually do the copy
<span class="fc bfc" id="L1925" title="All 2 branches covered.">      for (File child : children) {</span>
<span class="fc" id="L1926">        File childTarget = new File(trueTarget.getPath() + File.separator + child.getName());</span>
<span class="fc" id="L1927">        cp(child, childTarget, recursive);</span>
      }
<span class="fc" id="L1929">    } else {</span>
<span class="nc" id="L1930">      throw new IOException(&quot;cp: unknown file type: &quot; + source);</span>
    }
<span class="fc" id="L1932">  }</span>

  /**
   * @see IOUtils#cp(java.io.File, java.io.File, boolean)
   */
<span class="fc" id="L1937">  public static void cp(File source, File target) throws IOException { cp(source, target, false); }</span>

  /**
   * A Java implementation of the Unix tail functionality.
   * That is, read the last n lines of the input file f.
   * @param f The file to read the last n lines from
   * @param n The number of lines to read from the end of the file.
   * @param encoding The encoding to read the file in.
   * @return The read lines, one String per line.
   * @throws IOException if the file could not be read.
   */
  public static String[] tail(File f, int n, String encoding) throws IOException {
<span class="fc bfc" id="L1949" title="All 2 branches covered.">    if (n == 0) { return new String[0]; }</span>
    // Variables
<span class="fc" id="L1951">    RandomAccessFile raf = new RandomAccessFile(f, &quot;r&quot;);</span>
<span class="fc" id="L1952">    int linesRead = 0;</span>
<span class="fc" id="L1953">    List&lt;Byte&gt; bytes = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1954">    List&lt;String&gt; linesReversed = new ArrayList&lt;&gt;();</span>
    // Seek to end of file
<span class="fc" id="L1956">    long length = raf.length() - 1;</span>
<span class="fc" id="L1957">    raf.seek(length);</span>
    // Read backwards
<span class="fc bfc" id="L1959" title="All 2 branches covered.">    for(long seek = length; seek &gt;= 0; --seek){</span>
      // Seek back
<span class="fc" id="L1961">      raf.seek(seek);</span>
      // Read the next character
<span class="fc" id="L1963">      byte c = raf.readByte();</span>
<span class="fc bfc" id="L1964" title="All 2 branches covered.">      if(c == '\n'){</span>
        // If it's a newline, handle adding the line
<span class="fc" id="L1966">        byte[] str = new byte[bytes.size()];</span>
<span class="fc bfc" id="L1967" title="All 2 branches covered.">        for (int i = 0; i &lt; str.length; ++i) {</span>
<span class="fc" id="L1968">          str[i] = bytes.get(str.length - i - 1);</span>
        }
<span class="fc" id="L1970">        linesReversed.add(new String(str, encoding));</span>
<span class="fc" id="L1971">        bytes = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1972">        linesRead += 1;</span>
<span class="fc bfc" id="L1973" title="All 2 branches covered.">        if (linesRead == n){</span>
<span class="fc" id="L1974">          break;</span>
        }
<span class="fc" id="L1976">      } else {</span>
        // Else, register the character for later
<span class="fc" id="L1978">        bytes.add(c);</span>
      }
    }
    // Add any remaining lines
<span class="pc bpc" id="L1982" title="1 of 4 branches missed.">    if (linesRead &lt; n &amp;&amp; bytes.size() &gt; 0) {</span>
<span class="fc" id="L1983">      byte[] str = new byte[bytes.size()];</span>
<span class="fc bfc" id="L1984" title="All 2 branches covered.">      for (int i = 0; i &lt; str.length; ++i) {</span>
<span class="fc" id="L1985">        str[i] = bytes.get(str.length - i - 1);</span>
      }
<span class="fc" id="L1987">      linesReversed.add(new String(str, encoding));</span>
    }
    // Create output
<span class="fc" id="L1990">    String[] rtn = new String[linesReversed.size()];</span>
<span class="fc bfc" id="L1991" title="All 2 branches covered.">    for (int i = 0; i &lt; rtn.length; ++i) {</span>
<span class="fc" id="L1992">      rtn[i] = linesReversed.get(rtn.length - i - 1);</span>
    }
<span class="fc" id="L1994">    raf.close();</span>
<span class="fc" id="L1995">    return rtn;</span>
  }

  /** @see edu.stanford.nlp.io.IOUtils#tail(java.io.File, int, String) */
<span class="fc" id="L1999">  public static String[] tail(File f, int n) throws IOException { return tail(f, n, &quot;utf-8&quot;); }</span>

  /** Bare minimum sanity checks */
<span class="fc" id="L2002">  private static Set&lt;String&gt; blacklistedPathsToRemove = new HashSet&lt;String&gt;(){{</span>
<span class="fc" id="L2003">    add(&quot;/&quot;);</span>
<span class="fc" id="L2004">    add(&quot;/u&quot;); add(&quot;/u/&quot;);</span>
<span class="fc" id="L2005">    add(&quot;/u/nlp&quot;); add(&quot;/u/nlp/&quot;);</span>
<span class="fc" id="L2006">    add(&quot;/u/nlp/data&quot;); add(&quot;/u/nlp/data/&quot;);</span>
<span class="fc" id="L2007">    add(&quot;/scr&quot;); add(&quot;/scr/&quot;);</span>
<span class="fc" id="L2008">    add(&quot;/scr/nlp/data&quot;); add(&quot;/scr/nlp/data/&quot;);</span>
<span class="fc" id="L2009">  }};</span>

  /**
   * Delete this file; or, if it is a directory, delete this directory and all its contents.
   * This is a somewhat dangerous function to call from code, and so a few safety features have been
   * implemented (though you should not rely on these!):
   *
   * &lt;ul&gt;
   *   &lt;li&gt;Certain directories are prohibited from being removed.&lt;/li&gt;
   *   &lt;li&gt;More than 100 files cannot be removed with this function.&lt;/li&gt;
   *   &lt;li&gt;More than 10GB cannot be removed with this function.&lt;/li&gt;
   * &lt;/ul&gt;
   *
   * @param file The file or directory to delete.
   */
  public static void deleteRecursively(File file) {
    // Sanity checks
<span class="nc bnc" id="L2026" title="All 2 branches missed.">    if (blacklistedPathsToRemove.contains(file.getPath())) {</span>
<span class="nc" id="L2027">      throw new IllegalArgumentException(&quot;You're trying to delete &quot; + file + &quot;! I _really_ don't think you want to do that...&quot;);</span>
    }
<span class="nc" id="L2029">    int count = 0;</span>
<span class="nc" id="L2030">    long size = 0;</span>
<span class="nc bnc" id="L2031" title="All 2 branches missed.">    for (File f : iterFilesRecursive(file)) {</span>
<span class="nc" id="L2032">      count += 1;</span>
<span class="nc" id="L2033">      size += f.length();</span>
<span class="nc" id="L2034">    }</span>
<span class="nc bnc" id="L2035" title="All 2 branches missed.">    if (count &gt; 100) {</span>
<span class="nc" id="L2036">      throw new IllegalArgumentException(&quot;Deleting more than 100 files; you should do this manually&quot;);</span>
    }
<span class="nc bnc" id="L2038" title="All 2 branches missed.">    if (size &gt; 10000000000L) {  // 10 GB</span>
<span class="nc" id="L2039">      throw new IllegalArgumentException(&quot;Deleting more than 10GB; you should do this manually&quot;);</span>
    }
    // Do delete
<span class="nc bnc" id="L2042" title="All 2 branches missed.">    if (file.isDirectory()) {</span>
<span class="nc" id="L2043">      File[] children = file.listFiles();</span>
<span class="nc bnc" id="L2044" title="All 2 branches missed.">      if (children != null) {</span>
<span class="nc bnc" id="L2045" title="All 2 branches missed.">        for (File child : children) {</span>
<span class="nc" id="L2046">          deleteRecursively(child);</span>
        }
      }
    }
    //noinspection ResultOfMethodCallIgnored
<span class="nc" id="L2051">    file.delete();</span>
<span class="nc" id="L2052">  }</span>

  /**
   * Start a simple console. Read lines from stdin, and pass each line to the callback.
   * Returns on typing &quot;exit&quot; or &quot;quit&quot;.
   *
   * @param callback The function to run for every line of input.
   * @throws IOException Thrown from the underlying input stream.
   */
    public static void console(String prompt, Consumer&lt;String&gt; callback) throws IOException {
<span class="nc" id="L2062">    BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));</span>
    String line;
<span class="nc" id="L2064">    System.out.print(prompt);</span>
<span class="nc bnc" id="L2065" title="All 2 branches missed.">    while ( (line = reader.readLine()) != null) {</span>
<span class="nc bnc" id="L2066" title="All 16 branches missed.">      switch (line.toLowerCase()) {</span>
        case &quot;&quot;:
<span class="nc" id="L2068">          break;</span>
        case &quot;exit&quot;:
        case &quot;quit&quot;:
        case &quot;q&quot;:
<span class="nc" id="L2072">          return;</span>
        default:
<span class="nc" id="L2074">          callback.accept(line);</span>
          break;
      }
<span class="nc" id="L2077">      System.out.print(prompt);</span>
    }
<span class="nc" id="L2079">  }</span>

  /**
   * Create a prompt, and read a single line of response.
   * @param prompt An optional prompt to show the user.
   * @throws IOException Throw from the underlying reader.
   */
  public static String promptUserInput(Optional&lt;String&gt; prompt) throws IOException {
<span class="nc" id="L2087">    BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));</span>
<span class="nc" id="L2088">    System.out.print(prompt.orElse(&quot;&gt; &quot;));</span>
<span class="nc" id="L2089">    return reader.readLine();</span>
  }

  /** @see IOUtils#console(String, Consumer) */
  public static void console(Consumer&lt;String&gt; callback) throws IOException {
<span class="nc" id="L2094">    console(&quot;&gt; &quot;, callback);</span>
<span class="nc" id="L2095">  }</span>

  public static String throwableToStackTrace(Throwable t) {
<span class="nc" id="L2098">    StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L2099">    sb.append(t).append(eolChar);</span>

<span class="nc bnc" id="L2101" title="All 2 branches missed.">    for (StackTraceElement e : t.getStackTrace()) {</span>
<span class="nc" id="L2102">        sb.append(&quot;\t at &quot;).append(e).append(eolChar);</span>
    }
<span class="nc" id="L2104">    return sb.toString();</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>