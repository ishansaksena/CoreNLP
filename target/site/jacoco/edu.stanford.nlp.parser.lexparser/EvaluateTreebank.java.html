<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>EvaluateTreebank.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.parser.lexparser</a> &gt; <span class="el_source">EvaluateTreebank.java</span></div><h1>EvaluateTreebank.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.parser.lexparser; 
import edu.stanford.nlp.util.logging.Redwood;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;

import edu.stanford.nlp.io.NullOutputStream;
import edu.stanford.nlp.ling.*;
import edu.stanford.nlp.ling.SentenceUtils;
import edu.stanford.nlp.math.ArrayMath;
import edu.stanford.nlp.parser.common.NoSuchParseException;
import edu.stanford.nlp.parser.common.ParserGrammar;
import edu.stanford.nlp.parser.common.ParserQuery;
import edu.stanford.nlp.parser.common.ParserUtils;
import edu.stanford.nlp.parser.common.ParsingThreadsafeProcessor;
import edu.stanford.nlp.parser.metrics.AbstractEval;
import edu.stanford.nlp.parser.metrics.BestOfTopKEval;
import edu.stanford.nlp.parser.metrics.Eval;
import edu.stanford.nlp.parser.metrics.Evalb;
import edu.stanford.nlp.parser.metrics.EvalbByCat;
import edu.stanford.nlp.parser.metrics.FilteredEval;
import edu.stanford.nlp.parser.metrics.LeafAncestorEval;
import edu.stanford.nlp.parser.metrics.ParserQueryEval;
import edu.stanford.nlp.parser.metrics.TaggingEval;
import edu.stanford.nlp.parser.metrics.TopMatchEval;
import edu.stanford.nlp.parser.metrics.UnlabeledAttachmentEval;
import edu.stanford.nlp.trees.LeftHeadFinder;
import edu.stanford.nlp.trees.Tree;
import edu.stanford.nlp.trees.Treebank;
import edu.stanford.nlp.trees.TreebankLanguagePack;
import edu.stanford.nlp.trees.TreePrint;
import edu.stanford.nlp.trees.TreeTransformer;
import java.util.function.Function;
import edu.stanford.nlp.util.Generics;
import edu.stanford.nlp.util.ScoredObject;
import edu.stanford.nlp.util.Timing;
import edu.stanford.nlp.util.concurrent.MulticoreWrapper;

public class EvaluateTreebank  {

  /** A logger for this class */
<span class="nc" id="L50">  private static Redwood.RedwoodChannels log = Redwood.channels(EvaluateTreebank.class);</span>

  private final Options op;
  private final TreeTransformer debinarizer;
  private final TreeTransformer subcategoryStripper;
  private final TreeTransformer collinizer;
  private final TreeTransformer boundaryRemover;

  private final ParserGrammar pqFactory;

  // private final Lexicon lex;

<span class="nc" id="L62">  List&lt;Eval&gt; evals = null;</span>
<span class="nc" id="L63">  List&lt;ParserQueryEval&gt; parserQueryEvals = null;</span>

  private final boolean summary;
  private final boolean tsv;

  // no annotation
  private final TreeAnnotatorAndBinarizer binarizerOnly;

<span class="nc" id="L71">  AbstractEval pcfgLB = null;</span>
<span class="nc" id="L72">  AbstractEval pcfgChildSpecific = null;</span>
<span class="nc" id="L73">  LeafAncestorEval pcfgLA = null;</span>
<span class="nc" id="L74">  AbstractEval pcfgCB = null;</span>
<span class="nc" id="L75">  AbstractEval pcfgDA = null;</span>
<span class="nc" id="L76">  AbstractEval pcfgTA = null;</span>
<span class="nc" id="L77">  AbstractEval depDA = null;</span>
<span class="nc" id="L78">  AbstractEval depTA = null;</span>
<span class="nc" id="L79">  AbstractEval factLB = null;</span>
<span class="nc" id="L80">  AbstractEval factChildSpecific = null;</span>
<span class="nc" id="L81">  LeafAncestorEval factLA = null;</span>
<span class="nc" id="L82">  AbstractEval factCB = null;</span>
<span class="nc" id="L83">  AbstractEval factDA = null;</span>
<span class="nc" id="L84">  AbstractEval factTA = null;</span>
<span class="nc" id="L85">  AbstractEval pcfgRUO = null;</span>
<span class="nc" id="L86">  AbstractEval pcfgCUO = null;</span>
<span class="nc" id="L87">  AbstractEval pcfgCatE = null;</span>
<span class="nc" id="L88">  AbstractEval.ScoreEval pcfgLL = null;</span>
<span class="nc" id="L89">  AbstractEval.ScoreEval depLL = null;</span>
<span class="nc" id="L90">  AbstractEval.ScoreEval factLL = null;</span>
<span class="nc" id="L91">  AbstractEval kGoodLB = null;</span>

<span class="nc" id="L93">  private final List&lt;BestOfTopKEval&gt; topKEvals = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L95">  private int kbestPCFG = 0;</span>

<span class="nc" id="L97">  private int numSkippedEvals = 0;</span>

<span class="nc" id="L99">  private boolean saidMemMessage = false;</span>

  /**
   * The tagger optionally used before parsing.
   * &lt;br&gt;
   * We keep it here as a function rather than a MaxentTagger so that
   * we can distribute a version of the parser that doesn't include
   * the entire tagger.
   */
  protected final Function&lt;List&lt;? extends HasWord&gt;, List&lt;TaggedWord&gt;&gt; tagger;

  public EvaluateTreebank(LexicalizedParser parser) {
<span class="nc" id="L111">    this(parser.getOp(), parser.lex, parser);</span>
<span class="nc" id="L112">  }</span>

  public EvaluateTreebank(Options op, Lexicon lex, ParserGrammar pqFactory) {
<span class="nc" id="L115">    this(op, lex, pqFactory, pqFactory.loadTagger());</span>
<span class="nc" id="L116">  }</span>

<span class="nc" id="L118">  public EvaluateTreebank(Options op, Lexicon lex, ParserGrammar pqFactory, Function&lt;List&lt;? extends HasWord&gt;,List&lt;TaggedWord&gt;&gt; tagger) {</span>
<span class="nc" id="L119">    this.op = op;</span>
<span class="nc" id="L120">    this.debinarizer = new Debinarizer(op.forceCNF);</span>
<span class="nc" id="L121">    this.subcategoryStripper = op.tlpParams.subcategoryStripper();</span>

<span class="nc" id="L123">    this.evals = Generics.newArrayList();</span>
<span class="nc" id="L124">    evals.addAll(pqFactory.getExtraEvals());</span>
<span class="nc" id="L125">    this.parserQueryEvals = pqFactory.getParserQueryEvals();</span>

    // this.lex = lex;
<span class="nc" id="L128">    this.pqFactory = pqFactory;</span>

<span class="nc" id="L130">    this.tagger = tagger;</span>

<span class="nc" id="L132">    collinizer = op.tlpParams.collinizer();</span>
<span class="nc" id="L133">    boundaryRemover = new BoundaryRemover();</span>

<span class="nc" id="L135">    boolean runningAverages = Boolean.parseBoolean(op.testOptions.evals.getProperty(&quot;runningAverages&quot;));</span>
<span class="nc" id="L136">    summary = Boolean.parseBoolean(op.testOptions.evals.getProperty(&quot;summary&quot;));</span>
<span class="nc" id="L137">    tsv = Boolean.parseBoolean(op.testOptions.evals.getProperty(&quot;tsv&quot;));</span>

<span class="nc bnc" id="L139" title="All 2 branches missed.">    if (!op.trainOptions.leftToRight) {</span>
<span class="nc" id="L140">      binarizerOnly = new TreeAnnotatorAndBinarizer(op.tlpParams, op.forceCNF, false, false, op);</span>
    } else {
<span class="nc" id="L142">      binarizerOnly = new TreeAnnotatorAndBinarizer(op.tlpParams.headFinder(), new LeftHeadFinder(), op.tlpParams, op.forceCNF, false, false, op);</span>
    }


<span class="nc bnc" id="L146" title="All 2 branches missed.">    if (Boolean.parseBoolean(op.testOptions.evals.getProperty(&quot;pcfgLB&quot;))) {</span>
<span class="nc" id="L147">      pcfgLB = new Evalb(&quot;pcfg LP/LR&quot;, runningAverages);</span>
    }
    // TODO: might be nice to allow more than one child-specific scorer
<span class="nc bnc" id="L150" title="All 2 branches missed.">    if (op.testOptions.evals.getProperty(&quot;pcfgChildSpecific&quot;) != null) {</span>
<span class="nc" id="L151">      String filter = op.testOptions.evals.getProperty(&quot;pcfgChildSpecific&quot;);</span>
<span class="nc" id="L152">      pcfgChildSpecific = FilteredEval.childFilteredEval(&quot;pcfg children matching &quot; + filter + &quot; LP/LR&quot;, runningAverages, op.langpack(), filter);</span>
    }
<span class="nc bnc" id="L154" title="All 2 branches missed.">    if (Boolean.parseBoolean(op.testOptions.evals.getProperty(&quot;pcfgLA&quot;))) {</span>
<span class="nc" id="L155">      pcfgLA = new LeafAncestorEval(&quot;pcfg LeafAncestor&quot;);</span>
    }
<span class="nc bnc" id="L157" title="All 2 branches missed.">    if (Boolean.parseBoolean(op.testOptions.evals.getProperty(&quot;pcfgCB&quot;))) {</span>
<span class="nc" id="L158">      pcfgCB = new Evalb.CBEval(&quot;pcfg CB&quot;, runningAverages);</span>
    }
<span class="nc bnc" id="L160" title="All 2 branches missed.">    if (Boolean.parseBoolean(op.testOptions.evals.getProperty(&quot;pcfgDA&quot;))) {</span>
<span class="nc" id="L161">      pcfgDA = new UnlabeledAttachmentEval(&quot;pcfg DA&quot;, runningAverages, op.langpack().headFinder());</span>
    }
<span class="nc bnc" id="L163" title="All 2 branches missed.">    if (Boolean.parseBoolean(op.testOptions.evals.getProperty(&quot;pcfgTA&quot;))) {</span>
<span class="nc" id="L164">      pcfgTA = new TaggingEval(&quot;pcfg Tag&quot;, runningAverages, lex);</span>
    }
<span class="nc bnc" id="L166" title="All 2 branches missed.">    if (Boolean.parseBoolean(op.testOptions.evals.getProperty(&quot;depDA&quot;))) {</span>
<span class="nc" id="L167">      depDA = new UnlabeledAttachmentEval(&quot;dep DA&quot;, runningAverages, null, op.langpack().punctuationWordRejectFilter());</span>
    }
<span class="nc bnc" id="L169" title="All 2 branches missed.">    if (Boolean.parseBoolean(op.testOptions.evals.getProperty(&quot;depTA&quot;))) {</span>
<span class="nc" id="L170">      depTA = new TaggingEval(&quot;dep Tag&quot;, runningAverages, lex);</span>
    }
<span class="nc bnc" id="L172" title="All 2 branches missed.">    if (Boolean.parseBoolean(op.testOptions.evals.getProperty(&quot;factLB&quot;))) {</span>
<span class="nc" id="L173">      factLB = new Evalb(&quot;factor LP/LR&quot;, runningAverages);</span>
    }
<span class="nc bnc" id="L175" title="All 2 branches missed.">    if (op.testOptions.evals.getProperty(&quot;factChildSpecific&quot;) != null) {</span>
<span class="nc" id="L176">      String filter = op.testOptions.evals.getProperty(&quot;factChildSpecific&quot;);</span>
<span class="nc" id="L177">      factChildSpecific = FilteredEval.childFilteredEval(&quot;fact children matching &quot; + filter + &quot; LP/LR&quot;, runningAverages, op.langpack(), filter);</span>
    }
<span class="nc bnc" id="L179" title="All 2 branches missed.">    if (Boolean.parseBoolean(op.testOptions.evals.getProperty(&quot;factLA&quot;))) {</span>
<span class="nc" id="L180">      factLA = new LeafAncestorEval(&quot;factor LeafAncestor&quot;);</span>
    }
<span class="nc bnc" id="L182" title="All 2 branches missed.">    if (Boolean.parseBoolean(op.testOptions.evals.getProperty(&quot;factCB&quot;))) {</span>
<span class="nc" id="L183">      factCB = new Evalb.CBEval(&quot;fact CB&quot;, runningAverages);</span>
    }
<span class="nc bnc" id="L185" title="All 2 branches missed.">    if (Boolean.parseBoolean(op.testOptions.evals.getProperty(&quot;factDA&quot;))) {</span>
<span class="nc" id="L186">      factDA = new UnlabeledAttachmentEval(&quot;factor DA&quot;, runningAverages, null);</span>
    }
<span class="nc bnc" id="L188" title="All 2 branches missed.">    if (Boolean.parseBoolean(op.testOptions.evals.getProperty(&quot;factTA&quot;))) {</span>
<span class="nc" id="L189">      factTA = new TaggingEval(&quot;factor Tag&quot;, runningAverages, lex);</span>
    }
<span class="nc bnc" id="L191" title="All 2 branches missed.">    if (Boolean.parseBoolean(op.testOptions.evals.getProperty(&quot;pcfgRUO&quot;))) {</span>
<span class="nc" id="L192">      pcfgRUO = new AbstractEval.RuleErrorEval(&quot;pcfg Rule under/over&quot;);</span>
    }
<span class="nc bnc" id="L194" title="All 2 branches missed.">    if (Boolean.parseBoolean(op.testOptions.evals.getProperty(&quot;pcfgCUO&quot;))) {</span>
<span class="nc" id="L195">      pcfgCUO = new AbstractEval.CatErrorEval(&quot;pcfg Category under/over&quot;);</span>
    }
<span class="nc bnc" id="L197" title="All 2 branches missed.">    if (Boolean.parseBoolean(op.testOptions.evals.getProperty(&quot;pcfgCatE&quot;))) {</span>
<span class="nc" id="L198">      pcfgCatE = new EvalbByCat(&quot;pcfg Category Eval&quot;, runningAverages);</span>
    }
<span class="nc bnc" id="L200" title="All 2 branches missed.">    if (Boolean.parseBoolean(op.testOptions.evals.getProperty(&quot;pcfgLL&quot;))) {</span>
<span class="nc" id="L201">      pcfgLL = new AbstractEval.ScoreEval(&quot;pcfgLL&quot;, runningAverages);</span>
    }
<span class="nc bnc" id="L203" title="All 2 branches missed.">    if (Boolean.parseBoolean(op.testOptions.evals.getProperty(&quot;depLL&quot;))) {</span>
<span class="nc" id="L204">      depLL = new AbstractEval.ScoreEval(&quot;depLL&quot;, runningAverages);</span>
    }
<span class="nc bnc" id="L206" title="All 2 branches missed.">    if (Boolean.parseBoolean(op.testOptions.evals.getProperty(&quot;factLL&quot;))) {</span>
<span class="nc" id="L207">      factLL = new AbstractEval.ScoreEval(&quot;factLL&quot;, runningAverages);</span>
    }
<span class="nc bnc" id="L209" title="All 2 branches missed.">    if (Boolean.parseBoolean(op.testOptions.evals.getProperty(&quot;topMatch&quot;))) {</span>
<span class="nc" id="L210">      evals.add(new TopMatchEval(&quot;topMatch&quot;, runningAverages));</span>
    }
    // this one is for the various k Good/Best options.  Just for individual results
<span class="nc" id="L213">    kGoodLB = new Evalb(&quot;kGood LP/LR&quot;, false);</span>

<span class="nc bnc" id="L215" title="All 2 branches missed.">    if (Boolean.parseBoolean(op.testOptions.evals.getProperty(&quot;pcfgTopK&quot;))) {</span>
<span class="nc" id="L216">      topKEvals.add(new BestOfTopKEval(new Evalb(&quot;pcfg top k comparisons&quot;, false), new Evalb(&quot;pcfg top k LP/LR&quot;, runningAverages)));</span>
    }

<span class="nc bnc" id="L219" title="All 2 branches missed.">    if (topKEvals.size() &gt; 0) {</span>
<span class="nc" id="L220">      kbestPCFG = op.testOptions.evalPCFGkBest;</span>
    }
<span class="nc bnc" id="L222" title="All 2 branches missed.">    if (op.testOptions.printPCFGkBest &gt; 0) {</span>
<span class="nc" id="L223">      kbestPCFG = Math.max(kbestPCFG, op.testOptions.printPCFGkBest);</span>
    }

<span class="nc" id="L226">  }</span>

  public double getLBScore() {
<span class="nc bnc" id="L229" title="All 2 branches missed.">    if (factLB != null) {</span>
<span class="nc" id="L230">      return factLB.getEvalbF1Percent();</span>
    }
<span class="nc bnc" id="L232" title="All 2 branches missed.">    if (pcfgLB != null) {</span>
<span class="nc" id="L233">      return pcfgLB.getEvalbF1Percent();</span>
    }
<span class="nc" id="L235">    return 0.0;</span>
  }

  public double getTagScore() {
<span class="nc bnc" id="L239" title="All 2 branches missed.">    if (factTA != null) {</span>
<span class="nc" id="L240">      return factTA.getEvalbF1Percent();</span>
    }
<span class="nc bnc" id="L242" title="All 2 branches missed.">    if (pcfgTA != null) {</span>
<span class="nc" id="L243">      return pcfgTA.getEvalbF1Percent();</span>
    }
<span class="nc" id="L245">    return 0.0;</span>
  }


  /**
   * Remove tree scores, so they don't print.
   * &lt;br&gt;
   * TODO: The printing architecture should be fixed up in the trees package
   * sometime.
   */
  private static void nanScores(Tree tree) {
<span class="nc" id="L256">    tree.setScore(Double.NaN);</span>
<span class="nc" id="L257">    Tree[] kids = tree.children();</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">    for (Tree kid : kids) {</span>
<span class="nc" id="L259">      nanScores(kid);</span>
    }
<span class="nc" id="L261">  }</span>

  /**
   * Returns the input sentence for the parser.
   */
  private List&lt;CoreLabel&gt; getInputSentence(Tree t) {
<span class="nc bnc" id="L267" title="All 2 branches missed.">    if (op.testOptions.forceTags) {</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">      if (op.testOptions.preTag) {</span>
<span class="nc" id="L269">        List&lt;TaggedWord&gt; s = tagger.apply(t.yieldWords());</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">        if(op.testOptions.verbose) {</span>
<span class="nc" id="L271">          log.info(&quot;Guess tags: &quot;+Arrays.toString(s.toArray()));</span>
<span class="nc" id="L272">          log.info(&quot;Gold tags: &quot;+t.labeledYield().toString());</span>
        }
<span class="nc" id="L274">        return SentenceUtils.toCoreLabelList(s);</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">      } else if(op.testOptions.noFunctionalForcing) {</span>
<span class="nc" id="L276">        ArrayList&lt;? extends HasWord&gt; s = t.taggedYield();</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">        for (HasWord word : s) {</span>
<span class="nc" id="L278">          String tag = ((HasTag) word).tag();</span>
<span class="nc" id="L279">          tag = tag.split(&quot;-&quot;)[0];</span>
<span class="nc" id="L280">          ((HasTag) word).setTag(tag);</span>
<span class="nc" id="L281">        }</span>
<span class="nc" id="L282">        return SentenceUtils.toCoreLabelList(s);</span>
      } else {
<span class="nc" id="L284">        return SentenceUtils.toCoreLabelList(t.taggedYield());</span>
      }
    } else {
<span class="nc" id="L287">      return SentenceUtils.toCoreLabelList(t.yieldWords());</span>
    }
  }

  public void processResults(ParserQuery pq, Tree goldTree, PrintWriter pwErr, PrintWriter pwOut, PrintWriter pwFileOut, PrintWriter pwStats, TreePrint treePrint) {
<span class="nc bnc" id="L292" title="All 2 branches missed.">      if (pq.saidMemMessage()) {</span>
<span class="nc" id="L293">        saidMemMessage = true;</span>
      }

      Tree tree;
<span class="nc" id="L297">      List&lt;? extends HasWord&gt; sentence = pq.originalSentence();</span>
      try {
<span class="nc" id="L299">        tree = pq.getBestParse();</span>
<span class="nc" id="L300">      } catch (NoSuchParseException e) {</span>
<span class="nc" id="L301">        tree = null;</span>
<span class="nc" id="L302">      }</span>

<span class="nc" id="L304">      List&lt;ScoredObject&lt;Tree&gt;&gt; kbestPCFGTrees = null;</span>
<span class="nc bnc" id="L305" title="All 4 branches missed.">      if (tree != null &amp;&amp; kbestPCFG &gt; 0) {</span>
<span class="nc" id="L306">        kbestPCFGTrees = pq.getKBestPCFGParses(kbestPCFG);</span>
      }

      //combo parse goes to pwOut (System.out)
<span class="nc bnc" id="L310" title="All 2 branches missed.">      if (op.testOptions.verbose) {</span>
<span class="nc" id="L311">        pwOut.println(&quot;ComboParser best&quot;);</span>
<span class="nc" id="L312">        Tree ot = tree;</span>
<span class="nc bnc" id="L313" title="All 4 branches missed.">        if (ot != null &amp;&amp; ! op.tlpParams.treebankLanguagePack().isStartSymbol(ot.value())) {</span>
<span class="nc" id="L314">          ot = ot.treeFactory().newTreeNode(op.tlpParams.treebankLanguagePack().startSymbol(), Collections.singletonList(ot));</span>
        }
<span class="nc" id="L316">        treePrint.printTree(ot, pwOut);</span>
<span class="nc" id="L317">      } else {</span>
<span class="nc" id="L318">        treePrint.printTree(tree, pwOut);</span>
      }

      // **OUTPUT**
      // print various n-best like outputs (including 1-best)
      // print various statistics
<span class="nc bnc" id="L324" title="All 2 branches missed.">      if (tree != null) {</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">        if(op.testOptions.printAllBestParses) {</span>
<span class="nc" id="L326">          List&lt;ScoredObject&lt;Tree&gt;&gt; parses = pq.getBestPCFGParses();</span>
<span class="nc" id="L327">          int sz = parses.size();</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">          if (sz &gt; 1) {</span>
<span class="nc" id="L329">            pwOut.println(&quot;There were &quot; + sz + &quot; best PCFG parses with score &quot; + parses.get(0).score() + '.');</span>
<span class="nc" id="L330">            Tree transGoldTree = collinizer.transformTree(goldTree);</span>
<span class="nc" id="L331">            int iii = 0;</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">            for (ScoredObject&lt;Tree&gt; sot : parses) {</span>
<span class="nc" id="L333">              iii++;</span>
<span class="nc" id="L334">              Tree tb = sot.object();</span>
<span class="nc" id="L335">              Tree tbd = debinarizer.transformTree(tb);</span>
<span class="nc" id="L336">              tbd = subcategoryStripper.transformTree(tbd);</span>
<span class="nc" id="L337">              pq.restoreOriginalWords(tbd);</span>
<span class="nc" id="L338">              pwOut.println(&quot;PCFG Parse #&quot; + iii + &quot; with score &quot; + tbd.score());</span>
<span class="nc" id="L339">              tbd.pennPrint(pwOut);</span>
<span class="nc" id="L340">              Tree tbtr = collinizer.transformTree(tbd);</span>
              // pwOut.println(&quot;Tree size = &quot; + tbtr.size() + &quot;; depth = &quot; + tbtr.depth());
<span class="nc" id="L342">              kGoodLB.evaluate(tbtr, transGoldTree, pwErr);</span>
<span class="nc" id="L343">            }</span>
          }
<span class="nc" id="L345">        }</span>
        // Huang and Chiang (2006) Algorithm 3 output from the PCFG parser
<span class="nc bnc" id="L347" title="All 4 branches missed.">        else if (op.testOptions.printPCFGkBest &gt; 0 &amp;&amp; op.testOptions.outputkBestEquivocation == null) {</span>
<span class="nc" id="L348">          List&lt;ScoredObject&lt;Tree&gt;&gt; trees = kbestPCFGTrees.subList(0, op.testOptions.printPCFGkBest);</span>
<span class="nc" id="L349">          Tree transGoldTree = collinizer.transformTree(goldTree);</span>
<span class="nc" id="L350">          int i = 0;</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">          for (ScoredObject&lt;Tree&gt; tp : trees) {</span>
<span class="nc" id="L352">            i++;</span>
<span class="nc" id="L353">            pwOut.println(&quot;PCFG Parse #&quot; + i + &quot; with score &quot; + tp.score());</span>
<span class="nc" id="L354">            Tree tbd = tp.object();</span>
<span class="nc" id="L355">            tbd.pennPrint(pwOut);</span>
<span class="nc" id="L356">            Tree tbtr = collinizer.transformTree(tbd);</span>
<span class="nc" id="L357">            kGoodLB.evaluate(tbtr, transGoldTree, pwErr);</span>
<span class="nc" id="L358">          }</span>
<span class="nc" id="L359">        }</span>
        // Chart parser (factored) n-best list
<span class="nc bnc" id="L361" title="All 4 branches missed.">        else if (op.testOptions.printFactoredKGood &gt; 0 &amp;&amp; pq.hasFactoredParse()) {</span>
          // DZ: debug n best trees
<span class="nc" id="L363">          List&lt;ScoredObject&lt;Tree&gt;&gt; trees = pq.getKGoodFactoredParses(op.testOptions.printFactoredKGood);</span>
<span class="nc" id="L364">          Tree transGoldTree = collinizer.transformTree(goldTree);</span>
<span class="nc" id="L365">          int ii = 0;</span>
<span class="nc bnc" id="L366" title="All 2 branches missed.">          for (ScoredObject&lt;Tree&gt; tp : trees) {</span>
<span class="nc" id="L367">            ii++;</span>
<span class="nc" id="L368">            pwOut.println(&quot;Factored Parse #&quot; + ii + &quot; with score &quot; + tp.score());</span>
<span class="nc" id="L369">            Tree tbd = tp.object();</span>
<span class="nc" id="L370">            tbd.pennPrint(pwOut);</span>
<span class="nc" id="L371">            Tree tbtr = collinizer.transformTree(tbd);</span>
<span class="nc" id="L372">            kGoodLB.evaluate(tbtr, transGoldTree, pwOut);</span>
<span class="nc" id="L373">          }</span>
<span class="nc" id="L374">        }</span>
        //1-best output
<span class="nc bnc" id="L376" title="All 2 branches missed.">        else if(pwFileOut != null) {</span>
<span class="nc" id="L377">          pwFileOut.println(tree.toString());</span>
        }

        //Print the derivational entropy
<span class="nc bnc" id="L381" title="All 4 branches missed.">        if(op.testOptions.outputkBestEquivocation != null &amp;&amp; op.testOptions.printPCFGkBest &gt; 0) {</span>
<span class="nc" id="L382">          List&lt;ScoredObject&lt;Tree&gt;&gt; trees = kbestPCFGTrees.subList(0, op.testOptions.printPCFGkBest);</span>

<span class="nc" id="L384">          double[] logScores = new double[trees.size()];</span>
<span class="nc" id="L385">          int treeId = 0;</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">          for(ScoredObject&lt;Tree&gt; kBestTree : trees)</span>
<span class="nc" id="L387">            logScores[treeId++] = kBestTree.score();</span>

          //Re-normalize
<span class="nc" id="L390">          double entropy = 0.0;</span>
<span class="nc" id="L391">          double denom = ArrayMath.logSum(logScores);</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">          for (double logScore : logScores) {</span>
<span class="nc" id="L393">            double logPr = logScore - denom;</span>
<span class="nc" id="L394">            entropy += Math.exp(logPr) * (logPr / Math.log(2));</span>
          }
<span class="nc" id="L396">          entropy *= -1; //Convert to bits</span>
<span class="nc" id="L397">          pwStats.printf(&quot;%f\t%d\t%d\n&quot;, entropy,trees.size(),sentence.size());</span>
        }
      }


      // **EVALUATION**
      // Perform various evaluations specified by the user
<span class="nc bnc" id="L404" title="All 2 branches missed.">      if (tree != null) {</span>
        //Strip subcategories and remove punctuation for evaluation
<span class="nc" id="L406">        tree = subcategoryStripper.transformTree(tree);</span>
<span class="nc" id="L407">        Tree treeFact = collinizer.transformTree(tree);</span>

        //Setup the gold tree
<span class="nc bnc" id="L410" title="All 2 branches missed.">        if (op.testOptions.verbose) {</span>
<span class="nc" id="L411">          pwOut.println(&quot;Correct parse&quot;);</span>
<span class="nc" id="L412">          treePrint.printTree(goldTree, pwOut);</span>
        }
<span class="nc" id="L414">        Tree transGoldTree = collinizer.transformTree(goldTree);</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">        if(transGoldTree != null)</span>
<span class="nc" id="L416">          transGoldTree = subcategoryStripper.transformTree(transGoldTree);</span>

        //Can't do evaluation in these two cases
<span class="nc bnc" id="L419" title="All 2 branches missed.">        if (transGoldTree == null) {</span>
<span class="nc" id="L420">          pwErr.println(&quot;Couldn't transform gold tree for evaluation, skipping eval. Gold tree was:&quot;);</span>
<span class="nc" id="L421">          goldTree.pennPrint(pwErr);</span>
<span class="nc" id="L422">          numSkippedEvals++;</span>
<span class="nc" id="L423">          return;</span>

<span class="nc bnc" id="L425" title="All 2 branches missed.">        } else if (treeFact == null) {</span>
<span class="nc" id="L426">          pwErr.println(&quot;Couldn't transform hypothesis tree for evaluation, skipping eval. Tree was:&quot;);</span>
<span class="nc" id="L427">          tree.pennPrint(pwErr);</span>
<span class="nc" id="L428">          numSkippedEvals++;</span>
<span class="nc" id="L429">          return;</span>

<span class="nc bnc" id="L431" title="All 2 branches missed.">        } else if(treeFact.yield().size() != transGoldTree.yield().size()) {</span>
<span class="nc" id="L432">          List&lt;Label&gt; fYield = treeFact.yield();</span>
<span class="nc" id="L433">          List&lt;Label&gt; gYield = transGoldTree.yield();</span>
<span class="nc" id="L434">          pwErr.println(&quot;WARNING: Evaluation could not be performed due to gold/parsed yield mismatch.&quot;);</span>
<span class="nc" id="L435">          pwErr.printf(&quot;  sizes: gold: %d (transf) %d (orig); parsed: %d (transf) %d (orig).%n&quot;, gYield.size(), goldTree.yield().size(),</span>
<span class="nc" id="L436">                       fYield.size(), tree.yield().size());</span>
<span class="nc" id="L437">          pwErr.println(&quot;  gold: &quot; + SentenceUtils.listToString(gYield, true));</span>
<span class="nc" id="L438">          pwErr.println(&quot;  pars: &quot; + SentenceUtils.listToString(fYield, true));</span>
<span class="nc" id="L439">          numSkippedEvals++;</span>
<span class="nc" id="L440">          return;</span>
        }

<span class="nc bnc" id="L443" title="All 2 branches missed.">        if (topKEvals.size() &gt; 0) {</span>
<span class="nc" id="L444">          List&lt;Tree&gt; transGuesses = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L445">          int kbest = Math.min(op.testOptions.evalPCFGkBest, kbestPCFGTrees.size());</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">          for (ScoredObject&lt;Tree&gt; guess : kbestPCFGTrees.subList(0, kbest)) {</span>
<span class="nc" id="L447">            transGuesses.add(collinizer.transformTree(guess.object()));</span>
<span class="nc" id="L448">          }</span>
<span class="nc bnc" id="L449" title="All 2 branches missed.">          for (BestOfTopKEval eval : topKEvals) {</span>
<span class="nc" id="L450">            eval.evaluate(transGuesses, transGoldTree, pwErr);</span>
<span class="nc" id="L451">          }</span>
        }

        //PCFG eval
<span class="nc" id="L455">        Tree treePCFG = pq.getBestPCFGParse();</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">        if (treePCFG != null) {</span>
<span class="nc" id="L457">          Tree treePCFGeval = collinizer.transformTree(treePCFG);</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">          if (pcfgLB != null) {</span>
<span class="nc" id="L459">            pcfgLB.evaluate(treePCFGeval, transGoldTree, pwErr);</span>
          }
<span class="nc bnc" id="L461" title="All 2 branches missed.">          if (pcfgChildSpecific != null) {</span>
<span class="nc" id="L462">            pcfgChildSpecific.evaluate(treePCFGeval, transGoldTree, pwErr);</span>
          }
<span class="nc bnc" id="L464" title="All 2 branches missed.">          if(pcfgLA != null) {</span>
<span class="nc" id="L465">            pcfgLA.evaluate(treePCFGeval, transGoldTree, pwErr);</span>
          }
<span class="nc bnc" id="L467" title="All 2 branches missed.">          if (pcfgCB != null) {</span>
<span class="nc" id="L468">            pcfgCB.evaluate(treePCFGeval, transGoldTree, pwErr);</span>
          }
<span class="nc bnc" id="L470" title="All 2 branches missed.">          if (pcfgDA != null) {</span>
            // Re-index the leaves after Collinization, stripping traces, etc.
<span class="nc" id="L472">            treePCFGeval.indexLeaves(true);</span>
<span class="nc" id="L473">            transGoldTree.indexLeaves(true);</span>
<span class="nc" id="L474">            pcfgDA.evaluate(treePCFGeval, transGoldTree, pwErr);</span>
          }
<span class="nc bnc" id="L476" title="All 2 branches missed.">          if (pcfgTA != null) {</span>
<span class="nc" id="L477">            pcfgTA.evaluate(treePCFGeval, transGoldTree, pwErr);</span>
          }
<span class="nc bnc" id="L479" title="All 4 branches missed.">          if (pcfgLL != null &amp;&amp; pq.getPCFGParser() != null) {</span>
<span class="nc" id="L480">            pcfgLL.recordScore(pq.getPCFGParser(), pwErr);</span>
          }
<span class="nc bnc" id="L482" title="All 2 branches missed.">          if (pcfgRUO != null) {</span>
<span class="nc" id="L483">            pcfgRUO.evaluate(treePCFGeval, transGoldTree, pwErr);</span>
          }
<span class="nc bnc" id="L485" title="All 2 branches missed.">          if (pcfgCUO != null) {</span>
<span class="nc" id="L486">            pcfgCUO.evaluate(treePCFGeval, transGoldTree, pwErr);</span>
          }
<span class="nc bnc" id="L488" title="All 2 branches missed.">          if (pcfgCatE != null) {</span>
<span class="nc" id="L489">            pcfgCatE.evaluate(treePCFGeval, transGoldTree, pwErr);</span>
          }
        }

        //Dependency eval
        // todo: is treeDep really useful here, or should we really use depDAEval tree (debinarized) throughout? We use it for parse, and it sure seems like we could use it for tag eval, but maybe not factDA?
<span class="nc" id="L495">        Tree treeDep = pq.getBestDependencyParse(false);</span>
<span class="nc bnc" id="L496" title="All 2 branches missed.">        if (treeDep != null) {</span>
<span class="nc" id="L497">          Tree goldTreeB = binarizerOnly.transformTree(goldTree);</span>

<span class="nc" id="L499">          Tree goldTreeEval = goldTree.deepCopy();</span>
<span class="nc" id="L500">          goldTreeEval.indexLeaves(true);</span>
<span class="nc" id="L501">          goldTreeEval.percolateHeads(op.langpack().headFinder());</span>

<span class="nc" id="L503">          Tree depDAEval = pq.getBestDependencyParse(true);</span>
<span class="nc" id="L504">          depDAEval.indexLeaves(true);</span>
<span class="nc" id="L505">          depDAEval.percolateHeadIndices();</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">          if (depDA != null) {</span>
<span class="nc" id="L507">            depDA.evaluate(depDAEval, goldTreeEval, pwErr);</span>
          }
<span class="nc bnc" id="L509" title="All 2 branches missed.">          if (depTA != null) {</span>
<span class="nc" id="L510">            Tree undoneTree = debinarizer.transformTree(treeDep);</span>
<span class="nc" id="L511">            undoneTree = subcategoryStripper.transformTree(undoneTree);</span>
<span class="nc" id="L512">            pq.restoreOriginalWords(undoneTree);</span>
            // pwErr.println(&quot;subcategoryStripped tree: &quot; + undoneTree.toStructureDebugString());
<span class="nc" id="L514">            depTA.evaluate(undoneTree, goldTree, pwErr);</span>
          }
<span class="nc bnc" id="L516" title="All 4 branches missed.">          if (depLL != null &amp;&amp; pq.getDependencyParser() != null) {</span>
<span class="nc" id="L517">            depLL.recordScore(pq.getDependencyParser(), pwErr);</span>
          }
          Tree factTreeB;
<span class="nc bnc" id="L520" title="All 2 branches missed.">          if (pq.hasFactoredParse()) {</span>
<span class="nc" id="L521">            factTreeB = pq.getBestFactoredParse();</span>
          } else {
<span class="nc" id="L523">            factTreeB = treeDep;</span>
          }
<span class="nc bnc" id="L525" title="All 2 branches missed.">          if (factDA != null) {</span>
<span class="nc" id="L526">            factDA.evaluate(factTreeB, goldTreeB, pwErr);</span>
          }
        }

        //Factored parser (1best) eval
<span class="nc bnc" id="L531" title="All 2 branches missed.">        if (factLB != null) {</span>
<span class="nc" id="L532">          factLB.evaluate(treeFact, transGoldTree, pwErr);</span>
        }
<span class="nc bnc" id="L534" title="All 2 branches missed.">        if (factChildSpecific != null) {</span>
<span class="nc" id="L535">          factChildSpecific.evaluate(treeFact, transGoldTree, pwErr);</span>
        }
<span class="nc bnc" id="L537" title="All 2 branches missed.">        if(factLA != null) {</span>
<span class="nc" id="L538">          factLA.evaluate(treeFact, transGoldTree, pwErr);</span>
        }
<span class="nc bnc" id="L540" title="All 2 branches missed.">        if (factTA != null) {</span>
<span class="nc" id="L541">          factTA.evaluate(tree, boundaryRemover.transformTree(goldTree), pwErr);</span>
        }
<span class="nc bnc" id="L543" title="All 4 branches missed.">        if (factLL != null &amp;&amp; pq.getFactoredParser() != null) {</span>
<span class="nc" id="L544">          factLL.recordScore(pq.getFactoredParser(), pwErr);</span>
        }
<span class="nc bnc" id="L546" title="All 2 branches missed.">        if (factCB != null) {</span>
<span class="nc" id="L547">          factCB.evaluate(treeFact, transGoldTree, pwErr);</span>
        }
<span class="nc bnc" id="L549" title="All 2 branches missed.">        for (Eval eval : evals) {</span>
<span class="nc" id="L550">          eval.evaluate(treeFact, transGoldTree, pwErr);</span>
<span class="nc" id="L551">        }</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">        if (parserQueryEvals != null) {</span>
<span class="nc bnc" id="L553" title="All 2 branches missed.">          for (ParserQueryEval eval : parserQueryEvals) {</span>
<span class="nc" id="L554">            eval.evaluate(pq, transGoldTree, pwErr);</span>
<span class="nc" id="L555">          }</span>
        }
<span class="nc bnc" id="L557" title="All 2 branches missed.">        if (op.testOptions.evalb) {</span>
          // empty out scores just in case
<span class="nc" id="L559">          nanScores(tree);</span>
<span class="nc" id="L560">          EvalbFormatWriter.writeEVALBline(treeFact, transGoldTree);</span>
        }
      }
<span class="nc" id="L563">      pwErr.println();</span>
<span class="nc" id="L564">  }</span>

  /** Test the parser on a treebank. Parses will be written to stdout, and
   *  various other information will be written to stderr and stdout,
   *  particularly if &lt;code&gt;op.testOptions.verbose&lt;/code&gt; is true.
   *
   *  @param testTreebank The treebank to parse
   *  @return The labeled precision/recall F&lt;sub&gt;1&lt;/sub&gt; (EVALB measure)
   *          of the parser on the treebank.
   */
  public double testOnTreebank(Treebank testTreebank) {
<span class="nc" id="L575">    log.info(&quot;Testing on treebank&quot;);</span>
<span class="nc" id="L576">    Timing treebankTotalTimer = new Timing();</span>
<span class="nc" id="L577">    TreePrint treePrint = op.testOptions.treePrint(op.tlpParams);</span>
<span class="nc" id="L578">    TreebankLangParserParams tlpParams = op.tlpParams;</span>
<span class="nc" id="L579">    TreebankLanguagePack tlp = op.langpack();</span>
    PrintWriter pwOut, pwErr;
<span class="nc bnc" id="L581" title="All 2 branches missed.">    if (op.testOptions.quietEvaluation) {</span>
<span class="nc" id="L582">      NullOutputStream quiet = new NullOutputStream();</span>
<span class="nc" id="L583">      pwOut = tlpParams.pw(quiet);</span>
<span class="nc" id="L584">      pwErr = tlpParams.pw(quiet);</span>
<span class="nc" id="L585">    } else {</span>
<span class="nc" id="L586">      pwOut = tlpParams.pw();</span>
<span class="nc" id="L587">      pwErr = tlpParams.pw(System.err);</span>
    }
<span class="nc bnc" id="L589" title="All 2 branches missed.">    if (op.testOptions.verbose) {</span>
<span class="nc" id="L590">      pwErr.print(&quot;Testing &quot;);</span>
<span class="nc" id="L591">      pwErr.println(testTreebank.textualSummary(tlp));</span>
    }
<span class="nc bnc" id="L593" title="All 2 branches missed.">    if (op.testOptions.evalb) {</span>
<span class="nc" id="L594">      EvalbFormatWriter.initEVALBfiles(tlpParams);</span>
    }

<span class="nc" id="L597">    PrintWriter pwFileOut = null;</span>
<span class="nc bnc" id="L598" title="All 2 branches missed.">    if (op.testOptions.writeOutputFiles) {</span>
<span class="nc" id="L599">      String fname = op.testOptions.outputFilesPrefix + &quot;.&quot; + op.testOptions.outputFilesExtension;</span>
      try {
<span class="nc" id="L601">        pwFileOut = op.tlpParams.pw(new FileOutputStream(fname));</span>
<span class="nc" id="L602">      } catch (IOException ioe) {</span>
<span class="nc" id="L603">        ioe.printStackTrace();</span>
<span class="nc" id="L604">      }</span>
    }

<span class="nc" id="L607">    PrintWriter pwStats = null;</span>
<span class="nc bnc" id="L608" title="All 2 branches missed.">    if(op.testOptions.outputkBestEquivocation != null) {</span>
      try {
<span class="nc" id="L610">        pwStats = op.tlpParams.pw(new FileOutputStream(op.testOptions.outputkBestEquivocation));</span>
<span class="nc" id="L611">      } catch(IOException ioe) {</span>
<span class="nc" id="L612">        ioe.printStackTrace();</span>
<span class="nc" id="L613">      }</span>
    }

<span class="nc bnc" id="L616" title="All 2 branches missed.">    if (op.testOptions.testingThreads != 1) {</span>
<span class="nc" id="L617">      MulticoreWrapper&lt;List&lt;? extends HasWord&gt;, ParserQuery&gt; wrapper = new MulticoreWrapper&lt;&gt;(op.testOptions.testingThreads, new ParsingThreadsafeProcessor(pqFactory, pwErr));</span>

<span class="nc" id="L619">      LinkedList&lt;Tree&gt; goldTrees = new LinkedList&lt;&gt;();</span>
<span class="nc bnc" id="L620" title="All 2 branches missed.">      for (Tree goldTree : testTreebank) {</span>
<span class="nc" id="L621">        List&lt;? extends HasWord&gt; sentence = getInputSentence(goldTree);</span>
<span class="nc" id="L622">        goldTrees.add(goldTree);</span>

<span class="nc" id="L624">        pwErr.println(&quot;Parsing [len. &quot; + sentence.size() + &quot;]: &quot; + SentenceUtils.listToString(sentence));</span>
<span class="nc" id="L625">        wrapper.put(sentence);</span>
<span class="nc bnc" id="L626" title="All 2 branches missed.">        while (wrapper.peek()) {</span>
<span class="nc" id="L627">          ParserQuery pq = wrapper.poll();</span>
<span class="nc" id="L628">          goldTree = goldTrees.poll();</span>
<span class="nc" id="L629">          processResults(pq, goldTree, pwErr, pwOut, pwFileOut, pwStats, treePrint);</span>
<span class="nc" id="L630">        }</span>
<span class="nc" id="L631">      } // for tree iterator</span>
<span class="nc" id="L632">      wrapper.join();</span>
<span class="nc bnc" id="L633" title="All 2 branches missed.">      while (wrapper.peek()) {</span>
<span class="nc" id="L634">        ParserQuery pq = wrapper.poll();</span>
<span class="nc" id="L635">        Tree goldTree = goldTrees.poll();</span>
<span class="nc" id="L636">        processResults(pq, goldTree, pwErr, pwOut, pwFileOut, pwStats, treePrint);</span>
<span class="nc" id="L637">      }</span>
<span class="nc" id="L638">    } else {</span>
<span class="nc" id="L639">      ParserQuery pq = pqFactory.parserQuery();</span>

<span class="nc bnc" id="L641" title="All 2 branches missed.">      for (Tree goldTree : testTreebank) {</span>
<span class="nc" id="L642">        final List&lt;CoreLabel&gt; sentence = getInputSentence(goldTree);</span>

<span class="nc" id="L644">        pwErr.println(&quot;Parsing [len. &quot; + sentence.size() + &quot;]: &quot; + SentenceUtils.listToString(sentence));</span>

<span class="nc" id="L646">        pq.parseAndReport(sentence, pwErr);</span>

<span class="nc" id="L648">        processResults(pq, goldTree, pwErr, pwOut, pwFileOut, pwStats, treePrint);</span>
<span class="nc" id="L649">      } // for tree iterator</span>
    }

    //Done parsing...print the results of the evaluations
<span class="nc" id="L653">    treebankTotalTimer.done(&quot;Testing on treebank&quot;);</span>
<span class="nc bnc" id="L654" title="All 2 branches missed.">    if (op.testOptions.quietEvaluation) {</span>
<span class="nc" id="L655">      pwErr = tlpParams.pw(System.err);</span>
    }
<span class="nc bnc" id="L657" title="All 2 branches missed.">    if (saidMemMessage) {</span>
<span class="nc" id="L658">      ParserUtils.printOutOfMemory(pwErr);</span>
    }
<span class="nc bnc" id="L660" title="All 2 branches missed.">    if (op.testOptions.evalb) {</span>
<span class="nc" id="L661">      EvalbFormatWriter.closeEVALBfiles();</span>
    }
<span class="nc bnc" id="L663" title="All 2 branches missed.">    if(numSkippedEvals != 0) {</span>
<span class="nc" id="L664">      pwErr.printf(&quot;Unable to evaluate %d parser hypotheses due to yield mismatch\n&quot;,numSkippedEvals);</span>
    }
    // only created here so we know what parser types are supported...
<span class="nc" id="L667">    ParserQuery pq = pqFactory.parserQuery();</span>
<span class="nc bnc" id="L668" title="All 2 branches missed.">    if (summary) {</span>
<span class="nc bnc" id="L669" title="All 2 branches missed.">      if (pcfgLB != null) pcfgLB.display(false, pwErr);</span>
<span class="nc bnc" id="L670" title="All 2 branches missed.">      if (pcfgChildSpecific != null) pcfgChildSpecific.display(false, pwErr);</span>
<span class="nc bnc" id="L671" title="All 2 branches missed.">      if (pcfgLA != null) pcfgLA.display(false, pwErr);</span>
<span class="nc bnc" id="L672" title="All 2 branches missed.">      if (pcfgCB != null) pcfgCB.display(false, pwErr);</span>
<span class="nc bnc" id="L673" title="All 2 branches missed.">      if (pcfgDA != null) pcfgDA.display(false, pwErr);</span>
<span class="nc bnc" id="L674" title="All 2 branches missed.">      if (pcfgTA != null) pcfgTA.display(false, pwErr);</span>
<span class="nc bnc" id="L675" title="All 4 branches missed.">      if (pcfgLL != null &amp;&amp; pq.getPCFGParser() != null) pcfgLL.display(false, pwErr);</span>
<span class="nc bnc" id="L676" title="All 2 branches missed.">      if (depDA != null) depDA.display(false, pwErr);</span>
<span class="nc bnc" id="L677" title="All 2 branches missed.">      if (depTA != null) depTA.display(false, pwErr);</span>
<span class="nc bnc" id="L678" title="All 4 branches missed.">      if (depLL != null &amp;&amp; pq.getDependencyParser() != null) depLL.display(false, pwErr);</span>
<span class="nc bnc" id="L679" title="All 2 branches missed.">      if (factLB != null) factLB.display(false, pwErr);</span>
<span class="nc bnc" id="L680" title="All 2 branches missed.">      if (factChildSpecific != null) factChildSpecific.display(false, pwErr);</span>
<span class="nc bnc" id="L681" title="All 2 branches missed.">      if (factLA != null) factLA.display(false, pwErr);</span>
<span class="nc bnc" id="L682" title="All 2 branches missed.">      if (factCB != null) factCB.display(false, pwErr);</span>
<span class="nc bnc" id="L683" title="All 2 branches missed.">      if (factDA != null) factDA.display(false, pwErr);</span>
<span class="nc bnc" id="L684" title="All 2 branches missed.">      if (factTA != null) factTA.display(false, pwErr);</span>
<span class="nc bnc" id="L685" title="All 4 branches missed.">      if (factLL != null &amp;&amp; pq.getFactoredParser() != null) factLL.display(false, pwErr);</span>
<span class="nc bnc" id="L686" title="All 2 branches missed.">      if (pcfgCatE != null) pcfgCatE.display(false, pwErr);</span>
<span class="nc bnc" id="L687" title="All 2 branches missed.">      for (Eval eval : evals) {</span>
<span class="nc" id="L688">        eval.display(false, pwErr);</span>
<span class="nc" id="L689">      }</span>
<span class="nc bnc" id="L690" title="All 2 branches missed.">      for (BestOfTopKEval eval : topKEvals) {</span>
<span class="nc" id="L691">        eval.display(false, pwErr);</span>
<span class="nc" id="L692">      }</span>
    }
    // these ones only have a display mode, so display if turned on!!
<span class="nc bnc" id="L695" title="All 2 branches missed.">    if (pcfgRUO != null) pcfgRUO.display(true, pwErr);</span>
<span class="nc bnc" id="L696" title="All 2 branches missed.">    if (pcfgCUO != null) pcfgCUO.display(true, pwErr);</span>
<span class="nc bnc" id="L697" title="All 2 branches missed.">    if (tsv) {</span>
<span class="nc" id="L698">      NumberFormat nf = new DecimalFormat(&quot;0.00&quot;);</span>
<span class="nc" id="L699">      pwErr.println(&quot;factF1\tfactDA\tfactEx\tpcfgF1\tdepDA\tfactTA\tnum&quot;);</span>
<span class="nc bnc" id="L700" title="All 2 branches missed.">      if (factLB != null) pwErr.print(nf.format(factLB.getEvalbF1Percent()));</span>
<span class="nc" id="L701">      pwErr.print(&quot;\t&quot;);</span>
<span class="nc bnc" id="L702" title="All 4 branches missed.">      if (pq.getDependencyParser() != null &amp;&amp; factDA != null) pwErr.print(nf.format(factDA.getEvalbF1Percent()));</span>
<span class="nc" id="L703">      pwErr.print(&quot;\t&quot;);</span>
<span class="nc bnc" id="L704" title="All 2 branches missed.">      if (factLB != null) pwErr.print(nf.format(factLB.getExactPercent()));</span>
<span class="nc" id="L705">      pwErr.print(&quot;\t&quot;);</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">      if (pcfgLB != null) pwErr.print(nf.format(pcfgLB.getEvalbF1Percent()));</span>
<span class="nc" id="L707">      pwErr.print(&quot;\t&quot;);</span>
<span class="nc bnc" id="L708" title="All 4 branches missed.">      if (pq.getDependencyParser() != null &amp;&amp; depDA != null) pwErr.print(nf.format(depDA.getEvalbF1Percent()));</span>
<span class="nc" id="L709">      pwErr.print(&quot;\t&quot;);</span>
<span class="nc bnc" id="L710" title="All 4 branches missed.">      if (pq.getPCFGParser() != null &amp;&amp; factTA != null) pwErr.print(nf.format(factTA.getEvalbF1Percent()));</span>
<span class="nc" id="L711">      pwErr.print(&quot;\t&quot;);</span>
<span class="nc bnc" id="L712" title="All 2 branches missed.">      if (factLB != null) pwErr.print(factLB.getNum());</span>
<span class="nc" id="L713">      pwErr.println();</span>
    }

<span class="nc" id="L716">    double f1 = 0.0;</span>
<span class="nc bnc" id="L717" title="All 2 branches missed.">    if (factLB != null) {</span>
<span class="nc" id="L718">      f1 = factLB.getEvalbF1();</span>
    }

    //Close files (if necessary)
<span class="nc bnc" id="L722" title="All 2 branches missed.">    if(pwFileOut != null) pwFileOut.close();</span>
<span class="nc bnc" id="L723" title="All 2 branches missed.">    if(pwStats != null) pwStats.close();</span>

<span class="nc bnc" id="L725" title="All 2 branches missed.">    if (parserQueryEvals != null) {</span>
<span class="nc bnc" id="L726" title="All 2 branches missed.">      for (ParserQueryEval parserQueryEval : parserQueryEvals) {</span>
<span class="nc" id="L727">        parserQueryEval.display(false, pwErr);</span>
<span class="nc" id="L728">      }</span>
    }

<span class="nc" id="L731">    return f1;</span>
  } // end testOnTreebank()



}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>