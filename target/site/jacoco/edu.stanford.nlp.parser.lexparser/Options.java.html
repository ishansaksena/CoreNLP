<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Options.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.parser.lexparser</a> &gt; <span class="el_source">Options.java</span></div><h1>Options.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.parser.lexparser; 
import edu.stanford.nlp.util.logging.Redwood;

import edu.stanford.nlp.trees.CompositeTreeTransformer;
import edu.stanford.nlp.trees.TreebankLanguagePack;
import edu.stanford.nlp.trees.TreeTransformer;
import java.util.function.Function;
import edu.stanford.nlp.util.Generics;
import edu.stanford.nlp.util.ReflectionLoading;
import edu.stanford.nlp.util.StringUtils;

import java.io.*;
import java.util.*;


/**
 * This class contains options to the parser which MUST be the SAME at
 * both training and testing (parsing) time in order for the parser to
 * work properly.  It also contains an object which stores the options
 * used by the parser at training time and an object which contains
 * default options for test use.
 *
 * @author Dan Klein
 * @author Christopher Manning
 * @author John Bauer
 */
public class Options implements Serializable  {

  /** A logger for this class */
<span class="fc" id="L30">  private static Redwood.RedwoodChannels log = Redwood.channels(Options.class);</span>

  public Options() {
<span class="fc" id="L33">    this(new EnglishTreebankParserParams());</span>
<span class="fc" id="L34">  }</span>

<span class="fc" id="L36">  public Options(TreebankLangParserParams tlpParams) {</span>
<span class="fc" id="L37">    this.tlpParams = tlpParams;</span>
<span class="fc" id="L38">  }</span>

  /**
   * Set options based on a String array in the style of
   * commandline flags. This method goes through the array until it ends,
   * processing options, as for {@link #setOption}.
   *
   * @param flags Array of options (or as a varargs list of arguments).
   *      The options passed in should
   *      be specified like command-line arguments, including with an initial
   *      minus sign  for example,
   *          {&quot;-outputFormat&quot;, &quot;typedDependencies&quot;, &quot;-maxLength&quot;, &quot;70&quot;}
   * @throws IllegalArgumentException If an unknown flag is passed in
   */
  public void setOptions(String... flags) {
<span class="nc" id="L53">    setOptions(flags, 0, flags.length);</span>
<span class="nc" id="L54">  }</span>

  /**
   * Set options based on a String array in the style of
   * commandline flags. This method goes through the array until it ends,
   * processing options, as for {@link #setOption}.
   *
   * @param flags Array of options.  The options passed in should
   *      be specified like command-line arguments, including with an initial
   *      minus sign  for example,
   *          {&quot;-outputFormat&quot;, &quot;typedDependencies&quot;, &quot;-maxLength&quot;, &quot;70&quot;}
   * @param startIndex The index in the array to begin processing options at
   * @param endIndexPlusOne A number one greater than the last array index at
   *      which options should be processed
   * @throws IllegalArgumentException If an unknown flag is passed in
   */
  public void setOptions(final String[] flags, final int startIndex, final int endIndexPlusOne) {
<span class="nc bnc" id="L71" title="All 2 branches missed.">    for (int i = startIndex; i &lt; endIndexPlusOne;) {</span>
<span class="nc" id="L72">      i = setOption(flags, i);</span>
    }
<span class="nc" id="L74">  }</span>

  /**
   * Set options based on a String array in the style of
   * commandline flags. This method goes through the array until it ends,
   * processing options, as for {@link #setOption}.
   *
   * @param flags Array of options (or as a varargs list of arguments).
   *      The options passed in should
   *      be specified like command-line arguments, including with an initial
   *      minus sign  for example,
   *          {&quot;-outputFormat&quot;, &quot;typedDependencies&quot;, &quot;-maxLength&quot;, &quot;70&quot;}
   * @throws IllegalArgumentException If an unknown flag is passed in
   */
  public void setOptionsOrWarn(String... flags) {
<span class="nc" id="L89">    setOptionsOrWarn(flags, 0, flags.length);</span>
<span class="nc" id="L90">  }</span>

  /**
   * Set options based on a String array in the style of
   * commandline flags. This method goes through the array until it ends,
   * processing options, as for {@link #setOption}.
   *
   * @param flags Array of options.  The options passed in should
   *      be specified like command-line arguments, including with an initial
   *      minus sign  for example,
   *          {&quot;-outputFormat&quot;, &quot;typedDependencies&quot;, &quot;-maxLength&quot;, &quot;70&quot;}
   * @param startIndex The index in the array to begin processing options at
   * @param endIndexPlusOne A number one greater than the last array index at
   *      which options should be processed
   * @throws IllegalArgumentException If an unknown flag is passed in
   */
  public void setOptionsOrWarn(final String[] flags, final int startIndex, final int endIndexPlusOne) {
<span class="nc bnc" id="L107" title="All 2 branches missed.">    for (int i = startIndex; i &lt; endIndexPlusOne;) {</span>
<span class="nc" id="L108">      i = setOptionOrWarn(flags, i);</span>
    }
<span class="nc" id="L110">  }</span>

  /**
   * Set an option based on a String array in the style of
   * commandline flags. The option may
   * be either one known by the Options object, or one recognized by the
   * TreebankLangParserParams which has already been set up inside the Options
   * object, and then the option is set in the language-particular
   * TreebankLangParserParams.
   * Note that despite this method being an instance method, many flags
   * are actually set as static class variables in the Train and Test
   * classes (this should be fixed some day).
   * Some options (there are many others; see the source code):
   * &lt;ul&gt;
   * &lt;li&gt; &lt;code&gt;-maxLength n&lt;/code&gt; set the maximum length sentence to parse (inclusively)
   * &lt;li&gt; &lt;code&gt;-printTT&lt;/code&gt; print the training trees in raw, annotated, and annotated+binarized form.  Useful for debugging and other miscellany.
   * &lt;li&gt; &lt;code&gt;-printAnnotated filename&lt;/code&gt; use only in conjunction with -printTT.  Redirects printing of annotated training trees to &lt;code&gt;filename&lt;/code&gt;.
   * &lt;li&gt; &lt;code&gt;-forceTags&lt;/code&gt; when the parser is tested against a set of gold standard trees, use the tagged yield, instead of just the yield, as input.
   * &lt;/ul&gt;
   *
   * @param flags An array of options arguments, command-line style.  E.g. {&quot;-maxLength&quot;, &quot;50&quot;}.
   * @param i The index in flags to start at when processing an option
   * @return The index in flags of the position after the last element used in
   *      processing this option. If the current array position cannot be processed as a valid
   *      option, then a warning message is printed to stderr and the return value is &lt;code&gt;i+1&lt;/code&gt;
   */
  public int setOptionOrWarn(String[] flags, int i) {
<span class="nc" id="L137">    int j = setOptionFlag(flags, i);</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">    if (j == i) {</span>
<span class="nc" id="L139">      j = tlpParams.setOptionFlag(flags, i);</span>
    }
<span class="nc bnc" id="L141" title="All 2 branches missed.">    if (j == i) {</span>
<span class="nc" id="L142">      log.info(&quot;WARNING! lexparser.Options: Unknown option ignored: &quot; + flags[i]);</span>
<span class="nc" id="L143">      j++;</span>
    }
<span class="nc" id="L145">    return j;</span>
  }

  /**
   * Set an option based on a String array in the style of
   * commandline flags. The option may
   * be either one known by the Options object, or one recognized by the
   * TreebankLangParserParams which has already been set up inside the Options
   * object, and then the option is set in the language-particular
   * TreebankLangParserParams.
   * Note that despite this method being an instance method, many flags
   * are actually set as static class variables in the Train and Test
   * classes (this should be fixed some day).
   * Some options (there are many others; see the source code):
   * &lt;ul&gt;
   * &lt;li&gt; &lt;code&gt;-maxLength n&lt;/code&gt; set the maximum length sentence to parse (inclusively)
   * &lt;li&gt; &lt;code&gt;-printTT&lt;/code&gt; print the training trees in raw, annotated, and annotated+binarized form.  Useful for debugging and other miscellany.
   * &lt;li&gt; &lt;code&gt;-printAnnotated filename&lt;/code&gt; use only in conjunction with -printTT.  Redirects printing of annotated training trees to &lt;code&gt;filename&lt;/code&gt;.
   * &lt;li&gt; &lt;code&gt;-forceTags&lt;/code&gt; when the parser is tested against a set of gold standard trees, use the tagged yield, instead of just the yield, as input.
   * &lt;/ul&gt;
   *
   * @param flags An array of options arguments, command-line style.  E.g. {&quot;-maxLength&quot;, &quot;50&quot;}.
   * @param i The index in flags to start at when processing an option
   * @return The index in flags of the position after the last element used in
   *      processing this option.
   * @throws IllegalArgumentException If the current array position cannot be
   *      processed as a valid option
   */
  public int setOption(String[] flags, int i) {
<span class="nc" id="L174">    int j = setOptionFlag(flags, i);</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">    if (j == i) {</span>
<span class="nc" id="L176">      j = tlpParams.setOptionFlag(flags, i);</span>
    }
<span class="nc bnc" id="L178" title="All 2 branches missed.">    if (j == i) {</span>
<span class="nc" id="L179">      throw new IllegalArgumentException(&quot;Unknown option: &quot; + flags[i]);</span>
    }
<span class="nc" id="L181">    return j;</span>
  }

  /**
   * Set an option in this object, based on a String array in the style of
   * commandline flags.  The option is only processed with respect to
   * options directly known by the Options object.
   * Some options (there are many others; see the source code):
   * &lt;ul&gt;
   * &lt;li&gt; &lt;code&gt;-maxLength n&lt;/code&gt; set the maximum length sentence to parse (inclusively)
   * &lt;li&gt; &lt;code&gt;-printTT&lt;/code&gt; print the training trees in raw, annotated, and annotated+binarized form.  Useful for debugging and other miscellany.
   * &lt;li&gt; &lt;code&gt;-printAnnotated filename&lt;/code&gt; use only in conjunction with -printTT.  Redirects printing of annotated training trees to &lt;code&gt;filename&lt;/code&gt;.
   * &lt;li&gt; &lt;code&gt;-forceTags&lt;/code&gt; when the parser is tested against a set of gold standard trees, use the tagged yield, instead of just the yield, as input.
   * &lt;/ul&gt;
   *
   * @param args An array of options arguments, command-line style.  E.g. {&quot;-maxLength&quot;, &quot;50&quot;}.
   * @param i The index in args to start at when processing an option
   * @return The index in args of the position after the last element used in
   *      processing this option, or the value i unchanged if a valid option couldn't
   *      be processed starting at position i.
   */
  protected int setOptionFlag(String[] args, int i) {
<span class="nc bnc" id="L203" title="All 2 branches missed.">    if (args[i].equalsIgnoreCase(&quot;-PCFG&quot;)) {</span>
<span class="nc" id="L204">      doDep = false;</span>
<span class="nc" id="L205">      doPCFG = true;</span>
<span class="nc" id="L206">      i++;</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-dep&quot;)) {</span>
<span class="nc" id="L208">      doDep = true;</span>
<span class="nc" id="L209">      doPCFG = false;</span>
<span class="nc" id="L210">      i++;</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-factored&quot;)) {</span>
<span class="nc" id="L212">      doDep = true;</span>
<span class="nc" id="L213">      doPCFG = true;</span>
<span class="nc" id="L214">      testOptions.useFastFactored = false;</span>
<span class="nc" id="L215">      i++;</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-fastFactored&quot;)) {</span>
<span class="nc" id="L217">      doDep = true;</span>
<span class="nc" id="L218">      doPCFG = true;</span>
<span class="nc" id="L219">      testOptions.useFastFactored = true;</span>
<span class="nc" id="L220">      i++;</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-noRecoveryTagging&quot;)) {</span>
<span class="nc" id="L222">      testOptions.noRecoveryTagging = true;</span>
<span class="nc" id="L223">      i++;</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-useLexiconToScoreDependencyPwGt&quot;)) {</span>
<span class="nc" id="L225">      testOptions.useLexiconToScoreDependencyPwGt = true;</span>
<span class="nc" id="L226">      i++;</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-useSmoothTagProjection&quot;)) {</span>
<span class="nc" id="L228">      useSmoothTagProjection = true;</span>
<span class="nc" id="L229">      i++;</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-useUnigramWordSmoothing&quot;)) {</span>
<span class="nc" id="L231">      useUnigramWordSmoothing = true;</span>
<span class="nc" id="L232">      i++;</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-useNonProjectiveDependencyParser&quot;)) {</span>
<span class="nc" id="L234">      testOptions.useNonProjectiveDependencyParser = true;</span>
<span class="nc" id="L235">      i++;</span>
<span class="nc bnc" id="L236" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-maxLength&quot;) &amp;&amp; (i + 1 &lt; args.length)) {</span>
<span class="nc" id="L237">      testOptions.maxLength = Integer.parseInt(args[i + 1]);</span>
<span class="nc" id="L238">      i += 2;</span>
<span class="nc bnc" id="L239" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-MAX_ITEMS&quot;) &amp;&amp; (i + 1 &lt; args.length)) {</span>
<span class="nc" id="L240">      testOptions.MAX_ITEMS = Integer.parseInt(args[i + 1]);</span>
<span class="nc" id="L241">      i += 2;</span>
<span class="nc bnc" id="L242" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-trainLength&quot;) &amp;&amp; (i + 1 &lt; args.length)) {</span>
      // train on only short sentences
<span class="nc" id="L244">      trainOptions.trainLengthLimit = Integer.parseInt(args[i + 1]);</span>
<span class="nc" id="L245">      i += 2;</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-lengthNormalization&quot;)) {</span>
<span class="nc" id="L247">      testOptions.lengthNormalization = true;</span>
<span class="nc" id="L248">      i++;</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-iterativeCKY&quot;)) {</span>
<span class="nc" id="L250">      testOptions.iterativeCKY = true;</span>
<span class="nc" id="L251">      i++;</span>
<span class="nc bnc" id="L252" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-vMarkov&quot;) &amp;&amp; (i + 1 &lt; args.length)) {</span>
<span class="nc" id="L253">      int order = Integer.parseInt(args[i + 1]);</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">      if (order &lt;= 1) {</span>
<span class="nc" id="L255">        trainOptions.PA = false;</span>
<span class="nc" id="L256">        trainOptions.gPA = false;</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">      } else if (order == 2) {</span>
<span class="nc" id="L258">        trainOptions.PA = true;</span>
<span class="nc" id="L259">        trainOptions.gPA = false;</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">      } else if (order &gt;= 3) {</span>
<span class="nc" id="L261">        trainOptions.PA = true;</span>
<span class="nc" id="L262">        trainOptions.gPA = true;</span>
      }
<span class="nc" id="L264">      i += 2;</span>
<span class="nc bnc" id="L265" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-vSelSplitCutOff&quot;) &amp;&amp; (i + 1 &lt; args.length)) {</span>
<span class="nc" id="L266">      trainOptions.selectiveSplitCutOff = Double.parseDouble(args[i + 1]);</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">      trainOptions.selectiveSplit = trainOptions.selectiveSplitCutOff &gt; 0.0;</span>
<span class="nc" id="L268">      i += 2;</span>
<span class="nc bnc" id="L269" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-vSelPostSplitCutOff&quot;) &amp;&amp; (i + 1 &lt; args.length)) {</span>
<span class="nc" id="L270">      trainOptions.selectivePostSplitCutOff = Double.parseDouble(args[i + 1]);</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">      trainOptions.selectivePostSplit = trainOptions.selectivePostSplitCutOff &gt; 0.0;</span>
<span class="nc" id="L272">      i += 2;</span>
<span class="nc bnc" id="L273" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-deleteSplitters&quot;) &amp;&amp; (i+1 &lt; args.length)) {</span>
<span class="nc" id="L274">      String[] toDel = args[i+1].split(&quot; *, *&quot;);</span>
<span class="nc" id="L275">      trainOptions.deleteSplitters = Generics.newHashSet(Arrays.asList(toDel));</span>
<span class="nc" id="L276">      i += 2;</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-postSplitWithBaseCategory&quot;)) {</span>
<span class="nc" id="L278">      trainOptions.postSplitWithBaseCategory = true;</span>
<span class="nc" id="L279">      i += 1;</span>
<span class="nc bnc" id="L280" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-vPostMarkov&quot;) &amp;&amp; (i + 1 &lt; args.length)) {</span>
<span class="nc" id="L281">      int order = Integer.parseInt(args[i + 1]);</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">      if (order &lt;= 1) {</span>
<span class="nc" id="L283">        trainOptions.postPA = false;</span>
<span class="nc" id="L284">        trainOptions.postGPA = false;</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">      } else if (order == 2) {</span>
<span class="nc" id="L286">        trainOptions.postPA = true;</span>
<span class="nc" id="L287">        trainOptions.postGPA = false;</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">      } else if (order &gt;= 3) {</span>
<span class="nc" id="L289">        trainOptions.postPA = true;</span>
<span class="nc" id="L290">        trainOptions.postGPA = true;</span>
      }
<span class="nc" id="L292">      i += 2;</span>
<span class="nc bnc" id="L293" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-hMarkov&quot;) &amp;&amp; (i + 1 &lt; args.length)) {</span>
<span class="nc" id="L294">      int order = Integer.parseInt(args[i + 1]);</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">      if (order &gt;= 0) {</span>
<span class="nc" id="L296">        trainOptions.markovOrder = order;</span>
<span class="nc" id="L297">        trainOptions.markovFactor = true;</span>
      } else {
<span class="nc" id="L299">        trainOptions.markovFactor = false;</span>
      }
<span class="nc" id="L301">      i += 2;</span>
<span class="nc bnc" id="L302" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-distanceBins&quot;) &amp;&amp; (i + 1 &lt; args.length)) {</span>
<span class="nc" id="L303">      int numBins = Integer.parseInt(args[i + 1]);</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">      if (numBins &lt;= 1) {</span>
<span class="nc" id="L305">        distance = false;</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">      } else if (numBins == 4) {</span>
<span class="nc" id="L307">        distance = true;</span>
<span class="nc" id="L308">        coarseDistance = true;</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">      } else if (numBins == 5) {</span>
<span class="nc" id="L310">        distance = true;</span>
<span class="nc" id="L311">        coarseDistance = false;</span>
      } else {
<span class="nc" id="L313">        throw new IllegalArgumentException(&quot;Invalid value for -distanceBin: &quot; + args[i+1]);</span>
      }
<span class="nc" id="L315">      i += 2;</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-noStop&quot;)) {</span>
<span class="nc" id="L317">      genStop = false;</span>
<span class="nc" id="L318">      i++;</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-nonDirectional&quot;)) {</span>
<span class="nc" id="L320">      directional = false;</span>
<span class="nc" id="L321">      i++;</span>
<span class="nc bnc" id="L322" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-depWeight&quot;) &amp;&amp; (i + 1 &lt; args.length)) {</span>
<span class="nc" id="L323">      testOptions.depWeight = Double.parseDouble(args[i + 1]);</span>
<span class="nc" id="L324">      i += 2;</span>
<span class="nc bnc" id="L325" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-printPCFGkBest&quot;) &amp;&amp; (i + 1 &lt; args.length)) {</span>
<span class="nc" id="L326">      testOptions.printPCFGkBest = Integer.parseInt(args[i + 1]);</span>
<span class="nc" id="L327">      i += 2;</span>
<span class="nc bnc" id="L328" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-evalPCFGkBest&quot;) &amp;&amp; (i + 1 &lt; args.length)) {</span>
<span class="nc" id="L329">      testOptions.evalPCFGkBest = Integer.parseInt(args[i + 1]);</span>
<span class="nc" id="L330">      i += 2;</span>
<span class="nc bnc" id="L331" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-printFactoredKGood&quot;) &amp;&amp; (i + 1 &lt; args.length)) {</span>
<span class="nc" id="L332">      testOptions.printFactoredKGood = Integer.parseInt(args[i + 1]);</span>
<span class="nc" id="L333">      i += 2;</span>
<span class="nc bnc" id="L334" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-smoothTagsThresh&quot;) &amp;&amp; (i + 1 &lt; args.length)) {</span>
<span class="nc" id="L335">      lexOptions.smoothInUnknownsThreshold = Integer.parseInt(args[i + 1]);</span>
<span class="nc" id="L336">      i += 2;</span>
<span class="nc bnc" id="L337" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-unseenSmooth&quot;) &amp;&amp; (i + 1 &lt; args.length)) {</span>
<span class="nc" id="L338">      testOptions.unseenSmooth = Double.parseDouble(args[i + 1]);</span>
<span class="nc" id="L339">      i += 2;</span>
<span class="nc bnc" id="L340" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-fractionBeforeUnseenCounting&quot;) &amp;&amp; (i + 1 &lt; args.length)) {</span>
<span class="nc" id="L341">      trainOptions.fractionBeforeUnseenCounting = Double.parseDouble(args[i + 1]);</span>
<span class="nc" id="L342">      i += 2;</span>
<span class="nc bnc" id="L343" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-hSelSplitThresh&quot;) &amp;&amp; (i + 1 &lt; args.length)) {</span>
<span class="nc" id="L344">      trainOptions.HSEL_CUT = Integer.parseInt(args[i + 1]);</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">      trainOptions.hSelSplit = trainOptions.HSEL_CUT &gt; 0;</span>
<span class="nc" id="L346">      i += 2;</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-nohSelSplit&quot;)) {</span>
<span class="nc" id="L348">      trainOptions.hSelSplit = false;</span>
<span class="nc" id="L349">      i += 1;</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-tagPA&quot;)) {</span>
<span class="nc" id="L351">      trainOptions.tagPA = true;</span>
<span class="nc" id="L352">      i += 1;</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-noTagPA&quot;)) {</span>
<span class="nc" id="L354">      trainOptions.tagPA = false;</span>
<span class="nc" id="L355">      i += 1;</span>
<span class="nc bnc" id="L356" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-tagSelSplitCutOff&quot;) &amp;&amp; (i + 1 &lt; args.length)) {</span>
<span class="nc" id="L357">      trainOptions.tagSelectiveSplitCutOff = Double.parseDouble(args[i + 1]);</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">      trainOptions.tagSelectiveSplit = trainOptions.tagSelectiveSplitCutOff &gt; 0.0;</span>
<span class="nc" id="L359">      i += 2;</span>
<span class="nc bnc" id="L360" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-tagSelPostSplitCutOff&quot;) &amp;&amp; (i + 1 &lt; args.length)) {</span>
<span class="nc" id="L361">      trainOptions.tagSelectivePostSplitCutOff = Double.parseDouble(args[i + 1]);</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">      trainOptions.tagSelectivePostSplit = trainOptions.tagSelectivePostSplitCutOff &gt; 0.0;</span>
<span class="nc" id="L363">      i += 2;</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-noTagSplit&quot;)) {</span>
<span class="nc" id="L365">      trainOptions.noTagSplit = true;</span>
<span class="nc" id="L366">      i += 1;</span>
<span class="nc bnc" id="L367" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-uwm&quot;) &amp;&amp; (i + 1 &lt; args.length)) {</span>
<span class="nc" id="L368">      lexOptions.useUnknownWordSignatures = Integer.parseInt(args[i + 1]);</span>
<span class="nc" id="L369">      i += 2;</span>
<span class="nc bnc" id="L370" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-unknownSuffixSize&quot;) &amp;&amp; (i + 1 &lt; args.length)) {</span>
<span class="nc" id="L371">      lexOptions.unknownSuffixSize = Integer.parseInt(args[i + 1]);</span>
<span class="nc" id="L372">      i += 2;</span>
<span class="nc bnc" id="L373" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-unknownPrefixSize&quot;) &amp;&amp; (i + 1 &lt; args.length)) {</span>
<span class="nc" id="L374">      lexOptions.unknownPrefixSize = Integer.parseInt(args[i + 1]);</span>
<span class="nc" id="L375">      i += 2;</span>
<span class="nc bnc" id="L376" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-uwModelTrainer&quot;) &amp;&amp; (i + 1 &lt; args.length)) {</span>
<span class="nc" id="L377">      lexOptions.uwModelTrainer = args[i+1];</span>
<span class="nc" id="L378">      i += 2;</span>
<span class="nc bnc" id="L379" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-openClassThreshold&quot;) &amp;&amp; (i + 1 &lt; args.length)) {</span>
<span class="nc" id="L380">      trainOptions.openClassTypesThreshold = Integer.parseInt(args[i + 1]);</span>
<span class="nc" id="L381">      i += 2;</span>
<span class="nc bnc" id="L382" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-unary&quot;) &amp;&amp; i+1 &lt; args.length) {</span>
<span class="nc" id="L383">      trainOptions.markUnary = Integer.parseInt(args[i+1]);</span>
<span class="nc" id="L384">      i += 2;</span>
<span class="nc bnc" id="L385" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-unaryTags&quot;)) {</span>
<span class="nc" id="L386">      trainOptions.markUnaryTags = true;</span>
<span class="nc" id="L387">      i += 1;</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-mutate&quot;)) {</span>
<span class="nc" id="L389">      lexOptions.smartMutation = true;</span>
<span class="nc" id="L390">      i += 1;</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-useUnicodeType&quot;)) {</span>
<span class="nc" id="L392">      lexOptions.useUnicodeType = true;</span>
<span class="nc" id="L393">      i += 1;</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-rightRec&quot;)) {</span>
<span class="nc" id="L395">      trainOptions.rightRec = true;</span>
<span class="nc" id="L396">      i += 1;</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-noRightRec&quot;)) {</span>
<span class="nc" id="L398">      trainOptions.rightRec = false;</span>
<span class="nc" id="L399">      i += 1;</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-preTag&quot;)) {</span>
<span class="nc" id="L401">      testOptions.preTag = true;</span>
<span class="nc" id="L402">      i += 1;</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-forceTags&quot;)) {</span>
<span class="nc" id="L404">      testOptions.forceTags = true;</span>
<span class="nc" id="L405">      i += 1;</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-taggerSerializedFile&quot;)) {</span>
<span class="nc" id="L407">      testOptions.taggerSerializedFile = args[i+1];</span>
<span class="nc" id="L408">      i += 2;</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-forceTagBeginnings&quot;)) {</span>
<span class="nc" id="L410">      testOptions.forceTagBeginnings = true;</span>
<span class="nc" id="L411">      i += 1;</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-noFunctionalForcing&quot;)) {</span>
<span class="nc" id="L413">      testOptions.noFunctionalForcing = true;</span>
<span class="nc" id="L414">      i += 1;</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-scTags&quot;)) {</span>
<span class="nc" id="L416">      dcTags = false;</span>
<span class="nc" id="L417">      i += 1;</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-dcTags&quot;)) {</span>
<span class="nc" id="L419">      dcTags = true;</span>
<span class="nc" id="L420">      i += 1;</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-basicCategoryTagsInDependencyGrammar&quot;)) {</span>
<span class="nc" id="L422">      trainOptions.basicCategoryTagsInDependencyGrammar = true;</span>
<span class="nc" id="L423">      i+= 1;</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-evalb&quot;)) {</span>
<span class="nc" id="L425">      testOptions.evalb = true;</span>
<span class="nc" id="L426">      i += 1;</span>
<span class="nc bnc" id="L427" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-v&quot;) || args[i].equalsIgnoreCase(&quot;-verbose&quot;)) {</span>
<span class="nc" id="L428">      testOptions.verbose = true;</span>
<span class="nc" id="L429">      i += 1;</span>
<span class="nc bnc" id="L430" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-outputFilesDirectory&quot;) &amp;&amp; i+1 &lt; args.length) {</span>
<span class="nc" id="L431">      testOptions.outputFilesDirectory = args[i+1];</span>
<span class="nc" id="L432">      i += 2;</span>
<span class="nc bnc" id="L433" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-outputFilesExtension&quot;) &amp;&amp; i+1 &lt; args.length) {</span>
<span class="nc" id="L434">      testOptions.outputFilesExtension = args[i+1];</span>
<span class="nc" id="L435">      i += 2;</span>
<span class="nc bnc" id="L436" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-outputFilesPrefix&quot;) &amp;&amp; i+1 &lt; args.length) {</span>
<span class="nc" id="L437">      testOptions.outputFilesPrefix = args[i+1];</span>
<span class="nc" id="L438">      i += 2;</span>
<span class="nc bnc" id="L439" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-outputkBestEquivocation&quot;) &amp;&amp; i+1 &lt; args.length) {</span>
<span class="nc" id="L440">      testOptions.outputkBestEquivocation = args[i+1];</span>
<span class="nc" id="L441">      i += 2;</span>
<span class="nc bnc" id="L442" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-writeOutputFiles&quot;)) {</span>
<span class="nc" id="L443">      testOptions.writeOutputFiles = true;</span>
<span class="nc" id="L444">      i += 1;</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-printAllBestParses&quot;)) {</span>
<span class="nc" id="L446">      testOptions.printAllBestParses = true;</span>
<span class="nc" id="L447">      i += 1;</span>
<span class="nc bnc" id="L448" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-outputTreeFormat&quot;) || args[i].equalsIgnoreCase(&quot;-outputFormat&quot;)) {</span>
<span class="nc" id="L449">      testOptions.outputFormat = args[i + 1];</span>
<span class="nc" id="L450">      i += 2;</span>
<span class="nc bnc" id="L451" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-outputTreeFormatOptions&quot;) || args[i].equalsIgnoreCase(&quot;-outputFormatOptions&quot;)) {</span>
<span class="nc" id="L452">      testOptions.outputFormatOptions = args[i + 1];</span>
<span class="nc" id="L453">      i += 2;</span>
<span class="nc bnc" id="L454" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-addMissingFinalPunctuation&quot;)) {</span>
<span class="nc" id="L455">      testOptions.addMissingFinalPunctuation = true;</span>
<span class="nc" id="L456">      i += 1;</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-flexiTag&quot;)) {</span>
<span class="nc" id="L458">      lexOptions.flexiTag = true;</span>
<span class="nc" id="L459">      i += 1;</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-lexiTag&quot;)) {</span>
<span class="nc" id="L461">      lexOptions.flexiTag = false;</span>
<span class="nc" id="L462">      i += 1;</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-useSignatureForKnownSmoothing&quot;)) {</span>
<span class="nc" id="L464">      lexOptions.useSignatureForKnownSmoothing = true;</span>
<span class="nc" id="L465">      i += 1;</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-wordClassesFile&quot;)) {</span>
<span class="nc" id="L467">      lexOptions.wordClassesFile = args[i+1];</span>
<span class="nc" id="L468">      i += 2;</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-compactGrammar&quot;)) {</span>
<span class="nc" id="L470">      trainOptions.compactGrammar = Integer.parseInt(args[i + 1]);</span>
<span class="nc" id="L471">      i += 2;</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-markFinalStates&quot;)) {</span>
<span class="nc" id="L473">      trainOptions.markFinalStates = args[i + 1].equalsIgnoreCase(&quot;true&quot;);</span>
<span class="nc" id="L474">      i += 2;</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-leftToRight&quot;)) {</span>
<span class="nc" id="L476">      trainOptions.leftToRight = args[i + 1].equals(&quot;true&quot;);</span>
<span class="nc" id="L477">      i += 2;</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-cnf&quot;)) {</span>
<span class="nc" id="L479">      forceCNF = true;</span>
<span class="nc" id="L480">      i += 1;</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">    } else if(args[i].equalsIgnoreCase(&quot;-smoothRules&quot;)) {</span>
<span class="nc" id="L482">      trainOptions.ruleSmoothing = true;</span>
<span class="nc" id="L483">      trainOptions.ruleSmoothingAlpha = Double.valueOf(args[i+1]);</span>
<span class="nc" id="L484">      i += 2;</span>
<span class="nc bnc" id="L485" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-nodePrune&quot;) &amp;&amp; i+1 &lt; args.length) {</span>
<span class="nc" id="L486">      nodePrune = args[i+1].equalsIgnoreCase(&quot;true&quot;);</span>
<span class="nc" id="L487">      i += 2;</span>
<span class="nc bnc" id="L488" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-noDoRecovery&quot;)) {</span>
<span class="nc" id="L489">      testOptions.doRecovery = false;</span>
<span class="nc" id="L490">      i += 1;</span>
<span class="nc bnc" id="L491" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-acl03chinese&quot;)) {</span>
<span class="nc" id="L492">      trainOptions.markovOrder = 1;</span>
<span class="nc" id="L493">      trainOptions.markovFactor = true;</span>
      // no increment
<span class="nc bnc" id="L495" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-wordFunction&quot;)) {</span>
<span class="nc" id="L496">      wordFunction = ReflectionLoading.loadByReflection(args[i + 1]);</span>
<span class="nc" id="L497">      i += 2;</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-acl03pcfg&quot;)) {</span>
<span class="nc" id="L499">      doDep = false;</span>
<span class="nc" id="L500">      doPCFG = true;</span>
      // lexOptions.smoothInUnknownsThreshold = 30;
<span class="nc" id="L502">      trainOptions.markUnary = 1;</span>
<span class="nc" id="L503">      trainOptions.PA = true;</span>
<span class="nc" id="L504">      trainOptions.gPA = false;</span>
<span class="nc" id="L505">      trainOptions.tagPA = true;</span>
<span class="nc" id="L506">      trainOptions.tagSelectiveSplit = false;</span>
<span class="nc" id="L507">      trainOptions.rightRec = true;</span>
<span class="nc" id="L508">      trainOptions.selectiveSplit = true;</span>
<span class="nc" id="L509">      trainOptions.selectiveSplitCutOff = 400.0;</span>
<span class="nc" id="L510">      trainOptions.markovFactor = true;</span>
<span class="nc" id="L511">      trainOptions.markovOrder = 2;</span>
<span class="nc" id="L512">      trainOptions.hSelSplit = true;</span>
<span class="nc" id="L513">      lexOptions.useUnknownWordSignatures = 2;</span>
<span class="nc" id="L514">      lexOptions.flexiTag = true;</span>
      // DAN: Tag double-counting is BAD for PCFG-only parsing
<span class="nc" id="L516">      dcTags = false;</span>
      // don't increment i so it gets language specific stuff as well
<span class="nc bnc" id="L518" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-jenny&quot;)) {</span>
<span class="nc" id="L519">      doDep = false;</span>
<span class="nc" id="L520">      doPCFG = true;</span>
      // lexOptions.smoothInUnknownsThreshold = 30;
<span class="nc" id="L522">      trainOptions.markUnary = 1;</span>
<span class="nc" id="L523">      trainOptions.PA = false;</span>
<span class="nc" id="L524">      trainOptions.gPA = false;</span>
<span class="nc" id="L525">      trainOptions.tagPA = false;</span>
<span class="nc" id="L526">      trainOptions.tagSelectiveSplit = false;</span>
<span class="nc" id="L527">      trainOptions.rightRec = true;</span>
<span class="nc" id="L528">      trainOptions.selectiveSplit = false;</span>
//      trainOptions.selectiveSplitCutOff = 400.0;
<span class="nc" id="L530">      trainOptions.markovFactor = false;</span>
//      trainOptions.markovOrder = 2;
<span class="nc" id="L532">      trainOptions.hSelSplit = false;</span>
<span class="nc" id="L533">      lexOptions.useUnknownWordSignatures = 2;</span>
<span class="nc" id="L534">      lexOptions.flexiTag = true;</span>
      // DAN: Tag double-counting is BAD for PCFG-only parsing
<span class="nc" id="L536">      dcTags = false;</span>
      // don't increment i so it gets language specific stuff as well
<span class="nc bnc" id="L538" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-goodPCFG&quot;)) {</span>
<span class="nc" id="L539">      doDep = false;</span>
<span class="nc" id="L540">      doPCFG = true;</span>
      // op.lexOptions.smoothInUnknownsThreshold = 30;
<span class="nc" id="L542">      trainOptions.markUnary = 1;</span>
<span class="nc" id="L543">      trainOptions.PA = true;</span>
<span class="nc" id="L544">      trainOptions.gPA = false;</span>
<span class="nc" id="L545">      trainOptions.tagPA = true;</span>
<span class="nc" id="L546">      trainOptions.tagSelectiveSplit = false;</span>
<span class="nc" id="L547">      trainOptions.rightRec = true;</span>
<span class="nc" id="L548">      trainOptions.selectiveSplit = true;</span>
<span class="nc" id="L549">      trainOptions.selectiveSplitCutOff = 400.0;</span>
<span class="nc" id="L550">      trainOptions.markovFactor = true;</span>
<span class="nc" id="L551">      trainOptions.markovOrder = 2;</span>
<span class="nc" id="L552">      trainOptions.hSelSplit = true;</span>
<span class="nc" id="L553">      lexOptions.useUnknownWordSignatures = 2;</span>
<span class="nc" id="L554">      lexOptions.flexiTag = true;</span>
      // DAN: Tag double-counting is BAD for PCFG-only parsing
<span class="nc" id="L556">      dcTags = false;</span>
<span class="nc" id="L557">      String[] delSplit = { &quot;-deleteSplitters&quot;, &quot;VP^NP,VP^VP,VP^SINV,VP^SQ&quot; };</span>
<span class="nc bnc" id="L558" title="All 2 branches missed.">      if (this.setOptionFlag(delSplit, 0) != 2) {</span>
<span class="nc" id="L559">        log.info(&quot;Error processing deleteSplitters&quot;);</span>
      }
      // don't increment i so it gets language specific stuff as well
<span class="nc bnc" id="L562" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-linguisticPCFG&quot;)) {</span>
<span class="nc" id="L563">      doDep = false;</span>
<span class="nc" id="L564">      doPCFG = true;</span>
      // op.lexOptions.smoothInUnknownsThreshold = 30;
<span class="nc" id="L566">      trainOptions.markUnary = 1;</span>
<span class="nc" id="L567">      trainOptions.PA = true;</span>
<span class="nc" id="L568">      trainOptions.gPA = false;</span>
<span class="nc" id="L569">      trainOptions.tagPA = true;        // on at the moment, but iffy</span>
<span class="nc" id="L570">      trainOptions.tagSelectiveSplit = false;</span>
<span class="nc" id="L571">      trainOptions.rightRec = false;    // not for linguistic</span>
<span class="nc" id="L572">      trainOptions.selectiveSplit = true;</span>
<span class="nc" id="L573">      trainOptions.selectiveSplitCutOff = 400.0;</span>
<span class="nc" id="L574">      trainOptions.markovFactor = true;</span>
<span class="nc" id="L575">      trainOptions.markovOrder = 2;</span>
<span class="nc" id="L576">      trainOptions.hSelSplit = true;</span>
<span class="nc" id="L577">      lexOptions.useUnknownWordSignatures = 5;   // different from acl03pcfg</span>
<span class="nc" id="L578">      lexOptions.flexiTag = false;       // different from acl03pcfg</span>
      // DAN: Tag double-counting is BAD for PCFG-only parsing
<span class="nc" id="L580">      dcTags = false;</span>
      // don't increment i so it gets language specific stuff as well
<span class="nc bnc" id="L582" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-ijcai03&quot;)) {</span>
<span class="nc" id="L583">      doDep = true;</span>
<span class="nc" id="L584">      doPCFG = true;</span>
<span class="nc" id="L585">      trainOptions.markUnary = 0;</span>
<span class="nc" id="L586">      trainOptions.PA = true;</span>
<span class="nc" id="L587">      trainOptions.gPA = false;</span>
<span class="nc" id="L588">      trainOptions.tagPA = false;</span>
<span class="nc" id="L589">      trainOptions.tagSelectiveSplit = false;</span>
<span class="nc" id="L590">      trainOptions.rightRec = false;</span>
<span class="nc" id="L591">      trainOptions.selectiveSplit = true;</span>
<span class="nc" id="L592">      trainOptions.selectiveSplitCutOff = 300.0;</span>
<span class="nc" id="L593">      trainOptions.markovFactor = true;</span>
<span class="nc" id="L594">      trainOptions.markovOrder = 2;</span>
<span class="nc" id="L595">      trainOptions.hSelSplit = true;</span>
<span class="nc" id="L596">      trainOptions.compactGrammar = 0; /// cdm: May 2005 compacting bad for factored?</span>
<span class="nc" id="L597">      lexOptions.useUnknownWordSignatures = 2;</span>
<span class="nc" id="L598">      lexOptions.flexiTag = false;</span>
<span class="nc" id="L599">      dcTags = true;</span>
      // op.nodePrune = true;  // cdm: May 2005: this doesn't help
      // don't increment i so it gets language specific stuff as well
<span class="nc bnc" id="L602" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-goodFactored&quot;)) {</span>
<span class="nc" id="L603">      doDep = true;</span>
<span class="nc" id="L604">      doPCFG = true;</span>
<span class="nc" id="L605">      trainOptions.markUnary = 0;</span>
<span class="nc" id="L606">      trainOptions.PA = true;</span>
<span class="nc" id="L607">      trainOptions.gPA = false;</span>
<span class="nc" id="L608">      trainOptions.tagPA = false;</span>
<span class="nc" id="L609">      trainOptions.tagSelectiveSplit = false;</span>
<span class="nc" id="L610">      trainOptions.rightRec = false;</span>
<span class="nc" id="L611">      trainOptions.selectiveSplit = true;</span>
<span class="nc" id="L612">      trainOptions.selectiveSplitCutOff = 300.0;</span>
<span class="nc" id="L613">      trainOptions.markovFactor = true;</span>
<span class="nc" id="L614">      trainOptions.markovOrder = 2;</span>
<span class="nc" id="L615">      trainOptions.hSelSplit = true;</span>
<span class="nc" id="L616">      trainOptions.compactGrammar = 0; /// cdm: May 2005 compacting bad for factored?</span>
<span class="nc" id="L617">      lexOptions.useUnknownWordSignatures = 5;  // different from ijcai03</span>
<span class="nc" id="L618">      lexOptions.flexiTag = false;</span>
<span class="nc" id="L619">      dcTags = true;</span>
      // op.nodePrune = true;  // cdm: May 2005: this doesn't help
      // don't increment i so it gets language specific stuff as well
<span class="nc bnc" id="L622" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-chineseFactored&quot;)) {</span>
      // Single counting tag-&gt;word rewrite is also much better for Chinese
      // Factored.  Bracketing F1 goes up about 0.7%.
<span class="nc" id="L625">      dcTags = false;</span>
<span class="nc" id="L626">      lexOptions.useUnicodeType = true;</span>
<span class="nc" id="L627">      trainOptions.markovOrder = 2;</span>
<span class="nc" id="L628">      trainOptions.hSelSplit = true;</span>
<span class="nc" id="L629">      trainOptions.markovFactor = true;</span>
<span class="nc" id="L630">      trainOptions.HSEL_CUT = 50;</span>
      // trainOptions.openClassTypesThreshold=1;  // so can get unseen punctuation
      // trainOptions.fractionBeforeUnseenCounting=0.0;  // so can get unseen punctuation
      // don't increment i so it gets language specific stuff as well
<span class="nc bnc" id="L634" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-arabicFactored&quot;)) {</span>
<span class="nc" id="L635">      doDep = true;</span>
<span class="nc" id="L636">      doPCFG = true;</span>
<span class="nc" id="L637">      dcTags = false;   // &quot;false&quot; seems to help Arabic about 0.1% F1</span>
<span class="nc" id="L638">      trainOptions.markovFactor = true;</span>
<span class="nc" id="L639">      trainOptions.markovOrder = 2;</span>
<span class="nc" id="L640">      trainOptions.hSelSplit = true;</span>
<span class="nc" id="L641">      trainOptions.HSEL_CUT = 75;  // 75 bit better than 50, 100 a bit worse</span>
<span class="nc" id="L642">      trainOptions.PA = true;</span>
<span class="nc" id="L643">      trainOptions.gPA = false;</span>
<span class="nc" id="L644">      trainOptions.selectiveSplit = true;</span>
<span class="nc" id="L645">      trainOptions.selectiveSplitCutOff = 300.0;</span>
<span class="nc" id="L646">      trainOptions.markUnary = 1;  // Helps PCFG and marginally factLB</span>
      // trainOptions.compactGrammar = 0;  // Doesn't seem to help or only 0.05% F1
<span class="nc" id="L648">      lexOptions.useUnknownWordSignatures = 9;</span>
<span class="nc" id="L649">      lexOptions.unknownPrefixSize = 1;</span>
<span class="nc" id="L650">      lexOptions.unknownSuffixSize = 1;</span>
<span class="nc" id="L651">      testOptions.MAX_ITEMS = 500000; // Arabic sentences are long enough that this helps a fraction</span>
      // don't increment i so it gets language specific stuff as well
<span class="nc bnc" id="L653" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-frenchFactored&quot;)) {</span>
<span class="nc" id="L654">      doDep = true;</span>
<span class="nc" id="L655">      doPCFG = true;</span>
<span class="nc" id="L656">      dcTags = false;   //wsg2011: Setting to false improves F1 by 0.5%</span>
<span class="nc" id="L657">      trainOptions.markovFactor = true;</span>
<span class="nc" id="L658">      trainOptions.markovOrder = 2;</span>
<span class="nc" id="L659">      trainOptions.hSelSplit = true;</span>
<span class="nc" id="L660">      trainOptions.HSEL_CUT = 75;</span>
<span class="nc" id="L661">      trainOptions.PA = true;</span>
<span class="nc" id="L662">      trainOptions.gPA = false;</span>
<span class="nc" id="L663">      trainOptions.selectiveSplit = true;</span>
<span class="nc" id="L664">      trainOptions.selectiveSplitCutOff = 300.0;</span>
<span class="nc" id="L665">      trainOptions.markUnary = 0; //Unary rule marking bad for french..setting to 0 gives +0.3 F1</span>
<span class="nc" id="L666">      lexOptions.useUnknownWordSignatures = 1;</span>
<span class="nc" id="L667">      lexOptions.unknownPrefixSize = 1;</span>
<span class="nc" id="L668">      lexOptions.unknownSuffixSize = 2;</span>

<span class="nc bnc" id="L670" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-chinesePCFG&quot;)) {</span>
<span class="nc" id="L671">      trainOptions.markovOrder = 2;</span>
<span class="nc" id="L672">      trainOptions.markovFactor = true;</span>
<span class="nc" id="L673">      trainOptions.HSEL_CUT = 5;</span>
<span class="nc" id="L674">      trainOptions.PA = true;</span>
<span class="nc" id="L675">      trainOptions.gPA = true;</span>
<span class="nc" id="L676">      trainOptions.selectiveSplit = false;</span>
<span class="nc" id="L677">      doDep = false;</span>
<span class="nc" id="L678">      doPCFG = true;</span>
      // Single counting tag-&gt;word rewrite is also much better for Chinese PCFG
      // Bracketing F1 is up about 2% and tag accuracy about 1% (exact by 6%)
<span class="nc" id="L681">      dcTags = false;</span>
      // no increment
<span class="nc bnc" id="L683" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-printTT&quot;) &amp;&amp; (i+1 &lt; args.length)) {</span>
<span class="nc" id="L684">      trainOptions.printTreeTransformations = Integer.parseInt(args[i + 1]);</span>
<span class="nc" id="L685">      i += 2;</span>
<span class="nc bnc" id="L686" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-printAnnotatedRuleCounts&quot;)) {</span>
<span class="nc" id="L687">      trainOptions.printAnnotatedRuleCounts = true;</span>
<span class="nc" id="L688">      i++;</span>
<span class="nc bnc" id="L689" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-printAnnotatedStateCounts&quot;)) {</span>
<span class="nc" id="L690">      trainOptions.printAnnotatedStateCounts = true;</span>
<span class="nc" id="L691">      i++;</span>
<span class="nc bnc" id="L692" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-printAnnotated&quot;) &amp;&amp; (i + 1 &lt; args.length)) {</span>
      try {
<span class="nc" id="L694">        trainOptions.printAnnotatedPW = tlpParams.pw(new FileOutputStream(args[i + 1]));</span>
<span class="nc" id="L695">      } catch (IOException ioe) {</span>
<span class="nc" id="L696">        trainOptions.printAnnotatedPW = null;</span>
<span class="nc" id="L697">      }</span>
<span class="nc" id="L698">      i += 2;</span>
<span class="nc bnc" id="L699" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-printBinarized&quot;) &amp;&amp; (i + 1 &lt; args.length)) {</span>
      try {
<span class="nc" id="L701">        trainOptions.printBinarizedPW = tlpParams.pw(new FileOutputStream(args[i + 1]));</span>
<span class="nc" id="L702">      } catch (IOException ioe) {</span>
<span class="nc" id="L703">        trainOptions.printBinarizedPW = null;</span>
<span class="nc" id="L704">      }</span>
<span class="nc" id="L705">      i += 2;</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-printStates&quot;)) {</span>
<span class="nc" id="L707">      trainOptions.printStates = true;</span>
<span class="nc" id="L708">      i++;</span>
<span class="nc bnc" id="L709" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-preTransformer&quot;) &amp;&amp; (i + 1 &lt; args.length)) {</span>
<span class="nc" id="L710">      String[] classes = args[i + 1].split(&quot;,&quot;);</span>
<span class="nc" id="L711">      i += 2;</span>
<span class="nc bnc" id="L712" title="All 2 branches missed.">      if (classes.length == 1) {</span>
<span class="nc" id="L713">        trainOptions.preTransformer =</span>
<span class="nc" id="L714">          ReflectionLoading.loadByReflection(classes[0], this);</span>
<span class="nc bnc" id="L715" title="All 2 branches missed.">      } else if (classes.length &gt; 1) {</span>
<span class="nc" id="L716">        CompositeTreeTransformer composite = new CompositeTreeTransformer();</span>
<span class="nc" id="L717">        trainOptions.preTransformer = composite;</span>
<span class="nc bnc" id="L718" title="All 2 branches missed.">        for (String clazz : classes) {</span>
<span class="nc" id="L719">          TreeTransformer transformer =</span>
<span class="nc" id="L720">            ReflectionLoading.loadByReflection(clazz, this);</span>
<span class="nc" id="L721">          composite.addTransformer(transformer);</span>
        }
      }
<span class="nc bnc" id="L724" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-taggedFiles&quot;) &amp;&amp; (i + 1 &lt; args.length)) {</span>
<span class="nc" id="L725">      trainOptions.taggedFiles = args[i + 1];</span>
<span class="nc" id="L726">      i += 2;</span>
<span class="nc bnc" id="L727" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-predictSplits&quot;)) {</span>
      // This is an experimental (and still in development)
      // reimplementation of Berkeley's state splitting grammar.
<span class="nc" id="L730">      trainOptions.predictSplits = true;</span>
<span class="nc" id="L731">      trainOptions.compactGrammar = 0;</span>
<span class="nc" id="L732">      i++;</span>
<span class="nc bnc" id="L733" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-splitCount&quot;)) {</span>
<span class="nc" id="L734">      trainOptions.splitCount = Integer.parseInt(args[i + 1]);</span>
<span class="nc" id="L735">      i += 2;</span>
<span class="nc bnc" id="L736" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-splitRecombineRate&quot;)) {</span>
<span class="nc" id="L737">      trainOptions.splitRecombineRate = Double.parseDouble(args[i + 1]);</span>
<span class="nc" id="L738">      i += 2;</span>
<span class="nc bnc" id="L739" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-trainingThreads&quot;) ||</span>
<span class="nc bnc" id="L740" title="All 2 branches missed.">               args[i].equalsIgnoreCase(&quot;-nThreads&quot;)) {</span>
<span class="nc" id="L741">      trainOptions.trainingThreads = Integer.parseInt(args[i + 1]);</span>
<span class="nc" id="L742">      testOptions.testingThreads = Integer.parseInt(args[i + 1]);</span>
<span class="nc" id="L743">      i += 2;</span>
<span class="nc bnc" id="L744" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-testingThreads&quot;)) {</span>
<span class="nc" id="L745">      testOptions.testingThreads = Integer.parseInt(args[i + 1]);</span>
<span class="nc" id="L746">      i += 2;</span>
<span class="nc bnc" id="L747" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-evals&quot;)) {</span>
<span class="nc" id="L748">      testOptions.evals = StringUtils.stringToProperties(args[i+1], testOptions.evals);</span>
<span class="nc" id="L749">      i += 2;</span>
<span class="nc bnc" id="L750" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-fastFactoredCandidateMultiplier&quot;)) {</span>
<span class="nc" id="L751">      testOptions.fastFactoredCandidateMultiplier = Integer.parseInt(args[i + 1]);</span>
<span class="nc" id="L752">      i += 2;</span>
<span class="nc bnc" id="L753" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-fastFactoredCandidateAddend&quot;)) {</span>
<span class="nc" id="L754">      testOptions.fastFactoredCandidateAddend = Integer.parseInt(args[i + 1]);</span>
<span class="nc" id="L755">      i += 2;</span>
<span class="nc bnc" id="L756" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-quietEvaluation&quot;)) {</span>
<span class="nc" id="L757">      testOptions.quietEvaluation = true;</span>
<span class="nc" id="L758">      i += 1;</span>
<span class="nc bnc" id="L759" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-noquietEvaluation&quot;)) {</span>
<span class="nc" id="L760">      testOptions.quietEvaluation = false;</span>
<span class="nc" id="L761">      i += 1;</span>
<span class="nc bnc" id="L762" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-simpleBinarizedLabels&quot;)) {</span>
<span class="nc" id="L763">      trainOptions.simpleBinarizedLabels = true;</span>
<span class="nc" id="L764">      i += 1;</span>
<span class="nc bnc" id="L765" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-noRebinarization&quot;)) {</span>
<span class="nc" id="L766">      trainOptions.noRebinarization = true;</span>
<span class="nc" id="L767">      i += 1;</span>
<span class="nc bnc" id="L768" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-dvKBest&quot;)) {</span>
<span class="nc" id="L769">        trainOptions.dvKBest = Integer.parseInt(args[i + 1]);</span>
<span class="nc" id="L770">        rerankerKBest = trainOptions.dvKBest;</span>
<span class="nc" id="L771">        i += 2;</span>
<span class="nc bnc" id="L772" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-regCost&quot;)) {</span>
<span class="nc" id="L773">        trainOptions.regCost = Double.parseDouble(args[i + 1]);</span>
<span class="nc" id="L774">        i += 2;</span>
<span class="nc bnc" id="L775" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-dvIterations&quot;) || args[i].equalsIgnoreCase(&quot;-trainingIterations&quot;)) {</span>
<span class="nc" id="L776">      trainOptions.trainingIterations = Integer.parseInt(args[i + 1]);</span>
<span class="nc" id="L777">      i += 2;</span>
<span class="nc bnc" id="L778" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-stalledIterationLimit&quot;)) {</span>
<span class="nc" id="L779">      trainOptions.stalledIterationLimit = Integer.parseInt(args[i + 1]);</span>
<span class="nc" id="L780">      i += 2;</span>
<span class="nc bnc" id="L781" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-dvBatchSize&quot;) || args[i].equalsIgnoreCase(&quot;-batchSize&quot;)) {</span>
<span class="nc" id="L782">      trainOptions.batchSize = Integer.parseInt(args[i + 1]);</span>
<span class="nc" id="L783">      i += 2;</span>
<span class="nc bnc" id="L784" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-qnIterationsPerBatch&quot;)) {</span>
<span class="nc" id="L785">      trainOptions.qnIterationsPerBatch = Integer.parseInt(args[i + 1]);</span>
<span class="nc" id="L786">      i += 2;</span>
<span class="nc bnc" id="L787" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-qnEstimates&quot;)) {</span>
<span class="nc" id="L788">      trainOptions.qnEstimates = Integer.parseInt(args[i + 1]);</span>
<span class="nc" id="L789">      i += 2;</span>
<span class="nc bnc" id="L790" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-qnTolerance&quot;)) {</span>
<span class="nc" id="L791">      trainOptions.qnTolerance = Double.parseDouble(args[i + 1]);</span>
<span class="nc" id="L792">      i += 2;</span>
<span class="nc bnc" id="L793" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-debugOutputFrequency&quot;)) {</span>
<span class="nc" id="L794">      trainOptions.debugOutputFrequency = Integer.parseInt(args[i + 1]);</span>
<span class="nc" id="L795">      i += 2;</span>
<span class="nc bnc" id="L796" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-maxTrainTimeSeconds&quot;)) {</span>
<span class="nc" id="L797">      trainOptions.maxTrainTimeSeconds = Integer.parseInt(args[i + 1]);</span>
<span class="nc" id="L798">      i += 2;</span>
<span class="nc bnc" id="L799" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-dvSeed&quot;) || args[i].equalsIgnoreCase(&quot;-randomSeed&quot;)) {</span>
<span class="nc" id="L800">      trainOptions.randomSeed = Long.parseLong(args[i + 1]);</span>
<span class="nc" id="L801">      i += 2;      </span>
<span class="nc bnc" id="L802" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-wordVectorFile&quot;)) {</span>
<span class="nc" id="L803">      lexOptions.wordVectorFile = args[i + 1];</span>
<span class="nc" id="L804">      i += 2;</span>
<span class="nc bnc" id="L805" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-numHid&quot;)) {</span>
<span class="nc" id="L806">      lexOptions.numHid = Integer.parseInt(args[i + 1]);</span>
<span class="nc" id="L807">      i += 2;</span>
<span class="nc bnc" id="L808" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-learningRate&quot;)) {</span>
<span class="nc" id="L809">      trainOptions.learningRate = Double.parseDouble(args[i + 1]);</span>
<span class="nc" id="L810">      i += 2;</span>
<span class="nc bnc" id="L811" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-deltaMargin&quot;)) {</span>
<span class="nc" id="L812">      trainOptions.deltaMargin = Double.parseDouble(args[i + 1]);</span>
<span class="nc" id="L813">      i += 2;</span>
<span class="nc bnc" id="L814" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-unknownNumberVector&quot;)) {</span>
<span class="nc" id="L815">      trainOptions.unknownNumberVector = true;</span>
<span class="nc" id="L816">      i += 1;</span>
<span class="nc bnc" id="L817" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-noUnknownNumberVector&quot;)) {</span>
<span class="nc" id="L818">      trainOptions.unknownNumberVector = false;</span>
<span class="nc" id="L819">      i += 1;</span>
<span class="nc bnc" id="L820" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-unknownDashedWordVectors&quot;)) {</span>
<span class="nc" id="L821">      trainOptions.unknownDashedWordVectors = true;</span>
<span class="nc" id="L822">      i += 1;</span>
<span class="nc bnc" id="L823" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-noUnknownDashedWordVectors&quot;)) {</span>
<span class="nc" id="L824">      trainOptions.unknownDashedWordVectors = false;</span>
<span class="nc" id="L825">      i += 1;</span>
<span class="nc bnc" id="L826" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-unknownCapsVector&quot;)) {</span>
<span class="nc" id="L827">      trainOptions.unknownCapsVector = true;</span>
<span class="nc" id="L828">      i += 1;</span>
<span class="nc bnc" id="L829" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-noUnknownCapsVector&quot;)) {</span>
<span class="nc" id="L830">      trainOptions.unknownCapsVector = false;</span>
<span class="nc" id="L831">      i += 1;</span>
<span class="nc bnc" id="L832" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-unknownChineseYearVector&quot;)) {</span>
<span class="nc" id="L833">      trainOptions.unknownChineseYearVector = true;</span>
<span class="nc" id="L834">      i += 1;</span>
<span class="nc bnc" id="L835" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-noUnknownChineseYearVector&quot;)) {</span>
<span class="nc" id="L836">      trainOptions.unknownChineseYearVector = false;</span>
<span class="nc" id="L837">      i += 1;</span>
<span class="nc bnc" id="L838" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-unknownChineseNumberVector&quot;)) {</span>
<span class="nc" id="L839">      trainOptions.unknownChineseNumberVector = true;</span>
<span class="nc" id="L840">      i += 1;</span>
<span class="nc bnc" id="L841" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-noUnknownChineseNumberVector&quot;)) {</span>
<span class="nc" id="L842">      trainOptions.unknownChineseNumberVector = false;</span>
<span class="nc" id="L843">      i += 1;</span>
<span class="nc bnc" id="L844" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-unknownChinesePercentVector&quot;)) {</span>
<span class="nc" id="L845">      trainOptions.unknownChinesePercentVector = true;</span>
<span class="nc" id="L846">      i += 1;</span>
<span class="nc bnc" id="L847" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-noUnknownChinesePercentVector&quot;)) {</span>
<span class="nc" id="L848">      trainOptions.unknownChinesePercentVector = false;</span>
<span class="nc" id="L849">      i += 1;</span>
<span class="nc bnc" id="L850" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-dvSimplifiedModel&quot;)) {</span>
<span class="nc" id="L851">      trainOptions.dvSimplifiedModel = true;</span>
<span class="nc" id="L852">      i += 1;</span>
<span class="nc bnc" id="L853" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-scalingForInit&quot;)) {</span>
<span class="nc" id="L854">      trainOptions.scalingForInit = Double.parseDouble(args[i + 1]);</span>
<span class="nc" id="L855">      i += 2;</span>
<span class="nc bnc" id="L856" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-rerankerKBest&quot;)) {</span>
<span class="nc" id="L857">      rerankerKBest = Integer.parseInt(args[i + 1]);</span>
<span class="nc" id="L858">      i += 2;</span>
<span class="nc bnc" id="L859" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-baseParserWeight&quot;)) {</span>
<span class="nc" id="L860">      baseParserWeight = Double.parseDouble(args[i + 1]);</span>
<span class="nc" id="L861">      i += 2;</span>
<span class="nc bnc" id="L862" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-unkWord&quot;)) {</span>
<span class="nc" id="L863">      trainOptions.unkWord = args[i + 1];</span>
<span class="nc" id="L864">      i += 2;</span>
<span class="nc bnc" id="L865" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-lowercaseWordVectors&quot;)) {</span>
<span class="nc" id="L866">      trainOptions.lowercaseWordVectors = true;</span>
<span class="nc" id="L867">      i += 1;</span>
<span class="nc bnc" id="L868" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-noLowercaseWordVectors&quot;)) {</span>
<span class="nc" id="L869">      trainOptions.lowercaseWordVectors = false;</span>
<span class="nc" id="L870">      i += 1;</span>
<span class="nc bnc" id="L871" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-transformMatrixType&quot;)) {</span>
<span class="nc" id="L872">      trainOptions.transformMatrixType = TrainOptions.TransformMatrixType.valueOf(args[i + 1]);</span>
<span class="nc" id="L873">      i += 2;</span>
<span class="nc bnc" id="L874" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-useContextWords&quot;)) {</span>
<span class="nc" id="L875">      trainOptions.useContextWords = true;</span>
<span class="nc" id="L876">      i += 1;</span>
<span class="nc bnc" id="L877" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-noUseContextWords&quot;)) {</span>
<span class="nc" id="L878">      trainOptions.useContextWords = false;</span>
<span class="nc" id="L879">      i += 1;</span>
<span class="nc bnc" id="L880" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-trainWordVectors&quot;)) {</span>
<span class="nc" id="L881">      trainOptions.trainWordVectors = true;</span>
<span class="nc" id="L882">      i += 1;</span>
<span class="nc bnc" id="L883" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-noTrainWordVectors&quot;)) {</span>
<span class="nc" id="L884">      trainOptions.trainWordVectors = false;</span>
<span class="nc" id="L885">      i += 1;</span>
<span class="nc bnc" id="L886" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-markStrahler&quot;)) {</span>
<span class="nc" id="L887">      trainOptions.markStrahler = true;</span>
<span class="nc" id="L888">      i += 1;</span>
    }
<span class="nc" id="L890">    return i;</span>
  }

<span class="fc" id="L893">  public static class LexOptions implements Serializable {</span>

    /**
     * Whether to use suffix and capitalization information for unknowns.
     * Within the BaseLexicon model options have the following meaning:
     * 0 means a single unknown token.  1 uses suffix, and capitalization.
     * 2 uses a variant (richer) form of signature.  Good.
     * Use this one.  Using the richer signatures in versions 3 or 4 seems
     * to have very marginal or no positive value.
     * 3 uses a richer form of signature that mimics the NER word type
     * patterns.  4 is a variant of 2.  5 is another with more English
     * specific morphology (good for English unknowns!).
     * 6-9 are options for Arabic.  9 codes some patterns for numbers and
     * derivational morphology, but also supports unknownPrefixSize and
     * unknownSuffixSize.
     * For German, 0 means a single unknown token, and non-zero means to use
     * capitalization of first letter and a suffix of length
     * unknownSuffixSize.
     */
<span class="fc" id="L912">    public int useUnknownWordSignatures = 0;</span>

    /**
     * RS: file for Turian's word vectors
     * The default value is an example of size 25 word vectors on the nlp machines
     */
    public static final String DEFAULT_WORD_VECTOR_FILE = &quot;/scr/nlp/deeplearning/datasets/turian/embeddings-scaled.EMBEDDING_SIZE=25.txt&quot;;
<span class="fc" id="L919">    public String wordVectorFile = DEFAULT_WORD_VECTOR_FILE;</span>
    /**
     * Number of hidden units in the word vectors.  As setting of 0
     * will make it try to extract the size from the data file.
     */
<span class="fc" id="L924">    public int numHid = 0;</span>


    /**
     * Words more common than this are tagged with MLE P(t|w). Default 100. The
     * smoothing is sufficiently slight that changing this has little effect.
     * But set this to 0 to be able to use the parser as a vanilla PCFG with
     * no smoothing (not as a practical parser but for exposition or debugging).
     */
<span class="fc" id="L933">    public int smoothInUnknownsThreshold = 100;</span>

    /**
     * Smarter smoothing for rare words.
     */
<span class="fc" id="L938">    public boolean smartMutation = false;</span>

    /**
     * Make use of unicode code point types in smoothing.
     */
<span class="fc" id="L943">    public boolean useUnicodeType = false;</span>

    /** For certain Lexicons, a certain number of word-final letters are
     *  used to subclassify the unknown token. This gives the number of
     *  letters.
     */
<span class="fc" id="L949">    public int unknownSuffixSize = 1;</span>

    /** For certain Lexicons, a certain number of word-initial letters are
     *  used to subclassify the unknown token. This gives the number of
     *  letters.
     */
<span class="fc" id="L955">    public int unknownPrefixSize = 1;</span>

    /**
     * Model for unknown words that the lexicon should use.  This is the
     * name of a class.
     */
    public String uwModelTrainer; // = null;

    /* If this option is false, then all words that were seen in the training
     * data (even once) are constrained to only have seen tags.  That is,
     * mle is used for the lexicon.
     * If this option is true, then if a word has been seen more than
     * smoothInUnknownsThreshold, then it will still only get tags with which
     * it has been seen, but rarer words will get all tags for which the
     * unknown word model (or smart mutation) does not give a score of -Inf.
     * This will normally be all open class tags.
     * If floodTags is invoked by the parser, all other tags will also be
     * given a minimal non-zero, non-infinite probability.
     */
<span class="fc" id="L974">    public boolean flexiTag = false;</span>

    /** Whether to use signature rather than just being unknown as prior in
     *  known word smoothing.  Currently only works if turned on for English.
     */
    public boolean useSignatureForKnownSmoothing;

    /** A file of word class data which may be used for smoothing,
     *  normally instead of hand-specified signatures.
     */
    public String wordClassesFile;



    private static final long serialVersionUID = 2805351374506855632L;

<span class="fc" id="L990">    private static final String[] params = { &quot;useUnknownWordSignatures&quot;,</span>
                                             &quot;smoothInUnknownsThreshold&quot;,
                                             &quot;smartMutation&quot;,
                                             &quot;useUnicodeType&quot;,
                                             &quot;unknownSuffixSize&quot;,
                                             &quot;unknownPrefixSize&quot;,
                                             &quot;flexiTag&quot;,
                                             &quot;useSignatureForKnownSmoothing&quot;,
                                             &quot;wordClassesFile&quot; };

    @Override
    public String toString() {
<span class="nc" id="L1002">      return params[0] + &quot; &quot; + useUnknownWordSignatures + &quot;\n&quot; +</span>
        params[1] + &quot; &quot; + smoothInUnknownsThreshold + &quot;\n&quot; +
        params[2] + &quot; &quot; + smartMutation + &quot;\n&quot; +
        params[3] + &quot; &quot; + useUnicodeType + &quot;\n&quot; +
        params[4] + &quot; &quot; + unknownSuffixSize + &quot;\n&quot; +
        params[5] + &quot; &quot; + unknownPrefixSize + &quot;\n&quot; +
        params[6] + &quot; &quot; + flexiTag + &quot;\n&quot; +
        params[7] + &quot; &quot; + useSignatureForKnownSmoothing + &quot;\n&quot; +
        params[8] + &quot; &quot; + wordClassesFile + &quot;\n&quot;;
    }

    public void readData(BufferedReader in) throws IOException {
<span class="nc bnc" id="L1014" title="All 2 branches missed.">      for (int i = 0; i &lt; params.length; i++) {</span>
<span class="nc" id="L1015">        String line = in.readLine();</span>
<span class="nc" id="L1016">        int idx = line.indexOf(' ');</span>
<span class="nc" id="L1017">        String key = line.substring(0, idx);</span>
<span class="nc" id="L1018">        String value = line.substring(idx + 1);</span>
<span class="nc bnc" id="L1019" title="All 2 branches missed.">        if ( ! key.equalsIgnoreCase(params[i])) {</span>
<span class="nc" id="L1020">          log.info(&quot;Yikes!!! Expected &quot; + params[i] + &quot; got &quot; + key);</span>
        }
<span class="nc bnc" id="L1022" title="All 10 branches missed.">        switch (i) {</span>
        case 0:
<span class="nc" id="L1024">          useUnknownWordSignatures = Integer.parseInt(value);</span>
<span class="nc" id="L1025">          break;</span>
        case 1:
<span class="nc" id="L1027">          smoothInUnknownsThreshold = Integer.parseInt(value);</span>
<span class="nc" id="L1028">          break;</span>
        case 2:
<span class="nc" id="L1030">          smartMutation = Boolean.parseBoolean(value);</span>
<span class="nc" id="L1031">          break;</span>
        case 3:
<span class="nc" id="L1033">          useUnicodeType = Boolean.parseBoolean(value);</span>
<span class="nc" id="L1034">          break;</span>
        case 4:
<span class="nc" id="L1036">          unknownSuffixSize = Integer.parseInt(value);</span>
<span class="nc" id="L1037">          break;</span>
        case 5:
<span class="nc" id="L1039">          unknownPrefixSize = Integer.parseInt(value);</span>
<span class="nc" id="L1040">          break;</span>
        case 6:
<span class="nc" id="L1042">          flexiTag = Boolean.parseBoolean(value);</span>
<span class="nc" id="L1043">          break;</span>
        case 7:
<span class="nc" id="L1045">          useSignatureForKnownSmoothing = Boolean.parseBoolean(value);</span>
<span class="nc" id="L1046">          break;</span>
        case 8:
<span class="nc" id="L1048">          wordClassesFile = value;</span>
          break;
        }
      }
<span class="nc" id="L1052">    }</span>

  } // end class LexOptions


<span class="fc" id="L1057">  public LexOptions lexOptions = new LexOptions();</span>

  /**
   * The treebank-specific parser parameters  to use.
   */
  public TreebankLangParserParams tlpParams;

  /**
   * @return The treebank language pack for the treebank the parser
   * is trained on.
   */
  public TreebankLanguagePack langpack() {
<span class="fc" id="L1069">    return tlpParams.treebankLanguagePack();</span>
  }


  /**
   * Forces parsing with strictly CNF grammar -- unary chains are converted
   * to XP&amp;amp;YP symbols and back
   */
<span class="fc" id="L1077">  public boolean forceCNF = false;</span>

  /**
   * Do a PCFG parse of the sentence.  If both variables are on,
   * also do a combined parse of the sentence.
   */
<span class="fc" id="L1083">  public boolean doPCFG = true;</span>

  /**
   * Do a dependency parse of the sentence.
   */
<span class="fc" id="L1088">  public boolean doDep = true;</span>

  /**
   * if true, any child can be the head (seems rather bad!)
   */
<span class="fc" id="L1093">  public boolean freeDependencies = false;</span>

  /**
   * Whether dependency grammar considers left/right direction. Good.
   */
<span class="fc" id="L1098">  public boolean directional = true;</span>
<span class="fc" id="L1099">  public boolean genStop = true;</span>

<span class="fc" id="L1101">  public boolean useSmoothTagProjection = false;</span>
<span class="fc" id="L1102">  public boolean useUnigramWordSmoothing = false;</span>

  /**
   * Use distance bins in the dependency calculations
   */
<span class="fc" id="L1107">  public boolean distance = true;</span>
  /**
   * Use coarser distance (4 bins) in dependency calculations
   */
<span class="fc" id="L1111">  public boolean coarseDistance = false;</span>

  /**
   * &quot;double count&quot; tags rewrites as word in PCFG and Dep parser.  Good for
   * combined parsing only (it used to not kick in for PCFG parsing).  This
   * option is only used at Test time, but it is now in Options, so the
   * correct choice for a grammar is recorded by a serialized parser.
   * You should turn this off for a vanilla PCFG parser.
   */
<span class="fc" id="L1120">  public boolean dcTags = true;</span>

  /**
   * If true, inside the factored parser, remove any node from the final
   * chosen tree which improves the PCFG score. This was added as the
   * dependency factor tends to encourage 'deep' trees.
   */
<span class="fc" id="L1127">  public boolean nodePrune = false;</span>


<span class="fc" id="L1130">  public TrainOptions trainOptions = newTrainOptions();</span>

  /** Separated out so subclasses of Options can override */
  public TrainOptions newTrainOptions() {
<span class="fc" id="L1134">    return new TrainOptions();</span>
  }

  /**
   * Note that the TestOptions is transient.  This means that whatever
   * options get set at creation time are forgotten when the parser is
   * serialized.  If you want an option to be remembered when the
   * parser is reloaded, put it in either TrainOptions or in this
   * class itself.
   */
<span class="fc" id="L1144">  public transient TestOptions testOptions = newTestOptions();</span>

  /** Separated out so subclasses of Options can override */
  public TestOptions newTestOptions() {
<span class="fc" id="L1148">    return new TestOptions();</span>
  }


  /**
   * A function that maps words used in training and testing to new
   * words.  For example, it could be a function to lowercase text,
   * such as edu.stanford.nlp.util.LowercaseFunction (which makes the
   * parser case insensitive).  This function is applied in
   * LexicalizedParserQuery.parse and in the training methods which
   * build a new parser.
   */
<span class="fc" id="L1160">  public Function&lt;String, String&gt; wordFunction = null;</span>

  /**
   * If the parser has a reranker, it looks at this many trees when
   * building the reranked list.
   */
<span class="fc" id="L1166">  public int rerankerKBest = 100;</span>

  /**
   * If reranking sentences, we can use the score from the original
   * parser as well.  This tells us how much weight to give that score.
   */
<span class="fc" id="L1172">  public double baseParserWeight = 0.0;</span>

  /**
   * Making the TestOptions transient means it won't even be
   * constructed when you deserialize an Options, so we need to
   * construct it on our own when deserializing
   */
  private void readObject(ObjectInputStream in)
    throws IOException, ClassNotFoundException
  {
<span class="nc" id="L1182">    in.defaultReadObject();</span>
<span class="nc" id="L1183">    testOptions = newTestOptions();</span>
<span class="nc" id="L1184">  }</span>

  public void display() {
//    try {
<span class="nc" id="L1188">      log.info(&quot;Options parameters:&quot;);</span>
<span class="nc" id="L1189">      writeData(new PrintWriter(System.err));</span>
/*    } catch (IOException e) {
      e.printStackTrace();
    }*/
<span class="nc" id="L1193">  }</span>

  public void writeData(Writer w) {//throws IOException {
<span class="nc" id="L1196">    PrintWriter out = new PrintWriter(w);</span>
<span class="nc" id="L1197">    StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L1198">    sb.append(lexOptions.toString());</span>
<span class="nc" id="L1199">    sb.append(&quot;parserParams &quot;).append(tlpParams.getClass().getName()).append(&quot;\n&quot;);</span>
<span class="nc" id="L1200">    sb.append(&quot;forceCNF &quot;).append(forceCNF).append(&quot;\n&quot;);</span>
<span class="nc" id="L1201">    sb.append(&quot;doPCFG &quot;).append(doPCFG).append(&quot;\n&quot;);</span>
<span class="nc" id="L1202">    sb.append(&quot;doDep &quot;).append(doDep).append(&quot;\n&quot;);</span>
<span class="nc" id="L1203">    sb.append(&quot;freeDependencies &quot;).append(freeDependencies).append(&quot;\n&quot;);</span>
<span class="nc" id="L1204">    sb.append(&quot;directional &quot;).append(directional).append(&quot;\n&quot;);</span>
<span class="nc" id="L1205">    sb.append(&quot;genStop &quot;).append(genStop).append(&quot;\n&quot;);</span>
<span class="nc" id="L1206">    sb.append(&quot;distance &quot;).append(distance).append(&quot;\n&quot;);</span>
<span class="nc" id="L1207">    sb.append(&quot;coarseDistance &quot;).append(coarseDistance).append(&quot;\n&quot;);</span>
<span class="nc" id="L1208">    sb.append(&quot;dcTags &quot;).append(dcTags).append(&quot;\n&quot;);</span>
<span class="nc" id="L1209">    sb.append(&quot;nPrune &quot;).append(nodePrune).append(&quot;\n&quot;);</span>
<span class="nc" id="L1210">    out.print(sb.toString());</span>
<span class="nc" id="L1211">    out.flush();</span>
<span class="nc" id="L1212">  }</span>


  /**
   * Populates data in this Options from the character stream.
   * @param in The Reader
   * @throws IOException If there is a problem reading data
   */
  public void readData(BufferedReader in) throws IOException {
    String line, value;
    // skip old variables if still present
<span class="nc" id="L1223">    lexOptions.readData(in);</span>
<span class="nc" id="L1224">    line = in.readLine();</span>
<span class="nc" id="L1225">    value = line.substring(line.indexOf(' ') + 1);</span>
    try {
<span class="nc" id="L1227">      tlpParams = (TreebankLangParserParams) Class.forName(value).newInstance();</span>
<span class="nc" id="L1228">    } catch (Exception e) {</span>
<span class="nc" id="L1229">      IOException ioe = new IOException(&quot;Problem instantiating parserParams: &quot; + line);</span>
<span class="nc" id="L1230">      ioe.initCause(e);</span>
<span class="nc" id="L1231">      throw ioe;</span>
<span class="nc" id="L1232">    }</span>
<span class="nc" id="L1233">    line = in.readLine();</span>
    // ensure backwards compatibility
<span class="nc bnc" id="L1235" title="All 2 branches missed.">    if (line.matches(&quot;^forceCNF.*&quot;)) {</span>
<span class="nc" id="L1236">      value = line.substring(line.indexOf(' ') + 1);</span>
<span class="nc" id="L1237">      forceCNF = Boolean.parseBoolean(value);</span>
<span class="nc" id="L1238">      line = in.readLine();</span>
    }
<span class="nc" id="L1240">    value = line.substring(line.indexOf(' ') + 1);</span>
<span class="nc" id="L1241">    doPCFG = Boolean.parseBoolean(value);</span>
<span class="nc" id="L1242">    line = in.readLine();</span>
<span class="nc" id="L1243">    value = line.substring(line.indexOf(' ') + 1);</span>
<span class="nc" id="L1244">    doDep = Boolean.parseBoolean(value);</span>
<span class="nc" id="L1245">    line = in.readLine();</span>
<span class="nc" id="L1246">    value = line.substring(line.indexOf(' ') + 1);</span>
<span class="nc" id="L1247">    freeDependencies = Boolean.parseBoolean(value);</span>
<span class="nc" id="L1248">    line = in.readLine();</span>
<span class="nc" id="L1249">    value = line.substring(line.indexOf(' ') + 1);</span>
<span class="nc" id="L1250">    directional = Boolean.parseBoolean(value);</span>
<span class="nc" id="L1251">    line = in.readLine();</span>
<span class="nc" id="L1252">    value = line.substring(line.indexOf(' ') + 1);</span>
<span class="nc" id="L1253">    genStop = Boolean.parseBoolean(value);</span>
<span class="nc" id="L1254">    line = in.readLine();</span>
<span class="nc" id="L1255">    value = line.substring(line.indexOf(' ') + 1);</span>
<span class="nc" id="L1256">    distance = Boolean.parseBoolean(value);</span>
<span class="nc" id="L1257">    line = in.readLine();</span>
<span class="nc" id="L1258">    value = line.substring(line.indexOf(' ') + 1);</span>
<span class="nc" id="L1259">    coarseDistance = Boolean.parseBoolean(value);</span>
<span class="nc" id="L1260">    line = in.readLine();</span>
<span class="nc" id="L1261">    value = line.substring(line.indexOf(' ') + 1);</span>
<span class="nc" id="L1262">    dcTags = Boolean.parseBoolean(value);</span>
<span class="nc" id="L1263">    line = in.readLine();</span>
<span class="nc bnc" id="L1264" title="All 2 branches missed.">    if ( ! line.matches(&quot;^nPrune.*&quot;)) {</span>
<span class="nc" id="L1265">      throw new RuntimeException(&quot;Expected nPrune, found: &quot; + line);</span>
    }
<span class="nc" id="L1267">    value = line.substring(line.indexOf(' ') + 1);</span>
<span class="nc" id="L1268">    nodePrune = Boolean.parseBoolean(value);</span>
<span class="nc" id="L1269">    line = in.readLine(); // get rid of last line</span>
<span class="nc bnc" id="L1270" title="All 2 branches missed.">    if (line.length() != 0) {</span>
<span class="nc" id="L1271">      throw new RuntimeException(&quot;Expected blank line, found: &quot; + line);</span>
    }
<span class="nc" id="L1273">  }</span>

  private static final long serialVersionUID = 4L;

} // end class Options
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>