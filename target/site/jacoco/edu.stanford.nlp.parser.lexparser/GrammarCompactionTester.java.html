<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GrammarCompactionTester.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.parser.lexparser</a> &gt; <span class="el_source">GrammarCompactionTester.java</span></div><h1>GrammarCompactionTester.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.parser.lexparser; 
import edu.stanford.nlp.util.logging.Redwood;

import edu.stanford.nlp.fsm.*;
import edu.stanford.nlp.io.NumberRangeFileFilter;
import edu.stanford.nlp.trees.*;
import edu.stanford.nlp.util.*;
import edu.stanford.nlp.stats.ClassicCounter;
import java.util.*;


/**
 * @author Teg Grenager (grenager@cs.stanford.edu)
 */
<span class="nc" id="L15">public class GrammarCompactionTester  {</span>

  /** A logger for this class */
<span class="nc" id="L18">  private static Redwood.RedwoodChannels log = Redwood.channels(GrammarCompactionTester.class);</span>

  // for debugging
  //  public static MergeableGraph debugGraph = null;

<span class="nc" id="L23">  ExhaustivePCFGParser parser = null;</span>
<span class="nc" id="L24">  ExhaustiveDependencyParser dparser = null;</span>
<span class="nc" id="L25">  BiLexPCFGParser bparser = null;</span>
<span class="nc" id="L26">  Scorer scorer = null;</span>
  Options op;

  //  TreebankLangParserParams tlpParams = new EnglishTreebankParserParams();
  // tlpParams may be changed to something else later, so don't use it till
  // after options are parsed.


<span class="nc" id="L34">  GrammarCompactor compactor = null;</span>

<span class="nc" id="L36">  Map&lt;String, List&lt;List&lt;String&gt;&gt;&gt; allTestPaths = Generics.newHashMap();</span>
<span class="nc" id="L37">  Map&lt;String, List&lt;List&lt;String&gt;&gt;&gt; allTrainPaths = Generics.newHashMap();</span>

<span class="nc" id="L39">  String asciiOutputPath = null;</span>
<span class="nc" id="L40">  String path = &quot;/u/nlp/stuff/corpora/Treebank3/parsed/mrg/wsj&quot;;</span>
<span class="nc" id="L41">  int trainLow = 200, trainHigh = 2199, testLow = 2200, testHigh = 2219;</span>

<span class="nc" id="L43">  String suffixOrderString = null;</span>
<span class="nc" id="L44">  String minArcNumString = null;</span>
<span class="nc" id="L45">  String maxMergeCostString = null;</span>
<span class="nc" id="L46">  String sizeCutoffString = null;</span>
<span class="nc" id="L47">  String minPortionArcsString = null;</span>
<span class="nc" id="L48">  String ignoreUnsupportedSuffixesString = &quot;false&quot;;</span>
<span class="nc" id="L49">  String splitParamString = null;</span>
<span class="nc" id="L50">  String costModelString = null;</span>
<span class="nc" id="L51">  String verboseString = null;</span>
<span class="nc" id="L52">  String minArcCostString = null;</span>
<span class="nc" id="L53">  String trainThresholdString = null;</span>
<span class="nc" id="L54">  String heldoutThresholdString = null;</span>
<span class="nc" id="L55">  int markovOrder = -1;</span>
<span class="nc" id="L56">  String smoothParamString = null;</span>
<span class="nc" id="L57">  String scoringData = null;</span>
<span class="nc" id="L58">  String allowEpsilonsString = null;</span>
<span class="nc" id="L59">  boolean saveGraphs = false;</span>
  private int indexRangeLow;
  private int indexRangeHigh;
<span class="nc" id="L62">  private String outputFile = null;</span>
<span class="nc" id="L63">  private String inputFile = null;</span>
<span class="nc" id="L64">  private boolean toy = false;</span>

  /**
   */
  public Map&lt;String,List&lt;List&lt;String&gt;&gt;&gt; extractPaths(String path, int low, int high, boolean annotate) {

    // setup tree transforms
<span class="nc" id="L71">    Treebank trainTreebank = op.tlpParams.memoryTreebank(); // this is a new one</span>
<span class="nc" id="L72">    TreebankLanguagePack tlp = op.langpack();</span>

<span class="nc" id="L74">    trainTreebank.loadPath(path, new NumberRangeFileFilter(low, high, true));</span>

<span class="nc bnc" id="L76" title="All 2 branches missed.">    if (op.trainOptions.selectiveSplit) {</span>
<span class="nc" id="L77">      op.trainOptions.splitters = ParentAnnotationStats.getSplitCategories(trainTreebank, op.trainOptions.selectiveSplitCutOff, op.tlpParams.treebankLanguagePack());</span>
    }
<span class="nc bnc" id="L79" title="All 2 branches missed.">    if (op.trainOptions.selectivePostSplit) {</span>
<span class="nc" id="L80">      TreeTransformer myTransformer = new TreeAnnotator(op.tlpParams.headFinder(), op.tlpParams, op);</span>
<span class="nc" id="L81">      Treebank annotatedTB = trainTreebank.transform(myTransformer);</span>
<span class="nc" id="L82">      op.trainOptions.postSplitters = ParentAnnotationStats.getSplitCategories(annotatedTB, op.trainOptions.selectivePostSplitCutOff, op.tlpParams.treebankLanguagePack());</span>
    }

<span class="nc" id="L85">    List&lt;Tree&gt; trainTrees = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L86">    HeadFinder hf = null;</span>
<span class="nc bnc" id="L87" title="All 2 branches missed.">    if (op.trainOptions.leftToRight) {</span>
<span class="nc" id="L88">      hf = new LeftHeadFinder();</span>
    } else {
<span class="nc" id="L90">      hf = op.tlpParams.headFinder();</span>
    }
<span class="nc" id="L92">    TreeTransformer annotator = new TreeAnnotator(hf, op.tlpParams, op);</span>
<span class="nc bnc" id="L93" title="All 2 branches missed.">    for (Tree tree : trainTreebank) {</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">      if (annotate) {</span>
<span class="nc" id="L95">        tree = annotator.transformTree(tree);</span>
      }
<span class="nc" id="L97">      trainTrees.add(tree);</span>
<span class="nc" id="L98">    }</span>
<span class="nc" id="L99">    Extractor&lt;Map&lt;String,List&lt;List&lt;String&gt;&gt;&gt;&gt; pExtractor = new PathExtractor(hf, op);</span>
<span class="nc" id="L100">    Map&lt;String,List&lt;List&lt;String&gt;&gt;&gt; allPaths = pExtractor.extract(trainTrees);</span>
<span class="nc" id="L101">    return allPaths;</span>
  }


  public static void main(String[] args) {
<span class="nc" id="L106">    new GrammarCompactionTester().runTest(args);</span>
<span class="nc" id="L107">  }</span>

  public void runTest(String[] args) {
<span class="nc" id="L110">    System.out.println(&quot;Currently &quot; + new Date());</span>
<span class="nc" id="L111">    System.out.print(&quot;Invoked with arguments:&quot;);</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">    for (String arg : args) {</span>
<span class="nc" id="L113">      System.out.print(&quot; &quot; + arg);</span>
    }

<span class="nc" id="L116">    System.out.println();</span>

<span class="nc" id="L118">    int i = 0;</span>
<span class="nc bnc" id="L119" title="All 4 branches missed.">    while (i &lt; args.length &amp;&amp; args[i].startsWith(&quot;-&quot;)) {</span>
<span class="nc bnc" id="L120" title="All 4 branches missed.">      if (args[i].equalsIgnoreCase(&quot;-path&quot;) &amp;&amp; (i + 1 &lt; args.length)) {</span>
<span class="nc" id="L121">        path = args[i + 1];</span>
<span class="nc" id="L122">        i += 2;</span>
<span class="nc bnc" id="L123" title="All 4 branches missed.">      } else if (args[i].equalsIgnoreCase(&quot;-saveToAscii&quot;) &amp;&amp; (i + 1 &lt; args.length)) {</span>
<span class="nc" id="L124">        asciiOutputPath = args[i + 1];</span>
<span class="nc" id="L125">        i += 2;</span>
<span class="nc bnc" id="L126" title="All 4 branches missed.">      } else if (args[i].equalsIgnoreCase(&quot;-train&quot;) &amp;&amp; (i + 2 &lt; args.length)) {</span>
<span class="nc" id="L127">        trainLow = Integer.parseInt(args[i + 1]);</span>
<span class="nc" id="L128">        trainHigh = Integer.parseInt(args[i + 2]);</span>
<span class="nc" id="L129">        i += 3;</span>
<span class="nc bnc" id="L130" title="All 4 branches missed.">      } else if (args[i].equalsIgnoreCase(&quot;-test&quot;) &amp;&amp; (i + 2 &lt; args.length)) {</span>
<span class="nc" id="L131">        testLow = Integer.parseInt(args[i + 1]);</span>
<span class="nc" id="L132">        testHigh = Integer.parseInt(args[i + 2]);</span>
<span class="nc" id="L133">        i += 3;</span>
<span class="nc bnc" id="L134" title="All 4 branches missed.">      } else if (args[i].equalsIgnoreCase(&quot;-index&quot;) &amp;&amp; (i + 2 &lt; args.length)) {</span>
<span class="nc" id="L135">        indexRangeLow = Integer.parseInt(args[i + 1]);</span>
<span class="nc" id="L136">        indexRangeHigh = Integer.parseInt(args[i + 2]);</span>
<span class="nc" id="L137">        i += 3;</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">      } else if (args[i].equalsIgnoreCase(&quot;-outputFile&quot;)) {</span>
<span class="nc" id="L139">        outputFile = args[i + 1];</span>
<span class="nc" id="L140">        i += 2;</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">      } else if (args[i].equalsIgnoreCase(&quot;-inputFile&quot;)) {</span>
<span class="nc" id="L142">        inputFile = args[i + 1];</span>
<span class="nc" id="L143">        i += 2;</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">      } else if (args[i].equalsIgnoreCase(&quot;-suffixOrder&quot;)) {</span>
<span class="nc" id="L145">        suffixOrderString = args[i + 1];</span>
<span class="nc" id="L146">        i += 2;</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">      } else if (args[i].equalsIgnoreCase(&quot;-minArcNum&quot;)) {</span>
<span class="nc" id="L148">        minArcNumString = args[i + 1];</span>
<span class="nc" id="L149">        i += 2;</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">      } else if (args[i].equalsIgnoreCase(&quot;-maxMergeCost&quot;)) {</span>
<span class="nc" id="L151">        maxMergeCostString = args[i + 1];</span>
<span class="nc" id="L152">        i += 2;</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">      } else if (args[i].equalsIgnoreCase(&quot;-sizeCutoff&quot;)) {</span>
<span class="nc" id="L154">        sizeCutoffString = args[i + 1];</span>
<span class="nc" id="L155">        i += 2;</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">      } else if (args[i].equalsIgnoreCase(&quot;-minPortionArcs&quot;)) {</span>
<span class="nc" id="L157">        minPortionArcsString = args[i + 1];</span>
<span class="nc" id="L158">        i += 2;</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">      } else if (args[i].equalsIgnoreCase(&quot;-ignoreUnsupportedSuffixes&quot;)) {</span>
<span class="nc" id="L160">        ignoreUnsupportedSuffixesString = args[i + 1];</span>
<span class="nc" id="L161">        i += 2;</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">      } else if (args[i].equalsIgnoreCase(&quot;-trainThreshold&quot;)) {</span>
<span class="nc" id="L163">        trainThresholdString = args[i + 1];</span>
<span class="nc" id="L164">        i += 2;</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">      } else if (args[i].equalsIgnoreCase(&quot;-heldoutThreshold&quot;)) {</span>
<span class="nc" id="L166">        heldoutThresholdString = args[i + 1];</span>
<span class="nc" id="L167">        i += 2;</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">      } else if (args[i].equalsIgnoreCase(&quot;-minArcCost&quot;)) {</span>
<span class="nc" id="L169">        minArcCostString = args[i + 1];</span>
<span class="nc" id="L170">        i += 2;</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">      } else if (args[i].equalsIgnoreCase(&quot;-splitParam&quot;)) {</span>
<span class="nc" id="L172">        splitParamString = args[i + 1];</span>
<span class="nc" id="L173">        i += 2;</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">      } else if (args[i].equalsIgnoreCase(&quot;-costModel&quot;)) {</span>
<span class="nc" id="L175">        costModelString = args[i + 1];</span>
<span class="nc" id="L176">        i += 2;</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">      } else if (args[i].equalsIgnoreCase(&quot;-scoringData&quot;)) {</span>
<span class="nc" id="L178">        scoringData = args[i + 1];</span>
<span class="nc" id="L179">        i += 2;</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">      } else if (args[i].equalsIgnoreCase(&quot;-verbose&quot;)) {</span>
<span class="nc" id="L181">        verboseString = args[i + 1];</span>
<span class="nc" id="L182">        i += 2;</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">      } else if (args[i].equalsIgnoreCase(&quot;-allowEpsilons&quot;)) {</span>
<span class="nc" id="L184">        allowEpsilonsString = args[i + 1];</span>
<span class="nc" id="L185">        i += 2;</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">      } else if (args[i].equalsIgnoreCase(&quot;-saveGraphs&quot;)) {</span>
<span class="nc" id="L187">        saveGraphs = true;</span>
<span class="nc" id="L188">        i++;</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">      } else if (args[i].equalsIgnoreCase(&quot;-toy&quot;)) {</span>
<span class="nc" id="L190">        toy = true;</span>
<span class="nc" id="L191">        i++;</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">      } else if (args[i].equalsIgnoreCase(&quot;-markovOrder&quot;)) {</span>
<span class="nc" id="L193">        markovOrder = Integer.parseInt(args[i + 1]);</span>
<span class="nc" id="L194">        i += 2;</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">      } else if (args[i].equalsIgnoreCase(&quot;-smoothParam&quot;)) {</span>
<span class="nc" id="L196">        smoothParamString = args[i + 1];</span>
<span class="nc" id="L197">        i += 2;</span>
      } else {
<span class="nc" id="L199">        i = op.setOptionOrWarn(args, i);</span>
      }
    }

<span class="nc" id="L203">    op.trainOptions.sisterSplitters = Generics.newHashSet(Arrays.asList(op.tlpParams.sisterSplitters()));</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">    if (op.trainOptions.compactGrammar() == 4) {</span>
<span class="nc" id="L205">      System.out.println(&quot;Instantiating fsm.LossyGrammarCompactor&quot;);</span>
      try {
<span class="nc" id="L207">        Class[] argTypes = new Class[13];</span>
<span class="nc" id="L208">        Class strClass = String.class;</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">        for (int j = 0; j &lt; argTypes.length; j++) {</span>
<span class="nc" id="L210">          argTypes[j] = strClass;</span>
        }
<span class="nc" id="L212">        Object[] cArgs = new Object[13];</span>
<span class="nc" id="L213">        cArgs[0] = suffixOrderString;</span>
<span class="nc" id="L214">        cArgs[1] = minArcNumString;</span>
<span class="nc" id="L215">        cArgs[2] = trainThresholdString;</span>
<span class="nc" id="L216">        cArgs[3] = heldoutThresholdString;</span>
<span class="nc" id="L217">        cArgs[4] = sizeCutoffString;</span>
<span class="nc" id="L218">        cArgs[5] = minPortionArcsString;</span>
<span class="nc" id="L219">        cArgs[6] = splitParamString;</span>
<span class="nc" id="L220">        cArgs[7] = ignoreUnsupportedSuffixesString;</span>
<span class="nc" id="L221">        cArgs[8] = minArcCostString;</span>
<span class="nc" id="L222">        cArgs[9] = smoothParamString;</span>
<span class="nc" id="L223">        cArgs[10] = costModelString;</span>
<span class="nc" id="L224">        cArgs[11] = scoringData;</span>
<span class="nc" id="L225">        cArgs[12] = verboseString;</span>
<span class="nc" id="L226">        compactor = (GrammarCompactor) Class.forName(&quot;fsm.LossyGrammarCompactor&quot;).getConstructor(argTypes).newInstance(cArgs);</span>
<span class="nc" id="L227">      } catch (Exception e) {</span>
<span class="nc" id="L228">        log.info(&quot;Couldn't instantiate GrammarCompactor: &quot; + e);</span>
<span class="nc" id="L229">        e.printStackTrace();</span>
<span class="nc" id="L230">      }</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">    } else if (op.trainOptions.compactGrammar() == 5) {</span>
<span class="nc" id="L232">      System.out.println(&quot;Instantiating fsm.CategoryMergingGrammarCompactor&quot;);</span>
      try {
<span class="nc" id="L234">        Class[] argTypes = new Class[6];</span>
<span class="nc" id="L235">        Class strClass = String.class;</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">        for (int j = 0; j &lt; argTypes.length; j++) {</span>
<span class="nc" id="L237">          argTypes[j] = strClass;</span>
        }
<span class="nc" id="L239">        Object[] cArgs = new Object[6];</span>
<span class="nc" id="L240">        cArgs[0] = splitParamString;</span>
<span class="nc" id="L241">        cArgs[1] = trainThresholdString;</span>
<span class="nc" id="L242">        cArgs[2] = heldoutThresholdString;</span>
<span class="nc" id="L243">        cArgs[3] = minArcCostString;</span>
<span class="nc" id="L244">        cArgs[4] = ignoreUnsupportedSuffixesString;</span>
<span class="nc" id="L245">        cArgs[5] = smoothParamString;</span>
<span class="nc" id="L246">        compactor = (GrammarCompactor) Class.forName(&quot;fsm.CategoryMergingGrammarCompactor&quot;).getConstructor(argTypes).newInstance(cArgs);</span>
<span class="nc" id="L247">      } catch (Exception e) {</span>
<span class="nc" id="L248">        throw new RuntimeException(&quot;Couldn't instantiate CategoryMergingGrammarCompactor.&quot; + e);</span>
<span class="nc" id="L249">      }</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">    } else if (op.trainOptions.compactGrammar() == 3) {</span>
<span class="nc" id="L251">      System.out.println(&quot;Instantiating fsm.ExactGrammarCompactor&quot;);</span>
<span class="nc" id="L252">      compactor = new ExactGrammarCompactor(op, saveGraphs, true);</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">    } else if (op.trainOptions.compactGrammar() &gt; 0) {</span>
    }

<span class="nc bnc" id="L256" title="All 2 branches missed.">    if (markovOrder &gt;= 0) {</span>
<span class="nc" id="L257">      op.trainOptions.markovOrder = markovOrder;</span>
<span class="nc" id="L258">      op.trainOptions.hSelSplit = false;</span>
    }
<span class="nc bnc" id="L260" title="All 2 branches missed.">    if (toy) {</span>
<span class="nc" id="L261">      buildAndCompactToyGrammars();</span>
    } else {
<span class="nc" id="L263">      testGrammarCompaction();</span>
    }
<span class="nc" id="L265">  }</span>

  /*
  private static void testOneAtATimeMerging() {

    // use the parser constructor to extract the grammars from the treebank once
    LexicalizedParser lp = new LexicalizedParser(path, new NumberRangeFileFilter(trainLow, trainHigh, true), tlpParams);

    ParserData pd = lp.parserData();
    Pair originalGrammar = new Pair(pd.ug, pd.bg);

    // extract a bunch of paths
    Timing.startTime();
    System.out.print(&quot;Extracting other paths...&quot;);
    allTrainPaths = extractPaths(path, trainLow, trainHigh, true);
    allTestPaths = extractPaths(path, testLow, testHigh, true);
    Timing.tick(&quot;done&quot;);

    List mergePairs = null;
    if (inputFile != null) {
      // read merge pairs from file and do them and parse
      System.out.println(&quot;getting pairs from file: &quot; + inputFile);
      mergePairs = getMergePairsFromFile(inputFile);
    }
    // try one merge at a time and parse afterwards
    Numberer originalNumberer = Numberer.getGlobalNumberer(&quot;states&quot;);
    String header = &quot;index\tmergePair\tmergeCost\tparseF1\n&quot;;
    StringUtils.printToFile(outputFile, header, true);

    for (int i = indexRangeLow; i &lt; indexRangeHigh; i++) {

      Timing.startTime();
      Numberer.getNumberers().put(&quot;states&quot;, originalNumberer);
      if (mergePairs != null)
        System.out.println(&quot;passing merge pairs to compactor: &quot; + mergePairs);
      CategoryMergingGrammarCompactor compactor = new CategoryMergingGrammarCompactor(mergePairs, i);
      System.out.println(&quot;Compacting grammars with index &quot; + i);
      Pair compactedGrammar = compactor.compactGrammar(originalGrammar, allTrainPaths, allTestPaths);
      Pair mergePair = null;
      double mergeCosts = Double.NEGATIVE_INFINITY;
      List mergeList = compactor.getCompletedMergeList();
      if (mergeList != null &amp;&amp; mergeList.size() &gt; 0) {
        mergePair = (Pair) mergeList.get(0);
        mergeCosts = compactor.getActualScores().getCount(mergePair);
      }


      ParserData newPd = new ParserData(pd.lex,
                                        (BinaryGrammar) compactedGrammar.second, (UnaryGrammar) compactedGrammar.first,
                                        pd.dg, pd.numbs, pd.pt);

      lp = new LexicalizedParser(newPd);
      Timing.tick(&quot;done.&quot;);

      Treebank testTreebank = tlpParams.testMemoryTreebank();
      testTreebank.loadPath(path, new NumberRangeFileFilter(testLow, testHigh, true));
      System.out.println(&quot;Currently &quot; + new Date());
      double f1 = lp.testOnTreebank(testTreebank);
      System.out.println(&quot;Currently &quot; + new Date());

      String resultString = i + &quot;\t&quot; + mergePair + &quot;\t&quot; + mergeCosts + &quot;\t&quot; + f1 + &quot;\n&quot;;
      StringUtils.printToFile(outputFile, resultString, true);
    }
  }

  private static List getMergePairsFromFile(String filename) {
    List result = new ArrayList();
    try {
      String fileString = StringUtils.slurpFile(new File(filename));
      StringTokenizer st = new StringTokenizer(fileString);
      while (st.hasMoreTokens()) {
        String token1 = st.nextToken();
        if (st.hasMoreTokens()) {
          String token2 = st.nextToken();
          UnorderedPair pair = new UnorderedPair(token1, token2);
          result.add(pair);
        }
      }
    } catch (Exception e) {
      throw new RuntimeException(&quot;couldn't access file: &quot; + filename);
    }
    return result;
  }
*/
  /*
//    System.out.println(MergeableGraph.areIsomorphic(graphs[0], graphs[1], graphs[0].getStartNode(), graphs[1].getStartNode()));
//    System.out.println(MergeableGraph.areIsomorphic(graphs[1], graphs[2], graphs[1].getStartNode(), graphs[2].getStartNode()));
//    System.out.println(MergeableGraph.areIsomorphic(graphs[2], graphs[0], graphs[2].getStartNode(), graphs[0].getStartNode()));

  // now go through the grammars themselves and see if they are equal
  System.out.println(&quot;UR 0 and 1: &quot; + equalsUnary(((UnaryGrammar)grammars[0].first).rules(),((UnaryGrammar)grammars[1].first).rules()));
  System.out.println(&quot;UR 1 and 2: &quot;  + equalsUnary(((UnaryGrammar)grammars[1].first).rules(),((UnaryGrammar)grammars[2].first).rules()));
  System.out.println(&quot;UR 2 and 0: &quot;  + equalsUnary(((UnaryGrammar)grammars[2].first).rules(),((UnaryGrammar)grammars[0].first).rules()));

  System.out.println(&quot;BR 0 and 1: &quot;  + equalsBinary(((BinaryGrammar)grammars[0].second).rules(),((BinaryGrammar)grammars[1].second).rules()));
  System.out.println(&quot;BR 1 and 2: &quot; + equalsBinary(((BinaryGrammar)grammars[1].second).rules(),((BinaryGrammar)grammars[2].second).rules()));
  System.out.println(&quot;BR 2 and 0: &quot; + equalsBinary(((BinaryGrammar)grammars[2].second).rules(),((BinaryGrammar)grammars[0].second).rules()));

    System.exit(0);

  // now go through the grammars we made and see if they are equal!
  Set[] unaryRules = new Set[3];
  Set[] binaryRules = new Set[3];
  for (int i=0; i&lt;grammars.length; i++) {
    unaryRules[i] = new HashSet();
    System.out.println(i + &quot; size: &quot; + ((UnaryGrammar)grammars[i].first()).numRules());
    for (Iterator unRuleI = ((UnaryGrammar)grammars[i].first()).iterator(); unRuleI.hasNext();) {
      UnaryRule ur = (UnaryRule) unRuleI.next();
      String parent = (String) stateNumberers[i].object(ur.parent);
      String child = (String) stateNumberers[i].object(ur.child);
      unaryRules[i].add(new StringUnaryRule(parent, child, ur.score));
    }
    binaryRules[i] = new HashSet();
    System.out.println(i + &quot; size: &quot; + ((BinaryGrammar)grammars[i].second()).numRules());
    for (Iterator binRuleI = ((BinaryGrammar)grammars[i].second()).iterator(); binRuleI.hasNext();) {
      BinaryRule br = (BinaryRule) binRuleI.next();
      String parent = (String) stateNumberers[i].object(br.parent);
      String leftChild = (String) stateNumberers[i].object(br.leftChild);
      String rightChild = (String) stateNumberers[i].object(br.rightChild);
      binaryRules[i].add(new StringBinaryRule(parent, leftChild, rightChild, br.score));
    }
  }

  System.out.println(&quot;uR 0 and 1: &quot; + equals(unaryRules[0],unaryRules[1]));
  System.out.println(&quot;uR 1 and 2: &quot; + equals(unaryRules[1],unaryRules[2]));
  System.out.println(&quot;uR 2 and 0: &quot; + equals(unaryRules[2],unaryRules[0]));

  System.out.println(&quot;bR 0 and 1: &quot; + equals(binaryRules[0],binaryRules[1]));
  System.out.println(&quot;bR 1 and 2: &quot; + equals(binaryRules[1],binaryRules[2]));
  System.out.println(&quot;bR 2 and 0: &quot; + equals(binaryRules[2],binaryRules[0]));

}
*/

  /*
    public static void testCategoryMergingProblem() {
      LexicalizedParser lp = new LexicalizedParser(path, new NumberRangeFileFilter(trainLow, trainHigh, true), tlpParams);

      // test it without the change
      Treebank testTreebank = tlpParams.testMemoryTreebank();
      testTreebank.loadPath(path, new NumberRangeFileFilter(testLow, testHigh, true));
      System.out.println(&quot;Currently &quot; + new Date());
      lp.testOnTreebank(testTreebank);
      System.out.println(&quot;Currently &quot; + new Date());

      // pull out the rules and consistently change the name of one of the states
      ParserData pd = lp.parserData();
      BinaryGrammar bg = pd.bg;
      UnaryGrammar ug = pd.ug;
      Numberer stateNumberer = Numberer.getGlobalNumberer(&quot;states&quot;);
      UnaryGrammar newUG = new UnaryGrammar(stateNumberer.total()+1);
      for (Iterator urIter = ug.iterator(); urIter.hasNext();) {
        UnaryRule rule = (UnaryRule) urIter.next();
        rule.parent = changeIfNecessary(rule.parent, stateNumberer);
        rule.child = changeIfNecessary(rule.child, stateNumberer);
        newUG.addRule(rule);
      }
      BinaryGrammar newBG = new BinaryGrammar(stateNumberer.total()+1);
      for (Iterator urIter = bg.iterator(); urIter.hasNext();) {
        BinaryRule rule = (BinaryRule) urIter.next();
        rule.parent = changeIfNecessary(rule.parent, stateNumberer);
        rule.leftChild = changeIfNecessary(rule.leftChild, stateNumberer);
        rule.rightChild = changeIfNecessary(rule.rightChild, stateNumberer);
        newBG.addRule(rule);
      }
      newUG.purgeRules();
      newBG.splitRules();
      pd.ug = newUG;
      pd.bg = newBG;
      lp = new LexicalizedParser(pd);

      // test it with the change
      testTreebank = tlpParams.testMemoryTreebank();
      testTreebank.loadPath(path, new NumberRangeFileFilter(testLow, testHigh, true));
      System.out.println(&quot;Currently &quot; + new Date());
      lp.testOnTreebank(testTreebank);
      System.out.println(&quot;Currently &quot; + new Date());
    }
  */

  public Pair&lt;UnaryGrammar, BinaryGrammar&gt; translateAndSort(Pair&lt;UnaryGrammar, BinaryGrammar&gt; grammar, Index&lt;String&gt; oldIndex, Index&lt;String&gt; newIndex) {
<span class="nc" id="L446">    System.out.println(&quot;oldIndex.size()&quot; + oldIndex.size() + &quot; newIndex.size()&quot; + newIndex.size());</span>
<span class="nc" id="L447">    UnaryGrammar ug = grammar.first;</span>
<span class="nc" id="L448">    List&lt;UnaryRule&gt; unaryRules = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L449" title="All 2 branches missed.">    for (UnaryRule rule : ug.rules()) {</span>
<span class="nc" id="L450">      rule.parent = translate(rule.parent, oldIndex, newIndex);</span>
<span class="nc" id="L451">      rule.child = translate(rule.child, oldIndex, newIndex);</span>
<span class="nc" id="L452">      unaryRules.add(rule);</span>
<span class="nc" id="L453">    }</span>
<span class="nc" id="L454">    Collections.sort(unaryRules);</span>

<span class="nc" id="L456">    UnaryGrammar newUG = new UnaryGrammar(newIndex);</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">    for (UnaryRule unaryRule : unaryRules) {</span>
<span class="nc" id="L458">      newUG.addRule(unaryRule);</span>
<span class="nc" id="L459">    }</span>
<span class="nc" id="L460">    newUG.purgeRules();</span>

<span class="nc" id="L462">    BinaryGrammar bg = grammar.second;</span>
<span class="nc" id="L463">    List&lt;BinaryRule&gt; binaryRules = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">    for (BinaryRule rule : bg.rules()) {</span>
<span class="nc" id="L465">      rule.parent = translate(rule.parent, oldIndex, newIndex);</span>
<span class="nc" id="L466">      rule.leftChild = translate(rule.leftChild, oldIndex, newIndex);</span>
<span class="nc" id="L467">      rule.rightChild = translate(rule.rightChild, oldIndex, newIndex);</span>
<span class="nc" id="L468">      binaryRules.add(rule);</span>
<span class="nc" id="L469">    }</span>
<span class="nc" id="L470">    Collections.sort(unaryRules);</span>

<span class="nc" id="L472">    BinaryGrammar newBG = new BinaryGrammar(newIndex);</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">    for (BinaryRule binaryRule : binaryRules) {</span>
<span class="nc" id="L474">      newBG.addRule(binaryRule);</span>
<span class="nc" id="L475">    }</span>
<span class="nc" id="L476">    newBG.splitRules();</span>

<span class="nc" id="L478">    return Generics.newPair(newUG, newBG);</span>
  }

  private static int translate(int i, Index&lt;String&gt; oldIndex, Index&lt;String&gt; newIndex) {
<span class="nc" id="L482">    return newIndex.addToIndex(oldIndex.get(i));</span>
  }

  // WTF is this?
  public int changeIfNecessary(int i, Index&lt;String&gt; n) {
<span class="nc" id="L487">    String s = n.get(i);</span>
<span class="nc bnc" id="L488" title="All 2 branches missed.">    if (s.equals(&quot;NP^PP&quot;)) {</span>
<span class="nc" id="L489">      System.out.println(&quot;changed&quot;);</span>
<span class="nc" id="L490">      return n.addToIndex(&quot;NP-987928374&quot;);</span>
    }
<span class="nc" id="L492">    return i;</span>
  }

  public boolean equalsBinary(List&lt;BinaryRule&gt; l1, List&lt;BinaryRule&gt; l2) {
    // put each into a map to itself
<span class="nc" id="L497">    Map&lt;BinaryRule, BinaryRule&gt; map1 = Generics.newHashMap();</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">    for (BinaryRule o : l1) {</span>
<span class="nc" id="L499">      map1.put(o, o);</span>
<span class="nc" id="L500">    }</span>
<span class="nc" id="L501">    Map&lt;BinaryRule, BinaryRule&gt; map2 = Generics.newHashMap();</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">    for (BinaryRule o : l2) {</span>
<span class="nc" id="L503">      map2.put(o, o);</span>
<span class="nc" id="L504">    }</span>
<span class="nc" id="L505">    boolean isEqual = true;</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">    for (BinaryRule rule1 : map1.keySet()) {</span>
<span class="nc" id="L507">      BinaryRule rule2 = map2.get(rule1);</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">      if (rule2 == null) {</span>
<span class="nc" id="L509">        System.out.println(&quot;no rule for &quot; + rule1);</span>
<span class="nc" id="L510">        isEqual = false;</span>
      } else {
<span class="nc" id="L512">        map2.remove(rule2);</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">        if (rule1.score != rule2.score) {</span>
<span class="nc" id="L514">          System.out.println(rule1 + &quot; and &quot; + rule2 + &quot; have diff scores&quot;);</span>
<span class="nc" id="L515">          isEqual = false;</span>
        }
      }
<span class="nc" id="L518">    }</span>
<span class="nc" id="L519">    System.out.println(&quot;left over: &quot; + map2.keySet());</span>
<span class="nc" id="L520">    return isEqual;</span>
  }

  public boolean equalsUnary(List&lt;UnaryRule&gt; l1, List&lt;UnaryRule&gt; l2) {
    // put each into a map to itself
<span class="nc" id="L525">    Map&lt;UnaryRule, UnaryRule&gt; map1 = Generics.newHashMap();</span>
<span class="nc bnc" id="L526" title="All 2 branches missed.">    for (UnaryRule o : l1) {</span>
<span class="nc" id="L527">      map1.put(o, o);</span>
<span class="nc" id="L528">    }</span>
<span class="nc" id="L529">    Map&lt;UnaryRule, UnaryRule&gt; map2 = Generics.newHashMap();</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">    for (UnaryRule o : l2) {</span>
<span class="nc" id="L531">      map2.put(o, o);</span>
<span class="nc" id="L532">    }</span>
<span class="nc" id="L533">    boolean isEqual = true;</span>
<span class="nc bnc" id="L534" title="All 2 branches missed.">    for (UnaryRule rule1 : map1.keySet()) {</span>
<span class="nc" id="L535">      UnaryRule rule2 = map2.get(rule1);</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">      if (rule2 == null) {</span>
<span class="nc" id="L537">        System.out.println(&quot;no rule for &quot; + rule1);</span>
<span class="nc" id="L538">        isEqual = false;</span>
      } else {
<span class="nc" id="L540">        map2.remove(rule2);</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">        if (rule1.score != rule2.score) {</span>
<span class="nc" id="L542">          System.out.println(rule1 + &quot; and &quot; + rule2 + &quot; have diff scores&quot;);</span>
<span class="nc" id="L543">          isEqual = false;</span>
        }
      }
<span class="nc" id="L546">    }</span>
<span class="nc" id="L547">    System.out.println(&quot;left over: &quot; + map2.keySet());</span>
<span class="nc" id="L548">    return isEqual;</span>
  }

  private static &lt;T&gt; boolean equalSets(Set&lt;T&gt; set1, Set&lt;T&gt; set2) {
<span class="nc" id="L552">    boolean isEqual = true;</span>
<span class="nc bnc" id="L553" title="All 2 branches missed.">    if (set1.size() != set2.size()) {</span>
<span class="nc" id="L554">      System.out.println(&quot;sizes different: &quot; + set1.size() + &quot; vs. &quot; + set2.size());</span>
<span class="nc" id="L555">      isEqual = false;</span>
    }
<span class="nc" id="L557">    Set&lt;T&gt; newSet1 = (Set&lt;T&gt;) ((HashSet&lt;T&gt;) set1).clone();</span>
<span class="nc" id="L558">    newSet1.removeAll(set2);</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">    if (newSet1.size() &gt; 0) {</span>
<span class="nc" id="L560">      isEqual = false;</span>
<span class="nc" id="L561">      System.out.println(&quot;set1 left with: &quot; + newSet1);</span>
    }
<span class="nc" id="L563">    Set&lt;T&gt; newSet2 = (Set&lt;T&gt;) ((HashSet&lt;T&gt;) set2).clone();</span>
<span class="nc" id="L564">    newSet2.removeAll(set1);</span>
<span class="nc bnc" id="L565" title="All 2 branches missed.">    if (newSet2.size() &gt; 0) {</span>
<span class="nc" id="L566">      isEqual = false;</span>
<span class="nc" id="L567">      System.out.println(&quot;set2 left with: &quot; + newSet2);</span>
    }
<span class="nc" id="L569">    return isEqual;</span>
  }

  /*
  public static void testAutomatonCompaction() {
    // make our LossyAutomatonCompactor from the parameters passed at command line
    // now set up the compactor2 constructor args
    // extract a bunch of paths
    Timing.startTime();
    System.out.print(&quot;Extracting paths from treebank...&quot;);
    allTrainPaths = extractPaths(path, trainLow, trainHigh, false);
    allTestPaths = extractPaths(path, testLow, testHigh, false);
    Timing.tick(&quot;done&quot;);

    // for each category, construct an automaton and then compact it
    for (Iterator catIter = allTrainPaths.keySet().iterator(); catIter.hasNext();) {
      // construct an automaton from the paths
      String category = (String) catIter.next();
      List trainPaths = (List) allTrainPaths.get(category);
      List testPaths = (List) allTestPaths.get(category);
      if (testPaths == null) testPaths = new ArrayList();
      // now make the graph with the training paths (the LossyAutomatonCompactor will reestimate the weights anyway)
      TransducerGraph graph = TransducerGraph.createGraphFromPaths(trainPaths, 3);
      System.out.println(&quot;Created graph for: &quot; + category);

      System.out.println();
      int numArcs1 = graph.getArcs().size();

      LossyAutomatonCompactor compactor = new LossyAutomatonCompactor(3, // horizonOrder, 1 means that only exactly compatible merges are considered
								      0, // min nmber of arcs
								      10000000.0, // maxMergeCost
								      0.5, // splitParam
								      false, //  ignoreUnsupportedSuffixes
                      -1000, // minArcCost
								      trainPaths,
								      testPaths,
								      LossyAutomatonCompactor.DATA_LIKELIHOOD_COST, // costModel
								      false); // verbose

      TransducerGraph result = compactor.compactFA(graph);
      //do we need this?      result = new TransducerGraph(result, ntsp);  // pull out strings from sets returned by minimizer
      int numArcs2 = result.getArcs().size();
      System.out.println(&quot;LossyGrammarCompactor compacted &quot;+category+&quot; from &quot; + numArcs1 + &quot; to &quot; + numArcs2 + &quot; arcs&quot;);

    }


  }
*/
  private static &lt;T&gt; int numTokens(List&lt;List&lt;T&gt;&gt; paths) {
<span class="nc" id="L619">    int result = 0;</span>
<span class="nc bnc" id="L620" title="All 2 branches missed.">    for (List&lt;T&gt; path : paths) {</span>
<span class="nc" id="L621">      result += path.size();</span>
<span class="nc" id="L622">    }</span>
<span class="nc" id="L623">    return result;</span>
  }

  public void buildAndCompactToyGrammars() {
    // extract a bunch of paths
<span class="nc" id="L628">    System.out.print(&quot;Extracting other paths...&quot;);</span>
<span class="nc" id="L629">    allTrainPaths = extractPaths(path, trainLow, trainHigh, true);</span>
<span class="nc" id="L630">    TransducerGraph.NodeProcessor ntsp = new TransducerGraph.SetToStringNodeProcessor(new PennTreebankLanguagePack());</span>
<span class="nc" id="L631">    TransducerGraph.NodeProcessor otsp = new TransducerGraph.ObjectToSetNodeProcessor();</span>
<span class="nc" id="L632">    TransducerGraph.ArcProcessor isp = new TransducerGraph.InputSplittingProcessor();</span>
<span class="nc" id="L633">    TransducerGraph.ArcProcessor ocp = new TransducerGraph.OutputCombiningProcessor();</span>
<span class="nc" id="L634">    TransducerGraph.GraphProcessor normalizer = new TransducerGraph.NormalizingGraphProcessor(false);</span>
<span class="nc" id="L635">    TransducerGraph.GraphProcessor quasiDeterminizer = new QuasiDeterminizer();</span>
<span class="nc" id="L636">    AutomatonMinimizer exactMinimizer = new FastExactAutomatonMinimizer();</span>
<span class="nc bnc" id="L637" title="All 2 branches missed.">    for (String key : allTrainPaths.keySet()) {</span>
<span class="nc" id="L638">      System.out.println(&quot;creating graph for &quot; + key);</span>
<span class="nc" id="L639">      List&lt;List&lt;String&gt;&gt; paths = allTrainPaths.get(key);</span>
<span class="nc" id="L640">      ClassicCounter&lt;List&lt;String&gt;&gt; pathCounter = new ClassicCounter&lt;&gt;();</span>
<span class="nc bnc" id="L641" title="All 2 branches missed.">      for (List&lt;String&gt; o : paths) {</span>
<span class="nc" id="L642">        pathCounter.incrementCount(o);</span>
<span class="nc" id="L643">      }</span>
<span class="nc" id="L644">      ClassicCounter&lt;List&lt;String&gt;&gt; newPathCounter = removeLowCountPaths(pathCounter, 2);</span>
<span class="nc" id="L645">      paths.retainAll(newPathCounter.keySet()); // get rid of the low count ones</span>
<span class="nc" id="L646">      TransducerGraph result = TransducerGraph.createGraphFromPaths(newPathCounter, 1000);</span>
      // exact compaction
<span class="nc" id="L648">      int numArcs = result.getArcs().size();</span>
<span class="nc" id="L649">      int numNodes = result.getNodes().size();</span>
<span class="nc bnc" id="L650" title="All 2 branches missed.">      if (numArcs == 0) {</span>
<span class="nc" id="L651">        continue;</span>
      }
<span class="nc" id="L653">      System.out.println(&quot;initial graph has &quot; + numArcs + &quot; arcs and &quot; + numNodes + &quot; nodes.&quot;);</span>
<span class="nc" id="L654">      GrammarCompactor.writeFile(result, &quot;unminimized&quot;, key);</span>
      // do exact minimization
<span class="nc" id="L656">      result = normalizer.processGraph(result); // normalize it so that exact minimization works properly</span>
<span class="nc" id="L657">      result = quasiDeterminizer.processGraph(result); // push probabilities left or down</span>
<span class="nc" id="L658">      result = new TransducerGraph(result, ocp); // combine outputs into inputs</span>
<span class="nc" id="L659">      result = exactMinimizer.minimizeFA(result); // minimize the thing</span>
<span class="nc" id="L660">      result = new TransducerGraph(result, ntsp);  // pull out strings from sets returned by minimizer</span>
<span class="nc" id="L661">      result = new TransducerGraph(result, isp); // split outputs from inputs</span>
<span class="nc" id="L662">      numArcs = result.getArcs().size();</span>
<span class="nc" id="L663">      numNodes = result.getNodes().size();</span>

<span class="nc" id="L665">      System.out.println(&quot;after exact minimization graph has &quot; + numArcs + &quot; arcs and &quot; + numNodes + &quot; nodes.&quot;);</span>
<span class="nc" id="L666">      GrammarCompactor.writeFile(result, &quot;exactminimized&quot;, key);</span>

      // do additional lossy minimization
      /*
      NewLossyAutomatonCompactor compactor2 = new NewLossyAutomatonCompactor(paths, true);
      result = compactor2.compactFA(result);
      result = new TransducerGraph(result, ntsp);  // pull out strings from sets returned by minimizer
      numArcs = result.getArcs().size();
      numNodes = result.getNodes().size();

      System.out.println(&quot;after lossy minimization graph has &quot; + numArcs + &quot; arcs and &quot; + numNodes + &quot; nodes.&quot;);
      GrammarCompactor.writeFile(result, &quot;lossyminimized&quot;, key);
      */
<span class="nc" id="L679">    }</span>
<span class="nc" id="L680">  }</span>

  private static ClassicCounter&lt;List&lt;String&gt;&gt; removeLowCountPaths(ClassicCounter&lt;List&lt;String&gt;&gt; paths, double thresh) {
<span class="nc" id="L683">    ClassicCounter&lt;List&lt;String&gt;&gt; result = new ClassicCounter&lt;&gt;();</span>
<span class="nc" id="L684">    int numRetained = 0;</span>
<span class="nc bnc" id="L685" title="All 2 branches missed.">    for (List&lt;String&gt; path : paths.keySet()) {</span>
<span class="nc" id="L686">      double count = paths.getCount(path);</span>
<span class="nc bnc" id="L687" title="All 2 branches missed.">      if (count &gt;= thresh) {</span>
<span class="nc" id="L688">        result.setCount(path, count);</span>
<span class="nc" id="L689">        numRetained++;</span>
      }
<span class="nc" id="L691">    }</span>
<span class="nc" id="L692">    System.out.println(&quot;retained &quot; + numRetained);</span>
<span class="nc" id="L693">    return result;</span>
  }

  public void testGrammarCompaction() {

    // these for testing against the markov 3rd order baseline

    // use the parser constructor to extract the grammars from the treebank
<span class="nc" id="L701">    op = new Options();</span>
<span class="nc" id="L702">    LexicalizedParser lp = LexicalizedParser.trainFromTreebank(path, new NumberRangeFileFilter(trainLow, trainHigh, true), op);</span>

    // compact grammars
<span class="nc bnc" id="L705" title="All 2 branches missed.">    if (compactor != null) {</span>

      // extract a bunch of paths
<span class="nc" id="L708">      Timing.startTime();</span>
<span class="nc" id="L709">      System.out.print(&quot;Extracting other paths...&quot;);</span>
<span class="nc" id="L710">      allTrainPaths = extractPaths(path, trainLow, trainHigh, true);</span>
<span class="nc" id="L711">      allTestPaths = extractPaths(path, testLow, testHigh, true);</span>
<span class="nc" id="L712">      Timing.tick(&quot;done&quot;);</span>

      // compact grammars
<span class="nc" id="L715">      Timing.startTime();</span>
<span class="nc" id="L716">      System.out.print(&quot;Compacting grammars...&quot;);</span>
<span class="nc" id="L717">      Pair&lt;UnaryGrammar, BinaryGrammar&gt; grammar = Generics.newPair(lp.ug, lp.bg);</span>
<span class="nc" id="L718">      Triple&lt;Index&lt;String&gt;, UnaryGrammar, BinaryGrammar&gt; compactedGrammar = compactor.compactGrammar(grammar, allTrainPaths, allTestPaths, lp.stateIndex);</span>
<span class="nc" id="L719">      lp.stateIndex = compactedGrammar.first();</span>
<span class="nc" id="L720">      lp.ug = compactedGrammar.second();</span>
<span class="nc" id="L721">      lp.bg = compactedGrammar.third();</span>

<span class="nc" id="L723">      Timing.tick(&quot;done.&quot;);</span>
    }

<span class="nc bnc" id="L726" title="All 2 branches missed.">    if (asciiOutputPath != null) {</span>
<span class="nc" id="L727">      lp.saveParserToTextFile(asciiOutputPath);</span>
    }

    // test it
<span class="nc" id="L731">    Treebank testTreebank = op.tlpParams.testMemoryTreebank();</span>
<span class="nc" id="L732">    testTreebank.loadPath(path, new NumberRangeFileFilter(testLow, testHigh, true));</span>
<span class="nc" id="L733">    System.out.println(&quot;Currently &quot; + new Date());</span>
<span class="nc" id="L734">    EvaluateTreebank evaluator = new EvaluateTreebank(lp);</span>
<span class="nc" id="L735">    evaluator.testOnTreebank(testTreebank);</span>
<span class="nc" id="L736">    System.out.println(&quot;Currently &quot; + new Date());</span>
<span class="nc" id="L737">  }</span>

}

class StringUnaryRule {
  public String parent;
  public String child;
  public double score;

  @Override
  public boolean equals(Object o) {
<span class="nc bnc" id="L748" title="All 2 branches missed.">    if (this == o) {</span>
<span class="nc" id="L749">      return true;</span>
    }
<span class="nc bnc" id="L751" title="All 2 branches missed.">    if (!(o instanceof StringUnaryRule)) {</span>
<span class="nc" id="L752">      return false;</span>
    }

<span class="nc" id="L755">    final StringUnaryRule stringUnaryRule = (StringUnaryRule) o;</span>

<span class="nc bnc" id="L757" title="All 2 branches missed.">    if (score != stringUnaryRule.score) {</span>
<span class="nc" id="L758">      return false;</span>
    }
<span class="nc bnc" id="L760" title="All 6 branches missed.">    if (child != null ? !child.equals(stringUnaryRule.child) : stringUnaryRule.child != null) {</span>
<span class="nc" id="L761">      return false;</span>
    }
<span class="nc bnc" id="L763" title="All 6 branches missed.">    if (parent != null ? !parent.equals(stringUnaryRule.parent) : stringUnaryRule.parent != null) {</span>
<span class="nc" id="L764">      return false;</span>
    }

<span class="nc" id="L767">    return true;</span>
  }

  @Override
  public int hashCode() {
    int result;
    long temp;
<span class="nc bnc" id="L774" title="All 2 branches missed.">    result = (parent != null ? parent.hashCode() : 0);</span>
<span class="nc bnc" id="L775" title="All 2 branches missed.">    result = 29 * result + (child != null ? child.hashCode() : 0);</span>
<span class="nc" id="L776">    temp = Double.doubleToLongBits(score);</span>
<span class="nc" id="L777">    result = 29 * result + (int) (temp ^ (temp &gt;&gt;&gt; 32));</span>
<span class="nc" id="L778">    return result;</span>
  }

  @Override
  public String toString() {
<span class="nc" id="L783">    return &quot;UR:::::&quot; + parent + &quot;:::::&quot; + child + &quot;:::::&quot; + score;</span>
  }

<span class="nc" id="L786">  public StringUnaryRule(String parent, String child, double score) {</span>
<span class="nc" id="L787">    this.parent = parent;</span>
<span class="nc" id="L788">    this.child = child;</span>
<span class="nc" id="L789">    this.score = score;</span>
<span class="nc" id="L790">  }</span>
}

class StringBinaryRule {
  public String parent;
  public String leftChild;
  public String rightChild;
  public double score;

  @Override
  public boolean equals(Object o) {
<span class="nc bnc" id="L801" title="All 2 branches missed.">    if (this == o) {</span>
<span class="nc" id="L802">      return true;</span>
    }
<span class="nc bnc" id="L804" title="All 2 branches missed.">    if (!(o instanceof StringBinaryRule)) {</span>
<span class="nc" id="L805">      return false;</span>
    }

<span class="nc" id="L808">    final StringBinaryRule stringBinaryRule = (StringBinaryRule) o;</span>

<span class="nc bnc" id="L810" title="All 2 branches missed.">    if (score != stringBinaryRule.score) {</span>
<span class="nc" id="L811">      return false;</span>
    }
<span class="nc bnc" id="L813" title="All 6 branches missed.">    if (leftChild != null ? !leftChild.equals(stringBinaryRule.leftChild) : stringBinaryRule.leftChild != null) {</span>
<span class="nc" id="L814">      return false;</span>
    }
<span class="nc bnc" id="L816" title="All 6 branches missed.">    if (parent != null ? !parent.equals(stringBinaryRule.parent) : stringBinaryRule.parent != null) {</span>
<span class="nc" id="L817">      return false;</span>
    }
<span class="nc bnc" id="L819" title="All 6 branches missed.">    if (rightChild != null ? !rightChild.equals(stringBinaryRule.rightChild) : stringBinaryRule.rightChild != null) {</span>
<span class="nc" id="L820">      return false;</span>
    }

<span class="nc" id="L823">    return true;</span>
  }

  @Override
  public int hashCode() {
    int result;
    long temp;
<span class="nc bnc" id="L830" title="All 2 branches missed.">    result = (parent != null ? parent.hashCode() : 0);</span>
<span class="nc bnc" id="L831" title="All 2 branches missed.">    result = 29 * result + (leftChild != null ? leftChild.hashCode() : 0);</span>
<span class="nc bnc" id="L832" title="All 2 branches missed.">    result = 29 * result + (rightChild != null ? rightChild.hashCode() : 0);</span>
<span class="nc" id="L833">    temp = Double.doubleToLongBits(score);</span>
<span class="nc" id="L834">    result = 29 * result + (int) (temp ^ (temp &gt;&gt;&gt; 32));</span>
<span class="nc" id="L835">    return result;</span>
  }

  @Override
  public String toString() {
<span class="nc" id="L840">    return &quot;BR:::::&quot; + parent + &quot;:::::&quot; + leftChild + &quot;:::::&quot; + rightChild + &quot;:::::&quot; + score;</span>
  }

<span class="nc" id="L843">  public StringBinaryRule(String parent, String leftChild, String rightChild, double score) {</span>
<span class="nc" id="L844">    this.parent = parent;</span>
<span class="nc" id="L845">    this.leftChild = leftChild;</span>
<span class="nc" id="L846">    this.rightChild = rightChild;</span>
<span class="nc" id="L847">    this.score = score;</span>
<span class="nc" id="L848">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>