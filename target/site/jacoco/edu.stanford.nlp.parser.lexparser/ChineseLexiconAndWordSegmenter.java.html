<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ChineseLexiconAndWordSegmenter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.parser.lexparser</a> &gt; <span class="el_source">ChineseLexiconAndWordSegmenter.java</span></div><h1>ChineseLexiconAndWordSegmenter.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.parser.lexparser; 
import edu.stanford.nlp.util.logging.Redwood;

import edu.stanford.nlp.io.NumberRangeFileFilter;
import edu.stanford.nlp.io.NumberRangesFileFilter;
import edu.stanford.nlp.io.IOUtils;
import edu.stanford.nlp.ling.HasWord;
import edu.stanford.nlp.ling.TaggedWord;
import edu.stanford.nlp.ling.Word;
import edu.stanford.nlp.process.TokenizerFactory;
import java.util.function.Function;
import edu.stanford.nlp.process.WordSegmenter;
import edu.stanford.nlp.trees.*;
import edu.stanford.nlp.trees.international.pennchinese.ChineseEscaper;
import edu.stanford.nlp.util.Generics;
import edu.stanford.nlp.util.HashIndex;
import edu.stanford.nlp.util.Index;
import edu.stanford.nlp.util.Timing;

import java.io.*;
import java.util.*;
import java.util.zip.GZIPOutputStream;
import java.util.zip.GZIPInputStream;
import java.net.URL;
import java.net.URLConnection;

/**
 * This class lets you train a lexicon and segmenter at the same time.
 *
 * @author Galen Andrew
 * @author Pi-Chuan Chang
 */
public class ChineseLexiconAndWordSegmenter implements Lexicon, WordSegmenter  {

  /** A logger for this class */
<span class="nc" id="L36">  private static Redwood.RedwoodChannels log = Redwood.channels(ChineseLexiconAndWordSegmenter.class);</span>

  private final ChineseLexicon chineseLexicon;
  private final WordSegmenter wordSegmenter;

<span class="nc" id="L41">  public ChineseLexiconAndWordSegmenter(ChineseLexicon lex, WordSegmenter seg) {</span>
<span class="nc" id="L42">    chineseLexicon = lex;</span>
<span class="nc" id="L43">    wordSegmenter = seg;</span>
<span class="nc" id="L44">  }</span>

  @Override
  public List&lt;HasWord&gt; segment(String s) {
<span class="nc" id="L48">    return wordSegmenter.segment(s);</span>
  }

  @Override
  public boolean isKnown(int word) {
<span class="nc" id="L53">    return chineseLexicon.isKnown(word);</span>
  }

  @Override
  public boolean isKnown(String word) {
<span class="nc" id="L58">    return chineseLexicon.isKnown(word);</span>
  }

  /** {@inheritDoc} */
  @Override
  public Set&lt;String&gt; tagSet(Function&lt;String,String&gt; basicCategoryFunction) {
<span class="nc" id="L64">    return chineseLexicon.tagSet(basicCategoryFunction);</span>
  }


  @Override
  public Iterator&lt;IntTaggedWord&gt; ruleIteratorByWord(int word, int loc, String featureSpec) {
<span class="nc" id="L70">    return chineseLexicon.ruleIteratorByWord(word, loc, null);</span>
  }

  @Override
  public Iterator&lt;IntTaggedWord&gt; ruleIteratorByWord(String word, int loc, String featureSpec) {
<span class="nc" id="L75">    return chineseLexicon.ruleIteratorByWord(word, loc, null);</span>
  }

  /** Returns the number of rules (tag rewrites as word) in the Lexicon.
   *  This method assumes that the lexicon has been initialized.
   */
  @Override
  public int numRules() {
<span class="nc" id="L83">    return chineseLexicon.numRules();</span>
  }

  @Override
  public void initializeTraining(double numTrees) {
<span class="nc" id="L88">    chineseLexicon.initializeTraining(numTrees);</span>
<span class="nc" id="L89">    wordSegmenter.initializeTraining(numTrees);</span>
<span class="nc" id="L90">  }</span>

  @Override
  public void train(Collection&lt;Tree&gt; trees) {
<span class="nc" id="L94">    train(trees, 1.0);</span>
<span class="nc" id="L95">  }</span>

  @Override
  public void train(Collection&lt;Tree&gt; trees, double weight) {
<span class="nc bnc" id="L99" title="All 2 branches missed.">    for (Tree tree : trees) {</span>
<span class="nc" id="L100">      train(tree, weight);</span>
<span class="nc" id="L101">    }</span>
<span class="nc" id="L102">  }</span>

  @Override
  public void train(Tree tree) {
<span class="nc" id="L106">    train(tree, 1.0);</span>
<span class="nc" id="L107">  }</span>

  @Override
  public void train(Tree tree, double weight) {
<span class="nc" id="L111">    train(tree.taggedYield(), weight);</span>
<span class="nc" id="L112">  }</span>

  @Override
  public void train(List&lt;TaggedWord&gt; sentence) {
<span class="nc" id="L116">    train(sentence, 1.0);</span>
<span class="nc" id="L117">  }</span>

  @Override
  public void train(List&lt;TaggedWord&gt; sentence, double weight) {
<span class="nc" id="L121">    chineseLexicon.train(sentence, weight);</span>
<span class="nc" id="L122">    wordSegmenter.train(sentence);</span>
<span class="nc" id="L123">  }</span>

  @Override
  public void trainUnannotated(List&lt;TaggedWord&gt; sentence, double weight) {
    // TODO: for now we just punt on these
<span class="nc" id="L128">    throw new UnsupportedOperationException(&quot;This version of the parser does not support non-tree training data&quot;);</span>
  }

  @Override
  public void incrementTreesRead(double weight) {
<span class="nc" id="L133">    throw new UnsupportedOperationException();</span>
  }

  @Override
  public void train(TaggedWord tw, int loc, double weight) {
<span class="nc" id="L138">    throw new UnsupportedOperationException();</span>
  }

  @Override
  public void finishTraining() {
<span class="nc" id="L143">    chineseLexicon.finishTraining();</span>
<span class="nc" id="L144">    wordSegmenter.finishTraining();</span>
<span class="nc" id="L145">  }</span>

  @Override
  public float score(IntTaggedWord iTW, int loc, String word, String featureSpec) {
<span class="nc" id="L149">    return chineseLexicon.score(iTW, loc, word, null);</span>
  } // end score()


  @Override
  public void loadSegmenter(String filename) {
<span class="nc" id="L155">    throw new UnsupportedOperationException();</span>
  }

  @Override
  public void readData(BufferedReader in) throws IOException {
<span class="nc" id="L160">    chineseLexicon.readData(in);</span>
<span class="nc" id="L161">  }</span>

  @Override
  public void writeData(Writer w) throws IOException {
<span class="nc" id="L165">    chineseLexicon.writeData(w);</span>
<span class="nc" id="L166">  }</span>

  // the data &amp; functions below are for standalone segmenter. -pichuan
  private Options op;
  // helper function
  private static int numSubArgs(String[] args, int index) {
<span class="nc" id="L172">    int i = index;</span>
<span class="nc bnc" id="L173" title="All 4 branches missed.">    while (i + 1 &lt; args.length &amp;&amp; args[i + 1].charAt(0) != '-') {</span>
<span class="nc" id="L174">      i++;</span>
    }
<span class="nc" id="L176">    return i - index;</span>
  }

<span class="nc" id="L179">  private ChineseLexiconAndWordSegmenter(Treebank trainTreebank, Options op, Index&lt;String&gt; wordIndex, Index&lt;String&gt; tagIndex) {</span>
<span class="nc" id="L180">    ChineseLexiconAndWordSegmenter cs = getSegmenterDataFromTreebank(trainTreebank, op, wordIndex, tagIndex);</span>
<span class="nc" id="L181">    chineseLexicon = cs.chineseLexicon;</span>
<span class="nc" id="L182">    wordSegmenter = cs.wordSegmenter;</span>
<span class="nc" id="L183">  }</span>

  private static ChineseLexiconAndWordSegmenter getSegmenterDataFromTreebank(Treebank trainTreebank, Options op, Index&lt;String&gt; wordIndex, Index&lt;String&gt; tagIndex) {
<span class="nc" id="L186">    System.out.println(&quot;Currently &quot; + new Date());</span>
    //    printOptions(true, op);
<span class="nc" id="L188">    Timing.startTime();</span>
    // setup tree transforms
<span class="nc" id="L190">    TreebankLangParserParams tlpParams = op.tlpParams;</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">    if (op.testOptions.verbose) {</span>
<span class="nc" id="L192">      System.out.print(&quot;Training &quot;);</span>
<span class="nc" id="L193">      System.out.println(trainTreebank.textualSummary());</span>
    }

<span class="nc" id="L196">    System.out.print(&quot;Binarizing trees...&quot;);</span>
    TreeAnnotatorAndBinarizer binarizer; // initialized below
<span class="nc bnc" id="L198" title="All 2 branches missed.">    if (!op.trainOptions.leftToRight) {</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">      binarizer = new TreeAnnotatorAndBinarizer(tlpParams, op.forceCNF, !op.trainOptions.outsideFactor(), true, op);</span>
    } else {
<span class="nc bnc" id="L201" title="All 2 branches missed.">      binarizer = new TreeAnnotatorAndBinarizer(tlpParams.headFinder(), new LeftHeadFinder(), tlpParams, op.forceCNF, !op.trainOptions.outsideFactor(), true, op);</span>
    }
<span class="nc" id="L203">    CollinsPuncTransformer collinsPuncTransformer = null;</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">    if (op.trainOptions.collinsPunc) {</span>
<span class="nc" id="L205">      collinsPuncTransformer = new CollinsPuncTransformer(tlpParams.treebankLanguagePack());</span>
    }
<span class="nc" id="L207">    List&lt;Tree&gt; binaryTrainTrees = new ArrayList&lt;&gt;();</span>
    // List&lt;Tree&gt; binaryTuneTrees = new ArrayList&lt;Tree&gt;();

<span class="nc bnc" id="L210" title="All 2 branches missed.">    if (op.trainOptions.selectiveSplit) {</span>
<span class="nc" id="L211">      op.trainOptions.splitters = ParentAnnotationStats.getSplitCategories(trainTreebank, true, 0, op.trainOptions.selectiveSplitCutOff, op.trainOptions.tagSelectiveSplitCutOff, tlpParams.treebankLanguagePack());</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">      if (op.testOptions.verbose) {</span>
<span class="nc" id="L213">        log.info(&quot;Parent split categories: &quot; + op.trainOptions.splitters);</span>
      }
    }
<span class="nc bnc" id="L216" title="All 2 branches missed.">    if (op.trainOptions.selectivePostSplit) {</span>
<span class="nc" id="L217">      TreeTransformer myTransformer = new TreeAnnotator(tlpParams.headFinder(), tlpParams, op);</span>
<span class="nc" id="L218">      Treebank annotatedTB = trainTreebank.transform(myTransformer);</span>
<span class="nc" id="L219">      op.trainOptions.postSplitters = ParentAnnotationStats.getSplitCategories(annotatedTB, true, 0, op.trainOptions.selectivePostSplitCutOff, op.trainOptions.tagSelectivePostSplitCutOff, tlpParams.treebankLanguagePack());</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">      if (op.testOptions.verbose) {</span>
<span class="nc" id="L221">        log.info(&quot;Parent post annotation split categories: &quot; + op.trainOptions.postSplitters);</span>
      }
    }
<span class="nc bnc" id="L224" title="All 2 branches missed.">    if (op.trainOptions.hSelSplit) {</span>
<span class="nc" id="L225">      binarizer.setDoSelectiveSplit(false);</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">      for (Tree tree : trainTreebank) {</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">        if (op.trainOptions.collinsPunc) {</span>
<span class="nc" id="L228">          tree = collinsPuncTransformer.transformTree(tree);</span>
        }
<span class="nc" id="L230">        tree = binarizer.transformTree(tree);</span>
<span class="nc" id="L231">      }</span>
<span class="nc" id="L232">      binarizer.setDoSelectiveSplit(true);</span>
    }
<span class="nc bnc" id="L234" title="All 2 branches missed.">    for (Tree tree : trainTreebank) {</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">      if (op.trainOptions.collinsPunc) {</span>
<span class="nc" id="L236">        tree = collinsPuncTransformer.transformTree(tree);</span>
      }
<span class="nc" id="L238">      tree = binarizer.transformTree(tree);</span>
<span class="nc" id="L239">      binaryTrainTrees.add(tree);</span>
<span class="nc" id="L240">    }</span>

<span class="nc" id="L242">    Timing.tick(&quot;done.&quot;);</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">    if (op.testOptions.verbose) {</span>
<span class="nc" id="L244">      binarizer.dumpStats();</span>
    }
<span class="nc" id="L246">    System.out.print(&quot;Extracting Lexicon...&quot;);</span>
<span class="nc" id="L247">    ChineseLexiconAndWordSegmenter clex = (ChineseLexiconAndWordSegmenter) op.tlpParams.lex(op, wordIndex, tagIndex);</span>
<span class="nc" id="L248">    clex.initializeTraining(binaryTrainTrees.size());</span>
<span class="nc" id="L249">    clex.train(binaryTrainTrees);</span>
<span class="nc" id="L250">    clex.finishTraining();</span>
<span class="nc" id="L251">    Timing.tick(&quot;done.&quot;);</span>
<span class="nc" id="L252">    return clex;</span>
  }

  private static void printArgs(String[] args, PrintStream ps) {
<span class="nc" id="L256">    ps.print(&quot;ChineseLexiconAndWordSegmenter invoked with arguments:&quot;);</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">    for (String arg : args) {</span>
<span class="nc" id="L258">      ps.print(&quot; &quot; + arg);</span>
    }
<span class="nc" id="L260">    ps.println();</span>
<span class="nc" id="L261">  }</span>

  static void saveSegmenterDataToSerialized(ChineseLexiconAndWordSegmenter cs, String filename) {
    try {
<span class="nc" id="L265">      log.info(&quot;Writing segmenter in serialized format to file &quot; + filename + &quot; &quot;);</span>
<span class="nc" id="L266">      ObjectOutputStream out = IOUtils.writeStreamFromString(filename);</span>

<span class="nc" id="L268">      out.writeObject(cs);</span>
<span class="nc" id="L269">      out.close();</span>
<span class="nc" id="L270">      log.info(&quot;done.&quot;);</span>
<span class="nc" id="L271">    } catch (IOException ioe) {</span>
<span class="nc" id="L272">      ioe.printStackTrace();</span>
<span class="nc" id="L273">    }</span>
<span class="nc" id="L274">  }</span>


  static void saveSegmenterDataToText(ChineseLexiconAndWordSegmenter cs, String filename) {
    try {
<span class="nc" id="L279">      log.info(&quot;Writing parser in text grammar format to file &quot; + filename);</span>
      OutputStream os;
<span class="nc bnc" id="L281" title="All 2 branches missed.">      if (filename.endsWith(&quot;.gz&quot;)) {</span>
        // it's faster to do the buffering _outside_ the gzipping as here
<span class="nc" id="L283">        os = new BufferedOutputStream(new GZIPOutputStream(new FileOutputStream(filename)));</span>
      } else {
<span class="nc" id="L285">        os = new BufferedOutputStream(new FileOutputStream(filename));</span>
      }
<span class="nc" id="L287">      PrintWriter out = new PrintWriter(os);</span>
<span class="nc" id="L288">      String prefix = &quot;BEGIN &quot;;</span>
      //      out.println(prefix + &quot;OPTIONS&quot;);
      //      if (pd.pt != null) {
      //        pd.pt.writeData(out);
      //      }
      //      out.println();
      //      log.info(&quot;.&quot;);
<span class="nc" id="L295">      out.println(prefix + &quot;LEXICON&quot;);</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">      if (cs != null) {</span>
<span class="nc" id="L297">        cs.writeData(out);</span>
      }
<span class="nc" id="L299">      out.println();</span>
<span class="nc" id="L300">      log.info(&quot;.&quot;);</span>
<span class="nc" id="L301">      out.flush();</span>
<span class="nc" id="L302">      out.close();</span>
<span class="nc" id="L303">      log.info(&quot;done.&quot;);</span>
<span class="nc" id="L304">    } catch (IOException e) {</span>
<span class="nc" id="L305">      log.info(&quot;Trouble saving segmenter data to ASCII format.&quot;);</span>
<span class="nc" id="L306">      e.printStackTrace();</span>
<span class="nc" id="L307">    }</span>
<span class="nc" id="L308">  }</span>

  private static Treebank makeTreebank(String treebankPath, Options op, FileFilter filt) {
<span class="nc" id="L311">    log.info(&quot;Training a segmenter from treebank dir: &quot; + treebankPath);</span>
<span class="nc" id="L312">    Treebank trainTreebank = op.tlpParams.memoryTreebank();</span>
<span class="nc" id="L313">    log.info(&quot;Reading trees...&quot;);</span>
<span class="nc bnc" id="L314" title="All 2 branches missed.">    if (filt == null) {</span>
<span class="nc" id="L315">      trainTreebank.loadPath(treebankPath);</span>
    } else {
<span class="nc" id="L317">      trainTreebank.loadPath(treebankPath, filt);</span>
    }

<span class="nc" id="L320">    Timing.tick(&quot;done [read &quot; + trainTreebank.size() + &quot; trees].&quot;);</span>
<span class="nc" id="L321">    return trainTreebank;</span>
  }

  /**
   * Construct a new ChineseLexiconAndWordSegmenter.  This loads a segmenter file that
   * was previously assembled and stored.
   *
   * @throws IllegalArgumentException If segmenter data cannot be loaded
   */
<span class="nc" id="L330">  public ChineseLexiconAndWordSegmenter(String segmenterFileOrUrl, Options op) {</span>
<span class="nc" id="L331">    ChineseLexiconAndWordSegmenter cs = getSegmenterDataFromFile(segmenterFileOrUrl, op);</span>
<span class="nc" id="L332">    this.op = cs.op; // in case a serialized options was read in</span>
<span class="nc" id="L333">    chineseLexicon = cs.chineseLexicon;</span>
<span class="nc" id="L334">    wordSegmenter = cs.wordSegmenter;</span>
<span class="nc" id="L335">  }</span>

  public static ChineseLexiconAndWordSegmenter getSegmenterDataFromFile(String parserFileOrUrl, Options op) {
<span class="nc" id="L338">    ChineseLexiconAndWordSegmenter cs = getSegmenterDataFromSerializedFile(parserFileOrUrl);</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">    if (cs == null) {</span>
//      pd = getSegmenterDataFromTextFile(parserFileOrUrl, op);
    }
<span class="nc" id="L342">    return cs;</span>
  }

  protected static ChineseLexiconAndWordSegmenter getSegmenterDataFromSerializedFile(String serializedFileOrUrl) {
<span class="nc" id="L346">    ChineseLexiconAndWordSegmenter cs = null;</span>
    try {
<span class="nc" id="L348">      log.info(&quot;Loading segmenter from serialized file &quot; + serializedFileOrUrl + &quot; ...&quot;);</span>
      ObjectInputStream in;
      InputStream is;
<span class="nc bnc" id="L351" title="All 2 branches missed.">      if (serializedFileOrUrl.startsWith(&quot;http://&quot;)) {</span>
<span class="nc" id="L352">        URL u = new URL(serializedFileOrUrl);</span>
<span class="nc" id="L353">        URLConnection uc = u.openConnection();</span>
<span class="nc" id="L354">        is = uc.getInputStream();</span>
<span class="nc" id="L355">      } else {</span>
<span class="nc" id="L356">        is = new FileInputStream(serializedFileOrUrl);</span>
      }
<span class="nc bnc" id="L358" title="All 2 branches missed.">      if (serializedFileOrUrl.endsWith(&quot;.gz&quot;)) {</span>
        // it's faster to do the buffering _outside_ the gzipping as here
<span class="nc" id="L360">        in = new ObjectInputStream(new BufferedInputStream(new GZIPInputStream(is)));</span>
      } else {
<span class="nc" id="L362">        in = new ObjectInputStream(new BufferedInputStream(is));</span>
      }
<span class="nc" id="L364">      cs = (ChineseLexiconAndWordSegmenter) in.readObject();</span>
<span class="nc" id="L365">      in.close();</span>
<span class="nc" id="L366">      log.info(&quot; done.&quot;);</span>
<span class="nc" id="L367">      return cs;</span>
<span class="nc" id="L368">    } catch (InvalidClassException ice) {</span>
      // For this, it's not a good idea to continue and try it as a text file!
<span class="nc" id="L370">      log.info();   // as in middle of line from above message</span>
<span class="nc" id="L371">      throw new RuntimeException(ice);</span>
<span class="nc" id="L372">    } catch (FileNotFoundException fnfe) {</span>
      // For this, it's not a good idea to continue and try it as a text file!
<span class="nc" id="L374">      log.info();   // as in middle of line from above message</span>
<span class="nc" id="L375">      throw new RuntimeException(fnfe);</span>
<span class="nc" id="L376">    } catch (StreamCorruptedException sce) {</span>
      // suppress error message, on the assumption that we've really got
      // a text grammar, and that'll be tried next
<span class="nc" id="L379">    } catch (Exception e) {</span>
<span class="nc" id="L380">      log.info();   // as in middle of line from above message</span>
<span class="nc" id="L381">      e.printStackTrace();</span>
<span class="nc" id="L382">    }</span>
<span class="nc" id="L383">    return null;</span>
  }

  /** This method lets you train and test a segmenter relative to a
   *  Treebank.
   *  &lt;p&gt;
   *  &lt;i&gt;Implementation note:&lt;/i&gt; This method is largely cloned from
   *  LexicalizedParser's main method.  Should we try to have it be able
   *  to train segmenters to stop things going out of sync?
   */
  public static void main(String[] args) {
<span class="nc" id="L394">    boolean train = false;</span>
<span class="nc" id="L395">    boolean saveToSerializedFile = false;</span>
<span class="nc" id="L396">    boolean saveToTextFile = false;</span>
<span class="nc" id="L397">    String serializedInputFileOrUrl = null;</span>
<span class="nc" id="L398">    String textInputFileOrUrl = null;</span>
<span class="nc" id="L399">    String serializedOutputFileOrUrl = null;</span>
<span class="nc" id="L400">    String textOutputFileOrUrl = null;</span>
<span class="nc" id="L401">    String treebankPath = null;</span>
<span class="nc" id="L402">    Treebank testTreebank = null;</span>
    // Treebank tuneTreebank = null;
<span class="nc" id="L404">    String testPath = null;</span>
<span class="nc" id="L405">    FileFilter testFilter = null;</span>
<span class="nc" id="L406">    FileFilter trainFilter = null;</span>
<span class="nc" id="L407">    String encoding = null;</span>

    // variables needed to process the files to be parsed
<span class="nc" id="L410">    TokenizerFactory&lt;Word&gt; tokenizerFactory = null;</span>
//    DocumentPreprocessor documentPreprocessor = new DocumentPreprocessor();
<span class="nc" id="L412">    boolean tokenized = false; // whether or not the input file has already been tokenized</span>
<span class="nc" id="L413">    Function&lt;List&lt;HasWord&gt;, List&lt;HasWord&gt;&gt; escaper = new ChineseEscaper();</span>
    // int tagDelimiter = -1;
    // String sentenceDelimiter = &quot;\n&quot;;
    // boolean fromXML = false;
<span class="nc" id="L417">    int argIndex = 0;</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">    if (args.length &lt; 1) {</span>
<span class="nc" id="L419">      log.info(&quot;usage: java edu.stanford.nlp.parser.lexparser.&quot; +</span>
                         &quot;LexicalizedParser parserFileOrUrl filename*&quot;);
<span class="nc" id="L421">      return;</span>
    }

<span class="nc" id="L424">    Options op = new Options();</span>
<span class="nc" id="L425">    op.tlpParams = new ChineseTreebankParserParams();</span>

    // while loop through option arguments
<span class="nc bnc" id="L428" title="All 4 branches missed.">    while (argIndex &lt; args.length &amp;&amp; args[argIndex].charAt(0) == '-') {</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">      if (args[argIndex].equalsIgnoreCase(&quot;-train&quot;)) {</span>
<span class="nc" id="L430">        train = true;</span>
<span class="nc" id="L431">        saveToSerializedFile = true;</span>
<span class="nc" id="L432">        int numSubArgs = numSubArgs(args, argIndex);</span>
<span class="nc" id="L433">        argIndex++;</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">        if (numSubArgs &gt; 1) {</span>
<span class="nc" id="L435">          treebankPath = args[argIndex];</span>
<span class="nc" id="L436">          argIndex++;</span>
        } else {
<span class="nc" id="L438">          throw new RuntimeException(&quot;Error: -train option must have treebankPath as first argument.&quot;);</span>
        }
<span class="nc bnc" id="L440" title="All 2 branches missed.">        if (numSubArgs == 2) {</span>
<span class="nc" id="L441">          trainFilter = new NumberRangesFileFilter(args[argIndex++], true);</span>
<span class="nc bnc" id="L442" title="All 2 branches missed.">        } else if (numSubArgs &gt;= 3) {</span>
          try {
<span class="nc" id="L444">            int low = Integer.parseInt(args[argIndex]);</span>
<span class="nc" id="L445">            int high = Integer.parseInt(args[argIndex + 1]);</span>
<span class="nc" id="L446">            trainFilter = new NumberRangeFileFilter(low, high, true);</span>
<span class="nc" id="L447">            argIndex += 2;</span>
<span class="nc" id="L448">          } catch (NumberFormatException e) {</span>
            // maybe it's a ranges expression?
<span class="nc" id="L450">            trainFilter = new NumberRangesFileFilter(args[argIndex], true);</span>
<span class="nc" id="L451">            argIndex++;</span>
<span class="nc" id="L452">          }</span>
        }
<span class="nc bnc" id="L454" title="All 2 branches missed.">      } else if (args[argIndex].equalsIgnoreCase(&quot;-encoding&quot;)) { // sets encoding for TreebankLangParserParams</span>
<span class="nc" id="L455">        encoding = args[argIndex + 1];</span>
<span class="nc" id="L456">        op.tlpParams.setInputEncoding(encoding);</span>
<span class="nc" id="L457">        op.tlpParams.setOutputEncoding(encoding);</span>
<span class="nc" id="L458">        argIndex += 2;</span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">      } else if (args[argIndex].equalsIgnoreCase(&quot;-loadFromSerializedFile&quot;)) {</span>
        // load the parser from a binary serialized file
        // the next argument must be the path to the parser file
<span class="nc" id="L462">        serializedInputFileOrUrl = args[argIndex + 1];</span>
<span class="nc" id="L463">        argIndex += 2;</span>
        // doesn't make sense to load from TextFile -pichuan
        //      } else if (args[argIndex].equalsIgnoreCase(&quot;-loadFromTextFile&quot;)) {
        //        // load the parser from declarative text file
        //        // the next argument must be the path to the parser file
        //        textInputFileOrUrl = args[argIndex + 1];
        //        argIndex += 2;
<span class="nc bnc" id="L470" title="All 2 branches missed.">      } else if (args[argIndex].equalsIgnoreCase(&quot;-saveToSerializedFile&quot;)) {</span>
<span class="nc" id="L471">        saveToSerializedFile = true;</span>
<span class="nc" id="L472">        serializedOutputFileOrUrl = args[argIndex + 1];</span>
<span class="nc" id="L473">        argIndex += 2;</span>
<span class="nc bnc" id="L474" title="All 2 branches missed.">      } else if (args[argIndex].equalsIgnoreCase(&quot;-saveToTextFile&quot;)) {</span>
        // save the parser to declarative text file
<span class="nc" id="L476">        saveToTextFile = true;</span>
<span class="nc" id="L477">        textOutputFileOrUrl = args[argIndex + 1];</span>
<span class="nc" id="L478">        argIndex += 2;</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">      } else if (args[argIndex].equalsIgnoreCase(&quot;-treebank&quot;)) {</span>
        // the next argument is the treebank path and range for testing
<span class="nc" id="L481">        int numSubArgs = numSubArgs(args, argIndex);</span>
<span class="nc" id="L482">        argIndex++;</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">        if (numSubArgs == 1) {</span>
<span class="nc" id="L484">          testFilter = new NumberRangesFileFilter(args[argIndex++], true);</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">        } else if (numSubArgs &gt; 1) {</span>
<span class="nc" id="L486">          testPath = args[argIndex++];</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">          if (numSubArgs == 2) {</span>
<span class="nc" id="L488">            testFilter = new NumberRangesFileFilter(args[argIndex++], true);</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">          } else if (numSubArgs &gt;= 3) {</span>
            try {
<span class="nc" id="L491">              int low = Integer.parseInt(args[argIndex]);</span>
<span class="nc" id="L492">              int high = Integer.parseInt(args[argIndex + 1]);</span>
<span class="nc" id="L493">              testFilter = new NumberRangeFileFilter(low, high, true);</span>
<span class="nc" id="L494">              argIndex += 2;</span>
<span class="nc" id="L495">            } catch (NumberFormatException e) {</span>
              // maybe it's a ranges expression?
<span class="nc" id="L497">              testFilter = new NumberRangesFileFilter(args[argIndex++], true);</span>
<span class="nc" id="L498">            }</span>
          }
        }
<span class="nc" id="L501">      } else {</span>
<span class="nc" id="L502">        int j = op.tlpParams.setOptionFlag(args, argIndex);</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">        if (j == argIndex) {</span>
<span class="nc" id="L504">          log.info(&quot;Unknown option ignored: &quot; + args[argIndex]);</span>
<span class="nc" id="L505">          j++;</span>
        }
<span class="nc" id="L507">        argIndex = j;</span>
<span class="nc" id="L508">      }</span>
    } // end while loop through arguments

<span class="nc" id="L511">    TreebankLangParserParams tlpParams = op.tlpParams;</span>

    // all other arguments are order dependent and
    // are processed in order below

<span class="nc" id="L516">    ChineseLexiconAndWordSegmenter cs = null;</span>
<span class="nc bnc" id="L517" title="All 4 branches missed.">    if (!train &amp;&amp; op.testOptions.verbose) {</span>
<span class="nc" id="L518">      System.out.println(&quot;Currently &quot; + new Date());</span>
<span class="nc" id="L519">      printArgs(args, System.out);</span>
    }
<span class="nc bnc" id="L521" title="All 2 branches missed.">    if (train) {</span>
<span class="nc" id="L522">      printArgs(args, System.out);</span>
      // so we train a parser using the treebank
<span class="nc bnc" id="L524" title="All 2 branches missed.">      if (treebankPath == null) {</span>
        // the next arg must be the treebank path, since it wasn't give earlier
<span class="nc" id="L526">        treebankPath = args[argIndex];</span>
<span class="nc" id="L527">        argIndex++;</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">        if (args.length &gt; argIndex + 1) {</span>
          try {
            // the next two args might be the range
<span class="nc" id="L531">            int low = Integer.parseInt(args[argIndex]);</span>
<span class="nc" id="L532">            int high = Integer.parseInt(args[argIndex + 1]);</span>
<span class="nc" id="L533">            trainFilter = new NumberRangeFileFilter(low, high, true);</span>
<span class="nc" id="L534">            argIndex += 2;</span>
<span class="nc" id="L535">          } catch (NumberFormatException e) {</span>
            // maybe it's a ranges expression?
<span class="nc" id="L537">            trainFilter = new NumberRangesFileFilter(args[argIndex], true);</span>
<span class="nc" id="L538">            argIndex++;</span>
<span class="nc" id="L539">          }</span>
        }
      }
<span class="nc" id="L542">      Treebank trainTreebank = makeTreebank(treebankPath, op, trainFilter);</span>
<span class="nc" id="L543">      Index&lt;String&gt; wordIndex = new HashIndex&lt;&gt;();</span>
<span class="nc" id="L544">      Index&lt;String&gt; tagIndex = new HashIndex&lt;&gt;();</span>
<span class="nc" id="L545">      cs = new ChineseLexiconAndWordSegmenter(trainTreebank, op, wordIndex, tagIndex);</span>
<span class="nc bnc" id="L546" title="All 2 branches missed.">    } else if (textInputFileOrUrl != null) {</span>
      // so we load the segmenter from a text grammar file
      // XXXXX fix later -pichuan
      //cs = new LexicalizedParser(textInputFileOrUrl, true, op);
    } else {
      // so we load a serialized segmenter
<span class="nc bnc" id="L552" title="All 2 branches missed.">      if (serializedInputFileOrUrl == null) {</span>
        // the next argument must be the path to the serialized parser
<span class="nc" id="L554">        serializedInputFileOrUrl = args[argIndex];</span>
<span class="nc" id="L555">        argIndex++;</span>
      }
      try {
<span class="nc" id="L558">        cs = new ChineseLexiconAndWordSegmenter(serializedInputFileOrUrl, op);</span>
<span class="nc" id="L559">      } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L560">        log.info(&quot;Error loading segmenter, exiting...&quot;);</span>
<span class="nc" id="L561">        System.exit(0);</span>
<span class="nc" id="L562">      }</span>
    }

    // the following has to go after reading parser to make sure
    // op and tlpParams are the same for train and test
<span class="nc" id="L567">    TreePrint treePrint = op.testOptions.treePrint(tlpParams);</span>

<span class="nc bnc" id="L569" title="All 2 branches missed.">    if (testFilter != null) {</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">      if (testPath == null) {</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">        if (treebankPath == null) {</span>
<span class="nc" id="L572">          throw new RuntimeException(&quot;No test treebank path specified...&quot;);</span>
        } else {
<span class="nc" id="L574">          log.info(&quot;No test treebank path specified.  Using train path: \&quot;&quot; + treebankPath + &quot;\&quot;&quot;);</span>
<span class="nc" id="L575">          testPath = treebankPath;</span>
        }
      }
<span class="nc" id="L578">      testTreebank = tlpParams.testMemoryTreebank();</span>
<span class="nc" id="L579">      testTreebank.loadPath(testPath, testFilter);</span>
    }

<span class="nc" id="L582">    op.trainOptions.sisterSplitters = Generics.newHashSet(Arrays.asList(tlpParams.sisterSplitters()));</span>

    // at this point we should be sure that op.tlpParams is
    // set appropriately (from command line, or from grammar file),
    // and will never change again.  We also set the tlpParams of the
    // LexicalizedParser instance to be the same object.  This is
    // redundancy that we probably should take out eventually.
    //
    // -- Roger
<span class="nc bnc" id="L591" title="All 2 branches missed.">    if (op.testOptions.verbose) {</span>
<span class="nc" id="L592">      log.info(&quot;Lexicon is &quot; + cs.getClass().getName());</span>
    }

<span class="nc" id="L595">    PrintWriter pwOut = tlpParams.pw();</span>
<span class="nc" id="L596">    PrintWriter pwErr = tlpParams.pw(System.err);</span>


    // Now what do we do with the parser we've made
<span class="nc bnc" id="L600" title="All 2 branches missed.">    if (saveToTextFile) {</span>
      // save the parser to textGrammar format
<span class="nc bnc" id="L602" title="All 2 branches missed.">      if (textOutputFileOrUrl != null) {</span>
<span class="nc" id="L603">        saveSegmenterDataToText(cs, textOutputFileOrUrl);</span>
      } else {
<span class="nc" id="L605">        log.info(&quot;Usage: must specify a text segmenter data output path&quot;);</span>
      }
    }
<span class="nc bnc" id="L608" title="All 2 branches missed.">    if (saveToSerializedFile) {</span>
<span class="nc bnc" id="L609" title="All 4 branches missed.">      if (serializedOutputFileOrUrl == null &amp;&amp; argIndex &lt; args.length) {</span>
        // the next argument must be the path to serialize to
<span class="nc" id="L611">        serializedOutputFileOrUrl = args[argIndex];</span>
<span class="nc" id="L612">        argIndex++;</span>
      }
<span class="nc bnc" id="L614" title="All 2 branches missed.">      if (serializedOutputFileOrUrl != null) {</span>
<span class="nc" id="L615">        saveSegmenterDataToSerialized(cs, serializedOutputFileOrUrl);</span>
<span class="nc bnc" id="L616" title="All 4 branches missed.">      } else if (textOutputFileOrUrl == null &amp;&amp; testTreebank == null) {</span>
        // no saving/parsing request has been specified
<span class="nc" id="L618">        log.info(&quot;usage: &quot; + &quot;java edu.stanford.nlp.parser.lexparser.ChineseLexiconAndWordSegmenter&quot; + &quot;-train trainFilesPath [start stop] serializedParserFilename&quot;);</span>
      }
    }
    /* --------------------- Testing part!!!! ----------------------- */
<span class="nc bnc" id="L622" title="All 2 branches missed.">    if (op.testOptions.verbose) {</span>
//      printOptions(false, op);
    }
<span class="nc bnc" id="L625" title="All 6 branches missed.">    if (testTreebank != null || (argIndex &lt; args.length &amp;&amp; args[argIndex].equalsIgnoreCase(&quot;-treebank&quot;))) {</span>
      // test parser on treebank
<span class="nc bnc" id="L627" title="All 2 branches missed.">      if (testTreebank == null) {</span>
        // the next argument is the treebank path and range for testing
<span class="nc" id="L629">        testTreebank = tlpParams.testMemoryTreebank();</span>
<span class="nc bnc" id="L630" title="All 2 branches missed.">        if (args.length &lt; argIndex + 4) {</span>
<span class="nc" id="L631">          testTreebank.loadPath(args[argIndex + 1]);</span>
        } else {
<span class="nc" id="L633">          int testlow = Integer.parseInt(args[argIndex + 2]);</span>
<span class="nc" id="L634">          int testhigh = Integer.parseInt(args[argIndex + 3]);</span>
<span class="nc" id="L635">          testTreebank.loadPath(args[argIndex + 1], new NumberRangeFileFilter(testlow, testhigh, true));</span>
        }
      }
      /* TODO - test segmenting on treebank. -pichuan */
//      lp.testOnTreebank(testTreebank);
//    } else if (argIndex &gt;= args.length) {
//      // no more arguments, so we just parse our own test sentence
//      if (lp.parse(op.tlpParams.defaultTestSentence())) {
//        treePrint.printTree(lp.getBestParse(), pwOut);
//      } else {
//        pwErr.println(&quot;Error. Can't parse test sentence: &quot; +
//              lp.parse(op.tlpParams.defaultTestSentence()));
//      }
    }
//wsg2010: This code block doesn't actually do anything. It appears to read and tokenize a file, and then just print it.
//         There are easier ways to do that. This code was copied from an old version of LexicalizedParser.
//    else {
//      // We parse filenames given by the remaining arguments
//      int numWords = 0;
//      Timing timer = new Timing();
//      // set the tokenizer
//      if (tokenized) {
//        tokenizerFactory = WhitespaceTokenizer.factory();
//      }
//      TreebankLanguagePack tlp = tlpParams.treebankLanguagePack();
//      if (tokenizerFactory == null) {
//        tokenizerFactory = (TokenizerFactory&lt;Word&gt;) tlp.getTokenizerFactory();
//      }
//      documentPreprocessor.setTokenizerFactory(tokenizerFactory);
//      documentPreprocessor.setSentenceFinalPuncWords(tlp.sentenceFinalPunctuationWords());
//      if (encoding != null) {
//        documentPreprocessor.setEncoding(encoding);
//      }
//      timer.start();
//      for (int i = argIndex; i &lt; args.length; i++) {
//        String filename = args[i];
//        try {
//          List document = null;
//          if (fromXML) {
//            document = documentPreprocessor.getSentencesFromXML(filename, sentenceDelimiter, tokenized);
//          } else {
//            document = documentPreprocessor.getSentencesFromText(filename, escaper, sentenceDelimiter, tagDelimiter);
//          }
//          log.info(&quot;Segmenting file: &quot; + filename + &quot; with &quot; + document.size() + &quot; sentences.&quot;);
//          PrintWriter pwo = pwOut;
//          if (op.testOptions.writeOutputFiles) {
//            try {
//              pwo = tlpParams.pw(new FileOutputStream(filename + &quot;.stp&quot;));
//            } catch (IOException ioe) {
//              ioe.printStackTrace();
//            }
//          }
//          int num = 0;
//          treePrint.printHeader(pwo, tlp.getEncoding());
//          for (Iterator it = document.iterator(); it.hasNext();) {
//            num++;
//            List sentence = (List) it.next();
//            int len = sentence.size();
//            numWords += len;
////            pwErr.println(&quot;Parsing [sent. &quot; + num + &quot; len. &quot; + len + &quot;]: &quot; + sentence);
//            pwo.println(Sentence.listToString(sentence));
//          }
//          treePrint.printFooter(pwo);
//          if (op.testOptions.writeOutputFiles) {
//            pwo.close();
//          }
//        } catch (IOException e) {
//          pwErr.println(&quot;Couldn't find file: &quot; + filename);
//        }
//
//      } // end for each file
//      long millis = timer.stop();
//      double wordspersec = numWords / (((double) millis) / 1000);
//      NumberFormat nf = new DecimalFormat(&quot;0.00&quot;); // easier way!
//      pwErr.println(&quot;Segmented &quot; + numWords + &quot; words at &quot; + nf.format(wordspersec) + &quot; words per second.&quot;);
//    }
<span class="nc" id="L711">  }</span>

  private static final long serialVersionUID = -6554995189795187918L;


  @Override
  public UnknownWordModel getUnknownWordModel() {
<span class="nc" id="L718">    return chineseLexicon.getUnknownWordModel();</span>
  }

  @Override
  public void setUnknownWordModel(UnknownWordModel uwm) {
<span class="nc" id="L723">    chineseLexicon.setUnknownWordModel(uwm);</span>
<span class="nc" id="L724">  }</span>

  @Override
  public void train(Collection&lt;Tree&gt; trees, Collection&lt;Tree&gt; rawTrees) {
<span class="nc" id="L728">    train(trees);</span>

<span class="nc" id="L730">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>