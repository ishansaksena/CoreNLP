<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ChineseTreebankParserParams.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.parser.lexparser</a> &gt; <span class="el_source">ChineseTreebankParserParams.java</span></div><h1>ChineseTreebankParserParams.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.parser.lexparser; 
import edu.stanford.nlp.util.logging.Redwood;

import edu.stanford.nlp.io.EncodingPrintWriter;
import edu.stanford.nlp.io.NumberRangesFileFilter;
import edu.stanford.nlp.io.RuntimeIOException;
import edu.stanford.nlp.ling.CategoryWordTag;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.ling.Label;
import edu.stanford.nlp.ling.SentenceUtils;
import edu.stanford.nlp.ling.Word;
import edu.stanford.nlp.process.WordSegmenter;
import edu.stanford.nlp.process.WordSegmentingTokenizer;
import edu.stanford.nlp.trees.*;
import edu.stanford.nlp.trees.international.pennchinese.*;
import java.util.function.Predicate;
import edu.stanford.nlp.util.Index;
import edu.stanford.nlp.util.ReflectionLoading;
import edu.stanford.nlp.util.StringUtils;

import java.io.IOException;
import java.util.*;


/**
 * Parameter file for parsing the Penn Chinese Treebank.  Includes
 * category enrichments specific to the Penn Chinese Treebank.
 *
 * @author Roger Levy
 * @author Christopher Manning
 * @author Galen Andrew
 */

public class ChineseTreebankParserParams extends AbstractTreebankParserParams  {

  /** A logger for this class */
<span class="fc" id="L37">  private static Redwood.RedwoodChannels log = Redwood.channels(ChineseTreebankParserParams.class);</span>

  /**
   * The variable ctlp stores the same thing as the tlp variable in
   * AbstractTreebankParserParams, but pre-cast to be a
   * ChineseTreebankLanguagePack.
   * todo [cdm 2013]: Just change to method that casts
   */
  private ChineseTreebankLanguagePack ctlp;
<span class="fc" id="L46">  public boolean charTags = false;</span>
<span class="fc" id="L47">  public boolean useCharacterBasedLexicon = false;</span>
<span class="fc" id="L48">  public boolean useMaxentLexicon = false;</span>
<span class="fc" id="L49">  public boolean useMaxentDepGrammar = false;</span>
<span class="fc" id="L50">  public boolean segment = false;</span>
<span class="fc" id="L51">  public boolean segmentMarkov = false;</span>
<span class="fc" id="L52">  public boolean sunJurafskyHeadFinder = false;</span>
<span class="fc" id="L53">  public boolean bikelHeadFinder = false;</span>
<span class="fc" id="L54">  public boolean discardFrags = false;</span>
<span class="fc" id="L55">  public boolean useSimilarWordMap = false;</span>

<span class="fc" id="L57">  public String segmenterClass = null;</span>

  private Lexicon lex;
  private WordSegmenter segmenter;
<span class="fc" id="L61">  private HeadFinder headFinder = null;</span>

  private static void printlnErr(String s) {
<span class="nc" id="L64">    EncodingPrintWriter.err.println(s, ChineseTreebankLanguagePack.ENCODING);</span>
<span class="nc" id="L65">  }</span>

  public ChineseTreebankParserParams() {
<span class="fc" id="L68">    super(new ChineseTreebankLanguagePack());</span>
<span class="fc" id="L69">    ctlp = (ChineseTreebankLanguagePack) super.treebankLanguagePack();</span>
<span class="fc" id="L70">  }</span>

  /**
   * Returns a ChineseHeadFinder
   */
  @Override
  public HeadFinder headFinder() {
<span class="nc bnc" id="L77" title="All 2 branches missed.">    if(headFinder == null) {</span>
<span class="nc bnc" id="L78" title="All 2 branches missed.">      if (sunJurafskyHeadFinder) {</span>
<span class="nc" id="L79">        return new SunJurafskyChineseHeadFinder();</span>
<span class="nc bnc" id="L80" title="All 2 branches missed.">      } else if (bikelHeadFinder) {</span>
<span class="nc" id="L81">        return new BikelChineseHeadFinder();</span>
      } else {
<span class="nc" id="L83">        return new ChineseHeadFinder();</span>
      }
    } else
<span class="nc" id="L86">      return headFinder;</span>
  }

  @Override
  public HeadFinder typedDependencyHeadFinder() {
<span class="nc bnc" id="L91" title="All 2 branches missed.">    if (this.generateOriginalDependencies()) {</span>
<span class="nc" id="L92">      return new ChineseSemanticHeadFinder();</span>
    } else {
<span class="nc" id="L94">      return new UniversalChineseSemanticHeadFinder();</span>
    }

  }

  /**
   * Returns a ChineseLexicon
   */
  @Override
  public Lexicon lex(Options op, Index&lt;String&gt; wordIndex, Index&lt;String&gt; tagIndex) {
<span class="nc bnc" id="L104" title="All 2 branches missed.">    if (useCharacterBasedLexicon) {</span>
<span class="nc" id="L105">      return lex = new ChineseCharacterBasedLexicon(this, wordIndex, tagIndex);</span>
    // } else if (useMaxentLexicon) {
    // return lex = new ChineseMaxentLexicon();
    }
<span class="nc bnc" id="L109" title="All 2 branches missed.">    if (op.lexOptions.uwModelTrainer == null) {</span>
<span class="nc" id="L110">      op.lexOptions.uwModelTrainer = &quot;edu.stanford.nlp.parser.lexparser.ChineseUnknownWordModelTrainer&quot;;</span>
    }
<span class="nc bnc" id="L112" title="All 2 branches missed.">    if (segmenterClass != null) {</span>
      try {
<span class="nc" id="L114">        segmenter = ReflectionLoading.loadByReflection(segmenterClass, this,</span>
                                                       wordIndex, tagIndex);
<span class="nc" id="L116">      } catch (ReflectionLoading.ReflectionLoadingException e) {</span>
<span class="nc" id="L117">        segmenter = ReflectionLoading.loadByReflection(segmenterClass);</span>
<span class="nc" id="L118">      }</span>
    }

<span class="nc" id="L121">    ChineseLexicon clex = new ChineseLexicon(op, this, wordIndex, tagIndex);</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">    if (segmenter != null) {</span>
<span class="nc" id="L123">      lex = new ChineseLexiconAndWordSegmenter(clex, segmenter);</span>
<span class="nc" id="L124">      ctlp.setTokenizerFactory(WordSegmentingTokenizer.factory(segmenter));</span>
    } else {
<span class="nc" id="L126">      lex = clex;</span>
    }

<span class="nc" id="L129">    return lex;</span>
  }

  @Override
  public double[] MLEDependencyGrammarSmoothingParams() {
<span class="nc" id="L134">    return new double[]{5.8, 17.7, 6.5, 0.4};</span>
  }

  @Override
  public TreeReaderFactory treeReaderFactory() {
<span class="nc" id="L139">    final TreeNormalizer tn = new CTBErrorCorrectingTreeNormalizer(splitNPTMP, splitPPTMP, splitXPTMP, charTags);</span>
<span class="nc" id="L140">    return new CTBTreeReaderFactory(tn, discardFrags);</span>
  }

  /**
   * Uses a DiskTreebank with a CHTBTokenizer and a
   * BobChrisTreeNormalizer.
   */
  @Override
  public DiskTreebank diskTreebank() {
<span class="nc" id="L149">    String encoding = inputEncoding;</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">    if (!java.nio.charset.Charset.isSupported(encoding)) {</span>
<span class="nc" id="L151">      printlnErr(&quot;Warning: desired encoding &quot; + encoding + &quot; not accepted. &quot;);</span>
<span class="nc" id="L152">      printlnErr(&quot;Using UTF-8 to construct DiskTreebank&quot;);</span>
<span class="nc" id="L153">      encoding = &quot;UTF-8&quot;;</span>
    }

<span class="nc" id="L156">    return new DiskTreebank(treeReaderFactory(), encoding);</span>
  }


  /**
   * Uses a MemoryTreebank with a CHTBTokenizer and a
   * BobChrisTreeNormalizer
   */
  @Override
  public MemoryTreebank memoryTreebank() {
<span class="nc" id="L166">    String encoding = inputEncoding;</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">    if (!java.nio.charset.Charset.isSupported(encoding)) {</span>
<span class="nc" id="L168">      System.out.println(&quot;Warning: desired encoding &quot; + encoding + &quot; not accepted. &quot;);</span>
<span class="nc" id="L169">      System.out.println(&quot;Using UTF-8 to construct MemoryTreebank&quot;);</span>
<span class="nc" id="L170">      encoding = &quot;UTF-8&quot;;</span>
    }

<span class="nc" id="L173">    return new MemoryTreebank(treeReaderFactory(), encoding);</span>
  }


  /**
   * Returns a ChineseCollinizer
   */
  @Override
  public TreeTransformer collinizer() {
<span class="nc" id="L182">    return new ChineseCollinizer(ctlp);</span>
  }

  /**
   * Returns a ChineseCollinizer that doesn't delete punctuation
   */
  @Override
  public TreeTransformer collinizerEvalb() {
<span class="nc" id="L190">    return new ChineseCollinizer(ctlp, false);</span>
  }

  //   /** Returns a &lt;code&gt;ChineseTreebankLanguagePack&lt;/code&gt; */
  //   public TreebankLanguagePack treebankLanguagePack() {
  //     return new ChineseTreebankLanguagePack();
  //   }


  /* --------- not used now
    // Automatically generated by ParentAnnotationStats -- preferably don't edit
    private static final String[] splitters1 = new String[] {&quot;VA^VCD&quot;, &quot;NP^NP&quot;, &quot;NP^VP&quot;, &quot;NP^IP&quot;, &quot;NP^DNP&quot;, &quot;NP^PP&quot;, &quot;NP^LCP&quot;, &quot;NP^PRN&quot;, &quot;NP^QP&quot;, &quot;PP^IP&quot;, &quot;PP^NP&quot;, &quot;NN^FRAG&quot;, &quot;NN^NP&quot;, &quot;NT^FRAG&quot;, &quot;NT^NP&quot;, &quot;NR^FRAG&quot;, &quot;NR^NP&quot;, &quot;VV^FRAG&quot;, &quot;VV^VRD&quot;, &quot;VV^VCD&quot;, &quot;VV^VP&quot;, &quot;VV^VSB&quot;, &quot;VP^VP&quot;, &quot;VP^IP&quot;, &quot;VP^DVP&quot;, &quot;IP^ROOT&quot;, &quot;IP^IP&quot;, &quot;IP^CP&quot;, &quot;IP^VP&quot;, &quot;IP^PP&quot;, &quot;IP^NP&quot;, &quot;IP^LCP&quot;, &quot;CP^IP&quot;, &quot;QP^NP&quot;, &quot;QP^PP&quot;, &quot;QP^VP&quot;, &quot;ADVP^CP&quot;, &quot;CC^VP&quot;, &quot;CC^NP&quot;, &quot;CC^IP&quot;, &quot;CC^QP&quot;, &quot;PU^NP&quot;, &quot;PU^FRAG&quot;, &quot;PU^IP&quot;, &quot;PU^VP&quot;, &quot;PU^PRN&quot;, &quot;PU^QP&quot;, &quot;PU^LST&quot;, &quot;NP^DNP~QP&quot;, &quot;NT^NP~NP&quot;, &quot;NT^NP~VP&quot;, &quot;NT^NP~IP&quot;, &quot;NT^NP~LCP&quot;, &quot;NT^NP~PP&quot;, &quot;NT^NP~PRN&quot;, &quot;NT^NP~QP&quot;, &quot;NT^NP~DNP&quot;, &quot;NP^NP~VP&quot;, &quot;NP^NP~NP&quot;, &quot;NP^NP~IP&quot;, &quot;NP^NP~PP&quot;, &quot;NP^NP~DNP&quot;, &quot;NP^NP~LCP&quot;, &quot;NN^NP~VP&quot;, &quot;NN^NP~IP&quot;, &quot;NN^NP~NP&quot;, &quot;NN^NP~PP&quot;, &quot;NN^NP~DNP&quot;, &quot;NN^NP~LCP&quot;, &quot;NN^NP~UCP&quot;, &quot;NN^NP~QP&quot;, &quot;NN^NP~PRN&quot;, &quot;M^CLP~DP&quot;, &quot;M^CLP~QP&quot;, &quot;M^CLP~NP&quot;, &quot;M^CLP~CLP&quot;, &quot;CD^QP~VP&quot;, &quot;CD^QP~NP&quot;, &quot;CD^QP~QP&quot;, &quot;CD^QP~LCP&quot;, &quot;CD^QP~PP&quot;, &quot;CD^QP~DNP&quot;, &quot;CD^QP~DP&quot;, &quot;CD^QP~IP&quot;, &quot;IP^IP~IP&quot;, &quot;IP^IP~ROOT&quot;, &quot;IP^IP~VP&quot;, &quot;LC^LCP~PP&quot;, &quot;LC^LCP~IP&quot;, &quot;NP^VP~IP&quot;, &quot;NP^VP~VP&quot;, &quot;AD^ADVP~IP&quot;, &quot;AD^ADVP~QP&quot;, &quot;AD^ADVP~VP&quot;, &quot;AD^ADVP~NP&quot;, &quot;AD^ADVP~PP&quot;, &quot;AD^ADVP~ADVP&quot;, &quot;NP^IP~ROOT&quot;, &quot;NP^IP~IP&quot;, &quot;NP^IP~CP&quot;, &quot;NP^IP~VP&quot;, &quot;DT^DP~PP&quot;, &quot;P^PP~IP&quot;, &quot;P^PP~NP&quot;, &quot;P^PP~VP&quot;, &quot;P^PP~DNP&quot;, &quot;VV^VP~IP&quot;, &quot;VV^VP~VP&quot;, &quot;PU^IP~IP&quot;, &quot;PU^IP~VP&quot;, &quot;PU^IP~ROOT&quot;, &quot;PU^IP~CP&quot;, &quot;JJ^ADJP~DNP&quot;, &quot;JJ^ADJP~ADJP&quot;, &quot;NR^NP~IP&quot;, &quot;NR^NP~NP&quot;, &quot;NR^NP~PP&quot;, &quot;NR^NP~VP&quot;, &quot;NR^NP~DNP&quot;, &quot;NR^NP~LCP&quot;, &quot;NR^NP~PRN&quot;, &quot;NP^PP~NP&quot;, &quot;NP^PP~IP&quot;, &quot;NP^PP~DNP&quot;, &quot;VA^VP~VP&quot;, &quot;VA^VP~IP&quot;, &quot;VA^VP~DVP&quot;, &quot;VP^VP~VP&quot;, &quot;VP^VP~IP&quot;, &quot;VP^VP~DVP&quot;, &quot;VP^IP~ROOT&quot;, &quot;VP^IP~CP&quot;, &quot;VP^IP~IP&quot;, &quot;VP^IP~VP&quot;, &quot;VP^IP~PP&quot;, &quot;VP^IP~LCP&quot;, &quot;VP^IP~NP&quot;, &quot;PN^NP~NP&quot;, &quot;PN^NP~IP&quot;, &quot;PN^NP~PP&quot;};
    private static final String[] splitters2 = new String[] {&quot;VA^VCD&quot;, &quot;NP^NP&quot;, &quot;NP^VP&quot;, &quot;NP^IP&quot;, &quot;NP^DNP&quot;, &quot;NP^PP&quot;, &quot;NP^LCP&quot;, &quot;NN^FRAG&quot;, &quot;NN^NP&quot;, &quot;NT^FRAG&quot;, &quot;NT^NP&quot;, &quot;NR^FRAG&quot;, &quot;NR^NP&quot;, &quot;VV^FRAG&quot;, &quot;VV^VRD&quot;, &quot;VV^VCD&quot;, &quot;VV^VP&quot;, &quot;VV^VSB&quot;, &quot;VP^VP&quot;, &quot;VP^IP&quot;, &quot;VP^DVP&quot;, &quot;IP^ROOT&quot;, &quot;IP^IP&quot;, &quot;IP^CP&quot;, &quot;IP^VP&quot;, &quot;IP^PP&quot;, &quot;CP^IP&quot;, &quot;ADVP^CP&quot;, &quot;CC^VP&quot;, &quot;CC^NP&quot;, &quot;PU^NP&quot;, &quot;PU^FRAG&quot;, &quot;PU^IP&quot;, &quot;PU^VP&quot;, &quot;PU^PRN&quot;, &quot;NT^NP~NP&quot;, &quot;NT^NP~VP&quot;, &quot;NT^NP~IP&quot;, &quot;NT^NP~LCP&quot;, &quot;NT^NP~PP&quot;, &quot;NP^NP~VP&quot;, &quot;NP^NP~NP&quot;, &quot;NP^NP~IP&quot;, &quot;NP^NP~PP&quot;, &quot;NP^NP~DNP&quot;, &quot;NN^NP~VP&quot;, &quot;NN^NP~IP&quot;, &quot;NN^NP~NP&quot;, &quot;NN^NP~PP&quot;, &quot;NN^NP~DNP&quot;, &quot;NN^NP~LCP&quot;, &quot;NN^NP~UCP&quot;, &quot;NN^NP~QP&quot;, &quot;NN^NP~PRN&quot;, &quot;M^CLP~DP&quot;, &quot;CD^QP~VP&quot;, &quot;CD^QP~NP&quot;, &quot;CD^QP~QP&quot;, &quot;CD^QP~LCP&quot;, &quot;CD^QP~PP&quot;, &quot;CD^QP~DNP&quot;, &quot;CD^QP~DP&quot;, &quot;LC^LCP~PP&quot;, &quot;NP^VP~IP&quot;, &quot;NP^VP~VP&quot;, &quot;AD^ADVP~IP&quot;, &quot;AD^ADVP~QP&quot;, &quot;AD^ADVP~VP&quot;, &quot;AD^ADVP~NP&quot;, &quot;NP^IP~ROOT&quot;, &quot;NP^IP~IP&quot;, &quot;NP^IP~CP&quot;, &quot;NP^IP~VP&quot;, &quot;P^PP~IP&quot;, &quot;P^PP~NP&quot;, &quot;P^PP~VP&quot;, &quot;P^PP~DNP&quot;, &quot;VV^VP~IP&quot;, &quot;VV^VP~VP&quot;, &quot;PU^IP~IP&quot;, &quot;PU^IP~VP&quot;, &quot;PU^IP~ROOT&quot;, &quot;PU^IP~CP&quot;, &quot;JJ^ADJP~DNP&quot;, &quot;NR^NP~IP&quot;, &quot;NR^NP~NP&quot;, &quot;NR^NP~PP&quot;, &quot;NR^NP~VP&quot;, &quot;NR^NP~DNP&quot;, &quot;NR^NP~LCP&quot;, &quot;NP^PP~NP&quot;, &quot;VA^VP~VP&quot;, &quot;VA^VP~IP&quot;, &quot;VP^VP~VP&quot;, &quot;VP^IP~ROOT&quot;, &quot;VP^IP~CP&quot;, &quot;VP^IP~IP&quot;, &quot;VP^IP~VP&quot;, &quot;VP^IP~PP&quot;, &quot;VP^IP~LCP&quot;, &quot;VP^IP~NP&quot;, &quot;PN^NP~NP&quot;};
    private static final String[] splitters3 = new String[] {&quot;NP^NP&quot;, &quot;NP^VP&quot;, &quot;NP^IP&quot;, &quot;NP^DNP&quot;, &quot;NP^PP&quot;, &quot;NP^LCP&quot;, &quot;NN^FRAG&quot;, &quot;NN^NP&quot;, &quot;NT^FRAG&quot;, &quot;NR^FRAG&quot;, &quot;NR^NP&quot;, &quot;VV^FRAG&quot;, &quot;VV^VRD&quot;, &quot;VV^VCD&quot;, &quot;VV^VP&quot;, &quot;VV^VSB&quot;, &quot;VP^VP&quot;, &quot;VP^IP&quot;, &quot;IP^ROOT&quot;, &quot;IP^IP&quot;, &quot;IP^CP&quot;, &quot;IP^VP&quot;, &quot;PU^NP&quot;, &quot;PU^FRAG&quot;, &quot;PU^IP&quot;, &quot;PU^VP&quot;, &quot;PU^PRN&quot;, &quot;NP^NP~VP&quot;, &quot;NN^NP~VP&quot;, &quot;NN^NP~IP&quot;, &quot;NN^NP~NP&quot;, &quot;NN^NP~PP&quot;, &quot;NN^NP~DNP&quot;, &quot;NN^NP~LCP&quot;, &quot;M^CLP~DP&quot;, &quot;CD^QP~VP&quot;, &quot;CD^QP~NP&quot;, &quot;CD^QP~QP&quot;, &quot;AD^ADVP~IP&quot;, &quot;AD^ADVP~QP&quot;, &quot;AD^ADVP~VP&quot;, &quot;P^PP~IP&quot;, &quot;VV^VP~IP&quot;, &quot;VV^VP~VP&quot;, &quot;PU^IP~IP&quot;, &quot;PU^IP~VP&quot;, &quot;NR^NP~IP&quot;, &quot;NR^NP~NP&quot;, &quot;NR^NP~PP&quot;, &quot;NR^NP~VP&quot;, &quot;VP^VP~VP&quot;, &quot;VP^IP~ROOT&quot;, &quot;VP^IP~CP&quot;, &quot;VP^IP~IP&quot;, &quot;VP^IP~VP&quot;};
    private static final String[] splitters4 = new String[] {&quot;NP^NP&quot;, &quot;NP^VP&quot;, &quot;NP^IP&quot;, &quot;NN^FRAG&quot;, &quot;NT^FRAG&quot;, &quot;NR^FRAG&quot;, &quot;VV^FRAG&quot;, &quot;VV^VRD&quot;, &quot;VV^VCD&quot;, &quot;VP^VP&quot;, &quot;VP^IP&quot;, &quot;IP^ROOT&quot;, &quot;IP^IP&quot;, &quot;IP^CP&quot;, &quot;IP^VP&quot;, &quot;PU^NP&quot;, &quot;PU^FRAG&quot;, &quot;PU^IP&quot;, &quot;PU^VP&quot;, &quot;NN^NP~VP&quot;, &quot;NN^NP~IP&quot;, &quot;NN^NP~NP&quot;, &quot;NN^NP~PP&quot;, &quot;NN^NP~DNP&quot;, &quot;NN^NP~LCP&quot;, &quot;CD^QP~VP&quot;, &quot;CD^QP~NP&quot;, &quot;AD^ADVP~IP&quot;, &quot;VV^VP~IP&quot;, &quot;VV^VP~VP&quot;, &quot;NR^NP~IP&quot;, &quot;VP^IP~ROOT&quot;, &quot;VP^IP~CP&quot;};
    // these ones were built by hand.
    // one can't tag split under FRAG or everything breaks, because of those
    // big flat FRAGs....
    private static final String[] splitters5 = new String[] {&quot;NN^FRAG&quot;, &quot;NT^FRAG&quot;, &quot;NR^FRAG&quot;, &quot;VV^FRAG&quot;, &quot;VV^VCD&quot;, &quot;VV^VRD&quot;, &quot;NP^NP&quot;, &quot;VP^VP&quot;, &quot;IP^ROOT&quot;, &quot;IP^IP&quot;, &quot;PU^NP&quot;, &quot;PU^FRAG&quot;, &quot;P^PP~VP&quot;, &quot;P^PP~IP&quot;};
    private static final String[] splitters6 = new String[] {&quot;VV^VCD&quot;, &quot;VV^VRD&quot;, &quot;NP^NP&quot;, &quot;VP^VP&quot;, &quot;IP^ROOT&quot;, &quot;IP^IP&quot;, &quot;PU^NP&quot;, &quot;P^PP~VP&quot;, &quot;P^PP~IP&quot;};
    private static final String[] splitters7 = new String[] {&quot;NP^NP&quot;, &quot;VP^VP&quot;, &quot;IP^ROOT&quot;, &quot;IP^IP&quot;, &quot;PU^NP&quot;, &quot;P^PP~VP&quot;, &quot;P^PP~IP&quot;};
    private static final String[] splitters8 = new String[] {&quot;IP^ROOT&quot;, &quot;IP^IP&quot;, &quot;PU^NP&quot;, &quot;P^PP~VP&quot;, &quot;P^PP~IP&quot;};
    private static final String[] splitters9 = new String[] {&quot;VV^VCD&quot;, &quot;VV^VRD&quot;, &quot;NP^NP&quot;, &quot;VP^VP&quot;, &quot;IP^ROOT&quot;, &quot;IP^IP&quot;, &quot;P^PP~VP&quot;, &quot;P^PP~IP&quot;};
    private static final String[] splitters10 = new String[] {&quot;NP^NP&quot;, &quot;VP^VP&quot;, &quot;IP^ROOT&quot;, &quot;IP^IP&quot;, &quot;P^PP~VP&quot;, &quot;P^PP~IP&quot;};


    public String[] splitters() {
      switch (selectiveSplitLevel) {
      case 1:
        return splitters1;
      case 2:
        return splitters2;
      case 3:
        return splitters3;
      case 4:
        return splitters4;
      case 5:
        return splitters5;
      case 6:
        return splitters6;
      case 7:
        return splitters7;
      case 8:
        return splitters8;
      case 9:
        return splitters9;
      case 10:
        return splitters10;
      default:
        return new String[0];
      }
    }
  ------------------ */

  @Override
  public String[] sisterSplitters() {
<span class="nc" id="L246">    return StringUtils.EMPTY_STRING_ARRAY;</span>
  }

  /**
   * transformTree does all language-specific tree
   * transformations. Any parameterizations should be inside the
   * specific TreebankLangParserParams class.
   */
  @Override
  public Tree transformTree(Tree t, Tree root) {
<span class="nc bnc" id="L256" title="All 4 branches missed.">    if (t == null || t.isLeaf()) {</span>
<span class="nc" id="L257">      return t;</span>
    }

    String parentStr;
    String grandParentStr;
    Tree parent;
    Tree grandParent;
<span class="nc bnc" id="L264" title="All 4 branches missed.">    if (root == null || t.equals(root)) {</span>
<span class="nc" id="L265">      parent = null;</span>
<span class="nc" id="L266">      parentStr = &quot;&quot;;</span>
    } else {
<span class="nc" id="L268">      parent = t.parent(root);</span>
<span class="nc" id="L269">      parentStr = parent.label().value();</span>
    }
<span class="nc bnc" id="L271" title="All 4 branches missed.">    if (parent == null || parent.equals(root)) {</span>
<span class="nc" id="L272">      grandParent = null;</span>
<span class="nc" id="L273">      grandParentStr = &quot;&quot;;</span>
    } else {
<span class="nc" id="L275">      grandParent = parent.parent(root);</span>
<span class="nc" id="L276">      grandParentStr = grandParent.label().value();</span>
    }

<span class="nc" id="L279">    String baseParentStr = ctlp.basicCategory(parentStr);</span>
<span class="nc" id="L280">    String baseGrandParentStr = ctlp.basicCategory(grandParentStr);</span>

<span class="nc" id="L282">    CoreLabel lab = (CoreLabel) t.label();</span>
<span class="nc" id="L283">    String word = lab.word();</span>
<span class="nc" id="L284">    String tag = lab.tag();</span>
<span class="nc" id="L285">    String baseTag = ctlp.basicCategory(tag);</span>
<span class="nc" id="L286">    String category = lab.value();</span>
<span class="nc" id="L287">    String baseCategory = ctlp.basicCategory(category);</span>

<span class="nc bnc" id="L289" title="All 2 branches missed.">    if (t.isPreTerminal()) { // it's a POS tag</span>
<span class="nc" id="L290">      List&lt;String&gt; leftAunts = listBasicCategories(SisterAnnotationStats.leftSisterLabels(parent, grandParent));</span>
<span class="nc" id="L291">      List&lt;String&gt; rightAunts = listBasicCategories(SisterAnnotationStats.rightSisterLabels(parent, grandParent));</span>

      // Chinese-specific punctuation splits
<span class="nc bnc" id="L294" title="All 4 branches missed.">      if (chineseSplitPunct &amp;&amp; baseTag.equals(&quot;PU&quot;)) {</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">        if (ChineseTreebankLanguagePack.chineseDouHaoAcceptFilter().test(word)) {</span>
<span class="nc" id="L296">          tag = tag + &quot;-DOU&quot;;</span>
          // System.out.println(&quot;Punct: Split dou hao&quot;); // debugging
<span class="nc bnc" id="L298" title="All 2 branches missed.">        } else if (ChineseTreebankLanguagePack.chineseCommaAcceptFilter().test(word)) {</span>
<span class="nc" id="L299">          tag = tag + &quot;-COMMA&quot;;</span>
          // System.out.println(&quot;Punct: Split comma&quot;); // debugging
<span class="nc bnc" id="L301" title="All 2 branches missed.">        } else if (ChineseTreebankLanguagePack.chineseColonAcceptFilter().test(word)) {</span>
<span class="nc" id="L302">          tag = tag + &quot;-COLON&quot;;</span>
          // System.out.println(&quot;Punct: Split colon&quot;); // debugging
<span class="nc bnc" id="L304" title="All 2 branches missed.">        } else if (ChineseTreebankLanguagePack.chineseQuoteMarkAcceptFilter().test(word)) {</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">          if (chineseSplitPunctLR) {</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">            if (ChineseTreebankLanguagePack.chineseLeftQuoteMarkAcceptFilter().test(word)) {</span>
<span class="nc" id="L307">              tag += &quot;-LQUOTE&quot;;</span>
            } else {
<span class="nc" id="L309">              tag += &quot;-RQUOTE&quot;;</span>
            }
          } else {
<span class="nc" id="L312">            tag = tag + &quot;-QUOTE&quot;;</span>
          }
          // System.out.println(&quot;Punct: Split quote&quot;); // debugging
<span class="nc bnc" id="L315" title="All 2 branches missed.">        } else if (ChineseTreebankLanguagePack.chineseEndSentenceAcceptFilter().test(word)) {</span>
<span class="nc" id="L316">          tag = tag + &quot;-ENDSENT&quot;;</span>
          // System.out.println(&quot;Punct: Split end sent&quot;); // debugging
<span class="nc bnc" id="L318" title="All 2 branches missed.">        } else if (ChineseTreebankLanguagePack.chineseParenthesisAcceptFilter().test(word)) {</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">          if (chineseSplitPunctLR) {</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">            if (ChineseTreebankLanguagePack.chineseLeftParenthesisAcceptFilter().test(word)) {</span>
<span class="nc" id="L321">              tag += &quot;-LPAREN&quot;;</span>
            } else {
<span class="nc" id="L323">              tag += &quot;-RPAREN&quot;;</span>
            }
          } else {
<span class="nc" id="L326">            tag += &quot;-PAREN&quot;;</span>
            //printlnErr(&quot;Just used -PAREN annotation&quot;);
            //printlnErr(word);
            //throw new RuntimeException();
          }
          // System.out.println(&quot;Punct: Split paren&quot;); // debugging
<span class="nc bnc" id="L332" title="All 2 branches missed.">        } else if (ChineseTreebankLanguagePack.chineseDashAcceptFilter().test(word)) {</span>
<span class="nc" id="L333">          tag = tag + &quot;-DASH&quot;;</span>
          // System.out.println(&quot;Punct: Split dash&quot;); // debugging
<span class="nc bnc" id="L335" title="All 2 branches missed.">        } else if (ChineseTreebankLanguagePack.chineseOtherAcceptFilter().test(word)) {</span>
<span class="nc" id="L336">          tag = tag + &quot;-OTHER&quot;;</span>
        } else {
<span class="nc" id="L338">          printlnErr(&quot;Unknown punct (you should add it to CTLP): &quot; + tag + &quot; |&quot; + word + &quot;|&quot;);</span>
        }
<span class="nc bnc" id="L340" title="All 2 branches missed.">      } else if (chineseSplitDouHao) {   // only split DouHao</span>
<span class="nc bnc" id="L341" title="All 4 branches missed.">        if (ChineseTreebankLanguagePack.chineseDouHaoAcceptFilter().test(word) &amp;&amp; baseTag.equals(&quot;PU&quot;)) {</span>
<span class="nc" id="L342">          tag = tag + &quot;-DOU&quot;;</span>
        }
      }

      // Chinese-specific POS tag splits (non-punctuation)

<span class="nc bnc" id="L348" title="All 2 branches missed.">      if (tagWordSize) {</span>
<span class="nc" id="L349">        int l = word.length();</span>
<span class="nc" id="L350">        tag += &quot;-&quot; + l + &quot;CHARS&quot;;</span>
      }

<span class="nc bnc" id="L353" title="All 4 branches missed.">      if (mergeNNVV &amp;&amp; baseTag.equals(&quot;NN&quot;)) {</span>
<span class="nc" id="L354">        tag = &quot;VV&quot;;</span>
      }

<span class="nc bnc" id="L357" title="All 8 branches missed.">      if ((chineseSelectiveTagPA || chineseVerySelectiveTagPA) &amp;&amp; (baseTag.equals(&quot;CC&quot;) || baseTag.equals(&quot;P&quot;))) {</span>
<span class="nc" id="L358">        tag += &quot;-&quot; + baseParentStr;</span>
      }
<span class="nc bnc" id="L360" title="All 4 branches missed.">      if (chineseSelectiveTagPA &amp;&amp; (baseTag.equals(&quot;VV&quot;))) {</span>
<span class="nc" id="L361">        tag += &quot;-&quot; + baseParentStr;</span>
      }

<span class="nc bnc" id="L364" title="All 4 branches missed.">      if (markMultiNtag &amp;&amp; tag.startsWith(&quot;N&quot;)) {</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">        for (int i = 0; i &lt; parent.numChildren(); i++) {</span>
<span class="nc bnc" id="L366" title="All 4 branches missed.">          if (parent.children()[i].label().value().startsWith(&quot;N&quot;) &amp;&amp; parent.children()[i] != t) {</span>
<span class="nc" id="L367">            tag += &quot;=N&quot;;</span>
            //System.out.println(&quot;Found multi=N rewrite&quot;);
          }
        }
      }

<span class="nc bnc" id="L373" title="All 4 branches missed.">      if (markVVsisterIP &amp;&amp; baseTag.equals(&quot;VV&quot;)) {</span>
<span class="nc" id="L374">        boolean seenIP = false;</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">        for (int i = 0; i &lt; parent.numChildren(); i++) {</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">          if (parent.children()[i].label().value().startsWith(&quot;IP&quot;)) {</span>
<span class="nc" id="L377">            seenIP = true;</span>
          }
        }
<span class="nc bnc" id="L380" title="All 2 branches missed.">        if (seenIP) {</span>
<span class="nc" id="L381">          tag += &quot;-IP&quot;;</span>
          //System.out.println(&quot;Found VV with IP sister&quot;); // testing
        }
      }

<span class="nc bnc" id="L386" title="All 4 branches missed.">      if (markPsisterIP &amp;&amp; baseTag.equals(&quot;P&quot;)) {</span>
<span class="nc" id="L387">        boolean seenIP = false;</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">        for (int i = 0; i &lt; parent.numChildren(); i++) {</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">          if (parent.children()[i].label().value().startsWith(&quot;IP&quot;)) {</span>
<span class="nc" id="L390">            seenIP = true;</span>
          }
        }
<span class="nc bnc" id="L393" title="All 2 branches missed.">        if (seenIP) {</span>
<span class="nc" id="L394">          tag += &quot;-IP&quot;;</span>
        }
      }

<span class="nc bnc" id="L398" title="All 6 branches missed.">      if (markADgrandchildOfIP &amp;&amp; baseTag.equals(&quot;AD&quot;) &amp;&amp; baseGrandParentStr.equals(&quot;IP&quot;)) {</span>
<span class="nc" id="L399">        tag += &quot;~IP&quot;;</span>
        //System.out.println(&quot;Found AD with IP grandparent&quot;); // testing
      }

<span class="nc bnc" id="L403" title="All 4 branches missed.">      if (gpaAD &amp;&amp; baseTag.equals(&quot;AD&quot;)) {</span>
<span class="nc" id="L404">        tag += &quot;~&quot; + baseGrandParentStr;</span>
        //System.out.println(&quot;Found AD with grandparent &quot; + grandParentStr); // testing
      }

<span class="nc bnc" id="L408" title="All 6 branches missed.">      if (markPostverbalP &amp;&amp; leftAunts.contains(&quot;VV&quot;) &amp;&amp; baseTag.equals(&quot;P&quot;)) {</span>
        //System.out.println(&quot;Found post-verbal P&quot;);
<span class="nc" id="L410">        tag += &quot;^=lVV&quot;;</span>
      }

      // end Chinese-specific tag splits

<span class="nc" id="L415">      Label label = new CategoryWordTag(tag, word, tag);</span>
<span class="nc" id="L416">      t.setLabel(label);</span>
<span class="nc" id="L417">    } else {</span>
      // it's a phrasal category
<span class="nc" id="L419">      Tree[] kids = t.children();</span>

      // Chinese-specific category splits
<span class="nc" id="L422">      List&lt;String&gt; leftSis = listBasicCategories(SisterAnnotationStats.leftSisterLabels(t, parent));</span>
<span class="nc" id="L423">      List&lt;String&gt; rightSis = listBasicCategories(SisterAnnotationStats.rightSisterLabels(t, parent));</span>

<span class="nc bnc" id="L425" title="All 4 branches missed.">      if (paRootDtr &amp;&amp; baseParentStr.equals(&quot;ROOT&quot;)) {</span>
<span class="nc" id="L426">        category += &quot;^ROOT&quot;;</span>
      }

<span class="nc bnc" id="L429" title="All 4 branches missed.">      if (markIPsisterBA &amp;&amp; baseCategory.equals(&quot;IP&quot;)) {</span>
<span class="nc bnc" id="L430" title="All 2 branches missed.">        if (leftSis.contains(&quot;BA&quot;)) {</span>
<span class="nc" id="L431">          category += &quot;=BA&quot;;</span>
          //System.out.println(&quot;Found IP sister of BA&quot;);
        }
      }

<span class="nc bnc" id="L436" title="All 4 branches missed.">      if (dominatesV &amp;&amp; hasV(t.preTerminalYield())) {</span>
        // mark categories containing a verb
<span class="nc" id="L438">        category += &quot;-v&quot;;</span>
      }

<span class="nc bnc" id="L441" title="All 4 branches missed.">      if (markIPsisterVVorP &amp;&amp; baseCategory.equals(&quot;IP&quot;)) {</span>
        // todo: cdm: is just looking for &quot;P&quot; here selective enough??
<span class="nc bnc" id="L443" title="All 4 branches missed.">        if (leftSis.contains(&quot;VV&quot;) || leftSis.contains(&quot;P&quot;)) {</span>
<span class="nc" id="L444">          category += &quot;=VVP&quot;;</span>
        }
      }

<span class="nc bnc" id="L448" title="All 4 branches missed.">      if (markIPsisDEC &amp;&amp; baseCategory.equals(&quot;IP&quot;)) {</span>
<span class="nc bnc" id="L449" title="All 2 branches missed.">        if (rightSis.contains(&quot;DEC&quot;)) {</span>
<span class="nc" id="L450">          category += &quot;=DEC&quot;;</span>
          //System.out.println(&quot;Found prenominal IP&quot;);
        }
      }

<span class="nc bnc" id="L455" title="All 2 branches missed.">      if (baseCategory.equals(&quot;VP&quot;)) {</span>
        // cdm 2008: this used to just check that it startsWith(&quot;VP&quot;), but
        // I think that was bad because it also matched VPT verb compounds
<span class="nc bnc" id="L458" title="All 2 branches missed.">        if (chineseSplitVP == 3) {</span>
<span class="nc" id="L459">          boolean hasCC = false;</span>
<span class="nc" id="L460">          boolean hasPU = false;</span>
<span class="nc" id="L461">          boolean hasLexV = false;</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">          for (Tree kid : kids) {</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">            if (kid.label().value().startsWith(&quot;CC&quot;)) {</span>
<span class="nc" id="L464">              hasCC = true;</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">            } else if (kid.label().value().startsWith(&quot;PU&quot;)) {</span>
<span class="nc" id="L466">              hasPU = true;</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">            } else if (StringUtils.lookingAt(kid.label().value(), &quot;(V[ACEV]|VCD|VCP|VNV|VPT|VRD|VSB)&quot;)) {</span>
<span class="nc" id="L468">              hasLexV = true;</span>
            }
          }
<span class="nc bnc" id="L471" title="All 6 branches missed.">          if (hasCC || (hasPU &amp;&amp; ! hasLexV)) {</span>
<span class="nc" id="L472">            category += &quot;-CRD&quot;;</span>
            //System.out.println(&quot;Found coordinate VP&quot;); // testing
<span class="nc bnc" id="L474" title="All 2 branches missed.">          } else if (hasLexV) {</span>
<span class="nc" id="L475">            category += &quot;-COMP&quot;;</span>
            //System.out.println(&quot;Found complementing VP&quot;); // testing
          } else {
<span class="nc" id="L478">            category += &quot;-ADJT&quot;;</span>
            //System.out.println(&quot;Found adjoining VP&quot;); // testing
          }
<span class="nc bnc" id="L481" title="All 2 branches missed.">        } else if (chineseSplitVP &gt;= 1) {</span>
<span class="nc" id="L482">          boolean hasBA = false;</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">          for (Tree kid : kids) {</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">            if (kid.label().value().startsWith(&quot;BA&quot;)) {</span>
<span class="nc" id="L485">              hasBA = true;</span>
<span class="nc bnc" id="L486" title="All 4 branches missed.">            } else if (chineseSplitVP == 2 &amp;&amp; tlp.basicCategory(kid.label().value()).equals(&quot;VP&quot;)) {</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">              for (Tree kidkid : kid.children()) {</span>
<span class="nc bnc" id="L488" title="All 2 branches missed.">                if (kidkid.label().value().startsWith(&quot;BA&quot;)) {</span>
<span class="nc" id="L489">                  hasBA = true;</span>
                }
              }
            }
          }
<span class="nc bnc" id="L494" title="All 2 branches missed.">          if (hasBA) {</span>
<span class="nc" id="L495">            category += &quot;-BA&quot;;</span>
          }
        }
      }

<span class="nc bnc" id="L500" title="All 4 branches missed.">      if (markVPadjunct &amp;&amp; baseParentStr.equals(&quot;VP&quot;)) {</span>
        // cdm 2008: This used to use startsWith(&quot;VP&quot;) but changed to baseCat
<span class="nc" id="L502">        Tree[] sisters = parent.children();</span>
<span class="nc" id="L503">        boolean hasVPsister = false;</span>
<span class="nc" id="L504">        boolean hasCC = false;</span>
<span class="nc" id="L505">        boolean hasPU = false;</span>
<span class="nc" id="L506">        boolean hasLexV = false;</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">        for (Tree sister : sisters) {</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">          if (tlp.basicCategory(sister.label().value()).equals(&quot;VP&quot;)) {</span>
<span class="nc" id="L509">            hasVPsister = true;</span>
          }
<span class="nc bnc" id="L511" title="All 2 branches missed.">          if (sister.label().value().startsWith(&quot;CC&quot;)) {</span>
<span class="nc" id="L512">            hasCC = true;</span>
          }
<span class="nc bnc" id="L514" title="All 2 branches missed.">          if (sister.label().value().startsWith(&quot;PU&quot;)) {</span>
<span class="nc" id="L515">            hasPU = true;</span>
          }
<span class="nc bnc" id="L517" title="All 2 branches missed.">          if (StringUtils.lookingAt(sister.label().value(), &quot;(V[ACEV]|VCD|VCP|VNV|VPT|VRD|VSB)&quot;)) {</span>
<span class="nc" id="L518">            hasLexV = true;</span>
          }
        }
<span class="nc bnc" id="L521" title="All 8 branches missed.">        if (hasVPsister &amp;&amp; !(hasCC || hasPU || hasLexV)) {</span>
<span class="nc" id="L522">          category += &quot;-VPADJ&quot;;</span>
          //System.out.println(&quot;Found adjunct of VP&quot;); // testing
        }
      }

<span class="nc bnc" id="L527" title="All 6 branches missed.">      if (markNPmodNP &amp;&amp; baseCategory.equals(&quot;NP&quot;) &amp;&amp; baseParentStr.equals(&quot;NP&quot;)) {</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">        if (rightSis.contains(&quot;NP&quot;)) {</span>
<span class="nc" id="L529">          category += &quot;=MODIFIERNP&quot;;</span>
          //System.out.println(&quot;Found NP modifier of NP&quot;); // testing
        }
      }

<span class="nc bnc" id="L534" title="All 6 branches missed.">      if (markModifiedNP &amp;&amp; baseCategory.equals(&quot;NP&quot;) &amp;&amp; baseParentStr.equals(&quot;NP&quot;)) {</span>
<span class="nc bnc" id="L535" title="All 14 branches missed.">        if (rightSis.isEmpty() &amp;&amp; (leftSis.contains(&quot;ADJP&quot;) || leftSis.contains(&quot;NP&quot;) || leftSis.contains(&quot;DNP&quot;) || leftSis.contains(&quot;QP&quot;) || leftSis.contains(&quot;CP&quot;) || leftSis.contains(&quot;PP&quot;))) {</span>
<span class="nc" id="L536">          category += &quot;=MODIFIEDNP&quot;;</span>
          //System.out.println(&quot;Found modified NP&quot;); // testing
        }
      }

<span class="nc bnc" id="L541" title="All 6 branches missed.">      if (markNPconj &amp;&amp; baseCategory.equals(&quot;NP&quot;) &amp;&amp; baseParentStr.equals(&quot;NP&quot;)) {</span>
<span class="nc bnc" id="L542" title="All 8 branches missed.">        if (rightSis.contains(&quot;CC&quot;) || rightSis.contains(&quot;PU&quot;) || leftSis.contains(&quot;CC&quot;) || leftSis.contains(&quot;PU&quot;)) {</span>
<span class="nc" id="L543">          category += &quot;=CONJ&quot;;</span>
          //System.out.println(&quot;Found NP conjunct&quot;); // testing
        }
      }

<span class="nc bnc" id="L548" title="All 6 branches missed.">      if (markIPconj &amp;&amp; baseCategory.equals(&quot;IP&quot;) &amp;&amp; baseParentStr.equals(&quot;IP&quot;)) {</span>
<span class="nc" id="L549">        Tree[] sisters = parent.children();</span>
<span class="nc" id="L550">        boolean hasCommaSis = false;</span>
<span class="nc" id="L551">        boolean hasIPSis = false;</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">        for (Tree sister : sisters) {</span>
<span class="nc bnc" id="L553" title="All 4 branches missed.">          if (ctlp.basicCategory(sister.label().value()).equals(&quot;PU&quot;) &amp;&amp; ChineseTreebankLanguagePack.chineseCommaAcceptFilter().test(sister.children()[0].label().toString())) {</span>
<span class="nc" id="L554">            hasCommaSis = true;</span>
            //System.out.println(&quot;Found CommaSis&quot;); // testing
          }
<span class="nc bnc" id="L557" title="All 4 branches missed.">          if (ctlp.basicCategory(sister.label().value()).equals(&quot;IP&quot;) &amp;&amp; sister != t) {</span>
<span class="nc" id="L558">            hasIPSis = true;</span>
          }
        }
<span class="nc bnc" id="L561" title="All 4 branches missed.">        if (hasCommaSis &amp;&amp; hasIPSis) {</span>
<span class="nc" id="L562">          category += &quot;-CONJ&quot;;</span>
          //System.out.println(&quot;Found IP conjunct&quot;); // testing
        }
      }

<span class="nc bnc" id="L567" title="All 6 branches missed.">      if (unaryIP &amp;&amp; baseCategory.equals(&quot;IP&quot;) &amp;&amp; t.numChildren() == 1) {</span>
<span class="nc" id="L568">        category += &quot;-U&quot;;</span>
        //System.out.println(&quot;Found unary IP&quot;); //testing
      }
<span class="nc bnc" id="L571" title="All 6 branches missed.">      if (unaryCP &amp;&amp; baseCategory.equals(&quot;CP&quot;) &amp;&amp; t.numChildren() == 1) {</span>
<span class="nc" id="L572">        category += &quot;-U&quot;;</span>
        //System.out.println(&quot;Found unary CP&quot;); //testing
      }

<span class="nc bnc" id="L576" title="All 4 branches missed.">      if (splitBaseNP &amp;&amp; baseCategory.equals(&quot;NP&quot;)) {</span>
<span class="nc bnc" id="L577" title="All 2 branches missed.">        if (t.isPrePreTerminal()) {</span>
<span class="nc" id="L578">          category = category + &quot;-B&quot;;</span>
        }
      }

      //if (Test.verbose) printlnErr(baseCategory + &quot; &quot; + leftSis.toString()); //debugging

<span class="nc bnc" id="L584" title="All 6 branches missed.">      if (markPostverbalPP &amp;&amp; leftSis.contains(&quot;VV&quot;) &amp;&amp; baseCategory.equals(&quot;PP&quot;)) {</span>
        //System.out.println(&quot;Found post-verbal PP&quot;);
<span class="nc" id="L586">        category += &quot;=lVV&quot;;</span>
      }

<span class="nc bnc" id="L589" title="All 6 branches missed.">      if ((markADgrandchildOfIP || gpaAD) &amp;&amp; listBasicCategories(SisterAnnotationStats.kidLabels(t)).contains(&quot;AD&quot;)) {</span>
<span class="nc" id="L590">        category += &quot;^ADVP&quot;;</span>
      }

<span class="nc bnc" id="L593" title="All 2 branches missed.">      if (markCC) {</span>
        // was: for (int i = 0; i &lt; kids.length; i++) {
        // This second version takes an idea from Collins: don't count
        // marginal conjunctions which don't conjoin 2 things.
<span class="nc bnc" id="L597" title="All 2 branches missed.">        for (int i = 1; i &lt; kids.length - 1; i++) {</span>
<span class="nc" id="L598">          String cat2 = kids[i].label().value();</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">          if (cat2.startsWith(&quot;CC&quot;)) {</span>
<span class="nc" id="L600">            category += &quot;-CC&quot;;</span>
          }
        }
      }

<span class="nc" id="L605">      Label label = new CategoryWordTag(category, word, tag);</span>
<span class="nc" id="L606">      t.setLabel(label);</span>
    }
<span class="nc" id="L608">    return t;</span>
  }


  /**
   * Chinese: Split the dou hao (a punctuation mark separating
   * members of a list) from other punctuation.  Good but included below.
   */
<span class="fc" id="L616">  public boolean chineseSplitDouHao = false;</span>
  /**
   * Chinese: split Chinese punctuation several ways, along the lines
   * of English punctuation plus another category for the dou hao.  Good.
   */
<span class="fc" id="L621">  public boolean chineseSplitPunct = true;</span>
  /**
   * Chinese: split left right/paren quote (if chineseSplitPunct is also
   * true.  Only very marginal gains, but seems positive.
   */
<span class="fc" id="L626">  public boolean chineseSplitPunctLR = false;</span>

  /**
   * Chinese: mark VVs that are sister of IP (communication &amp;amp;
   * small-clause-taking verbs).  Good: give 0.5%
   */
<span class="fc" id="L632">  public boolean markVVsisterIP = true;</span>

  /**
   * Chinese: mark P's that are sister of IP.  Negative effect
   */
<span class="fc" id="L637">  public boolean markPsisterIP = true;</span>

  /**
   * Chinese: mark IP's that are sister of VV or P.  These rarely
   * have punctuation. Small positive effect.
   */
<span class="fc" id="L643">  public boolean markIPsisterVVorP = true;</span>


  /**
   * Chinese: mark ADs that are grandchild of IP.
   */
<span class="fc" id="L649">  public boolean markADgrandchildOfIP = false;</span>
  /**
   * Grandparent annotate all AD.  Seems slightly negative.
   */
<span class="fc" id="L653">  public boolean gpaAD = true;</span>

  // using tagPA on Chinese 100k is negative.

<span class="fc" id="L657">  public boolean chineseVerySelectiveTagPA = false;</span>
<span class="fc" id="L658">  public boolean chineseSelectiveTagPA = false;</span>

  /**
   * Chinese: mark IPs that are sister of BA.  These always have
   * overt NP.  Very slightly positive.
   */
<span class="fc" id="L664">  public boolean markIPsisterBA = true;</span>

  /**
   * Chinese: mark phrases that are adjuncts of VP (these tend to be
   * locatives/temporals, and have a specific distribution).
   * Necessary even with chineseSplitVP==3 and parent annotation because
   * parent annotation happens with unsplit parent categories.
   * Slightly positive.
   */
<span class="fc" id="L673">  public boolean markVPadjunct = true;</span>

  /**
   * Chinese: mark NP modifiers of NPs. Quite positive (0.5%)
   */
<span class="fc" id="L678">  public boolean markNPmodNP = true;</span>

  /**
   * Chinese: mark left-modified NPs (rightmost NPs with a left-side
   * mod).  Slightly positive.
   */
<span class="fc" id="L684">  public boolean markModifiedNP = true;</span>

  /**
   * Chinese: mark NPs that are conjuncts.  Negative on small set.
   */
<span class="fc" id="L689">  public boolean markNPconj = true;</span>

  /**
   * Chinese: mark nominal tags that are part of multi-nominal
   * rewrites.  Doesn't seem any good.
   */
<span class="fc" id="L695">  public boolean markMultiNtag = false;</span>

  /**
   * Chinese: mark IPs that are part of prenominal modifiers. Negative.
   */
<span class="fc" id="L700">  public boolean markIPsisDEC = true;</span>

  /**
   * Chinese: mark IPs that are conjuncts.  Or those that have
   * (adjuncts or subjects)
   */
<span class="fc" id="L706">  public boolean markIPconj = false;</span>
<span class="fc" id="L707">  public boolean markIPadjsubj = false;</span>

  /**
   * Chinese VP splitting.  0 = none;
   * 1 = mark with -BA a VP that directly dominates a BA;
   * 2 = mark with -BA a VP that directly dominates a BA or a VP that
   *     directly dominates a BA
   * 3 = split VPs into VP-COMP, VP-CRD, VP-ADJ.  (Negative value.)
   */
<span class="fc" id="L716">  public int chineseSplitVP = 3;</span>

  /** Chinese: if an IP has no subject (including no empty-category
   * subject), then it should only have an NP (adjunct) daughter if
   * it's a coordinate IP and the NP scopes over the conjunct
   * IPs. (sometimes this NP daughter is adjoined in an IP -&amp;gt; NP
   * IP_coord structure, sometimes the IP conjuncts are at the same
   * level as the NP).  In other cases NP adjuncts should be inside
   * VP.  So: an IP dominating neither a non-subject NP nor another IP
   * should have no NP daughters.  BUT this generalization breaks down
   * when you try to extend it to IPs ignoring their empty subjects.
   * So the simplest thing to do would be to mark non-subject dtrs of
   * IP....  but I think we need to leave the SBJ functional tagging
   * on categories to be consistent about this.
   *
   * Update: I tried retaining SBJ markers with
   * SbjRetainingTreeNormalizer but it works worse than using
   * markVPadjunct.
   */

  /**
   * Chinese: merge NN and VV.  A lark.
   */
<span class="fc" id="L739">  public boolean mergeNNVV = false;</span>

  // XXXX upto in testing

  /**
   * Chinese: unary category marking
   */
<span class="fc" id="L746">  public boolean unaryIP = false;</span>
<span class="fc" id="L747">  public boolean unaryCP = false;</span>

  /**
   * Chinese: parent annotate daughter of root.  Meant only for
   * selectivesplit=false.
   */
<span class="fc" id="L753">  public boolean paRootDtr = false; // true</span>

  /**
   * Chinese: mark P with a left aunt VV, and PP with a left sister
   * VV.  Note that it's necessary to mark both to thread the
   * context-marking.  Used to identify post-verbal P's, which are
   * rare.
   */
<span class="fc" id="L761">  public boolean markPostverbalP = false;</span>
<span class="fc" id="L762">  public boolean markPostverbalPP = false;</span>


  // Not used now
  // /** How selectively to split. */
  // public int selectiveSplitLevel = 1;

  /**
   * Mark base NPs.  Good.
   */
<span class="fc" id="L772">  public boolean splitBaseNP = false;</span>

  /**
   * Annotate tags for number of characters contained.
   */
<span class="fc" id="L777">  public boolean tagWordSize = false;</span>

  /**
   * Mark phrases which are conjunctions.
   * Appears negative, even with 200K words training data.
   */
<span class="fc" id="L783">  public boolean markCC = false;</span>

  /**
   * Whether to retain the -TMP functional tag on various phrasal
   * categories.  On 80K words training, minutely helpful; on 200K
   * words, best option gives 0.6%.  Doing
   * splitNPTMP and splitPPTMP (but not splitXPTMP) is best.
   */
<span class="fc" id="L791">  public boolean splitNPTMP = false;</span>
<span class="fc" id="L792">  public boolean splitPPTMP = false;</span>
<span class="fc" id="L793">  public boolean splitXPTMP = false;</span>

  /**
   * Verbal distance -- mark whether symbol dominates a verb (V*).
   * Seems bad for Chinese.
   */
<span class="fc" id="L799">  public boolean dominatesV = false;</span>


  /**
   * Parameters specific for creating a ChineseLexicon
   */
  public static final boolean DEFAULT_USE_GOOD_TURNING_UNKNOWN_WORD_MODEL = false;
<span class="fc" id="L806">  public boolean useGoodTuringUnknownWordModel = DEFAULT_USE_GOOD_TURNING_UNKNOWN_WORD_MODEL;</span>
<span class="fc" id="L807">  public boolean useCharBasedUnknownWordModel = false;</span>


  /**
   * Parameters for a ChineseCharacterBasedLexicon
   */
<span class="fc" id="L813">  public double lengthPenalty = 5.0;</span>

<span class="fc" id="L815">  public boolean useUnknownCharacterModel = true;</span>

  /**
   * penaltyType should be set as follows:
   * 0: no length penalty
   * 1: quadratic length penalty
   * 2: penalty for continuation chars only
   * TODO: make this an enum
   */
<span class="fc" id="L824">  public int penaltyType = 0;</span>

  @Override
  public void display() {
<span class="nc bnc" id="L828" title="All 4 branches missed.">    String chineseParams = &quot;Using ChineseTreebankParserParams&quot; + &quot; chineseSplitDouHao=&quot; + chineseSplitDouHao + &quot; chineseSplitPunct=&quot; + chineseSplitPunct + &quot; chineseSplitPunctLR=&quot; + chineseSplitPunctLR + &quot; markVVsisterIP=&quot; + markVVsisterIP + &quot; markVPadjunct=&quot; + markVPadjunct + &quot; chineseSplitVP=&quot; + chineseSplitVP + &quot; mergeNNVV=&quot; + mergeNNVV + &quot; unaryIP=&quot; + unaryIP + &quot; unaryCP=&quot; + unaryCP + &quot; paRootDtr=&quot; + paRootDtr + &quot; markPsisterIP=&quot; + markPsisterIP + &quot; markIPsisterVVorP=&quot; + markIPsisterVVorP + &quot; markADgrandchildOfIP=&quot; + markADgrandchildOfIP + &quot; gpaAD=&quot; + gpaAD + &quot; markIPsisterBA=&quot; + markIPsisterBA + &quot; markNPmodNP=&quot; + markNPmodNP + &quot; markNPconj=&quot; + markNPconj + &quot; markMultiNtag=&quot; + markMultiNtag + &quot; markIPsisDEC=&quot; + markIPsisDEC + &quot; markIPconj=&quot; + markIPconj + &quot; markIPadjsubj=&quot; + markIPadjsubj + &quot; markPostverbalP=&quot; + markPostverbalP + &quot; markPostverbalPP=&quot; + markPostverbalPP</span>
            //      + &quot; selSplitLevel=&quot; + selectiveSplitLevel
            + &quot; baseNP=&quot; + splitBaseNP + &quot; headFinder=&quot; + (sunJurafskyHeadFinder ? &quot;sunJurafsky&quot; : (bikelHeadFinder ? &quot;bikel&quot; : &quot;levy&quot;)) + &quot; discardFrags=&quot; + discardFrags  + &quot; dominatesV=&quot; + dominatesV;
<span class="nc" id="L831">    printlnErr(chineseParams);</span>
<span class="nc" id="L832">  }</span>


  private List&lt;String&gt; listBasicCategories(List&lt;String&gt; l) {
<span class="nc" id="L836">    List&lt;String&gt; l1 = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L837" title="All 2 branches missed.">    for (String s : l) {</span>
<span class="nc" id="L838">      l1.add(ctlp.basicCategory(s));</span>
<span class="nc" id="L839">    }</span>
<span class="nc" id="L840">    return l1;</span>
  }

  // TODO: Rewrite this as general matching predicate
  private static boolean hasV(List tags) {
<span class="nc bnc" id="L845" title="All 2 branches missed.">    for (Object tag : tags) {</span>
<span class="nc" id="L846">      String str = tag.toString();</span>
<span class="nc bnc" id="L847" title="All 2 branches missed.">      if (str.startsWith(&quot;V&quot;)) {</span>
<span class="nc" id="L848">        return true;</span>
      }
<span class="nc" id="L850">    }</span>
<span class="nc" id="L851">    return false;</span>
  }

  /**
   * Set language-specific options according to flags.
   * This routine should process the option starting in args[i] (which
   * might potentially be several arguments long if it takes arguments).
   * It should return the index after the last index it consumed in
   * processing.  In particular, if it cannot process the current option,
   * the return value should be i.
   */
  @Override
  public int setOptionFlag(String[] args, int i) {
    // [CDM 2008: there are no generic options!] first, see if it's a generic option
    // int j = super.setOptionFlag(args, i);
    // if(i != j) return j;

    //lang. specific options
    // if (args[i].equalsIgnoreCase(&quot;-vSelSplitLevel&quot;) &amp;&amp;
    //            (i+1 &lt; args.length)) {
    //   selectiveSplitLevel = Integer.parseInt(args[i+1]);
    //   i+=2;
    // } else
<span class="nc bnc" id="L874" title="All 2 branches missed.">    if (args[i].equalsIgnoreCase(&quot;-paRootDtr&quot;)) {</span>
<span class="nc" id="L875">      paRootDtr = true;</span>
<span class="nc" id="L876">      i += 1;</span>
<span class="nc bnc" id="L877" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-unaryIP&quot;)) {</span>
<span class="nc" id="L878">      unaryIP = true;</span>
<span class="nc" id="L879">      i += 1;</span>
<span class="nc bnc" id="L880" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-unaryCP&quot;)) {</span>
<span class="nc" id="L881">      unaryCP = true;</span>
<span class="nc" id="L882">      i += 1;</span>
<span class="nc bnc" id="L883" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-markPostverbalP&quot;)) {</span>
<span class="nc" id="L884">      markPostverbalP = true;</span>
<span class="nc" id="L885">      i += 1;</span>
<span class="nc bnc" id="L886" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-markPostverbalPP&quot;)) {</span>
<span class="nc" id="L887">      markPostverbalPP = true;</span>
<span class="nc" id="L888">      i += 1;</span>
<span class="nc bnc" id="L889" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-baseNP&quot;)) {</span>
<span class="nc" id="L890">      splitBaseNP = true;</span>
<span class="nc" id="L891">      i += 1;</span>
<span class="nc bnc" id="L892" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-markVVsisterIP&quot;)) {</span>
<span class="nc" id="L893">      markVVsisterIP = true;</span>
<span class="nc" id="L894">      i += 1;</span>
<span class="nc bnc" id="L895" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-markPsisterIP&quot;)) {</span>
<span class="nc" id="L896">      markPsisterIP = true;</span>
<span class="nc" id="L897">      i += 1;</span>
<span class="nc bnc" id="L898" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-markIPsisterVVorP&quot;)) {</span>
<span class="nc" id="L899">      markIPsisterVVorP = true;</span>
<span class="nc" id="L900">      i += 1;</span>
<span class="nc bnc" id="L901" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-markIPsisterBA&quot;)) {</span>
<span class="nc" id="L902">      markIPsisterBA = true;</span>
<span class="nc" id="L903">      i += 1;</span>
<span class="nc bnc" id="L904" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-dominatesV&quot;)) {</span>
<span class="nc" id="L905">      dominatesV = true;</span>
<span class="nc" id="L906">      i += 1;</span>
<span class="nc bnc" id="L907" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-gpaAD&quot;)) {</span>
<span class="nc" id="L908">      gpaAD = true;</span>
<span class="nc" id="L909">      i += 1;</span>
<span class="nc bnc" id="L910" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-markVPadjunct&quot;)) {</span>
<span class="nc" id="L911">      markVPadjunct = Boolean.valueOf(args[i+1]);</span>
<span class="nc" id="L912">      i += 2;</span>
<span class="nc bnc" id="L913" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-markNPmodNP&quot;)) {</span>
<span class="nc" id="L914">      markNPmodNP = true;</span>
<span class="nc" id="L915">      i += 1;</span>
<span class="nc bnc" id="L916" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-markModifiedNP&quot;)) {</span>
<span class="nc" id="L917">      markModifiedNP = true;</span>
<span class="nc" id="L918">      i += 1;</span>
<span class="nc bnc" id="L919" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-nomarkModifiedNP&quot;)) {</span>
<span class="nc" id="L920">      markModifiedNP = false;</span>
<span class="nc" id="L921">      i += 1;</span>
<span class="nc bnc" id="L922" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-markNPconj&quot;)) {</span>
<span class="nc" id="L923">      markNPconj = true;</span>
<span class="nc" id="L924">      i += 1;</span>
<span class="nc bnc" id="L925" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-nomarkNPconj&quot;)) {</span>
<span class="nc" id="L926">      markNPconj = false;</span>
<span class="nc" id="L927">      i += 1;</span>
<span class="nc bnc" id="L928" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-chineseSplitPunct&quot;)) {</span>
<span class="nc" id="L929">      chineseSplitPunct = true;</span>
<span class="nc" id="L930">      i += 1;</span>
<span class="nc bnc" id="L931" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-chineseSplitPunctLR&quot;)) {</span>
<span class="nc" id="L932">      chineseSplitPunct = true;</span>
<span class="nc" id="L933">      chineseSplitPunctLR = true;</span>
<span class="nc" id="L934">      i += 1;</span>
<span class="nc bnc" id="L935" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-chineseSelectiveTagPA&quot;)) {</span>
<span class="nc" id="L936">      chineseSelectiveTagPA = true;</span>
<span class="nc" id="L937">      i += 1;</span>
<span class="nc bnc" id="L938" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-chineseVerySelectiveTagPA&quot;)) {</span>
<span class="nc" id="L939">      chineseVerySelectiveTagPA = true;</span>
<span class="nc" id="L940">      i += 1;</span>
<span class="nc bnc" id="L941" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-markIPsisDEC&quot;)) {</span>
<span class="nc" id="L942">      markIPsisDEC = true;</span>
<span class="nc" id="L943">      i += 1;</span>
<span class="nc bnc" id="L944" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-chineseSplitVP&quot;)) {</span>
<span class="nc" id="L945">      chineseSplitVP = Integer.parseInt(args[i+1]);</span>
<span class="nc" id="L946">      i += 2;</span>
<span class="nc bnc" id="L947" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-tagWordSize&quot;)) {</span>
<span class="nc" id="L948">      tagWordSize = true;</span>
<span class="nc" id="L949">      i += 1;</span>
<span class="nc bnc" id="L950" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-vanilla&quot;)) {</span>
<span class="nc" id="L951">      chineseSplitDouHao = false;</span>
<span class="nc" id="L952">      chineseSplitPunct = false;</span>
<span class="nc" id="L953">      chineseSplitPunctLR = false;</span>
<span class="nc" id="L954">      markVVsisterIP = false;</span>
<span class="nc" id="L955">      markPsisterIP = false;</span>
<span class="nc" id="L956">      markIPsisterVVorP = false;</span>
<span class="nc" id="L957">      markADgrandchildOfIP = false;</span>
<span class="nc" id="L958">      gpaAD = false;</span>
<span class="nc" id="L959">      markIPsisterBA = false;</span>
<span class="nc" id="L960">      markVPadjunct = false;</span>
<span class="nc" id="L961">      markNPmodNP = false;</span>
<span class="nc" id="L962">      markModifiedNP = false;</span>
<span class="nc" id="L963">      markNPconj = false;</span>
<span class="nc" id="L964">      markMultiNtag = false;</span>
<span class="nc" id="L965">      markIPsisDEC = false;</span>
<span class="nc" id="L966">      markIPconj = false;</span>
<span class="nc" id="L967">      markIPadjsubj = false;</span>
<span class="nc" id="L968">      chineseSplitVP = 0;</span>
<span class="nc" id="L969">      mergeNNVV = false;</span>
<span class="nc" id="L970">      unaryIP = false;</span>
<span class="nc" id="L971">      unaryCP = false;</span>
<span class="nc" id="L972">      paRootDtr = false;</span>
<span class="nc" id="L973">      markPostverbalP = false;</span>
<span class="nc" id="L974">      markPostverbalPP = false;</span>
<span class="nc" id="L975">      splitBaseNP = false;</span>
      // selectiveSplitLevel = 0;
<span class="nc" id="L977">      i += 1;</span>
<span class="nc bnc" id="L978" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-acl03chinese&quot;)) {</span>
<span class="nc" id="L979">      chineseSplitDouHao = false;</span>
<span class="nc" id="L980">      chineseSplitPunct = true;</span>
<span class="nc" id="L981">      chineseSplitPunctLR = true;</span>
<span class="nc" id="L982">      markVVsisterIP = true;</span>
<span class="nc" id="L983">      markPsisterIP = true;</span>
<span class="nc" id="L984">      markIPsisterVVorP = true;</span>
<span class="nc" id="L985">      markADgrandchildOfIP = false;</span>
<span class="nc" id="L986">      gpaAD = true;</span>
<span class="nc" id="L987">      markIPsisterBA = false;</span>
<span class="nc" id="L988">      markVPadjunct = true;</span>
<span class="nc" id="L989">      markNPmodNP = true;</span>
<span class="nc" id="L990">      markModifiedNP = true;</span>
<span class="nc" id="L991">      markNPconj = true;</span>
<span class="nc" id="L992">      markMultiNtag = false;</span>
<span class="nc" id="L993">      markIPsisDEC = true;</span>
<span class="nc" id="L994">      markIPconj = false;</span>
<span class="nc" id="L995">      markIPadjsubj = false;</span>
<span class="nc" id="L996">      chineseSplitVP = 3;</span>
<span class="nc" id="L997">      mergeNNVV = false;</span>
<span class="nc" id="L998">      unaryIP = true;</span>
<span class="nc" id="L999">      unaryCP = true;</span>
<span class="nc" id="L1000">      paRootDtr = true;</span>
<span class="nc" id="L1001">      markPostverbalP = false;</span>
<span class="nc" id="L1002">      markPostverbalPP = false;</span>
<span class="nc" id="L1003">      splitBaseNP = false;</span>
      // selectiveSplitLevel = 0;
<span class="nc" id="L1005">      i += 1;</span>
<span class="nc bnc" id="L1006" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-chineseFactored&quot;)) {</span>
<span class="nc" id="L1007">      chineseSplitDouHao = false;</span>
<span class="nc" id="L1008">      chineseSplitPunct = true;</span>
<span class="nc" id="L1009">      chineseSplitPunctLR = true;</span>
<span class="nc" id="L1010">      markVVsisterIP = true;</span>
<span class="nc" id="L1011">      markPsisterIP = true;</span>
<span class="nc" id="L1012">      markIPsisterVVorP = true;</span>
<span class="nc" id="L1013">      markADgrandchildOfIP = false;</span>
<span class="nc" id="L1014">      gpaAD = true;</span>
<span class="nc" id="L1015">      markIPsisterBA = true;</span>
<span class="nc" id="L1016">      markVPadjunct = true;</span>
<span class="nc" id="L1017">      markNPmodNP = true;</span>
<span class="nc" id="L1018">      markModifiedNP = true;</span>
<span class="nc" id="L1019">      markNPconj = true;</span>
<span class="nc" id="L1020">      markMultiNtag = false;</span>
<span class="nc" id="L1021">      markIPsisDEC = true;</span>
<span class="nc" id="L1022">      markIPconj = false;</span>
<span class="nc" id="L1023">      markIPadjsubj = false;</span>
<span class="nc" id="L1024">      chineseSplitVP = 3;</span>
<span class="nc" id="L1025">      mergeNNVV = false;</span>
<span class="nc" id="L1026">      unaryIP = true;</span>
<span class="nc" id="L1027">      unaryCP = true;</span>
<span class="nc" id="L1028">      paRootDtr = true;</span>
<span class="nc" id="L1029">      markPostverbalP = false;</span>
<span class="nc" id="L1030">      markPostverbalPP = false;</span>
<span class="nc" id="L1031">      splitBaseNP = false;</span>
      // selectiveSplitLevel = 0;
<span class="nc" id="L1033">      chineseVerySelectiveTagPA = true;</span>
<span class="nc" id="L1034">      i += 1;</span>
<span class="nc bnc" id="L1035" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-chinesePCFG&quot;)) {</span>
<span class="nc" id="L1036">      chineseSplitDouHao = false;</span>
<span class="nc" id="L1037">      chineseSplitPunct = true;</span>
<span class="nc" id="L1038">      chineseSplitPunctLR = true;</span>
<span class="nc" id="L1039">      markVVsisterIP = true;</span>
<span class="nc" id="L1040">      markPsisterIP = false;</span>
<span class="nc" id="L1041">      markIPsisterVVorP = true;</span>
<span class="nc" id="L1042">      markADgrandchildOfIP = false;</span>
<span class="nc" id="L1043">      gpaAD = false;</span>
<span class="nc" id="L1044">      markIPsisterBA = true;</span>
<span class="nc" id="L1045">      markVPadjunct = true;</span>
<span class="nc" id="L1046">      markNPmodNP = true;</span>
<span class="nc" id="L1047">      markModifiedNP = true;</span>
<span class="nc" id="L1048">      markNPconj = false;</span>
<span class="nc" id="L1049">      markMultiNtag = false;</span>
<span class="nc" id="L1050">      markIPsisDEC = false;</span>
<span class="nc" id="L1051">      markIPconj = false;</span>
<span class="nc" id="L1052">      markIPadjsubj = false;</span>
<span class="nc" id="L1053">      chineseSplitVP = 0;</span>
<span class="nc" id="L1054">      mergeNNVV = false;</span>
<span class="nc" id="L1055">      unaryIP = false;</span>
<span class="nc" id="L1056">      unaryCP = false;</span>
<span class="nc" id="L1057">      paRootDtr = false;</span>
<span class="nc" id="L1058">      markPostverbalP = false;</span>
<span class="nc" id="L1059">      markPostverbalPP = false;</span>
<span class="nc" id="L1060">      splitBaseNP = false;</span>
      // selectiveSplitLevel = 0;
<span class="nc" id="L1062">      chineseVerySelectiveTagPA = true;</span>
<span class="nc" id="L1063">      i += 1;</span>
<span class="nc bnc" id="L1064" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-sunHead&quot;)) {</span>
<span class="nc" id="L1065">      sunJurafskyHeadFinder = true;</span>
<span class="nc" id="L1066">      i++;</span>
<span class="nc bnc" id="L1067" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-bikelHead&quot;)) {</span>
<span class="nc" id="L1068">      bikelHeadFinder = true;</span>
<span class="nc" id="L1069">      i++;</span>
<span class="nc bnc" id="L1070" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-discardFrags&quot;)) {</span>
<span class="nc" id="L1071">      discardFrags = true;</span>
<span class="nc" id="L1072">      i++;</span>
<span class="nc bnc" id="L1073" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-charLex&quot;)) {</span>
<span class="nc" id="L1074">      useCharacterBasedLexicon = true;</span>
<span class="nc" id="L1075">      i++;</span>
<span class="nc bnc" id="L1076" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-charUnk&quot;)) {</span>
<span class="nc" id="L1077">      useCharBasedUnknownWordModel = true;</span>
<span class="nc" id="L1078">      i++;</span>
<span class="nc bnc" id="L1079" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-rad&quot;)) {</span>
<span class="nc" id="L1080">      useUnknownCharacterModel = true;</span>
<span class="nc" id="L1081">      i++;</span>
<span class="nc bnc" id="L1082" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-lengthPenalty&quot;) &amp;&amp; (i + 1 &lt; args.length)) {</span>
<span class="nc" id="L1083">      lengthPenalty = Double.parseDouble(args[i + 1]);</span>
<span class="nc" id="L1084">      i += 2;</span>
<span class="nc bnc" id="L1085" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-penaltyType&quot;) &amp;&amp; (i + 1 &lt; args.length)) {</span>
<span class="nc" id="L1086">      penaltyType = Integer.parseInt(args[i + 1]);</span>
<span class="nc" id="L1087">      i += 2;</span>
<span class="nc bnc" id="L1088" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-gtUnknown&quot;)) {</span>
<span class="nc" id="L1089">      useGoodTuringUnknownWordModel = true;</span>
<span class="nc" id="L1090">      i++;</span>
<span class="nc bnc" id="L1091" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-maxentUnk&quot;)) {</span>
      // useMaxentUnknownWordModel = true;
<span class="nc" id="L1093">      i++;</span>
<span class="nc bnc" id="L1094" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-tuneSigma&quot;)) {</span>
      // ChineseMaxentLexicon.tuneSigma = true;
<span class="nc" id="L1096">      i++;</span>
<span class="nc bnc" id="L1097" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-trainCountThresh&quot;) &amp;&amp; (i + 1 &lt; args.length)) {</span>
      // ChineseMaxentLexicon.trainCountThreshold = Integer.parseInt(args[i + 1]);
<span class="nc" id="L1099">      i += 2;</span>
<span class="nc bnc" id="L1100" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-markCC&quot;)) {</span>
<span class="nc" id="L1101">      markCC = true;</span>
<span class="nc" id="L1102">      i++;</span>
<span class="nc bnc" id="L1103" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-segmentMarkov&quot;) || args[i].equalsIgnoreCase(&quot;-segmentWords&quot;)) {</span>
<span class="nc" id="L1104">      segment = true;</span>
<span class="nc" id="L1105">      segmentMarkov = true;</span>
<span class="nc" id="L1106">      segmenterClass = &quot;edu.stanford.nlp.parser.lexparser.ChineseMarkovWordSegmenter&quot;;</span>
<span class="nc" id="L1107">      i++;</span>
<span class="nc bnc" id="L1108" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-segmentMaxMatch&quot;)) {</span>
<span class="nc" id="L1109">      segment = true;</span>
<span class="nc" id="L1110">      segmentMarkov = false;</span>
<span class="nc" id="L1111">      segmenterClass = &quot;edu.stanford.nlp.parser.lexparser.MaxMatchSegmenter&quot;;</span>
<span class="nc" id="L1112">      i++;</span>
<span class="nc bnc" id="L1113" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-segmentDPMaxMatch&quot;)) {</span>
<span class="nc" id="L1114">      segment = true;</span>
<span class="nc" id="L1115">      segmentMarkov = false;</span>
<span class="nc" id="L1116">      segmenterClass = &quot;edu.stanford.nlp.wordseg.MaxMatchSegmenter&quot;;</span>
<span class="nc" id="L1117">      i++;</span>
<span class="nc bnc" id="L1118" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-maxentLex&quot;)) {</span>
      // useMaxentLexicon = true;
<span class="nc" id="L1120">      i++;</span>
<span class="nc bnc" id="L1121" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-fixUnkFunctionWords&quot;)) {</span>
      // ChineseMaxentLexicon.fixUnkFunctionWords = true;
<span class="nc" id="L1123">      i++;</span>
<span class="nc bnc" id="L1124" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-similarWordSmoothing&quot;)) {</span>
<span class="nc" id="L1125">      useSimilarWordMap = true;</span>
<span class="nc" id="L1126">      i++;</span>
<span class="nc bnc" id="L1127" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-maxentLexSeenTagsOnly&quot;)) {</span>
      // useMaxentLexicon = true;
      // ChineseMaxentLexicon.seenTagsOnly = true;
<span class="nc" id="L1130">      i++;</span>
<span class="nc bnc" id="L1131" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-maxentLexFeatLevel&quot;) &amp;&amp; (i + 1 &lt; args.length)) {</span>
      // ChineseMaxentLexicon.featureLevel = Integer.parseInt(args[i + 1]);
<span class="nc" id="L1133">      i += 2;</span>
<span class="nc bnc" id="L1134" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-maxentDepGrammarFeatLevel&quot;) &amp;&amp; (i + 1 &lt; args.length)) {</span>
<span class="nc" id="L1135">      depGramFeatureLevel = Integer.parseInt(args[i + 1]);</span>
<span class="nc" id="L1136">      i += 2;</span>
<span class="nc bnc" id="L1137" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-maxentDepGrammar&quot;)) {</span>
      // useMaxentDepGrammar = true;
<span class="nc" id="L1139">      i++;</span>
<span class="nc bnc" id="L1140" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-splitNPTMP&quot;)) {</span>
<span class="nc" id="L1141">      splitNPTMP = true;</span>
<span class="nc" id="L1142">      i++;</span>
<span class="nc bnc" id="L1143" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-splitPPTMP&quot;)) {</span>
<span class="nc" id="L1144">      splitPPTMP = true;</span>
<span class="nc" id="L1145">      i++;</span>
<span class="nc bnc" id="L1146" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-splitXPTMP&quot;)) {</span>
<span class="nc" id="L1147">      splitXPTMP = true;</span>
<span class="nc" id="L1148">      i++;</span>
<span class="nc bnc" id="L1149" title="All 2 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-segmenter&quot;)) {</span>
<span class="nc" id="L1150">      segment = true;</span>
<span class="nc" id="L1151">      segmentMarkov = false;</span>
<span class="nc" id="L1152">      segmenterClass = args[i + 1];</span>
<span class="nc" id="L1153">      i += 2;</span>
<span class="nc bnc" id="L1154" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-headFinder&quot;) &amp;&amp; (i + 1 &lt; args.length)) {</span>
      try {
<span class="nc" id="L1156">        headFinder = (HeadFinder) Class.forName(args[i + 1]).newInstance();</span>
<span class="nc" id="L1157">      } catch (Exception e) {</span>
<span class="nc" id="L1158">        log.info(e);</span>
<span class="nc" id="L1159">        log.info(this.getClass().getName() + &quot;: Could not load head finder &quot; + args[i + 1]);</span>
<span class="nc" id="L1160">        throw new RuntimeException(e);</span>
<span class="nc" id="L1161">      }</span>
<span class="nc" id="L1162">      i+=2;</span>
    }

<span class="nc" id="L1165">    return i;</span>
  }

<span class="fc" id="L1168">  private int depGramFeatureLevel = 0;</span>

  @Override
  public Extractor&lt;DependencyGrammar&gt; dependencyGrammarExtractor(final Options op, Index&lt;String&gt; wordIndex, Index&lt;String&gt; tagIndex) {
    /* ----------
    if (useMaxentDepGrammar) {
      return new Extractor() {
        public Object extract(Collection&lt;Tree&gt; trees) {
          ChineseWordFeatureExtractor wfe = new ChineseWordFeatureExtractor(trees);
          ChineseWordFeatureExtractor wfe2 = new ChineseWordFeatureExtractor(trees);
          wfe.setFeatureLevel(2);
          wfe2.turnOffWordFeatures = true;
          wfe2.setFeatureLevel(depGramFeatureLevel);
          MaxentDependencyGrammar dg = new MaxentDependencyGrammar(op.tlpParams, wfe, wfe2, true, false, false);
          dg.train(trees);
          return dg;
        }

        public Object extract(Iterator&lt;Tree&gt; iterator, Function&lt;Tree, Tree&gt; f) {
          throw new UnsupportedOperationException();
        }
      };
    } else ------- */
<span class="nc bnc" id="L1191" title="All 2 branches missed.">    if (useSimilarWordMap) {</span>
<span class="nc" id="L1192">      return new MLEDependencyGrammarExtractor(op, wordIndex, tagIndex) {</span>
        @Override
        public MLEDependencyGrammar formResult() {
<span class="nc" id="L1195">          wordIndex.addToIndex(Lexicon.UNKNOWN_WORD);</span>
<span class="nc" id="L1196">          ChineseSimWordAvgDepGrammar dg = new ChineseSimWordAvgDepGrammar(tlpParams, directional, useDistance, useCoarseDistance, op.trainOptions.basicCategoryTagsInDependencyGrammar, op, wordIndex, tagIndex);</span>
<span class="nc bnc" id="L1197" title="All 2 branches missed.">          if (lex == null) {</span>
<span class="nc" id="L1198">            throw new RuntimeException(&quot;Attempt to create ChineseSimWordAvgDepGrammar before Lexicon!!!&quot;);</span>
          } else {
<span class="nc" id="L1200">            dg.setLex(lex);</span>
          }
<span class="nc bnc" id="L1202" title="All 2 branches missed.">          for (IntDependency dependency : dependencyCounter.keySet()) {</span>
<span class="nc" id="L1203">            dg.addRule(dependency, dependencyCounter.getCount(dependency));</span>
<span class="nc" id="L1204">          }</span>
<span class="nc" id="L1205">          return dg;</span>
        }

     };
    } else {
<span class="nc" id="L1210">      return new MLEDependencyGrammarExtractor(op, wordIndex, tagIndex);</span>
    }
  }

  /**
   * Return a default sentence for the language (for testing)
   */
  @Override
  public ArrayList&lt;Word&gt; defaultTestSentence() {
<span class="nc" id="L1219">    return SentenceUtils.toUntaggedList(&quot;\u951f\u65a4\u62f7&quot;, &quot;\u951f\u65a4\u62f7&quot;, &quot;\u5b66\u6821&quot;, &quot;\u951f\u65a4\u62f7&quot;, &quot;\u5b66\u4e60&quot;, &quot;\u951f\u65a4\u62f7&quot;);</span>
  }


  private static final long serialVersionUID = 2;


  @Override
  public List&lt;GrammaticalStructure&gt;
    readGrammaticalStructureFromFile(String filename)
  {
    try {
<span class="nc bnc" id="L1231" title="All 2 branches missed.">      if (this.generateOriginalDependencies()) {</span>
<span class="nc" id="L1232">        return ChineseGrammaticalStructure.</span>
<span class="nc" id="L1233">            readCoNLLXGrammaticalStructureCollection(filename);</span>
      } else {
<span class="nc" id="L1235">        return UniversalChineseGrammaticalStructure.</span>
<span class="nc" id="L1236">            readCoNLLXGrammaticalStructureCollection(filename);</span>
      }
<span class="nc" id="L1238">    } catch (IOException e) {</span>
<span class="nc" id="L1239">      throw new RuntimeIOException(e);</span>
    }
  }

  @Override
  public GrammaticalStructure getGrammaticalStructure(Tree t,
                                                      Predicate&lt;String&gt; filter,
                                                      HeadFinder hf) {
<span class="nc bnc" id="L1247" title="All 2 branches missed.">    if (this.generateOriginalDependencies()) {</span>
<span class="nc" id="L1248">      return new ChineseGrammaticalStructure(t, filter, hf);</span>
    } else {
<span class="nc" id="L1250">      return new UniversalChineseGrammaticalStructure(t, filter, hf);</span>
    }
  }

  @Override
  public boolean supportsBasicDependencies() {
<span class="nc" id="L1256">    return true;</span>
  }

  @Override
  public boolean generateOriginalDependencies() {
<span class="nc" id="L1261">    return generateOriginalDependencies;</span>
  }

  /**
   * For testing: loads a treebank and prints the trees.
   */
  public static void main(String[] args) {
<span class="nc" id="L1268">    TreebankLangParserParams tlpp = new ChineseTreebankParserParams();</span>
<span class="nc" id="L1269">    System.out.println(&quot;Default encoding is: &quot; +</span>
<span class="nc" id="L1270">                       tlpp.diskTreebank().encoding());</span>

<span class="nc bnc" id="L1272" title="All 2 branches missed.">    if (args.length &lt; 2) {</span>
<span class="nc" id="L1273">      printlnErr(&quot;Usage: edu.stanford.nlp.parser.lexparser.ChineseTreebankParserParams treesPath fileRange&quot;);</span>
    } else {
<span class="nc" id="L1275">      Treebank m = tlpp.diskTreebank();</span>
<span class="nc" id="L1276">      m.loadPath(args[0], new NumberRangesFileFilter(args[1], false));</span>

<span class="nc bnc" id="L1278" title="All 2 branches missed.">      for (Tree t : m ) {</span>
<span class="nc" id="L1279">        t.pennPrint(tlpp.pw());</span>
<span class="nc" id="L1280">      }</span>
<span class="nc" id="L1281">      System.out.println(&quot;There were &quot; + m.size() + &quot; trees.&quot;);</span>
    }
<span class="nc" id="L1283">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>