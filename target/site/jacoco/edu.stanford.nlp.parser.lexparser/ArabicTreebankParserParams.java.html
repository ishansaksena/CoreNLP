<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ArabicTreebankParserParams.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.parser.lexparser</a> &gt; <span class="el_source">ArabicTreebankParserParams.java</span></div><h1>ArabicTreebankParserParams.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.parser.lexparser; 
import edu.stanford.nlp.util.logging.Redwood;

import java.util.*;
import java.util.regex.*;

import edu.stanford.nlp.international.arabic.ArabicMorphoFeatureSpecification;
import edu.stanford.nlp.international.morph.MorphoFeatureSpecification;
import edu.stanford.nlp.international.morph.MorphoFeatureSpecification.MorphoFeatureType;
import edu.stanford.nlp.international.morph.MorphoFeatures;
import edu.stanford.nlp.ling.*;
import edu.stanford.nlp.ling.SentenceUtils;
import edu.stanford.nlp.process.SerializableFunction;
import edu.stanford.nlp.trees.*;
import edu.stanford.nlp.trees.international.arabic.*;
import edu.stanford.nlp.trees.tregex.*;
import java.util.function.Function;
import edu.stanford.nlp.util.Generics;
import edu.stanford.nlp.util.Index;
import edu.stanford.nlp.util.Pair;

/**
 * A {@link TreebankLangParserParams} implementing class for
 * the Penn Arabic Treebank.  The baseline feature set works with either
 * UTF-8 or Buckwalter input, although the behavior of some unused features depends
 * on the input encoding.
 *
 * @author Roger Levy
 * @author Christopher Manning
 * @author Spence Green
 */
public class ArabicTreebankParserParams extends AbstractTreebankParserParams  {

  /** A logger for this class */
<span class="fc" id="L35">  private static Redwood.RedwoodChannels log = Redwood.channels(ArabicTreebankParserParams.class);</span>

  private static final long serialVersionUID = 8853426784197984653L;

  private final StringBuilder optionsString;

<span class="fc" id="L41">  private boolean retainNPTmp = false;</span>
<span class="fc" id="L42">  private boolean retainNPSbj = false;</span>
<span class="fc" id="L43">  private boolean retainPRD = false;</span>
<span class="fc" id="L44">  private boolean retainPPClr = false;</span>
<span class="fc" id="L45">  private boolean changeNoLabels = false;</span>
<span class="fc" id="L46">  private boolean collinizerRetainsPunctuation = false;</span>
<span class="fc" id="L47">  private boolean discardX = false;</span>

  private HeadFinder headFinder;
  private final Map&lt;String,Pair&lt;TregexPattern,Function&lt;TregexMatcher,String&gt;&gt;&gt; annotationPatterns;
  private final List&lt;Pair&lt;TregexPattern,Function&lt;TregexMatcher,String&gt;&gt;&gt; activeAnnotations;

<span class="fc" id="L53">  private static final String[] EMPTY_STRING_ARRAY = new String[0];</span>

<span class="fc" id="L55">  private MorphoFeatureSpecification morphoSpec = null;</span>
  
  public ArabicTreebankParserParams() {
<span class="fc" id="L58">    super(new ArabicTreebankLanguagePack());</span>

<span class="fc" id="L60">    optionsString = new StringBuilder();</span>
<span class="fc" id="L61">    optionsString.append(&quot;ArabicTreebankParserParams\n&quot;);</span>

<span class="fc" id="L63">    annotationPatterns = Generics.newHashMap();</span>
<span class="fc" id="L64">    activeAnnotations = new ArrayList&lt;&gt;();</span>

    //Initialize the headFinder here
<span class="fc" id="L67">    headFinder = headFinder();</span>

<span class="fc" id="L69">    initializeAnnotationPatterns();</span>
<span class="fc" id="L70">  }</span>

  /**
   * Creates an {@link ArabicTreeReaderFactory} with parameters set
   * via options passed in from the command line.
   *
   * @return An {@link ArabicTreeReaderFactory}
   */
  public TreeReaderFactory treeReaderFactory() {
<span class="nc" id="L79">    return new ArabicTreeReaderFactory(retainNPTmp, retainPRD,</span>
        changeNoLabels, discardX,
        retainNPSbj, false, retainPPClr);
  }

  //NOTE (WSG): This method is called by main() to load the test treebank
  @Override
  public MemoryTreebank memoryTreebank() {
<span class="nc" id="L87">    return new MemoryTreebank(treeReaderFactory(), inputEncoding);</span>
  }

  //NOTE (WSG): This method is called to load the training treebank
  @Override
  public DiskTreebank diskTreebank() {
<span class="nc" id="L93">    return new DiskTreebank(treeReaderFactory(), inputEncoding);</span>
  }

  @Override
  public HeadFinder headFinder() {
<span class="fc bfc" id="L98" title="All 2 branches covered.">    if(headFinder == null)</span>
<span class="fc" id="L99">      headFinder = new ArabicHeadFinder(treebankLanguagePack());</span>
<span class="fc" id="L100">    return headFinder;</span>
  }

  @Override
  public HeadFinder typedDependencyHeadFinder() {
<span class="nc" id="L105">    return headFinder();</span>
  }


  /**
   * Returns a lexicon for Arabic.  At the moment this is just a BaseLexicon.
   *
   * @param op Lexicon options
   * @return A Lexicon
   */
  @Override
  public Lexicon lex(Options op, Index&lt;String&gt; wordIndex, Index&lt;String&gt; tagIndex) {
<span class="nc bnc" id="L117" title="All 2 branches missed.">    if(op.lexOptions.uwModelTrainer == null) {</span>
<span class="nc" id="L118">      op.lexOptions.uwModelTrainer = &quot;edu.stanford.nlp.parser.lexparser.ArabicUnknownWordModelTrainer&quot;;</span>
    }
<span class="nc bnc" id="L120" title="All 2 branches missed.">    if(morphoSpec != null) {</span>
<span class="nc" id="L121">      return new FactoredLexicon(op, morphoSpec, wordIndex, tagIndex);</span>
    }
<span class="nc" id="L123">    return new BaseLexicon(op, wordIndex, tagIndex);</span>
  }

  /**
   * Return a default sentence for the language (for testing).
   * The example is in UTF-8.
   */
  public List&lt;? extends HasWord&gt; defaultTestSentence() {
<span class="nc" id="L131">    String[] sent = {&quot;هو&quot;,&quot;استنكر&quot;,&quot;الحكومة&quot;,&quot;يوم&quot;,&quot;امس&quot;,&quot;.&quot;};</span>
<span class="nc" id="L132">    return SentenceUtils.toWordList(sent);</span>
  }

<span class="nc" id="L135">  protected class ArabicSubcategoryStripper implements TreeTransformer {</span>

<span class="nc" id="L137">    protected final TreeFactory tf = new LabeledScoredTreeFactory();</span>

    public Tree transformTree(Tree tree) {
<span class="nc" id="L140">      Label lab = tree.label();</span>
<span class="nc" id="L141">      String s = lab.value();</span>

<span class="nc bnc" id="L143" title="All 2 branches missed.">      if (tree.isLeaf()) {</span>
<span class="nc" id="L144">        Tree leaf = tf.newLeaf(lab);</span>
<span class="nc" id="L145">        leaf.setScore(tree.score());</span>
<span class="nc" id="L146">        return leaf;</span>

<span class="nc bnc" id="L148" title="All 2 branches missed.">      } else if(tree.isPhrasal()) {</span>
<span class="nc bnc" id="L149" title="All 4 branches missed.">        if(retainNPTmp &amp;&amp; s.startsWith(&quot;NP-TMP&quot;)) {</span>
<span class="nc" id="L150">          s = &quot;NP-TMP&quot;;</span>
<span class="nc bnc" id="L151" title="All 4 branches missed.">        } else if(retainNPSbj &amp;&amp; s.startsWith(&quot;NP-SBJ&quot;)) {</span>
<span class="nc" id="L152">          s = &quot;NP-SBJ&quot;;</span>
<span class="nc bnc" id="L153" title="All 4 branches missed.">        } else if(retainPRD &amp;&amp; s.matches(&quot;VB[^P].*PRD.*&quot;)) {</span>
<span class="nc" id="L154">          s = tlp.basicCategory(s);</span>
<span class="nc" id="L155">          s += &quot;-PRD&quot;;</span>
        } else {
<span class="nc" id="L157">          s = tlp.basicCategory(s);</span>
        }

<span class="nc bnc" id="L160" title="All 2 branches missed.">      } else if(tree.isPreTerminal()) {</span>
<span class="nc" id="L161">        s = tlp.basicCategory(s);</span>

      } else {
<span class="nc" id="L164">        System.err.printf(&quot;Encountered a non-leaf/phrasal/pre-terminal node %s\n&quot;,s);</span>
        //Normalize by default
<span class="nc" id="L166">        s = tlp.basicCategory(s);</span>
      }

      // Recursively process children depth-first
<span class="nc" id="L170">      List&lt;Tree&gt; children = new ArrayList&lt;&gt;(tree.numChildren());</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">      for (Tree child : tree.getChildrenAsList()) {</span>
<span class="nc" id="L172">        Tree newChild = transformTree(child);</span>
<span class="nc" id="L173">        children.add(newChild);</span>
<span class="nc" id="L174">      }</span>

      // Make the new parent label
<span class="nc" id="L177">      Tree node = tf.newTreeNode(lab, children);</span>
<span class="nc" id="L178">      node.setValue(s);</span>
<span class="nc" id="L179">      node.setScore(tree.score());</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">      if(node.label() instanceof HasTag)</span>
<span class="nc" id="L181">        ((HasTag) node.label()).setTag(s);</span>

<span class="nc" id="L183">      return node;</span>
    }
  }

  /**
   * Returns a TreeTransformer that retains categories
   * according to the following options supported by setOptionFlag:
   * &lt;p&gt;
   * &lt;code&gt;-retainNPTmp&lt;/code&gt; Retain temporal NP marking on NPs.
   * &lt;code&gt;-retainNPSbj&lt;/code&gt; Retain NP subject function tags
   * &lt;code&gt;-markPRDverbs&lt;/code&gt; Retain PRD verbs.
   * &lt;/p&gt;
   */
  //NOTE (WSG): This is applied to both the best parse by getBestParse()
  //and to the gold eval tree by testOnTreebank()
  @Override
  public TreeTransformer subcategoryStripper() {
<span class="nc" id="L200">    return new ArabicSubcategoryStripper();</span>
  }


  /**
   * The collinizer eliminates punctuation
   */
  @Override
  public TreeTransformer collinizer() {
<span class="nc bnc" id="L209" title="All 2 branches missed.">    return new TreeCollinizer(tlp, !collinizerRetainsPunctuation, false);</span>
  }

  /**
   * Stand-in collinizer does nothing to the tree.
   */
  @Override
  public TreeTransformer collinizerEvalb() {
<span class="nc" id="L217">    return collinizer();</span>
  }

  @Override
  public String[] sisterSplitters() {
<span class="nc" id="L222">    return EMPTY_STRING_ARRAY;</span>
  }

  // WSGDEBUG -- Annotate POS tags with nominal (grammatical) gender
<span class="fc" id="L226">  private static final MorphoFeatureSpecification tagSpec = new ArabicMorphoFeatureSpecification();</span>
  static {
<span class="fc" id="L228">    tagSpec.activate(MorphoFeatureType.NGEN);</span>
<span class="fc" id="L229">  }</span>
  
  @Override
  public Tree transformTree(Tree t, Tree root) {

<span class="nc" id="L234">    String baseCat = t.value();</span>
<span class="nc" id="L235">    StringBuilder newCategory = new StringBuilder();</span>

    //Add manual state splits
<span class="nc bnc" id="L238" title="All 2 branches missed.">    for (Pair&lt;TregexPattern,Function&lt;TregexMatcher,String&gt;&gt; e : activeAnnotations) {</span>
<span class="nc" id="L239">      TregexMatcher m = e.first().matcher(root);</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">      if (m.matchesAt(t))</span>
<span class="nc" id="L241">        newCategory.append(e.second().apply(m));</span>
<span class="nc" id="L242">    }</span>

    // WSGDEBUG
    //Add morphosyntactic features if this is a POS tag
<span class="nc bnc" id="L246" title="All 4 branches missed.">    if(t.isPreTerminal() &amp;&amp; tagSpec != null) {</span>
<span class="nc bnc" id="L247" title="All 4 branches missed.">      if( !(t.firstChild().label() instanceof CoreLabel) || ((CoreLabel) t.firstChild().label()).originalText() == null )</span>
<span class="nc" id="L248">        throw new RuntimeException(String.format(&quot;%s: Term lacks morpho analysis: %s&quot;,this.getClass().getName(),t.toString()));</span>

<span class="nc" id="L250">      String morphoStr = ((CoreLabel) t.firstChild().label()).originalText();</span>
<span class="nc" id="L251">      MorphoFeatures feats = tagSpec.strToFeatures(morphoStr);</span>
<span class="nc" id="L252">      baseCat = feats.getTag(baseCat);</span>
    }

    //Update the label(s)
<span class="nc" id="L256">    String newCat = baseCat + newCategory.toString();</span>
<span class="nc" id="L257">    t.setValue(newCat);</span>
<span class="nc bnc" id="L258" title="All 4 branches missed.">    if (t.isPreTerminal() &amp;&amp; t.label() instanceof HasTag)</span>
<span class="nc" id="L259">      ((HasTag) t.label()).setTag(newCat);</span>

<span class="nc" id="L261">    return t;</span>
  }

  /**
   * These are the annotations included when the user selects the -arabicFactored option.
   */
<span class="fc" id="L267">  private final List&lt;String&gt; baselineFeatures = new ArrayList&lt;&gt;();</span>
  {
<span class="fc" id="L269">    baselineFeatures.add(&quot;-markNounNPargTakers&quot;);</span>
<span class="fc" id="L270">    baselineFeatures.add(&quot;-genitiveMark&quot;);</span>
<span class="fc" id="L271">    baselineFeatures.add(&quot;-splitPUNC&quot;);</span>
<span class="fc" id="L272">    baselineFeatures.add(&quot;-markContainsVerb&quot;);</span>
<span class="fc" id="L273">    baselineFeatures.add(&quot;-markStrictBaseNP&quot;);</span>
<span class="fc" id="L274">    baselineFeatures.add(&quot;-markOneLevelIdafa&quot;);</span>
<span class="fc" id="L275">    baselineFeatures.add(&quot;-splitIN&quot;);</span>
<span class="fc" id="L276">    baselineFeatures.add(&quot;-markMasdarVP&quot;);</span>
<span class="fc" id="L277">    baselineFeatures.add(&quot;-containsSVO&quot;);</span>
<span class="fc" id="L278">    baselineFeatures.add(&quot;-splitCC&quot;);</span>
<span class="fc" id="L279">    baselineFeatures.add(&quot;-markFem&quot;);</span>
    
    // Added for MWE experiments
<span class="fc" id="L282">    baselineFeatures.add(&quot;-mwe&quot;);</span>
<span class="fc" id="L283">    baselineFeatures.add(&quot;-mweContainsVerb&quot;);</span>
  }
<span class="fc" id="L285">  private final List&lt;String&gt; additionalFeatures = new ArrayList&lt;&gt;();</span>

  private void initializeAnnotationPatterns() {
    //This doesn't/can't really pick out genitives, but just any NP following an NN head.
    //wsg2011: In particular, it doesn't select NP complements of PPs, which are also genitive.
<span class="fc" id="L290">    final String genitiveNodeTregexString = &quot;@NP &gt; @NP $- /^N/&quot;;</span>

<span class="fc" id="L292">    TregexPatternCompiler tregexPatternCompiler =</span>
<span class="fc" id="L293">      new TregexPatternCompiler(headFinder());</span>

    try {
      // ******************
      // Baseline features
      // ******************
<span class="fc" id="L299">      annotationPatterns.put(&quot;-genitiveMark&quot;, new Pair&lt;&gt;(TregexPattern.compile(genitiveNodeTregexString), new SimpleStringFunction(&quot;-genitive&quot;)));</span>
<span class="fc" id="L300">      annotationPatterns.put(&quot;-markStrictBaseNP&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;@NP !&lt; (__ &lt; (__ &lt; __))&quot;), new SimpleStringFunction(&quot;-base&quot;))); // NP with no phrasal node in it</span>
<span class="fc" id="L301">      annotationPatterns.put(&quot;-markOneLevelIdafa&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;@NP &lt; (@NP &lt; (__ &lt; __)) !&lt; (/^[^N]/ &lt; (__ &lt; __)) !&lt; (__ &lt; (__ &lt; (__ &lt; __)))&quot;), new SimpleStringFunction(&quot;-idafa1&quot;)));</span>
<span class="fc" id="L302">      annotationPatterns.put(&quot;-markNounNPargTakers&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;@NN|NNS|NNP|NNPS|DTNN|DTNNS|DTNNP|DTNNPS &gt;# (@NP &lt; @NP)&quot;), new SimpleStringFunction(&quot;-NounNParg&quot;)));</span>
<span class="fc" id="L303">      annotationPatterns.put(&quot;-markContainsVerb&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;__ &lt;&lt; (/^[CIP]?V/ &lt; (__ !&lt; __))&quot;), new SimpleStringFunction(&quot;-withV&quot;)));</span>
<span class="fc" id="L304">      annotationPatterns.put(&quot;-splitIN&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;@IN &lt; __=word&quot;), new AddRelativeNodeFunction(&quot;-&quot;, &quot;word&quot;, false)));</span>
<span class="fc" id="L305">      annotationPatterns.put(&quot;-splitPUNC&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;@PUNC &lt; __=&quot; + AnnotatePunctuationFunction2.key), new AnnotatePunctuationFunction2()));</span>
<span class="fc" id="L306">      annotationPatterns.put(&quot;-markMasdarVP&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;@VP|MWVP &lt; /VBG|VN/&quot;), new SimpleStringFunction(&quot;-masdar&quot;)));</span>
<span class="fc" id="L307">      annotationPatterns.put(&quot;-containsSVO&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;__ &lt;&lt; (@S &lt; (@NP . @VP|MWVP))&quot;), new SimpleStringFunction(&quot;-hasSVO&quot;)));</span>
<span class="fc" id="L308">      annotationPatterns.put(&quot;-splitCC&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;@CC|CONJ . __=term , __&quot;), new AddEquivalencedConjNode(&quot;-&quot;, &quot;term&quot;)));</span>
<span class="fc" id="L309">      annotationPatterns.put(&quot;-markFem&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;__ &lt; /ة$/&quot;), new SimpleStringFunction(&quot;-fem&quot;)));</span>
      
      // Added for MWE experiments
<span class="fc" id="L312">      annotationPatterns.put(&quot;-mwe&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;__ &gt; /MW/=tag&quot;), new AddRelativeNodeFunction(&quot;-&quot;, &quot;tag&quot;, true)));</span>
<span class="fc" id="L313">      annotationPatterns.put(&quot;-mweContainsVerb&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;__ &lt;&lt; @MWVP&quot;), new SimpleStringFunction(&quot;-withV&quot;)));</span>

      //This version, which uses the PTB equivalence classing, results in slightly lower labeled F1
      //than the splitPUNC feature above, which was included in the COLING2010 evaluation
<span class="fc" id="L317">      annotationPatterns.put(&quot;-splitPUNC2&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;@PUNC &lt; __=punc&quot;), new AnnotatePunctuationFunction(&quot;-&quot;, &quot;punc&quot;)));</span>

      // Label each POS with its parent
<span class="fc" id="L320">      annotationPatterns.put(&quot;-tagPAar&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;!@PUNC &lt; (__ !&lt; __) &gt; __=parent&quot;), new AddRelativeNodeFunction(&quot;-&quot;, &quot;parent&quot;, true)));</span>

      //Didn't work
<span class="fc" id="L323">      annotationPatterns.put(&quot;-splitCC1&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;@CC|CONJ &lt; __=term&quot;), new AddRelativeNodeRegexFunction(&quot;-&quot;, &quot;term&quot;, &quot;-*([^-].*)&quot;)));</span>
<span class="fc" id="L324">      annotationPatterns.put(&quot;-splitCC2&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;@CC . __=term , __&quot;), new AddRelativeNodeFunction(&quot;-&quot;, &quot;term&quot;, true)));</span>
<span class="fc" id="L325">      annotationPatterns.put(&quot;-idafaJJ1&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;@NP &lt;, (@NN $+ @NP) &lt;+(@NP) @ADJP&quot;), new SimpleStringFunction(&quot;-idafaJJ&quot;)));</span>
<span class="fc" id="L326">      annotationPatterns.put(&quot;-idafaJJ2&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;@NP &lt;, (@NN $+ @NP) &lt;+(@NP) @ADJP !&lt;&lt; @SBAR&quot;), new SimpleStringFunction(&quot;-idafaJJ&quot;)));</span>

<span class="fc" id="L328">      annotationPatterns.put(&quot;-properBaseNP&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;@NP !&lt;&lt; @NP &lt; /NNP/ !&lt; @PUNC|CD&quot;), new SimpleStringFunction(&quot;-prop&quot;)));</span>
<span class="fc" id="L329">      annotationPatterns.put(&quot;-interrog&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;__ &lt;&lt; هل|ماذا|لماذا|اين|متى&quot;), new SimpleStringFunction(&quot;-inter&quot;)));</span>
<span class="fc" id="L330">      annotationPatterns.put(&quot;-splitPseudo&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;@NN &lt; مع|بعد|بين&quot;), new SimpleStringFunction(&quot;-pseudo&quot;)));</span>
<span class="fc" id="L331">      annotationPatterns.put(&quot;-nPseudo&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;@NP &lt; (@NN &lt; مع|بعد|بين)&quot;), new SimpleStringFunction(&quot;-npseudo&quot;)));</span>
<span class="fc" id="L332">      annotationPatterns.put(&quot;-pseudoArg&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;@NP &lt; @NP $, (@NN &lt; مع|بعد|بين)&quot;), new SimpleStringFunction(&quot;-pseudoArg&quot;)));</span>
<span class="fc" id="L333">      annotationPatterns.put(&quot;-eqL1&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;__ &lt; (@S !&lt; @VP|S)&quot;), new SimpleStringFunction(&quot;-haseq&quot;)));</span>
<span class="fc" id="L334">      annotationPatterns.put(&quot;-eqL1L2&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;__ &lt; (__ &lt; (@S !&lt; @VP|S)) | &lt; (@S !&lt; @VP|S)&quot;), new SimpleStringFunction(&quot;-haseq&quot;)));</span>
<span class="fc" id="L335">      annotationPatterns.put(&quot;-fullQuote&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;__ &lt; ((@PUNC &lt; \&quot;) $ (@PUNC &lt; \&quot;))&quot;), new SimpleStringFunction(&quot;-fq&quot;)));</span>
<span class="fc" id="L336">      annotationPatterns.put(&quot;-brokeQuote&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;__ &lt; ((@PUNC &lt; \&quot;) !$ (@PUNC &lt; \&quot;))&quot;), new SimpleStringFunction(&quot;-bq&quot;)));</span>
<span class="fc" id="L337">      annotationPatterns.put(&quot;-splitVP&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;@VP &lt;# __=term1&quot;), new AddRelativeNodeFunction(&quot;-&quot;, &quot;term1&quot;, true)));</span>
<span class="fc" id="L338">      annotationPatterns.put(&quot;-markFemP&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;@NP|ADJP &lt; (__ &lt; /ة$/)&quot;), new SimpleStringFunction(&quot;-femP&quot;)));</span>
<span class="fc" id="L339">      annotationPatterns.put(&quot;-embedSBAR&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;@NP|PP &lt;+(@NP|PP) @SBAR&quot;), new SimpleStringFunction(&quot;-embedSBAR&quot;)));</span>
<span class="fc" id="L340">      annotationPatterns.put(&quot;-complexVP&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;__ &lt;&lt; (@VP &lt; (@NP $ @NP)) &gt; __&quot;), new SimpleStringFunction(&quot;-complexVP&quot;)));</span>
<span class="fc" id="L341">      annotationPatterns.put(&quot;-containsJJ&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;@NP &lt;+(@NP) /JJ/&quot;), new SimpleStringFunction(&quot;-hasJJ&quot;)));</span>
<span class="fc" id="L342">      annotationPatterns.put(&quot;-markMasdarVP2&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;__ &lt;&lt; @VN|VBG&quot;), new SimpleStringFunction(&quot;-masdar&quot;)));</span>
<span class="fc" id="L343">      annotationPatterns.put(&quot;-coordNP&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;@NP|ADJP &lt;+(@NP|ADJP) (@CC|PUNC $- __ $+ __)&quot;), new SimpleStringFunction(&quot;-coordNP&quot;)));</span>
<span class="fc" id="L344">      annotationPatterns.put(&quot;-coordWa&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;__ &lt;&lt; (@CC , __ &lt; و-)&quot;), new SimpleStringFunction(&quot;-coordWA&quot;)));</span>
<span class="fc" id="L345">      annotationPatterns.put(&quot;-NPhasADJP&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;@NP &lt;+(@NP) @ADJP&quot;), new SimpleStringFunction(&quot;-NPhasADJP&quot;)));</span>
<span class="fc" id="L346">      annotationPatterns.put(&quot;-NPADJP&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;@NP &lt; @ADJP&quot;), new SimpleStringFunction(&quot;-npadj&quot;)));</span>
<span class="fc" id="L347">      annotationPatterns.put(&quot;-NPJJ&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;@NP &lt; /JJ/&quot;), new SimpleStringFunction(&quot;-npjj&quot;)));</span>
<span class="fc" id="L348">      annotationPatterns.put(&quot;-NPCC&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;@NP &lt;+(@NP) @CC&quot;), new SimpleStringFunction(&quot;-npcc&quot;)));</span>
<span class="fc" id="L349">      annotationPatterns.put(&quot;-NPCD&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;@NP &lt; @CD&quot;), new SimpleStringFunction(&quot;-npcd&quot;)));</span>
<span class="fc" id="L350">      annotationPatterns.put(&quot;-NPNNP&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;@NP &lt; /NNP/&quot;), new SimpleStringFunction(&quot;-npnnp&quot;)));</span>
<span class="fc" id="L351">      annotationPatterns.put(&quot;-SVO&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;@S &lt; (@NP . @VP)&quot;), new SimpleStringFunction(&quot;-svo&quot;)));</span>
<span class="fc" id="L352">      annotationPatterns.put(&quot;-containsSBAR&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;__ &lt;&lt; @SBAR&quot;), new SimpleStringFunction(&quot;-hasSBAR&quot;)));</span>


      //WSGDEBUG - Template
      //annotationPatterns.put(&quot;&quot;, new Pair&lt;TregexPattern,Function&lt;TregexMatcher,String&gt;&gt;(tregexPatternCompiler.compile(&quot;&quot;), new SimpleStringFunction(&quot;&quot;)));


      // ************
      // Old and unused features (in various states of repair)
      // *************
<span class="fc" id="L362">      annotationPatterns.put(&quot;-markGappedVP&quot;, new Pair&lt;&gt;(TregexPattern.compile(&quot;@VP &gt; @VP $- __ $ /^(?:CC|CONJ)/ !&lt; /^V/&quot;), new SimpleStringFunction(&quot;-gappedVP&quot;)));</span>
<span class="fc" id="L363">      annotationPatterns.put(&quot;-markGappedVPConjoiners&quot;, new Pair&lt;&gt;(TregexPattern.compile(&quot;/^(?:CC|CONJ)/ $ (@VP &gt; @VP $- __ !&lt; /^V/)&quot;), new SimpleStringFunction(&quot;-gappedVP&quot;)));</span>
<span class="fc" id="L364">      annotationPatterns.put(&quot;-markGenitiveParent&quot;, new Pair&lt;&gt;(TregexPattern.compile(&quot;@NP &lt; (&quot; + genitiveNodeTregexString + ')'), new SimpleStringFunction(&quot;-genitiveParent&quot;)));</span>
      // maSdr: this pattern is just a heuristic classification, which matches on
      // various common maSdr pattterns, but probably also matches on a lot of other
      // stuff.  It marks NPs with possible maSdr.
      // Roger's old pattern:
<span class="fc" id="L369">      annotationPatterns.put(&quot;-maSdrMark&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;/^N/ &lt;&lt;# (/^[t\\u062a].+[y\\u064a].$/ &gt; @NN|NOUN|DTNN)&quot;), new SimpleStringFunction(&quot;-maSdr&quot;)));</span>
      // chris' attempt
<span class="fc" id="L371">      annotationPatterns.put(&quot;-maSdrMark2&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;/^N/ &lt;&lt;# (/^(?:[t\\u062a].+[y\\u064a].|&lt;.{3,}|A.{3,})$/ &gt; @NN|NOUN|DTNN)&quot;), new SimpleStringFunction(&quot;-maSdr&quot;)));</span>
<span class="fc" id="L372">      annotationPatterns.put(&quot;-maSdrMark3&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;/^N/ &lt;&lt;# (/^(?:[t\\u062a&lt;A].{3,})$/ &gt; @NN|NOUN|DTNN)&quot;), new SimpleStringFunction(&quot;-maSdr&quot;)));</span>
<span class="fc" id="L373">      annotationPatterns.put(&quot;-maSdrMark4&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;/^N/ &lt;&lt;# (/^(?:[t\\u062a&lt;A].{3,})$/ &gt; (@NN|NOUN|DTNN &gt; (@NP &lt; @NP)))&quot;), new SimpleStringFunction(&quot;-maSdr&quot;)));</span>
<span class="fc" id="L374">      annotationPatterns.put(&quot;-maSdrMark5&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;/^N/ &lt;&lt;# (__ &gt; (@NN|NOUN|DTNN &gt; (@NP &lt; @NP)))&quot;), new SimpleStringFunction(&quot;-maSdr&quot;)));</span>
<span class="fc" id="L375">      annotationPatterns.put(&quot;-mjjMark&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;@JJ|DTJJ &lt; /^m/ $+ @PP &gt;# @ADJP &quot;), new SimpleStringFunction(&quot;-mjj&quot;)));</span>
      //annotationPatterns.put(markPRDverbString,new Pair&lt;TregexPattern,Function&lt;TregexMatcher,String&gt;&gt;(TregexPattern.compile(&quot;/^V[^P]/ &gt; VP $ /-PRD$/&quot;),new SimpleStringFunction(&quot;-PRDverb&quot;))); // don't need this pattern anymore, the functionality has been moved to ArabicTreeNormalizer
      // PUNC is PUNC in either raw or Bies POS encoding
<span class="fc" id="L378">      annotationPatterns.put(&quot;-markNPwithSdescendant&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;__ !&lt; @S &lt;&lt; @S [ &gt;&gt; @NP | == @NP ]&quot;), new SimpleStringFunction(&quot;-inNPdominatesS&quot;)));</span>
<span class="fc" id="L379">      annotationPatterns.put(&quot;-markRightRecursiveNP&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;__ &lt;&lt;- @NP [&gt;&gt;- @NP | == @NP]&quot;), new SimpleStringFunction(&quot;-rrNP&quot;)));</span>
<span class="fc" id="L380">      annotationPatterns.put(&quot;-markBaseNP&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;@NP !&lt; @NP !&lt; @VP !&lt; @SBAR !&lt; @ADJP !&lt; @ADVP !&lt; @S !&lt; @QP !&lt; @UCP !&lt; @PP&quot;), new SimpleStringFunction(&quot;-base&quot;)));</span>
      // allow only a single level of idafa as Base NP; this version works!
<span class="fc" id="L382">      annotationPatterns.put(&quot;-markBaseNPplusIdafa&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;@NP !&lt; (/^[^N]/ &lt; (__ &lt; __)) !&lt; (__ &lt; (__ &lt; (__ &lt; __)))&quot;), new SimpleStringFunction(&quot;-base&quot;)));</span>
<span class="fc" id="L383">      annotationPatterns.put(&quot;-markTwoLevelIdafa&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;@NP &lt; (@NP &lt; (@NP &lt; (__ &lt; __)) !&lt; (/^[^N]/ &lt; (__ &lt; __))) !&lt; (/^[^N]/ &lt; (__ &lt; __)) !&lt; (__ &lt; (__ &lt; (__ &lt; (__ &lt; __))))&quot;), new SimpleStringFunction(&quot;-idafa2&quot;)));</span>
<span class="fc" id="L384">      annotationPatterns.put(&quot;-markDefiniteIdafa&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;@NP &lt; (/^(?:NN|NOUN)/ !$,, /^[^AP]/) &lt;+(/^NP/) (@NP &lt; /^DT/)&quot;), new SimpleStringFunction(&quot;-defIdafa&quot;)));</span>
<span class="fc" id="L385">      annotationPatterns.put(&quot;-markDefiniteIdafa1&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;@NP &lt; (/^(?:NN|NOUN)/ !$,, /^[^AP]/) &lt; (@NP &lt; /^DT/) !&lt; (/^[^N]/ &lt; (__ &lt; __)) !&lt; (__ &lt; (__ &lt; (__ &lt; __)))&quot;), new SimpleStringFunction(&quot;-defIdafa1&quot;)));</span>
<span class="fc" id="L386">      annotationPatterns.put(&quot;-markContainsSBAR&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;__ &lt;&lt; @SBAR&quot;), new SimpleStringFunction(&quot;-withSBAR&quot;)));</span>
<span class="fc" id="L387">      annotationPatterns.put(&quot;-markPhrasalNodesDominatedBySBAR&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;__ &lt; (__ &lt; __) &gt;&gt; @SBAR&quot;), new SimpleStringFunction(&quot;-domBySBAR&quot;)));</span>
<span class="fc" id="L388">      annotationPatterns.put(&quot;-markCoordinateNPs&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;@NP &lt; @CC|CONJ&quot;), new SimpleStringFunction(&quot;-coord&quot;)));</span>
      //annotationPatterns.put(&quot;-markCopularVerbTags&quot;,new Pair&lt;TregexPattern,Function&lt;TregexMatcher,String&gt;&gt;(tregexPatternCompiler.compile(&quot;/^V/ &lt; &quot; + copularVerbForms),new SimpleStringFunction(&quot;-copular&quot;)));
      //annotationPatterns.put(&quot;-markSBARVerbTags&quot;,new Pair&lt;TregexPattern,Function&lt;TregexMatcher,String&gt;&gt;(tregexPatternCompiler.compile(&quot;/^V/ &lt; &quot; + sbarVerbForms),new SimpleStringFunction(&quot;-SBARverb&quot;)));
<span class="fc" id="L391">      annotationPatterns.put(&quot;-markNounAdjVPheads&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;@NN|NNS|NNP|NNPS|JJ|DTJJ|DTNN|DTNNS|DTNNP|DTNNPS &gt;# @VP&quot;), new SimpleStringFunction(&quot;-VHead&quot;)));</span>
      // a better version of the below might only mark clitic pronouns, but
      // since most pronouns are clitics, let's try this first....
<span class="fc" id="L394">      annotationPatterns.put(&quot;-markPronominalNP&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;@NP &lt; @PRP&quot;), new SimpleStringFunction(&quot;-PRP&quot;)));</span>
      // try doing coordination parallelism -- there's a lot of that in Arabic (usually the same, sometimes different CC)
<span class="fc" id="L396">      annotationPatterns.put(&quot;-markMultiCC&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;__ &lt; (@CC $.. @CC)&quot;), new SimpleStringFunction(&quot;-multiCC&quot;))); // this unfortunately didn't seem helpful for capturing CC parallelism; should try again</span>
<span class="fc" id="L397">      annotationPatterns.put(&quot;-markHasCCdaughter&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;__ &lt; @CC&quot;), new SimpleStringFunction(&quot;-CCdtr&quot;)));</span>
<span class="fc" id="L398">      annotationPatterns.put(&quot;-markAcronymNP&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;@NP !&lt;  (__ &lt; (__ &lt; __)) &lt; (/^NN/ &lt; /^.$/ $ (/^NN/ &lt; /^.$/)) !&lt; (__ &lt; /../)&quot;), new SimpleStringFunction(&quot;-acro&quot;)));</span>
<span class="fc" id="L399">      annotationPatterns.put(&quot;-markAcronymNN&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;/^NN/ &lt; /^.$/ $ (/^NN/ &lt; /^.$/) &gt; (@NP !&lt;  (__ &lt; (__ &lt; __)) !&lt; (__ &lt; /../))&quot;), new SimpleStringFunction(&quot;-acro&quot;)));</span>
      //PP Specific patterns
<span class="fc" id="L401">      annotationPatterns.put(&quot;-markPPwithPPdescendant&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;__ !&lt; @PP &lt;&lt; @PP [ &gt;&gt; @PP | == @PP ]&quot;), new SimpleStringFunction(&quot;-inPPdominatesPP&quot;)));</span>
<span class="fc" id="L402">      annotationPatterns.put(&quot;-gpAnnotatePrepositions&quot;, new Pair&lt;&gt;(TregexPattern.compile(&quot;/^(?:IN|PREP)$/ &gt; (__ &gt; __=gp)&quot;), new AddRelativeNodeFunction(&quot;^^&quot;, &quot;gp&quot;, false)));</span>
<span class="fc" id="L403">      annotationPatterns.put(&quot;-gpEquivalencePrepositions&quot;, new Pair&lt;&gt;(TregexPattern.compile(&quot;/^(?:IN|PREP)$/ &gt; (@PP &gt;+(/^PP/) __=gp)&quot;), new AddEquivalencedNodeFunction(&quot;^^&quot;, &quot;gp&quot;)));</span>
<span class="fc" id="L404">      annotationPatterns.put(&quot;-gpEquivalencePrepositionsVar&quot;, new Pair&lt;&gt;(TregexPattern.compile(&quot;/^(?:IN|PREP)$/ &gt; (@PP &gt;+(/^PP/) __=gp)&quot;), new AddEquivalencedNodeFunctionVar(&quot;^^&quot;, &quot;gp&quot;)));</span>
<span class="fc" id="L405">      annotationPatterns.put(&quot;-markPPParent&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;@PP=max !&lt; @PP&quot;), new AddRelativeNodeRegexFunction(&quot;^^&quot;, &quot;max&quot;, &quot;^(\\w)&quot;)));</span>
<span class="fc" id="L406">      annotationPatterns.put(&quot;-whPP&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;@PP &lt;- (@SBAR &lt;, /^WH/)&quot;), new SimpleStringFunction(&quot;-whPP&quot;)));</span>
      //    annotationPatterns.put(&quot;-markTmpPP&quot;, new Pair&lt;TregexPattern,Function&lt;TregexMatcher,String&gt;&gt;(tregexPatternCompiler.compile(&quot;@PP !&lt;+(__) @PP&quot;),new LexicalCategoryFunction(&quot;-TMP&quot;,temporalNouns)));
<span class="fc" id="L408">      annotationPatterns.put(&quot;-deflateMin&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;__ &lt; (__ &lt; من)&quot;), new SimpleStringFunction(&quot;-min&quot;)));</span>
<span class="fc" id="L409">      annotationPatterns.put(&quot;-v2MarkovIN&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;@IN &gt; (@__=p1 &gt; @__=p2)&quot;), new AddRelativeNodeFunction(&quot;^&quot;, &quot;p1&quot;, &quot;p2&quot;, false)));</span>
<span class="fc" id="L410">      annotationPatterns.put(&quot;-pleonasticMin&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;@PP &lt;, (IN &lt; من) &gt; @S&quot;), new SimpleStringFunction(&quot;-pleo&quot;)));</span>
<span class="fc" id="L411">      annotationPatterns.put(&quot;-v2MarkovPP&quot;, new Pair&lt;&gt;(tregexPatternCompiler.compile(&quot;@PP &gt; (@__=p1 &gt; @__=p2)&quot;), new AddRelativeNodeFunction(&quot;^&quot;, &quot;p1&quot;, &quot;p2&quot;, false)));</span>

<span class="nc" id="L413">    } catch (TregexParseException e) {</span>
<span class="nc" id="L414">      int nth = annotationPatterns.size() + 1;</span>
<span class="nc bnc" id="L415" title="All 4 branches missed.">      String nthStr = (nth == 1) ? &quot;1st&quot;: ((nth == 2) ? &quot;2nd&quot;: nth + &quot;th&quot;);</span>
<span class="nc" id="L416">      log.info(&quot;Parse exception on &quot; + nthStr + &quot; annotation pattern initialization:&quot; + e);</span>
<span class="nc" id="L417">      throw e;</span>
<span class="fc" id="L418">    }</span>
<span class="fc" id="L419">  }</span>

  private static class SimpleStringFunction implements SerializableFunction&lt;TregexMatcher,String&gt; {

<span class="fc" id="L423">    public SimpleStringFunction(String result) {</span>
<span class="fc" id="L424">      this.result = result;</span>
<span class="fc" id="L425">    }</span>

    private String result;

    public String apply(TregexMatcher tregexMatcher) {
<span class="nc" id="L430">      return result;</span>
    }

    @Override
<span class="nc" id="L434">    public String toString() { return &quot;SimpleStringFunction[&quot; + result + ']'; }</span>

    private static final long serialVersionUID = 1L;
  }


  private static class AddRelativeNodeFunction implements SerializableFunction&lt;TregexMatcher,String&gt; {

    private String annotationMark;
    private String key;
    private String key2;
<span class="fc" id="L445">    private boolean doBasicCat = false;</span>

<span class="fc" id="L447">    private static final TreebankLanguagePack tlp = new ArabicTreebankLanguagePack();</span>

<span class="fc" id="L449">    public AddRelativeNodeFunction(String annotationMark, String key, boolean basicCategory) {</span>
<span class="fc" id="L450">      this.annotationMark = annotationMark;</span>
<span class="fc" id="L451">      this.key = key;</span>
<span class="fc" id="L452">      this.key2 = null;</span>
<span class="fc" id="L453">      doBasicCat = basicCategory;</span>
<span class="fc" id="L454">    }</span>

    public AddRelativeNodeFunction(String annotationMark, String key1, String key2, boolean basicCategory) {
<span class="fc" id="L457">      this(annotationMark,key1,basicCategory);</span>
<span class="fc" id="L458">      this.key2 = key2;</span>
<span class="fc" id="L459">    }</span>

    public String apply(TregexMatcher m) {
<span class="nc bnc" id="L462" title="All 2 branches missed.">      if(key2 == null)</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">        return annotationMark + ((doBasicCat) ? tlp.basicCategory(m.getNode(key).label().value()) : m.getNode(key).label().value());</span>
      else {
<span class="nc bnc" id="L465" title="All 2 branches missed.">        String annot1 = (doBasicCat) ? tlp.basicCategory(m.getNode(key).label().value()) : m.getNode(key).label().value();</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">        String annot2 = (doBasicCat) ? tlp.basicCategory(m.getNode(key2).label().value()) : m.getNode(key2).label().value();</span>
<span class="nc" id="L467">        return annotationMark + annot1 + annotationMark + annot2;</span>
      }
    }

    @Override
    public String toString() {
<span class="nc bnc" id="L473" title="All 2 branches missed.">      if(key2 == null)</span>
<span class="nc" id="L474">        return &quot;AddRelativeNodeFunction[&quot; + annotationMark + ',' + key + ']';</span>
      else
<span class="nc" id="L476">        return &quot;AddRelativeNodeFunction[&quot; + annotationMark + ',' + key + ',' + key2 + ']';</span>
    }

    private static final long serialVersionUID = 1L;

  }


  private static class AddRelativeNodeRegexFunction implements SerializableFunction&lt;TregexMatcher,String&gt; {

    private String annotationMark;
    private String key;
    private Pattern pattern;

<span class="fc" id="L490">    private String key2 = null;</span>
    private Pattern pattern2;

<span class="fc" id="L493">    public AddRelativeNodeRegexFunction(String annotationMark, String key, String regex) {</span>
<span class="fc" id="L494">      this.annotationMark = annotationMark;</span>
<span class="fc" id="L495">      this.key = key;</span>
      try {
<span class="fc" id="L497">        this.pattern = Pattern.compile(regex);</span>
<span class="nc" id="L498">      } catch (PatternSyntaxException pse) {</span>
<span class="nc" id="L499">        log.info(&quot;Bad pattern: &quot; + regex);</span>
<span class="nc" id="L500">        pattern = null;</span>
<span class="nc" id="L501">        throw new IllegalArgumentException(pse);</span>
<span class="fc" id="L502">      }</span>
<span class="fc" id="L503">    }</span>

    public String apply(TregexMatcher m) {
<span class="nc" id="L506">      String val = m.getNode(key).label().value();</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">      if (pattern != null) {</span>
<span class="nc" id="L508">        Matcher mat = pattern.matcher(val);</span>
<span class="nc bnc" id="L509" title="All 2 branches missed.">        if (mat.find()) {</span>
<span class="nc" id="L510">          val = mat.group(1);</span>
        }
      }

<span class="nc bnc" id="L514" title="All 4 branches missed.">      if(key2 != null &amp;&amp; pattern2 != null) {</span>
<span class="nc" id="L515">        String val2 = m.getNode(key2).label().value();</span>
<span class="nc" id="L516">        Matcher mat2 = pattern2.matcher(val2);</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">        if(mat2.find()) {</span>
<span class="nc" id="L518">          val = val + annotationMark + mat2.group(1);</span>
        } else {
<span class="nc" id="L520">          val = val + annotationMark + val2;</span>
        }
      }

<span class="nc" id="L524">      return annotationMark + val;</span>
    }

    @Override
<span class="nc" id="L528">    public String toString() { return &quot;AddRelativeNodeRegexFunction[&quot; + annotationMark + ',' + key + ',' + pattern + ']'; }</span>

    private static final long serialVersionUID = 1L;
  }


  /** This one only distinguishes VP, S and Other (mainly nominal) contexts.
   *  These seem the crucial distinctions for Arabic true prepositions,
   *  based on raw counts in data.
   */
  private static class AddEquivalencedNodeFunction implements SerializableFunction&lt;TregexMatcher,String&gt; {

    private String annotationMark;
    private String key;

<span class="fc" id="L543">    public AddEquivalencedNodeFunction(String annotationMark, String key) {</span>
<span class="fc" id="L544">      this.annotationMark = annotationMark;</span>
<span class="fc" id="L545">      this.key = key;</span>
<span class="fc" id="L546">    }</span>

    public String apply(TregexMatcher m) {
<span class="nc" id="L549">      String node = m.getNode(key).label().value();</span>
<span class="nc bnc" id="L550" title="All 2 branches missed.">      if (node.startsWith(&quot;S&quot;)) {</span>
<span class="nc" id="L551">        return annotationMark + 'S';</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">      } else if (node.startsWith(&quot;V&quot;)) {</span>
<span class="nc" id="L553">        return annotationMark + 'V';</span>
      } else {
<span class="nc" id="L555">        return &quot;&quot;;</span>
      }
    }

    @Override
<span class="nc" id="L560">    public String toString() { return &quot;AddEquivalencedNodeFunction[&quot; + annotationMark + ',' + key + ']'; }</span>

    private static final long serialVersionUID = 1L;
  }


  /** This one only distinguishes VP, S*, A* versus other (mainly nominal) contexts. */
  private static class AddEquivalencedNodeFunctionVar implements SerializableFunction&lt;TregexMatcher,String&gt; {

    private String annotationMark;
    private String key;

<span class="fc" id="L572">    public AddEquivalencedNodeFunctionVar(String annotationMark, String key) {</span>
<span class="fc" id="L573">      this.annotationMark = annotationMark;</span>
<span class="fc" id="L574">      this.key = key;</span>
<span class="fc" id="L575">    }</span>

    public String apply(TregexMatcher m) {
<span class="nc" id="L578">      String node = m.getNode(key).label().value();</span>
      // We also tried if (node.startsWith(&quot;V&quot;)) [var2] and if (node.startsWith(&quot;V&quot;) || node.startsWith(&quot;S&quot;)) [var3]. Both seemed markedly worse than the basic function or this var form (which seems a bit better than the basic equiv option).
<span class="nc bnc" id="L580" title="All 6 branches missed.">      if (node.startsWith(&quot;S&quot;) || node.startsWith(&quot;V&quot;) || node.startsWith(&quot;A&quot;)) {</span>
<span class="nc" id="L581">        return annotationMark + &quot;VSA&quot;;</span>
      } else {
<span class="nc" id="L583">        return &quot;&quot;;</span>
      }
    }

    @Override
<span class="nc" id="L588">    public String toString() { return &quot;AddEquivalencedNodeFunctionVar[&quot; + annotationMark + ',' + key + ']'; }</span>

    private static final long serialVersionUID = 1L;
  }

<span class="fc" id="L593">  private static class AnnotatePunctuationFunction2 implements SerializableFunction&lt;TregexMatcher,String&gt; {</span>
    static final String key = &quot;term&quot;;

<span class="fc" id="L596">    private static final Pattern quote = Pattern.compile(&quot;^\&quot;$&quot;);</span>

    public String apply(TregexMatcher m) {

<span class="nc" id="L600">      final String punc = m.getNode(key).value();</span>

<span class="nc bnc" id="L602" title="All 2 branches missed.">      if (punc.equals(&quot;.&quot;))</span>
<span class="nc" id="L603">        return &quot;-fs&quot;;</span>
<span class="nc bnc" id="L604" title="All 2 branches missed.">      else if (punc.equals(&quot;?&quot;))</span>
<span class="nc" id="L605">        return &quot;-quest&quot;;</span>
<span class="nc bnc" id="L606" title="All 2 branches missed.">      else if (punc.equals(&quot;,&quot;))</span>
<span class="nc" id="L607">        return &quot;-comma&quot;;</span>
<span class="nc bnc" id="L608" title="All 4 branches missed.">      else if (punc.equals(&quot;:&quot;) || punc.equals(&quot;;&quot;))</span>
<span class="nc" id="L609">        return &quot;-colon&quot;;</span>
<span class="nc bnc" id="L610" title="All 2 branches missed.">      else if (punc.equals(&quot;-LRB-&quot;))</span>
<span class="nc" id="L611">        return &quot;-lrb&quot;;</span>
<span class="nc bnc" id="L612" title="All 2 branches missed.">      else if (punc.equals(&quot;-RRB-&quot;))</span>
<span class="nc" id="L613">        return &quot;-rrb&quot;;</span>
<span class="nc bnc" id="L614" title="All 2 branches missed.">      else if (punc.equals(&quot;-PLUS-&quot;))</span>
<span class="nc" id="L615">        return &quot;-plus&quot;;</span>
<span class="nc bnc" id="L616" title="All 2 branches missed.">      else if (punc.equals(&quot;-&quot;))</span>
<span class="nc" id="L617">        return &quot;-dash&quot;;</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">      else if (quote.matcher(punc).matches())</span>
<span class="nc" id="L619">        return &quot;-quote&quot;;</span>
      //      else if(punc.equals(&quot;/&quot;))
      //        return &quot;-slash&quot;;
      //      else if(punc.equals(&quot;%&quot;))
      //        return &quot;-perc&quot;;
      //      else if(punc.contains(&quot;..&quot;))
      //        return &quot;-ellipses&quot;;
<span class="nc" id="L626">      return &quot;&quot;;</span>
    }

    @Override
<span class="nc" id="L630">    public String toString() { return &quot;AnnotatePunctuationFunction2&quot;; }</span>

    private static final long serialVersionUID = 1L;
  }


  private static class AddEquivalencedConjNode implements SerializableFunction&lt;TregexMatcher,String&gt; {

    private String annotationMark;
    private String key;

    private static final String nnTags = &quot;DTNN DTNNP DTNNPS DTNNS NN NNP NNS NNPS&quot;;
<span class="fc" id="L642">    private static final Set&lt;String&gt; nnTagClass = Collections.unmodifiableSet(Generics.newHashSet(Arrays.asList(nnTags.split(&quot;\\s+&quot;))));</span>

    private static final String jjTags = &quot;ADJ_NUM DTJJ DTJJR JJ JJR&quot;;
<span class="fc" id="L645">    private static final Set&lt;String&gt; jjTagClass = Collections.unmodifiableSet(Generics.newHashSet(Arrays.asList(jjTags.split(&quot;\\s+&quot;))));</span>

    private static final String vbTags = &quot;VBD VBP&quot;;
<span class="fc" id="L648">    private static final Set&lt;String&gt; vbTagClass = Collections.unmodifiableSet(Generics.newHashSet(Arrays.asList(vbTags.split(&quot;\\s+&quot;))));</span>

<span class="fc" id="L650">    private static final TreebankLanguagePack tlp = new ArabicTreebankLanguagePack();</span>

<span class="fc" id="L652">    public AddEquivalencedConjNode(String annotationMark, String key) {</span>
<span class="fc" id="L653">      this.annotationMark = annotationMark;</span>
<span class="fc" id="L654">      this.key = key;</span>
<span class="fc" id="L655">    }</span>

    public String apply(TregexMatcher m) {
<span class="nc" id="L658">      String node = m.getNode(key).value();</span>
<span class="nc" id="L659">      String eqClass = tlp.basicCategory(node);</span>

<span class="nc bnc" id="L661" title="All 2 branches missed.">      if(nnTagClass.contains(eqClass))</span>
<span class="nc" id="L662">        eqClass = &quot;noun&quot;;</span>
<span class="nc bnc" id="L663" title="All 2 branches missed.">      else if(jjTagClass.contains(eqClass))</span>
<span class="nc" id="L664">        eqClass = &quot;adj&quot;;</span>
<span class="nc bnc" id="L665" title="All 2 branches missed.">      else if(vbTagClass.contains(eqClass))</span>
<span class="nc" id="L666">        eqClass = &quot;vb&quot;;</span>

<span class="nc" id="L668">      return annotationMark + eqClass;</span>
    }

    @Override
<span class="nc" id="L672">    public String toString() { return &quot;AddEquivalencedConjNode[&quot; + annotationMark + ',' + key + ']'; }</span>

    private static final long serialVersionUID = 1L;
  }

  /**
   * Reconfigures active features after a change in the default headfinder.
   *
   * @param hf
   */
  private void setHeadFinder(HeadFinder hf) {
<span class="nc bnc" id="L683" title="All 2 branches missed.">    if(hf == null)</span>
<span class="nc" id="L684">      throw new IllegalArgumentException();</span>

<span class="nc" id="L686">    headFinder = hf;</span>

    // Need to re-initialize all patterns due to the new headFinder
<span class="nc" id="L689">    initializeAnnotationPatterns();</span>

<span class="nc" id="L691">    activeAnnotations.clear();</span>

<span class="nc bnc" id="L693" title="All 2 branches missed.">    for(String key : baselineFeatures) {</span>
<span class="nc" id="L694">      Pair&lt;TregexPattern,Function&lt;TregexMatcher,String&gt;&gt; p = annotationPatterns.get(key);</span>
<span class="nc" id="L695">      activeAnnotations.add(p);</span>
<span class="nc" id="L696">    }</span>
<span class="nc bnc" id="L697" title="All 2 branches missed.">    for(String key : additionalFeatures) {</span>
<span class="nc" id="L698">      Pair&lt;TregexPattern,Function&lt;TregexMatcher,String&gt;&gt; p = annotationPatterns.get(key);</span>
<span class="nc" id="L699">      activeAnnotations.add(p);</span>
<span class="nc" id="L700">    }</span>
<span class="nc" id="L701">  }</span>

  /**
   * Configures morpho-syntactic annotations for POS tags.
   *
   * @param activeFeats A comma-separated list of feature values with names according
   * to MorphoFeatureType.
   *
   */
  private String setupMorphoFeatures(String activeFeats) {
<span class="nc" id="L711">    String[] feats = activeFeats.split(&quot;,&quot;);</span>
<span class="nc" id="L712">    morphoSpec = tlp.morphFeatureSpec();</span>
<span class="nc bnc" id="L713" title="All 2 branches missed.">    for(String feat : feats) {</span>
<span class="nc" id="L714">      MorphoFeatureType fType = MorphoFeatureType.valueOf(feat.trim());</span>
<span class="nc" id="L715">      morphoSpec.activate(fType);</span>
    }
<span class="nc" id="L717">    return morphoSpec.toString();</span>
  }

  private void removeBaselineFeature(String featName) {
<span class="nc bnc" id="L721" title="All 2 branches missed.">    if(baselineFeatures.contains(featName)) {</span>
<span class="nc" id="L722">      baselineFeatures.remove(featName);</span>
<span class="nc" id="L723">      Pair&lt;TregexPattern,Function&lt;TregexMatcher,String&gt;&gt; p = annotationPatterns.get(featName);</span>
<span class="nc" id="L724">      activeAnnotations.remove(p);</span>
    }
<span class="nc" id="L726">  }</span>

  @Override
  public void display() {
<span class="nc" id="L730">    log.info(optionsString.toString());</span>
<span class="nc" id="L731">  }</span>

  /** Some options for setOptionFlag:
   *
   * &lt;p&gt;
   * &lt;code&gt;-retainNPTmp&lt;/code&gt; Retain temporal NP marking on NPs.
   * &lt;code&gt;-retainNPSbj&lt;/code&gt; Retain NP subject function tags
   * &lt;code&gt;-markGappedVP&lt;/code&gt; marked gapped VPs.
   * &lt;code&gt;-collinizerRetainsPunctuation&lt;/code&gt; does what it says.
   * &lt;/p&gt;
   *
   * @param args flag arguments (usually from commmand line
   * @param i index at which to begin argument processing
   * @return Index in args array after the last processed index for option
   */
  @Override
  public int setOptionFlag(String[] args, int i) {
    //log.info(&quot;Setting option flag: &quot;  + args[i]);

    //lang. specific options
<span class="nc" id="L751">    boolean didSomething = false;</span>
<span class="nc bnc" id="L752" title="All 2 branches missed.">    if (annotationPatterns.keySet().contains(args[i])) {</span>
<span class="nc bnc" id="L753" title="All 2 branches missed.">      if(!baselineFeatures.contains(args[i])) additionalFeatures.add(args[i]);</span>
<span class="nc" id="L754">      Pair&lt;TregexPattern,Function&lt;TregexMatcher,String&gt;&gt; p = annotationPatterns.get(args[i]);</span>
<span class="nc" id="L755">      activeAnnotations.add(p);</span>
<span class="nc" id="L756">      optionsString.append(&quot;Option &quot; + args[i] + &quot; added annotation pattern &quot; + p.first() + &quot; with annotation &quot; + p.second() + '\n');</span>
<span class="nc" id="L757">      didSomething = true;</span>

<span class="nc bnc" id="L759" title="All 2 branches missed.">    } else if (args[i].equals(&quot;-retainNPTmp&quot;)) {</span>
<span class="nc" id="L760">      optionsString.append(&quot;Retaining NP-TMP marking.\n&quot;);</span>
<span class="nc" id="L761">      retainNPTmp = true;</span>
<span class="nc" id="L762">      didSomething = true;</span>

<span class="nc bnc" id="L764" title="All 2 branches missed.">    } else if (args[i].equals(&quot;-retainNPSbj&quot;)) {</span>
<span class="nc" id="L765">      optionsString.append(&quot;Retaining NP-SBJ dash tag.\n&quot;);</span>
<span class="nc" id="L766">      retainNPSbj = true;</span>
<span class="nc" id="L767">      didSomething = true;</span>

<span class="nc bnc" id="L769" title="All 2 branches missed.">    } else if (args[i].equals(&quot;-retainPPClr&quot;)) {</span>
<span class="nc" id="L770">      optionsString.append(&quot;Retaining PP-CLR dash tag.\n&quot;);</span>
<span class="nc" id="L771">      retainPPClr = true;</span>
<span class="nc" id="L772">      didSomething = true;</span>

<span class="nc bnc" id="L774" title="All 2 branches missed.">    } else if (args[i].equals(&quot;-discardX&quot;)) {</span>
<span class="nc" id="L775">      optionsString.append(&quot;Discarding X trees.\n&quot;);</span>
<span class="nc" id="L776">      discardX = true;</span>
<span class="nc" id="L777">      didSomething = true;</span>

<span class="nc bnc" id="L779" title="All 2 branches missed.">    } else if (args[i].equals(&quot;-changeNoLabels&quot;)) {</span>
<span class="nc" id="L780">      optionsString.append(&quot;Change no labels.\n&quot;);</span>
<span class="nc" id="L781">      changeNoLabels = true;</span>
<span class="nc" id="L782">      didSomething = true;</span>

<span class="nc bnc" id="L784" title="All 2 branches missed.">    } else if (args[i].equals(&quot;-markPRDverbs&quot;)) {</span>
<span class="nc" id="L785">      optionsString.append(&quot;Mark PRD.\n&quot;);</span>
<span class="nc" id="L786">      retainPRD = true;</span>
<span class="nc" id="L787">      didSomething = true;</span>

<span class="nc bnc" id="L789" title="All 2 branches missed.">    } else if (args[i].equals(&quot;-collinizerRetainsPunctuation&quot;)) {</span>
<span class="nc" id="L790">      optionsString.append(&quot;Collinizer retains punctuation.\n&quot;);</span>
<span class="nc" id="L791">      collinizerRetainsPunctuation = true;</span>
<span class="nc" id="L792">      didSomething = true;</span>

<span class="nc bnc" id="L794" title="All 2 branches missed.">    } else if (args[i].equals(&quot;-arabicFactored&quot;)) {</span>
<span class="nc bnc" id="L795" title="All 2 branches missed.">      for(String annotation : baselineFeatures) {</span>
<span class="nc" id="L796">        String[] a = {annotation};</span>
<span class="nc" id="L797">        setOptionFlag(a,0);</span>
<span class="nc" id="L798">      }</span>
<span class="nc" id="L799">      didSomething = true;</span>

<span class="nc bnc" id="L801" title="All 4 branches missed.">    } else if (args[i].equalsIgnoreCase(&quot;-headFinder&quot;) &amp;&amp; (i + 1 &lt; args.length)) {</span>
      try {
<span class="nc" id="L803">        HeadFinder hf = (HeadFinder) Class.forName(args[i + 1]).newInstance();</span>
<span class="nc" id="L804">        setHeadFinder(hf);</span>
<span class="nc" id="L805">        optionsString.append(&quot;HeadFinder: &quot; + args[i + 1] + &quot;\n&quot;);</span>

<span class="nc" id="L807">      } catch (Exception e) {</span>
<span class="nc" id="L808">        log.info(e);</span>
<span class="nc" id="L809">        log.info(this.getClass().getName() +</span>
                           &quot;: Could not load head finder &quot; + args[i + 1]);
<span class="nc" id="L811">      }</span>
<span class="nc" id="L812">      i++;</span>
<span class="nc" id="L813">      didSomething = true;</span>

<span class="nc bnc" id="L815" title="All 4 branches missed.">    } else if(args[i].equals(&quot;-factlex&quot;) &amp;&amp; (i + 1 &lt; args.length)) {</span>
<span class="nc" id="L816">      String activeFeats = setupMorphoFeatures(args[++i]);</span>
<span class="nc" id="L817">      optionsString.append(&quot;Factored Lexicon: active features: &quot;).append(activeFeats);</span>
//
//      removeBaselineFeature(&quot;-markFem&quot;);
//      optionsString.append(&quot; (removed -markFem)\n&quot;);

<span class="nc" id="L822">      didSomething = true;</span>

<span class="nc bnc" id="L824" title="All 2 branches missed.">    } else if(args[i].equals(&quot;-noFeatures&quot;)) {</span>
<span class="nc" id="L825">      activeAnnotations.clear();</span>
<span class="nc" id="L826">      optionsString.append(&quot;Removed all manual features.\n&quot;);</span>

<span class="nc" id="L828">      didSomething = true;</span>
    }
    //wsg2010: The segmenter does not work, but keep this to remember how it was instantiated.
    //    else if (args[i].equals(&quot;-arabicTokenizerModel&quot;)) {
    //      String modelFile = args[i+1];
    //      try {
    //        WordSegmenter aSeg = (WordSegmenter) Class.forName(&quot;edu.stanford.nlp.wordseg.ArabicSegmenter&quot;).newInstance();
    //        aSeg.loadSegmenter(modelFile);
    //        System.out.println(&quot;aSeg=&quot; + aSeg);
    //        TokenizerFactory&lt;Word&gt; aTF = WordSegmentingTokenizer.factory(aSeg);
    //        ((ArabicTreebankLanguagePack) treebankLanguagePack()).setTokenizerFactory(aTF);
    //      } catch (RuntimeIOException ex) {
    //        log.info(&quot;Couldn't load ArabicSegmenter &quot; + modelFile);
    //        ex.printStackTrace();
    //      } catch (Exception e) {
    //        log.info(&quot;Couldn't instantiate segmenter: edu.stanford.nlp.wordseg.ArabicSegmenter&quot;);
    //        e.printStackTrace();
    //      }
    //      i++; // 2 args
    //      didSomething = true;
    //    }

<span class="nc bnc" id="L850" title="All 2 branches missed.">    if (didSomething) i++;</span>

<span class="nc" id="L852">    return i;</span>
  }


  /**
   *
   * @param args
   */
  public static void main(String[] args) {
<span class="nc bnc" id="L861" title="All 2 branches missed.">    if(args.length != 1) {</span>
<span class="nc" id="L862">      System.exit(-1);</span>
    }

<span class="nc" id="L865">    ArabicTreebankParserParams tlpp = new ArabicTreebankParserParams();</span>
<span class="nc" id="L866">    String[] options = {&quot;-arabicFactored&quot;};</span>
<span class="nc" id="L867">    tlpp.setOptionFlag(options, 0);</span>
<span class="nc" id="L868">    DiskTreebank tb = tlpp.diskTreebank();</span>
<span class="nc" id="L869">    tb.loadPath(args[0], &quot;txt&quot;, false);</span>

<span class="nc bnc" id="L871" title="All 2 branches missed.">    for(Tree t : tb) {</span>
<span class="nc bnc" id="L872" title="All 2 branches missed.">      for(Tree subtree : t) {</span>
<span class="nc" id="L873">        tlpp.transformTree(subtree, t);</span>
<span class="nc" id="L874">      }</span>
<span class="nc" id="L875">      System.out.println(t.toString());</span>
<span class="nc" id="L876">    }</span>
<span class="nc" id="L877">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>