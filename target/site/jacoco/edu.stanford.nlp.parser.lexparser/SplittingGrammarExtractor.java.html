<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SplittingGrammarExtractor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.parser.lexparser</a> &gt; <span class="el_source">SplittingGrammarExtractor.java</span></div><h1>SplittingGrammarExtractor.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.parser.lexparser; 
import edu.stanford.nlp.util.logging.Redwood;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.IdentityHashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.Set;

import edu.stanford.nlp.io.RuntimeIOException;
import edu.stanford.nlp.ling.TaggedWord;
import edu.stanford.nlp.math.SloppyMath;
import edu.stanford.nlp.stats.ClassicCounter;
import edu.stanford.nlp.stats.Counter;
import edu.stanford.nlp.stats.IntCounter;
import edu.stanford.nlp.trees.Tree;
import edu.stanford.nlp.util.Generics;
import edu.stanford.nlp.util.HashIndex;
import edu.stanford.nlp.util.Index;
import edu.stanford.nlp.util.MapFactory;
import edu.stanford.nlp.util.MutableDouble;
import edu.stanford.nlp.util.Pair;
import edu.stanford.nlp.util.ThreeDimensionalMap;
import edu.stanford.nlp.util.Triple;
import edu.stanford.nlp.util.TwoDimensionalMap;


import java.io.*;

/**
 * This class is a reimplementation of Berkeley's state splitting
 * grammar.  This work is experimental and still in progress.  There
 * are several extremely important pieces to implement:
 * &lt;ol&gt;
 * &lt;li&gt; this code should use log probabilities throughout instead of
 *      multiplying tiny numbers
 * &lt;li&gt; time efficiency of the training code is fawful
 * &lt;li&gt; there are better ways to extract parses using this grammar than
 *      the method in ExhaustivePCFGParser
 * &lt;li&gt; we should also implement cascading parsers that let us
 *      shortcircuit low quality parses earlier (which could possibly
 *      benefit non-split parsers as well)
 * &lt;li&gt; when looping, we should short circuit if we go too many loops
 * &lt;li&gt; ought to smooth as per page 436
 * &lt;/ol&gt;
 *
 * @author John Bauer
 */
public class SplittingGrammarExtractor  {

  /** A logger for this class */
<span class="nc" id="L57">  private static Redwood.RedwoodChannels log = Redwood.channels(SplittingGrammarExtractor.class);</span>
  static final int MIN_DEBUG_ITERATION=0;
  static final int MAX_DEBUG_ITERATION=0;
  static final int MAX_ITERATIONS = Integer.MAX_VALUE;

<span class="nc" id="L62">  int iteration = 0;</span>

  boolean DEBUG() {
<span class="nc bnc" id="L65" title="All 4 branches missed.">    return (iteration &gt;= MIN_DEBUG_ITERATION &amp;&amp; iteration &lt; MAX_DEBUG_ITERATION);</span>
  }

  Options op;
  /**
   * These objects are created and filled in here.  The caller can get
   * the data from the extractor once it is finished.
   */
  Index&lt;String&gt; stateIndex;
  Index&lt;String&gt; wordIndex;
  Index&lt;String&gt; tagIndex;
  /**
   * This is a list gotten from the list of startSymbols in op.langpack()
   */
  List&lt;String&gt; startSymbols;

  /**
   * A combined list of all the trees in the training set.
   */
<span class="nc" id="L84">  List&lt;Tree&gt; trees = new ArrayList&lt;&gt;();</span>

  /**
   * All of the weights associated with the trees in the training set.
   * In general, this is just the weight of the original treebank.
   * Note that this uses an identity hash map to map from tree pointer
   * to weight.
   */
<span class="nc" id="L92">  Counter&lt;Tree&gt; treeWeights = new ClassicCounter&lt;&gt;(MapFactory.&lt;Tree, MutableDouble&gt;identityHashMapFactory());</span>

  /**
   * How many total weighted trees we have
   */
  double trainSize;

  /**
   * The original states in the trees
   */
<span class="nc" id="L102">  Set&lt;String&gt; originalStates = Generics.newHashSet();</span>

  /**
   * The current number of times a particular state has been split
   */
<span class="nc" id="L107">  IntCounter&lt;String&gt; stateSplitCounts = new IntCounter&lt;&gt;();</span>

  /**
   * The binary betas are weights to go from Ax to By, Cz.  This maps
   * from (A, B, C) to (x, y, z) to beta(Ax, By, Cz).
   */
<span class="nc" id="L113">  ThreeDimensionalMap&lt;String, String, String, double[][][]&gt; binaryBetas = new ThreeDimensionalMap&lt;&gt;();</span>
  /**
   * The unary betas are weights to go from Ax to By.  This maps
   * from (A, B) to (x, y) to beta(Ax, By).
   */
<span class="nc" id="L118">  TwoDimensionalMap&lt;String, String, double[][]&gt; unaryBetas = new TwoDimensionalMap&lt;&gt;();</span>

  /**
   * The latest lexicon we trained.  At the end of the process, this
   * is the lexicon for the parser.
   */
  Lexicon lex;

  transient Index&lt;String&gt; tempWordIndex;
  transient Index&lt;String&gt; tempTagIndex;

  /**
   * The lexicon we are in the process of building in each iteration.
   */
  transient Lexicon tempLex;

  /**
   * The latest pair of unary and binary grammars we trained.
   */
  Pair&lt;UnaryGrammar, BinaryGrammar&gt; bgug;

<span class="nc" id="L139">  Random random = new Random(87543875943265L);</span>

  static final double LEX_SMOOTH = 0.0001;
  static final double STATE_SMOOTH = 0.0;

<span class="nc" id="L144">  public SplittingGrammarExtractor(Options op) {</span>
<span class="nc" id="L145">    this.op = op;</span>
<span class="nc" id="L146">    startSymbols = Arrays.asList(op.langpack().startSymbols());</span>
<span class="nc" id="L147">  }</span>

  double[] neginfDoubles(int size) {
<span class="nc" id="L150">    double[] result = new double[size];</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">    for (int i = 0; i &lt; size; ++i) {</span>
<span class="nc" id="L152">      result[i] = Double.NEGATIVE_INFINITY;</span>
    }
<span class="nc" id="L154">    return result;</span>
  }

  public void outputTransitions(Tree tree,
                                IdentityHashMap&lt;Tree, double[][]&gt; unaryTransitions,
                                IdentityHashMap&lt;Tree, double[][][]&gt; binaryTransitions) {
<span class="nc" id="L160">    outputTransitions(tree, 0, unaryTransitions, binaryTransitions);</span>
<span class="nc" id="L161">  }</span>

  public void outputTransitions(Tree tree, int depth,
                                IdentityHashMap&lt;Tree, double[][]&gt; unaryTransitions,
                                IdentityHashMap&lt;Tree, double[][][]&gt; binaryTransitions) {
<span class="nc bnc" id="L166" title="All 2 branches missed.">    for (int i = 0; i &lt; depth; ++i) {</span>
<span class="nc" id="L167">      System.out.print(&quot; &quot;);</span>
    }
<span class="nc bnc" id="L169" title="All 2 branches missed.">    if (tree.isLeaf()) {</span>
<span class="nc" id="L170">      System.out.println(tree.label().value());</span>
<span class="nc" id="L171">      return;</span>
    }
<span class="nc bnc" id="L173" title="All 2 branches missed.">    if (tree.children().length == 1) {</span>
<span class="nc" id="L174">      System.out.println(tree.label().value() + &quot; -&gt; &quot; + tree.children()[0].label().value());</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">      if (!tree.isPreTerminal()) {</span>
<span class="nc" id="L176">        double[][] transitions = unaryTransitions.get(tree);</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">        for (int i = 0; i &lt; transitions.length; ++i) {</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">          for (int j = 0; j &lt; transitions[0].length; ++j) {</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">            for (int z = 0; z &lt; depth; ++z) {</span>
<span class="nc" id="L180">              System.out.print(&quot; &quot;);</span>
            }
<span class="nc" id="L182">            System.out.println(&quot;  &quot; + i + &quot;,&quot; + j + &quot;: &quot; + transitions[i][j] + &quot; | &quot; + Math.exp(transitions[i][j]));</span>
          }
        }
<span class="nc" id="L185">      }</span>
    } else {
<span class="nc" id="L187">      System.out.println(tree.label().value() + &quot; -&gt; &quot; + tree.children()[0].label().value() + &quot; &quot; + tree.children()[1].label().value());</span>
<span class="nc" id="L188">      double[][][] transitions = binaryTransitions.get(tree);</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">      for (int i = 0; i &lt; transitions.length; ++i) {</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">        for (int j = 0; j &lt; transitions[0].length; ++j) {</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">          for (int k = 0; k &lt; transitions[0][0].length; ++k) {</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">            for (int z = 0; z &lt; depth; ++z) {</span>
<span class="nc" id="L193">              System.out.print(&quot; &quot;);</span>
            }
<span class="nc" id="L195">            System.out.println(&quot;  &quot; + i + &quot;,&quot; + j + &quot;,&quot; + k + &quot;: &quot; + transitions[i][j][k] + &quot; | &quot; + Math.exp(transitions[i][j][k]));</span>
          }
        }
      }
    }
<span class="nc bnc" id="L200" title="All 2 branches missed.">    if (tree.isPreTerminal()) {</span>
<span class="nc" id="L201">      return;</span>
    }
<span class="nc bnc" id="L203" title="All 2 branches missed.">    for (Tree child : tree.children()) {</span>
<span class="nc" id="L204">      outputTransitions(child, depth + 1, unaryTransitions, binaryTransitions);</span>
    }
<span class="nc" id="L206">  }</span>

  public void outputBetas() {
<span class="nc" id="L209">    System.out.println(&quot;UNARY:&quot;);</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">    for (String parent : unaryBetas.firstKeySet()) {</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">      for (String child : unaryBetas.get(parent).keySet()) {</span>
<span class="nc" id="L212">        System.out.println(&quot;  &quot; + parent + &quot;-&gt;&quot; + child);</span>
<span class="nc" id="L213">        double[][] betas = unaryBetas.get(parent).get(child);</span>
<span class="nc" id="L214">        int parentStates = betas.length;</span>
<span class="nc" id="L215">        int childStates = betas[0].length;</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">        for (int i = 0; i &lt; parentStates; ++i) {</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">          for (int j = 0; j &lt; childStates; ++j) {</span>
<span class="nc" id="L218">            System.out.println(&quot;    &quot; + i + &quot;-&gt;&quot; + j + &quot; &quot; + betas[i][j] + &quot; | &quot; + Math.exp(betas[i][j]));</span>
          }
        }
<span class="nc" id="L221">      }</span>
<span class="nc" id="L222">    }</span>
<span class="nc" id="L223">    System.out.println(&quot;BINARY:&quot;);</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">    for (String parent : binaryBetas.firstKeySet()) {</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">      for (String left : binaryBetas.get(parent).firstKeySet()) {</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">        for (String right : binaryBetas.get(parent).get(left).keySet()) {</span>
<span class="nc" id="L227">          System.out.println(&quot;  &quot; + parent + &quot;-&gt;&quot; + left + &quot;,&quot; + right);</span>
<span class="nc" id="L228">          double[][][] betas = binaryBetas.get(parent).get(left).get(right);</span>
<span class="nc" id="L229">          int parentStates = betas.length;</span>
<span class="nc" id="L230">          int leftStates = betas[0].length;</span>
<span class="nc" id="L231">          int rightStates = betas[0][0].length;</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">          for (int i = 0; i &lt; parentStates; ++i) {</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">            for (int j = 0; j &lt; leftStates; ++j) {</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">              for (int k = 0; k &lt; rightStates; ++k) {</span>
<span class="nc" id="L235">                System.out.println(&quot;    &quot; + i + &quot;-&gt;&quot; + j + &quot;,&quot; + k + &quot; &quot; + betas[i][j][k] + &quot; | &quot; + Math.exp(betas[i][j][k]));</span>
              }
            }
          }
<span class="nc" id="L239">        }</span>
<span class="nc" id="L240">      }</span>
<span class="nc" id="L241">    }</span>
<span class="nc" id="L242">  }</span>

  public String state(String tag, int i) {
<span class="nc bnc" id="L245" title="All 4 branches missed.">    if (startSymbols.contains(tag) || tag.equals(Lexicon.BOUNDARY_TAG)) {</span>
<span class="nc" id="L246">      return tag;</span>
    }
<span class="nc" id="L248">    return tag + &quot;^&quot; + i;</span>
  }

  public int getStateSplitCount(Tree tree) {
<span class="nc" id="L252">    return stateSplitCounts.getIntCount(tree.label().value());</span>
  }

  public int getStateSplitCount(String label) {
<span class="nc" id="L256">    return stateSplitCounts.getIntCount(label);</span>
  }


  /**
   * Count all the internal labels in all the trees, and set their
   * initial state counts to 1.
   */
  public void countOriginalStates() {
<span class="nc" id="L265">    originalStates.clear();</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">    for (Tree tree : trees) {</span>
<span class="nc" id="L267">      countOriginalStates(tree);</span>
<span class="nc" id="L268">    }</span>

<span class="nc bnc" id="L270" title="All 2 branches missed.">    for (String state : originalStates) {</span>
<span class="nc" id="L271">      stateSplitCounts.incrementCount(state, 1);</span>
<span class="nc" id="L272">    }</span>
<span class="nc" id="L273">  }</span>

  /**
   * Counts the labels in the tree, but not the words themselves.
   */
  private void countOriginalStates(Tree tree) {
<span class="nc bnc" id="L279" title="All 2 branches missed.">    if (tree.isLeaf()) {</span>
<span class="nc" id="L280">      return;</span>
    }

<span class="nc" id="L283">    originalStates.add(tree.label().value());</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">    for (Tree child : tree.children()) {</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">      if (child.isLeaf())</span>
<span class="nc" id="L286">        continue;</span>
<span class="nc" id="L287">      countOriginalStates(child);</span>
    }
<span class="nc" id="L289">  }</span>

  private void initialBetasAndLexicon() {
<span class="nc" id="L292">    wordIndex = new HashIndex&lt;&gt;();</span>
<span class="nc" id="L293">    tagIndex = new HashIndex&lt;&gt;();</span>
<span class="nc" id="L294">    lex = op.tlpParams.lex(op, wordIndex, tagIndex);</span>
<span class="nc" id="L295">    lex.initializeTraining(trainSize);</span>

<span class="nc bnc" id="L297" title="All 2 branches missed.">    for (Tree tree : trees) {</span>
<span class="nc" id="L298">      double weight = treeWeights.getCount(tree);</span>
<span class="nc" id="L299">      lex.incrementTreesRead(weight);</span>
<span class="nc" id="L300">      initialBetasAndLexicon(tree, 0, weight);</span>
<span class="nc" id="L301">    }</span>

<span class="nc" id="L303">    lex.finishTraining();</span>
<span class="nc" id="L304">  }</span>

  private int initialBetasAndLexicon(Tree tree, int position, double weight) {
<span class="nc bnc" id="L307" title="All 2 branches missed.">    if (tree.isLeaf()) {</span>
      // should never get here, unless a training tree is just one leaf
<span class="nc" id="L309">      return position;</span>
    }

<span class="nc bnc" id="L312" title="All 2 branches missed.">    if (tree.isPreTerminal()) {</span>
      // fill in initial lexicon here
<span class="nc" id="L314">      String tag = tree.label().value();</span>
<span class="nc" id="L315">      String word = tree.children()[0].label().value();</span>
<span class="nc" id="L316">      TaggedWord tw = new TaggedWord(word, state(tag, 0));</span>
<span class="nc" id="L317">      lex.train(tw, position, weight);</span>
<span class="nc" id="L318">      return (position + 1);</span>
    }

<span class="nc bnc" id="L321" title="All 2 branches missed.">    if (tree.children().length == 2) {</span>
<span class="nc" id="L322">      String label = tree.label().value();</span>
<span class="nc" id="L323">      String leftLabel = tree.getChild(0).label().value();</span>
<span class="nc" id="L324">      String rightLabel = tree.getChild(1).label().value();</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">      if (!binaryBetas.contains(label, leftLabel, rightLabel)) {</span>
<span class="nc" id="L326">        double[][][] map = new double[1][1][1];</span>
<span class="nc" id="L327">        map[0][0][0] = 0.0;</span>
<span class="nc" id="L328">        binaryBetas.put(label, leftLabel, rightLabel, map);</span>
      }
<span class="nc bnc" id="L330" title="All 2 branches missed.">    } else if (tree.children().length == 1) {</span>
<span class="nc" id="L331">      String label = tree.label().value();</span>
<span class="nc" id="L332">      String childLabel = tree.getChild(0).label().value();</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">      if (!unaryBetas.contains(label, childLabel)) {</span>
<span class="nc" id="L334">        double[][] map = new double[1][1];</span>
<span class="nc" id="L335">        map[0][0] = 0.0;</span>
<span class="nc" id="L336">        unaryBetas.put(label, childLabel, map);</span>
      }
<span class="nc" id="L338">    } else {</span>
      // should have been binarized
<span class="nc" id="L340">      throw new RuntimeException(&quot;Trees should have been binarized, expected 1 or 2 children&quot;);</span>
    }

<span class="nc bnc" id="L343" title="All 2 branches missed.">    for (Tree child : tree.children()) {</span>
<span class="nc" id="L344">      position = initialBetasAndLexicon(child, position, weight);</span>
    }
<span class="nc" id="L346">    return position;</span>
  }


  /**
   * Splits the state counts.  Root states and the boundary tag do not
   * get their counts increased, and all others are doubled.  Betas
   * and transition weights are handled later.
   */
  private void splitStateCounts() {
    // double the count of states...
<span class="nc" id="L357">    IntCounter&lt;String&gt; newStateSplitCounts = new IntCounter&lt;&gt;();</span>
<span class="nc" id="L358">    newStateSplitCounts.addAll(stateSplitCounts);</span>
<span class="nc" id="L359">    newStateSplitCounts.addAll(stateSplitCounts);</span>

    // root states should only have 1
<span class="nc bnc" id="L362" title="All 2 branches missed.">    for (String root : startSymbols) {</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">      if (newStateSplitCounts.getCount(root) &gt; 1) {</span>
<span class="nc" id="L364">        newStateSplitCounts.setCount(root, 1);</span>
      }
<span class="nc" id="L366">    }</span>

<span class="nc bnc" id="L368" title="All 2 branches missed.">    if (newStateSplitCounts.getCount(Lexicon.BOUNDARY_TAG) &gt; 1) {</span>
<span class="nc" id="L369">      newStateSplitCounts.setCount(Lexicon.BOUNDARY_TAG, 1);</span>
    }

<span class="nc" id="L372">    stateSplitCounts = newStateSplitCounts;</span>
<span class="nc" id="L373">  }</span>


  static final double EPSILON = 0.0001;

  /**
   * Before each iteration of splitting states, we have tables of
   * betas which correspond to the transitions between different
   * substates.  When we resplit the states, we duplicate parent
   * states and then split their transitions 50/50 with some random
   * variation between child states.
   */
  public void splitBetas() {
<span class="nc" id="L386">    TwoDimensionalMap&lt;String, String, double[][]&gt; tempUnaryBetas = new TwoDimensionalMap&lt;&gt;();</span>
<span class="nc" id="L387">    ThreeDimensionalMap&lt;String, String, String, double[][][]&gt; tempBinaryBetas = new ThreeDimensionalMap&lt;&gt;();</span>

<span class="nc bnc" id="L389" title="All 2 branches missed.">    for (String parent : unaryBetas.firstKeySet()) {</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">      for (String child : unaryBetas.get(parent).keySet()) {</span>
<span class="nc" id="L391">        double[][] betas = unaryBetas.get(parent, child);</span>
<span class="nc" id="L392">        int parentStates = betas.length;</span>
<span class="nc" id="L393">        int childStates = betas[0].length;</span>

        double[][] newBetas;
<span class="nc bnc" id="L396" title="All 2 branches missed.">        if (!startSymbols.contains(parent)) {</span>
<span class="nc" id="L397">          newBetas = new double[parentStates * 2][childStates];</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">          for (int i = 0; i &lt; parentStates; ++i) {</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">            for (int j = 0; j &lt; childStates; ++j) {</span>
<span class="nc" id="L400">              newBetas[i * 2][j] = betas[i][j];</span>
<span class="nc" id="L401">              newBetas[i * 2 + 1][j] = betas[i][j];</span>
            }
          }
<span class="nc" id="L404">          parentStates *= 2;</span>
<span class="nc" id="L405">          betas = newBetas;</span>
        }
<span class="nc bnc" id="L407" title="All 2 branches missed.">        if (!child.equals(Lexicon.BOUNDARY_TAG)) {</span>
<span class="nc" id="L408">          newBetas = new double[parentStates][childStates * 2];</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">          for (int i = 0; i &lt; parentStates; ++i) {</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">            for (int j = 0; j &lt; childStates; ++j) {</span>
<span class="nc" id="L411">              double childWeight = 0.45 + random.nextDouble() * 0.1;</span>
<span class="nc" id="L412">              newBetas[i][j * 2] = betas[i][j] + Math.log(childWeight);</span>
<span class="nc" id="L413">              newBetas[i][j * 2 + 1] = betas[i][j] + Math.log(1.0 - childWeight);</span>
            }
          }
<span class="nc" id="L416">          betas = newBetas;</span>
        }
<span class="nc" id="L418">        tempUnaryBetas.put(parent, child, betas);</span>
<span class="nc" id="L419">      }</span>
<span class="nc" id="L420">    }</span>

<span class="nc bnc" id="L422" title="All 2 branches missed.">    for (String parent : binaryBetas.firstKeySet()) {</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">      for (String left : binaryBetas.get(parent).firstKeySet()) {</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">        for (String right : binaryBetas.get(parent).get(left).keySet()) {</span>
<span class="nc" id="L425">          double[][][] betas = binaryBetas.get(parent, left, right);</span>
<span class="nc" id="L426">          int parentStates = betas.length;</span>
<span class="nc" id="L427">          int leftStates = betas[0].length;</span>
<span class="nc" id="L428">          int rightStates = betas[0][0].length;</span>

          double[][][] newBetas;
<span class="nc bnc" id="L431" title="All 2 branches missed.">          if (!startSymbols.contains(parent)) {</span>
<span class="nc" id="L432">            newBetas = new double[parentStates * 2][leftStates][rightStates];</span>
<span class="nc bnc" id="L433" title="All 2 branches missed.">            for (int i = 0; i &lt; parentStates; ++i) {</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">              for (int j = 0; j &lt; leftStates; ++j) {</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">                for (int k = 0; k &lt; rightStates; ++k) {</span>
<span class="nc" id="L436">                  newBetas[i * 2][j][k] = betas[i][j][k];</span>
<span class="nc" id="L437">                  newBetas[i * 2 + 1][j][k] = betas[i][j][k];</span>
                }
              }
            }
<span class="nc" id="L441">            parentStates *= 2;</span>
<span class="nc" id="L442">            betas = newBetas;</span>
          }

<span class="nc" id="L445">          newBetas = new double[parentStates][leftStates * 2][rightStates];</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">          for (int i = 0; i &lt; parentStates; ++i) {</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">            for (int j = 0; j &lt; leftStates; ++j) {</span>
<span class="nc bnc" id="L448" title="All 2 branches missed.">              for (int k = 0; k &lt; rightStates; ++k) {</span>
<span class="nc" id="L449">                double leftWeight = 0.45 + random.nextDouble() * 0.1;</span>
<span class="nc" id="L450">                newBetas[i][j * 2][k] = betas[i][j][k] + Math.log(leftWeight);</span>
<span class="nc" id="L451">                newBetas[i][j * 2 + 1][k] = betas[i][j][k] + Math.log(1 - leftWeight);</span>
              }
            }
          }
<span class="nc" id="L455">          leftStates *= 2;</span>
<span class="nc" id="L456">          betas = newBetas;</span>

<span class="nc bnc" id="L458" title="All 2 branches missed.">          if (!right.equals(Lexicon.BOUNDARY_TAG)) {</span>
<span class="nc" id="L459">            newBetas = new double[parentStates][leftStates][rightStates * 2];</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">            for (int i = 0; i &lt; parentStates; ++i) {</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">              for (int j = 0; j &lt; leftStates; ++j) {</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">                for (int k = 0; k &lt; rightStates; ++k) {</span>
<span class="nc" id="L463">                  double rightWeight = 0.45 + random.nextDouble() * 0.1;</span>
<span class="nc" id="L464">                  newBetas[i][j][k * 2] = betas[i][j][k] + Math.log(rightWeight);</span>
<span class="nc" id="L465">                  newBetas[i][j][k * 2 + 1] = betas[i][j][k] + Math.log(1 - rightWeight);</span>
                }
              }
            }
          }
<span class="nc" id="L470">          tempBinaryBetas.put(parent, left, right, newBetas);</span>
<span class="nc" id="L471">        }</span>
<span class="nc" id="L472">      }</span>
<span class="nc" id="L473">    }</span>
<span class="nc" id="L474">    unaryBetas = tempUnaryBetas;</span>
<span class="nc" id="L475">    binaryBetas = tempBinaryBetas;</span>
<span class="nc" id="L476">  }</span>


  /**
   * Recalculates the betas for all known transitions.  The current
   * betas are used to produce probabilities, which then are used to
   * compute new betas.  If splitStates is true, then the
   * probabilities produced are as if the states were split again from
   * the last time betas were calculated.
   * &lt;br&gt;
   * The return value is whether or not the betas have mostly
   * converged from the last time this method was called.  Obviously
   * if splitStates was true, the betas will be entirely different, so
   * this is false.  Otherwise, the new betas are compared against the
   * old values, and convergence means they differ by less than
   * EPSILON.
   */
  public boolean recalculateBetas(boolean splitStates) {
<span class="nc bnc" id="L494" title="All 2 branches missed.">    if (splitStates) {</span>
<span class="nc bnc" id="L495" title="All 2 branches missed.">      if (DEBUG()) {</span>
<span class="nc" id="L496">        System.out.println(&quot;Pre-split betas&quot;);</span>
<span class="nc" id="L497">        outputBetas();</span>
      }
<span class="nc" id="L499">      splitBetas();</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">      if (DEBUG()) {</span>
<span class="nc" id="L501">        System.out.println(&quot;Post-split betas&quot;);</span>
<span class="nc" id="L502">        outputBetas();</span>
      }
    }

<span class="nc" id="L506">    TwoDimensionalMap&lt;String, String, double[][]&gt; tempUnaryBetas = new TwoDimensionalMap&lt;&gt;();</span>
<span class="nc" id="L507">    ThreeDimensionalMap&lt;String, String, String, double[][][]&gt; tempBinaryBetas = new ThreeDimensionalMap&lt;&gt;();</span>

<span class="nc" id="L509">    recalculateTemporaryBetas(splitStates, null, tempUnaryBetas, tempBinaryBetas);</span>
<span class="nc bnc" id="L510" title="All 2 branches missed.">    boolean converged = useNewBetas(!splitStates, tempUnaryBetas, tempBinaryBetas);</span>

<span class="nc bnc" id="L512" title="All 2 branches missed.">    if (DEBUG()) {</span>
<span class="nc" id="L513">      outputBetas();</span>
    }

<span class="nc" id="L516">    return converged;</span>
  }

  public boolean useNewBetas(boolean testConverged,
                             TwoDimensionalMap&lt;String, String, double[][]&gt; tempUnaryBetas,
                             ThreeDimensionalMap&lt;String, String, String, double[][][]&gt; tempBinaryBetas) {
<span class="nc" id="L522">    rescaleTemporaryBetas(tempUnaryBetas, tempBinaryBetas);</span>

    // if we just split states, we have obviously not converged
<span class="nc bnc" id="L525" title="All 4 branches missed.">    boolean converged = testConverged &amp;&amp; testConvergence(tempUnaryBetas, tempBinaryBetas);</span>

<span class="nc" id="L527">    unaryBetas = tempUnaryBetas;</span>
<span class="nc" id="L528">    binaryBetas = tempBinaryBetas;</span>

<span class="nc" id="L530">    wordIndex = tempWordIndex;</span>
<span class="nc" id="L531">    tagIndex = tempTagIndex;</span>
<span class="nc" id="L532">    lex = tempLex;</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">    if (DEBUG()) {</span>
<span class="nc" id="L534">      System.out.println(&quot;LEXICON&quot;);</span>
      try {
<span class="nc" id="L536">        OutputStreamWriter osw = new OutputStreamWriter(System.out, &quot;utf-8&quot;);</span>
<span class="nc" id="L537">        lex.writeData(osw);</span>
<span class="nc" id="L538">        osw.flush();</span>
<span class="nc" id="L539">      } catch (IOException e) {</span>
<span class="nc" id="L540">        throw new RuntimeIOException(e);</span>
<span class="nc" id="L541">      }</span>
    }
<span class="nc" id="L543">    tempWordIndex = null;</span>
<span class="nc" id="L544">    tempTagIndex = null;</span>
<span class="nc" id="L545">    tempLex = null;</span>

<span class="nc" id="L547">    return converged;</span>
  }

  /**
   * Creates temporary beta data structures and fills them in by
   * iterating over the trees.
   */
  public void recalculateTemporaryBetas(boolean splitStates, Map&lt;String, double[]&gt; totalStateMass,
                                        TwoDimensionalMap&lt;String, String, double[][]&gt; tempUnaryBetas,
                                        ThreeDimensionalMap&lt;String, String, String, double[][][]&gt; tempBinaryBetas) {
<span class="nc" id="L557">    tempWordIndex = new HashIndex&lt;&gt;();</span>
<span class="nc" id="L558">    tempTagIndex = new HashIndex&lt;&gt;();</span>
<span class="nc" id="L559">    tempLex = op.tlpParams.lex(op, tempWordIndex, tempTagIndex);</span>
<span class="nc" id="L560">    tempLex.initializeTraining(trainSize);</span>

<span class="nc bnc" id="L562" title="All 2 branches missed.">    for (Tree tree : trees) {</span>
<span class="nc" id="L563">      double weight = treeWeights.getCount(tree);</span>
<span class="nc bnc" id="L564" title="All 2 branches missed.">      if (DEBUG()) {</span>
<span class="nc" id="L565">        System.out.println(&quot;Incrementing trees read: &quot; + weight);</span>
      }
<span class="nc" id="L567">      tempLex.incrementTreesRead(weight);</span>
<span class="nc" id="L568">      recalculateTemporaryBetas(tree, splitStates, totalStateMass, tempUnaryBetas, tempBinaryBetas);</span>
<span class="nc" id="L569">    }</span>

<span class="nc" id="L571">    tempLex.finishTraining();</span>
<span class="nc" id="L572">  }</span>

  public boolean testConvergence(TwoDimensionalMap&lt;String, String, double[][]&gt; tempUnaryBetas,
                                 ThreeDimensionalMap&lt;String, String, String, double[][][]&gt; tempBinaryBetas) {

    // now, we check each of the new betas to see if it's close to the
    // old value for the same transition.  if not, we have not yet
    // converged.  if all of them are, we have converged.
<span class="nc bnc" id="L580" title="All 2 branches missed.">    for (String parentLabel : unaryBetas.firstKeySet()) {</span>
<span class="nc bnc" id="L581" title="All 2 branches missed.">      for (String childLabel : unaryBetas.get(parentLabel).keySet()) {</span>
<span class="nc" id="L582">        double[][] betas = unaryBetas.get(parentLabel, childLabel);</span>
<span class="nc" id="L583">        double[][] newBetas = tempUnaryBetas.get(parentLabel, childLabel);</span>
<span class="nc" id="L584">        int parentStates = betas.length;</span>
<span class="nc" id="L585">        int childStates = betas[0].length;</span>
<span class="nc bnc" id="L586" title="All 2 branches missed.">        for (int i = 0; i &lt; parentStates; ++i) {</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">          for (int j = 0; j &lt; childStates; ++j) {</span>
<span class="nc" id="L588">            double oldValue = betas[i][j];</span>
<span class="nc" id="L589">            double newValue = newBetas[i][j];</span>
<span class="nc bnc" id="L590" title="All 2 branches missed.">            if (Math.abs(newValue - oldValue) &gt; EPSILON) {</span>
<span class="nc" id="L591">              return false;</span>
            }
          }
        }
<span class="nc" id="L595">      }</span>
<span class="nc" id="L596">    }</span>
<span class="nc bnc" id="L597" title="All 2 branches missed.">    for (String parentLabel : binaryBetas.firstKeySet()) {</span>
<span class="nc bnc" id="L598" title="All 2 branches missed.">      for (String leftLabel : binaryBetas.get(parentLabel).firstKeySet()) {</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">        for (String rightLabel : binaryBetas.get(parentLabel).get(leftLabel).keySet()) {</span>
<span class="nc" id="L600">          double[][][] betas = binaryBetas.get(parentLabel, leftLabel, rightLabel);</span>
<span class="nc" id="L601">          double[][][] newBetas = tempBinaryBetas.get(parentLabel, leftLabel, rightLabel);</span>
<span class="nc" id="L602">          int parentStates = betas.length;</span>
<span class="nc" id="L603">          int leftStates = betas[0].length;</span>
<span class="nc" id="L604">          int rightStates = betas[0][0].length;</span>
<span class="nc bnc" id="L605" title="All 2 branches missed.">          for (int i = 0; i &lt; parentStates; ++i) {</span>
<span class="nc bnc" id="L606" title="All 2 branches missed.">            for (int j = 0; j &lt; leftStates; ++j) {</span>
<span class="nc bnc" id="L607" title="All 2 branches missed.">              for (int k = 0; k &lt; rightStates; ++k) {</span>
<span class="nc" id="L608">                double oldValue = betas[i][j][k];</span>
<span class="nc" id="L609">                double newValue = newBetas[i][j][k];</span>
<span class="nc bnc" id="L610" title="All 2 branches missed.">                if (Math.abs(newValue - oldValue) &gt; EPSILON) {</span>
<span class="nc" id="L611">                  return false;</span>
                }
              }
            }
          }
<span class="nc" id="L616">        }</span>
<span class="nc" id="L617">      }</span>
<span class="nc" id="L618">    }</span>

<span class="nc" id="L620">    return true;</span>
  }

  public void recalculateTemporaryBetas(Tree tree, boolean splitStates,
                                        Map&lt;String, double[]&gt; totalStateMass,
                                        TwoDimensionalMap&lt;String, String, double[][]&gt; tempUnaryBetas,
                                        ThreeDimensionalMap&lt;String, String, String, double[][][]&gt; tempBinaryBetas) {
<span class="nc bnc" id="L627" title="All 2 branches missed.">    if (DEBUG()) {</span>
<span class="nc" id="L628">      System.out.println(&quot;Recalculating temporary betas for tree &quot; + tree);</span>
    }
<span class="nc" id="L630">    double[] stateWeights = { Math.log(treeWeights.getCount(tree)) };</span>

<span class="nc" id="L632">    IdentityHashMap&lt;Tree, double[][]&gt; unaryTransitions = new IdentityHashMap&lt;&gt;();</span>
<span class="nc" id="L633">    IdentityHashMap&lt;Tree, double[][][]&gt; binaryTransitions = new IdentityHashMap&lt;&gt;();</span>
<span class="nc" id="L634">    recountTree(tree, splitStates, unaryTransitions, binaryTransitions);</span>

<span class="nc bnc" id="L636" title="All 2 branches missed.">    if (DEBUG()) {</span>
<span class="nc" id="L637">      System.out.println(&quot;  Transitions:&quot;);</span>
<span class="nc" id="L638">      outputTransitions(tree, unaryTransitions, binaryTransitions);</span>
    }

<span class="nc" id="L641">    recalculateTemporaryBetas(tree, stateWeights, 0, unaryTransitions, binaryTransitions,</span>
                              totalStateMass, tempUnaryBetas, tempBinaryBetas);
<span class="nc" id="L643">  }</span>

  public int recalculateTemporaryBetas(Tree tree, double[] stateWeights, int position,
                                       IdentityHashMap&lt;Tree, double[][]&gt; unaryTransitions,
                                       IdentityHashMap&lt;Tree, double[][][]&gt; binaryTransitions,
                                       Map&lt;String, double[]&gt; totalStateMass,
                                       TwoDimensionalMap&lt;String, String, double[][]&gt; tempUnaryBetas,
                                       ThreeDimensionalMap&lt;String, String, String, double[][][]&gt; tempBinaryBetas) {
<span class="nc bnc" id="L651" title="All 2 branches missed.">    if (tree.isLeaf()) {</span>
      // possible to get here if we have a tree with no structure
<span class="nc" id="L653">      return position;</span>
    }

<span class="nc bnc" id="L656" title="All 2 branches missed.">    if (totalStateMass != null) {</span>
<span class="nc" id="L657">      double[] stateTotal = totalStateMass.get(tree.label().value());</span>
<span class="nc bnc" id="L658" title="All 2 branches missed.">      if (stateTotal == null) {</span>
<span class="nc" id="L659">        stateTotal = new double[stateWeights.length];</span>
<span class="nc" id="L660">        totalStateMass.put(tree.label().value(), stateTotal);</span>
      }
<span class="nc bnc" id="L662" title="All 2 branches missed.">      for (int i = 0; i &lt; stateWeights.length; ++i) {</span>
<span class="nc" id="L663">        stateTotal[i] += Math.exp(stateWeights[i]);</span>
      }
    }

<span class="nc bnc" id="L667" title="All 2 branches missed.">    if (tree.isPreTerminal()) {</span>
      // fill in our new lexicon here.
<span class="nc" id="L669">      String tag = tree.label().value();</span>
<span class="nc" id="L670">      String word = tree.children()[0].label().value();</span>
      // We smooth by LEX_SMOOTH, if relevant.  We rescale so that sum
      // of the weights being added to the lexicon stays the same.
<span class="nc" id="L673">      double total = 0.0;</span>
<span class="nc bnc" id="L674" title="All 2 branches missed.">      for (double stateWeight : stateWeights) {</span>
<span class="nc" id="L675">        total += Math.exp(stateWeight);</span>
      }
<span class="nc bnc" id="L677" title="All 2 branches missed.">      if (total &lt;= 0.0) {</span>
<span class="nc" id="L678">        return position + 1;</span>
      }
<span class="nc" id="L680">      double scale = 1.0 / (1.0 + LEX_SMOOTH);</span>
<span class="nc" id="L681">      double smoothing = total * LEX_SMOOTH / stateWeights.length;</span>
<span class="nc bnc" id="L682" title="All 2 branches missed.">      for (int state = 0; state &lt; stateWeights.length; ++state) {</span>
        // TODO: maybe optimize all this TaggedWord creation
<span class="nc" id="L684">        TaggedWord tw = new TaggedWord(word, state(tag, state));</span>
<span class="nc" id="L685">        tempLex.train(tw, position, (Math.exp(stateWeights[state]) + smoothing) * scale);</span>
      }
<span class="nc" id="L687">      return position + 1;</span>
    }

<span class="nc bnc" id="L690" title="All 2 branches missed.">    if (tree.children().length == 1) {</span>
<span class="nc" id="L691">      String parentLabel = tree.label().value();</span>
<span class="nc" id="L692">      String childLabel = tree.children()[0].label().value();</span>
<span class="nc" id="L693">      double[][] transitions = unaryTransitions.get(tree);</span>
<span class="nc" id="L694">      int parentStates = transitions.length;</span>
<span class="nc" id="L695">      int childStates = transitions[0].length;</span>
<span class="nc" id="L696">      double[][] betas = tempUnaryBetas.get(parentLabel, childLabel);</span>
<span class="nc bnc" id="L697" title="All 2 branches missed.">      if (betas == null) {</span>
<span class="nc" id="L698">        betas = new double[parentStates][childStates];</span>
<span class="nc bnc" id="L699" title="All 2 branches missed.">        for (int i = 0; i &lt; parentStates; ++i) {</span>
<span class="nc bnc" id="L700" title="All 2 branches missed.">          for (int j = 0; j &lt; childStates; ++j) {</span>
<span class="nc" id="L701">            betas[i][j] = Double.NEGATIVE_INFINITY;</span>
          }
        }
<span class="nc" id="L704">        tempUnaryBetas.put(parentLabel, childLabel, betas);</span>
      }
<span class="nc" id="L706">      double[] childWeights = neginfDoubles(childStates);</span>
<span class="nc bnc" id="L707" title="All 2 branches missed.">      for (int i = 0; i &lt; parentStates; ++i) {</span>
<span class="nc bnc" id="L708" title="All 2 branches missed.">        for (int j = 0; j &lt; childStates; ++j) {</span>
<span class="nc" id="L709">          double weight = transitions[i][j];</span>
<span class="nc" id="L710">          betas[i][j] = SloppyMath.logAdd(betas[i][j], weight + stateWeights[i]);</span>
<span class="nc" id="L711">          childWeights[j] = SloppyMath.logAdd(childWeights[j], weight + stateWeights[i]);</span>
        }
      }
<span class="nc" id="L714">      position = recalculateTemporaryBetas(tree.children()[0], childWeights, position, unaryTransitions, binaryTransitions, totalStateMass, tempUnaryBetas, tempBinaryBetas);</span>
<span class="nc" id="L715">    } else { // length == 2</span>
<span class="nc" id="L716">      String parentLabel = tree.label().value();</span>
<span class="nc" id="L717">      String leftLabel = tree.children()[0].label().value();</span>
<span class="nc" id="L718">      String rightLabel = tree.children()[1].label().value();</span>
<span class="nc" id="L719">      double[][][] transitions = binaryTransitions.get(tree);</span>
<span class="nc" id="L720">      int parentStates = transitions.length;</span>
<span class="nc" id="L721">      int leftStates = transitions[0].length;</span>
<span class="nc" id="L722">      int rightStates = transitions[0][0].length;</span>

<span class="nc" id="L724">      double[][][] betas = tempBinaryBetas.get(parentLabel, leftLabel, rightLabel);</span>
<span class="nc bnc" id="L725" title="All 2 branches missed.">      if (betas == null) {</span>
<span class="nc" id="L726">        betas = new double[parentStates][leftStates][rightStates];</span>
<span class="nc bnc" id="L727" title="All 2 branches missed.">        for (int i = 0; i &lt; parentStates; ++i) {</span>
<span class="nc bnc" id="L728" title="All 2 branches missed.">          for (int j = 0; j &lt; leftStates; ++j) {</span>
<span class="nc bnc" id="L729" title="All 2 branches missed.">            for (int k = 0; k &lt; rightStates; ++k) {</span>
<span class="nc" id="L730">              betas[i][j][k] = Double.NEGATIVE_INFINITY;</span>
            }
          }
        }
<span class="nc" id="L734">        tempBinaryBetas.put(parentLabel, leftLabel, rightLabel, betas);</span>
      }
<span class="nc" id="L736">      double[] leftWeights = neginfDoubles(leftStates);</span>
<span class="nc" id="L737">      double[] rightWeights = neginfDoubles(rightStates);</span>
<span class="nc bnc" id="L738" title="All 2 branches missed.">      for (int i = 0; i &lt; parentStates; ++i) {</span>
<span class="nc bnc" id="L739" title="All 2 branches missed.">        for (int j = 0; j &lt; leftStates; ++j) {</span>
<span class="nc bnc" id="L740" title="All 2 branches missed.">          for (int k = 0; k &lt; rightStates; ++k) {</span>
<span class="nc" id="L741">            double weight = transitions[i][j][k];</span>
<span class="nc" id="L742">            betas[i][j][k] = SloppyMath.logAdd(betas[i][j][k], weight + stateWeights[i]);</span>
<span class="nc" id="L743">            leftWeights[j] = SloppyMath.logAdd(leftWeights[j], weight + stateWeights[i]);</span>
<span class="nc" id="L744">            rightWeights[k] = SloppyMath.logAdd(rightWeights[k], weight + stateWeights[i]);</span>
          }
        }
      }
<span class="nc" id="L748">      position = recalculateTemporaryBetas(tree.children()[0], leftWeights, position, unaryTransitions, binaryTransitions, totalStateMass, tempUnaryBetas, tempBinaryBetas);</span>
<span class="nc" id="L749">      position = recalculateTemporaryBetas(tree.children()[1], rightWeights, position, unaryTransitions, binaryTransitions, totalStateMass, tempUnaryBetas, tempBinaryBetas);</span>
    }
<span class="nc" id="L751">    return position;</span>
  }

  public void rescaleTemporaryBetas(TwoDimensionalMap&lt;String, String, double[][]&gt; tempUnaryBetas,
                                    ThreeDimensionalMap&lt;String, String, String, double[][][]&gt; tempBinaryBetas) {
<span class="nc bnc" id="L756" title="All 2 branches missed.">    for (String parent : tempUnaryBetas.firstKeySet()) {</span>
<span class="nc bnc" id="L757" title="All 2 branches missed.">      for (String child : tempUnaryBetas.get(parent).keySet()) {</span>
<span class="nc" id="L758">        double[][] betas = tempUnaryBetas.get(parent).get(child);</span>
<span class="nc" id="L759">        int parentStates = betas.length;</span>
<span class="nc" id="L760">        int childStates = betas[0].length;</span>
<span class="nc bnc" id="L761" title="All 2 branches missed.">        for (int i = 0; i &lt; parentStates; ++i) {</span>
<span class="nc" id="L762">          double sum = Double.NEGATIVE_INFINITY;</span>
<span class="nc bnc" id="L763" title="All 2 branches missed.">          for (int j = 0; j &lt; childStates; ++j) {</span>
<span class="nc" id="L764">            sum = SloppyMath.logAdd(sum, betas[i][j]);</span>
          }
<span class="nc bnc" id="L766" title="All 2 branches missed.">          if (Double.isInfinite(sum)) {</span>
<span class="nc bnc" id="L767" title="All 2 branches missed.">            for (int j = 0; j &lt; childStates; ++j) {</span>
<span class="nc" id="L768">              betas[i][j] = -Math.log(childStates);</span>
            }
          } else {
<span class="nc bnc" id="L771" title="All 2 branches missed.">            for (int j = 0; j &lt; childStates; ++j) {</span>
<span class="nc" id="L772">              betas[i][j] -= sum;</span>
            }
          }
        }
<span class="nc" id="L776">      }</span>
<span class="nc" id="L777">    }</span>

<span class="nc bnc" id="L779" title="All 2 branches missed.">    for (String parent : tempBinaryBetas.firstKeySet()) {</span>
<span class="nc bnc" id="L780" title="All 2 branches missed.">      for (String left : tempBinaryBetas.get(parent).firstKeySet()) {</span>
<span class="nc bnc" id="L781" title="All 2 branches missed.">        for (String right : tempBinaryBetas.get(parent).get(left).keySet()) {</span>
<span class="nc" id="L782">          double[][][] betas = tempBinaryBetas.get(parent).get(left).get(right);</span>
<span class="nc" id="L783">          int parentStates = betas.length;</span>
<span class="nc" id="L784">          int leftStates = betas[0].length;</span>
<span class="nc" id="L785">          int rightStates = betas[0][0].length;</span>
<span class="nc bnc" id="L786" title="All 2 branches missed.">          for (int i = 0; i &lt; parentStates; ++i) {</span>
<span class="nc" id="L787">            double sum = Double.NEGATIVE_INFINITY;</span>
<span class="nc bnc" id="L788" title="All 2 branches missed.">            for (int j = 0; j &lt; leftStates; ++j) {</span>
<span class="nc bnc" id="L789" title="All 2 branches missed.">              for (int k = 0; k &lt; rightStates; ++k) {</span>
<span class="nc" id="L790">                sum = SloppyMath.logAdd(sum, betas[i][j][k]);</span>
              }
            }
<span class="nc bnc" id="L793" title="All 2 branches missed.">            if (Double.isInfinite(sum)) {</span>
<span class="nc bnc" id="L794" title="All 2 branches missed.">              for (int j = 0; j &lt; leftStates; ++j) {</span>
<span class="nc bnc" id="L795" title="All 2 branches missed.">                for (int k = 0; k &lt; rightStates; ++k) {</span>
<span class="nc" id="L796">                  betas[i][j][k] = -Math.log(leftStates * rightStates);</span>
                }
              }
            } else {
<span class="nc bnc" id="L800" title="All 2 branches missed.">              for (int j = 0; j &lt; leftStates; ++j) {</span>
<span class="nc bnc" id="L801" title="All 2 branches missed.">                for (int k = 0; k &lt; rightStates; ++k) {</span>
<span class="nc" id="L802">                  betas[i][j][k] -= sum;</span>
                }
              }
            }
          }
<span class="nc" id="L807">        }</span>
<span class="nc" id="L808">      }</span>
<span class="nc" id="L809">    }</span>
<span class="nc" id="L810">  }</span>

  public void recountTree(Tree tree, boolean splitStates,
                          IdentityHashMap&lt;Tree, double[][]&gt; unaryTransitions,
                          IdentityHashMap&lt;Tree, double[][][]&gt; binaryTransitions) {
<span class="nc" id="L815">    IdentityHashMap&lt;Tree, double[]&gt; probIn = new IdentityHashMap&lt;&gt;();</span>
<span class="nc" id="L816">    IdentityHashMap&lt;Tree, double[]&gt; probOut = new IdentityHashMap&lt;&gt;();</span>
<span class="nc" id="L817">    recountTree(tree, splitStates, probIn, probOut, unaryTransitions, binaryTransitions);</span>
<span class="nc" id="L818">  }</span>

  public void recountTree(Tree tree, boolean splitStates,
                          IdentityHashMap&lt;Tree, double[]&gt; probIn,
                          IdentityHashMap&lt;Tree, double[]&gt; probOut,
                          IdentityHashMap&lt;Tree, double[][]&gt; unaryTransitions,
                          IdentityHashMap&lt;Tree, double[][][]&gt; binaryTransitions) {
<span class="nc" id="L825">    recountInside(tree, splitStates, 0, probIn);</span>
<span class="nc bnc" id="L826" title="All 2 branches missed.">    if (DEBUG()) {</span>
<span class="nc" id="L827">      System.out.println(&quot;ROOT PROBABILITY: &quot; + probIn.get(tree)[0]);</span>
    }
<span class="nc" id="L829">    recountOutside(tree, probIn, probOut);</span>
<span class="nc" id="L830">    recountWeights(tree, probIn, probOut, unaryTransitions, binaryTransitions);</span>
<span class="nc" id="L831">  }</span>

  public void recountWeights(Tree tree,
                             IdentityHashMap&lt;Tree, double[]&gt; probIn,
                             IdentityHashMap&lt;Tree, double[]&gt; probOut,
                             IdentityHashMap&lt;Tree, double[][]&gt; unaryTransitions,
                             IdentityHashMap&lt;Tree, double[][][]&gt; binaryTransitions) {
<span class="nc bnc" id="L838" title="All 4 branches missed.">    if (tree.isLeaf() || tree.isPreTerminal()) {</span>
<span class="nc" id="L839">      return;</span>
    }
<span class="nc bnc" id="L841" title="All 2 branches missed.">    if (tree.children().length == 1) {</span>
<span class="nc" id="L842">      Tree child = tree.children()[0];</span>
<span class="nc" id="L843">      String parentLabel = tree.label().value();</span>
<span class="nc" id="L844">      String childLabel = child.label().value();</span>
<span class="nc" id="L845">      double[][] betas = unaryBetas.get(parentLabel, childLabel);</span>
<span class="nc" id="L846">      double[] childInside = probIn.get(child);</span>
<span class="nc" id="L847">      double[] parentOutside = probOut.get(tree);</span>
<span class="nc" id="L848">      int parentStates = betas.length;</span>
<span class="nc" id="L849">      int childStates = betas[0].length;</span>
<span class="nc" id="L850">      double[][] transitions = new double[parentStates][childStates];</span>
<span class="nc" id="L851">      unaryTransitions.put(tree, transitions);</span>
<span class="nc bnc" id="L852" title="All 2 branches missed.">      for (int i = 0; i &lt; parentStates; ++i) {</span>
<span class="nc bnc" id="L853" title="All 2 branches missed.">        for (int j = 0; j &lt; childStates; ++j) {</span>
<span class="nc" id="L854">          transitions[i][j] = parentOutside[i] + childInside[j] + betas[i][j];</span>
        }
      }
      // Renormalize.  Note that we renormalize to 1, regardless of
      // the original total.
      // TODO: smoothing?
<span class="nc bnc" id="L860" title="All 2 branches missed.">      for (int i = 0; i &lt; parentStates; ++i) {</span>
<span class="nc" id="L861">        double total = Double.NEGATIVE_INFINITY;</span>
<span class="nc bnc" id="L862" title="All 2 branches missed.">        for (int j = 0; j &lt; childStates; ++j) {</span>
<span class="nc" id="L863">          total = SloppyMath.logAdd(total, transitions[i][j]);</span>
        }
        // By subtracting off the log total, we make it so the log sum
        // of the transitions is 0, meaning the sum of the actual
        // transitions is 1.  It works if you do the math...
<span class="nc bnc" id="L868" title="All 2 branches missed.">        if (Double.isInfinite(total)) {</span>
<span class="nc" id="L869">          double transition = -Math.log(childStates);</span>
<span class="nc bnc" id="L870" title="All 2 branches missed.">          for (int j = 0; j &lt; childStates; ++j) {</span>
<span class="nc" id="L871">            transitions[i][j] = transition;</span>
          }
<span class="nc" id="L873">        } else {</span>
<span class="nc bnc" id="L874" title="All 2 branches missed.">          for (int j = 0; j &lt; childStates; ++j) {</span>
<span class="nc" id="L875">            transitions[i][j] = transitions[i][j] - total;</span>
          }
        }
      }
<span class="nc" id="L879">      recountWeights(child, probIn, probOut, unaryTransitions, binaryTransitions);</span>
<span class="nc" id="L880">    } else { // length == 2</span>
<span class="nc" id="L881">      Tree left = tree.children()[0];</span>
<span class="nc" id="L882">      Tree right = tree.children()[1];</span>
<span class="nc" id="L883">      String parentLabel = tree.label().value();</span>
<span class="nc" id="L884">      String leftLabel = left.label().value();</span>
<span class="nc" id="L885">      String rightLabel = right.label().value();</span>
<span class="nc" id="L886">      double[][][] betas = binaryBetas.get(parentLabel, leftLabel, rightLabel);</span>
<span class="nc" id="L887">      double[] leftInside = probIn.get(left);</span>
<span class="nc" id="L888">      double[] rightInside = probIn.get(right);</span>
<span class="nc" id="L889">      double[] parentOutside = probOut.get(tree);</span>
<span class="nc" id="L890">      int parentStates = betas.length;</span>
<span class="nc" id="L891">      int leftStates = betas[0].length;</span>
<span class="nc" id="L892">      int rightStates = betas[0][0].length;</span>
<span class="nc" id="L893">      double[][][] transitions = new double[parentStates][leftStates][rightStates];</span>
<span class="nc" id="L894">      binaryTransitions.put(tree, transitions);</span>
<span class="nc bnc" id="L895" title="All 2 branches missed.">      for (int i = 0; i &lt; parentStates; ++i) {</span>
<span class="nc bnc" id="L896" title="All 2 branches missed.">        for (int j = 0; j &lt; leftStates; ++j) {</span>
<span class="nc bnc" id="L897" title="All 2 branches missed.">          for (int k = 0; k &lt; rightStates; ++k) {</span>
<span class="nc" id="L898">            transitions[i][j][k] = parentOutside[i] + leftInside[j] + rightInside[k] + betas[i][j][k];</span>
          }
        }
      }
      // Renormalize.  Note that we renormalize to 1, regardless of
      // the original total.
      // TODO: smoothing?
<span class="nc bnc" id="L905" title="All 2 branches missed.">      for (int i = 0; i &lt; parentStates; ++i) {</span>
<span class="nc" id="L906">        double total = Double.NEGATIVE_INFINITY;</span>
<span class="nc bnc" id="L907" title="All 2 branches missed.">        for (int j = 0; j &lt; leftStates; ++j) {</span>
<span class="nc bnc" id="L908" title="All 2 branches missed.">          for (int k = 0; k &lt; rightStates; ++k) {</span>
<span class="nc" id="L909">            total = SloppyMath.logAdd(total, transitions[i][j][k]);</span>
          }
        }
        // By subtracting off the log total, we make it so the log sum
        // of the transitions is 0, meaning the sum of the actual
        // transitions is 1.  It works if you do the math...
<span class="nc bnc" id="L915" title="All 2 branches missed.">        if (Double.isInfinite(total)) {</span>
<span class="nc" id="L916">          double transition = -Math.log(leftStates * rightStates);</span>
<span class="nc bnc" id="L917" title="All 2 branches missed.">          for (int j = 0; j &lt; leftStates; ++j) {</span>
<span class="nc bnc" id="L918" title="All 2 branches missed.">            for (int k = 0; k &lt; rightStates; ++k) {</span>
<span class="nc" id="L919">              transitions[i][j][k] = transition;</span>
            }
          }
<span class="nc" id="L922">        } else {</span>
<span class="nc bnc" id="L923" title="All 2 branches missed.">          for (int j = 0; j &lt; leftStates; ++j) {</span>
<span class="nc bnc" id="L924" title="All 2 branches missed.">            for (int k = 0; k &lt; rightStates; ++k) {</span>
<span class="nc" id="L925">              transitions[i][j][k] = transitions[i][j][k] - total;</span>
            }
          }
        }
      }
<span class="nc" id="L930">      recountWeights(left, probIn, probOut, unaryTransitions, binaryTransitions);</span>
<span class="nc" id="L931">      recountWeights(right, probIn, probOut, unaryTransitions, binaryTransitions);</span>
    }
<span class="nc" id="L933">  }</span>

  public void recountOutside(Tree tree,
                             IdentityHashMap&lt;Tree, double[]&gt; probIn,
                             IdentityHashMap&lt;Tree, double[]&gt; probOut) {
<span class="nc" id="L938">    double[] rootScores = { 0.0 };</span>
<span class="nc" id="L939">    probOut.put(tree, rootScores);</span>
<span class="nc" id="L940">    recurseOutside(tree, probIn, probOut);</span>
<span class="nc" id="L941">  }</span>

  public void recurseOutside(Tree tree,
                             IdentityHashMap&lt;Tree, double[]&gt; probIn,
                             IdentityHashMap&lt;Tree, double[]&gt; probOut) {
<span class="nc bnc" id="L946" title="All 4 branches missed.">    if (tree.isLeaf() || tree.isPreTerminal()) {</span>
<span class="nc" id="L947">      return;</span>
    }
<span class="nc bnc" id="L949" title="All 2 branches missed.">    if (tree.children().length == 1) {</span>
<span class="nc" id="L950">      recountOutside(tree.children()[0], tree, probIn, probOut);</span>
    } else { // length == 2
<span class="nc" id="L952">      recountOutside(tree.children()[0], tree.children()[1], tree,</span>
                     probIn, probOut);
    }
<span class="nc" id="L955">  }</span>

  public void recountOutside(Tree child, Tree parent,
                             IdentityHashMap&lt;Tree, double[]&gt; probIn,
                             IdentityHashMap&lt;Tree, double[]&gt; probOut) {
<span class="nc" id="L960">    String parentLabel = parent.label().value();</span>
<span class="nc" id="L961">    String childLabel = child.label().value();</span>
<span class="nc" id="L962">    double[] parentScores = probOut.get(parent);</span>
<span class="nc" id="L963">    double[][] betas = unaryBetas.get(parentLabel, childLabel);</span>
<span class="nc" id="L964">    int parentStates = betas.length;</span>
<span class="nc" id="L965">    int childStates = betas[0].length;</span>

<span class="nc" id="L967">    double[] scores = neginfDoubles(childStates);</span>
<span class="nc" id="L968">    probOut.put(child, scores);</span>

<span class="nc bnc" id="L970" title="All 2 branches missed.">    for (int i = 0; i &lt; parentStates; ++i) {</span>
<span class="nc bnc" id="L971" title="All 2 branches missed.">      for (int j = 0; j &lt; childStates; ++j) {</span>
        // TODO: no inside scores here, right?
<span class="nc" id="L973">        scores[j] = SloppyMath.logAdd(scores[j], betas[i][j] + parentScores[i]);</span>
      }
    }

<span class="nc" id="L977">    recurseOutside(child, probIn, probOut);</span>
<span class="nc" id="L978">  }</span>

  public void recountOutside(Tree left, Tree right, Tree parent,
                             IdentityHashMap&lt;Tree, double[]&gt; probIn,
                             IdentityHashMap&lt;Tree, double[]&gt; probOut) {
<span class="nc" id="L983">    String parentLabel = parent.label().value();</span>
<span class="nc" id="L984">    String leftLabel = left.label().value();</span>
<span class="nc" id="L985">    String rightLabel = right.label().value();</span>
<span class="nc" id="L986">    double[] leftInsideScores = probIn.get(left);</span>
<span class="nc" id="L987">    double[] rightInsideScores = probIn.get(right);</span>
<span class="nc" id="L988">    double[] parentScores = probOut.get(parent);</span>
<span class="nc" id="L989">    double[][][] betas = binaryBetas.get(parentLabel, leftLabel, rightLabel);</span>
<span class="nc" id="L990">    int parentStates = betas.length;</span>
<span class="nc" id="L991">    int leftStates = betas[0].length;</span>
<span class="nc" id="L992">    int rightStates = betas[0][0].length;</span>

<span class="nc" id="L994">    double[] leftScores = neginfDoubles(leftStates);</span>
<span class="nc" id="L995">    probOut.put(left, leftScores);</span>
<span class="nc" id="L996">    double[] rightScores = neginfDoubles(rightStates);</span>
<span class="nc" id="L997">    probOut.put(right, rightScores);</span>

<span class="nc bnc" id="L999" title="All 2 branches missed.">    for (int i = 0; i &lt; parentStates; ++i) {</span>
<span class="nc bnc" id="L1000" title="All 2 branches missed.">      for (int j = 0; j &lt; leftStates; ++j) {</span>
<span class="nc bnc" id="L1001" title="All 2 branches missed.">        for (int k = 0; k &lt; rightStates; ++k) {</span>
<span class="nc" id="L1002">          leftScores[j] = SloppyMath.logAdd(leftScores[j], betas[i][j][k] + parentScores[i] + rightInsideScores[k]);</span>
<span class="nc" id="L1003">          rightScores[k] = SloppyMath.logAdd(rightScores[k], betas[i][j][k] + parentScores[i] + leftInsideScores[j]);</span>
        }
      }
    }

<span class="nc" id="L1008">    recurseOutside(left, probIn, probOut);</span>
<span class="nc" id="L1009">    recurseOutside(right, probIn, probOut);</span>
<span class="nc" id="L1010">  }</span>

  public int recountInside(Tree tree, boolean splitStates, int loc,
                           IdentityHashMap&lt;Tree, double[]&gt; probIn) {
<span class="nc bnc" id="L1014" title="All 2 branches missed.">    if (tree.isLeaf()) {</span>
<span class="nc" id="L1015">      throw new RuntimeException();</span>
<span class="nc bnc" id="L1016" title="All 2 branches missed.">    } else if (tree.isPreTerminal()) {</span>
<span class="nc" id="L1017">      int stateCount = getStateSplitCount(tree);</span>
<span class="nc" id="L1018">      String word = tree.children()[0].label().value();</span>
<span class="nc" id="L1019">      String tag = tree.label().value();</span>

<span class="nc" id="L1021">      double[] scores = new double[stateCount];</span>
<span class="nc" id="L1022">      probIn.put(tree, scores);</span>

<span class="nc bnc" id="L1024" title="All 4 branches missed.">      if (splitStates &amp;&amp; !tag.equals(Lexicon.BOUNDARY_TAG)) {</span>
<span class="nc bnc" id="L1025" title="All 2 branches missed.">        for (int i = 0; i &lt; stateCount / 2; ++i) {</span>
<span class="nc" id="L1026">          IntTaggedWord tw = new IntTaggedWord(word, state(tag, i), wordIndex, tagIndex);</span>
<span class="nc" id="L1027">          double logProb = lex.score(tw, loc, word, null);</span>
<span class="nc" id="L1028">          double wordWeight = 0.45 + random.nextDouble() * 0.1;</span>
<span class="nc" id="L1029">          scores[i * 2] = logProb + Math.log(wordWeight);</span>
<span class="nc" id="L1030">          scores[i * 2 + 1] = logProb + Math.log(1.0 - wordWeight);</span>
<span class="nc bnc" id="L1031" title="All 2 branches missed.">          if (DEBUG()) {</span>
<span class="nc" id="L1032">            System.out.println(&quot;Lexicon log prob &quot; + state(tag, i) + &quot;-&quot; + word + &quot;: &quot; + logProb);</span>
<span class="nc" id="L1033">            System.out.println(&quot;  Log Split -&gt; &quot; + scores[i * 2] + &quot;,&quot; + scores[i * 2 + 1]);</span>
          }
        }
      } else {
<span class="nc bnc" id="L1037" title="All 2 branches missed.">        for (int i = 0; i &lt; stateCount; ++i) {</span>
<span class="nc" id="L1038">          IntTaggedWord tw = new IntTaggedWord(word, state(tag, i), wordIndex, tagIndex);</span>
<span class="nc" id="L1039">          double prob = lex.score(tw, loc, word, null);</span>
<span class="nc bnc" id="L1040" title="All 2 branches missed.">          if (DEBUG()) {</span>
<span class="nc" id="L1041">            System.out.println(&quot;Lexicon log prob &quot; + state(tag, i) + &quot;-&quot; + word + &quot;: &quot; + prob);</span>
          }
<span class="nc" id="L1043">          scores[i] = prob;</span>
        }
      }
<span class="nc" id="L1046">      loc = loc + 1;</span>
<span class="nc bnc" id="L1047" title="All 2 branches missed.">    } else if (tree.children().length == 1) {</span>
<span class="nc" id="L1048">      loc = recountInside(tree.children()[0], splitStates, loc, probIn);</span>
<span class="nc" id="L1049">      double[] childScores = probIn.get(tree.children()[0]);</span>
<span class="nc" id="L1050">      String parentLabel = tree.label().value();</span>
<span class="nc" id="L1051">      String childLabel = tree.children()[0].label().value();</span>
<span class="nc" id="L1052">      double[][] betas = unaryBetas.get(parentLabel, childLabel);</span>
<span class="nc" id="L1053">      int parentStates = betas.length; // size of the first key</span>
<span class="nc" id="L1054">      int childStates = betas[0].length;</span>

<span class="nc" id="L1056">      double[] scores = neginfDoubles(parentStates);</span>
<span class="nc" id="L1057">      probIn.put(tree, scores);</span>

<span class="nc bnc" id="L1059" title="All 2 branches missed.">      for (int i = 0; i &lt; parentStates; ++i) {</span>
<span class="nc bnc" id="L1060" title="All 2 branches missed.">        for (int j = 0; j &lt; childStates; ++j) {</span>
<span class="nc" id="L1061">          scores[i] = SloppyMath.logAdd(scores[i], childScores[j] + betas[i][j]);</span>
        }
      }
<span class="nc bnc" id="L1064" title="All 2 branches missed.">      if (DEBUG()) {</span>
<span class="nc" id="L1065">        System.out.println(parentLabel + &quot; -&gt; &quot; + childLabel);</span>
<span class="nc bnc" id="L1066" title="All 2 branches missed.">        for (int i = 0; i &lt; parentStates; ++i) {</span>
<span class="nc" id="L1067">          System.out.println(&quot;  &quot; + i + &quot;:&quot; + scores[i]);</span>
<span class="nc bnc" id="L1068" title="All 2 branches missed.">          for (int j = 0; j &lt; childStates; ++j) {</span>
<span class="nc" id="L1069">            System.out.println(&quot;    &quot; + i + &quot;,&quot; + j + &quot;: &quot; + betas[i][j] + &quot; | &quot; + Math.exp(betas[i][j]));</span>
          }
        }
      }
<span class="nc" id="L1073">    } else { // length == 2</span>
<span class="nc" id="L1074">      loc = recountInside(tree.children()[0], splitStates, loc, probIn);</span>
<span class="nc" id="L1075">      loc = recountInside(tree.children()[1], splitStates, loc, probIn);</span>
<span class="nc" id="L1076">      double[] leftScores = probIn.get(tree.children()[0]);</span>
<span class="nc" id="L1077">      double[] rightScores = probIn.get(tree.children()[1]);</span>
<span class="nc" id="L1078">      String parentLabel = tree.label().value();</span>
<span class="nc" id="L1079">      String leftLabel = tree.children()[0].label().value();</span>
<span class="nc" id="L1080">      String rightLabel = tree.children()[1].label().value();</span>
<span class="nc" id="L1081">      double[][][] betas = binaryBetas.get(parentLabel, leftLabel, rightLabel);</span>
<span class="nc" id="L1082">      int parentStates = betas.length;</span>
<span class="nc" id="L1083">      int leftStates = betas[0].length;</span>
<span class="nc" id="L1084">      int rightStates = betas[0][0].length;</span>

<span class="nc" id="L1086">      double[] scores = neginfDoubles(parentStates);</span>
<span class="nc" id="L1087">      probIn.put(tree, scores);</span>

<span class="nc bnc" id="L1089" title="All 2 branches missed.">      for (int i = 0; i &lt; parentStates; ++i) {</span>
<span class="nc bnc" id="L1090" title="All 2 branches missed.">        for (int j = 0; j &lt; leftStates; ++j) {</span>
<span class="nc bnc" id="L1091" title="All 2 branches missed.">          for (int k = 0; k &lt; rightStates; ++k) {</span>
<span class="nc" id="L1092">            scores[i] = SloppyMath.logAdd(scores[i], leftScores[j] + rightScores[k] + betas[i][j][k]);</span>
          }
        }
      }
<span class="nc bnc" id="L1096" title="All 2 branches missed.">      if (DEBUG()) {</span>
<span class="nc" id="L1097">        System.out.println(parentLabel + &quot; -&gt; &quot; + leftLabel + &quot;,&quot; + rightLabel);</span>
<span class="nc bnc" id="L1098" title="All 2 branches missed.">        for (int i = 0; i &lt; parentStates; ++i) {</span>
<span class="nc" id="L1099">          System.out.println(&quot;  &quot; + i + &quot;:&quot; + scores[i]);</span>
<span class="nc bnc" id="L1100" title="All 2 branches missed.">          for (int j = 0; j &lt; leftStates; ++j) {</span>
<span class="nc bnc" id="L1101" title="All 2 branches missed.">            for (int k = 0; k &lt; rightStates; ++k) {</span>
<span class="nc" id="L1102">              System.out.println(&quot;    &quot; + i + &quot;,&quot; + j + &quot;,&quot; + k + &quot;: &quot; + betas[i][j][k] + &quot; | &quot; + Math.exp(betas[i][j][k]));</span>
            }
          }
        }
      }
    }
<span class="nc" id="L1108">    return loc;</span>
  }

  public void mergeStates() {
<span class="nc bnc" id="L1112" title="All 2 branches missed.">    if (op.trainOptions.splitRecombineRate &lt;= 0.0) {</span>
<span class="nc" id="L1113">      return;</span>
    }

    // we go through the machinery to sum up the temporary betas,
    // counting the total mass
<span class="nc" id="L1118">    TwoDimensionalMap&lt;String, String, double[][]&gt; tempUnaryBetas = new TwoDimensionalMap&lt;&gt;();</span>
<span class="nc" id="L1119">    ThreeDimensionalMap&lt;String, String, String, double[][][]&gt; tempBinaryBetas = new ThreeDimensionalMap&lt;&gt;();</span>
<span class="nc" id="L1120">    Map&lt;String, double[]&gt; totalStateMass = Generics.newHashMap();</span>
<span class="nc" id="L1121">    recalculateTemporaryBetas(false, totalStateMass, tempUnaryBetas, tempBinaryBetas);</span>

    // Next, for each tree we count the effect of merging its
    // annotations.  We only consider the most recently split
    // annotations as candidates for merging.
<span class="nc" id="L1126">    Map&lt;String, double[]&gt; deltaAnnotations = Generics.newHashMap();</span>
<span class="nc bnc" id="L1127" title="All 2 branches missed.">    for (Tree tree : trees) {</span>
<span class="nc" id="L1128">      countMergeEffects(tree, totalStateMass, deltaAnnotations);</span>
<span class="nc" id="L1129">    }</span>

    // Now we have a map of the (approximate) likelihood loss from
    // merging each state.  We merge the ones that provide the least
    // benefit, up to the splitRecombineRate
<span class="nc" id="L1134">    List&lt;Triple&lt;String, Integer, Double&gt;&gt; sortedDeltas =</span>
            new ArrayList&lt;&gt;();
<span class="nc bnc" id="L1136" title="All 2 branches missed.">    for (String state : deltaAnnotations.keySet()) {</span>
<span class="nc" id="L1137">      double[] scores = deltaAnnotations.get(state);</span>
<span class="nc bnc" id="L1138" title="All 2 branches missed.">      for (int i = 0; i &lt; scores.length; ++i) {</span>
<span class="nc" id="L1139">        sortedDeltas.add(new Triple&lt;&gt;(state, i * 2, scores[i]));</span>
      }
<span class="nc" id="L1141">    }</span>
<span class="nc" id="L1142">    Collections.sort(sortedDeltas, new Comparator&lt;Triple&lt;String, Integer, Double&gt;&gt;() {</span>
        public int compare(Triple&lt;String, Integer, Double&gt; first,
                           Triple&lt;String, Integer, Double&gt; second) {
          // The most useful splits will have a large loss in
          // likelihood if they are merged.  Thus, we want those at
          // the end of the list.  This means we make the comparison
          // &quot;backwards&quot;, sorting from high to low.
<span class="nc" id="L1149">          return Double.compare(second.third(), first.third());</span>
        }
<span class="nc bnc" id="L1151" title="All 2 branches missed.">        public boolean equals(Object o) { return o == this; }</span>
      });

    // for (Triple&lt;String, Integer, Double&gt; delta : sortedDeltas) {
    //   System.out.println(delta.first() + &quot;-&quot; + delta.second() + &quot;: &quot; + delta.third());
    // }
    // System.out.println(&quot;-------------&quot;);

    // Only merge a fraction of the splits based on what the user
    // originally asked for
<span class="nc" id="L1161">    int splitsToMerge = (int) (sortedDeltas.size() * op.trainOptions.splitRecombineRate);</span>
<span class="nc" id="L1162">    splitsToMerge = Math.max(0, splitsToMerge);</span>
<span class="nc" id="L1163">    splitsToMerge = Math.min(sortedDeltas.size() - 1, splitsToMerge);</span>
<span class="nc" id="L1164">    sortedDeltas = sortedDeltas.subList(0, splitsToMerge);</span>

<span class="nc" id="L1166">    System.out.println();</span>
<span class="nc" id="L1167">    System.out.println(sortedDeltas);</span>

<span class="nc" id="L1169">    Map&lt;String, int[]&gt; mergeCorrespondence = buildMergeCorrespondence(sortedDeltas);</span>

<span class="nc" id="L1171">    recalculateMergedBetas(mergeCorrespondence);</span>

<span class="nc bnc" id="L1173" title="All 2 branches missed.">    for (Triple&lt;String, Integer, Double&gt; delta : sortedDeltas) {</span>
<span class="nc" id="L1174">      stateSplitCounts.decrementCount(delta.first(), 1);</span>
<span class="nc" id="L1175">    }</span>
<span class="nc" id="L1176">  }</span>

  public void recalculateMergedBetas(Map&lt;String, int[]&gt; mergeCorrespondence) {
<span class="nc" id="L1179">    TwoDimensionalMap&lt;String, String, double[][]&gt; tempUnaryBetas = new TwoDimensionalMap&lt;&gt;();</span>
<span class="nc" id="L1180">    ThreeDimensionalMap&lt;String, String, String, double[][][]&gt; tempBinaryBetas = new ThreeDimensionalMap&lt;&gt;();</span>

<span class="nc" id="L1182">    tempWordIndex = new HashIndex&lt;&gt;();</span>
<span class="nc" id="L1183">    tempTagIndex = new HashIndex&lt;&gt;();</span>
<span class="nc" id="L1184">    tempLex = op.tlpParams.lex(op, tempWordIndex, tempTagIndex);</span>
<span class="nc" id="L1185">    tempLex.initializeTraining(trainSize);</span>

<span class="nc bnc" id="L1187" title="All 2 branches missed.">    for (Tree tree : trees) {</span>
<span class="nc" id="L1188">      double treeWeight = treeWeights.getCount(tree);</span>
<span class="nc" id="L1189">      double[] stateWeights = { Math.log(treeWeight) };</span>
<span class="nc" id="L1190">      tempLex.incrementTreesRead(treeWeight);</span>

<span class="nc" id="L1192">      IdentityHashMap&lt;Tree, double[][]&gt; oldUnaryTransitions = new IdentityHashMap&lt;&gt;();</span>
<span class="nc" id="L1193">      IdentityHashMap&lt;Tree, double[][][]&gt; oldBinaryTransitions = new IdentityHashMap&lt;&gt;();</span>
<span class="nc" id="L1194">      recountTree(tree, false, oldUnaryTransitions, oldBinaryTransitions);</span>

<span class="nc" id="L1196">      IdentityHashMap&lt;Tree, double[][]&gt; unaryTransitions = new IdentityHashMap&lt;&gt;();</span>
<span class="nc" id="L1197">      IdentityHashMap&lt;Tree, double[][][]&gt; binaryTransitions = new IdentityHashMap&lt;&gt;();</span>
<span class="nc" id="L1198">      mergeTransitions(tree, oldUnaryTransitions, oldBinaryTransitions, unaryTransitions, binaryTransitions, stateWeights, mergeCorrespondence);</span>

<span class="nc" id="L1200">      recalculateTemporaryBetas(tree, stateWeights, 0, unaryTransitions, binaryTransitions,</span>
                                null, tempUnaryBetas, tempBinaryBetas);
<span class="nc" id="L1202">    }</span>

<span class="nc" id="L1204">    tempLex.finishTraining();</span>
<span class="nc" id="L1205">    useNewBetas(false, tempUnaryBetas, tempBinaryBetas);</span>
<span class="nc" id="L1206">  }</span>

  /**
   * Given a tree and the original set of transition probabilities
   * from one state to the next in the tree, along with a list of the
   * weights in the tree and a count of the mass in each substate at
   * the current node, this method merges the probabilities as
   * necessary.  The results go into newUnaryTransitions and
   * newBinaryTransitions.
   */
  public void mergeTransitions(Tree parent,
                               IdentityHashMap&lt;Tree, double[][]&gt; oldUnaryTransitions,
                               IdentityHashMap&lt;Tree, double[][][]&gt; oldBinaryTransitions,
                               IdentityHashMap&lt;Tree, double[][]&gt; newUnaryTransitions,
                               IdentityHashMap&lt;Tree, double[][][]&gt; newBinaryTransitions,
                               double[] stateWeights,
                               Map&lt;String, int[]&gt; mergeCorrespondence) {
<span class="nc bnc" id="L1223" title="All 4 branches missed.">    if (parent.isPreTerminal() || parent.isLeaf()) {</span>
<span class="nc" id="L1224">      return;</span>
    }
<span class="nc bnc" id="L1226" title="All 2 branches missed.">    if (parent.children().length == 1) {</span>
<span class="nc" id="L1227">      double[][] oldTransitions = oldUnaryTransitions.get(parent);</span>

<span class="nc" id="L1229">      String parentLabel = parent.label().value();</span>
<span class="nc" id="L1230">      int[] parentCorrespondence = mergeCorrespondence.get(parentLabel);</span>
<span class="nc" id="L1231">      int parentStates = parentCorrespondence[parentCorrespondence.length - 1] + 1;</span>

<span class="nc" id="L1233">      String childLabel = parent.children()[0].label().value();</span>
<span class="nc" id="L1234">      int[] childCorrespondence = mergeCorrespondence.get(childLabel);</span>
<span class="nc" id="L1235">      int childStates = childCorrespondence[childCorrespondence.length - 1] + 1;</span>

      // System.out.println(&quot;P: &quot; + parentLabel + &quot; &quot; + parentStates +
      //                    &quot; C: &quot; + childLabel + &quot; &quot; + childStates);


      // Add up the probabilities of transitioning to each state,
      // scaled by the probability of being in a given state to begin
      // with.  This accounts for when two states in the parent are
      // collapsed into one state.
<span class="nc" id="L1245">      double[][] newTransitions = new double[parentStates][childStates];</span>
<span class="nc bnc" id="L1246" title="All 2 branches missed.">      for (int i = 0; i &lt; parentStates; ++i) {</span>
<span class="nc bnc" id="L1247" title="All 2 branches missed.">        for (int j = 0; j &lt; childStates; ++j) {</span>
<span class="nc" id="L1248">          newTransitions[i][j] = Double.NEGATIVE_INFINITY;</span>
        }
      }
<span class="nc" id="L1251">      newUnaryTransitions.put(parent, newTransitions);</span>
<span class="nc bnc" id="L1252" title="All 2 branches missed.">      for (int i = 0; i &lt; oldTransitions.length; ++i) {</span>
<span class="nc" id="L1253">        int ti = parentCorrespondence[i];</span>
<span class="nc bnc" id="L1254" title="All 2 branches missed.">        for (int j = 0; j &lt; oldTransitions[0].length; ++j) {</span>
<span class="nc" id="L1255">          int tj = childCorrespondence[j];</span>
          // System.out.println(i + &quot; &quot; + ti + &quot; &quot; + j + &quot; &quot; + tj);
<span class="nc" id="L1257">          newTransitions[ti][tj] = SloppyMath.logAdd(newTransitions[ti][tj], oldTransitions[i][j] + stateWeights[i]);</span>
        }
      }

      // renormalize
<span class="nc bnc" id="L1262" title="All 2 branches missed.">      for (int i = 0; i &lt; parentStates; ++i) {</span>
<span class="nc" id="L1263">        double total = Double.NEGATIVE_INFINITY;</span>
<span class="nc bnc" id="L1264" title="All 2 branches missed.">        for (int j = 0; j &lt; childStates; ++j) {</span>
<span class="nc" id="L1265">          total = SloppyMath.logAdd(total, newTransitions[i][j]);</span>
        }
<span class="nc bnc" id="L1267" title="All 2 branches missed.">        if (Double.isInfinite(total)) {</span>
<span class="nc bnc" id="L1268" title="All 2 branches missed.">          for (int j = 0; j &lt; childStates; ++j) {</span>
<span class="nc" id="L1269">            newTransitions[i][j] = -Math.log(childStates);</span>
          }
        } else {
<span class="nc bnc" id="L1272" title="All 2 branches missed.">          for (int j = 0; j &lt; childStates; ++j) {</span>
<span class="nc" id="L1273">            newTransitions[i][j] -= total;</span>
          }
        }
      }

<span class="nc" id="L1278">      double[] childWeights = neginfDoubles(oldTransitions[0].length);</span>
<span class="nc bnc" id="L1279" title="All 2 branches missed.">      for (int i = 0; i &lt; oldTransitions.length; ++i) {</span>
<span class="nc bnc" id="L1280" title="All 2 branches missed.">        for (int j = 0; j &lt; oldTransitions[0].length; ++j) {</span>
<span class="nc" id="L1281">          double weight = oldTransitions[i][j];</span>
<span class="nc" id="L1282">          childWeights[j] = SloppyMath.logAdd(childWeights[j], weight + stateWeights[i]);</span>
        }
      }

<span class="nc" id="L1286">      mergeTransitions(parent.children()[0], oldUnaryTransitions, oldBinaryTransitions, newUnaryTransitions, newBinaryTransitions, childWeights, mergeCorrespondence);</span>
<span class="nc" id="L1287">    } else {</span>
<span class="nc" id="L1288">      double[][][] oldTransitions = oldBinaryTransitions.get(parent);</span>

<span class="nc" id="L1290">      String parentLabel = parent.label().value();</span>
<span class="nc" id="L1291">      int[] parentCorrespondence = mergeCorrespondence.get(parentLabel);</span>
<span class="nc" id="L1292">      int parentStates = parentCorrespondence[parentCorrespondence.length - 1] + 1;</span>

<span class="nc" id="L1294">      String leftLabel = parent.children()[0].label().value();</span>
<span class="nc" id="L1295">      int[] leftCorrespondence = mergeCorrespondence.get(leftLabel);</span>
<span class="nc" id="L1296">      int leftStates = leftCorrespondence[leftCorrespondence.length - 1] + 1;</span>

<span class="nc" id="L1298">      String rightLabel = parent.children()[1].label().value();</span>
<span class="nc" id="L1299">      int[] rightCorrespondence = mergeCorrespondence.get(rightLabel);</span>
<span class="nc" id="L1300">      int rightStates = rightCorrespondence[rightCorrespondence.length - 1] + 1;</span>

      // System.out.println(&quot;P: &quot; + parentLabel + &quot; &quot; + parentStates +
      //                    &quot; L: &quot; + leftLabel + &quot; &quot; + leftStates +
      //                    &quot; R: &quot; + rightLabel + &quot; &quot; + rightStates);

<span class="nc" id="L1306">      double[][][] newTransitions = new double[parentStates][leftStates][rightStates];</span>
<span class="nc bnc" id="L1307" title="All 2 branches missed.">      for (int i = 0; i &lt; parentStates; ++i) {</span>
<span class="nc bnc" id="L1308" title="All 2 branches missed.">        for (int j = 0; j &lt; leftStates; ++j) {</span>
<span class="nc bnc" id="L1309" title="All 2 branches missed.">          for (int k = 0; k &lt; rightStates; ++k) {</span>
<span class="nc" id="L1310">            newTransitions[i][j][k] = Double.NEGATIVE_INFINITY;</span>
          }
        }
      }
<span class="nc" id="L1314">      newBinaryTransitions.put(parent, newTransitions);</span>
<span class="nc bnc" id="L1315" title="All 2 branches missed.">      for (int i = 0; i &lt; oldTransitions.length; ++i) {</span>
<span class="nc" id="L1316">        int ti = parentCorrespondence[i];</span>
<span class="nc bnc" id="L1317" title="All 2 branches missed.">        for (int j = 0; j &lt; oldTransitions[0].length; ++j) {</span>
<span class="nc" id="L1318">          int tj = leftCorrespondence[j];</span>
<span class="nc bnc" id="L1319" title="All 2 branches missed.">          for (int k = 0; k &lt; oldTransitions[0][0].length; ++k) {</span>
<span class="nc" id="L1320">            int tk = rightCorrespondence[k];</span>
            // System.out.println(i + &quot; &quot; + ti + &quot; &quot; + j + &quot; &quot; + tj + &quot; &quot; + k + &quot; &quot; + tk);
<span class="nc" id="L1322">            newTransitions[ti][tj][tk] = SloppyMath.logAdd(newTransitions[ti][tj][tk], oldTransitions[i][j][k] + stateWeights[i]);</span>
          }
        }
      }

      // renormalize
<span class="nc bnc" id="L1328" title="All 2 branches missed.">      for (int i = 0; i &lt; parentStates; ++i) {</span>
<span class="nc" id="L1329">        double total = Double.NEGATIVE_INFINITY;</span>
<span class="nc bnc" id="L1330" title="All 2 branches missed.">        for (int j = 0; j &lt; leftStates; ++j) {</span>
<span class="nc bnc" id="L1331" title="All 2 branches missed.">          for (int k = 0; k &lt; rightStates; ++k) {</span>
<span class="nc" id="L1332">            total = SloppyMath.logAdd(total, newTransitions[i][j][k]);</span>
          }
        }
<span class="nc bnc" id="L1335" title="All 2 branches missed.">        if (Double.isInfinite(total)) {</span>
<span class="nc bnc" id="L1336" title="All 2 branches missed.">          for (int j = 0; j &lt; leftStates; ++j) {</span>
<span class="nc bnc" id="L1337" title="All 2 branches missed.">            for (int k = 0; k &lt; rightStates; ++k) {</span>
<span class="nc" id="L1338">              newTransitions[i][j][k] = -Math.log(leftStates * rightStates);</span>
            }
          }
        } else {
<span class="nc bnc" id="L1342" title="All 2 branches missed.">          for (int j = 0; j &lt; leftStates; ++j) {</span>
<span class="nc bnc" id="L1343" title="All 2 branches missed.">            for (int k = 0; k &lt; rightStates; ++k) {</span>
<span class="nc" id="L1344">              newTransitions[i][j][k] -= total;</span>
            }
          }
        }
      }

<span class="nc" id="L1350">      double[] leftWeights = neginfDoubles(oldTransitions[0].length);</span>
<span class="nc" id="L1351">      double[] rightWeights = neginfDoubles(oldTransitions[0][0].length);</span>
<span class="nc bnc" id="L1352" title="All 2 branches missed.">      for (int i = 0; i &lt; oldTransitions.length; ++i) {</span>
<span class="nc bnc" id="L1353" title="All 2 branches missed.">        for (int j = 0; j &lt; oldTransitions[0].length; ++j) {</span>
<span class="nc bnc" id="L1354" title="All 2 branches missed.">          for (int k = 0; k &lt; oldTransitions[0][0].length; ++k) {</span>
<span class="nc" id="L1355">            double weight = oldTransitions[i][j][k];</span>
<span class="nc" id="L1356">            leftWeights[j] = SloppyMath.logAdd(leftWeights[j], weight + stateWeights[i]);</span>
<span class="nc" id="L1357">            rightWeights[k] = SloppyMath.logAdd(rightWeights[k], weight + stateWeights[i]);</span>
          }
        }
      }

<span class="nc" id="L1362">      mergeTransitions(parent.children()[0], oldUnaryTransitions, oldBinaryTransitions, newUnaryTransitions, newBinaryTransitions, leftWeights, mergeCorrespondence);</span>
<span class="nc" id="L1363">      mergeTransitions(parent.children()[1], oldUnaryTransitions, oldBinaryTransitions, newUnaryTransitions, newBinaryTransitions, rightWeights, mergeCorrespondence);</span>
    }
<span class="nc" id="L1365">  }</span>

  Map&lt;String, int[]&gt; buildMergeCorrespondence(List&lt;Triple&lt;String, Integer, Double&gt;&gt; deltas) {
<span class="nc" id="L1368">    Map&lt;String, int[]&gt; mergeCorrespondence = Generics.newHashMap();</span>
<span class="nc bnc" id="L1369" title="All 2 branches missed.">    for (String state : originalStates) {</span>
<span class="nc" id="L1370">      int states = getStateSplitCount(state);</span>
<span class="nc" id="L1371">      int[] correspondence = new int[states];</span>
<span class="nc bnc" id="L1372" title="All 2 branches missed.">      for (int i = 0; i &lt; states; ++i) {</span>
<span class="nc" id="L1373">        correspondence[i] = i;</span>
      }
<span class="nc" id="L1375">      mergeCorrespondence.put(state, correspondence);</span>
<span class="nc" id="L1376">    }</span>
<span class="nc bnc" id="L1377" title="All 2 branches missed.">    for (Triple&lt;String, Integer, Double&gt; merge : deltas) {</span>
<span class="nc" id="L1378">      int states = getStateSplitCount(merge.first());</span>
<span class="nc" id="L1379">      int split = merge.second();</span>
<span class="nc" id="L1380">      int[] correspondence = mergeCorrespondence.get(merge.first());</span>
<span class="nc bnc" id="L1381" title="All 2 branches missed.">      for (int i = split + 1; i &lt; states; ++i) {</span>
<span class="nc" id="L1382">        correspondence[i] = correspondence[i] - 1;</span>
      }
<span class="nc" id="L1384">    }</span>
<span class="nc" id="L1385">    return mergeCorrespondence;</span>
  }

  public void countMergeEffects(Tree tree, Map&lt;String, double[]&gt; totalStateMass,
                                Map&lt;String, double[]&gt; deltaAnnotations) {
<span class="nc" id="L1390">    IdentityHashMap&lt;Tree, double[]&gt; probIn = new IdentityHashMap&lt;&gt;();</span>
<span class="nc" id="L1391">    IdentityHashMap&lt;Tree, double[]&gt; probOut = new IdentityHashMap&lt;&gt;();</span>
<span class="nc" id="L1392">    IdentityHashMap&lt;Tree, double[][]&gt; unaryTransitions = new IdentityHashMap&lt;&gt;();</span>
<span class="nc" id="L1393">    IdentityHashMap&lt;Tree, double[][][]&gt; binaryTransitions = new IdentityHashMap&lt;&gt;();</span>
<span class="nc" id="L1394">    recountTree(tree, false, probIn, probOut, unaryTransitions, binaryTransitions);</span>

    // no need to count the root
<span class="nc bnc" id="L1397" title="All 2 branches missed.">    for (Tree child : tree.children()) {</span>
<span class="nc" id="L1398">      countMergeEffects(child, totalStateMass, deltaAnnotations, probIn, probOut);</span>
    }
<span class="nc" id="L1400">  }</span>

  public void countMergeEffects(Tree tree, Map&lt;String, double[]&gt; totalStateMass,
                                Map&lt;String, double[]&gt; deltaAnnotations,
                                IdentityHashMap&lt;Tree, double[]&gt; probIn,
                                IdentityHashMap&lt;Tree, double[]&gt; probOut) {
<span class="nc bnc" id="L1406" title="All 2 branches missed.">    if (tree.isLeaf()) {</span>
<span class="nc" id="L1407">      return;</span>
    }
<span class="nc bnc" id="L1409" title="All 2 branches missed.">    if (tree.label().value().equals(Lexicon.BOUNDARY_TAG)) {</span>
<span class="nc" id="L1410">      return;</span>
    }

<span class="nc" id="L1413">    String label = tree.label().value();</span>
<span class="nc" id="L1414">    double totalMass = 0.0;</span>
<span class="nc" id="L1415">    double[] stateMass = totalStateMass.get(label);</span>
<span class="nc bnc" id="L1416" title="All 2 branches missed.">    for (double mass : stateMass) {</span>
<span class="nc" id="L1417">      totalMass += mass;</span>
    }

<span class="nc" id="L1420">    double[] nodeProbIn = probIn.get(tree);</span>
<span class="nc" id="L1421">    double[] nodeProbOut = probOut.get(tree);</span>

<span class="nc" id="L1423">    double[] nodeDelta = deltaAnnotations.get(label);</span>
<span class="nc bnc" id="L1424" title="All 2 branches missed.">    if (nodeDelta == null) {</span>
<span class="nc" id="L1425">      nodeDelta = new double[nodeProbIn.length / 2];</span>
<span class="nc" id="L1426">      deltaAnnotations.put(label, nodeDelta);</span>
    }

<span class="nc bnc" id="L1429" title="All 2 branches missed.">    for (int i = 0; i &lt; nodeProbIn.length / 2; ++i) {</span>
<span class="nc" id="L1430">      double probInMerged = SloppyMath.logAdd(Math.log(stateMass[i * 2] / totalMass) + nodeProbIn[i * 2],</span>
<span class="nc" id="L1431">                                              Math.log(stateMass[i * 2 + 1] / totalMass) + nodeProbIn[i * 2 + 1]);</span>
<span class="nc" id="L1432">      double probOutMerged = SloppyMath.logAdd(nodeProbOut[i * 2], nodeProbOut[i * 2 + 1]);</span>
<span class="nc" id="L1433">      double probMerged = probInMerged + probOutMerged;</span>
<span class="nc" id="L1434">      double probUnmerged = SloppyMath.logAdd(nodeProbIn[i * 2] + nodeProbOut[i * 2],</span>
                                              nodeProbIn[i * 2 + 1] + nodeProbOut[i * 2 + 1]);
<span class="nc" id="L1436">      nodeDelta[i] = nodeDelta[i] + probMerged - probUnmerged;</span>
    }

<span class="nc bnc" id="L1439" title="All 2 branches missed.">    if (tree.isPreTerminal()) {</span>
<span class="nc" id="L1440">      return;</span>
    }
<span class="nc bnc" id="L1442" title="All 2 branches missed.">    for (Tree child : tree.children()) {</span>
<span class="nc" id="L1443">      countMergeEffects(child, totalStateMass, deltaAnnotations, probIn, probOut);</span>
    }
<span class="nc" id="L1445">  }</span>

  public void buildStateIndex() {
<span class="nc" id="L1448">    stateIndex = new HashIndex&lt;&gt;();</span>
<span class="nc bnc" id="L1449" title="All 2 branches missed.">    for (String key : stateSplitCounts.keySet()) {</span>
<span class="nc bnc" id="L1450" title="All 2 branches missed.">      for (int i = 0; i &lt; stateSplitCounts.getIntCount(key); ++i) {</span>
<span class="nc" id="L1451">        stateIndex.addToIndex(state(key, i));</span>
      }
<span class="nc" id="L1453">    }</span>
<span class="nc" id="L1454">  }</span>

  public void buildGrammars() {
    // In order to build the grammars, we first need to fill in the
    // temp betas with the sums of the transitions from Ax to By or Ax
    // to By,Cz.  We also need the sum total of the mass in each state
    // Ax over all the trees.

    // we go through the machinery to sum up the temporary betas,
    // counting the total mass...
<span class="nc" id="L1464">    TwoDimensionalMap&lt;String, String, double[][]&gt; tempUnaryBetas = new TwoDimensionalMap&lt;&gt;();</span>
<span class="nc" id="L1465">    ThreeDimensionalMap&lt;String, String, String, double[][][]&gt; tempBinaryBetas = new ThreeDimensionalMap&lt;&gt;();</span>
<span class="nc" id="L1466">    Map&lt;String, double[]&gt; totalStateMass = Generics.newHashMap();</span>
<span class="nc" id="L1467">    recalculateTemporaryBetas(false, totalStateMass, tempUnaryBetas, tempBinaryBetas);</span>

    // ... but note we don't actually rescale the betas.
    // instead we use the temporary betas and the total mass in each
    // state to calculate the grammars

    // First build up a BinaryGrammar.
    // The score for each rule will be the Beta scores found earlier,
    // scaled by the total weight of a transition between unsplit states
<span class="nc" id="L1476">    BinaryGrammar bg = new BinaryGrammar(stateIndex);</span>
<span class="nc bnc" id="L1477" title="All 2 branches missed.">    for (String parent : tempBinaryBetas.firstKeySet()) {</span>
<span class="nc" id="L1478">      int parentStates = getStateSplitCount(parent);</span>
<span class="nc" id="L1479">      double[] stateTotal = totalStateMass.get(parent);</span>
<span class="nc bnc" id="L1480" title="All 2 branches missed.">      for (String left : tempBinaryBetas.get(parent).firstKeySet()) {</span>
<span class="nc" id="L1481">        int leftStates = getStateSplitCount(left);</span>
<span class="nc bnc" id="L1482" title="All 2 branches missed.">        for (String right : tempBinaryBetas.get(parent).get(left).keySet()) {</span>
<span class="nc" id="L1483">          int rightStates = getStateSplitCount(right);</span>
<span class="nc" id="L1484">          double[][][] betas = tempBinaryBetas.get(parent, left, right);</span>
<span class="nc bnc" id="L1485" title="All 2 branches missed.">          for (int i = 0; i &lt; parentStates; ++i) {</span>
<span class="nc bnc" id="L1486" title="All 2 branches missed.">            if (stateTotal[i] &lt; EPSILON) {</span>
<span class="nc" id="L1487">              continue;</span>
            }
<span class="nc bnc" id="L1489" title="All 2 branches missed.">            for (int j = 0; j &lt; leftStates; ++j) {</span>
<span class="nc bnc" id="L1490" title="All 2 branches missed.">              for (int k = 0; k &lt; rightStates; ++k) {</span>
<span class="nc" id="L1491">                int parentIndex = stateIndex.indexOf(state(parent, i));</span>
<span class="nc" id="L1492">                int leftIndex = stateIndex.indexOf(state(left, j));</span>
<span class="nc" id="L1493">                int rightIndex = stateIndex.indexOf(state(right, k));</span>
<span class="nc" id="L1494">                double score = betas[i][j][k] - Math.log(stateTotal[i]);</span>
<span class="nc" id="L1495">                BinaryRule br = new BinaryRule(parentIndex, leftIndex, rightIndex, score);</span>
<span class="nc" id="L1496">                bg.addRule(br);</span>
              }
            }
          }
<span class="nc" id="L1500">        }</span>
<span class="nc" id="L1501">      }</span>
<span class="nc" id="L1502">    }</span>

    // Now build up a UnaryGrammar
<span class="nc" id="L1505">    UnaryGrammar ug = new UnaryGrammar(stateIndex);</span>
<span class="nc bnc" id="L1506" title="All 2 branches missed.">    for (String parent : tempUnaryBetas.firstKeySet()) {</span>
<span class="nc" id="L1507">      int parentStates = getStateSplitCount(parent);</span>
<span class="nc" id="L1508">      double[] stateTotal = totalStateMass.get(parent);</span>
<span class="nc bnc" id="L1509" title="All 2 branches missed.">      for (String child : tempUnaryBetas.get(parent).keySet()) {</span>
<span class="nc" id="L1510">        int childStates = getStateSplitCount(child);</span>
<span class="nc" id="L1511">        double[][] betas = tempUnaryBetas.get(parent, child);</span>
<span class="nc bnc" id="L1512" title="All 2 branches missed.">        for (int i = 0; i &lt; parentStates; ++i) {</span>
<span class="nc bnc" id="L1513" title="All 2 branches missed.">          if (stateTotal[i] &lt; EPSILON) {</span>
<span class="nc" id="L1514">            continue;</span>
          }
<span class="nc bnc" id="L1516" title="All 2 branches missed.">          for (int j = 0; j &lt; childStates; ++j) {</span>
<span class="nc" id="L1517">            int parentIndex = stateIndex.indexOf(state(parent, i));</span>
<span class="nc" id="L1518">            int childIndex = stateIndex.indexOf(state(child, j));</span>
<span class="nc" id="L1519">            double score = betas[i][j] - Math.log(stateTotal[i]);</span>
<span class="nc" id="L1520">            UnaryRule ur = new UnaryRule(parentIndex, childIndex, score);</span>
<span class="nc" id="L1521">            ug.addRule(ur);</span>
          }
        }
<span class="nc" id="L1524">      }</span>
<span class="nc" id="L1525">    }</span>


<span class="nc" id="L1528">    bgug = new Pair&lt;&gt;(ug, bg);</span>
<span class="nc" id="L1529">  }</span>

  public void saveTrees(Collection&lt;Tree&gt; trees1, double weight1,
                        Collection&lt;Tree&gt; trees2, double weight2) {
<span class="nc" id="L1533">    trainSize = 0.0;</span>
<span class="nc" id="L1534">    int treeCount = 0;</span>
<span class="nc" id="L1535">    trees.clear();</span>
<span class="nc" id="L1536">    treeWeights.clear();</span>
<span class="nc bnc" id="L1537" title="All 2 branches missed.">    for (Tree tree : trees1) {</span>
<span class="nc" id="L1538">      trees.add(tree);</span>
<span class="nc" id="L1539">      treeWeights.incrementCount(tree, weight1);</span>
<span class="nc" id="L1540">      trainSize += weight1;</span>
<span class="nc" id="L1541">    }</span>
<span class="nc" id="L1542">    treeCount += trees1.size();</span>
<span class="nc bnc" id="L1543" title="All 4 branches missed.">    if (trees2 != null &amp;&amp; weight2 &gt;= 0.0) {</span>
<span class="nc bnc" id="L1544" title="All 2 branches missed.">      for (Tree tree : trees2) {</span>
<span class="nc" id="L1545">        trees.add(tree);</span>
<span class="nc" id="L1546">        treeWeights.incrementCount(tree, weight2);</span>
<span class="nc" id="L1547">        trainSize += weight2;</span>
<span class="nc" id="L1548">      }</span>
<span class="nc" id="L1549">      treeCount += trees2.size();</span>
    }
<span class="nc" id="L1551">    log.info(&quot;Found &quot; + treeCount +</span>
                       &quot; trees with total weight &quot; + trainSize);
<span class="nc" id="L1553">  }</span>

  public void extract(Collection&lt;Tree&gt; treeList) {
<span class="nc" id="L1556">    extract(treeList, 1.0, null, 0.0);</span>
<span class="nc" id="L1557">  }</span>

  /**
   * First, we do a few setup steps.  We read in all the trees, which
   * is necessary because we continually reprocess them and use the
   * object pointers as hash keys rather than hashing the trees
   * themselves.  We then count the initial states in the treebank.
   * &lt;br&gt;
   * Having done that, we then assign initial probabilities to the
   * trees.  At first, each state has 1.0 of the probability mass for
   * each Ax-ByCz and Ax-By transition.  We then split the number of
   * states and the probabilities on each tree.
   * &lt;br&gt;
   * We then repeatedly recalculate the betas and reannotate the
   * weights, going until we converge, which is defined as no betas
   * move more then epsilon.
   * &lt;br&gt;
   * java -mx4g edu.stanford.nlp.parser.lexparser.LexicalizedParser  -PCFG -saveToSerializedFile englishSplit.ser.gz -saveToTextFile englishSplit.txt -maxLength 40 -train ../data/wsj/wsjtwentytrees.mrg    -testTreebank ../data/wsj/wsjtwentytrees.mrg   -evals &quot;factDA,tsv&quot; -uwm 0  -hMarkov 0 -vMarkov 0 -simpleBinarizedLabels -noRebinarization -predictSplits -splitTrainingThreads 1 -splitCount 1 -splitRecombineRate 0.5
   * &lt;br&gt;
   * may also need
   * &lt;br&gt;
   *  -smoothTagsThresh 0
   * &lt;br&gt;
   * java -mx8g edu.stanford.nlp.parser.lexparser.LexicalizedParser -evals &quot;factDA,tsv&quot; -PCFG -vMarkov 0 -hMarkov 0 -uwm 0 -saveToSerializedFile wsjS1.ser.gz -maxLength 40 -train /afs/ir/data/linguistic-data/Treebank/3/parsed/mrg/wsj 200-2199 -testTreebank /afs/ir/data/linguistic-data/Treebank/3/parsed/mrg/wsj 2200-2219 -compactGrammar 0 -simpleBinarizedLabels -predictSplits -smoothTagsThresh 0 -splitCount 1 -noRebinarization
   */
  public void extract(Collection&lt;Tree&gt; trees1, double weight1,
                      Collection&lt;Tree&gt; trees2, double weight2) {
<span class="nc" id="L1584">    saveTrees(trees1, weight1, trees2, weight2);</span>

<span class="nc" id="L1586">    countOriginalStates();</span>

    // Initial betas will be 1 for all possible unary and binary
    // transitions in our treebank
<span class="nc" id="L1590">    initialBetasAndLexicon();</span>

<span class="nc bnc" id="L1592" title="All 2 branches missed.">    for (int cycle = 0; cycle &lt; op.trainOptions.splitCount; ++cycle) {</span>
      // All states except the root state get split into 2
<span class="nc" id="L1594">      splitStateCounts();</span>

      // first, recalculate the betas and the lexicon for having split
      // the transitions
<span class="nc" id="L1598">      recalculateBetas(true);</span>

      // now, loop until we converge while recalculating betas
      // TODO: add a loop counter, stop after X iterations
<span class="nc" id="L1602">      iteration = 0;</span>
<span class="nc" id="L1603">      boolean converged = false;</span>
<span class="nc bnc" id="L1604" title="All 4 branches missed.">      while (!converged &amp;&amp; iteration &lt; MAX_ITERATIONS) {</span>
<span class="nc bnc" id="L1605" title="All 2 branches missed.">        if (DEBUG()) {</span>
<span class="nc" id="L1606">          System.out.println();</span>
<span class="nc" id="L1607">          System.out.println();</span>
<span class="nc" id="L1608">          System.out.println(&quot;-------------------&quot;);</span>
<span class="nc" id="L1609">          System.out.println(&quot;Iteration &quot; + iteration);</span>
        }

<span class="nc" id="L1612">        converged = recalculateBetas(false);</span>
<span class="nc" id="L1613">        ++iteration;</span>
      }

<span class="nc" id="L1616">      log.info(&quot;Converged for cycle &quot; + cycle +</span>
                         &quot; in &quot; + iteration + &quot; iterations&quot;);

<span class="nc" id="L1619">      mergeStates();</span>
    }

    // Build up the state index.  The BG &amp; UG both expect a set count
    // of states.
<span class="nc" id="L1624">    buildStateIndex();</span>

<span class="nc" id="L1626">    buildGrammars();</span>
<span class="nc" id="L1627">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>