<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SUTime.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.time</a> &gt; <span class="el_source">SUTime.java</span></div><h1>SUTime.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.time;

import edu.stanford.nlp.ling.tokensregex.types.Expressions;
import edu.stanford.nlp.util.CollectionUtils;
import edu.stanford.nlp.util.FuzzyInterval;
import edu.stanford.nlp.util.Generics;
import edu.stanford.nlp.util.HasInterval;
import edu.stanford.nlp.util.HashIndex;
import edu.stanford.nlp.util.Index;
import edu.stanford.nlp.util.Interval;
import edu.stanford.nlp.util.Pair;
import edu.stanford.nlp.util.StringUtils;
// import edu.stanford.nlp.util.logging.Redwood;

import org.joda.time.*;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;
import org.joda.time.format.DateTimeFormatterBuilder;

import java.io.Serializable;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * SUTime is a collection of data structures to represent various temporal
 * concepts and operations between them.
 *
 * Different types of time expressions:
 * &lt;ul&gt;
 * &lt;li&gt;Time - A time point on a time scale  In most cases, we only know partial information
 *        (with a certain granularity) about a point in time (8:00pm)&lt;/li&gt;
 * &lt;li&gt;Duration - A length of time (3 days) &lt;/li&gt;
 * &lt;li&gt;Interval - A range of time with start and end points&lt;/li&gt;
 * &lt;li&gt;Set - A set of time: Can be periodic (Friday every week) or union (Thursday or Friday)&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;
 * Use {@link TimeAnnotator} to annotate documents within an Annotation pipeline such as CoreNLP.
 * Use {@link SUTimeMain} for standalone testing.
 *
 * @author Angel Chang
 */
public class SUTime  {

  /** A logger for this class */
  // private static Redwood.RedwoodChannels log = Redwood.channels(SUTime.class);

  // TODO:
  // 1. Decrease dependency on JodaTime...
  // 2. Number parsing
  // - Improve Number detection/normalization
  // - Handle four-years, one thousand two hundred and sixty years
  // - Currently custom word to number combo - integrate with Number classifier,
  // QuantifiableEntityNormalizer
  // - Stop repeated conversions of word to numbers
  // 3. Durations
  // - Underspecified durations
  // 4. Date Time
  // - Patterns
  // -- 1st/last week(end) of blah blah
  // -- Don't treat all 3 to 5 as times
  // - Holidays
  // - Too many classes - reduce number of classes
  // 5. Nest time expressions
  // - Before annotating: Can remove nested time expressions
  // - After annotating: types to combine time expressions
  // 6. Set of times (Timex3 standard is weird, timex2 makes more sense?)
  // - freq, quant
  // 7. Ground with respect to reference time - figure out what is reference
  // time to use for what
  // - news... things happen in the past, so favor resolving to past?
  // - Use heuristics from GUTime to figure out direction to resolve to
  // - tids for anchor times...., valueFromFunctions for resolved relative times
  // (option to keep some nested times)?
  // 8. Composite time patterns
  // - Composite time operators
  // 9. Ranges
  // - comparing times (before, after, ...
  // - intersect, mid, resolving
  // - specify clear start/end for range (sonal)
  // 10. Clean up formatting
  // 11. ISO/Timex3/Custom
  // 12. Keep modifiers
  // 13. Handle mid- (token not separated)
  // 14. future, plurals
  // 15. Resolve to future.... with year specified....
  // 16. Check recursive calls
  // 17. Add TimeWithFields (that doesn't use jodatime and is only field based?

<span class="nc" id="L91">  private SUTime() {</span>
<span class="nc" id="L92">  }</span>

<span class="pc" id="L94">  public enum TimexType {</span>
<span class="fc" id="L95">    DATE, TIME, DURATION, SET</span>
  }

<span class="pc" id="L98">  public enum TimexMod {</span>
<span class="fc" id="L99">    BEFORE(&quot;&lt;&quot;), AFTER(&quot;&gt;&quot;), ON_OR_BEFORE(&quot;&lt;=&quot;), ON_OR_AFTER(&quot;&lt;=&quot;), LESS_THAN(&quot;&lt;&quot;), MORE_THAN(&quot;&gt;&quot;),</span>
<span class="fc" id="L100">    EQUAL_OR_LESS(&quot;&lt;=&quot;), EQUAL_OR_MORE(&quot;&gt;=&quot;), START, MID, END, APPROX(&quot;~&quot;), EARLY /* GUTIME */, LATE; /* GUTIME */</span>
    private String symbol;

<span class="fc" id="L103">    TimexMod() { }</span>

<span class="fc" id="L105">    TimexMod(String symbol) {</span>
<span class="fc" id="L106">      this.symbol = symbol;</span>
<span class="fc" id="L107">    }</span>

    public String getSymbol() {
<span class="nc" id="L110">      return symbol;</span>
    }
  }

<span class="nc" id="L114">  public enum TimexDocFunc {</span>
<span class="nc" id="L115">    CREATION_TIME, EXPIRATION_TIME, MODIFICATION_TIME, PUBLICATION_TIME, RELEASE_TIME, RECEPTION_TIME, NONE</span>
  }

<span class="nc" id="L118">  public enum TimexAttr {</span>
<span class="nc" id="L119">    type, value, tid, beginPoint, endPoint, quant, freq, mod, anchorTimeID, comment, valueFromFunction, temporalFunction, functionInDocument</span>
  }

  public static final String PAD_FIELD_UNKNOWN = &quot;X&quot;;
  public static final String PAD_FIELD_UNKNOWN2 = &quot;XX&quot;;
  public static final String PAD_FIELD_UNKNOWN4 = &quot;XXXX&quot;;

  // Flags for how to resolve a time expression
  public static final int RESOLVE_NOW = 0x01;
  public static final int RESOLVE_TO_THIS = 0x20;
  public static final int RESOLVE_TO_PAST = 0x40; // Resolve to a past time
  public static final int RESOLVE_TO_FUTURE = 0x80; // Resolve to a future time
  public static final int RESOLVE_TO_CLOSEST = 0x200; // Resolve to closest time
  public static final int DUR_RESOLVE_TO_AS_REF = 0x1000;
  public static final int DUR_RESOLVE_FROM_AS_REF = 0x2000;
  public static final int RANGE_RESOLVE_TIME_REF = 0x100000;

  public static final int RELATIVE_OFFSET_INEXACT = 0x0100;

  public static final int RANGE_OFFSET_BEGIN = 0x0001;
  public static final int RANGE_OFFSET_END = 0x0002;
  public static final int RANGE_EXPAND_FIX_BEGIN = 0x0010;
  public static final int RANGE_EXPAND_FIX_END = 0x0020;

  /** Flags for how to pad when converting times into ranges */
  public static final int RANGE_FLAGS_PAD_MASK = 0x000f; // Pad type
  /** Simple range (without padding) */
  public static final int RANGE_FLAGS_PAD_NONE = 0x0001;
  /** Automatic range (whatever padding we think is most appropriate, default) */
  public static final int RANGE_FLAGS_PAD_AUTO = 0x0002;
  /** Pad to most specific (whatever that is) */
  public static final int RANGE_FLAGS_PAD_FINEST = 0x0003;
  /** Pad to specified granularity */
  public static final int RANGE_FLAGS_PAD_SPECIFIED = 0x0004;

  public static final int FORMAT_ISO = 0x01;
  public static final int FORMAT_TIMEX3_VALUE = 0x02;
  public static final int FORMAT_FULL = 0x04;
  public static final int FORMAT_PAD_UNKNOWN = 0x1000;

  protected static final int timexVersion = 3;

  public static SUTime.Time getCurrentTime() {
<span class="nc" id="L162">    return new GroundedTime(new DateTime());</span>
  }

  // Index of time id to temporal object
  public static class TimeIndex {
<span class="nc" id="L167">    Index&lt;TimeExpression&gt; temporalExprIndex = new HashIndex&lt;&gt;();</span>
<span class="nc" id="L168">    Index&lt;Temporal&gt; temporalIndex = new HashIndex&lt;&gt;();</span>
<span class="nc" id="L169">    Index&lt;Temporal&gt; temporalFuncIndex = new HashIndex&lt;&gt;();</span>

    SUTime.Time docDate;

<span class="nc" id="L173">    public TimeIndex() {</span>
<span class="nc" id="L174">      addTemporal(SUTime.TIME_REF);</span>
<span class="nc" id="L175">    }</span>

    public void clear() {
<span class="nc" id="L178">      temporalExprIndex.clear();</span>
<span class="nc" id="L179">      temporalIndex.clear();</span>
<span class="nc" id="L180">      temporalFuncIndex.clear();</span>
      // t0 is the document date (reserve)
<span class="nc" id="L182">      temporalExprIndex.add(null);</span>
<span class="nc" id="L183">      addTemporal(SUTime.TIME_REF);</span>
<span class="nc" id="L184">    }</span>

<span class="nc" id="L186">    public int getNumberOfTemporals() { return temporalIndex.size(); }</span>
<span class="nc" id="L187">    public int getNumberOfTemporalExprs() { return temporalExprIndex.size(); }</span>
<span class="nc" id="L188">    public int getNumberOfTemporalFuncs() { return temporalFuncIndex.size(); }</span>

<span class="nc" id="L190">    private static final Pattern ID_PATTERN = Pattern.compile(&quot;([a-zA-Z]*)(\\d+)&quot;);</span>

    public TimeExpression getTemporalExpr(String s) {
<span class="nc" id="L193">      Matcher m = ID_PATTERN.matcher(s);</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">      if (m.matches()) {</span>
<span class="nc" id="L195">        String prefix = m.group(1);</span>
<span class="nc" id="L196">        int id = Integer.parseInt(m.group(2));</span>
<span class="nc bnc" id="L197" title="All 4 branches missed.">        if (&quot;t&quot;.equals(prefix) || prefix.isEmpty()) {</span>
<span class="nc" id="L198">          return temporalExprIndex.get(id);</span>
        }
      }
<span class="nc" id="L201">      return null;</span>
    }

    public Temporal getTemporal(String s) {
<span class="nc" id="L205">      Matcher m = ID_PATTERN.matcher(s);</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">      if (m.matches()) {</span>
<span class="nc" id="L207">        String prefix = m.group(1);</span>
<span class="nc" id="L208">        int id = Integer.parseInt(m.group(2));</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">        if (&quot;t&quot;.equals(prefix)) {</span>
<span class="nc" id="L210">          TimeExpression te = temporalExprIndex.get(id);</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">          return (te != null)? te.getTemporal(): null;</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">        } else if (prefix.isEmpty()) {</span>
<span class="nc" id="L213">          return temporalIndex.get(id);</span>
        }
      }
<span class="nc" id="L216">      return null;</span>
    }

    public TimeExpression getTemporalExpr(int i) {
<span class="nc" id="L220">      return temporalExprIndex.get(i);</span>
    }

    public Temporal getTemporal(int i) {
<span class="nc" id="L224">      return temporalIndex.get(i);</span>
    }

    public Temporal getTemporalFunc(int i) {
<span class="nc" id="L228">      return temporalFuncIndex.get(i);</span>
    }

    public boolean addTemporalExpr(TimeExpression t) {
<span class="nc" id="L232">      Temporal temp = t.getTemporal();</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">      if (temp != null) {</span>
<span class="nc" id="L234">        addTemporal(temp);</span>
      }
<span class="nc" id="L236">      return temporalExprIndex.add(t);</span>
    }

    public boolean addTemporal(Temporal t) {
<span class="nc" id="L240">      return temporalIndex.add(t);</span>
    }

    public boolean addTemporalFunc(Temporal t) {
<span class="nc" id="L244">      return temporalFuncIndex.add(t);</span>
    }

    public int addToIndexTemporalExpr(TimeExpression t) {
<span class="nc" id="L248">      return temporalExprIndex.addToIndex(t);</span>
    }

    public int addToIndexTemporal(Temporal t) {
<span class="nc" id="L252">      return temporalIndex.addToIndex(t);</span>
    }

    public int addToIndexTemporalFunc(Temporal t) {
<span class="nc" id="L256">      return temporalFuncIndex.addToIndex(t);</span>
    }
  }

  /**
   * Basic temporal object.
   *
   * &lt;p&gt;
   * There are 4 main types of temporal objects
   * &lt;ol&gt;
   * &lt;li&gt;Time - Conceptually a point in time
   * &lt;br&gt;NOTE: Due to limitation in precision, it is
   * difficult to get an exact point in time
   * &lt;/li&gt;
   * &lt;li&gt;Duration - Amount of time in a time interval
   *  &lt;ul&gt;&lt;li&gt;DurationWithMillis - Duration specified in milliseconds
   *          (wrapper around JodaTime Duration)&lt;/li&gt;
   *      &lt;li&gt;DurationWithFields - Duration specified with
   *         fields like day, year, etc (wrapper around JodaTime Period)&lt;/lI&gt;
   *      &lt;li&gt;DurationRange - A duration that falls in a particular range (with min to max)&lt;/li&gt;
   *  &lt;/ul&gt;
   * &lt;/li&gt;
   * &lt;li&gt;Range - Time Interval with a start time, end time, and duration&lt;/li&gt;
   * &lt;li&gt;TemporalSet - A set of temporal objects
   *  &lt;ul&gt;&lt;li&gt;ExplicitTemporalSet - Explicit set of temporals (not used)
   *         &lt;br&gt;Ex: Tuesday 1-2pm, Wednesday night&lt;/li&gt;
   *      &lt;li&gt;PeriodicTemporalSet - Reoccurring times
   *         &lt;br&gt;Ex: Every Tuesday&lt;/li&gt;
   *  &lt;/ul&gt;
   * &lt;/li&gt;
   * &lt;/ol&gt;
   */
  public abstract static class Temporal implements Cloneable, Serializable {
    public String mod;
    public boolean approx;
    StandardTemporalType standardTemporalType;
    public String timeLabel;
    // Duration after which the time is uncertain (what is there is an estimate)
    public Duration uncertaintyGranularity;

<span class="fc" id="L296">    public Temporal() {</span>
<span class="fc" id="L297">    }</span>

<span class="fc" id="L299">    public Temporal(Temporal t) {</span>
<span class="fc" id="L300">      this.mod = t.mod;</span>
<span class="fc" id="L301">      this.approx = t.approx;</span>
<span class="fc" id="L302">      this.uncertaintyGranularity = t.uncertaintyGranularity;</span>
//      this.standardTimeType = t.standardTimeType;
//      this.timeLabel = t.timeLabel;
<span class="fc" id="L305">    }</span>

    public abstract boolean isGrounded();

    // Returns time representation for Temporal (if available)
    public abstract Time getTime();

    // Returns duration (estimate of how long the temporal expression is for)
    public abstract Duration getDuration();

    // Returns range (start/end points of temporal, automatic granularity)
    public Range getRange() {
<span class="fc" id="L317">      return getRange(RANGE_FLAGS_PAD_AUTO);</span>
    }

    // Returns range (start/end points of temporal)
    public Range getRange(int flags) {
<span class="fc" id="L322">      return getRange(flags, null);</span>
    }

    // Returns range (start/end points of temporal), using specified flags
    public abstract Range getRange(int flags, Duration granularity);

    // Returns how often this time would repeat
    // Ex: friday repeat weekly, hour repeat hourly, hour in a day repeat daily
    public Duration getPeriod() {
  /*    TimeLabel tl = getTimeLabel();
      if (tl != null) {
        return tl.getPeriod();
      } */
<span class="fc" id="L335">      StandardTemporalType tlt = getStandardTemporalType();</span>
<span class="pc bpc" id="L336" title="1 of 2 branches missed.">      if (tlt != null) {</span>
<span class="fc" id="L337">        return tlt.getPeriod();</span>
      }
<span class="nc" id="L339">      return null;</span>
    }

    // Returns the granularity to which this time or duration is specified
    // Typically the most specific time unit
    public Duration getGranularity() {
<span class="nc" id="L345">      StandardTemporalType tlt = getStandardTemporalType();</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">      if (tlt != null) {</span>
<span class="nc" id="L347">        return tlt.getGranularity();</span>
      }
<span class="nc" id="L349">      return null;</span>
    }

    public Duration getUncertaintyGranularity() {
<span class="nc bnc" id="L353" title="All 2 branches missed.">      if (uncertaintyGranularity != null) return uncertaintyGranularity;</span>
<span class="nc" id="L354">      return getGranularity();</span>
    }

    // Resolves this temporal expression with respect to the specified reference
    // time using flags
    public Temporal resolve(Time refTime) {
<span class="fc" id="L360">      return resolve(refTime, 0);</span>
    }

    public abstract Temporal resolve(Time refTime, int flags);

    public StandardTemporalType getStandardTemporalType() {
<span class="fc" id="L366">      return standardTemporalType;</span>
    }

    // Returns if the current temporal expression is an reference
    public boolean isRef() {
<span class="nc" id="L371">      return false;</span>
    }

    // Return sif the current temporal expression is approximate
    public boolean isApprox() {
<span class="fc" id="L376">      return approx;</span>
    }

    // TIMEX related functions
    public int getTid(TimeIndex timeIndex) {
<span class="nc" id="L381">      return timeIndex.addToIndexTemporal(this);</span>
    }

    public String getTidString(TimeIndex timeIndex) {
<span class="nc" id="L385">      return &quot;t&quot; + getTid(timeIndex);</span>
    }

    public int getTfid(TimeIndex timeIndex) {
<span class="nc" id="L389">      return timeIndex.addToIndexTemporalFunc(this);</span>
    }

    public String getTfidString(TimeIndex timeIndex) {
<span class="nc" id="L393">      return &quot;tf&quot; + getTfid(timeIndex);</span>
    }

    // Returns attributes to convert this temporal expression into timex object
    public boolean includeTimexAltValue() {
<span class="nc" id="L398">      return false;</span>
    }

    public Map&lt;String, String&gt; getTimexAttributes(TimeIndex timeIndex) {
<span class="nc" id="L402">      Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;();</span>
<span class="nc" id="L403">      map.put(TimexAttr.tid.name(), getTidString(timeIndex));</span>
      // NOTE: GUTime used &quot;VAL&quot; instead of TIMEX3 standard &quot;value&quot;
      // NOTE: attributes are case sensitive, GUTIME used mostly upper case
      // attributes....
<span class="nc" id="L407">      String val = getTimexValue();</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">      if (val != null) {</span>
<span class="nc" id="L409">        map.put(TimexAttr.value.name(), val);</span>
      }
<span class="nc bnc" id="L411" title="All 4 branches missed.">      if (val == null || includeTimexAltValue()) {</span>
<span class="nc" id="L412">        String str = toFormattedString(FORMAT_FULL);</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">        if (str != null) {</span>
<span class="nc" id="L414">          map.put(&quot;alt_value&quot;, str);</span>
        }
      }
      /*     Range r = getRange();
           if (r != null) map.put(&quot;range&quot;, r.toString());    */
      /*     map.put(&quot;str&quot;, toString());        */
<span class="nc" id="L420">      map.put(TimexAttr.type.name(), getTimexType().name());</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">      if (mod != null) {</span>
<span class="nc" id="L422">        map.put(TimexAttr.mod.name(), mod);</span>
      }
<span class="nc" id="L424">      return map;</span>
    }

    // Returns the timex type
    public TimexType getTimexType() {
<span class="nc bnc" id="L429" title="All 2 branches missed.">      if (getStandardTemporalType() != null) {</span>
<span class="nc" id="L430">        return getStandardTemporalType().getTimexType();</span>
      } else {
<span class="nc" id="L432">        return null;</span>
      }
    }

    // Returns timex value (by default it is the ISO string representation of
    // this object)
    public String getTimexValue() {
<span class="nc" id="L439">      return toFormattedString(FORMAT_TIMEX3_VALUE);</span>
    }

    public String toISOString() {
<span class="fc" id="L443">      return toFormattedString(FORMAT_ISO);</span>
    }

    public String toString() {
      // TODO: Full string representation
<span class="fc" id="L448">      return toFormattedString(FORMAT_FULL);</span>
    }

    public String getTimeLabel() {
<span class="fc" id="L452">      return timeLabel;</span>
    }

    public String toFormattedString(int flags) {
<span class="nc" id="L456">      return getTimeLabel();</span>
    }

    // Temporal operations...
    public static Temporal setTimeZone(Temporal t, DateTimeZone tz) {
<span class="nc bnc" id="L461" title="All 2 branches missed.">      if (t == null) return null;</span>
<span class="nc" id="L462">      return t.setTimeZone(tz);</span>
    }

    public Temporal setTimeZone(DateTimeZone tz) {
<span class="nc" id="L466">      return this;</span>
    }

    public Temporal setTimeZone(int offsetHours) {
<span class="nc" id="L470">      return setTimeZone(DateTimeZone.forOffsetHours(offsetHours));</span>
    }

    // public abstract Temporal add(Duration offset);
    public Temporal next() {
<span class="fc" id="L475">      Duration per = getPeriod();</span>
<span class="pc bpc" id="L476" title="1 of 2 branches missed.">      if (per != null) {</span>
<span class="fc bfc" id="L477" title="All 2 branches covered.">        if (this instanceof Duration) {</span>
<span class="fc" id="L478">          return new RelativeTime(new RelativeTime(TemporalOp.THIS, this, DUR_RESOLVE_TO_AS_REF), TemporalOp.OFFSET, per);</span>
        } else {
          // return new RelativeTime(new RelativeTime(TemporalOp.THIS, this),
          // TemporalOp.OFFSET, per);
<span class="fc" id="L482">          return TemporalOp.OFFSET.apply(this, per);</span>
        }
      }
<span class="nc" id="L485">      return null;</span>
    }

    public Temporal prev() {
<span class="nc" id="L489">      Duration per = getPeriod();</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">      if (per != null) {</span>
<span class="nc bnc" id="L491" title="All 2 branches missed.">        if (this instanceof Duration) {</span>
<span class="nc" id="L492">          return new RelativeTime(new RelativeTime(TemporalOp.THIS, this, DUR_RESOLVE_FROM_AS_REF), TemporalOp.OFFSET, per.multiplyBy(-1));</span>
        } else {
          // return new RelativeTime(new RelativeTime(TemporalOp.THIS, this),
          // TemporalOp.OFFSET, per.multiplyBy(-1));
<span class="nc" id="L496">          return TemporalOp.OFFSET.apply(this, per.multiplyBy(-1));</span>
        }
      }
<span class="nc" id="L499">      return null;</span>
    }

    public/* abstract*/Temporal intersect(Temporal t) {
<span class="nc" id="L503">      return null;</span>
    }

    public String getMod() {
<span class="fc" id="L507">      return mod;</span>
    }

    /*   public void setMod(String mod) {
         this.mod = mod;
       } */

    public Temporal addMod(String mod) {
      try {
<span class="nc" id="L516">        Temporal t = (Temporal) this.clone();</span>
<span class="nc" id="L517">        t.mod = mod;</span>
<span class="nc" id="L518">        return t;</span>
<span class="nc" id="L519">      } catch (CloneNotSupportedException ex) {</span>
<span class="nc" id="L520">        throw new RuntimeException(ex);</span>
      }
    }

    public Temporal addModApprox(String mod, boolean approx) {
      try {
<span class="fc" id="L526">        Temporal t = (Temporal) this.clone();</span>
<span class="fc" id="L527">        t.mod = mod;</span>
<span class="fc" id="L528">        t.approx = approx;</span>
<span class="fc" id="L529">        return t;</span>
<span class="nc" id="L530">      } catch (CloneNotSupportedException ex) {</span>
<span class="nc" id="L531">        throw new RuntimeException(ex);</span>
      }
    }

    private static final long serialVersionUID = 1;
  }

  public static &lt;T extends Temporal&gt; T createTemporal(StandardTemporalType timeType, T temporal) {
<span class="fc" id="L539">    temporal.standardTemporalType = timeType;</span>
<span class="fc" id="L540">    return temporal;</span>
  }

  public static &lt;T extends Temporal&gt; T createTemporal(StandardTemporalType timeType, String label, T temporal) {
<span class="fc" id="L544">    temporal.standardTemporalType = timeType;</span>
<span class="fc" id="L545">    temporal.timeLabel = label;</span>
<span class="fc" id="L546">    return temporal;</span>
  }

  public static &lt;T extends Temporal&gt; T createTemporal(StandardTemporalType timeType, String label, String mod, T temporal) {
<span class="fc" id="L550">    temporal.standardTemporalType = timeType;</span>
<span class="fc" id="L551">    temporal.timeLabel = label;</span>
<span class="fc" id="L552">    temporal.mod = mod;</span>
<span class="fc" id="L553">    return temporal;</span>
  }
  // Basic time units (durations)

<span class="fc" id="L557">  public static final Duration YEAR = new DurationWithFields(Period.years(1)) {</span>
    @Override
    public DateTimeFieldType[] getDateTimeFields() {
<span class="fc" id="L560">      return new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.yearOfCentury(), DateTimeFieldType.yearOfEra() };</span>
    }
    private static final long serialVersionUID = 1;
  };

<span class="fc" id="L565">  public static final Duration DAY = new DurationWithFields(Period.days(1)) {</span>
    @Override
    public DateTimeFieldType[] getDateTimeFields() {
<span class="fc" id="L568">      return new DateTimeFieldType[] { DateTimeFieldType.dayOfMonth(), DateTimeFieldType.dayOfWeek(), DateTimeFieldType.dayOfYear() };</span>
    }
    private static final long serialVersionUID = 1;
  };

<span class="fc" id="L573">  public static final Duration WEEK = new DurationWithFields(Period.weeks(1)) {</span>
    @Override
    public DateTimeFieldType[] getDateTimeFields() {
<span class="fc" id="L576">      return new DateTimeFieldType[] { DateTimeFieldType.weekOfWeekyear() };</span>
    }
    private static final long serialVersionUID = 1;
  };

<span class="fc" id="L581">  public static final Duration FORTNIGHT = new DurationWithFields(Period.weeks(2));</span>

<span class="fc" id="L583">  public static final Duration MONTH = new DurationWithFields(Period.months(1)) {</span>
    @Override
    public DateTimeFieldType[] getDateTimeFields() {
<span class="fc" id="L586">      return new DateTimeFieldType[] { DateTimeFieldType.monthOfYear() };</span>
    }
    private static final long serialVersionUID = 1;
  };

  // public static final Duration QUARTER = new DurationWithFields(new
  // Period(JodaTimeUtils.Quarters)) {
<span class="fc" id="L593">  public static final Duration QUARTER = new DurationWithFields(Period.months(3)) {</span>
    @Override
    public DateTimeFieldType[] getDateTimeFields() {
<span class="fc" id="L596">      return new DateTimeFieldType[] { JodaTimeUtils.QuarterOfYear };</span>
    }
    private static final long serialVersionUID = 1;
  };

<span class="fc" id="L601">  public static final Duration HALFYEAR = new DurationWithFields(Period.months(6)) {</span>
    @Override
    public DateTimeFieldType[] getDateTimeFields() {
<span class="nc" id="L604">      return new DateTimeFieldType[] { JodaTimeUtils.HalfYearOfYear };</span>
    }
    private static final long serialVersionUID = 1;
  };

<span class="fc" id="L609">  public static final Duration MILLIS = new DurationWithFields(Period.millis(1)) {</span>
    @Override
    public DateTimeFieldType[] getDateTimeFields() {
<span class="nc" id="L612">      return new DateTimeFieldType[] { DateTimeFieldType.millisOfSecond(), DateTimeFieldType.millisOfDay() };</span>
    }
    private static final long serialVersionUID = 1;
  };

<span class="fc" id="L617">  public static final Duration SECOND = new DurationWithFields(Period.seconds(1)) {</span>
    @Override
    public DateTimeFieldType[] getDateTimeFields() {
<span class="nc" id="L620">      return new DateTimeFieldType[] { DateTimeFieldType.secondOfMinute(), DateTimeFieldType.secondOfDay() };</span>
    }
    private static final long serialVersionUID = 1;
  };

<span class="fc" id="L625">  public static final Duration MINUTE = new DurationWithFields(Period.minutes(1)) {</span>
    @Override
    public DateTimeFieldType[] getDateTimeFields() {
<span class="nc" id="L628">      return new DateTimeFieldType[] { DateTimeFieldType.minuteOfHour(), DateTimeFieldType.minuteOfDay() };</span>
    }
    private static final long serialVersionUID = 1;
  };

<span class="fc" id="L633">  public static final Duration HOUR = new DurationWithFields(Period.hours(1)) {</span>
    @Override
    public DateTimeFieldType[] getDateTimeFields() {
<span class="nc" id="L636">      return new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.hourOfHalfday() };</span>
    }
    private static final long serialVersionUID = 1;
  };

<span class="fc" id="L641">  public static final Duration HALFHOUR = new DurationWithFields(Period.minutes(30));</span>

<span class="fc" id="L643">  public static final Duration QUARTERHOUR = new DurationWithFields(Period.minutes(15));</span>

<span class="fc" id="L645">  public static final Duration DECADE = new DurationWithFields(Period.years(10)) {</span>
    @Override
    public DateTimeFieldType[] getDateTimeFields() {
<span class="nc" id="L648">      return new DateTimeFieldType[] { JodaTimeUtils.DecadeOfCentury };</span>
    }
    private static final long serialVersionUID = 1;
  };

<span class="fc" id="L653">  public static final Duration CENTURY = new DurationWithFields(Period.years(100)) {</span>
    @Override
    public DateTimeFieldType[] getDateTimeFields() {
<span class="nc" id="L656">      return new DateTimeFieldType[] { DateTimeFieldType.centuryOfEra() };</span>
    }
    private static final long serialVersionUID = 1;
  };

<span class="fc" id="L661">  public static final Duration MILLENNIUM = new DurationWithFields(Period.years(1000));</span>

<span class="fc" id="L663">  public static final Time TIME_REF = new RefTime(&quot;REF&quot;) {</span>
    private static final long serialVersionUID = 1;
  };
<span class="fc" id="L666">  public static final Time TIME_REF_UNKNOWN = new RefTime(&quot;UNKNOWN&quot;);</span>
<span class="fc" id="L667">  public static final Time TIME_UNKNOWN = new SimpleTime(&quot;UNKNOWN&quot;);</span>
<span class="fc" id="L668">  public static final Time TIME_NONE = null; // No time</span>
<span class="fc" id="L669">  public static final Time TIME_NONE_OK = new SimpleTime(&quot;NOTIME&quot;);</span>

  // The special time of now
<span class="fc" id="L672">  public static final Time TIME_NOW = new RefTime(StandardTemporalType.REFTIME, &quot;PRESENT_REF&quot;, &quot;NOW&quot;);</span>
<span class="fc" id="L673">  public static final Time TIME_PRESENT = createTemporal(StandardTemporalType.REFDATE, &quot;PRESENT_REF&quot;, new InexactTime(new Range(TIME_NOW, TIME_NOW)));</span>
<span class="fc" id="L674">  public static final Time TIME_PAST = createTemporal(StandardTemporalType.REFDATE, &quot;PAST_REF&quot;,new InexactTime(new Range(TIME_UNKNOWN, TIME_NOW)));</span>
<span class="fc" id="L675">  public static final Time TIME_FUTURE = createTemporal(StandardTemporalType.REFDATE, &quot;FUTURE_REF&quot;, new InexactTime(new Range(TIME_NOW, TIME_UNKNOWN)));</span>

<span class="fc" id="L677">  public static final Duration DURATION_UNKNOWN = new DurationWithFields();</span>
<span class="fc" id="L678">  public static final Duration DURATION_NONE = new DurationWithFields(Period.ZERO);</span>

  // Basic dates/times

  // Day of week
  // Use constructors rather than calls to
  // StandardTemporalType.createTemporal because sometimes the class
  // loader seems to load objects in an incorrect order, resulting in
  // an exception.  This is especially evident when deserializing
<span class="fc" id="L687">  public static final Time MONDAY = new PartialTime(StandardTemporalType.DAY_OF_WEEK, new Partial(DateTimeFieldType.dayOfWeek(), 1));</span>
<span class="fc" id="L688">  public static final Time TUESDAY = new PartialTime(StandardTemporalType.DAY_OF_WEEK, new Partial(DateTimeFieldType.dayOfWeek(), 2));</span>
<span class="fc" id="L689">  public static final Time WEDNESDAY = new PartialTime(StandardTemporalType.DAY_OF_WEEK, new Partial(DateTimeFieldType.dayOfWeek(), 3));</span>
<span class="fc" id="L690">  public static final Time THURSDAY = new PartialTime(StandardTemporalType.DAY_OF_WEEK, new Partial(DateTimeFieldType.dayOfWeek(), 4));</span>
<span class="fc" id="L691">  public static final Time FRIDAY = new PartialTime(StandardTemporalType.DAY_OF_WEEK, new Partial(DateTimeFieldType.dayOfWeek(), 5));</span>
<span class="fc" id="L692">  public static final Time SATURDAY = new PartialTime(StandardTemporalType.DAY_OF_WEEK, new Partial(DateTimeFieldType.dayOfWeek(), 6));</span>
<span class="fc" id="L693">  public static final Time SUNDAY = new PartialTime(StandardTemporalType.DAY_OF_WEEK, new Partial(DateTimeFieldType.dayOfWeek(), 7));</span>

<span class="fc" id="L695">  public static final Time WEEKDAY = createTemporal(StandardTemporalType.DAYS_OF_WEEK, &quot;WD&quot;,</span>
<span class="fc" id="L696">          new InexactTime(null, SUTime.DAY, new SUTime.Range(SUTime.MONDAY, SUTime.FRIDAY)) {</span>
            @Override
            public Duration getDuration() {
<span class="nc" id="L699">              return SUTime.DAY;</span>
            }
            private static final long serialVersionUID = 1;
          });
<span class="fc" id="L703">  public static final Time WEEKEND = createTemporal(StandardTemporalType.DAYS_OF_WEEK, &quot;WE&quot;,</span>
<span class="fc" id="L704">          new TimeWithRange(new SUTime.Range(SUTime.SATURDAY, SUTime.SUNDAY, SUTime.DAY.multiplyBy(2))));</span>

  // Months
  // Use constructors rather than calls to
  // StandardTemporalType.createTemporal because sometimes the class
  // loader seems to load objects in an incorrect order, resulting in
  // an exception.  This is especially evident when deserializing
<span class="fc" id="L711">  public static final Time JANUARY = new IsoDate(StandardTemporalType.MONTH_OF_YEAR, -1, 1, -1);</span>
<span class="fc" id="L712">  public static final Time FEBRUARY = new IsoDate(StandardTemporalType.MONTH_OF_YEAR, -1, 2, -1);</span>
<span class="fc" id="L713">  public static final Time MARCH = new IsoDate(StandardTemporalType.MONTH_OF_YEAR, -1, 3, -1);</span>
<span class="fc" id="L714">  public static final Time APRIL = new IsoDate(StandardTemporalType.MONTH_OF_YEAR, -1, 4, -1);</span>
<span class="fc" id="L715">  public static final Time MAY = new IsoDate(StandardTemporalType.MONTH_OF_YEAR, -1, 5, -1);</span>
<span class="fc" id="L716">  public static final Time JUNE = new IsoDate(StandardTemporalType.MONTH_OF_YEAR, -1, 6, -1);</span>
<span class="fc" id="L717">  public static final Time JULY = new IsoDate(StandardTemporalType.MONTH_OF_YEAR, -1, 7, -1);</span>
<span class="fc" id="L718">  public static final Time AUGUST = new IsoDate(StandardTemporalType.MONTH_OF_YEAR, -1, 8, -1);</span>
<span class="fc" id="L719">  public static final Time SEPTEMBER = new IsoDate(StandardTemporalType.MONTH_OF_YEAR, -1, 9, -1);</span>
<span class="fc" id="L720">  public static final Time OCTOBER = new IsoDate(StandardTemporalType.MONTH_OF_YEAR, -1, 10, -1);</span>
<span class="fc" id="L721">  public static final Time NOVEMBER = new IsoDate(StandardTemporalType.MONTH_OF_YEAR, -1, 11, -1);</span>
<span class="fc" id="L722">  public static final Time DECEMBER = new IsoDate(StandardTemporalType.MONTH_OF_YEAR, -1, 12, -1);</span>

  // Dates are rough with respect to northern hemisphere (actual
  // solstice/equinox days depend on the year)
<span class="fc" id="L726">  public static final Time SPRING_EQUINOX = createTemporal(StandardTemporalType.DAY_OF_YEAR, &quot;SP&quot;, new SUTime.InexactTime(new SUTime.Range(new IsoDate(-1, 3, 20), new IsoDate(-1, 3, 21))));</span>
<span class="fc" id="L727">  public static final Time SUMMER_SOLSTICE = createTemporal(StandardTemporalType.DAY_OF_YEAR, &quot;SU&quot;, new SUTime.InexactTime(new SUTime.Range(new IsoDate(-1, 6, 20), new IsoDate(-1, 6, 21))));</span>
<span class="fc" id="L728">  public static final Time WINTER_SOLSTICE = createTemporal(StandardTemporalType.DAY_OF_YEAR, &quot;WI&quot;, new SUTime.InexactTime(new SUTime.Range(new IsoDate(-1, 12, 21), new IsoDate(-1, 12, 22))));</span>
<span class="fc" id="L729">  public static final Time FALL_EQUINOX = createTemporal(StandardTemporalType.DAY_OF_YEAR, &quot;FA&quot;, new SUTime.InexactTime(new SUTime.Range(new IsoDate(-1, 9, 22), new IsoDate(-1, 9, 23))));</span>

  // Dates for seasons are rough with respect to northern hemisphere
<span class="fc" id="L732">  public static final Time SPRING = createTemporal(StandardTemporalType.SEASON_OF_YEAR, &quot;SP&quot;,</span>
           new SUTime.InexactTime(SPRING_EQUINOX, QUARTER, new SUTime.Range(SUTime.MARCH, SUTime.JUNE, SUTime.QUARTER)));
<span class="fc" id="L734">  public static final Time SUMMER = createTemporal(StandardTemporalType.SEASON_OF_YEAR, &quot;SU&quot;,</span>
           new SUTime.InexactTime(SUMMER_SOLSTICE, QUARTER, new SUTime.Range(SUTime.JUNE, SUTime.SEPTEMBER, SUTime.QUARTER)));
<span class="fc" id="L736">  public static final Time FALL = createTemporal(StandardTemporalType.SEASON_OF_YEAR, &quot;FA&quot;,</span>
          new SUTime.InexactTime(FALL_EQUINOX, QUARTER, new SUTime.Range(SUTime.SEPTEMBER, SUTime.DECEMBER, SUTime.QUARTER)));
<span class="fc" id="L738">  public static final Time WINTER = createTemporal(StandardTemporalType.SEASON_OF_YEAR, &quot;WI&quot;,</span>
          new SUTime.InexactTime(WINTER_SOLSTICE, QUARTER, new SUTime.Range(SUTime.DECEMBER, SUTime.MARCH, SUTime.QUARTER)));

  // Time of day
<span class="fc" id="L742">  public static final PartialTime NOON = createTemporal(StandardTemporalType.TIME_OF_DAY, &quot;MI&quot;, new IsoTime(12, 0, -1));</span>
<span class="fc" id="L743">  public static final PartialTime MIDNIGHT = createTemporal(StandardTemporalType.TIME_OF_DAY, new IsoTime(0, 0, -1));</span>
<span class="fc" id="L744">  public static final Time MORNING = createTemporal(StandardTemporalType.TIME_OF_DAY, &quot;MO&quot;, new InexactTime(new Range(new InexactTime(new Partial(DateTimeFieldType.hourOfDay(), 6)), NOON)));</span>
<span class="fc" id="L745">  public static final Time AFTERNOON = createTemporal(StandardTemporalType.TIME_OF_DAY, &quot;AF&quot;, new InexactTime(new Range(NOON, new InexactTime(new Partial(DateTimeFieldType.hourOfDay(), 18)))));</span>
<span class="fc" id="L746">  public static final Time EVENING = createTemporal(StandardTemporalType.TIME_OF_DAY, &quot;EV&quot;, new InexactTime(new Range(new InexactTime(new Partial(DateTimeFieldType.hourOfDay(), 18)), new InexactTime(new Partial(DateTimeFieldType</span>
<span class="fc" id="L747">      .hourOfDay(), 20)))));</span>
<span class="fc" id="L748">  public static final Time NIGHT = createTemporal(StandardTemporalType.TIME_OF_DAY, &quot;NI&quot;,</span>
<span class="fc" id="L749">          new InexactTime(MIDNIGHT, new Range(new InexactTime(new Partial(DateTimeFieldType.hourOfDay(), 14)), HOUR.multiplyBy(10))));</span>
<span class="fc" id="L750">  public static final Time SUNRISE = createTemporal(StandardTemporalType.TIME_OF_DAY, &quot;MO&quot;, TimexMod.EARLY.name(), new PartialTime());</span>
<span class="fc" id="L751">  public static final Time SUNSET = createTemporal(StandardTemporalType.TIME_OF_DAY, &quot;EV&quot;, TimexMod.EARLY.name(), new PartialTime());</span>
<span class="fc" id="L752">  public static final Time DAWN = createTemporal(StandardTemporalType.TIME_OF_DAY, &quot;MO&quot;, TimexMod.EARLY.name(), new PartialTime());</span>
<span class="fc" id="L753">  public static final Time DUSK = createTemporal(StandardTemporalType.TIME_OF_DAY, &quot;EV&quot;, new PartialTime());</span>
<span class="fc" id="L754">  public static final Time DAYTIME = createTemporal(StandardTemporalType.TIME_OF_DAY, &quot;DT&quot;, new InexactTime(new Range(SUNRISE, SUNSET)));</span>
<span class="fc" id="L755">  public static final Time LUNCHTIME = createTemporal(StandardTemporalType.TIME_OF_DAY, &quot;MI&quot;, new InexactTime(new Range(new InexactTime(new Partial(DateTimeFieldType.hourOfDay(), 12)), new InexactTime(new Partial(DateTimeFieldType</span>
<span class="fc" id="L756">      .hourOfDay(), 14)))));</span>
<span class="fc" id="L757">  public static final Time TEATIME = createTemporal(StandardTemporalType.TIME_OF_DAY, &quot;AF&quot;, new InexactTime(new Range(new InexactTime(new Partial(DateTimeFieldType.hourOfDay(), 15)), new InexactTime(new Partial(DateTimeFieldType</span>
<span class="fc" id="L758">      .hourOfDay(), 17)))));</span>
<span class="fc" id="L759">  public static final Time DINNERTIME = createTemporal(StandardTemporalType.TIME_OF_DAY, &quot;EV&quot;, new InexactTime(new Range(new InexactTime(new Partial(DateTimeFieldType.hourOfDay(), 18)), new InexactTime(new Partial(DateTimeFieldType</span>
<span class="fc" id="L760">      .hourOfDay(), 20)))));</span>

<span class="fc" id="L762">  public static final Time MORNING_TWILIGHT = createTemporal(StandardTemporalType.TIME_OF_DAY, &quot;MO&quot;, new InexactTime(new Range(DAWN, SUNRISE)));</span>
<span class="fc" id="L763">  public static final Time EVENING_TWILIGHT = createTemporal(StandardTemporalType.TIME_OF_DAY, &quot;EV&quot;, new InexactTime(new Range(SUNSET, DUSK)));</span>
<span class="fc" id="L764">  public static final TemporalSet TWILIGHT = createTemporal(StandardTemporalType.TIME_OF_DAY, &quot;NI&quot;, new ExplicitTemporalSet(EVENING_TWILIGHT, MORNING_TWILIGHT));</span>

  // Relative days
<span class="fc" id="L767">  public static final RelativeTime YESTERDAY = new RelativeTime(DAY.multiplyBy(-1));</span>
<span class="fc" id="L768">  public static final RelativeTime TOMORROW = new RelativeTime(DAY.multiplyBy(+1));</span>
<span class="fc" id="L769">  public static final RelativeTime TODAY = new RelativeTime(TemporalOp.THIS, SUTime.DAY);</span>
<span class="fc" id="L770">  public static final RelativeTime TONIGHT = new RelativeTime(TemporalOp.THIS, SUTime.NIGHT);</span>

<span class="pc" id="L772">  public enum TimeUnit {</span>
    // Basic time units
<span class="fc" id="L774">    MILLIS(SUTime.MILLIS), SECOND(SUTime.SECOND), MINUTE(SUTime.MINUTE), HOUR(SUTime.HOUR),</span>
<span class="fc" id="L775">    DAY(SUTime.DAY), WEEK(SUTime.WEEK), MONTH(SUTime.MONTH), QUARTER(SUTime.QUARTER), HALFYEAR(SUTime.HALFYEAR),</span>
<span class="fc" id="L776">    YEAR(SUTime.YEAR), DECADE(SUTime.DECADE), CENTURY(SUTime.CENTURY), MILLENNIUM(SUTime.MILLENNIUM),</span>
<span class="fc" id="L777">    UNKNOWN(SUTime.DURATION_UNKNOWN);</span>

    protected Duration duration;

<span class="fc" id="L781">    TimeUnit(Duration d) {</span>
<span class="fc" id="L782">      this.duration = d;</span>
<span class="fc" id="L783">    }</span>

    public Duration getDuration() {
<span class="fc" id="L786">      return duration;</span>
    } // How long does this time last?

    public Duration getPeriod() {
<span class="nc" id="L790">      return duration;</span>
    } // How often does this type of time occur?

    public Duration getGranularity() {
<span class="fc" id="L794">      return duration;</span>
    } // What is the granularity of this time?

    public Temporal createTemporal(int n) {
<span class="nc" id="L798">      return duration.multiplyBy(n);</span>
    }
  }

<span class="pc" id="L802">  public enum StandardTemporalType {</span>
<span class="fc" id="L803">    REFDATE(TimexType.DATE),</span>
<span class="fc" id="L804">    REFTIME(TimexType.TIME),</span>
 /*   MILLIS(TimexType.TIME, TimeUnit.MILLIS),
    SECOND(TimexType.TIME, TimeUnit.SECOND),
    MINUTE(TimexType.TIME, TimeUnit.MINUTE),
    HOUR(TimexType.TIME, TimeUnit.HOUR),
    DAY(TimexType.TIME, TimeUnit.DAY),
    WEEK(TimexType.TIME, TimeUnit.WEEK),
    MONTH(TimexType.TIME, TimeUnit.MONTH),
    QUARTER(TimexType.TIME, TimeUnit.QUARTER),
    YEAR(TimexType.TIME, TimeUnit.YEAR),  */
<span class="fc" id="L814">    TIME_OF_DAY(TimexType.TIME, TimeUnit.HOUR, SUTime.DAY) {</span>
      @Override
      public Duration getDuration() {
<span class="fc" id="L817">        return SUTime.HOUR.makeInexact();</span>
      }
    },
<span class="fc" id="L820">    DAY_OF_YEAR(TimexType.DATE, TimeUnit.DAY, SUTime.YEAR) {</span>
      @Override
      protected Time _createTemporal(int n) {
<span class="nc" id="L823">        return new PartialTime(new Partial(DateTimeFieldType.dayOfYear(), n));</span>
      }
    },
<span class="fc" id="L826">    DAY_OF_WEEK(TimexType.DATE, TimeUnit.DAY, SUTime.WEEK) {</span>
      @Override
      protected Time _createTemporal(int n) {
<span class="nc" id="L829">        return new PartialTime(new Partial(DateTimeFieldType.dayOfWeek(), n));</span>
      }
    },
<span class="fc" id="L832">    DAYS_OF_WEEK(TimexType.DATE, TimeUnit.DAY, SUTime.WEEK) {</span>
      @Override
      public Duration getDuration() {
<span class="nc" id="L835">        return SUTime.DAY.makeInexact();</span>
      }
    },
<span class="fc" id="L838">    WEEK_OF_YEAR(TimexType.DATE, TimeUnit.WEEK, SUTime.YEAR) {</span>
      @Override
      protected Time _createTemporal(int n) {
<span class="nc" id="L841">        return new PartialTime(new Partial(DateTimeFieldType.weekOfWeekyear(), n));</span>
      }
    },
<span class="fc" id="L844">    MONTH_OF_YEAR(TimexType.DATE, TimeUnit.MONTH, SUTime.YEAR) {</span>
      @Override
      protected Time _createTemporal(int n) {
        //return new PartialTime(new Partial(DateTimeFieldType.monthOfYear(), n));
<span class="nc" id="L848">        return new IsoDate(-1, n, -1);</span>
      }
    },
<span class="fc" id="L851">    PART_OF_YEAR(TimexType.DATE, TimeUnit.DAY, SUTime.YEAR) {</span>
      @Override
      public Duration getDuration() {
<span class="nc" id="L854">        return SUTime.DAY.makeInexact();</span>
      }
    },
<span class="fc" id="L857">    SEASON_OF_YEAR(TimexType.DATE, TimeUnit.QUARTER, SUTime.YEAR),</span>

<span class="fc" id="L859">    QUARTER_OF_YEAR(TimexType.DATE, TimeUnit.QUARTER, SUTime.YEAR) {</span>
      @Override
      protected Time _createTemporal(int n) {
<span class="nc" id="L862">        return new PartialTime(new Partial(JodaTimeUtils.QuarterOfYear, n));</span>
      }
    },

<span class="fc" id="L866">    HALF_OF_YEAR(TimexType.DATE, TimeUnit.HALFYEAR, SUTime.YEAR) {</span>
      @Override
      protected Time _createTemporal(int n) {
<span class="nc" id="L869">        return new PartialTime(new Partial(JodaTimeUtils.HalfYearOfYear, n));</span>
      }
    };

    final TimexType timexType;
<span class="pc" id="L874">    TimeUnit unit = TimeUnit.UNKNOWN;</span>
<span class="pc" id="L875">    Duration period = SUTime.DURATION_NONE;</span>

<span class="fc" id="L877">    StandardTemporalType(TimexType timexType) {</span>
<span class="fc" id="L878">      this.timexType = timexType;</span>
<span class="fc" id="L879">    }</span>

<span class="nc" id="L881">    StandardTemporalType(TimexType timexType, TimeUnit unit) {</span>
<span class="nc" id="L882">      this.timexType = timexType;</span>
<span class="nc" id="L883">      this.unit = unit;</span>
<span class="nc" id="L884">      this.period = unit.getPeriod();</span>
<span class="nc" id="L885">    }</span>

<span class="fc" id="L887">    StandardTemporalType(TimexType timexType, TimeUnit unit, Duration period) {</span>
<span class="fc" id="L888">      this.timexType = timexType;</span>
<span class="fc" id="L889">      this.unit = unit;</span>
<span class="fc" id="L890">      this.period = period;</span>
<span class="fc" id="L891">    }</span>

    public TimexType getTimexType() {
<span class="nc" id="L894">      return timexType;</span>
    }

    public Duration getDuration() {
<span class="fc" id="L898">      return unit.getDuration();</span>
    } // How long does this time last?

    public Duration getPeriod() {
<span class="fc" id="L902">      return period;</span>
    } // How often does this type of time occur?

    public Duration getGranularity() {
<span class="fc" id="L906">      return unit.getGranularity();</span>
    } // What is the granularity of this time?

    protected Temporal _createTemporal(int n) {
<span class="nc" id="L910">      return null;</span>
    }

    public Temporal createTemporal(int n) {
<span class="nc" id="L914">      Temporal t = _createTemporal(n);</span>
<span class="nc bnc" id="L915" title="All 2 branches missed.">      if (t != null) {</span>
<span class="nc" id="L916">        t.standardTemporalType = this;</span>
      }
<span class="nc" id="L918">      return t;</span>
    }

    public static Temporal create(Expressions.CompositeValue compositeValue) {
<span class="nc" id="L922">      StandardTemporalType temporalType = compositeValue.get(&quot;type&quot;);</span>
<span class="nc" id="L923">      String label = compositeValue.get(&quot;label&quot;);</span>
<span class="nc" id="L924">      String modifier = compositeValue.get(&quot;modifier&quot;);</span>
<span class="nc" id="L925">      Temporal temporal = compositeValue.get(&quot;value&quot;);</span>
<span class="nc bnc" id="L926" title="All 2 branches missed.">      if (temporal == null) {</span>
<span class="nc" id="L927">        temporal = new PartialTime();</span>
      }
<span class="nc" id="L929">      return SUTime.createTemporal(temporalType,  label, modifier, temporal);</span>
    }
  }



  // Temporal operators (currently operates on two temporals and returns another
  // temporal)
  // Can add operators for:
  // lookup of temporal from string
  // creating durations, dates
  // public interface TemporalOp extends Function&lt;Temporal,Temporal&gt;();
<span class="pc" id="L941">  public enum TemporalOp {</span>
    // For durations: possible interpretation of next/prev:
    // next month, next week
    // NEXT: on Thursday, next week = week starting on next monday
    // ??? on Thursday, next week = one week starting from now
    // prev month, prev week
    // PREV: on Thursday, last week = week starting on the monday one week
    // before this monday
    // ??? on Thursday, last week = one week going back starting from now
    // NEXT: on June 19, next month = July 1 to July 31
    // ???:  on June 19, next month = July 19 to August 19
    //
    //
    // For partial dates: two kind of next
    // next tuesday, next winter, next january
    // NEXT (PARENT UNIT, FAVOR): Example: on monday, next tuesday = tuesday of
    // the week after this
    // NEXT IMMEDIATE (NOT FAVORED): Example: on monday, next saturday =
    // saturday of this week
    // last saturday, last winter, last january
    // PREV (PARENT UNIT, FAVOR): Example: on wednesday, last tuesday = tuesday
    // of the week before this
    // PREV IMMEDIATE (NOT FAVORED): Example: on saturday, last tuesday =
    // tuesday of this week

    // (successor) Next week/day/...
<span class="fc" id="L967">    NEXT {</span>
      @Override
      public Temporal apply(Temporal arg1, Temporal arg2, int flags) {
<span class="pc bpc" id="L970" title="1 of 2 branches missed.">        if (arg2 == null) {</span>
<span class="nc" id="L971">          return arg1;</span>
        }
<span class="fc" id="L973">        Temporal arg2Next = arg2.next();</span>
<span class="pc bpc" id="L974" title="2 of 4 branches missed.">        if (arg1 == null || arg2Next == null) {</span>
<span class="nc" id="L975">          return arg2Next;</span>
        }
<span class="pc bpc" id="L977" title="1 of 2 branches missed.">        if (arg1 instanceof Time) {</span>
          // TODO: flags?
<span class="fc" id="L979">          Temporal resolved = arg2Next.resolve((Time) arg1, 0 /* RESOLVE_TO_FUTURE */);</span>
<span class="fc" id="L980">          return resolved;</span>
        } else {
<span class="nc" id="L982">          throw new UnsupportedOperationException(&quot;NEXT not implemented for arg1=&quot; + arg1.getClass() + &quot;, arg2=&quot; + arg2.getClass());</span>
        }
      }
    },
    // This coming week/friday
<span class="fc" id="L987">    NEXT_IMMEDIATE {</span>
      @Override
      public Temporal apply(Temporal arg1, Temporal arg2, int flags) {
<span class="nc bnc" id="L990" title="All 2 branches missed.">        if (arg1 == null) {</span>
<span class="nc" id="L991">          return new RelativeTime(NEXT_IMMEDIATE, arg2);</span>
        }
<span class="nc bnc" id="L993" title="All 2 branches missed.">        if (arg2 == null) {</span>
<span class="nc" id="L994">          return arg1;</span>
        }
        // Temporal arg2Next = arg2.next();
        // if (arg1 == null || arg2Next == null) { return arg2Next; }
<span class="nc bnc" id="L998" title="All 2 branches missed.">        if (arg1 instanceof Time) {</span>
<span class="nc" id="L999">          Time t = (Time) arg1;</span>
<span class="nc bnc" id="L1000" title="All 2 branches missed.">          if (arg2 instanceof Duration) {</span>
<span class="nc" id="L1001">            return ((Duration) arg2).toTime(t, flags | RESOLVE_TO_FUTURE);</span>
          } else {
            // TODO: flags?
<span class="nc" id="L1004">            Temporal resolvedThis = arg2.resolve(t, RESOLVE_TO_FUTURE);</span>
<span class="nc bnc" id="L1005" title="All 2 branches missed.">            if (resolvedThis != null) {</span>
<span class="nc bnc" id="L1006" title="All 2 branches missed.">              if (resolvedThis instanceof Time) {</span>
<span class="nc bnc" id="L1007" title="All 2 branches missed.">                if (((Time) resolvedThis).compareTo(t) &lt;= 0) {</span>
<span class="nc" id="L1008">                  return NEXT.apply(arg1, arg2);</span>
                }
              }
            }
<span class="nc" id="L1012">            return resolvedThis;</span>
          }
        } else {
<span class="nc" id="L1015">          throw new UnsupportedOperationException(&quot;NEXT_IMMEDIATE not implemented for arg1=&quot; + arg1.getClass() + &quot;, arg2=&quot; + arg2.getClass());</span>
        }
      }
    },
    // Use arg1 as reference to resolve arg2 (take more general fields from arg1
    // and apply to arg2)
<span class="fc" id="L1021">    THIS {</span>
      @Override
      public Temporal apply(Temporal arg1, Temporal arg2, int flags) {
<span class="pc bpc" id="L1024" title="1 of 2 branches missed.">        if (arg1 == null) {</span>
<span class="nc" id="L1025">          return new RelativeTime(THIS, arg2, flags);</span>
        }
<span class="pc bpc" id="L1027" title="1 of 2 branches missed.">        if (arg1 instanceof Time) {</span>
<span class="fc bfc" id="L1028" title="All 2 branches covered.">          if (arg2 instanceof Duration) {</span>
<span class="fc" id="L1029">            return ((Duration) arg2).toTime((Time) arg1, flags);</span>
          } else {
            // TODO: flags?
<span class="fc" id="L1032">            return arg2.resolve((Time) arg1, flags | RESOLVE_TO_THIS);</span>
          }
        } else {
<span class="nc" id="L1035">          throw new UnsupportedOperationException(&quot;THIS not implemented for arg1=&quot; + arg1.getClass() + &quot;, arg2=&quot; + arg2.getClass());</span>
        }
      }
    },
    // (predecessor) Previous week/day/...
<span class="fc" id="L1040">    PREV {</span>
      @Override
      public Temporal apply(Temporal arg1, Temporal arg2, int flags) {
<span class="nc bnc" id="L1043" title="All 2 branches missed.">        if (arg2 == null) {</span>
<span class="nc" id="L1044">          return arg1;</span>
        }
<span class="nc" id="L1046">        Temporal arg2Prev = arg2.prev();</span>
<span class="nc bnc" id="L1047" title="All 4 branches missed.">        if (arg1 == null || arg2Prev == null) {</span>
<span class="nc" id="L1048">          return arg2Prev;</span>
        }
<span class="nc bnc" id="L1050" title="All 2 branches missed.">        if (arg1 instanceof Time) {</span>
          // TODO: flags?
<span class="nc" id="L1052">          Temporal resolved = arg2Prev.resolve((Time) arg1, 0 /*RESOLVE_TO_PAST */);</span>
<span class="nc" id="L1053">          return resolved;</span>
        } else {
<span class="nc" id="L1055">          throw new UnsupportedOperationException(&quot;PREV not implemented for arg1=&quot; + arg1.getClass() + &quot;, arg2=&quot; + arg2.getClass());</span>
        }
      }
    },
    // This past week/friday
<span class="fc" id="L1060">    PREV_IMMEDIATE {</span>
      @Override
      public Temporal apply(Temporal arg1, Temporal arg2, int flags) {
<span class="nc bnc" id="L1063" title="All 2 branches missed.">        if (arg1 == null) {</span>
<span class="nc" id="L1064">          return new RelativeTime(PREV_IMMEDIATE, arg2);</span>
        }
<span class="nc bnc" id="L1066" title="All 2 branches missed.">        if (arg2 == null) {</span>
<span class="nc" id="L1067">          return arg1;</span>
        }
        // Temporal arg2Prev = arg2.prev();
        // if (arg1 == null || arg2Prev == null) { return arg2Prev; }
<span class="nc bnc" id="L1071" title="All 2 branches missed.">        if (arg1 instanceof Time) {</span>
<span class="nc" id="L1072">          Time t = (Time) arg1;</span>
<span class="nc bnc" id="L1073" title="All 2 branches missed.">          if (arg2 instanceof Duration) {</span>
<span class="nc" id="L1074">            return ((Duration) arg2).toTime(t, flags | RESOLVE_TO_PAST);</span>
          } else {
            // TODO: flags?
<span class="nc" id="L1077">            Temporal resolvedThis = arg2.resolve(t, RESOLVE_TO_PAST);</span>
<span class="nc bnc" id="L1078" title="All 2 branches missed.">            if (resolvedThis != null) {</span>
<span class="nc bnc" id="L1079" title="All 2 branches missed.">              if (resolvedThis instanceof Time) {</span>
<span class="nc bnc" id="L1080" title="All 2 branches missed.">                if (((Time) resolvedThis).compareTo(t) &gt;= 0) {</span>
<span class="nc" id="L1081">                  return PREV.apply(arg1, arg2);</span>
                }
              }
            }
<span class="nc" id="L1085">            return resolvedThis;</span>
          }
        } else {
<span class="nc" id="L1088">          throw new UnsupportedOperationException(&quot;PREV_IMMEDIATE not implemented for arg1=&quot; + arg1.getClass() + &quot;, arg2=&quot; + arg2.getClass());</span>
        }
      }
    },
<span class="fc" id="L1092">    UNION {</span>
      @Override
      public Temporal apply(Temporal arg1, Temporal arg2, int flags) {
<span class="nc bnc" id="L1095" title="All 2 branches missed.">        if (arg1 == null) {</span>
<span class="nc" id="L1096">          return arg2;</span>
        }
<span class="nc bnc" id="L1098" title="All 2 branches missed.">        if (arg2 == null) {</span>
<span class="nc" id="L1099">          return arg1;</span>
        }
        // return arg1.union(arg2);
<span class="nc" id="L1102">        throw new UnsupportedOperationException(&quot;UNION not implemented for arg1=&quot; + arg1.getClass() + &quot;, arg2=&quot; + arg2.getClass());</span>
      }
    },
<span class="fc" id="L1105">    INTERSECT {</span>
      @Override
      public Temporal apply(Temporal arg1, Temporal arg2, int flags) {
<span class="nc bnc" id="L1108" title="All 2 branches missed.">        if (arg1 == null) {</span>
<span class="nc" id="L1109">          return arg2;</span>
        }
<span class="nc bnc" id="L1111" title="All 2 branches missed.">        if (arg2 == null) {</span>
<span class="nc" id="L1112">          return arg1;</span>
        }
<span class="nc" id="L1114">        Temporal t = arg1.intersect(arg2);</span>
<span class="nc bnc" id="L1115" title="All 2 branches missed.">        if (t == null) {</span>
<span class="nc" id="L1116">          t = arg2.intersect(arg1);</span>
        }
<span class="nc" id="L1118">        return t;</span>
        // throw new
        // UnsupportedOperationException(&quot;INTERSECT not implemented for arg1=&quot; +
        // arg1.getClass() + &quot;, arg2=&quot;+arg2.getClass());
      }
    },
    // arg2 is &quot;in&quot; arg1, composite datetime
<span class="fc" id="L1125">    IN {</span>
      @Override
      public Temporal apply(Temporal arg1, Temporal arg2, int flags) {
<span class="nc bnc" id="L1128" title="All 2 branches missed.">        if (arg1 == null) {</span>
<span class="nc" id="L1129">          return arg2;</span>
        }
<span class="nc bnc" id="L1131" title="All 2 branches missed.">        if (arg1 instanceof Time) {</span>
          // TODO: flags?
<span class="nc" id="L1133">          return arg2.intersect((Time) arg1);</span>
        } else {
<span class="nc" id="L1135">          throw new UnsupportedOperationException(&quot;IN not implemented for arg1=&quot; + arg1.getClass() + &quot;, arg2=&quot; + arg2.getClass());</span>
        }
      }
    },
<span class="fc" id="L1139">    OFFSET {</span>
      // There is inexact offset where we remove anything from the result that is more granular than the duration
      @Override
      public Temporal apply(Temporal arg1, Temporal arg2, int flags) {
<span class="pc bpc" id="L1143" title="1 of 2 branches missed.">        if (arg1 == null) {</span>
<span class="nc" id="L1144">          return new RelativeTime(OFFSET, arg2);</span>
        }
<span class="pc bpc" id="L1146" title="2 of 4 branches missed.">        if (arg1 instanceof Time &amp;&amp; arg2 instanceof Duration) {</span>
<span class="fc" id="L1147">          return ((Time) arg1).offset((Duration) arg2, flags | RELATIVE_OFFSET_INEXACT);</span>
<span class="nc bnc" id="L1148" title="All 4 branches missed.">        } else if (arg1 instanceof Range &amp;&amp; arg2 instanceof Duration) {</span>
<span class="nc" id="L1149">          return ((Range) arg1).offset((Duration) arg2, flags | RELATIVE_OFFSET_INEXACT);</span>
        } else {
<span class="nc" id="L1151">          throw new UnsupportedOperationException(&quot;OFFSET not implemented for arg1=&quot; + arg1.getClass() + &quot;, arg2=&quot; + arg2.getClass());</span>
        }
      }
    },
<span class="fc" id="L1155">    MINUS {</span>
      @Override
      public Temporal apply(Temporal arg1, Temporal arg2, int flags) {
<span class="nc bnc" id="L1158" title="All 2 branches missed.">        if (arg1 == null) {</span>
<span class="nc" id="L1159">          return arg2;</span>
        }
<span class="nc bnc" id="L1161" title="All 2 branches missed.">        if (arg2 == null) {</span>
<span class="nc" id="L1162">          return arg1;</span>
        }
<span class="nc bnc" id="L1164" title="All 4 branches missed.">        if (arg1 instanceof Duration &amp;&amp; arg2 instanceof Duration) {</span>
<span class="nc" id="L1165">          return ((Duration) arg1).subtract((Duration) arg2);</span>
<span class="nc bnc" id="L1166" title="All 4 branches missed.">        } else if (arg1 instanceof Time &amp;&amp; arg2 instanceof Duration) {</span>
<span class="nc" id="L1167">          return ((Time) arg1).subtract((Duration) arg2);</span>
<span class="nc bnc" id="L1168" title="All 4 branches missed.">        } else if (arg1 instanceof Range &amp;&amp; arg2 instanceof Duration) {</span>
<span class="nc" id="L1169">          return ((Range) arg1).subtract((Duration) arg2);</span>
        } else {
<span class="nc" id="L1171">          throw new UnsupportedOperationException(&quot;MINUS not implemented for arg1=&quot; + arg1.getClass() + &quot;, arg2=&quot; + arg2.getClass());</span>
        }
      }
    },
<span class="fc" id="L1175">    PLUS {</span>
      @Override
      public Temporal apply(Temporal arg1, Temporal arg2, int flags) {
<span class="nc bnc" id="L1178" title="All 2 branches missed.">        if (arg1 == null) {</span>
<span class="nc" id="L1179">          return arg2;</span>
        }
<span class="nc bnc" id="L1181" title="All 2 branches missed.">        if (arg2 == null) {</span>
<span class="nc" id="L1182">          return arg1;</span>
        }
<span class="nc bnc" id="L1184" title="All 4 branches missed.">        if (arg1 instanceof Duration &amp;&amp; arg2 instanceof Duration) {</span>
<span class="nc" id="L1185">          return ((Duration) arg1).add((Duration) arg2);</span>
<span class="nc bnc" id="L1186" title="All 4 branches missed.">        } else if (arg1 instanceof Time &amp;&amp; arg2 instanceof Duration) {</span>
<span class="nc" id="L1187">          return ((Time) arg1).add((Duration) arg2);</span>
<span class="nc bnc" id="L1188" title="All 4 branches missed.">        } else if (arg1 instanceof Range &amp;&amp; arg2 instanceof Duration) {</span>
<span class="nc" id="L1189">          return ((Range) arg1).add((Duration) arg2);</span>
        } else {
<span class="nc" id="L1191">          throw new UnsupportedOperationException(&quot;PLUS not implemented for arg1=&quot; + arg1.getClass() + &quot;, arg2=&quot; + arg2.getClass());</span>
        }
      }
    },
<span class="fc" id="L1195">    MIN {</span>
      @Override
      public Temporal apply(Temporal arg1, Temporal arg2, int flags) {
<span class="nc bnc" id="L1198" title="All 2 branches missed.">        if (arg1 == null) {</span>
<span class="nc" id="L1199">          return arg2;</span>
        }
<span class="nc bnc" id="L1201" title="All 2 branches missed.">        if (arg2 == null) {</span>
<span class="nc" id="L1202">          return arg1;</span>
        }
<span class="nc bnc" id="L1204" title="All 4 branches missed.">        if (arg1 instanceof Time &amp;&amp; arg2 instanceof Time) {</span>
<span class="nc" id="L1205">          return Time.min((Time) arg1, (Time) arg2);</span>
<span class="nc bnc" id="L1206" title="All 4 branches missed.">        } else if (arg1 instanceof Duration &amp;&amp; arg2 instanceof Duration) {</span>
<span class="nc" id="L1207">          return Duration.min((Duration) arg1, (Duration) arg2);</span>
        } else {
<span class="nc" id="L1209">          throw new UnsupportedOperationException(&quot;MIN not implemented for arg1=&quot; + arg1.getClass() + &quot;, arg2=&quot; + arg2.getClass());</span>
        }
      }
    },
<span class="fc" id="L1213">    MAX {</span>
      @Override
      public Temporal apply(Temporal arg1, Temporal arg2, int flags) {
<span class="nc bnc" id="L1216" title="All 2 branches missed.">        if (arg1 == null) {</span>
<span class="nc" id="L1217">          return arg2;</span>
        }
<span class="nc bnc" id="L1219" title="All 2 branches missed.">        if (arg2 == null) {</span>
<span class="nc" id="L1220">          return arg1;</span>
        }
<span class="nc bnc" id="L1222" title="All 4 branches missed.">        if (arg1 instanceof Time &amp;&amp; arg2 instanceof Time) {</span>
<span class="nc" id="L1223">          return Time.max((Time) arg1, (Time) arg2);</span>
<span class="nc bnc" id="L1224" title="All 4 branches missed.">        } else if (arg1 instanceof Duration &amp;&amp; arg2 instanceof Duration) {</span>
<span class="nc" id="L1225">          return Duration.max((Duration) arg1, (Duration) arg2);</span>
        } else {
<span class="nc" id="L1227">          throw new UnsupportedOperationException(&quot;MAX not implemented for arg1=&quot; + arg1.getClass() + &quot;, arg2=&quot; + arg2.getClass());</span>
        }
      }
    },
<span class="fc" id="L1231">    MULTIPLY {</span>
      public Temporal apply(Duration d, int scale) {
<span class="nc bnc" id="L1233" title="All 2 branches missed.">        if (d == null)</span>
<span class="nc" id="L1234">          return null;</span>
<span class="nc bnc" id="L1235" title="All 2 branches missed.">        if (scale == 1) return d;</span>
<span class="nc" id="L1236">        return d.multiplyBy(scale);</span>
      }

      public Temporal apply(PeriodicTemporalSet d, int scale) {
<span class="nc bnc" id="L1240" title="All 2 branches missed.">        if (d == null)</span>
<span class="nc" id="L1241">          return null;</span>
<span class="nc bnc" id="L1242" title="All 2 branches missed.">        if (scale == 1) return d;</span>
<span class="nc" id="L1243">        return d.multiplyDurationBy(scale);</span>
      }

      @Override
      public Temporal apply(Object... args) {
<span class="nc bnc" id="L1248" title="All 2 branches missed.">        if (args.length == 2) {</span>
<span class="nc bnc" id="L1249" title="All 6 branches missed.">          if (args[0] instanceof Duration &amp;&amp; (args[1] instanceof Integer || args[1] instanceof Long)) {</span>
<span class="nc" id="L1250">            return apply((Duration) args[0], ((Number) args[1]).intValue());</span>
          }
<span class="nc bnc" id="L1252" title="All 6 branches missed.">          if (args[0] instanceof PeriodicTemporalSet &amp;&amp; (args[1] instanceof Integer || args[1] instanceof Long)) {</span>
<span class="nc" id="L1253">            return apply((PeriodicTemporalSet) args[0], ((Number) args[1]).intValue());</span>
          }
        }
<span class="nc" id="L1256">        throw new UnsupportedOperationException(&quot;apply(Object...) not implemented for TemporalOp &quot; + this);</span>
      }
    },
<span class="fc" id="L1259">    DIVIDE {</span>
      public Temporal apply(Duration d, int scale) {
<span class="nc bnc" id="L1261" title="All 2 branches missed.">        if (d == null)</span>
<span class="nc" id="L1262">          return null;</span>
<span class="nc bnc" id="L1263" title="All 2 branches missed.">        if (scale == 1) return d;</span>
<span class="nc" id="L1264">        return d.divideBy(scale);</span>
      }
      public Temporal apply(PeriodicTemporalSet d, int scale) {
<span class="nc bnc" id="L1267" title="All 2 branches missed.">        if (d == null)</span>
<span class="nc" id="L1268">          return null;</span>
<span class="nc bnc" id="L1269" title="All 2 branches missed.">        if (scale == 1) return d;</span>
<span class="nc" id="L1270">        return d.divideDurationBy(scale);</span>
      }

      @Override
      public Temporal apply(Object... args) {
<span class="nc bnc" id="L1275" title="All 2 branches missed.">        if (args.length == 2) {</span>
<span class="nc bnc" id="L1276" title="All 6 branches missed.">          if (args[0] instanceof Duration &amp;&amp; (args[1] instanceof Integer || args[1] instanceof Long)) {</span>
<span class="nc" id="L1277">            return apply((Duration) args[0], ((Number) args[1]).intValue());</span>
          }
<span class="nc bnc" id="L1279" title="All 6 branches missed.">          if (args[0] instanceof PeriodicTemporalSet &amp;&amp; (args[1] instanceof Integer || args[1] instanceof Long)) {</span>
<span class="nc" id="L1280">            return apply((PeriodicTemporalSet) args[0], ((Number) args[1]).intValue());</span>
          }
        }
<span class="nc" id="L1283">        throw new UnsupportedOperationException(&quot;apply(Object...) not implemented for TemporalOp &quot; + this);</span>
      }
    },
<span class="fc" id="L1286">    CREATE {</span>
      public Temporal apply(TimeUnit tu, int n) {
<span class="nc" id="L1288">        return tu.createTemporal(n);</span>
      }

      @Override
      public Temporal apply(Object... args) {
<span class="nc bnc" id="L1293" title="All 2 branches missed.">        if (args.length == 2) {</span>
<span class="nc bnc" id="L1294" title="All 4 branches missed.">          if (args[0] instanceof TimeUnit &amp;&amp; args[1] instanceof Number) {</span>
<span class="nc" id="L1295">            return apply((TimeUnit) args[0], ((Number) args[1]).intValue());</span>
          }
<span class="nc bnc" id="L1297" title="All 4 branches missed.">          else if (args[0] instanceof StandardTemporalType &amp;&amp; args[1] instanceof Number) {</span>
<span class="nc" id="L1298">            return ((StandardTemporalType) args[0]).createTemporal(((Number) args[1]).intValue());</span>
          }
<span class="nc bnc" id="L1300" title="All 4 branches missed.">          else if (args[0] instanceof Temporal &amp;&amp; args[1] instanceof Number) {</span>
<span class="nc" id="L1301">            return new OrdinalTime((Temporal) args[0], ((Number) args[1]).intValue());</span>
          }
        }
<span class="nc" id="L1304">        throw new UnsupportedOperationException(&quot;apply(Object...) not implemented for TemporalOp &quot; + this);</span>
      }
    },
<span class="fc" id="L1307">    ADD_MODIFIER {</span>
      public Temporal apply(Temporal t, String modifier) {
<span class="nc" id="L1309">        return t.addMod(modifier);</span>
      }

      @Override
      public Temporal apply(Object... args) {
<span class="nc bnc" id="L1314" title="All 2 branches missed.">        if (args.length == 2) {</span>
<span class="nc bnc" id="L1315" title="All 4 branches missed.">          if (args[0] instanceof Temporal &amp;&amp; args[1] instanceof String) {</span>
<span class="nc" id="L1316">            return apply((Temporal) args[0], (String) args[1]);</span>
          }
        }
<span class="nc" id="L1319">        throw new UnsupportedOperationException(&quot;apply(Object...) not implemented for TemporalOp &quot; + this);</span>
      }
    },
<span class="fc" id="L1322">    OFFSET_EXACT {</span>
      // There is exact offset (more granular parts than the duration are kept)
      @Override
      public Temporal apply(Temporal arg1, Temporal arg2, int flags) {
<span class="pc bpc" id="L1326" title="1 of 2 branches missed.">        if (arg1 == null) {</span>
<span class="nc" id="L1327">          return new RelativeTime(OFFSET_EXACT, arg2);</span>
        }
<span class="pc bpc" id="L1329" title="2 of 4 branches missed.">        if (arg1 instanceof Time &amp;&amp; arg2 instanceof Duration) {</span>
<span class="fc" id="L1330">          return ((Time) arg1).offset((Duration) arg2, flags);</span>
<span class="nc bnc" id="L1331" title="All 4 branches missed.">        } else if (arg1 instanceof Range &amp;&amp; arg2 instanceof Duration) {</span>
<span class="nc" id="L1332">          return ((Range) arg1).offset((Duration) arg2, flags);</span>
        } else {
<span class="nc" id="L1334">          throw new UnsupportedOperationException(&quot;OFFSET_EXACT not implemented for arg1=&quot; + arg1.getClass() + &quot;, arg2=&quot; + arg2.getClass());</span>
        }
      }
    };


    public Temporal apply(Temporal arg1, Temporal arg2, int flags) {
<span class="nc" id="L1341">      throw new UnsupportedOperationException(&quot;apply(Temporal, Temporal, int) not implemented for TemporalOp &quot; + this);</span>
    }

    public Temporal apply(Temporal arg1, Temporal arg2) {
<span class="fc" id="L1345">      return apply(arg1, arg2, 0);</span>
    }

    public Temporal apply(Temporal... args) {
<span class="nc bnc" id="L1349" title="All 2 branches missed.">      if (args.length == 2) {</span>
<span class="nc" id="L1350">        return apply(args[0], args[1]);</span>
      }
<span class="nc" id="L1352">      throw new UnsupportedOperationException(&quot;apply(Temporal...) not implemented for TemporalOp &quot; + this);</span>
    }

    public Temporal apply(Object... args) {
<span class="nc" id="L1356">      throw new UnsupportedOperationException(&quot;apply(Object...) not implemented for TemporalOp &quot; + this);</span>
    }
  }

  /**
   * Time represents a time point on some time scale.
   * It is the base class for representing various types of time points.
   * Typically, since most time scales have marks with certain granularity
   *   each time point can be represented as an interval.
   */
  public abstract static class Time extends Temporal implements FuzzyInterval.FuzzyComparable&lt;Time&gt;, HasInterval&lt;Time&gt; {

<span class="fc" id="L1368">    public Time() {</span>
<span class="fc" id="L1369">    }</span>

    public Time(Time t) {
<span class="fc" id="L1372">      super(t); /*this.hasTime = t.hasTime; */</span>
<span class="fc" id="L1373">    }</span>

    // Represents a point in time - there is typically some
    // uncertainty/imprecision in the exact time
    @Override
    public boolean isGrounded() {
<span class="nc" id="L1379">      return false;</span>
    }

    // A time is defined by a begin and end point, and a duration
    @Override
    public Time getTime() {
<span class="nc" id="L1385">      return this;</span>
    }

    // Default is a instant in time with same begin and end point
    // Every time should return a non-null range
    @Override
    public Range getRange(int flags, Duration granularity) {
<span class="nc" id="L1392">      return new Range(this, this);</span>
    }

    // Default duration is zero
    @Override
    public Duration getDuration() {
<span class="nc" id="L1398">      return DURATION_NONE;</span>
    }

    @Override
    public Duration getGranularity() {
<span class="fc" id="L1403">      StandardTemporalType tlt = getStandardTemporalType();</span>
<span class="fc bfc" id="L1404" title="All 2 branches covered.">      if (tlt != null) {</span>
<span class="fc" id="L1405">        return tlt.getGranularity();</span>
      }
<span class="fc" id="L1407">      Partial p = this.getJodaTimePartial();</span>
<span class="fc" id="L1408">      return Duration.getDuration(JodaTimeUtils.getJodaTimePeriod(p));</span>
    }

    @Override
    public Interval&lt;Time&gt; getInterval() {
<span class="nc" id="L1413">      Range r = getRange();</span>
<span class="nc bnc" id="L1414" title="All 2 branches missed.">      if (r != null) {</span>
<span class="nc" id="L1415">        return r.getInterval();</span>
      } else
<span class="nc" id="L1417">        return null;</span>
    }

    @Override
    public boolean isComparable(Time t) {
<span class="nc" id="L1422">      Instant i = this.getJodaTimeInstant();</span>
<span class="nc" id="L1423">      Instant i2 = t.getJodaTimeInstant();</span>
<span class="nc bnc" id="L1424" title="All 4 branches missed.">      return (i != null &amp;&amp; i2 != null);</span>
    }

    @Override
    public int compareTo(Time t) {
<span class="nc" id="L1429">      Instant i = this.getJodaTimeInstant();</span>
<span class="nc" id="L1430">      Instant i2 = t.getJodaTimeInstant();</span>
<span class="nc" id="L1431">      return i.compareTo(i2);</span>
    }

    public boolean hasTime() {
<span class="nc" id="L1435">      return false;</span>
    }

    @Override
    public TimexType getTimexType() {
<span class="nc bnc" id="L1440" title="All 2 branches missed.">      if (getStandardTemporalType() != null) {</span>
<span class="nc" id="L1441">        return getStandardTemporalType().getTimexType();</span>
      }
<span class="nc bnc" id="L1443" title="All 2 branches missed.">      return (hasTime()) ? TimexType.TIME : TimexType.DATE;</span>
    }

    // Time operations
    public boolean contains(Time t) {
      // Check if this time contains other time
<span class="nc" id="L1449">      return getRange().contains(t.getRange());</span>
    }

    // public boolean isBefore(Time t);
    // public boolean isAfter(Time t);
    // public boolean overlaps(Time t);
    public Time reduceGranularityTo(Duration d) {
<span class="nc" id="L1456">      return this;</span>
    }

    // Add duration to time
    public abstract Time add(Duration offset);

    public Time offset(Duration offset, int flags) {
<span class="fc" id="L1463">      Time res = add(offset);</span>
<span class="fc bfc" id="L1464" title="All 2 branches covered.">      if ((flags &amp; RELATIVE_OFFSET_INEXACT) != 0) {</span>
        // Mark as uncertain anything not as granular as the granularity of the offset
<span class="fc" id="L1466">        res.uncertaintyGranularity = offset.getGranularity();</span>
<span class="fc" id="L1467">        return res;</span>
      } else {
<span class="fc" id="L1469">        return res;</span>
      }
    }

    public Time subtract(Duration offset) {
<span class="fc" id="L1474">      return add(offset.multiplyBy(-1));</span>
    }

    // Return closest time
    public static Time closest(Time ref, Time... times) {
<span class="nc" id="L1479">      Time res = null;</span>
<span class="nc" id="L1480">      long refMillis = ref.getJodaTimeInstant().getMillis();</span>
<span class="nc" id="L1481">      long min = 0;</span>
<span class="nc bnc" id="L1482" title="All 2 branches missed.">      for (Time t:times) {</span>
<span class="nc" id="L1483">        long d = Math.abs(refMillis - t.getJodaTimeInstant().getMillis());</span>
<span class="nc bnc" id="L1484" title="All 4 branches missed.">        if (res == null || d &lt; min) {</span>
<span class="nc" id="L1485">          res = t;</span>
<span class="nc" id="L1486">          min = d;</span>
        }
      }
<span class="nc" id="L1489">      return res;</span>
    }

    // Get absolute difference between times
    public static Duration distance(Time t1, Time t2) {
<span class="nc bnc" id="L1494" title="All 2 branches missed.">      if (t1.compareTo(t2) &lt; 0) {</span>
<span class="nc" id="L1495">        return difference(t1,t2);</span>
      } else {
<span class="nc" id="L1497">        return difference(t2,t1);</span>
      }
    }

    // Get difference between times
    public static Duration difference(Time t1, Time t2) {
      // TODO: Difference does not work between days of the week
      // Get duration from this t1 to t2
<span class="pc bpc" id="L1505" title="2 of 4 branches missed.">      if (t1 == null || t2 == null)</span>
<span class="nc" id="L1506">        return null;</span>
<span class="fc" id="L1507">      Instant i1 = t1.getJodaTimeInstant();</span>
<span class="fc" id="L1508">      Instant i2 = t2.getJodaTimeInstant();</span>
<span class="pc bpc" id="L1509" title="1 of 4 branches missed.">      if (i1 == null || i2 == null)</span>
<span class="fc" id="L1510">        return null;</span>
<span class="fc" id="L1511">      Duration d = new DurationWithMillis(i2.getMillis() - i1.getMillis());</span>
<span class="fc" id="L1512">      Duration g1 = t1.getGranularity();</span>
<span class="fc" id="L1513">      Duration g2 = t2.getGranularity();</span>
<span class="fc" id="L1514">      Duration g = Duration.max(g1, g2);</span>
<span class="pc bpc" id="L1515" title="1 of 2 branches missed.">      if (g != null) {</span>
<span class="fc" id="L1516">        Period p = g.getJodaTimePeriod();</span>
<span class="fc" id="L1517">        p = p.normalizedStandard();</span>
<span class="fc" id="L1518">        Period p2 = JodaTimeUtils.discardMoreSpecificFields(d.getJodaTimePeriod(), p.getFieldType(p.size() - 1), i1.getChronology());</span>
<span class="fc" id="L1519">        return new DurationWithFields(p2);</span>
      } else {
<span class="nc" id="L1521">        return d;</span>
      }
    }

    public static CompositePartialTime makeComposite(PartialTime pt, Time t) {
<span class="fc" id="L1526">      CompositePartialTime cp = null;</span>
<span class="fc" id="L1527">      StandardTemporalType tlt = t.getStandardTemporalType();</span>
<span class="fc bfc" id="L1528" title="All 2 branches covered.">      if (tlt != null) {</span>
<span class="pc bpc" id="L1529" title="2 of 4 branches missed.">        switch (tlt) {</span>
        case TIME_OF_DAY:
<span class="fc" id="L1531">          cp = new CompositePartialTime(pt, null, null, t);</span>
<span class="fc" id="L1532">          break;</span>
        case PART_OF_YEAR:
        case QUARTER_OF_YEAR:
        case SEASON_OF_YEAR:
<span class="fc" id="L1536">          cp = new CompositePartialTime(pt, t, null, null);</span>
<span class="fc" id="L1537">          break;</span>
        case DAYS_OF_WEEK:
<span class="nc" id="L1539">          cp = new CompositePartialTime(pt, null, t, null);</span>
          break;
        }
      }
<span class="fc" id="L1543">      return cp;</span>
    }

    @Override
    public Temporal resolve(Time t, int flags) {
<span class="nc" id="L1548">      return this;</span>
    }

    @Override
    public Temporal intersect(Temporal t) {
<span class="nc bnc" id="L1553" title="All 2 branches missed.">      if (t == null)</span>
<span class="nc" id="L1554">        return this;</span>
<span class="nc bnc" id="L1555" title="All 4 branches missed.">      if (t == TIME_UNKNOWN || t == DURATION_UNKNOWN)</span>
<span class="nc" id="L1556">        return this;</span>
<span class="nc bnc" id="L1557" title="All 2 branches missed.">      if (t instanceof Time) {</span>
<span class="nc" id="L1558">        return intersect((Time) t);</span>
<span class="nc bnc" id="L1559" title="All 2 branches missed.">      } else if (t instanceof Range) {</span>
<span class="nc" id="L1560">        return t.intersect(this);</span>
<span class="nc bnc" id="L1561" title="All 2 branches missed.">      } else if (t instanceof Duration) {</span>
<span class="nc" id="L1562">        return new RelativeTime(this, TemporalOp.INTERSECT, t);</span>
      }
<span class="nc" id="L1564">      return null;</span>
    }

    protected Time intersect(Time t) {
<span class="fc" id="L1568">      return null; //new RelativeTime(this, TemporalOp.INTERSECT, t);</span>
    }

    protected static Time intersect(Time t1, Time t2) {
<span class="nc bnc" id="L1572" title="All 2 branches missed.">      if (t1 == null)</span>
<span class="nc" id="L1573">        return t2;</span>
<span class="nc bnc" id="L1574" title="All 2 branches missed.">      if (t2 == null)</span>
<span class="nc" id="L1575">        return t1;</span>
<span class="nc" id="L1576">      return t1.intersect(t2);</span>
    }

    public static Time min(Time t1, Time t2) {
<span class="nc bnc" id="L1580" title="All 2 branches missed.">      if (t2 == null)</span>
<span class="nc" id="L1581">        return t1;</span>
<span class="nc bnc" id="L1582" title="All 2 branches missed.">      if (t1 == null)</span>
<span class="nc" id="L1583">        return t2;</span>
<span class="nc bnc" id="L1584" title="All 2 branches missed.">      if (t1.isComparable(t2)) {</span>
<span class="nc" id="L1585">        int c = t1.compareTo(t2);</span>
<span class="nc bnc" id="L1586" title="All 2 branches missed.">        return (c &lt; 0) ? t1 : t2;</span>
      }
<span class="nc" id="L1588">      return t1;</span>
    }

    public static Time max(Time t1, Time t2) {
<span class="nc bnc" id="L1592" title="All 2 branches missed.">      if (t1 == null)</span>
<span class="nc" id="L1593">        return t2;</span>
<span class="nc bnc" id="L1594" title="All 2 branches missed.">      if (t2 == null)</span>
<span class="nc" id="L1595">        return t1;</span>
<span class="nc bnc" id="L1596" title="All 2 branches missed.">      if (t1.isComparable(t2)) {</span>
<span class="nc" id="L1597">        int c = t1.compareTo(t2);</span>
<span class="nc bnc" id="L1598" title="All 2 branches missed.">        return (c &gt;= 0) ? t1 : t2;</span>
      }
<span class="nc" id="L1600">      return t2;</span>
    }

    // Conversions to joda time
    public Instant getJodaTimeInstant() {
<span class="fc" id="L1605">      return null;</span>
    }

    public Partial getJodaTimePartial() {
<span class="nc" id="L1609">      return null;</span>
    }

    private static final long serialVersionUID = 1;
  }

  /** Reference time (some kind of reference time). */
  public static class RefTime extends Time {
    String label;

<span class="fc" id="L1619">    public RefTime(String label) {</span>
<span class="fc" id="L1620">      this.label = label;</span>
<span class="fc" id="L1621">    }</span>

<span class="fc" id="L1623">    public RefTime(StandardTemporalType timeType, String timeLabel, String label) {</span>
<span class="fc" id="L1624">      this.standardTemporalType = timeType;</span>
<span class="fc" id="L1625">      this.timeLabel = timeLabel;</span>
<span class="fc" id="L1626">      this.label = label;</span>
<span class="fc" id="L1627">    }</span>

    @Override
    public boolean isRef() {
<span class="nc" id="L1631">      return true;</span>
    }

    @Override
    public String toFormattedString(int flags) {
<span class="nc bnc" id="L1636" title="All 2 branches missed.">      if (getTimeLabel() != null) {</span>
<span class="nc" id="L1637">        return getTimeLabel();</span>
      }
<span class="nc bnc" id="L1639" title="All 2 branches missed.">      if ((flags &amp; FORMAT_ISO) != 0) {</span>
<span class="nc" id="L1640">        return null;</span>
      } // TODO: is there iso standard?
<span class="nc" id="L1642">      return label;</span>
    }

    @Override
    public Time add(Duration offset) {
<span class="nc" id="L1647">      return new RelativeTime(this, TemporalOp.OFFSET_EXACT, offset);</span>
    }

    @Override
    public Time offset(Duration offset, int offsetFlags) {
<span class="nc bnc" id="L1652" title="All 2 branches missed.">      if ((offsetFlags &amp; RELATIVE_OFFSET_INEXACT) != 0) {</span>
<span class="nc" id="L1653">        return new RelativeTime(this, TemporalOp.OFFSET, offset);</span>
      } else {
<span class="nc" id="L1655">        return new RelativeTime(this, TemporalOp.OFFSET_EXACT, offset);</span>
      }
    }

    @Override
    public Time resolve(Time refTime, int flags) {
<span class="nc bnc" id="L1661" title="All 2 branches missed.">      if (this == TIME_REF) {</span>
<span class="nc" id="L1662">        return refTime;</span>
<span class="nc bnc" id="L1663" title="All 4 branches missed.">      } else if (this == TIME_NOW &amp;&amp; (flags &amp; RESOLVE_NOW) != 0) {</span>
<span class="nc" id="L1664">        return refTime;</span>
      } else {
<span class="nc" id="L1666">        return this;</span>
      }
    }

    private static final long serialVersionUID = 1;
  }

  /**
   * Simple time (vague time that we don't really know what to do with)
   **/
  public static class SimpleTime extends Time {
    String label;

<span class="fc" id="L1679">    public SimpleTime(String label) {</span>
<span class="fc" id="L1680">      this.label = label;</span>
<span class="fc" id="L1681">    }</span>

    @Override
    public String toFormattedString(int flags) {
<span class="nc bnc" id="L1685" title="All 2 branches missed.">      if (getTimeLabel() != null) {</span>
<span class="nc" id="L1686">        return getTimeLabel();</span>
      }
<span class="nc bnc" id="L1688" title="All 2 branches missed.">      if ((flags &amp; FORMAT_ISO) != 0) {</span>
<span class="nc" id="L1689">        return null;</span>
      } // TODO: is there iso standard?
<span class="nc" id="L1691">      return label;</span>
    }

    @Override
    public Time add(Duration offset) {
<span class="nc" id="L1696">      Time t = new RelativeTime(this, TemporalOp.OFFSET_EXACT, offset);</span>
      // t.approx = this.approx;
      // t.mod = this.mod;
<span class="nc" id="L1699">      return t;</span>
    }

    private static final long serialVersionUID = 1;
  }

  // Composite time - like PartialTime but with more, approximate fields
  public static class CompositePartialTime extends PartialTime {
    // Summer weekend morning in June
    Time tod; // Time of day
    Time dow; // Day of week
    Time poy; // Part of year

    // Duration duration; // Underspecified time (like day in June)

    public CompositePartialTime(PartialTime t, Time poy, Time dow, Time tod) {
<span class="fc" id="L1715">      super(t);</span>
<span class="fc" id="L1716">      this.poy = poy;</span>
<span class="fc" id="L1717">      this.dow = dow;</span>
<span class="fc" id="L1718">      this.tod = tod;</span>
<span class="fc" id="L1719">    }</span>

    public CompositePartialTime(PartialTime t, Partial p, Time poy, Time dow, Time tod) {
<span class="fc" id="L1722">      this(t, poy, dow, tod);</span>
<span class="fc" id="L1723">      this.base = p;</span>
<span class="fc" id="L1724">    }</span>

    @Override
    public Instant getJodaTimeInstant() {
<span class="nc" id="L1728">      Partial p = base;</span>
<span class="nc bnc" id="L1729" title="All 2 branches missed.">      if (tod != null) {</span>
<span class="nc" id="L1730">        Partial p2 = tod.getJodaTimePartial();</span>
<span class="nc bnc" id="L1731" title="All 4 branches missed.">        if (p2 != null &amp;&amp; JodaTimeUtils.isCompatible(p, p2)) {</span>
<span class="nc" id="L1732">          p = JodaTimeUtils.combine(p, p2);</span>
        }
      }
<span class="nc bnc" id="L1735" title="All 2 branches missed.">      if (dow != null) {</span>
<span class="nc" id="L1736">        Partial p2 = dow.getJodaTimePartial();</span>
<span class="nc bnc" id="L1737" title="All 4 branches missed.">        if (p2 != null &amp;&amp; JodaTimeUtils.isCompatible(p, p2)) {</span>
<span class="nc" id="L1738">          p = JodaTimeUtils.combine(p, p2);</span>
        }
      }
<span class="nc bnc" id="L1741" title="All 2 branches missed.">      if (poy != null) {</span>
<span class="nc" id="L1742">        Partial p2 = poy.getJodaTimePartial();</span>
<span class="nc bnc" id="L1743" title="All 4 branches missed.">        if (p2 != null &amp;&amp; JodaTimeUtils.isCompatible(p, p2)) {</span>
<span class="nc" id="L1744">          p = JodaTimeUtils.combine(p, p2);</span>
        }
      }
<span class="nc" id="L1747">      return JodaTimeUtils.getInstant(p);</span>
    }

    @Override
    public Duration getDuration() {
/*      TimeLabel tl = getTimeLabel();
      if (tl != null) {
        return tl.getDuration();
      } */
<span class="fc" id="L1756">      StandardTemporalType tlt = getStandardTemporalType();</span>
<span class="pc bpc" id="L1757" title="1 of 2 branches missed.">      if (tlt != null) {</span>
<span class="nc" id="L1758">        return tlt.getDuration();</span>
      }

<span class="pc bpc" id="L1761" title="1 of 2 branches missed.">      Duration bd = (base != null) ? Duration.getDuration(JodaTimeUtils.getJodaTimePeriod(base)) : null;</span>
<span class="fc bfc" id="L1762" title="All 2 branches covered.">      if (tod != null) {</span>
<span class="fc" id="L1763">        Duration d = tod.getDuration();</span>
<span class="pc bpc" id="L1764" title="1 of 2 branches missed.">        return (bd.compareTo(d) &lt; 0) ? bd : d;</span>
      }
<span class="pc bpc" id="L1766" title="1 of 2 branches missed.">      if (dow != null) {</span>
<span class="nc" id="L1767">        Duration d = dow.getDuration();</span>
<span class="nc bnc" id="L1768" title="All 2 branches missed.">        return (bd.compareTo(d) &lt; 0) ? bd : d;</span>
      }
<span class="pc bpc" id="L1770" title="1 of 2 branches missed.">      if (poy != null) {</span>
<span class="fc" id="L1771">        Duration d = poy.getDuration();</span>
<span class="pc bpc" id="L1772" title="1 of 2 branches missed.">        return (bd.compareTo(d) &lt; 0) ? bd : d;</span>
      }
<span class="nc" id="L1774">      return bd;</span>
    }

    @Override
    public Duration getPeriod() {
  /*    TimeLabel tl = getTimeLabel();
      if (tl != null) {
        return tl.getPeriod();
      } */
<span class="nc" id="L1783">      StandardTemporalType tlt = getStandardTemporalType();</span>
<span class="nc bnc" id="L1784" title="All 2 branches missed.">      if (tlt != null) {</span>
<span class="nc" id="L1785">        return tlt.getPeriod();</span>
      }

<span class="nc" id="L1788">      Duration bd = null;</span>
<span class="nc bnc" id="L1789" title="All 2 branches missed.">      if (base != null) {</span>
<span class="nc" id="L1790">        DateTimeFieldType mostGeneral = JodaTimeUtils.getMostGeneral(base);</span>
<span class="nc" id="L1791">        DurationFieldType df = mostGeneral.getRangeDurationType();</span>
<span class="nc bnc" id="L1792" title="All 2 branches missed.">        if (df == null) {</span>
<span class="nc" id="L1793">          df = mostGeneral.getDurationType();</span>
        }
<span class="nc bnc" id="L1795" title="All 2 branches missed.">        if (df != null) {</span>
<span class="nc" id="L1796">          bd = new DurationWithFields(new Period().withField(df, 1));</span>
        }
      }

<span class="nc bnc" id="L1800" title="All 2 branches missed.">      if (poy != null) {</span>
<span class="nc" id="L1801">        Duration d = poy.getPeriod();</span>
<span class="nc bnc" id="L1802" title="All 2 branches missed.">        return (bd.compareTo(d) &gt; 0) ? bd : d;</span>
      }
<span class="nc bnc" id="L1804" title="All 2 branches missed.">      if (dow != null) {</span>
<span class="nc" id="L1805">        Duration d = dow.getPeriod();</span>
<span class="nc bnc" id="L1806" title="All 2 branches missed.">        return (bd.compareTo(d) &gt; 0) ? bd : d;</span>
      }
<span class="nc bnc" id="L1808" title="All 2 branches missed.">      if (tod != null) {</span>
<span class="nc" id="L1809">        Duration d = tod.getPeriod();</span>
<span class="nc bnc" id="L1810" title="All 2 branches missed.">        return (bd.compareTo(d) &gt; 0) ? bd : d;</span>
      }
<span class="nc" id="L1812">      return bd;</span>
    }

    private static Range getIntersectedRange(CompositePartialTime cpt, Range r, Duration d) {
<span class="fc" id="L1816">      Time beginTime = r.beginTime();</span>
<span class="fc" id="L1817">      Time endTime = r.endTime();</span>
<span class="pc bpc" id="L1818" title="1 of 4 branches missed.">      if (beginTime != TIME_UNKNOWN &amp;&amp; endTime != TIME_UNKNOWN) {</span>
<span class="fc" id="L1819">        Time t1 = cpt.intersect(r.beginTime());</span>
<span class="pc bpc" id="L1820" title="1 of 2 branches missed.">        if (t1 instanceof PartialTime) {</span>
<span class="fc" id="L1821">          ((PartialTime) t1).withStandardFields();</span>
        }
<span class="fc" id="L1823">        Time t2 = cpt.intersect(r.endTime());</span>
<span class="fc bfc" id="L1824" title="All 2 branches covered.">        if (t2 instanceof PartialTime) {</span>
<span class="fc" id="L1825">          ((PartialTime) t2).withStandardFields();</span>
        }
<span class="fc" id="L1827">        return new Range(t1, t2, d);</span>
<span class="pc bpc" id="L1828" title="2 of 4 branches missed.">      } else if (beginTime != TIME_UNKNOWN &amp;&amp; endTime == TIME_UNKNOWN) {</span>
<span class="fc" id="L1829">        Time t1 = cpt.intersect(r.beginTime());</span>
<span class="pc bpc" id="L1830" title="1 of 2 branches missed.">        if (t1 instanceof PartialTime) {</span>
<span class="fc" id="L1831">          ((PartialTime) t1).withStandardFields();</span>
        }
<span class="fc" id="L1833">        Time t2 = t1.add(d);</span>
<span class="pc bpc" id="L1834" title="1 of 2 branches missed.">        if (t2 instanceof PartialTime) {</span>
<span class="fc" id="L1835">          ((PartialTime) t2).withStandardFields();</span>
        }
<span class="fc" id="L1837">        return new Range(t1, t2, d);</span>
      } else {
<span class="nc" id="L1839">        throw new RuntimeException(&quot;Unsupported range: &quot; + r);</span>
      }
    }

    @Override
    public Range getRange(int flags, Duration granularity) {
<span class="fc" id="L1845">      Duration d = getDuration();</span>
<span class="fc bfc" id="L1846" title="All 2 branches covered.">      if (tod != null) {</span>
<span class="fc" id="L1847">        Range r = tod.getRange(flags, granularity);</span>
<span class="pc bpc" id="L1848" title="1 of 2 branches missed.">        if (r != null) {</span>
<span class="fc" id="L1849">          CompositePartialTime cpt = new CompositePartialTime(this, poy, dow, null);</span>
<span class="fc" id="L1850">          return getIntersectedRange(cpt, r, d);</span>
        } else {
<span class="nc" id="L1852">          return super.getRange(flags, granularity);</span>
        }
      }
<span class="pc bpc" id="L1855" title="1 of 2 branches missed.">      if (dow != null) {</span>
<span class="nc" id="L1856">        Range r = dow.getRange(flags, granularity);</span>
<span class="nc bnc" id="L1857" title="All 2 branches missed.">        if (r != null) {</span>
<span class="nc" id="L1858">          CompositePartialTime cpt = new CompositePartialTime(this, poy, dow, null);</span>
<span class="nc" id="L1859">          return getIntersectedRange(cpt, r, d);</span>
        } else {
<span class="nc" id="L1861">          return super.getRange(flags, granularity);</span>
        }
      }
<span class="pc bpc" id="L1864" title="1 of 2 branches missed.">      if (poy != null) {</span>
<span class="fc" id="L1865">        Range r = poy.getRange(flags, granularity);</span>
<span class="pc bpc" id="L1866" title="1 of 2 branches missed.">        if (r != null) {</span>
<span class="fc" id="L1867">          CompositePartialTime cpt = new CompositePartialTime(this, poy, null, null);</span>
<span class="fc" id="L1868">          return getIntersectedRange(cpt, r, d);</span>
        } else {
<span class="nc" id="L1870">          return super.getRange(flags, granularity);</span>
        }
      }
<span class="nc" id="L1873">      return super.getRange(flags, granularity);</span>
    }

    @Override
    public Time intersect(Time t) {
<span class="pc bpc" id="L1878" title="2 of 4 branches missed.">      if (t == null || t == TIME_UNKNOWN)</span>
<span class="nc" id="L1879">        return this;</span>
<span class="pc bpc" id="L1880" title="1 of 2 branches missed.">      if (base == null)</span>
<span class="nc" id="L1881">        return t;</span>
<span class="fc bfc" id="L1882" title="All 2 branches covered.">      if (t instanceof PartialTime) {</span>
<span class="fc" id="L1883">        Pair&lt;PartialTime,PartialTime&gt; compatible = getCompatible(this, (PartialTime) t);</span>
<span class="pc bpc" id="L1884" title="1 of 2 branches missed.">        if (compatible == null) {</span>
<span class="nc" id="L1885">          return null;</span>
        }
<span class="fc" id="L1887">        Partial p = JodaTimeUtils.combine(compatible.first.base, compatible.second.base);</span>
<span class="pc bpc" id="L1888" title="1 of 2 branches missed.">        if (t instanceof CompositePartialTime) {</span>
<span class="nc" id="L1889">          CompositePartialTime cpt = (CompositePartialTime) t;</span>
<span class="nc" id="L1890">          Time ntod = Time.intersect(tod, cpt.tod);</span>
<span class="nc" id="L1891">          Time ndow = Time.intersect(dow, cpt.dow);</span>
<span class="nc" id="L1892">          Time npoy = Time.intersect(poy, cpt.poy);</span>
<span class="nc bnc" id="L1893" title="All 6 branches missed.">          if (ntod == null &amp;&amp; (tod != null || cpt.tod != null))</span>
<span class="nc" id="L1894">            return null;</span>
<span class="nc bnc" id="L1895" title="All 6 branches missed.">          if (ndow == null &amp;&amp; (dow != null || cpt.dow != null))</span>
<span class="nc" id="L1896">            return null;</span>
<span class="nc bnc" id="L1897" title="All 6 branches missed.">          if (npoy == null &amp;&amp; (poy != null || cpt.poy != null))</span>
<span class="nc" id="L1898">            return null;</span>
<span class="nc" id="L1899">          return new CompositePartialTime(this, p, npoy, ndow, ntod);</span>
        } else {
<span class="fc" id="L1901">          return new CompositePartialTime(this, p, poy, dow, tod);</span>
        }
      } else {
<span class="fc" id="L1904">        return super.intersect(t);</span>
      }
    }

    @Override
    protected PartialTime addSupported(Period p, int scalar) {
<span class="fc" id="L1910">      return new CompositePartialTime(this, base.withPeriodAdded(p, 1), poy, dow, tod);</span>
    }

    @Override
    protected PartialTime addUnsupported(Period p, int scalar) {
<span class="nc" id="L1915">      return new CompositePartialTime(this, JodaTimeUtils.addForce(base, p, scalar), poy, dow, tod);</span>
    }

    @Override
    public PartialTime reduceGranularityTo(Duration granularity) {
<span class="nc" id="L1920">      Partial p = JodaTimeUtils.discardMoreSpecificFields( base,</span>
<span class="nc" id="L1921">        JodaTimeUtils.getMostSpecific(granularity.getJodaTimePeriod()) );</span>
<span class="nc" id="L1922">      return new CompositePartialTime(this, p,</span>
<span class="nc" id="L1923">        poy.reduceGranularityTo(granularity),</span>
<span class="nc" id="L1924">        dow.reduceGranularityTo(granularity),</span>
<span class="nc" id="L1925">        tod.reduceGranularityTo(granularity));</span>
    }

    @Override
    public Time resolve(Time ref, int flags) {
<span class="pc bpc" id="L1930" title="3 of 6 branches missed.">      if (ref == null || ref == TIME_UNKNOWN || ref == TIME_REF) {</span>
<span class="nc" id="L1931">        return this;</span>
      }
<span class="pc bpc" id="L1933" title="1 of 2 branches missed.">      if (this == TIME_REF) {</span>
<span class="nc" id="L1934">        return ref;</span>
      }
<span class="pc bpc" id="L1936" title="1 of 2 branches missed.">      if (this == TIME_UNKNOWN) {</span>
<span class="nc" id="L1937">        return this;</span>
      }
<span class="fc" id="L1939">      Partial partialRef = ref.getJodaTimePartial();</span>
<span class="pc bpc" id="L1940" title="1 of 2 branches missed.">      if (partialRef == null) {</span>
<span class="nc" id="L1941">        throw new UnsupportedOperationException(&quot;Cannot resolve if reftime is of class: &quot; + ref.getClass());</span>
      }
<span class="fc" id="L1943">      DateTimeFieldType mgf = null;</span>
<span class="fc bfc" id="L1944" title="All 2 branches covered.">      if (poy != null)</span>
<span class="fc" id="L1945">        mgf = JodaTimeUtils.QuarterOfYear;</span>
<span class="pc bpc" id="L1946" title="1 of 2 branches missed.">      else if (dow != null)</span>
<span class="nc" id="L1947">        mgf = DateTimeFieldType.dayOfWeek();</span>
<span class="pc bpc" id="L1948" title="1 of 2 branches missed.">      else if (tod != null)</span>
<span class="fc" id="L1949">        mgf = DateTimeFieldType.halfdayOfDay();</span>
<span class="pc bpc" id="L1950" title="1 of 2 branches missed.">      Partial p = (base != null) ? JodaTimeUtils.combineMoreGeneralFields(base, partialRef, mgf) : partialRef;</span>
<span class="pc bpc" id="L1951" title="1 of 2 branches missed.">      if (p.isSupported(DateTimeFieldType.dayOfWeek())) {</span>
<span class="nc" id="L1952">        p = JodaTimeUtils.resolveDowToDay(p, partialRef);</span>
<span class="pc bpc" id="L1953" title="1 of 2 branches missed.">      } else if (dow != null) {</span>
<span class="nc" id="L1954">        p = JodaTimeUtils.resolveWeek(p, partialRef);</span>
      }
<span class="pc bpc" id="L1956" title="1 of 2 branches missed.">      if (p == base) {</span>
<span class="nc" id="L1957">        return this;</span>
      } else {
<span class="fc" id="L1959">        return new CompositePartialTime(this, p, poy, dow, tod);</span>
      }
    }

    @Override
    public DateTimeFormatter getFormatter(int flags) {
<span class="fc" id="L1965">      DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();</span>
<span class="fc" id="L1966">      boolean hasDate = appendDateFormats(builder, flags);</span>
<span class="fc bfc" id="L1967" title="All 2 branches covered.">      if (poy != null) {</span>
<span class="pc bpc" id="L1968" title="1 of 2 branches missed.">        if (!JodaTimeUtils.hasField(base, DateTimeFieldType.monthOfYear())) {</span>
          // Assume poy is compatible with whatever was built and
          // poy.toISOString() does the correct thing
<span class="nc" id="L1971">          builder.appendLiteral(&quot;-&quot;);</span>
<span class="nc" id="L1972">          builder.appendLiteral(poy.toISOString());</span>
<span class="nc" id="L1973">          hasDate = true;</span>
        }
      }
<span class="pc bpc" id="L1976" title="1 of 2 branches missed.">      if (dow != null) {</span>
<span class="nc bnc" id="L1977" title="All 4 branches missed.">        if (!JodaTimeUtils.hasField(base, DateTimeFieldType.monthOfYear()) &amp;&amp; !JodaTimeUtils.hasField(base, DateTimeFieldType.dayOfWeek())) {</span>
<span class="nc" id="L1978">          builder.appendLiteral(&quot;-&quot;);</span>
<span class="nc" id="L1979">          builder.appendLiteral(dow.toISOString());</span>
<span class="nc" id="L1980">          hasDate = true;</span>
        }
      }
<span class="fc bfc" id="L1983" title="All 2 branches covered.">      if (hasTime()) {</span>
<span class="pc bpc" id="L1984" title="1 of 2 branches missed.">        if (!hasDate) {</span>
<span class="nc" id="L1985">          builder.clear();</span>
        }
<span class="fc" id="L1987">        appendTimeFormats(builder, flags);</span>
<span class="pc bpc" id="L1988" title="1 of 2 branches missed.">      } else if (tod != null) {</span>
<span class="nc bnc" id="L1989" title="All 2 branches missed.">        if (!hasDate) {</span>
<span class="nc" id="L1990">          builder.clear();</span>
        }
        // Assume tod is compatible with whatever was built and
        // tod.toISOString() does the correct thing
<span class="nc" id="L1994">        builder.appendLiteral(&quot;T&quot;);</span>
<span class="nc" id="L1995">        builder.appendLiteral(tod.toISOString());</span>
      }
<span class="fc" id="L1997">      return builder.toFormatter();</span>
    }

    @Override
    public TimexType getTimexType() {
<span class="nc bnc" id="L2002" title="All 2 branches missed.">      if (tod != null) return TimexType.TIME;</span>
<span class="nc" id="L2003">      return super.getTimexType();</span>
    }

    private static final long serialVersionUID = 1;
  }

  /** The nth temporal.
   *  Example: The tenth week (of something, don't know yet)
   * The second friday
   */
  public static class OrdinalTime extends Time {
    Temporal base;
    int n;

<span class="nc" id="L2017">    public OrdinalTime(Temporal base, int n) {</span>
<span class="nc" id="L2018">      this.base = base;</span>
<span class="nc" id="L2019">      this.n = n;</span>
<span class="nc" id="L2020">    }</span>

<span class="nc" id="L2022">    public OrdinalTime(Temporal base, long n) {</span>
<span class="nc" id="L2023">      this.base = base;</span>
<span class="nc" id="L2024">      this.n = (int) n;</span>
<span class="nc" id="L2025">    }</span>

    @Override
    public Time add(Duration offset) {
<span class="nc" id="L2029">      return new RelativeTime(this, TemporalOp.OFFSET_EXACT, offset);</span>
    }

    @Override
    public String toFormattedString(int flags) {
<span class="nc bnc" id="L2034" title="All 2 branches missed.">      if (getTimeLabel() != null) {</span>
<span class="nc" id="L2035">        return getTimeLabel();</span>
      }
<span class="nc bnc" id="L2037" title="All 2 branches missed.">      if ((flags &amp; FORMAT_ISO) != 0) {</span>
<span class="nc" id="L2038">        return null;</span>
      } // TODO: is there iso standard?
<span class="nc bnc" id="L2040" title="All 2 branches missed.">      if ((flags &amp; FORMAT_TIMEX3_VALUE) != 0) {</span>
<span class="nc" id="L2041">        return null;</span>
      } // TODO: is there timex3 standard?
<span class="nc bnc" id="L2043" title="All 2 branches missed.">      if (base != null) {</span>
<span class="nc" id="L2044">        String str = base.toFormattedString(flags);</span>
<span class="nc bnc" id="L2045" title="All 2 branches missed.">        if (str != null) {</span>
<span class="nc" id="L2046">          return str + &quot;-#&quot; + n;</span>
        }
      }
<span class="nc" id="L2049">      return null;</span>
    }

    @Override
    public Time intersect(Time t) {
<span class="nc bnc" id="L2054" title="All 4 branches missed.">      if (base instanceof PartialTime &amp;&amp; t instanceof PartialTime) {</span>
<span class="nc" id="L2055">        return new OrdinalTime(base.intersect(t), n);</span>
      } else {
<span class="nc" id="L2057">        return new RelativeTime(t, TemporalOp.INTERSECT, this);</span>
      }
    }

    @Override
    public Temporal resolve(Time t, int flags) {
<span class="nc bnc" id="L2063" title="All 2 branches missed.">      if (t == null) return this; // No resolving to be done?</span>
<span class="nc bnc" id="L2064" title="All 2 branches missed.">      if (base instanceof PartialTime) {</span>
<span class="nc" id="L2065">        PartialTime pt = (PartialTime) base.resolve(t,flags);</span>
<span class="nc" id="L2066">        List&lt;Temporal&gt; list = pt.toList();</span>
<span class="nc bnc" id="L2067" title="All 4 branches missed.">        if (list != null &amp;&amp; list.size() &gt;= n) {</span>
<span class="nc" id="L2068">          return list.get(n-1);</span>
        }
<span class="nc bnc" id="L2070" title="All 2 branches missed.">      } else if (base instanceof Duration) {</span>
<span class="nc" id="L2071">        Duration d = ((Duration) base).multiplyBy(n-1);</span>
<span class="nc" id="L2072">        Time temp = t.getRange().begin();</span>
<span class="nc" id="L2073">        return temp.offset(d,0).reduceGranularityTo(d.getDuration());</span>
      }
<span class="nc" id="L2075">      return this;</span>
    }

    private static final long serialVersionUID = 1;

  } // end static class OrdinalTim


  // Time with a range (most times have a range...)
  public static class TimeWithRange extends Time {
    Range range; // guess at range

    public TimeWithRange(TimeWithRange t, Range range) {
<span class="fc" id="L2088">      super(t);</span>
<span class="fc" id="L2089">      this.range = range;</span>
<span class="fc" id="L2090">    }</span>

<span class="fc" id="L2092">    public TimeWithRange(Range range) {</span>
<span class="fc" id="L2093">      this.range = range;</span>
<span class="fc" id="L2094">    }</span>

    @Override
    public TimeWithRange setTimeZone(DateTimeZone tz) {
<span class="nc" id="L2098">      return new TimeWithRange(this, (Range) Temporal.setTimeZone(range, tz));</span>
    }

    @Override
    public Duration getDuration() {
<span class="nc bnc" id="L2103" title="All 2 branches missed.">      if (range != null)</span>
<span class="nc" id="L2104">        return range.getDuration();</span>
      else
<span class="nc" id="L2106">        return null;</span>
    }

    @Override
    public Range getRange(int flags, Duration granularity) {
<span class="pc bpc" id="L2111" title="1 of 2 branches missed.">      if (range != null) {</span>
<span class="fc" id="L2112">        return range.getRange(flags, granularity);</span>
      } else {
<span class="nc" id="L2114">        return null;</span>
      }
    }

    @Override
    public Time add(Duration offset) {
      // TODO: Check logic
//      if (getTimeLabel() != null) {
<span class="pc bpc" id="L2122" title="1 of 2 branches missed.">        if (getStandardTemporalType() != null) {</span>
        // Time has some meaning, keep as is
<span class="nc" id="L2124">        return new RelativeTime(this, TemporalOp.OFFSET_EXACT, offset);</span>
      } else
<span class="fc" id="L2126">        return new TimeWithRange(this, range.offset(offset,0));</span>
    }

    @Override
    public Time intersect(Time t) {
<span class="nc bnc" id="L2131" title="All 4 branches missed.">      if (t == null || t == TIME_UNKNOWN)</span>
<span class="nc" id="L2132">        return this;</span>
<span class="nc bnc" id="L2133" title="All 2 branches missed.">      if (t instanceof CompositePartialTime) {</span>
<span class="nc" id="L2134">        return t.intersect(this);</span>
<span class="nc bnc" id="L2135" title="All 2 branches missed.">      } else if (t instanceof PartialTime) {</span>
<span class="nc" id="L2136">        return t.intersect(this);</span>
<span class="nc bnc" id="L2137" title="All 2 branches missed.">      } else if (t instanceof GroundedTime) {</span>
<span class="nc" id="L2138">        return t.intersect(this);</span>
      } else {
<span class="nc" id="L2140">        return new TimeWithRange((Range) range.intersect(t));</span>
      }
    }

    @Override
    public Time resolve(Time refTime, int flags) {
<span class="nc" id="L2146">      CompositePartialTime cpt = makeComposite(new PartialTime(new Partial()), this);</span>
<span class="nc bnc" id="L2147" title="All 2 branches missed.">      if (cpt != null) {</span>
<span class="nc" id="L2148">        return cpt.resolve(refTime, flags);</span>
      }
<span class="nc" id="L2150">      Range groundedRange = null;</span>
<span class="nc bnc" id="L2151" title="All 2 branches missed.">      if (range != null) {</span>
<span class="nc" id="L2152">        groundedRange = range.resolve(refTime, flags).getRange();</span>
      }
<span class="nc" id="L2154">      return createTemporal(standardTemporalType, timeLabel, new TimeWithRange(this, groundedRange));</span>
      //return new TimeWithRange(this, groundedRange);
    }

    @Override
    public String toFormattedString(int flags) {
<span class="nc bnc" id="L2160" title="All 2 branches missed.">      if (getTimeLabel() != null) {</span>
<span class="nc" id="L2161">        return getTimeLabel();</span>
      }
<span class="nc bnc" id="L2163" title="All 2 branches missed.">      if ((flags &amp; FORMAT_TIMEX3_VALUE) != 0) {</span>
<span class="nc" id="L2164">        flags |= FORMAT_ISO;</span>
      }
<span class="nc" id="L2166">      return range.toFormattedString(flags);</span>
    }

    private static final long serialVersionUID = 1;
  }

  /**
   * Inexact time, not sure when this is, but have some guesses.
   */
  public static class InexactTime extends Time {
    Time base; // best guess
    Duration duration; // how long the time lasts
    Range range; // guess at range in which the time occurs

<span class="fc" id="L2180">    public InexactTime(Partial partial) {</span>
<span class="fc" id="L2181">      this.base = new PartialTime(partial);</span>
<span class="fc" id="L2182">      this.range = base.getRange();</span>
<span class="fc" id="L2183">      this.approx = true;</span>
<span class="fc" id="L2184">    }</span>

<span class="fc" id="L2186">    public InexactTime(Time base, Duration duration, Range range) {</span>
<span class="fc" id="L2187">      this.base = base;</span>
<span class="fc" id="L2188">      this.duration = duration;</span>
<span class="fc" id="L2189">      this.range = range;</span>
<span class="fc" id="L2190">      this.approx = true;</span>
<span class="fc" id="L2191">    }</span>

<span class="fc" id="L2193">    public InexactTime(Time base, Range range) {</span>
<span class="fc" id="L2194">      this.base = base;</span>
<span class="fc" id="L2195">      this.range = range;</span>
<span class="fc" id="L2196">      this.approx = true;</span>
<span class="fc" id="L2197">    }</span>

    public InexactTime(InexactTime t, Time base, Duration duration, Range range) {
<span class="nc" id="L2200">      super(t);</span>
<span class="nc" id="L2201">      this.base = base;</span>
<span class="nc" id="L2202">      this.duration = duration;</span>
<span class="nc" id="L2203">      this.range = range;</span>
<span class="nc" id="L2204">      this.approx = true;</span>
<span class="nc" id="L2205">    }</span>

<span class="fc" id="L2207">    public InexactTime(Range range) {</span>
<span class="fc" id="L2208">      this.base = range.mid();</span>
<span class="fc" id="L2209">      this.range = range;</span>
<span class="fc" id="L2210">      this.approx = true;</span>
<span class="fc" id="L2211">    }</span>

    @Override
    public int compareTo(Time t) {
<span class="nc bnc" id="L2215" title="All 2 branches missed.">      if (this.base != null) return (this.base.compareTo(t));</span>
<span class="nc bnc" id="L2216" title="All 2 branches missed.">      if (this.range != null) {</span>
<span class="nc bnc" id="L2217" title="All 4 branches missed.">        if (this.range.begin() != null &amp;&amp; this.range.begin().compareTo(t) &gt; 0) return 1;</span>
<span class="nc bnc" id="L2218" title="All 4 branches missed.">        else if (this.range.end() != null &amp;&amp;  this.range.end().compareTo(t) &lt; 0) return -1;</span>
<span class="nc" id="L2219">        else return this.range.getTime().compareTo(t);</span>
      }
<span class="nc" id="L2221">      return 0;</span>
    }

    @Override
    public InexactTime setTimeZone(DateTimeZone tz) {
<span class="nc" id="L2226">      return new InexactTime(this,</span>
<span class="nc" id="L2227">              (Time) Temporal.setTimeZone(base, tz), duration,</span>
<span class="nc" id="L2228">              (Range) Temporal.setTimeZone(range, tz));</span>
    }

    @Override
    public Time getTime() {
<span class="nc" id="L2233">      return this;</span>
    }

    @Override
    public Duration getDuration() {
<span class="fc bfc" id="L2238" title="All 2 branches covered.">      if (duration != null)</span>
<span class="fc" id="L2239">        return duration;</span>
<span class="pc bpc" id="L2240" title="1 of 2 branches missed.">      if (range != null)</span>
<span class="fc" id="L2241">        return range.getDuration();</span>
<span class="nc bnc" id="L2242" title="All 2 branches missed.">      else if (base != null)</span>
<span class="nc" id="L2243">        return base.getDuration();</span>
      else
<span class="nc" id="L2245">        return null;</span>
    }

    @Override
    public Range getRange(int flags, Duration granularity) {
<span class="pc bpc" id="L2250" title="1 of 2 branches missed.">      if (range != null) {</span>
<span class="fc" id="L2251">        return range.getRange(flags, granularity);</span>
<span class="nc bnc" id="L2252" title="All 2 branches missed.">      } else if (base != null) {</span>
<span class="nc" id="L2253">        return base.getRange(flags, granularity);</span>
      } else
<span class="nc" id="L2255">        return null;</span>
    }

    @Override
    public Time add(Duration offset) {
      //if (getTimeLabel() != null) {
<span class="pc bpc" id="L2261" title="1 of 2 branches missed.">      if (getStandardTemporalType() != null) {</span>
        // Time has some meaning, keep as is
<span class="fc" id="L2263">        return new RelativeTime(this, TemporalOp.OFFSET_EXACT, offset);</span>
      } else {
        // Some other time, who know what it means
        // Try to do offset
<span class="nc" id="L2267">        return new InexactTime(this, (Time) TemporalOp.OFFSET_EXACT.apply(base, offset), duration, (Range) TemporalOp.OFFSET_EXACT.apply(range, offset));</span>
      }
    }

    @Override
    public Time resolve(Time refTime, int flags) {
<span class="fc" id="L2273">      CompositePartialTime cpt = makeComposite(new PartialTime(this, new Partial()), this);</span>
<span class="pc bpc" id="L2274" title="1 of 2 branches missed.">      if (cpt != null) {</span>
<span class="fc" id="L2275">        return cpt.resolve(refTime, flags);</span>
      }
<span class="nc" id="L2277">      Time groundedBase = null;</span>
<span class="nc bnc" id="L2278" title="All 2 branches missed.">      if (base == TIME_REF) {</span>
<span class="nc" id="L2279">        groundedBase = refTime;</span>
<span class="nc bnc" id="L2280" title="All 2 branches missed.">      } else if (base != null) {</span>
<span class="nc" id="L2281">        groundedBase = base.resolve(refTime, flags).getTime();</span>
      }
<span class="nc" id="L2283">      Range groundedRange = null;</span>
<span class="nc bnc" id="L2284" title="All 2 branches missed.">      if (range != null) {</span>
<span class="nc" id="L2285">        groundedRange = range.resolve(refTime, flags).getRange();</span>
      }
      /*    if (groundedRange == range &amp;&amp; groundedBase == base) {
            return this;
          } */
<span class="nc" id="L2290">      return createTemporal(standardTemporalType, timeLabel, mod, new InexactTime(groundedBase, duration, groundedRange));</span>
      //return new InexactTime(groundedBase, duration, groundedRange);
    }

    @Override
    public Instant getJodaTimeInstant() {
<span class="fc" id="L2296">      Instant p = null;</span>
<span class="pc bpc" id="L2297" title="1 of 2 branches missed.">      if (base != null) {</span>
<span class="fc" id="L2298">        p = base.getJodaTimeInstant();</span>
      }
<span class="pc bpc" id="L2300" title="3 of 4 branches missed.">      if (p == null &amp;&amp; range != null) {</span>
<span class="nc" id="L2301">        p = range.mid().getJodaTimeInstant();</span>
      }
<span class="fc" id="L2303">      return p;</span>
    }

    @Override
    public Partial getJodaTimePartial() {
<span class="fc" id="L2308">      Partial p = null;</span>
<span class="pc bpc" id="L2309" title="1 of 2 branches missed.">      if (base != null) {</span>
<span class="fc" id="L2310">        p = base.getJodaTimePartial();</span>
      }
<span class="pc bpc" id="L2312" title="5 of 6 branches missed.">      if (p == null &amp;&amp; range != null &amp;&amp; range.mid() != null) {</span>
<span class="nc" id="L2313">        p = range.mid().getJodaTimePartial();</span>
      }
<span class="fc" id="L2315">      return p;</span>
    }

    @Override
    public String toFormattedString(int flags) {
<span class="pc bpc" id="L2320" title="1 of 2 branches missed.">      if (getTimeLabel() != null) {</span>
<span class="fc" id="L2321">        return getTimeLabel();</span>
      }

<span class="nc bnc" id="L2324" title="All 2 branches missed.">      if ((flags &amp; FORMAT_ISO) != 0) {</span>
<span class="nc" id="L2325">        return null;</span>
      } // TODO: is there iso standard?
<span class="nc bnc" id="L2327" title="All 2 branches missed.">      if ((flags &amp; FORMAT_TIMEX3_VALUE) != 0) {</span>
<span class="nc" id="L2328">        return null;</span>
      } // TODO: is there timex3 standard?
<span class="nc" id="L2330">      StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L2331">      sb.append(&quot;~(&quot;);</span>
<span class="nc bnc" id="L2332" title="All 2 branches missed.">      if (base != null) {</span>
<span class="nc" id="L2333">        sb.append(base.toFormattedString(flags));</span>
      }
<span class="nc bnc" id="L2335" title="All 2 branches missed.">      if (duration != null) {</span>
<span class="nc" id="L2336">        sb.append(&quot;:&quot;);</span>
<span class="nc" id="L2337">        sb.append(duration.toFormattedString(flags));</span>
      }
<span class="nc bnc" id="L2339" title="All 2 branches missed.">      if (range != null) {</span>
<span class="nc" id="L2340">        sb.append(&quot; IN &quot;);</span>
<span class="nc" id="L2341">        sb.append(range.toFormattedString(flags));</span>
      }
<span class="nc" id="L2343">      sb.append(&quot;)&quot;);</span>
<span class="nc" id="L2344">      return sb.toString();</span>
    }

    private static final long serialVersionUID = 1;
  }

  /** Relative Time (something not quite resolved). */
  public static class RelativeTime extends Time {

<span class="pc" id="L2353">    private Time base = TIME_REF;</span>
    private TemporalOp tempOp;
    private Temporal tempArg;
    private int opFlags;

    public RelativeTime(Time base, TemporalOp tempOp, Temporal tempArg, int flags) {
<span class="nc" id="L2359">      super(base);</span>
<span class="nc" id="L2360">      this.base = base;</span>
<span class="nc" id="L2361">      this.tempOp = tempOp;</span>
<span class="nc" id="L2362">      this.tempArg = tempArg;</span>
<span class="nc" id="L2363">      this.opFlags = flags;</span>
<span class="nc" id="L2364">    }</span>

    public RelativeTime(Time base, TemporalOp tempOp, Temporal tempArg) {
<span class="fc" id="L2367">      super(base);</span>
<span class="fc" id="L2368">      this.base = base;</span>
<span class="fc" id="L2369">      this.tempOp = tempOp;</span>
<span class="fc" id="L2370">      this.tempArg = tempArg;</span>
<span class="fc" id="L2371">    }</span>

<span class="fc" id="L2373">    public RelativeTime(TemporalOp tempOp, Temporal tempArg) {</span>
<span class="fc" id="L2374">      this.tempOp = tempOp;</span>
<span class="fc" id="L2375">      this.tempArg = tempArg;</span>
<span class="fc" id="L2376">    }</span>

<span class="fc" id="L2378">    public RelativeTime(TemporalOp tempOp, Temporal tempArg, int flags) {</span>
<span class="fc" id="L2379">      this.tempOp = tempOp;</span>
<span class="fc" id="L2380">      this.tempArg = tempArg;</span>
<span class="fc" id="L2381">      this.opFlags = flags;</span>
<span class="fc" id="L2382">    }</span>

    public RelativeTime(Duration offset) {
<span class="fc" id="L2385">      this(TIME_REF, TemporalOp.OFFSET, offset);</span>
<span class="fc" id="L2386">    }</span>

    public RelativeTime(Time base, Duration offset) {
<span class="fc" id="L2389">      this(base, TemporalOp.OFFSET, offset);</span>
<span class="fc" id="L2390">    }</span>

    public RelativeTime(Time base) {
<span class="nc" id="L2393">      super(base);</span>
<span class="nc" id="L2394">      this.base = base;</span>
<span class="nc" id="L2395">    }</span>

    public Time getBase() {
<span class="nc" id="L2398">      return base;</span>
    }

    public TemporalOp getTemporalOp() {
<span class="nc" id="L2402">      return tempOp;</span>
    }

    public Temporal getTemporalArg() {
<span class="nc" id="L2406">      return tempArg;</span>
    }

    public int getOpFlags() {
<span class="nc" id="L2410">      return opFlags;</span>
    }

    @Override
    public boolean isGrounded() {
<span class="nc bnc" id="L2415" title="All 4 branches missed.">      return (base != null) &amp;&amp; base.isGrounded();</span>
    }

    // TODO: compute duration/range =&gt; uncertainty of this time
    @Override
    public Duration getDuration() {
<span class="nc" id="L2421">      return null;</span>
    }

    @Override
    public Range getRange(int flags, Duration granularity) {
<span class="nc" id="L2426">      return new Range(this, this);</span>
    }

    @Override
    public Map&lt;String, String&gt; getTimexAttributes(TimeIndex timeIndex) {
<span class="nc" id="L2431">      Map&lt;String, String&gt; map = super.getTimexAttributes(timeIndex);</span>
<span class="nc" id="L2432">      String tfid = getTfidString(timeIndex);</span>
<span class="nc" id="L2433">      map.put(TimexAttr.temporalFunction.name(), &quot;true&quot;);</span>
<span class="nc" id="L2434">      map.put(TimexAttr.valueFromFunction.name(), tfid);</span>
<span class="nc bnc" id="L2435" title="All 2 branches missed.">      if (base != null) {</span>
<span class="nc" id="L2436">        map.put(TimexAttr.anchorTimeID.name(), base.getTidString(timeIndex));</span>
      }
<span class="nc" id="L2438">      return map;</span>
    }

    // / NOTE: This is not ISO or timex standard
    @Override
    public String toFormattedString(int flags) {
<span class="nc bnc" id="L2444" title="All 2 branches missed.">      if (getTimeLabel() != null) {</span>
<span class="nc" id="L2445">        return getTimeLabel();</span>
      }
<span class="nc bnc" id="L2447" title="All 2 branches missed.">      if ((flags &amp; FORMAT_ISO) != 0) {</span>
<span class="nc" id="L2448">        return null;</span>
      } // TODO: is there iso standard?
<span class="nc bnc" id="L2450" title="All 2 branches missed.">      if ((flags &amp; FORMAT_TIMEX3_VALUE) != 0) {</span>
<span class="nc" id="L2451">        return null;</span>
      } // TODO: is there timex3 standard?
<span class="nc" id="L2453">      StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L2454" title="All 4 branches missed.">      if (base != null &amp;&amp; base != TIME_REF) {</span>
<span class="nc" id="L2455">        sb.append(base.toFormattedString(flags));</span>
      }
<span class="nc bnc" id="L2457" title="All 2 branches missed.">      if (tempOp != null) {</span>
<span class="nc bnc" id="L2458" title="All 2 branches missed.">        if (sb.length() &gt; 0) {</span>
<span class="nc" id="L2459">          sb.append(&quot; &quot;);</span>
        }
<span class="nc" id="L2461">        sb.append(tempOp);</span>
<span class="nc bnc" id="L2462" title="All 2 branches missed.">        if (tempArg != null) {</span>
<span class="nc" id="L2463">          sb.append(&quot; &quot;).append(tempArg.toFormattedString(flags));</span>
        }
      }
<span class="nc" id="L2466">      return sb.toString();</span>
    }

    @Override
    public Temporal resolve(Time refTime, int flags) {
<span class="fc" id="L2471">      Temporal groundedBase = null;</span>
<span class="fc bfc" id="L2472" title="All 2 branches covered.">      if (base == TIME_REF) {</span>
<span class="fc" id="L2473">        groundedBase = refTime;</span>
<span class="pc bpc" id="L2474" title="1 of 2 branches missed.">      } else if (base != null) {</span>
<span class="fc" id="L2475">        groundedBase = base.resolve(refTime, flags);</span>
      }
<span class="pc bpc" id="L2477" title="1 of 2 branches missed.">      if (tempOp != null) {</span>
        // NOTE: Should be always safe to resolve and then apply since
        // we will terminate here (no looping hopefully)
<span class="fc" id="L2480">        Temporal t = tempOp.apply(groundedBase, tempArg, opFlags);</span>
<span class="pc bpc" id="L2481" title="1 of 2 branches missed.">        if (t != null) {</span>
<span class="fc" id="L2482">          t = t.addModApprox(mod, approx);</span>
<span class="fc" id="L2483">          return t;</span>
        } else {
          // NOTE: this can be difficult if applying op
          // gives back same stuff as before
          // Try applying op and then resolving
<span class="nc" id="L2488">          t = tempOp.apply(base, tempArg, opFlags);</span>
<span class="nc bnc" id="L2489" title="All 2 branches missed.">          if (t != null) {</span>
<span class="nc" id="L2490">            t = t.addModApprox(mod, approx);</span>
<span class="nc bnc" id="L2491" title="All 2 branches missed.">            if (!this.equals(t)) {</span>
<span class="nc" id="L2492">              return t.resolve(refTime, flags);</span>
            } else {
              // Applying op doesn't do much....
<span class="nc" id="L2495">              return this;</span>
            }
          } else {
<span class="nc" id="L2498">            return null;</span>
          }
        }
      } else {
<span class="nc bnc" id="L2502" title="All 2 branches missed.">        return (groundedBase != null) ? groundedBase.addModApprox(mod, approx) : null;</span>
      }
    }

    public boolean equals(Object o) {
<span class="nc bnc" id="L2507" title="All 2 branches missed.">      if (this == o) {</span>
<span class="nc" id="L2508">        return true;</span>
      }
<span class="nc bnc" id="L2510" title="All 4 branches missed.">      if (o == null || getClass() != o.getClass()) {</span>
<span class="nc" id="L2511">        return false;</span>
      }

<span class="nc" id="L2514">      RelativeTime that = (RelativeTime) o;</span>

<span class="nc bnc" id="L2516" title="All 2 branches missed.">      if (opFlags != that.opFlags) {</span>
<span class="nc" id="L2517">        return false;</span>
      }
<span class="nc bnc" id="L2519" title="All 6 branches missed.">      if (base != null ? !base.equals(that.base) : that.base != null) {</span>
<span class="nc" id="L2520">        return false;</span>
      }
<span class="nc bnc" id="L2522" title="All 6 branches missed.">      if (tempArg != null ? !tempArg.equals(that.tempArg) : that.tempArg != null) {</span>
<span class="nc" id="L2523">        return false;</span>
      }
<span class="nc bnc" id="L2525" title="All 2 branches missed.">      if (tempOp != that.tempOp) {</span>
<span class="nc" id="L2526">        return false;</span>
      }

<span class="nc" id="L2529">      return true;</span>
    }

    public int hashCode() {
<span class="nc bnc" id="L2533" title="All 2 branches missed.">      int result = base != null ? base.hashCode() : 0;</span>
<span class="nc bnc" id="L2534" title="All 2 branches missed.">      result = 31 * result + (tempOp != null ? tempOp.hashCode() : 0);</span>
<span class="nc bnc" id="L2535" title="All 2 branches missed.">      result = 31 * result + (tempArg != null ? tempArg.hashCode() : 0);</span>
<span class="nc" id="L2536">      result = 31 * result + opFlags;</span>
<span class="nc" id="L2537">      return result;</span>
    }

    @Override
    public Time add(Duration offset) {
      Time t;
<span class="nc" id="L2543">      Duration d = offset;</span>
<span class="nc bnc" id="L2544" title="All 2 branches missed.">      if (this.tempOp == null) {</span>
<span class="nc" id="L2545">        t = new RelativeTime(base, d);</span>
<span class="nc" id="L2546">        t.approx = this.approx;</span>
<span class="nc" id="L2547">        t.mod = this.mod;</span>
<span class="nc bnc" id="L2548" title="All 2 branches missed.">      } else if (this.tempOp == TemporalOp.OFFSET) {</span>
<span class="nc" id="L2549">        d = ((Duration) this.tempArg).add(offset);</span>
<span class="nc" id="L2550">        t = new RelativeTime(base, d);</span>
<span class="nc" id="L2551">        t.approx = this.approx;</span>
<span class="nc" id="L2552">        t.mod = this.mod;</span>
      } else {
<span class="nc" id="L2554">        t = new RelativeTime(this, d);</span>
      }
<span class="nc" id="L2556">      return t;</span>
    }

    @Override
    public Temporal intersect(Temporal t) {
<span class="nc" id="L2561">      return new RelativeTime(this, TemporalOp.INTERSECT, t);</span>
    }

    @Override
    public Time intersect(Time t) {
<span class="nc bnc" id="L2566" title="All 4 branches missed.">      if (base == TIME_REF || base == null) {</span>
<span class="nc bnc" id="L2567" title="All 4 branches missed.">        if (t instanceof PartialTime &amp;&amp; tempOp == TemporalOp.OFFSET) {</span>
<span class="nc" id="L2568">          RelativeTime rt = new RelativeTime(this, tempOp, tempArg);</span>
<span class="nc" id="L2569">          rt.base = t;</span>
<span class="nc" id="L2570">          return rt;</span>
        }
      }
<span class="nc" id="L2573">      return new RelativeTime(this, TemporalOp.INTERSECT, t);</span>
    }

    private static final long serialVersionUID = 1;

  } // end static class RelativeTime

  // Partial time with Joda Time fields
  public static class PartialTime extends Time {
    // There is typically some uncertainty/imprecision in the time
    Partial base; // For representing partial absolute time
    DateTimeZone dateTimeZone; // Datetime zone associated with this time

    // private static DateTimeFormatter isoDateFormatter =
    // ISODateTimeFormat.basicDate();
    // private static DateTimeFormatter isoDateTimeFormatter =
    // ISODateTimeFormat.basicDateTimeNoMillis();
    // private static DateTimeFormatter isoTimeFormatter =
    // ISODateTimeFormat.basicTTimeNoMillis();
    // private static DateTimeFormatter isoDateFormatter =
    // ISODateTimeFormat.date();
    // private static DateTimeFormatter isoDateTimeFormatter =
    // ISODateTimeFormat.dateTimeNoMillis();
    // private static DateTimeFormatter isoTimeFormatter =
    // ISODateTimeFormat.tTimeNoMillis();

    public PartialTime(Time t, Partial p) {
<span class="fc" id="L2600">      super(t);</span>
<span class="fc bfc" id="L2601" title="All 2 branches covered.">      if (t instanceof PartialTime) {</span>
<span class="fc" id="L2602">        this.dateTimeZone = ((PartialTime) t).dateTimeZone;</span>
      }
<span class="fc" id="L2604">      this.base = p;</span>
<span class="fc" id="L2605">    }</span>

    public PartialTime(PartialTime pt) {
<span class="fc" id="L2608">      super(pt);</span>
<span class="fc" id="L2609">      this.dateTimeZone = pt.dateTimeZone;</span>
<span class="fc" id="L2610">      this.base = pt.base;</span>
<span class="fc" id="L2611">    }</span>

    // public PartialTime(Partial base, String mod) { this.base = base; this.mod
    // = mod; }
<span class="fc" id="L2615">    public PartialTime(Partial base) {</span>
<span class="fc" id="L2616">      this.base = base;</span>
<span class="fc" id="L2617">    }</span>

<span class="fc" id="L2619">    public PartialTime(StandardTemporalType temporalType, Partial base) {</span>
<span class="fc" id="L2620">      this.base = base;</span>
<span class="fc" id="L2621">      this.standardTemporalType = temporalType;</span>
<span class="fc" id="L2622">    }</span>

<span class="fc" id="L2624">    public PartialTime() {</span>
<span class="fc" id="L2625">    }</span>

    @Override
    public PartialTime setTimeZone(DateTimeZone tz) {
<span class="nc" id="L2629">      PartialTime tzPt = new PartialTime(this, base);</span>
<span class="nc" id="L2630">      tzPt.dateTimeZone = tz;</span>
<span class="nc" id="L2631">      return tzPt;</span>
    }

    @Override
    public Instant getJodaTimeInstant() {
<span class="fc" id="L2636">      return JodaTimeUtils.getInstant(base);</span>
    }

    @Override
    public Partial getJodaTimePartial() {
<span class="fc" id="L2641">      return base;</span>
    }

    @Override
    public boolean hasTime() {
<span class="pc bpc" id="L2646" title="1 of 2 branches missed.">      if (base == null)</span>
<span class="nc" id="L2647">        return false;</span>
<span class="fc" id="L2648">      DateTimeFieldType sdft = JodaTimeUtils.getMostSpecific(base);</span>
<span class="pc bpc" id="L2649" title="1 of 4 branches missed.">      if (sdft != null &amp;&amp; JodaTimeUtils.isMoreGeneral(DateTimeFieldType.dayOfMonth(), sdft, base.getChronology())) {</span>
<span class="fc" id="L2650">        return true;</span>
      } else {
<span class="fc" id="L2652">        return false;</span>
      }
    }

    @Override
    public TimexType getTimexType() {
<span class="nc bnc" id="L2658" title="All 2 branches missed.">      if (base == null) return null;</span>
<span class="nc" id="L2659">      return super.getTimexType();</span>
    }

    protected boolean appendDateFormats(DateTimeFormatterBuilder builder, int flags) {
<span class="pc bpc" id="L2663" title="1 of 2 branches missed.">      boolean alwaysPad = ((flags &amp; FORMAT_PAD_UNKNOWN) != 0);</span>
<span class="fc" id="L2664">      boolean hasDate = true;</span>
<span class="fc bfc" id="L2665" title="All 2 branches covered.">      boolean isISO = ((flags &amp; FORMAT_ISO) != 0);</span>
<span class="pc bpc" id="L2666" title="1 of 2 branches missed.">      boolean isTimex3 = ((flags &amp; FORMAT_TIMEX3_VALUE) != 0);</span>
      // ERA
<span class="pc bpc" id="L2668" title="1 of 2 branches missed.">      if (JodaTimeUtils.hasField(base, DateTimeFieldType.era())) {</span>
<span class="nc" id="L2669">        int era = base.get(DateTimeFieldType.era());</span>
<span class="nc bnc" id="L2670" title="All 2 branches missed.">        if (era == 0) {</span>
<span class="nc" id="L2671">          builder.appendLiteral('-');</span>
<span class="nc bnc" id="L2672" title="All 2 branches missed.">        } else if (era == 1) {</span>
<span class="nc" id="L2673">          builder.appendLiteral('+');</span>
        }
      }
      // YEAR
<span class="pc bpc" id="L2677" title="2 of 4 branches missed.">      if (JodaTimeUtils.hasField(base, DateTimeFieldType.centuryOfEra()) || JodaTimeUtils.hasField(base, JodaTimeUtils.DecadeOfCentury)</span>
<span class="pc bpc" id="L2678" title="1 of 2 branches missed.">          || JodaTimeUtils.hasField(base, DateTimeFieldType.yearOfCentury())) {</span>
<span class="nc bnc" id="L2679" title="All 2 branches missed.">        if (JodaTimeUtils.hasField(base, DateTimeFieldType.centuryOfEra())) {</span>
<span class="nc" id="L2680">          builder.appendCenturyOfEra(2, 2);</span>
        } else {
<span class="nc" id="L2682">          builder.appendLiteral(PAD_FIELD_UNKNOWN2);</span>
        }
<span class="nc bnc" id="L2684" title="All 2 branches missed.">        if (JodaTimeUtils.hasField(base, JodaTimeUtils.DecadeOfCentury)) {</span>
<span class="nc" id="L2685">          builder.appendDecimal(JodaTimeUtils.DecadeOfCentury, 1, 1);</span>
<span class="nc" id="L2686">          builder.appendLiteral(PAD_FIELD_UNKNOWN);</span>
<span class="nc bnc" id="L2687" title="All 2 branches missed.">        } else if (JodaTimeUtils.hasField(base, DateTimeFieldType.yearOfCentury())) {</span>
<span class="nc" id="L2688">          builder.appendYearOfCentury(2, 2);</span>
        } else {
<span class="nc" id="L2690">          builder.appendLiteral(PAD_FIELD_UNKNOWN2);</span>
        }
<span class="fc bfc" id="L2692" title="All 2 branches covered.">      } else if (JodaTimeUtils.hasField(base, DateTimeFieldType.year())) {</span>
<span class="fc" id="L2693">        builder.appendYear(4, 4);</span>
<span class="pc bpc" id="L2694" title="1 of 2 branches missed.">      } else if (JodaTimeUtils.hasField(base, DateTimeFieldType.weekyear())) {</span>
<span class="nc" id="L2695">        builder.appendWeekyear(4, 4);</span>
      } else {
<span class="fc" id="L2697">        builder.appendLiteral(PAD_FIELD_UNKNOWN4);</span>
<span class="fc" id="L2698">        hasDate = false;</span>
      }
      // Decide whether to include HALF, QUARTER, MONTH/DAY, or WEEK/WEEKDAY
<span class="fc" id="L2701">      boolean appendHalf = false;</span>
<span class="fc" id="L2702">      boolean appendQuarter = false;</span>
<span class="fc" id="L2703">      boolean appendMonthDay = false;</span>
<span class="fc" id="L2704">      boolean appendWeekDay = false;</span>
<span class="pc bpc" id="L2705" title="1 of 4 branches missed.">      if (isISO || isTimex3) {</span>
<span class="pc bpc" id="L2706" title="1 of 4 branches missed.">        if (JodaTimeUtils.hasField(base, DateTimeFieldType.monthOfYear()) &amp;&amp; JodaTimeUtils.hasField(base, DateTimeFieldType.dayOfMonth())) {</span>
<span class="fc" id="L2707">          appendMonthDay = true;</span>
<span class="pc bpc" id="L2708" title="2 of 4 branches missed.">        } else if (JodaTimeUtils.hasField(base, DateTimeFieldType.weekOfWeekyear()) || JodaTimeUtils.hasField(base, DateTimeFieldType.dayOfWeek())) {</span>
<span class="nc" id="L2709">          appendWeekDay = true;</span>
<span class="pc bpc" id="L2710" title="3 of 4 branches missed.">        } else if (JodaTimeUtils.hasField(base, DateTimeFieldType.monthOfYear()) || JodaTimeUtils.hasField(base, DateTimeFieldType.dayOfMonth())) {</span>
<span class="fc" id="L2711">          appendMonthDay = true;</span>
<span class="nc bnc" id="L2712" title="All 2 branches missed.">        } else if (JodaTimeUtils.hasField(base, JodaTimeUtils.QuarterOfYear)) {</span>
<span class="nc bnc" id="L2713" title="All 2 branches missed.">          if (!isISO) appendQuarter = true;</span>
<span class="nc bnc" id="L2714" title="All 2 branches missed.">        } else if (JodaTimeUtils.hasField(base, JodaTimeUtils.HalfYearOfYear)) {</span>
<span class="nc bnc" id="L2715" title="All 2 branches missed.">          if (!isISO) appendHalf = true;</span>
        }
      } else {
<span class="fc" id="L2718">        appendHalf = true;</span>
<span class="fc" id="L2719">        appendQuarter = true;</span>
<span class="fc" id="L2720">        appendMonthDay = true;</span>
<span class="fc" id="L2721">        appendWeekDay = true;</span>
      }

      // Half - Not ISO standard
<span class="pc bpc" id="L2725" title="1 of 4 branches missed.">      if (appendHalf &amp;&amp; JodaTimeUtils.hasField(base, JodaTimeUtils.HalfYearOfYear)) {</span>
<span class="nc" id="L2726">        builder.appendLiteral(&quot;-H&quot;);</span>
<span class="nc" id="L2727">        builder.appendDecimal(JodaTimeUtils.HalfYearOfYear, 1, 1);</span>
      }
      // Quarter  - Not ISO standard
<span class="pc bpc" id="L2730" title="1 of 4 branches missed.">      if (appendQuarter &amp;&amp; JodaTimeUtils.hasField(base, JodaTimeUtils.QuarterOfYear)) {</span>
<span class="nc" id="L2731">        builder.appendLiteral(&quot;-Q&quot;);</span>
<span class="nc" id="L2732">        builder.appendDecimal(JodaTimeUtils.QuarterOfYear, 1, 1);</span>
      }
      // MONTH
<span class="pc bpc" id="L2735" title="2 of 6 branches missed.">      if (appendMonthDay &amp;&amp; (JodaTimeUtils.hasField(base, DateTimeFieldType.monthOfYear()) || JodaTimeUtils.hasField(base, DateTimeFieldType.dayOfMonth()))) {</span>
<span class="fc" id="L2736">        hasDate = true;</span>
<span class="fc" id="L2737">        builder.appendLiteral('-');</span>
<span class="pc bpc" id="L2738" title="1 of 2 branches missed.">        if (JodaTimeUtils.hasField(base, DateTimeFieldType.monthOfYear())) {</span>
<span class="fc" id="L2739">          builder.appendMonthOfYear(2);</span>
        } else {
<span class="nc" id="L2741">          builder.appendLiteral(PAD_FIELD_UNKNOWN2);</span>
        }
        // Don't indicate day of month if not specified
<span class="fc bfc" id="L2744" title="All 2 branches covered.">        if (JodaTimeUtils.hasField(base, DateTimeFieldType.dayOfMonth())) {</span>
<span class="fc" id="L2745">          builder.appendLiteral('-');</span>
<span class="fc" id="L2746">          builder.appendDayOfMonth(2);</span>
<span class="pc bpc" id="L2747" title="1 of 2 branches missed.">        } else if (alwaysPad) {</span>
<span class="nc" id="L2748">          builder.appendLiteral(PAD_FIELD_UNKNOWN2);</span>
        }
      }
<span class="pc bpc" id="L2751" title="2 of 6 branches missed.">      if (appendWeekDay &amp;&amp; (JodaTimeUtils.hasField(base, DateTimeFieldType.weekOfWeekyear()) || JodaTimeUtils.hasField(base, DateTimeFieldType.dayOfWeek()))) {</span>
<span class="fc" id="L2752">        hasDate = true;</span>
<span class="fc" id="L2753">        builder.appendLiteral(&quot;-W&quot;);</span>
<span class="pc bpc" id="L2754" title="1 of 2 branches missed.">        if (JodaTimeUtils.hasField(base, DateTimeFieldType.weekOfWeekyear())) {</span>
<span class="nc" id="L2755">          builder.appendWeekOfWeekyear(2);</span>
        } else {
<span class="fc" id="L2757">          builder.appendLiteral(PAD_FIELD_UNKNOWN2);</span>
        }
        // Don't indicate the day of the week if not specified
<span class="pc bpc" id="L2760" title="1 of 2 branches missed.">        if (JodaTimeUtils.hasField(base, DateTimeFieldType.dayOfWeek())) {</span>
<span class="fc" id="L2761">          builder.appendLiteral(&quot;-&quot;);</span>
<span class="fc" id="L2762">          builder.appendDayOfWeek(1);</span>
        }
      }
<span class="fc" id="L2765">      return hasDate;</span>
    }

    protected boolean appendTimeFormats(DateTimeFormatterBuilder builder, int flags) {
<span class="pc bpc" id="L2769" title="1 of 2 branches missed.">      boolean alwaysPad = ((flags &amp; FORMAT_PAD_UNKNOWN) != 0);</span>
<span class="fc" id="L2770">      boolean hasTime = hasTime();</span>
<span class="fc" id="L2771">      DateTimeFieldType sdft = JodaTimeUtils.getMostSpecific(base);</span>
<span class="pc bpc" id="L2772" title="1 of 2 branches missed.">      if (hasTime) {</span>
<span class="fc" id="L2773">        builder.appendLiteral(&quot;T&quot;);</span>
<span class="pc bpc" id="L2774" title="1 of 2 branches missed.">        if (JodaTimeUtils.hasField(base, DateTimeFieldType.hourOfDay())) {</span>
<span class="fc" id="L2775">          builder.appendHourOfDay(2);</span>
<span class="nc bnc" id="L2776" title="All 2 branches missed.">        } else if (JodaTimeUtils.hasField(base, DateTimeFieldType.clockhourOfDay())) {</span>
<span class="nc" id="L2777">          builder.appendClockhourOfDay(2);</span>
        } else {
<span class="nc" id="L2779">          builder.appendLiteral(PAD_FIELD_UNKNOWN2);</span>
        }
<span class="pc bpc" id="L2781" title="1 of 2 branches missed.">        if (JodaTimeUtils.hasField(base, DateTimeFieldType.minuteOfHour())) {</span>
<span class="fc" id="L2782">          builder.appendLiteral(&quot;:&quot;);</span>
<span class="fc" id="L2783">          builder.appendMinuteOfHour(2);</span>
<span class="nc bnc" id="L2784" title="All 4 branches missed.">        } else if (alwaysPad || JodaTimeUtils.isMoreGeneral(DateTimeFieldType.minuteOfHour(), sdft, base.getChronology())) {</span>
<span class="nc" id="L2785">          builder.appendLiteral(&quot;:&quot;);</span>
<span class="nc" id="L2786">          builder.appendLiteral(PAD_FIELD_UNKNOWN2);</span>
        }
<span class="fc bfc" id="L2788" title="All 2 branches covered.">        if (JodaTimeUtils.hasField(base, DateTimeFieldType.secondOfMinute())) {</span>
<span class="fc" id="L2789">          builder.appendLiteral(&quot;:&quot;);</span>
<span class="fc" id="L2790">          builder.appendSecondOfMinute(2);</span>
<span class="pc bpc" id="L2791" title="2 of 4 branches missed.">        } else if (alwaysPad || JodaTimeUtils.isMoreGeneral(DateTimeFieldType.secondOfMinute(), sdft, base.getChronology())) {</span>
<span class="nc" id="L2792">          builder.appendLiteral(&quot;:&quot;);</span>
<span class="nc" id="L2793">          builder.appendLiteral(PAD_FIELD_UNKNOWN2);</span>
        }
<span class="fc bfc" id="L2795" title="All 2 branches covered.">        if (JodaTimeUtils.hasField(base, DateTimeFieldType.millisOfSecond())) {</span>
<span class="fc" id="L2796">          builder.appendLiteral(&quot;.&quot;);</span>
<span class="fc" id="L2797">          builder.appendMillisOfSecond(3);</span>
        }
        // builder.append(isoTimeFormatter);
      }
<span class="fc" id="L2801">      return hasTime;</span>
    }

    protected DateTimeFormatter getFormatter(int flags) {
<span class="fc" id="L2805">      DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();</span>
<span class="fc" id="L2806">      boolean hasDate = appendDateFormats(builder, flags);</span>
<span class="fc" id="L2807">      boolean hasTime = hasTime();</span>
<span class="pc bpc" id="L2808" title="1 of 2 branches missed.">      if (hasTime) {</span>
<span class="nc bnc" id="L2809" title="All 2 branches missed.">        if (!hasDate) {</span>
<span class="nc" id="L2810">          builder.clear();</span>
        }
<span class="nc" id="L2812">        appendTimeFormats(builder, flags);</span>
      }
<span class="fc" id="L2814">      return builder.toFormatter();</span>
    }

    @Override
    public boolean isGrounded() {
<span class="nc" id="L2819">      return false;</span>
    }

    // TODO: compute duration/range =&gt; uncertainty of this time
    @Override
    public Duration getDuration() {
/*      TimeLabel tl = getTimeLabel();
      if (tl != null) {
        return tl.getDuration();
      } */
<span class="fc" id="L2829">      StandardTemporalType tlt = getStandardTemporalType();</span>
<span class="fc bfc" id="L2830" title="All 2 branches covered.">      if (tlt != null) {</span>
<span class="fc" id="L2831">        return tlt.getDuration();</span>
      }
<span class="fc" id="L2833">      return Duration.getDuration(JodaTimeUtils.getJodaTimePeriod(base));</span>
    }

    @Override
    public Range getRange(int flags, Duration inputGranularity) {
<span class="fc" id="L2838">      Duration d = getDuration();</span>
<span class="pc bpc" id="L2839" title="1 of 2 branches missed.">      if (d != null) {</span>
<span class="fc" id="L2840">        int padType = (flags &amp; RANGE_FLAGS_PAD_MASK);</span>
<span class="fc" id="L2841">        Time start = this;</span>
<span class="fc" id="L2842">        Duration granularity = inputGranularity;</span>
<span class="pc bpc" id="L2843" title="3 of 5 branches missed.">        switch (padType) {</span>
        case RANGE_FLAGS_PAD_NONE:
          // The most basic range
<span class="nc" id="L2846">          start = this;</span>
<span class="nc" id="L2847">          break;</span>
        case RANGE_FLAGS_PAD_AUTO:
          // More complex range
<span class="fc bfc" id="L2850" title="All 2 branches covered.">          if (hasTime()) {</span>
<span class="fc" id="L2851">            granularity = SUTime.MILLIS;</span>
          } else {
<span class="fc" id="L2853">            granularity = SUTime.DAY;</span>
          }
<span class="fc" id="L2855">          start = padMoreSpecificFields(granularity);</span>
<span class="fc" id="L2856">          break;</span>
        case RANGE_FLAGS_PAD_FINEST:
<span class="nc" id="L2858">          granularity = SUTime.MILLIS;</span>
<span class="nc" id="L2859">          start = padMoreSpecificFields(granularity);</span>
<span class="nc" id="L2860">          break;</span>
        case RANGE_FLAGS_PAD_SPECIFIED:
<span class="fc" id="L2862">          start = padMoreSpecificFields(granularity);</span>
<span class="fc" id="L2863">          break;</span>
        default:
<span class="nc" id="L2865">          throw new UnsupportedOperationException(&quot;Unsupported pad type for getRange: &quot; + flags);</span>
        }
<span class="pc bpc" id="L2867" title="1 of 2 branches missed.">        if (start instanceof PartialTime) {</span>
<span class="fc" id="L2868">          ((PartialTime) start).withStandardFields();</span>
        }
<span class="fc" id="L2870">        Time end = start.add(d);</span>
<span class="pc bpc" id="L2871" title="1 of 2 branches missed.">        if (granularity != null) {</span>
<span class="fc" id="L2872">          end = end.subtract(granularity);</span>
        }
<span class="fc" id="L2874">        return new Range(start, end, d);</span>
      } else {
<span class="nc" id="L2876">        return new Range(this, this);</span>
      }
    }

    protected void withStandardFields() {
<span class="fc bfc" id="L2881" title="All 2 branches covered.">      if (base.isSupported(DateTimeFieldType.dayOfWeek())) {</span>
<span class="fc" id="L2882">        base = JodaTimeUtils.resolveDowToDay(base);</span>
<span class="fc bfc" id="L2883" title="All 4 branches covered.">      } else if (base.isSupported(DateTimeFieldType.monthOfYear()) &amp;&amp; base.isSupported(DateTimeFieldType.dayOfMonth())) {</span>
<span class="pc bpc" id="L2884" title="1 of 2 branches missed.">        if (base.isSupported(DateTimeFieldType.weekOfWeekyear())) {</span>
<span class="nc" id="L2885">          base = base.without(DateTimeFieldType.weekOfWeekyear());</span>
        }
<span class="pc bpc" id="L2887" title="1 of 2 branches missed.">        if (base.isSupported(DateTimeFieldType.dayOfWeek())) {</span>
<span class="nc" id="L2888">          base = base.without(DateTimeFieldType.dayOfWeek());</span>
        }
      }
<span class="fc" id="L2891">    }</span>

    @Override
    public PartialTime reduceGranularityTo(Duration granularity) {
<span class="nc" id="L2895">      Partial pbase = base;</span>
<span class="nc bnc" id="L2896" title="All 2 branches missed.">      if (JodaTimeUtils.hasField(granularity.getJodaTimePeriod(), DurationFieldType.weeks())) {</span>
        // Make sure the partial time has weeks in it
<span class="nc bnc" id="L2898" title="All 2 branches missed.">        if (!JodaTimeUtils.hasField(pbase, DateTimeFieldType.weekOfWeekyear())) {</span>
          // Add week year to it
<span class="nc" id="L2900">          pbase = JodaTimeUtils.resolveWeek(pbase);</span>
        }
      }
<span class="nc" id="L2903">      Partial p = JodaTimeUtils.discardMoreSpecificFields( pbase,</span>
<span class="nc" id="L2904">        JodaTimeUtils.getMostSpecific(granularity.getJodaTimePeriod()) );</span>
<span class="nc" id="L2905">      return new PartialTime(this,p);</span>
    }

    public PartialTime padMoreSpecificFields(Duration granularity) {
<span class="fc" id="L2909">      Period period = null;</span>
<span class="pc bpc" id="L2910" title="1 of 2 branches missed.">      if (granularity != null) {</span>
<span class="fc" id="L2911">        period = granularity.getJodaTimePeriod();</span>
      }
<span class="fc" id="L2913">      Partial p = JodaTimeUtils.padMoreSpecificFields(base, period);</span>
<span class="fc" id="L2914">      return new PartialTime(this,p);</span>
    }

    @Override
    public String toFormattedString(int flags) {
<span class="pc bpc" id="L2919" title="1 of 2 branches missed.">      if (getTimeLabel() != null) {</span>
<span class="nc" id="L2920">        return getTimeLabel();</span>
      }
      String s; // Initialized below
<span class="pc bpc" id="L2923" title="1 of 2 branches missed.">      if (base != null) {</span>
        // String s = ISODateTimeFormat.basicDateTime().print(base);
        // return s.replace('\ufffd', 'X');
<span class="fc" id="L2926">        DateTimeFormatter formatter = getFormatter(flags);</span>
<span class="fc" id="L2927">        s = formatter.print(base);</span>
<span class="fc" id="L2928">      } else {</span>
<span class="nc" id="L2929">        s = &quot;XXXX-XX-XX&quot;;</span>
      }
<span class="pc bpc" id="L2931" title="1 of 2 branches missed.">      if (dateTimeZone != null) {</span>
<span class="nc" id="L2932">        DateTimeFormatter formatter = DateTimeFormat.forPattern(&quot;Z&quot;);</span>
<span class="nc" id="L2933">        formatter = formatter.withZone(dateTimeZone);</span>
<span class="nc" id="L2934">        s = s + formatter.print(0);</span>
      }
<span class="fc" id="L2936">      return s;</span>
    }

    @Override
    public Time resolve(Time ref, int flags) {
<span class="pc bpc" id="L2941" title="3 of 6 branches missed.">      if (ref == null || ref == TIME_UNKNOWN || ref == TIME_REF) {</span>
<span class="nc" id="L2942">        return this;</span>
      }
<span class="pc bpc" id="L2944" title="1 of 2 branches missed.">      if (this == TIME_REF) {</span>
<span class="nc" id="L2945">        return ref;</span>
      }
<span class="pc bpc" id="L2947" title="1 of 2 branches missed.">      if (this == TIME_UNKNOWN) {</span>
<span class="nc" id="L2948">        return this;</span>
      }
<span class="fc" id="L2950">      Partial partialRef = ref.getJodaTimePartial();</span>
<span class="pc bpc" id="L2951" title="1 of 2 branches missed.">      if (partialRef == null) {</span>
<span class="nc" id="L2952">        throw new UnsupportedOperationException(&quot;Cannot resolve if reftime is of class: &quot; + ref.getClass());</span>
      }

<span class="pc bpc" id="L2955" title="1 of 2 branches missed.">      Partial p = (base != null) ? JodaTimeUtils.combineMoreGeneralFields(base, partialRef) : partialRef;</span>
<span class="fc" id="L2956">      p = JodaTimeUtils.resolveDowToDay(p, partialRef);</span>

      Time resolved;
<span class="pc bpc" id="L2959" title="1 of 2 branches missed.">      if (p == base) {</span>
<span class="nc" id="L2960">        resolved = this;</span>
      } else {
<span class="fc" id="L2962">        resolved = new PartialTime(this, p);</span>
        // log.info(&quot;Resolved &quot; + this + &quot; to &quot; + resolved + &quot;, ref=&quot; + ref);
      }

<span class="fc" id="L2966">      Duration resolvedGranularity = resolved.getGranularity();</span>
<span class="fc" id="L2967">      Duration refGranularity = ref.getGranularity();</span>
      // log.info(&quot;refGranularity is &quot; + refGranularity);
      // log.info(&quot;resolvedGranularity is &quot; + resolvedGranularity);
<span class="pc bpc" id="L2970" title="3 of 6 branches missed.">      if (resolvedGranularity != null &amp;&amp; refGranularity != null &amp;&amp; resolvedGranularity.compareTo(refGranularity) &gt;= 0) {</span>
<span class="pc bpc" id="L2971" title="1 of 2 branches missed.">        if ((flags &amp; RESOLVE_TO_PAST) != 0) {</span>
<span class="nc bnc" id="L2972" title="All 2 branches missed.">          if (resolved.compareTo(ref) &gt; 0) {</span>
<span class="nc" id="L2973">            Time t = (Time) this.prev();</span>
<span class="nc bnc" id="L2974" title="All 2 branches missed.">            if (t != null) {</span>
<span class="nc" id="L2975">              resolved = (Time) t.resolve(ref, 0);</span>
            }
<span class="nc" id="L2977">          }</span>
          // log.info(&quot;Resolved &quot; + this + &quot; to past &quot; + resolved + &quot;, ref=&quot; + ref);
<span class="pc bpc" id="L2979" title="1 of 2 branches missed.">        } else if ((flags &amp; RESOLVE_TO_FUTURE) != 0) {</span>
<span class="nc bnc" id="L2980" title="All 2 branches missed.">          if (resolved.compareTo(ref) &lt; 0) {</span>
<span class="nc" id="L2981">            Time t = (Time) this.next();</span>
<span class="nc bnc" id="L2982" title="All 2 branches missed.">            if (t != null) {</span>
<span class="nc" id="L2983">              resolved = (Time) t.resolve(ref, 0);</span>
            }
<span class="nc" id="L2985">          }</span>
          // log.info(&quot;Resolved &quot; + this + &quot; to future &quot; + resolved + &quot;, ref=&quot; + ref);
<span class="pc bpc" id="L2987" title="1 of 2 branches missed.">        } else if ((flags &amp; RESOLVE_TO_CLOSEST) != 0) {</span>
<span class="nc bnc" id="L2988" title="All 2 branches missed.">          if (resolved.compareTo(ref) &gt; 0) {</span>
<span class="nc" id="L2989">            Time t = (Time) this.prev();</span>
<span class="nc bnc" id="L2990" title="All 2 branches missed.">            if (t != null) {</span>
<span class="nc" id="L2991">              Time resolved2 = (Time) t.resolve(ref, 0);</span>
<span class="nc" id="L2992">              resolved = Time.closest(ref, resolved, resolved2);</span>
            }
<span class="nc bnc" id="L2994" title="All 2 branches missed.">          } if (resolved.compareTo(ref) &lt; 0) {</span>
<span class="nc" id="L2995">            Time t = (Time) this.next();</span>
<span class="nc bnc" id="L2996" title="All 2 branches missed.">            if (t != null) {</span>
<span class="nc" id="L2997">              Time resolved2 = (Time) t.resolve(ref, 0);</span>
<span class="nc" id="L2998">              resolved = Time.closest(ref, resolved, resolved2);</span>
            }
          }
          // log.info(&quot;Resolved &quot; + this + &quot; to closest &quot; + resolved + &quot;, ref=&quot; + ref);
        }
      }

<span class="fc" id="L3005">      return resolved;</span>
    }

    public boolean isCompatible(PartialTime time) {
<span class="fc" id="L3009">      return JodaTimeUtils.isCompatible(base, time.base);</span>
    }

    public static Pair&lt;PartialTime, PartialTime&gt; getCompatible(PartialTime t1, PartialTime t2) {
      // Incompatible timezones
<span class="pc bpc" id="L3014" title="3 of 4 branches missed.">      if (t1.dateTimeZone != null &amp;&amp; t2.dateTimeZone != null &amp;&amp;</span>
<span class="nc bnc" id="L3015" title="All 2 branches missed.">          !t1.dateTimeZone.equals(t2.dateTimeZone))</span>
<span class="nc" id="L3016">        return null;</span>
<span class="pc bpc" id="L3017" title="1 of 2 branches missed.">      if (t1.isCompatible(t2)) return Pair.makePair(t1,t2);</span>
<span class="nc bnc" id="L3018" title="All 4 branches missed.">      if (t1.uncertaintyGranularity != null &amp;&amp; t2.uncertaintyGranularity == null) {</span>
<span class="nc bnc" id="L3019" title="All 2 branches missed.">        if (t1.uncertaintyGranularity.compareTo(t2.getDuration()) &gt; 0) {</span>
          // Drop the uncertain fields from t1
<span class="nc" id="L3021">          Duration d = t1.uncertaintyGranularity;</span>
<span class="nc" id="L3022">          PartialTime t1b = t1.reduceGranularityTo(d);</span>
<span class="nc bnc" id="L3023" title="All 2 branches missed.">          if (t1b.isCompatible(t2)) return Pair.makePair(t1b,t2);</span>
<span class="nc" id="L3024">        }</span>
<span class="nc bnc" id="L3025" title="All 4 branches missed.">      } else if (t1.uncertaintyGranularity == null &amp;&amp; t2.uncertaintyGranularity != null) {</span>
<span class="nc bnc" id="L3026" title="All 2 branches missed.">        if (t2.uncertaintyGranularity.compareTo(t1.getDuration()) &gt; 0) {</span>
          // Drop the uncertain fields from t2
<span class="nc" id="L3028">          Duration d = t2.uncertaintyGranularity;</span>
<span class="nc" id="L3029">          PartialTime t2b = t2.reduceGranularityTo(d);</span>
<span class="nc bnc" id="L3030" title="All 2 branches missed.">          if (t1.isCompatible(t2b)) return Pair.makePair(t1,t2b);</span>
<span class="nc" id="L3031">        }</span>
<span class="nc bnc" id="L3032" title="All 4 branches missed.">      } else if (t1.uncertaintyGranularity != null &amp;&amp; t2.uncertaintyGranularity != null) {</span>
<span class="nc" id="L3033">        Duration d1 = Duration.max(t1.uncertaintyGranularity, t2.getDuration());</span>
<span class="nc" id="L3034">        Duration d2 = Duration.max(t2.uncertaintyGranularity, t1.getDuration());</span>
<span class="nc" id="L3035">        PartialTime t1b = t1.reduceGranularityTo(d1);</span>
<span class="nc" id="L3036">        PartialTime t2b = t2.reduceGranularityTo(d2);</span>
<span class="nc bnc" id="L3037" title="All 2 branches missed.">        if (t1b.isCompatible(t2b)) return Pair.makePair(t1b,t2b);</span>
      }
<span class="nc" id="L3039">      return null;</span>
    }

    @Override
    public Duration getPeriod() {
  /*    TimeLabel tl = getTimeLabel();
      if (tl != null) {
        return tl.getPeriod();
      } */
<span class="fc" id="L3048">      StandardTemporalType tlt = getStandardTemporalType();</span>
<span class="pc bpc" id="L3049" title="1 of 2 branches missed.">      if (tlt != null) {</span>
<span class="fc" id="L3050">        return tlt.getPeriod();</span>
      }
<span class="nc bnc" id="L3052" title="All 2 branches missed.">      if (base == null) {</span>
<span class="nc" id="L3053">        return null;</span>
      }
<span class="nc" id="L3055">      DateTimeFieldType mostGeneral = JodaTimeUtils.getMostGeneral(base);</span>
<span class="nc" id="L3056">      DurationFieldType df = mostGeneral.getRangeDurationType();</span>
      // if (df == null) {
      // df = mostGeneral.getDurationType();
      // }
<span class="nc bnc" id="L3060" title="All 2 branches missed.">      if (df != null) {</span>
        try {
<span class="nc" id="L3062">          return new DurationWithFields(new Period().withField(df, 1));</span>
<span class="nc" id="L3063">        } catch (Exception ex) {</span>
          // TODO: Do something intelligent here
        }
      }
<span class="nc" id="L3067">      return null;</span>
    }

    public List&lt;Temporal&gt; toList() {
<span class="nc bnc" id="L3071" title="All 2 branches missed.">      if (JodaTimeUtils.hasField(base, DateTimeFieldType.year())</span>
<span class="nc bnc" id="L3072" title="All 2 branches missed.">         &amp;&amp; JodaTimeUtils.hasField(base, DateTimeFieldType.monthOfYear())</span>
<span class="nc bnc" id="L3073" title="All 2 branches missed.">         &amp;&amp; JodaTimeUtils.hasField(base, DateTimeFieldType.dayOfWeek())) {</span>
<span class="nc" id="L3074">        List&lt;Temporal&gt; list = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L3075">        Partial pt = new Partial();</span>
<span class="nc" id="L3076">        pt = JodaTimeUtils.setField(pt, DateTimeFieldType.year(), base.get(DateTimeFieldType.year()));</span>
<span class="nc" id="L3077">        pt = JodaTimeUtils.setField(pt, DateTimeFieldType.monthOfYear(), base.get(DateTimeFieldType.monthOfYear()));</span>
<span class="nc" id="L3078">        pt = JodaTimeUtils.setField(pt, DateTimeFieldType.dayOfMonth(), 1);</span>

<span class="nc" id="L3080">        Partial candidate = JodaTimeUtils.resolveDowToDay(base, pt);</span>
<span class="nc bnc" id="L3081" title="All 2 branches missed.">        if (candidate.get(DateTimeFieldType.monthOfYear()) != base.get(DateTimeFieldType.monthOfYear())) {</span>
<span class="nc" id="L3082">          pt = JodaTimeUtils.setField(pt, DateTimeFieldType.dayOfMonth(), 8);</span>
<span class="nc" id="L3083">          candidate = JodaTimeUtils.resolveDowToDay(base, pt);</span>
<span class="nc bnc" id="L3084" title="All 2 branches missed.">          if (candidate.get(DateTimeFieldType.monthOfYear()) != base.get(DateTimeFieldType.monthOfYear())) {</span>
            // give up
<span class="nc" id="L3086">            return null;</span>
          }
        }
        try {
<span class="nc bnc" id="L3090" title="All 2 branches missed.">          while (candidate.get(DateTimeFieldType.monthOfYear()) == base.get(DateTimeFieldType.monthOfYear())) {</span>
<span class="nc" id="L3091">            list.add(new PartialTime(this, candidate));</span>
<span class="nc" id="L3092">            pt = JodaTimeUtils.setField(pt, DateTimeFieldType.dayOfMonth(), pt.get(DateTimeFieldType.dayOfMonth()) + 7);</span>
<span class="nc" id="L3093">            candidate = JodaTimeUtils.resolveDowToDay(base, pt);</span>
          }
<span class="nc" id="L3095">        } catch (IllegalFieldValueException ex) {}</span>
<span class="nc" id="L3096">        return list;</span>
      } else {
<span class="nc" id="L3098">        return null;</span>
      }
    }

    @Override
    public Time intersect(Time t) {
<span class="pc bpc" id="L3104" title="2 of 4 branches missed.">      if (t == null || t == TIME_UNKNOWN)</span>
<span class="nc" id="L3105">        return this;</span>
<span class="pc bpc" id="L3106" title="1 of 2 branches missed.">      if (base == null) {</span>
<span class="nc bnc" id="L3107" title="All 2 branches missed.">        if (dateTimeZone != null) {</span>
<span class="nc" id="L3108">          return (Time) t.setTimeZone(dateTimeZone);</span>
        } else {
<span class="nc" id="L3110">          return t;</span>
        }
      }
<span class="pc bpc" id="L3113" title="1 of 2 branches missed.">      if (t instanceof CompositePartialTime) {</span>
<span class="nc" id="L3114">        return t.intersect(this);</span>
<span class="pc bpc" id="L3115" title="1 of 2 branches missed.">      } else if (t instanceof PartialTime) {</span>
<span class="nc" id="L3116">        Pair&lt;PartialTime,PartialTime&gt; compatible = getCompatible(this, (PartialTime) t);</span>
<span class="nc bnc" id="L3117" title="All 2 branches missed.">        if (compatible == null) {</span>
<span class="nc" id="L3118">          return null;</span>
        }
<span class="nc" id="L3120">        Partial p = JodaTimeUtils.combine(compatible.first.base, compatible.second.base);</span>
        // Take timezone if there is one
<span class="nc bnc" id="L3122" title="All 2 branches missed.">        DateTimeZone dtz = (dateTimeZone != null)? dateTimeZone: ((PartialTime) t).dateTimeZone;</span>
<span class="nc" id="L3123">        PartialTime res = new PartialTime(p);</span>
<span class="nc bnc" id="L3124" title="All 2 branches missed.">        if (dtz != null) return res.setTimeZone(dtz);</span>
<span class="nc" id="L3125">        else return res;</span>
<span class="pc bpc" id="L3126" title="1 of 2 branches missed.">      } else if (t instanceof OrdinalTime) {</span>
<span class="nc" id="L3127">        Temporal temp = t.resolve(this);</span>
<span class="nc bnc" id="L3128" title="All 2 branches missed.">        if (temp instanceof PartialTime) return (Time) temp;</span>
<span class="nc" id="L3129">        else return t.intersect(this);</span>
<span class="pc bpc" id="L3130" title="1 of 2 branches missed.">      } else if (t instanceof GroundedTime) {</span>
<span class="nc" id="L3131">        return t.intersect(this);</span>
<span class="pc bpc" id="L3132" title="1 of 2 branches missed.">      } else if (t instanceof RelativeTime) {</span>
<span class="nc" id="L3133">        return t.intersect(this);</span>
      } else {
<span class="fc" id="L3135">        Time cpt = makeComposite(this, t);</span>
<span class="pc bpc" id="L3136" title="1 of 2 branches missed.">        if (cpt != null) {</span>
<span class="nc" id="L3137">          return cpt;</span>
        }
<span class="pc bpc" id="L3139" title="1 of 2 branches missed.">        if (t instanceof InexactTime) {</span>
<span class="fc" id="L3140">          return t.intersect(this);</span>
        }
      }
<span class="nc" id="L3143">      return null;</span>
      // return new RelativeTime(this, TemporalOp.INTERSECT, t);
    }

    /*public Temporal intersect(Temporal t) {
      if (t == null)
        return this;
      if (t == TIME_UNKNOWN || t == DURATION_UNKNOWN)
        return this;
      if (base == null)
        return t;
      if (t instanceof Time) {
        return intersect((Time) t);
      } else if (t instanceof Range) {
        return t.intersect(this);
      } else if (t instanceof Duration) {
        return new RelativeTime(this, TemporalOp.INTERSECT, t);
      }
      return null;
    }        */

    protected PartialTime addSupported(Period p, int scalar) {
<span class="fc" id="L3165">      return new PartialTime(base.withPeriodAdded(p, scalar));</span>
    }

    protected PartialTime addUnsupported(Period p, int scalar) {
<span class="fc" id="L3169">      return new PartialTime(this, JodaTimeUtils.addForce(base, p, scalar));</span>
    }

    @Override
    public Time add(Duration offset) {
<span class="pc bpc" id="L3174" title="1 of 2 branches missed.">      if (base == null) {</span>
<span class="nc" id="L3175">        return this;</span>
      }
<span class="fc" id="L3177">      Period per = offset.getJodaTimePeriod();</span>
<span class="fc" id="L3178">      PartialTime p = addSupported(per, 1);</span>
<span class="fc" id="L3179">      Period unsupported = JodaTimeUtils.getUnsupportedDurationPeriod(p.base, per);</span>
<span class="fc" id="L3180">      Time t = p;</span>
<span class="fc bfc" id="L3181" title="All 2 branches covered.">      if (unsupported != null) {</span>
<span class="pc bpc" id="L3182" title="1 of 4 branches missed.">        if (/*unsupported.size() == 1 &amp;&amp; */JodaTimeUtils.hasField(unsupported, DurationFieldType.weeks()) &amp;&amp; JodaTimeUtils.hasField(p.base, DateTimeFieldType.year())</span>
<span class="pc bpc" id="L3183" title="1 of 4 branches missed.">            &amp;&amp; JodaTimeUtils.hasField(p.base, DateTimeFieldType.monthOfYear()) &amp;&amp; JodaTimeUtils.hasField(p.base, DateTimeFieldType.dayOfMonth())) {</span>
          // What if there are other unsupported fields...
<span class="fc" id="L3185">          t = p.addUnsupported(per, 1);</span>
        } else {
<span class="pc bpc" id="L3187" title="2 of 6 branches missed.">          if (JodaTimeUtils.hasField(unsupported, DurationFieldType.months()) &amp;&amp; unsupported.getMonths() % 3 == 0 &amp;&amp; JodaTimeUtils.hasField(p.base, JodaTimeUtils.QuarterOfYear)) {</span>
<span class="fc" id="L3188">            Partial p2 = p.base.withFieldAddWrapped(JodaTimeUtils.Quarters, unsupported.getMonths() / 3);</span>
<span class="fc" id="L3189">            p = new PartialTime(p, p2);</span>
<span class="fc" id="L3190">            unsupported = unsupported.withMonths(0);</span>
          }
<span class="pc bpc" id="L3192" title="3 of 6 branches missed.">          if (JodaTimeUtils.hasField(unsupported, DurationFieldType.months()) &amp;&amp; unsupported.getMonths() % 6 == 0 &amp;&amp; JodaTimeUtils.hasField(p.base, JodaTimeUtils.HalfYearOfYear)) {</span>
<span class="nc" id="L3193">            Partial p2 = p.base.withFieldAddWrapped(JodaTimeUtils.HalfYears, unsupported.getMonths() / 6);</span>
<span class="nc" id="L3194">            p = new PartialTime(p, p2);</span>
<span class="nc" id="L3195">            unsupported = unsupported.withMonths(0);</span>
          }
<span class="pc bpc" id="L3197" title="3 of 6 branches missed.">          if (JodaTimeUtils.hasField(unsupported, DurationFieldType.years()) &amp;&amp; unsupported.getYears() % 10 == 0 &amp;&amp; JodaTimeUtils.hasField(p.base, JodaTimeUtils.DecadeOfCentury)) {</span>
<span class="nc" id="L3198">            Partial p2 = p.base.withFieldAddWrapped(JodaTimeUtils.Decades, unsupported.getYears() / 10);</span>
<span class="nc" id="L3199">            p = new PartialTime(p, p2);</span>
<span class="nc" id="L3200">            unsupported = unsupported.withYears(0);</span>
          }
<span class="pc bpc" id="L3202" title="2 of 4 branches missed.">          if (JodaTimeUtils.hasField(unsupported, DurationFieldType.years()) &amp;&amp; unsupported.getYears() % 100 == 0</span>
<span class="pc bpc" id="L3203" title="1 of 2 branches missed.">              &amp;&amp; JodaTimeUtils.hasField(p.base, DateTimeFieldType.centuryOfEra())) {</span>
<span class="nc" id="L3204">            Partial p2 = p.base.withField(DateTimeFieldType.centuryOfEra(), p.base.get(DateTimeFieldType.centuryOfEra()) + unsupported.getYears() / 100);</span>
<span class="nc" id="L3205">            p = new PartialTime(p, p2);</span>
<span class="nc" id="L3206">            unsupported = unsupported.withYears(0);</span>
          }
//          if (unsupported.getDays() != 0 &amp;&amp; !JodaTimeUtils.hasField(p.base, DateTimeFieldType.dayOfYear()) &amp;&amp; !JodaTimeUtils.hasField(p.base, DateTimeFieldType.dayOfMonth())
//              &amp;&amp; !JodaTimeUtils.hasField(p.base, DateTimeFieldType.dayOfWeek()) &amp;&amp; JodaTimeUtils.hasField(p.base, DateTimeFieldType.monthOfYear())) {
//            if (p.getGranularity().compareTo(DAY) &lt;= 0) {
//              // We are granular enough for this
//              Partial p2 = p.base.with(DateTimeFieldType.dayOfMonth(), unsupported.getDays());
//              p = new PartialTime(p, p2);
//              unsupported = unsupported.withDays(0);
//            }
//          }
<span class="fc bfc" id="L3217" title="All 2 branches covered.">          if (!unsupported.equals(Period.ZERO)) {</span>
<span class="fc" id="L3218">            t = new RelativeTime(p, new DurationWithFields(unsupported));</span>
<span class="fc" id="L3219">            t.approx = this.approx;</span>
<span class="fc" id="L3220">            t.mod = this.mod;</span>
          } else {
<span class="fc" id="L3222">            t = p;</span>
          }
        }
      }
<span class="fc" id="L3226">      return t;</span>
    }

    private static final long serialVersionUID = 1;
  }

  public static final int ERA_BC = 0;
  public static final int ERA_AD = 1;
  public static final int ERA_UNKNOWN = -1;
  /*
   * This is mostly a helper class but it is also the most standard type of date that people are
   * used to working with.
   */
  public static class IsoDate extends PartialTime {
    // TODO: We are also using this class for partial dates
    //       with just decade or century, but it is difficult
    //       to get that information out without using the underlying joda classes
    /** Era: BC is era 0, AD is era 1, Unknown is -1  */
<span class="pc" id="L3244">    public int era = ERA_UNKNOWN;</span>
    /** Year of Era */
<span class="pc" id="L3246">    public int year = -1;</span>
    /** Month of Year */
<span class="pc" id="L3248">    public int month = -1;</span>
    /** Day of Month */
<span class="pc" id="L3250">    public int day = -1;</span>

    public IsoDate(int y, int m, int d) {
<span class="fc" id="L3253">      this(null, y, m, d);</span>
<span class="fc" id="L3254">    }</span>

<span class="fc" id="L3256">    public IsoDate(StandardTemporalType temporalType, int y, int m, int d) {</span>
<span class="fc" id="L3257">      this.year = y;</span>
<span class="fc" id="L3258">      this.month = m;</span>
<span class="fc" id="L3259">      this.day = d;</span>
<span class="fc" id="L3260">      initBase();</span>
<span class="fc" id="L3261">      this.standardTemporalType = temporalType;</span>
<span class="fc" id="L3262">    }</span>

    // TODO: Added for grammar parsing
    public IsoDate(Number y, Number m, Number d) {
<span class="nc" id="L3266">      this(y,m,d,null,null);</span>
<span class="nc" id="L3267">    }</span>

<span class="nc" id="L3269">    public IsoDate(Number y, Number m, Number d, Number era, Boolean yearEraAdjustNeeded) {</span>
<span class="nc bnc" id="L3270" title="All 2 branches missed.">      this.year = (y != null)? y.intValue():-1;</span>
<span class="nc bnc" id="L3271" title="All 2 branches missed.">      this.month = (m != null)? m.intValue():-1;</span>
<span class="nc bnc" id="L3272" title="All 2 branches missed.">      this.day = (d != null)? d.intValue():-1;</span>
<span class="nc bnc" id="L3273" title="All 2 branches missed.">      this.era = (era != null)? era.intValue():ERA_UNKNOWN;</span>
<span class="nc bnc" id="L3274" title="All 6 branches missed.">      if (yearEraAdjustNeeded != null &amp;&amp; yearEraAdjustNeeded &amp;&amp; this.era == ERA_BC) {</span>
<span class="nc bnc" id="L3275" title="All 2 branches missed.">        if (this.year &gt; 0) {</span>
<span class="nc" id="L3276">          this.year--;</span>
        }
      }
<span class="nc" id="L3279">      initBase();</span>
<span class="nc" id="L3280">    }</span>


    // Assumes y, m, d are ISO formatted
<span class="nc" id="L3284">    public IsoDate(String y, String m, String d) {</span>
<span class="nc bnc" id="L3285" title="All 4 branches missed.">      if (y != null &amp;&amp; !PAD_FIELD_UNKNOWN4.equals(y)) {</span>
<span class="nc bnc" id="L3286" title="All 2 branches missed.">        if (!y.matches(&quot;[+-]?[0-9X]{4}&quot;)) {</span>
<span class="nc" id="L3287">          throw new IllegalArgumentException(&quot;Year not in ISO format &quot; + y);</span>
        }
<span class="nc bnc" id="L3289" title="All 2 branches missed.">        if (y.startsWith(&quot;-&quot;)) {</span>
<span class="nc" id="L3290">          y = y.substring(1);</span>
<span class="nc" id="L3291">          era = ERA_BC; // BC</span>
<span class="nc bnc" id="L3292" title="All 2 branches missed.">        } else if (y.startsWith(&quot;+&quot;)) {</span>
<span class="nc" id="L3293">          y = y.substring(1);</span>
<span class="nc" id="L3294">          era = ERA_AD; // AD</span>
        }
<span class="nc bnc" id="L3296" title="All 2 branches missed.">        if (y.contains(PAD_FIELD_UNKNOWN)) {</span>
        } else {
<span class="nc" id="L3298">          year = Integer.parseInt(y);</span>
        }
      } else {
<span class="nc" id="L3301">        y = PAD_FIELD_UNKNOWN4;</span>
      }
<span class="nc bnc" id="L3303" title="All 4 branches missed.">      if (m != null &amp;&amp; !PAD_FIELD_UNKNOWN2.equals(m)) {</span>
<span class="nc" id="L3304">        month = Integer.parseInt(m);</span>
      } else {
<span class="nc" id="L3306">        m = PAD_FIELD_UNKNOWN2;</span>
      }
<span class="nc bnc" id="L3308" title="All 4 branches missed.">      if (d != null &amp;&amp; !PAD_FIELD_UNKNOWN2.equals(d)) {</span>
<span class="nc" id="L3309">        day = Integer.parseInt(d);</span>
      } else {
<span class="nc" id="L3311">        d = PAD_FIELD_UNKNOWN2;</span>
      }

<span class="nc" id="L3314">      initBase();</span>
<span class="nc bnc" id="L3315" title="All 4 branches missed.">      if (year &lt; 0 &amp;&amp; !PAD_FIELD_UNKNOWN4.equals(y)) {</span>
<span class="nc bnc" id="L3316" title="All 4 branches missed.">        if (Character.isDigit(y.charAt(0)) &amp;&amp; Character.isDigit(y.charAt(1))) {</span>
<span class="nc" id="L3317">          int century = Integer.parseInt(y.substring(0, 2));</span>
<span class="nc" id="L3318">          base = JodaTimeUtils.setField(base, DateTimeFieldType.centuryOfEra(), century);</span>
        }
<span class="nc bnc" id="L3320" title="All 4 branches missed.">        if (Character.isDigit(y.charAt(2)) &amp;&amp; Character.isDigit(y.charAt(3))) {</span>
<span class="nc" id="L3321">          int cy = Integer.parseInt(y.substring(2, 4));</span>
<span class="nc" id="L3322">          base = JodaTimeUtils.setField(base, DateTimeFieldType.yearOfCentury(), cy);</span>
<span class="nc bnc" id="L3323" title="All 2 branches missed.">        } else if (Character.isDigit(y.charAt(2))) {</span>
<span class="nc" id="L3324">          int decade = Integer.parseInt(y.substring(2, 3));</span>
<span class="nc" id="L3325">          base = JodaTimeUtils.setField(base, JodaTimeUtils.DecadeOfCentury, decade);</span>
        }
      }
<span class="nc" id="L3328">    }</span>

    private void initBase() {
<span class="pc bpc" id="L3331" title="1 of 2 branches missed.">      if (era &gt;= 0 )</span>
<span class="nc" id="L3332">        base = JodaTimeUtils.setField(base, DateTimeFieldType.era(), era);</span>
<span class="fc bfc" id="L3333" title="All 2 branches covered.">      if (year &gt;= 0)</span>
<span class="fc" id="L3334">        base = JodaTimeUtils.setField(base, DateTimeFieldType.year(), year);</span>
<span class="pc bpc" id="L3335" title="1 of 2 branches missed.">      if (month &gt;= 0)</span>
<span class="fc" id="L3336">        base = JodaTimeUtils.setField(base, DateTimeFieldType.monthOfYear(), month);</span>
<span class="fc bfc" id="L3337" title="All 2 branches covered.">      if (day &gt;= 0)</span>
<span class="fc" id="L3338">        base = JodaTimeUtils.setField(base, DateTimeFieldType.dayOfMonth(), day);</span>
<span class="fc" id="L3339">    }</span>

    public String toString() {
      // TODO: is the right way to print this object?
<span class="nc" id="L3343">      StringBuilder os = new StringBuilder();</span>
<span class="nc bnc" id="L3344" title="All 2 branches missed.">      if (era == ERA_BC) {</span>
<span class="nc" id="L3345">        os.append(&quot;-&quot;);</span>
<span class="nc bnc" id="L3346" title="All 2 branches missed.">      } else if (era == ERA_AD) {</span>
<span class="nc" id="L3347">        os.append(&quot;+&quot;);</span>
      }
<span class="nc bnc" id="L3349" title="All 2 branches missed.">      if (year &gt;= 0)</span>
<span class="nc" id="L3350">        os.append(year);</span>
      else
<span class="nc" id="L3352">        os.append(&quot;XXXX&quot;);</span>
<span class="nc" id="L3353">      os.append(&quot;-&quot;);</span>
<span class="nc bnc" id="L3354" title="All 2 branches missed.">      if (month &gt;= 0)</span>
<span class="nc" id="L3355">        os.append(month);</span>
      else
<span class="nc" id="L3357">        os.append(&quot;XX&quot;);</span>
<span class="nc" id="L3358">      os.append(&quot;-&quot;);</span>
<span class="nc bnc" id="L3359" title="All 2 branches missed.">      if (day &gt;= 0)</span>
<span class="nc" id="L3360">        os.append(day);</span>
      else
<span class="nc" id="L3362">        os.append(&quot;XX&quot;);</span>
<span class="nc" id="L3363">      return os.toString();</span>
    }

    public int getYear() {
<span class="nc" id="L3367">      return year;</span>
    }

    // TODO: Should we allow setters??? Most time classes are immutable
    public void setYear(int y) {
<span class="nc" id="L3372">      this.year = y;</span>
<span class="nc" id="L3373">      initBase();</span>
<span class="nc" id="L3374">    }</span>

    public int getMonth() {
<span class="nc" id="L3377">      return month;</span>
    }

    // TODO: Should we allow setters??? Most time classes are immutable
    public void setMonth(int m) {
<span class="nc" id="L3382">      this.month = m;</span>
<span class="nc" id="L3383">      initBase();</span>
<span class="nc" id="L3384">    }</span>

    public int getDay() {
<span class="nc" id="L3387">      return day;</span>
    }

    // TODO: Should we allow setters??? Most time classes are immutable
    public void setDay(int d) {
<span class="nc" id="L3392">      this.day = d;</span>
<span class="nc" id="L3393">      initBase();</span>
<span class="nc" id="L3394">    }</span>

    // TODO: Should we allow setters??? Most time classes are immutable
    public void setDate(int y, int m, int d) {
<span class="nc" id="L3398">      this.year = y;</span>
<span class="nc" id="L3399">      this.month = m;</span>
<span class="nc" id="L3400">      this.day = d;</span>
<span class="nc" id="L3401">      initBase();</span>
<span class="nc" id="L3402">    }</span>

    private static final long serialVersionUID = 1;
  }

  public static final int HALFDAY_AM = 0;
  public static final int HALFDAY_PM = 1;
  public static final int HALFDAY_UNKNOWN = -1;

  // Helper time class
  protected static class IsoTime extends PartialTime {
<span class="pc" id="L3413">    public int hour = -1;</span>
<span class="pc" id="L3414">    public int minute = -1;</span>
<span class="pc" id="L3415">    public int second = -1;</span>
<span class="pc" id="L3416">    public int millis = -1;</span>
<span class="pc" id="L3417">    public int halfday = HALFDAY_UNKNOWN; // 0 = am, 1 = pm</span>

    public IsoTime(int h, int m, int s) {
<span class="fc" id="L3420">      this(h, m, s, -1, -1);</span>
<span class="fc" id="L3421">    }</span>

    // TODO: Added for reading types from file
    public IsoTime(Number h, Number m, Number s) {
<span class="nc" id="L3425">      this(h, m, s, null, null);</span>
<span class="nc" id="L3426">    }</span>

<span class="fc" id="L3428">    public IsoTime(int h, int m, int s, int ms, int halfday) {</span>
<span class="fc" id="L3429">      this.hour = h;</span>
<span class="fc" id="L3430">      this.minute = m;</span>
<span class="fc" id="L3431">      this.second = s;</span>
<span class="fc" id="L3432">      this.millis = ms;</span>
<span class="fc" id="L3433">      this.halfday = halfday;</span>
      // Some error checks
<span class="fc" id="L3435">      second += millis / 1000;</span>
<span class="fc" id="L3436">      millis = millis % 1000;</span>
<span class="fc" id="L3437">      minute += second / 60;</span>
<span class="fc" id="L3438">      second = second % 60;</span>
<span class="fc" id="L3439">      hour += hour / 60;</span>
<span class="fc" id="L3440">      minute = minute % 60;</span>
      // Error checks done
<span class="fc" id="L3442">      initBase();</span>
<span class="fc" id="L3443">    }</span>

    // TODO: Added for reading types from file
    public IsoTime(Number h, Number m, Number s, Number ms, Number halfday) {
<span class="nc bnc" id="L3447" title="All 2 branches missed.">      this(</span>
<span class="nc bnc" id="L3448" title="All 2 branches missed.">          (h != null)? h.intValue():-1,</span>
<span class="nc bnc" id="L3449" title="All 2 branches missed.">          (m != null)? m.intValue():-1,</span>
<span class="nc bnc" id="L3450" title="All 2 branches missed.">          (s != null)? s.intValue():-1,</span>
<span class="nc bnc" id="L3451" title="All 2 branches missed.">          (ms != null)? ms.intValue():-1,</span>
<span class="nc" id="L3452">          (halfday != null)? halfday.intValue():-1);</span>
<span class="nc" id="L3453">    }</span>

    public IsoTime(String h, String m, String s) {
<span class="nc" id="L3456">      this(h, m, s, null);</span>
<span class="nc" id="L3457">    }</span>

<span class="nc" id="L3459">    public IsoTime(String h, String m, String s, String ms) {</span>
<span class="nc bnc" id="L3460" title="All 2 branches missed.">      if (h != null) {</span>
<span class="nc" id="L3461">        hour = Integer.parseInt(h);</span>
      }
<span class="nc bnc" id="L3463" title="All 2 branches missed.">      if (m != null) {</span>
<span class="nc" id="L3464">        minute = Integer.parseInt(m);</span>
      }
<span class="nc bnc" id="L3466" title="All 2 branches missed.">      if (s != null) {</span>
<span class="nc" id="L3467">        second = Integer.parseInt(s);</span>
      }
<span class="nc bnc" id="L3469" title="All 2 branches missed.">      if (ms != null) {</span>
<span class="nc" id="L3470">        millis = Integer.parseInt(s);</span>
      }
<span class="nc" id="L3472">      initBase();</span>
<span class="nc" id="L3473">    }</span>

    @Override
    public boolean hasTime() {
<span class="fc" id="L3477">      return true;</span>
    }

    private void initBase() {
<span class="pc bpc" id="L3481" title="1 of 2 branches missed.">      if (hour &gt;= 0) {</span>
<span class="pc bpc" id="L3482" title="1 of 2 branches missed.">        if (hour &lt; 24) {</span>
<span class="fc" id="L3483">          base = JodaTimeUtils.setField(base, DateTimeFieldType.hourOfDay(), hour);</span>
        } else {
<span class="nc" id="L3485">          base = JodaTimeUtils.setField(base, DateTimeFieldType.clockhourOfDay(), hour);</span>
        }
      }
<span class="pc bpc" id="L3488" title="1 of 2 branches missed.">      if (minute &gt;= 0)</span>
<span class="fc" id="L3489">        base = JodaTimeUtils.setField(base, DateTimeFieldType.minuteOfHour(), minute);</span>
<span class="pc bpc" id="L3490" title="1 of 2 branches missed.">      if (second &gt;= 0)</span>
<span class="nc" id="L3491">        base = JodaTimeUtils.setField(base, DateTimeFieldType.secondOfMinute(), second);</span>
<span class="pc bpc" id="L3492" title="1 of 2 branches missed.">      if (millis &gt;= 0)</span>
<span class="nc" id="L3493">        base = JodaTimeUtils.setField(base, DateTimeFieldType.millisOfSecond(), millis);</span>
<span class="pc bpc" id="L3494" title="1 of 2 branches missed.">      if (halfday &gt;= 0) {</span>
<span class="nc" id="L3495">        base = JodaTimeUtils.setField(base, DateTimeFieldType.halfdayOfDay(), halfday);</span>
      }
<span class="fc" id="L3497">    }</span>
    private static final long serialVersionUID = 1;
  }


  protected static class IsoDateTime extends PartialTime {
    private final IsoDate date;
    private final IsoTime time;

<span class="nc" id="L3506">    public IsoDateTime(IsoDate date, IsoTime time) {</span>
<span class="nc" id="L3507">      this.date = date;</span>
<span class="nc" id="L3508">      this.time = time;</span>
<span class="nc" id="L3509">      base = JodaTimeUtils.combine(date.base, time.base);</span>
<span class="nc" id="L3510">    }</span>

    @Override
    public boolean hasTime() {
<span class="nc bnc" id="L3514" title="All 2 branches missed.">      return (time != null);</span>
    }

    /*    public String toISOString()
        {
          return date.toISOString() + time.toISOString();
        }  */

    private static final long serialVersionUID = 1;
  }

  // TODO: Timezone...
<span class="fc" id="L3526">  private static final Pattern PATTERN_ISO = Pattern.compile(&quot;(\\d\\d\\d\\d)-?(\\d\\d?)-?(\\d\\d?)(-?(?:T(\\d\\d):?(\\d\\d)?:?(\\d\\d)?(?:[.,](\\d{1,3}))?([+-]\\d\\d:?\\d\\d)?))?&quot;);</span>
<span class="fc" id="L3527">  private static final Pattern PATTERN_ISO_DATETIME = Pattern.compile(&quot;(\\d\\d\\d\\d)(\\d\\d)(\\d\\d):(\\d\\d)(\\d\\d)&quot;);</span>
<span class="fc" id="L3528">  private static final Pattern PATTERN_ISO_TIME = Pattern.compile(&quot;T(\\d\\d):?(\\d\\d)?:?(\\d\\d)?(?:[.,](\\d{1,3}))?([+-]\\d\\d:?\\d\\d)?&quot;);</span>
<span class="fc" id="L3529">  private static final Pattern PATTERN_ISO_DATE_1 = Pattern.compile(&quot;.*(\\d\\d\\d\\d)\\/(\\d\\d?)\\/(\\d\\d?).*&quot;);</span>
<span class="fc" id="L3530">  private static final Pattern PATTERN_ISO_DATE_2 = Pattern.compile(&quot;.*(\\d\\d\\d\\d)\\-(\\d\\d?)\\-(\\d\\d?).*&quot;);</span>
<span class="fc" id="L3531">  private static final Pattern PATTERN_ISO_DATE_PARTIAL = Pattern.compile(&quot;([0-9X]{4})[-]?([0-9X][0-9X])[-]?([0-9X][0-9X])&quot;);</span>

  // Ambiguous pattern - interpret as MM/DD/YY(YY)
<span class="fc" id="L3534">  private static final Pattern PATTERN_ISO_AMBIGUOUS_1 = Pattern.compile(&quot;.*(\\d\\d?)\\/(\\d\\d?)\\/(\\d\\d(\\d\\d)?).*&quot;);</span>

  // Ambiguous pattern - interpret as MM-DD-YY(YY)
<span class="fc" id="L3537">  private static final Pattern PATTERN_ISO_AMBIGUOUS_2 = Pattern.compile(&quot;.*(\\d\\d?)\\-(\\d\\d?)\\-(\\d\\d(\\d\\d)?).*&quot;);</span>

  // Euro date
  // Ambiguous pattern - interpret as DD.MM.YY(YY)
<span class="fc" id="L3541">  private static final Pattern PATTERN_ISO_AMBIGUOUS_3 = Pattern.compile(&quot;.*(\\d\\d?)\\.(\\d\\d?)\\.(\\d\\d(\\d\\d)?).*&quot;);</span>
<span class="fc" id="L3542">  private static final Pattern PATTERN_ISO_TIME_OF_DAY = Pattern.compile(&quot;.*(\\d?\\d):(\\d\\d)(:(\\d\\d)(\\.\\d+)?)?(\\s*([AP])\\.?M\\.?)?(\\s+([+\\-]\\d+|[A-Z][SD]T|GMT([+\\-]\\d+)?))?.*&quot;);</span>

  /**
   * Converts a string that represents some kind of date into ISO 8601 format and
   *  returns it as a SUTime.Time
   *   YYYYMMDDThhmmss
   *
   * @param dateStr
   * @param allowPartial (allow partial ISO)
   */
  public static SUTime.Time parseDateTime(String dateStr, boolean allowPartial)
  {
<span class="nc bnc" id="L3554" title="All 2 branches missed.">    if (dateStr == null) return null;</span>

<span class="nc" id="L3556">    Matcher m = PATTERN_ISO.matcher(dateStr);</span>
<span class="nc bnc" id="L3557" title="All 2 branches missed.">    if (m.matches()) {</span>
<span class="nc" id="L3558">      String time = m.group(4);</span>
<span class="nc" id="L3559">      SUTime.IsoDate isoDate = new SUTime.IsoDate(m.group(1), m.group(2), m.group(3));</span>
<span class="nc bnc" id="L3560" title="All 2 branches missed.">      if (time != null) {</span>
<span class="nc" id="L3561">        SUTime.IsoTime isoTime = new SUTime.IsoTime(m.group(5), m.group(6), m.group(7), m.group(8));</span>
<span class="nc" id="L3562">        return new SUTime.IsoDateTime(isoDate,isoTime);</span>
      } else {
<span class="nc" id="L3564">        return isoDate;</span>
      }
    }

<span class="nc" id="L3568">    m = PATTERN_ISO_DATETIME.matcher(dateStr);</span>
<span class="nc bnc" id="L3569" title="All 2 branches missed.">    if (m.matches()) {</span>
<span class="nc" id="L3570">      SUTime.IsoDate date = new SUTime.IsoDate(m.group(1), m.group(2), m.group(3));</span>
<span class="nc" id="L3571">      SUTime.IsoTime time = new SUTime.IsoTime(m.group(4), m.group(5), null);</span>
<span class="nc" id="L3572">      return new SUTime.IsoDateTime(date,time);</span>
    }

<span class="nc" id="L3575">    m = PATTERN_ISO_TIME.matcher(dateStr);</span>
<span class="nc bnc" id="L3576" title="All 2 branches missed.">    if (m.matches()) {</span>
<span class="nc" id="L3577">      return new SUTime.IsoTime(m.group(1), m.group(2), m.group(3), m.group(4));</span>
    }

<span class="nc" id="L3580">    SUTime.IsoDate isoDate = null;</span>
<span class="nc bnc" id="L3581" title="All 2 branches missed.">    if (isoDate == null) {</span>
<span class="nc" id="L3582">      m = PATTERN_ISO_DATE_1.matcher(dateStr);</span>

<span class="nc bnc" id="L3584" title="All 2 branches missed.">      if (m.matches()) {</span>
<span class="nc" id="L3585">        isoDate = new SUTime.IsoDate(m.group(1), m.group(2), m.group(3));</span>
      }
    }

<span class="nc bnc" id="L3589" title="All 2 branches missed.">    if (isoDate == null) {</span>
<span class="nc" id="L3590">      m = PATTERN_ISO_DATE_2.matcher(dateStr);</span>
<span class="nc bnc" id="L3591" title="All 2 branches missed.">      if (m.matches()) {</span>
<span class="nc" id="L3592">        isoDate = new SUTime.IsoDate(m.group(1), m.group(2), m.group(3));</span>
      }
    }

<span class="nc bnc" id="L3596" title="All 2 branches missed.">    if (allowPartial) {</span>
<span class="nc" id="L3597">      m = PATTERN_ISO_DATE_PARTIAL.matcher(dateStr);</span>
<span class="nc bnc" id="L3598" title="All 2 branches missed.">      if (m.matches()) {</span>
<span class="nc bnc" id="L3599" title="All 6 branches missed.">        if (!(m.group(1).equals(&quot;XXXX&quot;) &amp;&amp; m.group(2).equals(&quot;XX&quot;) &amp;&amp; m.group(3).equals(&quot;XX&quot;))) {</span>
<span class="nc" id="L3600">          isoDate = new SUTime.IsoDate(m.group(1), m.group(2), m.group(3));</span>
        }
      }
    }

<span class="nc bnc" id="L3605" title="All 2 branches missed.">    if (isoDate == null) {</span>
<span class="nc" id="L3606">      m = PATTERN_ISO_AMBIGUOUS_1.matcher(dateStr);</span>

<span class="nc bnc" id="L3608" title="All 2 branches missed.">      if (m.matches()) {</span>
<span class="nc" id="L3609">        isoDate = new SUTime.IsoDate(m.group(3), m.group(1), m.group(2));</span>
      }
    }

<span class="nc bnc" id="L3613" title="All 2 branches missed.">    if (isoDate == null) {</span>
<span class="nc" id="L3614">      m = PATTERN_ISO_AMBIGUOUS_2.matcher(dateStr);</span>
<span class="nc bnc" id="L3615" title="All 2 branches missed.">      if (m.matches()) {</span>
<span class="nc" id="L3616">        isoDate = new SUTime.IsoDate(m.group(3), m.group(1), m.group(2));</span>
      }
    }

<span class="nc bnc" id="L3620" title="All 2 branches missed.">    if (isoDate == null) {</span>
<span class="nc" id="L3621">      m = PATTERN_ISO_AMBIGUOUS_3.matcher(dateStr);</span>
<span class="nc bnc" id="L3622" title="All 2 branches missed.">      if (m.matches()) {</span>
<span class="nc" id="L3623">        isoDate = new SUTime.IsoDate(m.group(3), m.group(2), m.group(1));</span>
      }
    }

    // Now add Time of Day
<span class="nc" id="L3628">    SUTime.IsoTime isoTime = null;</span>
<span class="nc bnc" id="L3629" title="All 2 branches missed.">    if (isoTime == null) {</span>
<span class="nc" id="L3630">      m = PATTERN_ISO_TIME_OF_DAY.matcher(dateStr);</span>
<span class="nc bnc" id="L3631" title="All 2 branches missed.">      if (m.matches()) {</span>
        // TODO: Fix
<span class="nc" id="L3633">        isoTime = new SUTime.IsoTime(m.group(1), m.group(2), m.group(4));</span>
      }
    }

<span class="nc bnc" id="L3637" title="All 4 branches missed.">    if (isoDate != null &amp;&amp; isoTime != null) {</span>
<span class="nc" id="L3638">      return new SUTime.IsoDateTime(isoDate, isoTime);</span>
<span class="nc bnc" id="L3639" title="All 2 branches missed.">    } else if (isoDate != null) {</span>
<span class="nc" id="L3640">      return isoDate;</span>
    } else {
<span class="nc" id="L3642">      return isoTime;</span>
    }
  }

  public static SUTime.Time parseDateTime(String dateStr) {
<span class="nc" id="L3647">    return parseDateTime(dateStr, false);</span>
  }

  public static class GroundedTime extends Time {
    // Represents an absolute time
    ReadableInstant base;

    public GroundedTime(Time p, ReadableInstant base) {
<span class="nc" id="L3655">      super(p);</span>
<span class="nc" id="L3656">      this.base = base;</span>
<span class="nc" id="L3657">    }</span>

<span class="nc" id="L3659">    public GroundedTime(ReadableInstant base) {</span>
<span class="nc" id="L3660">      this.base = base;</span>
<span class="nc" id="L3661">    }</span>

    @Override
    public GroundedTime setTimeZone(DateTimeZone tz) {
<span class="nc" id="L3665">      MutableDateTime tzBase = base.toInstant().toMutableDateTime();</span>
<span class="nc" id="L3666">      tzBase.setZone(tz);           // TODO: setZoneRetainFields?</span>
<span class="nc" id="L3667">      return new GroundedTime(this, tzBase);</span>
    }

    @Override
    public boolean hasTime() {
<span class="nc" id="L3672">      return true;</span>
    }

    @Override
    public boolean isGrounded() {
<span class="nc" id="L3677">      return true;</span>
    }

    @Override
    public Duration getDuration() {
<span class="nc" id="L3682">      return DURATION_NONE;</span>
    }

    @Override
    public Range getRange(int flags, Duration granularity) {
<span class="nc" id="L3687">      return new Range(this, this);</span>
    }

    @Override
    public String toFormattedString(int flags) {
<span class="nc" id="L3692">      return base.toString();</span>
    }

    @Override
    public Time resolve(Time refTime, int flags) {
<span class="nc" id="L3697">      return this;</span>
    }

    @Override
    public Time add(Duration offset) {
<span class="nc" id="L3702">      Period p = offset.getJodaTimePeriod();</span>
<span class="nc" id="L3703">      GroundedTime g = new GroundedTime(base.toInstant().withDurationAdded(p.toDurationFrom(base), 1));</span>
<span class="nc" id="L3704">      g.approx = this.approx;</span>
<span class="nc" id="L3705">      g.mod = this.mod;</span>
<span class="nc" id="L3706">      return g;</span>
    }

    @Override
    public Time intersect(Time t) {
<span class="nc bnc" id="L3711" title="All 2 branches missed.">      if (t.getRange().contains(this.getRange())) {</span>
<span class="nc" id="L3712">        return this;</span>
      } else {
<span class="nc" id="L3714">        return null;</span>
      }
    }

    @Override
    public Temporal intersect(Temporal other) {
<span class="nc bnc" id="L3720" title="All 2 branches missed.">      if (other == null)</span>
<span class="nc" id="L3721">        return this;</span>
<span class="nc bnc" id="L3722" title="All 2 branches missed.">      if (other == TIME_UNKNOWN)</span>
<span class="nc" id="L3723">        return this;</span>
<span class="nc bnc" id="L3724" title="All 2 branches missed.">      if (other.getRange().contains(this.getRange())) {</span>
<span class="nc" id="L3725">        return this;</span>
      } else {
<span class="nc" id="L3727">        return null;</span>
      }
    }

    @Override
    public Instant getJodaTimeInstant() {
<span class="nc" id="L3733">      return base.toInstant();</span>
    }

    @Override
    public Partial getJodaTimePartial() {
<span class="nc" id="L3738">      return JodaTimeUtils.getPartial(base.toInstant(), JodaTimeUtils.EMPTY_ISO_PARTIAL);</span>
    }

    private static final long serialVersionUID = 1;
  }

  // Duration classes
  /**
   * A Duration represents a period of time (without endpoints).
   * &lt;br&gt;
   * We have 3 types of durations:
   * &lt;ol&gt;
   * &lt;li&gt; DurationWithFields - corresponds to JodaTime Period,
   * where we have fields like hours, weeks, etc &lt;/li&gt;
   * &lt;li&gt; DurationWithMillis -
   * corresponds to JodaTime Duration, where the duration is specified in millis
   * this gets rid of certain ambiguities such as a month with can be 28, 30, or
   * 31 days &lt;/li&gt;
   * &lt;li&gt;InexactDuration - duration that is under determined (like a few
   * days)&lt;/li&gt;
   * &lt;/ol&gt;
   */
  public abstract static class Duration extends Temporal implements FuzzyInterval.FuzzyComparable&lt;Duration&gt; {

<span class="fc" id="L3762">    public Duration() {</span>
<span class="fc" id="L3763">    }</span>

    public Duration(Duration d) {
<span class="nc" id="L3766">      super(d);</span>
<span class="nc" id="L3767">    }</span>

    public static Duration getDuration(ReadablePeriod p) {
<span class="fc" id="L3770">      return new DurationWithFields(p);</span>
    }

    public static Duration getDuration(org.joda.time.Duration d) {
<span class="nc" id="L3774">      return new DurationWithMillis(d);</span>
    }

    public static Duration getInexactDuration(ReadablePeriod p) {
<span class="nc" id="L3778">      return new InexactDuration(p);</span>
    }

    public static Duration getInexactDuration(org.joda.time.Duration d) {
<span class="nc" id="L3782">      return new InexactDuration(d.toPeriod());</span>
    }

    // Returns the inexact version of the duration
    public InexactDuration makeInexact() {
<span class="fc" id="L3787">      return new InexactDuration(getJodaTimePeriod());</span>
    }

    public DateTimeFieldType[] getDateTimeFields() {
<span class="fc" id="L3791">      return null;</span>
    }

    @Override
    public boolean isGrounded() {
<span class="nc" id="L3796">      return false;</span>
    }

    @Override
    public Time getTime() {
<span class="nc" id="L3801">      return null;</span>
    } // There is no time associated with a duration?

    public Time toTime(Time refTime) {
<span class="nc" id="L3805">      return toTime(refTime, 0);</span>
    }

    public Time toTime(Time refTime, int flags) {
      // if ((flags &amp; (DUR_RESOLVE_FROM_AS_REF | DUR_RESOLVE_TO_AS_REF)) == 0)
      {
<span class="fc" id="L3811">        Partial p = refTime.getJodaTimePartial();</span>
<span class="pc bpc" id="L3812" title="1 of 2 branches missed.">        if (p != null) {</span>
          // For durations that have corresponding date time fields
          // this = current time without more specific fields than the duration
<span class="fc" id="L3815">          DateTimeFieldType[] dtFieldTypes = getDateTimeFields();</span>
<span class="fc bfc" id="L3816" title="All 2 branches covered.">          if (dtFieldTypes != null) {</span>
<span class="fc" id="L3817">            Time t = null;</span>
<span class="fc bfc" id="L3818" title="All 2 branches covered.">            for (DateTimeFieldType dtft : dtFieldTypes) {</span>
<span class="fc bfc" id="L3819" title="All 2 branches covered.">              if (p.isSupported(dtft)) {</span>
<span class="fc" id="L3820">                t = new PartialTime(JodaTimeUtils.discardMoreSpecificFields(p, dtft));</span>
              }
            }
<span class="fc bfc" id="L3823" title="All 2 branches covered.">            if (t == null) {</span>
<span class="fc" id="L3824">              Instant instant = refTime.getJodaTimeInstant();</span>
<span class="pc bpc" id="L3825" title="1 of 2 branches missed.">              if (instant != null) {</span>
<span class="fc bfc" id="L3826" title="All 2 branches covered.">                for (DateTimeFieldType dtft : dtFieldTypes) {</span>
<span class="pc bpc" id="L3827" title="1 of 2 branches missed.">                  if (instant.isSupported(dtft)) {</span>
<span class="fc" id="L3828">                    Partial p2 = JodaTimeUtils.getPartial(instant, p.with(dtft, 1));</span>
<span class="fc" id="L3829">                    t = new PartialTime(JodaTimeUtils.discardMoreSpecificFields(p2, dtft));</span>
                  }
                }
              }
            }
<span class="pc bpc" id="L3834" title="1 of 2 branches missed.">            if (t != null) {</span>
<span class="pc bpc" id="L3835" title="1 of 2 branches missed.">              if ((flags &amp; RESOLVE_TO_PAST) != 0) {</span>
                // Check if this time is in the past, if not, subtract duration
<span class="nc bnc" id="L3837" title="All 2 branches missed.">                if (t.compareTo(refTime) &gt;= 0) {</span>
<span class="nc" id="L3838">                  return t.subtract(this);</span>
                }
<span class="pc bpc" id="L3840" title="1 of 2 branches missed.">              } else if ((flags &amp; RESOLVE_TO_FUTURE) != 0) {</span>
                // Check if this time is in the future, if not, subtract
                // duration
<span class="nc bnc" id="L3843" title="All 2 branches missed.">                if (t.compareTo(refTime) &lt;= 0) {</span>
<span class="nc" id="L3844">                  return t.add(this);</span>
                }
              }
            }
<span class="fc" id="L3848">            return t;</span>
          }
        }
      }
<span class="fc" id="L3852">      Time minTime = refTime.subtract(this);</span>
<span class="fc" id="L3853">      Time maxTime = refTime.add(this);</span>
<span class="fc" id="L3854">      Range likelyRange = null;</span>
<span class="pc bpc" id="L3855" title="1 of 2 branches missed.">      if ((flags &amp; (DUR_RESOLVE_FROM_AS_REF | RESOLVE_TO_FUTURE)) != 0) {</span>
<span class="nc" id="L3856">        likelyRange = new Range(refTime, maxTime, this);</span>
<span class="fc bfc" id="L3857" title="All 2 branches covered.">      } else if ((flags &amp; (DUR_RESOLVE_TO_AS_REF | RESOLVE_TO_PAST)) != 0) {</span>
<span class="fc" id="L3858">        likelyRange = new Range(minTime, refTime, this);</span>
      } else {
<span class="fc" id="L3860">        Duration halfDuration = this.divideBy(2);</span>
<span class="fc" id="L3861">        likelyRange = new Range(refTime.subtract(halfDuration), refTime.add(halfDuration), this);</span>
      }
<span class="fc" id="L3863">      return new TimeWithRange(likelyRange);</span>
//      if ((flags &amp; (RESOLVE_TO_FUTURE | RESOLVE_TO_PAST)) != 0) {
//        return new TimeWithRange(likelyRange);
//      }
//      Range r = new Range(minTime, maxTime, this.multiplyBy(2));
//      return new InexactTime(new TimeWithRange(likelyRange), this, r);
    }

    @Override
    public Duration getDuration() {
<span class="nc" id="L3873">      return this;</span>
    }

    @Override
    public Range getRange(int flags, Duration granularity) {
<span class="nc" id="L3878">      return new Range(null, null, this);</span>
    } // Unanchored range

    @Override
    public TimexType getTimexType() {
<span class="nc" id="L3883">      return TimexType.DURATION;</span>
    }

    public abstract Period getJodaTimePeriod();

    public abstract org.joda.time.Duration getJodaTimeDuration();

    @Override
    public String toFormattedString(int flags) {
<span class="pc bpc" id="L3892" title="1 of 2 branches missed.">      if (getTimeLabel() != null) {</span>
<span class="nc" id="L3893">        return getTimeLabel();</span>
      }
<span class="fc" id="L3895">      Period p = getJodaTimePeriod();</span>
<span class="pc bpc" id="L3896" title="1 of 2 branches missed.">      String s = (p != null) ? p.toString() : &quot;PXX&quot;;</span>
<span class="fc bfc" id="L3897" title="All 2 branches covered.">      if ((flags &amp; (FORMAT_ISO | FORMAT_TIMEX3_VALUE)) == 0) {</span>
<span class="fc" id="L3898">        String m = getMod();</span>
<span class="pc bpc" id="L3899" title="1 of 2 branches missed.">        if (m != null) {</span>
          try {
<span class="nc" id="L3901">            TimexMod tm = TimexMod.valueOf(m);</span>
<span class="nc bnc" id="L3902" title="All 2 branches missed.">            if (tm.getSymbol() != null) {</span>
<span class="nc" id="L3903">              s = tm.getSymbol() + s;</span>
            }
<span class="nc" id="L3905">          } catch (Exception ex) {</span>
<span class="nc" id="L3906">          }</span>
        }
      }
<span class="fc" id="L3909">      return s;</span>
    }

    @Override
    public Duration getPeriod() {
  /*    TimeLabel tl = getTimeLabel();
      if (tl != null) {
        return tl.getPeriod();
      } */
<span class="fc" id="L3918">      StandardTemporalType tlt = getStandardTemporalType();</span>
<span class="pc bpc" id="L3919" title="1 of 2 branches missed.">      if (tlt != null) {</span>
<span class="nc" id="L3920">        return tlt.getPeriod();</span>
      }
<span class="fc" id="L3922">      return this;</span>
    }

    // Rough approximate ordering of durations
    @Override
    public int compareTo(Duration d) {
<span class="fc" id="L3928">      org.joda.time.Duration d1 = getJodaTimeDuration();</span>
<span class="fc" id="L3929">      org.joda.time.Duration d2 = d.getJodaTimeDuration();</span>
<span class="pc bpc" id="L3930" title="3 of 4 branches missed.">      if (d1 == null &amp;&amp; d2 == null) {</span>
<span class="nc" id="L3931">        return 0;</span>
<span class="pc bpc" id="L3932" title="1 of 2 branches missed.">      } else if (d1 == null) {</span>
<span class="nc" id="L3933">        return 1;</span>
<span class="pc bpc" id="L3934" title="1 of 2 branches missed.">      } else if (d2 == null) {</span>
<span class="nc" id="L3935">        return -1;</span>
      }

<span class="fc" id="L3938">      int cmp = d1.compareTo(d2);</span>
<span class="fc bfc" id="L3939" title="All 2 branches covered.">      if (cmp == 0) {</span>
<span class="pc bpc" id="L3940" title="3 of 4 branches missed.">        if (d.isApprox() &amp;&amp; !this.isApprox()) {</span>
          // Put exact in front of approx
<span class="nc" id="L3942">          return -1;</span>
<span class="pc bpc" id="L3943" title="2 of 4 branches missed.">        } else if (!d.isApprox() &amp;&amp; this.isApprox()) {</span>
<span class="nc" id="L3944">          return 1;</span>
        } else {
<span class="fc" id="L3946">          return 0;</span>
        }
      } else {
<span class="fc" id="L3949">        return cmp;</span>
      }
    }

    @Override
    public boolean isComparable(Duration d) {
      // TODO: When is two durations comparable?
<span class="fc" id="L3956">      return true;</span>
    }

    // Operations with durations
    public abstract Duration add(Duration d);

    public abstract Duration multiplyBy(int m);

    public abstract Duration divideBy(int m);

    public Duration subtract(Duration d) {
<span class="nc" id="L3967">      return add(d.multiplyBy(-1));</span>
    }

    @Override
    public Duration resolve(Time refTime, int flags) {
<span class="nc" id="L3972">      return this;</span>
    }

    @Override
    public Temporal intersect(Temporal t) {
<span class="nc bnc" id="L3977" title="All 2 branches missed.">      if (t == null)</span>
<span class="nc" id="L3978">        return this;</span>
<span class="nc bnc" id="L3979" title="All 4 branches missed.">      if (t == TIME_UNKNOWN || t == DURATION_UNKNOWN)</span>
<span class="nc" id="L3980">        return this;</span>
<span class="nc bnc" id="L3981" title="All 2 branches missed.">      if (t instanceof Time) {</span>
<span class="nc" id="L3982">        RelativeTime rt = new RelativeTime((Time) t, TemporalOp.INTERSECT, this);</span>
<span class="nc" id="L3983">        rt = (RelativeTime) rt.addMod(this.getMod());</span>
<span class="nc" id="L3984">        return rt;</span>
<span class="nc bnc" id="L3985" title="All 2 branches missed.">      } else if (t instanceof Range) {</span>
        // return new TemporalSet(t, TemporalOp.INTERSECT, this);
<span class="nc bnc" id="L3987" title="All 2 branches missed.">      } else if (t instanceof Duration) {</span>
<span class="nc" id="L3988">        Duration d = (Duration) t;</span>
<span class="nc" id="L3989">        return intersect(d);</span>
      }
<span class="nc" id="L3991">      return null;</span>
    }

    public Duration intersect(Duration d) {
<span class="nc bnc" id="L3995" title="All 4 branches missed.">      if (d == null || d == DURATION_UNKNOWN)</span>
<span class="nc" id="L3996">        return this;</span>
<span class="nc" id="L3997">      int cmp = compareTo(d);</span>
<span class="nc bnc" id="L3998" title="All 2 branches missed.">      if (cmp &lt; 0) {</span>
<span class="nc" id="L3999">        return this;</span>
      } else {
<span class="nc" id="L4001">        return d;</span>
      }
    }

    public static Duration min(Duration d1, Duration d2) {
<span class="nc bnc" id="L4006" title="All 2 branches missed.">      if (d2 == null)</span>
<span class="nc" id="L4007">        return d1;</span>
<span class="nc bnc" id="L4008" title="All 2 branches missed.">      if (d1 == null)</span>
<span class="nc" id="L4009">        return d2;</span>
<span class="nc bnc" id="L4010" title="All 2 branches missed.">      if (d1.isComparable(d2)) {</span>
<span class="nc" id="L4011">        int c = d1.compareTo(d2);</span>
<span class="nc bnc" id="L4012" title="All 2 branches missed.">        return (c &lt; 0) ? d1 : d2;</span>
      }
<span class="nc" id="L4014">      return d1;</span>
    }

    public static Duration max(Duration d1, Duration d2) {
<span class="pc bpc" id="L4018" title="1 of 2 branches missed.">      if (d1 == null)</span>
<span class="nc" id="L4019">        return d2;</span>
<span class="pc bpc" id="L4020" title="1 of 2 branches missed.">      if (d2 == null)</span>
<span class="nc" id="L4021">        return d1;</span>
<span class="pc bpc" id="L4022" title="1 of 2 branches missed.">      if (d1.isComparable(d2)) {</span>
<span class="fc" id="L4023">        int c = d1.compareTo(d2);</span>
<span class="pc bpc" id="L4024" title="1 of 2 branches missed.">        return (c &gt;= 0) ? d1 : d2;</span>
      }
<span class="nc" id="L4026">      return d2;</span>
    }

    private static final long serialVersionUID = 1;
  }

  /**
   * Duration that is specified using fields such as milliseconds, days, etc.
   */
  public static class DurationWithFields extends Duration {
    // Use Inexact duration to be able to specify duration with uncertain number
    // Like a few years
    ReadablePeriod period;

<span class="fc" id="L4040">    public DurationWithFields() {</span>
<span class="fc" id="L4041">      this.period = null;</span>
<span class="fc" id="L4042">    }</span>

<span class="fc" id="L4044">    public DurationWithFields(ReadablePeriod period) {</span>
<span class="fc" id="L4045">      this.period = period;</span>
<span class="fc" id="L4046">    }</span>

    public DurationWithFields(Duration d, ReadablePeriod period) {
<span class="nc" id="L4049">      super(d);</span>
<span class="nc" id="L4050">      this.period = period;</span>
<span class="nc" id="L4051">    }</span>

    @Override
    public Duration multiplyBy(int m) {
<span class="pc bpc" id="L4055" title="1 of 4 branches missed.">      if (m == 1 || period == null) {</span>
<span class="fc" id="L4056">        return this;</span>
      } else {
<span class="fc" id="L4058">        MutablePeriod p = period.toMutablePeriod();</span>
<span class="fc bfc" id="L4059" title="All 2 branches covered.">        for (int i = 0; i &lt; period.size(); i++) {</span>
<span class="fc" id="L4060">          p.setValue(i, period.getValue(i) * m);</span>
        }
<span class="fc" id="L4062">        return new DurationWithFields(p);</span>
      }
    }

    @Override
    public Duration divideBy(int m) {
<span class="pc bpc" id="L4068" title="2 of 4 branches missed.">      if (m == 1 || period == null) {</span>
<span class="nc" id="L4069">        return this;</span>
      } else {
<span class="fc" id="L4071">        MutablePeriod p = new MutablePeriod();</span>
<span class="fc bfc" id="L4072" title="All 2 branches covered.">        for (int i = 0; i &lt; period.size(); i++) {</span>
<span class="fc" id="L4073">          int oldVal = period.getValue(i);</span>
<span class="fc" id="L4074">          DurationFieldType field = period.getFieldType(i);</span>
<span class="fc" id="L4075">          int remainder = oldVal % m;</span>
<span class="fc" id="L4076">          p.add(field, oldVal - remainder);</span>
<span class="fc bfc" id="L4077" title="All 2 branches covered.">          if (remainder != 0) {</span>
            DurationFieldType f;
<span class="fc" id="L4079">            int standardUnit = 1;</span>
            // TODO: This seems silly, how to do this with jodatime???
<span class="pc bpc" id="L4081" title="1 of 2 branches missed.">            if (DurationFieldType.centuries().equals(field)) {</span>
<span class="nc" id="L4082">              f = DurationFieldType.years();</span>
<span class="nc" id="L4083">              standardUnit = 100;</span>
<span class="pc bpc" id="L4084" title="1 of 2 branches missed.">            } else if (DurationFieldType.years().equals(field)) {</span>
<span class="nc" id="L4085">              f = DurationFieldType.months();</span>
<span class="nc" id="L4086">              standardUnit = 12;</span>
<span class="pc bpc" id="L4087" title="1 of 2 branches missed.">            } else if (DurationFieldType.halfdays().equals(field)) {</span>
<span class="nc" id="L4088">              f = DurationFieldType.hours();</span>
<span class="nc" id="L4089">              standardUnit = 12;</span>
<span class="pc bpc" id="L4090" title="1 of 2 branches missed.">            } else if (DurationFieldType.days().equals(field)) {</span>
<span class="nc" id="L4091">              f = DurationFieldType.hours();</span>
<span class="nc" id="L4092">              standardUnit = 24;</span>
<span class="pc bpc" id="L4093" title="1 of 2 branches missed.">            } else if (DurationFieldType.hours().equals(field)) {</span>
<span class="nc" id="L4094">              f = DurationFieldType.minutes();</span>
<span class="nc" id="L4095">              standardUnit = 60;</span>
<span class="pc bpc" id="L4096" title="1 of 2 branches missed.">            } else if (DurationFieldType.minutes().equals(field)) {</span>
<span class="nc" id="L4097">              f = DurationFieldType.seconds();</span>
<span class="nc" id="L4098">              standardUnit = 60;</span>
<span class="pc bpc" id="L4099" title="1 of 2 branches missed.">            } else if (DurationFieldType.seconds().equals(field)) {</span>
<span class="nc" id="L4100">              f = DurationFieldType.millis();</span>
<span class="nc" id="L4101">              standardUnit = 1000;</span>
<span class="pc bpc" id="L4102" title="1 of 2 branches missed.">            } else if (DurationFieldType.months().equals(field)) {</span>
<span class="fc" id="L4103">              f = DurationFieldType.days();</span>
<span class="fc" id="L4104">              standardUnit = 30;</span>
<span class="nc bnc" id="L4105" title="All 2 branches missed.">            } else if (DurationFieldType.weeks().equals(field)) {</span>
<span class="nc" id="L4106">              f = DurationFieldType.days();</span>
<span class="nc" id="L4107">              standardUnit = 7;</span>
<span class="nc bnc" id="L4108" title="All 2 branches missed.">            } else if (DurationFieldType.millis().equals(field)) {</span>
              // No more granularity units....
<span class="nc" id="L4110">              f = DurationFieldType.millis();</span>
<span class="nc" id="L4111">              standardUnit = 0;</span>
            } else {
<span class="nc" id="L4113">              throw new UnsupportedOperationException(&quot;Unsupported duration type: &quot; + field + &quot; when dividing&quot;);</span>
            }
<span class="fc" id="L4115">            p.add(f, standardUnit * remainder);</span>
          }
        }
<span class="fc bfc" id="L4118" title="All 2 branches covered.">        for (int i = 0; i &lt; p.size(); i++) {</span>
<span class="fc" id="L4119">          p.setValue(i, p.getValue(i) / m);</span>
        }
<span class="fc" id="L4121">        return new DurationWithFields(p);</span>
      }
    }

    @Override
    public Period getJodaTimePeriod() {
<span class="pc bpc" id="L4127" title="1 of 2 branches missed.">      return (period != null) ? period.toPeriod() : null;</span>
    }

    @Override
    public org.joda.time.Duration getJodaTimeDuration() {
<span class="pc bpc" id="L4132" title="1 of 2 branches missed.">      return (period != null) ? period.toPeriod().toDurationFrom(JodaTimeUtils.INSTANT_ZERO) : null;</span>
    }

    @Override
    public Duration resolve(Time refTime, int flags) {
<span class="nc bnc" id="L4137" title="All 2 branches missed.">      Instant instant = (refTime != null) ? refTime.getJodaTimeInstant() : null;</span>
<span class="nc bnc" id="L4138" title="All 2 branches missed.">      if (instant != null) {</span>
<span class="nc bnc" id="L4139" title="All 2 branches missed.">        if ((flags &amp; DUR_RESOLVE_FROM_AS_REF) != 0) {</span>
<span class="nc" id="L4140">          return new DurationWithMillis(this, period.toPeriod().toDurationFrom(instant));</span>
<span class="nc bnc" id="L4141" title="All 2 branches missed.">        } else if ((flags &amp; DUR_RESOLVE_TO_AS_REF) != 0) {</span>
<span class="nc" id="L4142">          return new DurationWithMillis(this, period.toPeriod().toDurationTo(instant));</span>
        }
      }
<span class="nc" id="L4145">      return this;</span>
    }

    @Override
    public Duration add(Duration d) {
<span class="nc" id="L4150">      Period p = period.toPeriod().plus(d.getJodaTimePeriod());</span>
<span class="nc bnc" id="L4151" title="All 4 branches missed.">      if (this instanceof InexactDuration || d instanceof InexactDuration) {</span>
<span class="nc" id="L4152">        return new InexactDuration(this, p);</span>
      } else {
<span class="nc" id="L4154">        return new DurationWithFields(this, p);</span>
      }
    }

    @Override
    public Duration getGranularity() {
<span class="fc" id="L4160">      Period res = new Period();</span>
<span class="fc" id="L4161">      res = res.withField(JodaTimeUtils.getMostSpecific(getJodaTimePeriod()), 1);</span>
<span class="fc" id="L4162">      return Duration.getDuration(res);</span>
    }

    private static final long serialVersionUID = 1;
  }

  /**
   * Duration specified in terms of milliseconds.
   */
  public static class DurationWithMillis extends Duration {
    private final ReadableDuration base;

<span class="fc" id="L4174">    public DurationWithMillis(long ms) {</span>
<span class="fc" id="L4175">      this.base = new org.joda.time.Duration(ms);</span>
<span class="fc" id="L4176">    }</span>

<span class="nc" id="L4178">    public DurationWithMillis(ReadableDuration base) {</span>
<span class="nc" id="L4179">      this.base = base;</span>
<span class="nc" id="L4180">    }</span>

    public DurationWithMillis(Duration d, ReadableDuration base) {
<span class="nc" id="L4183">      super(d);</span>
<span class="nc" id="L4184">      this.base = base;</span>
<span class="nc" id="L4185">    }</span>

    @Override
    public Duration multiplyBy(int m) {
<span class="nc bnc" id="L4189" title="All 2 branches missed.">      if (m == 1) {</span>
<span class="nc" id="L4190">        return this;</span>
      } else {
<span class="nc" id="L4192">        long ms = base.getMillis();</span>
<span class="nc" id="L4193">        return new DurationWithMillis(ms * m);</span>
      }
    }

    @Override
    public Duration divideBy(int m) {
<span class="nc bnc" id="L4199" title="All 2 branches missed.">      if (m == 1) {</span>
<span class="nc" id="L4200">        return this;</span>
      } else {
<span class="nc" id="L4202">        long ms = base.getMillis();</span>
<span class="nc" id="L4203">        return new DurationWithMillis(ms / m);</span>
      }
    }

    @Override
    public Period getJodaTimePeriod() {
<span class="fc" id="L4209">      return base.toPeriod();</span>
    }

    @Override
    public org.joda.time.Duration getJodaTimeDuration() {
<span class="nc" id="L4214">      return base.toDuration();</span>
    }

    @Override
    public Duration add(Duration d) {
<span class="nc bnc" id="L4219" title="All 2 branches missed.">      if (d instanceof DurationWithMillis) {</span>
<span class="nc" id="L4220">        return new DurationWithMillis(this, base.toDuration().plus(((DurationWithMillis) d).base));</span>
<span class="nc bnc" id="L4221" title="All 2 branches missed.">      } else if (d instanceof DurationWithFields) {</span>
<span class="nc" id="L4222">        return ((DurationWithFields) d).add(this);</span>
      } else {
<span class="nc" id="L4224">        throw new UnsupportedOperationException(&quot;Unknown duration type in add: &quot; + d.getClass());</span>
      }
    }

    private static final long serialVersionUID = 1;
  }

  /**
   * A range of durations.  For instance, 2 to 3 days.
   */
  public static class DurationRange extends Duration {
    private final Duration minDuration;
    private final Duration maxDuration;

    public DurationRange(DurationRange d, Duration min, Duration max) {
<span class="nc" id="L4239">      super(d);</span>
<span class="nc" id="L4240">      this.minDuration = min;</span>
<span class="nc" id="L4241">      this.maxDuration = max;</span>
<span class="nc" id="L4242">    }</span>

<span class="nc" id="L4244">    public DurationRange(Duration min, Duration max) {</span>
<span class="nc" id="L4245">      this.minDuration = min;</span>
<span class="nc" id="L4246">      this.maxDuration = max;</span>
<span class="nc" id="L4247">    }</span>

    @Override
    public boolean includeTimexAltValue() {
<span class="nc" id="L4251">      return true;</span>
    }

    @Override
    public String toFormattedString(int flags) {
<span class="nc bnc" id="L4256" title="All 2 branches missed.">      if ((flags &amp; (FORMAT_ISO | FORMAT_TIMEX3_VALUE)) != 0) {</span>
        // return super.toFormattedString(flags);
<span class="nc" id="L4258">        return null;</span>
      }
<span class="nc" id="L4260">      StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L4261" title="All 2 branches missed.">      if (minDuration != null)</span>
<span class="nc" id="L4262">        sb.append(minDuration.toFormattedString(flags));</span>
<span class="nc" id="L4263">      sb.append(&quot;/&quot;);</span>
<span class="nc bnc" id="L4264" title="All 2 branches missed.">      if (maxDuration != null)</span>
<span class="nc" id="L4265">        sb.append(maxDuration.toFormattedString(flags));</span>
<span class="nc" id="L4266">      return sb.toString();</span>
    }

    @Override
    public Period getJodaTimePeriod() {
<span class="nc bnc" id="L4271" title="All 2 branches missed.">      if (minDuration == null)</span>
<span class="nc" id="L4272">        return maxDuration.getJodaTimePeriod();</span>
<span class="nc bnc" id="L4273" title="All 2 branches missed.">      if (maxDuration == null)</span>
<span class="nc" id="L4274">        return minDuration.getJodaTimePeriod();</span>
<span class="nc" id="L4275">      Duration mid = minDuration.add(maxDuration).divideBy(2);</span>
<span class="nc" id="L4276">      return mid.getJodaTimePeriod();</span>
    }

    @Override
    public org.joda.time.Duration getJodaTimeDuration() {
<span class="nc bnc" id="L4281" title="All 2 branches missed.">      if (minDuration == null)</span>
<span class="nc" id="L4282">        return maxDuration.getJodaTimeDuration();</span>
<span class="nc bnc" id="L4283" title="All 2 branches missed.">      if (maxDuration == null)</span>
<span class="nc" id="L4284">        return minDuration.getJodaTimeDuration();</span>
<span class="nc" id="L4285">      Duration mid = minDuration.add(maxDuration).divideBy(2);</span>
<span class="nc" id="L4286">      return mid.getJodaTimeDuration();</span>
    }

    @Override
    public Duration add(Duration d) {
<span class="nc bnc" id="L4291" title="All 2 branches missed.">      Duration min2 = (minDuration != null) ? minDuration.add(d) : null;</span>
<span class="nc bnc" id="L4292" title="All 2 branches missed.">      Duration max2 = (maxDuration != null) ? maxDuration.add(d) : null;</span>
<span class="nc" id="L4293">      return new DurationRange(this, min2, max2);</span>
    }

    @Override
    public Duration multiplyBy(int m) {
<span class="nc bnc" id="L4298" title="All 2 branches missed.">      Duration min2 = (minDuration != null) ? minDuration.multiplyBy(m) : null;</span>
<span class="nc bnc" id="L4299" title="All 2 branches missed.">      Duration max2 = (maxDuration != null) ? maxDuration.multiplyBy(m) : null;</span>
<span class="nc" id="L4300">      return new DurationRange(this, min2, max2);</span>
    }

    @Override
    public Duration divideBy(int m) {
<span class="nc bnc" id="L4305" title="All 2 branches missed.">      Duration min2 = (minDuration != null) ? minDuration.divideBy(m) : null;</span>
<span class="nc bnc" id="L4306" title="All 2 branches missed.">      Duration max2 = (maxDuration != null) ? maxDuration.divideBy(m) : null;</span>
<span class="nc" id="L4307">      return new DurationRange(this, min2, max2);</span>
    }

    private static final long serialVersionUID = 1;
  }

  /**
   * Duration that is inexact.  Use for durations such as &quot;several days&quot;
   * in which case, we know the field is DAY, but we don't know the exact
   * number of days
   */
  public static class InexactDuration extends DurationWithFields {
    // Original duration is estimate of how long this duration is
    // but since some aspects of it is unknown....
    // for now all fields are inexact

    // TODO: Have inexact duration in which some fields are exact
    // add/toISOString
    // boolean[] exactFields;
<span class="fc" id="L4326">    public InexactDuration(ReadablePeriod period) {</span>
<span class="fc" id="L4327">      this.period = period;</span>
      // exactFields = new boolean[period.size()];
<span class="fc" id="L4329">      this.approx = true;</span>
<span class="fc" id="L4330">    }</span>

    public InexactDuration(Duration d) {
<span class="nc" id="L4333">      super(d, d.getJodaTimePeriod());</span>
<span class="nc" id="L4334">      this.approx = true;</span>
<span class="nc" id="L4335">    }</span>

    public InexactDuration(Duration d, ReadablePeriod period) {
<span class="nc" id="L4338">      super(d, period);</span>
<span class="nc" id="L4339">      this.approx = true;</span>
<span class="nc" id="L4340">    }</span>

    @Override
    public String toFormattedString(int flags) {
<span class="nc" id="L4344">      String s = super.toFormattedString(flags);</span>
<span class="nc" id="L4345">      return s.replaceAll(&quot;\\d+&quot;, PAD_FIELD_UNKNOWN);</span>
    }

    private static final long serialVersionUID = 1;
  }

  /**
   * A time interval
   */
  public static class Range extends Temporal implements HasInterval&lt;Time&gt; {
    private final Time begin; // = TIME_UNKNOWN;
    private final Time end; // = TIME_UNKNOWN;
    private final Duration duration; // = DURATION_UNKNOWN;

<span class="fc" id="L4359">    public Range(Time begin, Time end) {</span>
<span class="fc" id="L4360">      this.begin = begin;</span>
<span class="fc" id="L4361">      this.end = end;</span>
<span class="fc" id="L4362">      this.duration = Time.difference(begin, end);</span>
<span class="fc" id="L4363">    }</span>

<span class="fc" id="L4365">    public Range(Time begin, Time end, Duration duration) {</span>
<span class="fc" id="L4366">      this.begin = begin;</span>
<span class="fc" id="L4367">      this.end = end;</span>
<span class="fc" id="L4368">      this.duration = duration;</span>
<span class="fc" id="L4369">    }</span>

<span class="fc" id="L4371">    public Range(Time begin, Duration duration) {</span>
<span class="fc" id="L4372">      this.begin = begin;</span>
<span class="fc" id="L4373">      this.end = TIME_UNKNOWN;</span>
<span class="fc" id="L4374">      this.duration = duration;</span>
<span class="fc" id="L4375">    }</span>

    public Range(Range r, Time begin, Time end, Duration duration) {
<span class="fc" id="L4378">      super(r);</span>
<span class="fc" id="L4379">      this.begin = begin;</span>
<span class="fc" id="L4380">      this.end = end;</span>
<span class="fc" id="L4381">      this.duration = duration;</span>
<span class="fc" id="L4382">    }</span>

    @Override
    public Range setTimeZone(DateTimeZone tz) {
<span class="nc" id="L4386">      return new Range(this, (Time) Temporal.setTimeZone(begin, tz), (Time) Temporal.setTimeZone(end, tz), duration);</span>
    }

    @Override
    public Interval&lt;Time&gt; getInterval() {
<span class="nc" id="L4391">      return FuzzyInterval.toInterval(begin, end);</span>
    }

    public org.joda.time.Interval getJodaTimeInterval() {
<span class="fc" id="L4395">      return new org.joda.time.Interval(begin.getJodaTimeInstant(), end.getJodaTimeInstant());</span>
    }

    @Override
    public boolean isGrounded() {
<span class="nc bnc" id="L4400" title="All 4 branches missed.">      return begin.isGrounded() &amp;&amp; end.isGrounded();</span>
    }

    @Override
    public Time getTime() {
<span class="nc" id="L4405">      return begin;</span>
    } // TODO: return something that makes sense for time...

    @Override
    public Duration getDuration() {
<span class="fc" id="L4410">      return duration;</span>
    }

    @Override
    public Range getRange(int flags, Duration granularity) {
<span class="fc" id="L4415">      return this;</span>
    }

    @Override
    public TimexType getTimexType() {
<span class="nc" id="L4420">      return TimexType.DURATION;</span>
    }

    @Override
    public Map&lt;String, String&gt; getTimexAttributes(TimeIndex timeIndex) {
<span class="nc bnc" id="L4425" title="All 2 branches missed.">      String beginTidStr = (begin != null) ? begin.getTidString(timeIndex) : null;</span>
<span class="nc bnc" id="L4426" title="All 2 branches missed.">      String endTidStr = (end != null) ? end.getTidString(timeIndex) : null;</span>
<span class="nc" id="L4427">      Map&lt;String, String&gt; map = super.getTimexAttributes(timeIndex);</span>
<span class="nc bnc" id="L4428" title="All 2 branches missed.">      if (beginTidStr != null) {</span>
<span class="nc" id="L4429">        map.put(TimexAttr.beginPoint.name(), beginTidStr);</span>
      }
<span class="nc bnc" id="L4431" title="All 2 branches missed.">      if (endTidStr != null) {</span>
<span class="nc" id="L4432">        map.put(TimexAttr.endPoint.name(), endTidStr);</span>
      }
<span class="nc" id="L4434">      return map;</span>
    }

    // public boolean includeTimexAltValue() { return true; }
    @Override
    public String toFormattedString(int flags) {
<span class="pc bpc" id="L4440" title="1 of 2 branches missed.">      if ((flags &amp; (FORMAT_ISO | FORMAT_TIMEX3_VALUE)) != 0) {</span>
<span class="pc bpc" id="L4441" title="1 of 2 branches missed.">        if (getTimeLabel() != null) {</span>
<span class="nc" id="L4442">          return getTimeLabel();</span>
        }
<span class="pc bpc" id="L4444" title="1 of 2 branches missed.">        String beginStr = (begin != null) ? begin.toFormattedString(flags) : null;</span>
<span class="fc bfc" id="L4445" title="All 2 branches covered.">        String endStr = (end != null) ? end.toFormattedString(flags) : null;</span>
<span class="pc bpc" id="L4446" title="1 of 2 branches missed.">        String durationStr = (duration != null) ? duration.toFormattedString(flags) : null;</span>
<span class="pc bpc" id="L4447" title="1 of 2 branches missed.">        if ((flags &amp; FORMAT_ISO) != 0) {</span>
<span class="pc bpc" id="L4448" title="1 of 4 branches missed.">          if (beginStr != null &amp;&amp; endStr != null) {</span>
<span class="fc" id="L4449">            return beginStr + &quot;/&quot; + endStr;</span>
<span class="pc bpc" id="L4450" title="2 of 4 branches missed.">          } else if (beginStr != null &amp;&amp; durationStr != null) {</span>
<span class="fc" id="L4451">            return beginStr + &quot;/&quot; + durationStr;</span>
<span class="nc bnc" id="L4452" title="All 4 branches missed.">          } else if (durationStr != null &amp;&amp; endStr != null) {</span>
<span class="nc" id="L4453">            return durationStr + &quot;/&quot; + endStr;</span>
          }
        }
<span class="nc" id="L4456">        return durationStr;</span>
      } else {
<span class="nc" id="L4458">        StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L4459">        sb.append(&quot;(&quot;);</span>
<span class="nc bnc" id="L4460" title="All 2 branches missed.">        if (begin != null)</span>
<span class="nc" id="L4461">          sb.append(begin);</span>
<span class="nc" id="L4462">        sb.append(&quot;,&quot;);</span>
<span class="nc bnc" id="L4463" title="All 2 branches missed.">        if (end != null)</span>
<span class="nc" id="L4464">          sb.append(end);</span>
<span class="nc" id="L4465">        sb.append(&quot;,&quot;);</span>
<span class="nc bnc" id="L4466" title="All 2 branches missed.">        if (duration != null)</span>
<span class="nc" id="L4467">          sb.append(duration);</span>
<span class="nc" id="L4468">        sb.append(&quot;)&quot;);</span>
<span class="nc" id="L4469">        return sb.toString();</span>
      }
    }

    @Override
    public Range resolve(Time refTime, int flags) {
<span class="nc bnc" id="L4475" title="All 2 branches missed.">      if (refTime == null) {</span>
<span class="nc" id="L4476">        return this;</span>
      }
<span class="nc bnc" id="L4478" title="All 2 branches missed.">      if (isGrounded())</span>
<span class="nc" id="L4479">        return this;</span>
<span class="nc bnc" id="L4480" title="All 6 branches missed.">      if ((flags &amp; RANGE_RESOLVE_TIME_REF) != 0 &amp;&amp; (begin == TIME_REF || end == TIME_REF)) {</span>
<span class="nc" id="L4481">        Time groundedBegin = begin;</span>
<span class="nc" id="L4482">        Duration groundedDuration = duration;</span>
<span class="nc bnc" id="L4483" title="All 2 branches missed.">        if (begin == TIME_REF) {</span>
<span class="nc" id="L4484">          groundedBegin = (Time) begin.resolve(refTime, flags);</span>
<span class="nc bnc" id="L4485" title="All 2 branches missed.">          groundedDuration = (duration != null) ? duration.resolve(refTime, flags | DUR_RESOLVE_FROM_AS_REF) : null;</span>
        }
<span class="nc" id="L4487">        Time groundedEnd = end;</span>
<span class="nc bnc" id="L4488" title="All 2 branches missed.">        if (end == TIME_REF) {</span>
<span class="nc" id="L4489">          groundedEnd = (Time) end.resolve(refTime, flags);</span>
<span class="nc bnc" id="L4490" title="All 2 branches missed.">          groundedDuration = (duration != null) ? duration.resolve(refTime, flags | DUR_RESOLVE_TO_AS_REF) : null;</span>
        }
<span class="nc" id="L4492">        return new Range(this, groundedBegin, groundedEnd, groundedDuration);</span>
      } else {
<span class="nc" id="L4494">        return this;</span>
      }
    }

    // TODO: Implement some range operations....
    public Range offset(Duration d, int offsetFlags) {
<span class="fc" id="L4500">      return offset(d, offsetFlags, RANGE_OFFSET_BEGIN | RANGE_OFFSET_END);</span>
    }

    public Range offset(Duration d, int offsetFlags, int rangeFlags) {
<span class="fc" id="L4504">      Time b2 = begin;</span>
<span class="pc bpc" id="L4505" title="1 of 2 branches missed.">      if ((rangeFlags &amp; RANGE_OFFSET_BEGIN) != 0) {</span>
<span class="pc bpc" id="L4506" title="1 of 2 branches missed.">        b2 = (begin != null) ? begin.offset(d,offsetFlags) : null;</span>
      }
<span class="fc" id="L4508">      Time e2 = end;</span>
<span class="pc bpc" id="L4509" title="1 of 2 branches missed.">      if ((rangeFlags &amp; RANGE_OFFSET_END) != 0) {</span>
<span class="pc bpc" id="L4510" title="1 of 2 branches missed.">        e2 = (end != null) ? end.offset(d,offsetFlags) : null;</span>
      }
<span class="fc" id="L4512">      return new Range(this, b2, e2, duration);</span>
    }

    public Range subtract(Duration d) {
<span class="nc" id="L4516">      return subtract(d, RANGE_EXPAND_FIX_BEGIN);</span>
    }

    public Range subtract(Duration d, int flags) {
<span class="nc" id="L4520">      return add(d.multiplyBy(-1), RANGE_EXPAND_FIX_BEGIN);</span>
    }

    public Range add(Duration d) {
<span class="nc" id="L4524">      return add(d, RANGE_EXPAND_FIX_BEGIN);</span>
    }

    public Range add(Duration d, int flags) {
<span class="nc" id="L4528">      Duration d2 = duration.add(d);</span>
<span class="nc" id="L4529">      Time b2 = begin;</span>
<span class="nc" id="L4530">      Time e2 = end;</span>
<span class="nc bnc" id="L4531" title="All 2 branches missed.">      if ((flags &amp; RANGE_EXPAND_FIX_BEGIN) == 0) {</span>
<span class="nc bnc" id="L4532" title="All 2 branches missed.">        b2 = (end != null) ? end.offset(d2.multiplyBy(-1),0) : null;</span>
<span class="nc bnc" id="L4533" title="All 2 branches missed.">      } else if ((flags &amp; RANGE_EXPAND_FIX_END) == 0) {</span>
<span class="nc bnc" id="L4534" title="All 2 branches missed.">        e2 = (begin != null) ? begin.offset(d2,0) : null;</span>
      }
<span class="nc" id="L4536">      return new Range(this, b2, e2, d2);</span>
    }

    public Time begin() {
<span class="fc" id="L4540">      return begin;</span>
    }

    public Time end() {
<span class="nc" id="L4544">      return end;</span>
    }

    public Time beginTime() {
<span class="pc bpc" id="L4548" title="1 of 2 branches missed.">      if (begin != null) {</span>
<span class="fc" id="L4549">        Range r = begin.getRange();</span>
<span class="pc bpc" id="L4550" title="2 of 4 branches missed.">        if (r != null &amp;&amp; !begin.equals(r.begin)) {</span>
<span class="fc" id="L4551">          return r.begin;</span>
        }
      }
<span class="nc" id="L4554">      return begin;</span>
    }

    public Time endTime() {
      /*    if (end != null) {
            Range r = end.getRange();
            if (r != null &amp;&amp; !end.equals(r.end)) {
              //return r.endTime();
              return r.end;
            }
          }        */
<span class="fc" id="L4565">      return end;</span>
    }

    public Time mid() {
<span class="pc bpc" id="L4569" title="1 of 4 branches missed.">      if (duration != null &amp;&amp; begin != null) {</span>
<span class="fc" id="L4570">        Time b = begin.getRange(RANGE_FLAGS_PAD_SPECIFIED,duration.getGranularity()).begin();</span>
<span class="fc" id="L4571">        return b.add(duration.divideBy(2));</span>
<span class="pc bpc" id="L4572" title="3 of 4 branches missed.">      } else if (duration != null &amp;&amp; end != null) {</span>
<span class="nc" id="L4573">        return end.subtract(duration.divideBy(2));</span>
<span class="pc bpc" id="L4574" title="2 of 4 branches missed.">      } else if (begin != null &amp;&amp; end != null) {</span>
        // TODO: ....
<span class="nc bnc" id="L4576" title="All 2 branches missed.">      } else if (begin != null) {</span>
<span class="nc" id="L4577">        return begin;</span>
<span class="nc bnc" id="L4578" title="All 2 branches missed.">      } else if (end != null) {</span>
<span class="nc" id="L4579">        return end;</span>
      }
<span class="fc" id="L4581">      return null;</span>
    }

    // TODO: correct implementation
    @Override
    public Temporal intersect(Temporal t) {
<span class="nc bnc" id="L4587" title="All 2 branches missed.">      if (t instanceof Time) {</span>
<span class="nc" id="L4588">        return new RelativeTime((Time) t, TemporalOp.INTERSECT, this);</span>
<span class="nc bnc" id="L4589" title="All 2 branches missed.">      } else if (t instanceof Range) {</span>
<span class="nc" id="L4590">        Range rt = (Range) t;</span>
        // Assume begin/end defined (TODO: handle if duration defined)
<span class="nc" id="L4592">        Time b = Time.max(begin, rt.begin);</span>
<span class="nc" id="L4593">        Time e = Time.min(end, rt.end);</span>
<span class="nc" id="L4594">        return new Range(b, e);</span>
<span class="nc bnc" id="L4595" title="All 2 branches missed.">      } else if (t instanceof Duration) {</span>
<span class="nc" id="L4596">        return new InexactTime(null, (Duration) t, this);</span>
      }
<span class="nc" id="L4598">      return null;</span>
    }

    /**
     * Checks if the provided range r is within the current range.
     * Note that equal ranges also returns true.
     *
     * @param r range
     * @return true if range r is contained in r
     */
    public boolean contains(Range r) {
<span class="fc bfc" id="L4609" title="All 2 branches covered.">      if ((this.beginTime().getJodaTimeInstant().isBefore(r.beginTime().getJodaTimeInstant())</span>
<span class="fc bfc" id="L4610" title="All 2 branches covered.">                      || this.beginTime().getJodaTimeInstant().isEqual(r.beginTime().getJodaTimeInstant()))</span>
<span class="fc bfc" id="L4611" title="All 2 branches covered.">              &amp;&amp; (this.endTime().getJodaTimeInstant().isAfter(r.endTime().getJodaTimeInstant())</span>
<span class="fc bfc" id="L4612" title="All 2 branches covered.">                      || this.endTime().getJodaTimeInstant().isEqual(r.endTime().getJodaTimeInstant()))) {</span>
<span class="fc" id="L4613">        return true;</span>
      }
<span class="fc" id="L4615">      return false;</span>
    }


    /**
     * Checks if the provided time is within the current range.
     * @param t A time to check containment for
     * @return Returns whether the provided time is within the current range
     */
    public boolean contains(Time t) {
<span class="fc" id="L4625">    	return this.getJodaTimeInterval().contains(t.getJodaTimeInstant());</span>
    }


    private static final long serialVersionUID = 1;
  }


  /**
   * Exciting set of times
   */
  public abstract static class TemporalSet extends Temporal {
<span class="fc" id="L4637">    public TemporalSet() {</span>
<span class="fc" id="L4638">    }</span>

    public TemporalSet(TemporalSet t) {
<span class="nc" id="L4641">      super(t);</span>
<span class="nc" id="L4642">    }</span>

    // public boolean includeTimexAltValue() { return true; }
    @Override
    public TimexType getTimexType() {
<span class="nc" id="L4647">      return TimexType.SET;</span>
    }

    private static final long serialVersionUID = 1;
  }

  /**
   * Explicit set of times: like tomorrow and next week, not really used
   */
  public static class ExplicitTemporalSet extends TemporalSet {
    private final Set&lt;Temporal&gt; temporals;

<span class="fc" id="L4659">    public ExplicitTemporalSet(Temporal... temporals) {</span>
<span class="fc" id="L4660">      this.temporals = CollectionUtils.asSet(temporals);</span>
<span class="fc" id="L4661">    }</span>

<span class="nc" id="L4663">    public ExplicitTemporalSet(Set&lt;Temporal&gt; temporals) {</span>
<span class="nc" id="L4664">      this.temporals = temporals;</span>
<span class="nc" id="L4665">    }</span>

    public ExplicitTemporalSet(ExplicitTemporalSet p, Set&lt;Temporal&gt; temporals) {
<span class="nc" id="L4668">      super(p);</span>
<span class="nc" id="L4669">      this.temporals = temporals;</span>
<span class="nc" id="L4670">    }</span>

    @Override
    public ExplicitTemporalSet setTimeZone(DateTimeZone tz) {
<span class="nc" id="L4674">      Set&lt;Temporal&gt; tzTemporals = Generics.newHashSet(temporals.size());</span>
<span class="nc bnc" id="L4675" title="All 2 branches missed.">      for (Temporal t:temporals) {</span>
<span class="nc" id="L4676">        tzTemporals.add(Temporal.setTimeZone(t, tz));</span>
<span class="nc" id="L4677">      }</span>
<span class="nc" id="L4678">      return new ExplicitTemporalSet(this, tzTemporals);</span>
    }

    @Override
    public boolean isGrounded() {
<span class="nc" id="L4683">      return false;</span>
    }

    @Override
    public Time getTime() {
<span class="nc" id="L4688">      return null;</span>
    }

    @Override
    public Duration getDuration() {
      // TODO: Return difference between min/max of set
<span class="nc" id="L4694">      return null;</span>
    }

    @Override
    public Range getRange(int flags, Duration granularity) {
      // TODO: Return min/max of set
<span class="nc" id="L4700">      return null;</span>
    }

    @Override
    public Temporal resolve(Time refTime, int flags) {
<span class="nc" id="L4705">      Temporal[] newTemporals = new Temporal[temporals.size()];</span>
<span class="nc" id="L4706">      int i = 0;</span>
<span class="nc bnc" id="L4707" title="All 2 branches missed.">      for (Temporal t : temporals) {</span>
<span class="nc" id="L4708">        newTemporals[i] = t.resolve(refTime, flags);</span>
<span class="nc" id="L4709">        i++;</span>
<span class="nc" id="L4710">      }</span>
<span class="nc" id="L4711">      return new ExplicitTemporalSet(newTemporals);</span>
    }

    @Override
    public String toFormattedString(int flags) {
<span class="nc bnc" id="L4716" title="All 2 branches missed.">      if (getTimeLabel() != null) {</span>
<span class="nc" id="L4717">        return getTimeLabel();</span>
      }
<span class="nc bnc" id="L4719" title="All 2 branches missed.">      if ((flags &amp; FORMAT_ISO) != 0) {</span>
        // TODO: is there iso standard?
<span class="nc" id="L4721">        return null;</span>
      }
<span class="nc bnc" id="L4723" title="All 2 branches missed.">      if ((flags &amp; FORMAT_TIMEX3_VALUE) != 0) {</span>
        // TODO: is there timex3 standard?
<span class="nc" id="L4725">        return null;</span>
      }
<span class="nc" id="L4727">      return &quot;{&quot; + StringUtils.join(temporals, &quot;, &quot;) + &quot;}&quot;;</span>
    }

    @Override
    public Temporal intersect(Temporal other) {
<span class="nc bnc" id="L4732" title="All 2 branches missed.">      if (other == null)</span>
<span class="nc" id="L4733">        return this;</span>
<span class="nc bnc" id="L4734" title="All 4 branches missed.">      if (other == TIME_UNKNOWN || other == DURATION_UNKNOWN)</span>
<span class="nc" id="L4735">        return this;</span>
<span class="nc" id="L4736">      Set&lt;Temporal&gt; newTemporals = Generics.newHashSet();</span>
<span class="nc bnc" id="L4737" title="All 2 branches missed.">      for (Temporal t : temporals) {</span>
<span class="nc" id="L4738">        Temporal t2 = t.intersect(other);</span>
<span class="nc bnc" id="L4739" title="All 2 branches missed.">        if (t2 != null)</span>
<span class="nc" id="L4740">          newTemporals.add(t2);</span>
<span class="nc" id="L4741">      }</span>
<span class="nc" id="L4742">      return new ExplicitTemporalSet(newTemporals);</span>
    }

    private static final long serialVersionUID = 1;
  }


<span class="fc" id="L4749">  public static final PeriodicTemporalSet HOURLY = new PeriodicTemporalSet(null, HOUR, &quot;EVERY&quot;, &quot;P1X&quot;);</span>
<span class="fc" id="L4750">  public static final PeriodicTemporalSet NIGHTLY = new PeriodicTemporalSet(NIGHT, DAY, &quot;EVERY&quot;, &quot;P1X&quot;);</span>
<span class="fc" id="L4751">  public static final PeriodicTemporalSet DAILY = new PeriodicTemporalSet(null, DAY, &quot;EVERY&quot;, &quot;P1X&quot;);</span>
<span class="fc" id="L4752">  public static final PeriodicTemporalSet MONTHLY = new PeriodicTemporalSet(null, MONTH, &quot;EVERY&quot;, &quot;P1X&quot;);</span>
<span class="fc" id="L4753">  public static final PeriodicTemporalSet QUARTERLY = new PeriodicTemporalSet(null, QUARTER, &quot;EVERY&quot;, &quot;P1X&quot;);</span>
<span class="fc" id="L4754">  public static final PeriodicTemporalSet YEARLY = new PeriodicTemporalSet(null, YEAR, &quot;EVERY&quot;, &quot;P1X&quot;);</span>
<span class="fc" id="L4755">  public static final PeriodicTemporalSet WEEKLY = new PeriodicTemporalSet(null, WEEK, &quot;EVERY&quot;, &quot;P1X&quot;);</span>

  /**
   * PeriodicTemporalSet represent a set of times that occurs with some frequency.
   * Example: At 2-3pm every friday from September 1, 2011 to December 30, 2011.
   */
  public static class PeriodicTemporalSet extends TemporalSet {
    /** Start and end times for when this set of times is suppose to be happening
     *  (e.g. 2011-09-01 to 2011-12-30) */
    Range occursIn;

    /** Temporal that re-occurs (e.g. Friday 2-3pm) */
    Temporal base;

    /** The periodicity of re-occurrence (e.g. week) */
    Duration periodicity;

    // How often (once, twice)
    // int count;

    /** Quantifier - every, every other */
    String quant;

    /** String representation of frequency (3 days = P3D, 3 times = P3X) */
    String freq;

    // public ExplicitTemporalSet toExplicitTemporalSet();
<span class="fc" id="L4782">    public PeriodicTemporalSet(Temporal base, Duration periodicity, String quant, String freq) {</span>
<span class="fc" id="L4783">      this.base = base;</span>
<span class="fc" id="L4784">      this.periodicity = periodicity;</span>
<span class="fc" id="L4785">      this.quant = quant;</span>
<span class="fc" id="L4786">      this.freq = freq;</span>
<span class="fc" id="L4787">    }</span>

    public PeriodicTemporalSet(PeriodicTemporalSet p, Temporal base, Duration periodicity, Range range, String quant, String freq) {
<span class="nc" id="L4790">      super(p);</span>
<span class="nc" id="L4791">      this.occursIn = range;</span>
<span class="nc" id="L4792">      this.base = base;</span>
<span class="nc" id="L4793">      this.periodicity = periodicity;</span>
<span class="nc" id="L4794">      this.quant = quant;</span>
<span class="nc" id="L4795">      this.freq = freq;</span>
<span class="nc" id="L4796">    }</span>

    @Override
    public PeriodicTemporalSet setTimeZone(DateTimeZone tz) {
<span class="nc" id="L4800">      return new PeriodicTemporalSet(this, Temporal.setTimeZone(base, tz), periodicity,</span>
<span class="nc" id="L4801">              (Range) Temporal.setTimeZone(occursIn, tz), quant, freq);</span>
    }

    public PeriodicTemporalSet multiplyDurationBy(int scale) {
<span class="nc" id="L4805">      return new PeriodicTemporalSet(this, this.base, periodicity.multiplyBy(scale), this.occursIn, this.quant, this.freq);</span>
    }

    public PeriodicTemporalSet divideDurationBy(int scale) {
<span class="nc" id="L4809">      return new PeriodicTemporalSet(this, this.base, periodicity.divideBy(scale), this.occursIn, this.quant, this.freq);</span>
    }

    @Override
    public boolean isGrounded() {
<span class="nc bnc" id="L4814" title="All 4 branches missed.">      return (occursIn != null &amp;&amp; occursIn.isGrounded());</span>
    }

    @Override
    public Duration getPeriod() {
<span class="nc" id="L4819">      return periodicity;</span>
    }

    @Override
    public Time getTime() {
<span class="nc" id="L4824">      return null;</span>
    }

    @Override
    public Duration getDuration() {
<span class="nc" id="L4829">      return null;</span>
    }

    @Override
    public Range getRange(int flags, Duration granularity) {
<span class="nc" id="L4834">      return occursIn;</span>
    }

    @Override
    public Map&lt;String, String&gt; getTimexAttributes(TimeIndex timeIndex) {
<span class="nc" id="L4839">      Map&lt;String, String&gt; map = super.getTimexAttributes(timeIndex);</span>
<span class="nc bnc" id="L4840" title="All 2 branches missed.">      if (quant != null) {</span>
<span class="nc" id="L4841">        map.put(TimexAttr.quant.name(), quant);</span>
      }
<span class="nc bnc" id="L4843" title="All 2 branches missed.">      if (freq != null) {</span>
<span class="nc" id="L4844">        map.put(TimexAttr.freq.name(), freq);</span>
      }
<span class="nc bnc" id="L4846" title="All 2 branches missed.">      if (periodicity != null) {</span>
<span class="nc" id="L4847">        map.put(&quot;periodicity&quot;, periodicity.getTimexValue());</span>
      }
<span class="nc" id="L4849">      return map;</span>
    }

    @Override
    public Temporal resolve(Time refTime, int flags) {
<span class="nc bnc" id="L4854" title="All 2 branches missed.">      Range resolvedOccursIn = (occursIn != null) ? occursIn.resolve(refTime, flags) : null;</span>
<span class="nc bnc" id="L4855" title="All 2 branches missed.">      Temporal resolvedBase = (base != null) ? base.resolve(null, 0) : null;</span>
<span class="nc" id="L4856">      return new PeriodicTemporalSet(this, resolvedBase, this.periodicity, resolvedOccursIn, this.quant, this.freq);</span>
    }

    @Override
    public String toFormattedString(int flags) {
<span class="nc bnc" id="L4861" title="All 2 branches missed.">      if (getTimeLabel() != null) {</span>
<span class="nc" id="L4862">        return getTimeLabel();</span>
      }
<span class="nc bnc" id="L4864" title="All 2 branches missed.">      if ((flags &amp; FORMAT_ISO) != 0) {</span>
        // TODO: is there iso standard?
<span class="nc" id="L4866">        return null;</span>
      }
<span class="nc bnc" id="L4868" title="All 2 branches missed.">      if (base != null) {</span>
<span class="nc" id="L4869">        return base.toFormattedString(flags);</span>
      } else {
<span class="nc bnc" id="L4871" title="All 2 branches missed.">        if (periodicity != null) {</span>
<span class="nc" id="L4872">          return periodicity.toFormattedString(flags);</span>
        }
      }
<span class="nc" id="L4875">      return null;</span>
    }

    @Override
    public Temporal intersect(Temporal t) {
<span class="nc bnc" id="L4880" title="All 2 branches missed.">      if (t instanceof Range) {</span>
<span class="nc bnc" id="L4881" title="All 2 branches missed.">        if (occursIn == null) {</span>
<span class="nc" id="L4882">          return new PeriodicTemporalSet(this, base, periodicity, (Range) t, quant, freq);</span>
        }
<span class="nc bnc" id="L4884" title="All 2 branches missed.">      } else if (base != null) {</span>
<span class="nc" id="L4885">        Temporal merged = base.intersect(t);</span>
<span class="nc" id="L4886">        return new PeriodicTemporalSet(this, merged, periodicity, occursIn, quant, freq);</span>
      } else {
<span class="nc" id="L4888">        return new PeriodicTemporalSet(this, t, periodicity, occursIn, quant, freq);</span>
      }
<span class="nc" id="L4890">      return null;</span>
    }

    private static final long serialVersionUID = 1;
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>