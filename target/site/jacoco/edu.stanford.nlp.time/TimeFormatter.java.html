<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TimeFormatter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.time</a> &gt; <span class="el_source">TimeFormatter.java</span></div><h1>TimeFormatter.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.time;

import edu.stanford.nlp.ling.CoreAnnotations;
import edu.stanford.nlp.ling.tokensregex.*;
import edu.stanford.nlp.ling.tokensregex.types.Expression;
import edu.stanford.nlp.ling.tokensregex.types.Expressions;
import edu.stanford.nlp.ling.tokensregex.types.Value;
import edu.stanford.nlp.util.CollectionValuedMap;
import edu.stanford.nlp.util.CoreMap;
import java.util.function.Function;
import edu.stanford.nlp.util.Generics;
import org.joda.time.*;
import org.joda.time.format.*;

import java.lang.reflect.Method;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.regex.MatchResult;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Time specific patterns and formatting
 *
 * @author Angel Chang
 */
public class TimeFormatter {

<span class="nc" id="L29">  private TimeFormatter() {} // static methods/classes</span>


  public static class JavaDateFormatExtractor implements
          Function&lt;CoreMap, Value&gt; {

<span class="nc" id="L35">    private static final Class&lt;CoreAnnotations.TextAnnotation&gt; textAnnotationField = CoreAnnotations.TextAnnotation.class;</span>
    private final SimpleDateFormat format;

<span class="nc" id="L38">    public JavaDateFormatExtractor(String pattern) {</span>
<span class="nc" id="L39">      this.format = new SimpleDateFormat(pattern);</span>
<span class="nc" id="L40">    }</span>

    @Override
    public Value apply(CoreMap m) {
      try {
        // TODO: Allow specification of locale, pivot year (set2DigitYearStart) for interpreting 2 digit years
<span class="nc" id="L46">        String str = m.get(textAnnotationField);</span>
<span class="nc" id="L47">        Date d = format.parse(str);</span>
<span class="nc" id="L48">        return new Expressions.PrimitiveValue(&quot;GroundedTime&quot;, new SUTime.GroundedTime(new Instant(d.getTime())));</span>
<span class="nc" id="L49">      } catch (java.text.ParseException ex) {</span>
<span class="nc" id="L50">        return null;</span>
      }
    }

  }


  public static class JodaDateTimeFormatExtractor implements
          Function&lt;CoreMap, Value&gt; {

<span class="nc" id="L60">    private static final Class&lt;CoreAnnotations.TextAnnotation&gt; textAnnotationField = CoreAnnotations.TextAnnotation.class;</span>
    private final DateTimeFormatter formatter;

<span class="nc" id="L63">    public JodaDateTimeFormatExtractor(DateTimeFormatter formatter) {</span>
<span class="nc" id="L64">      this.formatter = formatter;</span>
<span class="nc" id="L65">    }</span>

<span class="nc" id="L67">    public JodaDateTimeFormatExtractor(String pattern) {</span>
<span class="nc" id="L68">      this.formatter = DateTimeFormat.forPattern(pattern);</span>
<span class="nc" id="L69">    }</span>

    @Override
    public Value apply(CoreMap m) {
      try {
<span class="nc" id="L74">        String str = m.get(textAnnotationField);</span>
        // TODO: Allow specification of pivot year (withPivotYear) for interpreting 2 digit years
<span class="nc" id="L76">        DateTime d = formatter.parseDateTime(str);</span>
<span class="nc" id="L77">        return new Expressions.PrimitiveValue(&quot;GroundedTime&quot;, new SUTime.GroundedTime(d));</span>
<span class="nc" id="L78">      } catch (IllegalArgumentException ex) {</span>
<span class="nc" id="L79">        return null;</span>
      }
    }
  }


  static class ApplyActionWrapper&lt;I,O&gt; implements Function&lt;I,O&gt; {

    private final Env env;
    private final Function&lt;I,O&gt; base;
    private final Expression action;

<span class="nc" id="L91">    ApplyActionWrapper(Env env, Function&lt;I,O&gt; base, Expression action) {</span>
<span class="nc" id="L92">      this.env = env;</span>
<span class="nc" id="L93">      this.base = base;</span>
<span class="nc" id="L94">      this.action = action;</span>
<span class="nc" id="L95">    }</span>

    @Override
    public O apply(I in) {
<span class="nc" id="L99">      O v = base.apply(in);</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">      if (action != null) {</span>
<span class="nc" id="L101">        action.evaluate(env, v);</span>
      }
<span class="nc" id="L103">      return v;</span>
    }

  }


<span class="nc" id="L109">  static class TimePatternExtractRuleCreator extends SequenceMatchRules.AnnotationExtractRuleCreator {</span>

    private static void updateExtractRule(SequenceMatchRules.AnnotationExtractRule r,
                                     Env env,
                                     Pattern pattern,
                                     Function&lt;String, Value&gt; extractor) {
<span class="nc" id="L115">      MatchedExpression.SingleAnnotationExtractor annotationExtractor = SequenceMatchRules.createAnnotationExtractor(env,r);</span>
<span class="nc" id="L116">      annotationExtractor.valueExtractor =</span>
              new SequenceMatchRules.CoreMapFunctionApplier&lt;&gt;(
                      env, r.annotationField,
                      extractor);
<span class="nc" id="L120">      r.extractRule = new SequenceMatchRules.CoreMapExtractRule&lt;&gt;(</span>
              env, r.annotationField,
              new SequenceMatchRules.StringPatternExtractRule&lt;&gt;(pattern,
                      new SequenceMatchRules.StringMatchedExpressionExtractor(annotationExtractor, r.matchedExpressionGroup)));
<span class="nc" id="L124">      r.filterRule = new SequenceMatchRules.AnnotationMatchedFilter(annotationExtractor);</span>
<span class="nc" id="L125">      r.pattern = pattern;</span>
<span class="nc" id="L126">    }</span>

    private static void updateExtractRule(SequenceMatchRules.AnnotationExtractRule r,
                                     Env env,
                                     Function&lt;CoreMap, Value&gt; extractor) {
<span class="nc" id="L131">      MatchedExpression.SingleAnnotationExtractor annotationExtractor = SequenceMatchRules.createAnnotationExtractor(env,r);</span>
<span class="nc" id="L132">      annotationExtractor.valueExtractor = extractor;</span>
<span class="nc" id="L133">      r.extractRule = new SequenceMatchRules.CoreMapExtractRule&lt;&gt;(</span>
              env, r.annotationField,
              new SequenceMatchRules.BasicSequenceExtractRule(annotationExtractor));
<span class="nc" id="L136">      r.filterRule = new SequenceMatchRules.AnnotationMatchedFilter(annotationExtractor);</span>
<span class="nc" id="L137">    }</span>

    @Override
    public SequenceMatchRules.AnnotationExtractRule create(Env env, Map&lt;String,Object&gt; attributes) {
<span class="nc" id="L141">      SequenceMatchRules.AnnotationExtractRule r = super.create(env, attributes);</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">      if (r.ruleType == null) { r.ruleType = &quot;time&quot;; }</span>
<span class="nc" id="L143">      String expr = Expressions.asObject(env, attributes.get(&quot;pattern&quot;));</span>
<span class="nc" id="L144">      String formatter = Expressions.asObject(env, attributes.get(&quot;formatter&quot;));</span>
<span class="nc" id="L145">      Expression action = Expressions.asExpression(env, attributes.get(&quot;action&quot;));</span>
<span class="nc" id="L146">      String localeString = Expressions.asObject(env, attributes.get(&quot;locale&quot;));</span>
<span class="nc" id="L147">      r.pattern = expr;</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">      if (formatter == null) {</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">        if (r.annotationField == null) { r.annotationField = EnvLookup.getDefaultTextAnnotationKey(env);  }</span>
        /* Parse pattern and figure out what the result should be.... */
<span class="nc" id="L151">        CustomDateFormatExtractor formatExtractor = new CustomDateFormatExtractor(expr, localeString);</span>
        //SequenceMatchRules.Expression result = (SequenceMatchRules.Expression) attributes.get(&quot;result&quot;);
<span class="nc" id="L153">        updateExtractRule(r, env, formatExtractor.getTextPattern(), new ApplyActionWrapper&lt;&gt;(env, formatExtractor, action));</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">      } else if (&quot;org.joda.time.format.DateTimeFormat&quot;.equals(formatter)) {</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">        if (r.annotationField == null) { r.annotationField = r.tokensAnnotationField;  }</span>
<span class="nc" id="L156">        updateExtractRule(r, env, new ApplyActionWrapper&lt;&gt;(env, new JodaDateTimeFormatExtractor(expr), action));</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">      } else if (&quot;org.joda.time.format.ISODateTimeFormat&quot;.equals(formatter)) {</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">        if (r.annotationField == null) { r.annotationField = r.tokensAnnotationField;  }</span>
        try {
<span class="nc" id="L160">          Method m = ISODateTimeFormat.class.getMethod(expr);</span>
<span class="nc" id="L161">          DateTimeFormatter dtf = (DateTimeFormatter) m.invoke(null);</span>
<span class="nc" id="L162">          updateExtractRule(r, env, new ApplyActionWrapper&lt;&gt;(env, new JodaDateTimeFormatExtractor(expr), action));</span>
<span class="nc" id="L163">        } catch (Exception ex) {</span>
<span class="nc" id="L164">          throw new RuntimeException(&quot;Error creating DateTimeFormatter&quot;, ex);</span>
<span class="nc" id="L165">        }</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">      } else if (&quot;java.text.SimpleDateFormat&quot;.equals(formatter)) {</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">        if (r.annotationField == null) { r.annotationField = r.tokensAnnotationField;  }</span>
<span class="nc" id="L168">        updateExtractRule(r, env, new ApplyActionWrapper&lt;&gt;(env, new JavaDateFormatExtractor(expr), action));</span>
      } else {
<span class="nc" id="L170">        throw new IllegalArgumentException(&quot;Unsupported formatter: &quot; + formatter);</span>
      }
<span class="nc" id="L172">      return r;</span>
    }
  }

  /*
   * Rules for parsing time specific patterns.
   * Patterns are similar to time patterns used by JodaTime combined with a simplified regex expression
   *
   # y       year                         year          1996                         y
   # M       month of year                month         July; Jul; 07                M
   # d       day of month                 number        10                           d
   # H       hour of day (0~23)           number        0                            H
   # k       clockhour of day (1~24)      number        24                           k
   # m       minute of hour               number        30                           m
   # s       second of minute             number        55                           s
   # S       fraction of second           number        978                          S (Millisecond)
   # a       half day of day marker       am/pm
   */

  /**
   * Converts time string pattern to text pattern.
   */
  public static class CustomDateFormatExtractor implements Function&lt;String, Value&gt; {

    private final FormatterBuilder builder;
    private final String timePattern;
    private final Pattern textPattern;

<span class="nc" id="L200">    public CustomDateFormatExtractor(String timePattern, String localeString) {</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">      Locale locale = (localeString != null)? new Locale(localeString): Locale.getDefault();</span>
<span class="nc" id="L202">      this.timePattern = timePattern;</span>
<span class="nc" id="L203">      builder = new FormatterBuilder();</span>
<span class="nc" id="L204">      builder.locale = locale;</span>
<span class="nc" id="L205">      parsePatternTo(builder, timePattern);</span>
<span class="nc" id="L206">      textPattern = builder.toTextPattern();</span>
<span class="nc" id="L207">    }</span>

    public Pattern getTextPattern()
    {
<span class="nc" id="L211">      return textPattern;</span>
    }

    public Value apply(String str) {
<span class="nc" id="L215">      Value v = null;</span>
<span class="nc" id="L216">      Matcher m = textPattern.matcher(str);</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">      if (m.matches()) {</span>
<span class="nc" id="L218">        return apply(m);</span>
      }
<span class="nc" id="L220">      return v;</span>
    }

    public Value apply(MatchResult m) {
<span class="nc" id="L224">      SUTime.Temporal t = new SUTime.PartialTime();</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">      for (FormatComponent fc:builder.pieces) {</span>
<span class="nc" id="L226">        int group = fc.getGroup();</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">        if (group &gt; 0) {</span>
<span class="nc" id="L228">          String fieldValueStr = m.group(group);</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">          if (fieldValueStr != null) {</span>
            try {
<span class="nc" id="L231">              t = fc.updateTemporal(t, fieldValueStr);</span>
<span class="nc" id="L232">            } catch (IllegalArgumentException ex) {</span>
<span class="nc" id="L233">              return null;</span>
<span class="nc" id="L234">            }</span>
          }
        }
<span class="nc" id="L237">      }</span>
<span class="nc" id="L238">      return new Expressions.PrimitiveValue(&quot;Temporal&quot;, t);</span>
    }

  }


<span class="nc" id="L244">  private abstract static class FormatComponent {</span>

<span class="nc" id="L246">    int group = -1;</span>
<span class="nc" id="L247">    String quantifier = null;</span>

    public void appendQuantifier(String str) {
<span class="nc bnc" id="L250" title="All 2 branches missed.">      if (quantifier != null) {</span>
<span class="nc" id="L251">        quantifier = quantifier + str;</span>
      } else {
<span class="nc" id="L253">        quantifier = str;</span>
      }
<span class="nc" id="L255">    }</span>

    public StringBuilder appendRegex(StringBuilder sb) {
<span class="nc bnc" id="L258" title="All 2 branches missed.">      if (group &gt; 0) {</span>
<span class="nc" id="L259">        sb.append('(');</span>
      }
<span class="nc" id="L261">      appendRegex0(sb);</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">      if (quantifier != null) {</span>
<span class="nc" id="L263">        sb.append(quantifier);</span>
      }
<span class="nc bnc" id="L265" title="All 2 branches missed.">      if (group &gt; 0) {</span>
<span class="nc" id="L266">        sb.append(')');</span>
      }
<span class="nc" id="L268">      return sb;</span>
    }
    protected abstract StringBuilder appendRegex0(StringBuilder sb);

<span class="nc" id="L272">    public SUTime.Temporal updateTemporal(SUTime.Temporal t, String fieldValueStr) { return t; }</span>
<span class="nc" id="L273">    public int getGroup() { return group; }</span>

  }

<span class="nc" id="L277">  private abstract static class DateTimeFieldComponent extends FormatComponent {</span>

    DateTimeFieldType fieldType;

<span class="nc" id="L281">    public Integer parseValue(String str) { return null; }</span>
<span class="nc" id="L282">    public DateTimeFieldType getDateTimeFieldType() { return fieldType; }</span>

    public SUTime.Temporal updateTemporal(SUTime.Temporal t, String fieldValueStr) {
<span class="nc" id="L285">      DateTimeFieldType dt = getDateTimeFieldType();</span>
<span class="nc bnc" id="L286" title="All 4 branches missed.">      if (fieldValueStr != null &amp;&amp; dt != null) {</span>
<span class="nc" id="L287">        Integer v = parseValue(fieldValueStr);</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">        if (v != null) {</span>
<span class="nc" id="L289">          Partial pt = new Partial();</span>
<span class="nc" id="L290">          pt = JodaTimeUtils.setField(pt, dt, v);</span>
<span class="nc" id="L291">          t = t.intersect(new SUTime.PartialTime(pt));</span>
<span class="nc" id="L292">        } else {</span>
<span class="nc" id="L293">          throw new IllegalArgumentException(&quot;Cannot interpret &quot; + fieldValueStr + &quot; for &quot; + fieldType);</span>
        }
      }
<span class="nc" id="L296">      return t;</span>
    }

  }


  private static class NumericDateComponent extends DateTimeFieldComponent {

    private final int minValue;
    private final int maxValue;
    private final int minDigits;
    private final int maxDigits;

<span class="nc" id="L309">    public NumericDateComponent(DateTimeFieldType fieldType, int minDigits, int maxDigits) {</span>
<span class="nc" id="L310">      this.fieldType = fieldType;</span>
<span class="nc" id="L311">      this.minDigits = minDigits;</span>
<span class="nc" id="L312">      this.maxDigits = maxDigits;</span>
<span class="nc" id="L313">      MutableDateTime dt = new MutableDateTime(0L, DateTimeZone.UTC);</span>
<span class="nc" id="L314">      MutableDateTime.Property property = dt.property(fieldType);</span>
<span class="nc" id="L315">      minValue = property.getMinimumValueOverall();</span>
<span class="nc" id="L316">      maxValue = property.getMaximumValueOverall();</span>
<span class="nc" id="L317">    }</span>

    protected StringBuilder appendRegex0(StringBuilder sb) {
<span class="nc bnc" id="L320" title="All 4 branches missed.">      if (maxDigits &gt; 5 || minDigits != maxDigits) {</span>
<span class="nc" id="L321">        sb.append(&quot;\\d{&quot;).append(minDigits).append(',').append(maxDigits).append('}');</span>
      } else {
<span class="nc bnc" id="L323" title="All 2 branches missed.">        for (int i = 0; i &lt; minDigits; i++) {</span>
<span class="nc" id="L324">          sb.append(&quot;\\d&quot;);</span>
        }
      }
<span class="nc" id="L327">      return sb;</span>
    }

    public Integer parseValue(String str) {
<span class="nc" id="L331">      int v = Integer.valueOf(str);</span>
<span class="nc bnc" id="L332" title="All 4 branches missed.">      if (v &gt;= minValue &amp;&amp; v &lt;= maxValue) {</span>
<span class="nc" id="L333">        return v;</span>
      } else {
<span class="nc" id="L335">        return null;</span>
      }
    }

  }


  private static class RelaxedNumericDateComponent extends FormatComponent
  {
    NumericDateComponent[] possibleNumericDateComponents;
    int minDigits;
    int maxDigits;

    public RelaxedNumericDateComponent(DateTimeFieldType[] fieldTypes, int minDigits, int maxDigits)
<span class="nc" id="L349">    {</span>
<span class="nc" id="L350">      this.minDigits = minDigits;</span>
<span class="nc" id="L351">      this.maxDigits = maxDigits;</span>
<span class="nc" id="L352">      possibleNumericDateComponents = new NumericDateComponent[fieldTypes.length];</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">      for (int i = 0; i &lt; fieldTypes.length; i++) {</span>
<span class="nc" id="L354">        possibleNumericDateComponents[i] = new NumericDateComponent(fieldTypes[i], minDigits, maxDigits);</span>
      }
<span class="nc" id="L356">    }</span>

    protected StringBuilder appendRegex0(StringBuilder sb) {
<span class="nc bnc" id="L359" title="All 4 branches missed.">      if (maxDigits &gt; 5 || minDigits != maxDigits) {</span>
<span class="nc" id="L360">        sb.append(&quot;\\d{&quot;).append(minDigits).append(&quot;,&quot;).append(maxDigits).append(&quot;}&quot;);</span>
      } else {
<span class="nc bnc" id="L362" title="All 2 branches missed.">        for (int i = 0; i &lt; minDigits; i++) {</span>
<span class="nc" id="L363">          sb.append(&quot;\\d&quot;);</span>
        }
      }
<span class="nc" id="L366">      return sb;</span>
    }

    public SUTime.Temporal updateTemporal(SUTime.Temporal t, String fieldValueStr) {
<span class="nc bnc" id="L370" title="All 2 branches missed.">      if (fieldValueStr != null) {</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">        for (NumericDateComponent c:possibleNumericDateComponents) {</span>
<span class="nc" id="L372">          Integer v = c.parseValue(fieldValueStr);</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">          if (v != null) {</span>
<span class="nc" id="L374">            t = c.updateTemporal(t, fieldValueStr);</span>
<span class="nc" id="L375">            return t;</span>
          }
        }
<span class="nc" id="L378">        throw new IllegalArgumentException(&quot;Cannot interpret &quot; + fieldValueStr);</span>
      }
<span class="nc" id="L380">      return t;</span>
    }
  }

<span class="nc" id="L384">  private static final Comparator&lt;String&gt; STRING_LENGTH_REV_COMPARATOR = (o1, o2) -&gt; {</span>
<span class="nc bnc" id="L385" title="All 2 branches missed.">    if (o1.length() &gt; o2.length()) return -1;</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">    else if (o1.length() &lt; o2.length()) return 1;</span>
    else {
<span class="nc" id="L388">      return o1.compareToIgnoreCase(o2);</span>
    }
  };


  private static class TextDateComponent extends DateTimeFieldComponent {

    Map&lt;String, Integer&gt; valueMapping;
    List&lt;String&gt; validValues;
    Locale locale;
    int minValue;
    int maxValue;
    Boolean isShort;

<span class="nc" id="L402">    public TextDateComponent() {}</span>

<span class="nc" id="L404">    public TextDateComponent(DateTimeFieldType fieldType, Locale locale, Boolean isShort) {</span>
<span class="nc" id="L405">      this.fieldType = fieldType;</span>
<span class="nc" id="L406">      this.locale = locale;</span>
<span class="nc" id="L407">      this.isShort = isShort;</span>

<span class="nc" id="L409">      MutableDateTime dt = new MutableDateTime(0L, DateTimeZone.UTC);</span>
<span class="nc" id="L410">      MutableDateTime.Property property = dt.property(fieldType);</span>
<span class="nc" id="L411">      minValue = property.getMinimumValueOverall();</span>
<span class="nc" id="L412">      maxValue = property.getMaximumValueOverall();</span>
<span class="nc" id="L413">      this.validValues = new ArrayList&lt;&gt;(maxValue - minValue + 1);</span>
<span class="nc" id="L414">      this.valueMapping = Generics.newHashMap();</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">      for (int i = minValue; i &lt;= maxValue; i++) {</span>
<span class="nc" id="L416">        property.set(i);</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">        if (isShort != null) {</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">          if (isShort) {</span>
<span class="nc" id="L419">            addValue(property.getAsShortText(locale), i);</span>
          } else {
<span class="nc" id="L421">            addValue(property.getAsText(locale), i);</span>
          }
        } else {
<span class="nc" id="L424">          addValue(property.getAsShortText(locale), i);</span>
<span class="nc" id="L425">          addValue(property.getAsText(locale), i);</span>
        }
      }
      // Order by length for regex
<span class="nc" id="L429">      Collections.sort(validValues, STRING_LENGTH_REV_COMPARATOR);</span>
<span class="nc" id="L430">    }</span>

    public void addValue(String str, int v) {
<span class="nc" id="L433">      validValues.add(str);</span>
<span class="nc" id="L434">      valueMapping.put(str.toLowerCase(locale), v);</span>
<span class="nc" id="L435">    }</span>

    public Integer parseValue(String str) {
<span class="nc" id="L438">      str = str.toLowerCase(locale);</span>
<span class="nc" id="L439">      Integer v = valueMapping.get(str);</span>
<span class="nc" id="L440">      return v;</span>
    }

    @Override
    protected StringBuilder appendRegex0(StringBuilder sb) {
<span class="nc" id="L445">      boolean first = true;</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">      for (String v:validValues) {</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">        if (first) {</span>
<span class="nc" id="L448">          first = false;</span>
        } else {
<span class="nc" id="L450">          sb.append(&quot;|&quot;);</span>
        }
<span class="nc" id="L452">        sb.append(Pattern.quote(v));</span>
<span class="nc" id="L453">      }</span>
<span class="nc" id="L454">      return sb;</span>
    }
  }

  private static class TimeZoneOffsetComponent extends FormatComponent
  {
    String zeroOffsetParseText;  // Text indicating timezone offset is zero

    // TimezoneOffset is + or - followed by
    // hh
    // hhmm
    // hhmmss
    // hhmmssSSS
    // hh:mm
    // hh:mm:ss
    // hh:mm:ss.SSS
    public TimeZoneOffsetComponent(String zeroOffsetParseText)
<span class="nc" id="L471">    {</span>
<span class="nc" id="L472">      this.zeroOffsetParseText = zeroOffsetParseText;</span>
<span class="nc" id="L473">    }</span>

    protected StringBuilder appendRegex0(StringBuilder sb) {
<span class="nc" id="L476">      sb.append(&quot;[+-]\\d\\d(?::?\\d\\d(?::?\\d\\d(?:[.,]?\\d{1,3})?)?)?&quot;);</span>
<span class="nc bnc" id="L477" title="All 2 branches missed.">      if (zeroOffsetParseText != null) {</span>
<span class="nc" id="L478">        sb.append(&quot;|&quot;).append(Pattern.quote(zeroOffsetParseText));</span>
      }
<span class="nc" id="L480">      return sb;</span>
    }

    private static int parseInteger(String str, int pos, int length) {
<span class="nc" id="L484">      return Integer.parseInt(str.substring(pos, pos+length));</span>
    }

    public int parseOffsetMillis(String str) {
<span class="nc" id="L488">      int offset = 0;</span>
<span class="nc bnc" id="L489" title="All 4 branches missed.">      if (zeroOffsetParseText != null &amp;&amp; str.equalsIgnoreCase(zeroOffsetParseText)) {</span>
<span class="nc" id="L490">        return offset;</span>
      }
<span class="nc" id="L492">      boolean negative = false;</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">      if (str.startsWith(&quot;+&quot;)) {</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">      } else if (str.startsWith(&quot;-&quot;)) {</span>
<span class="nc" id="L495">        negative = true;</span>
      } else {
<span class="nc" id="L497">        throw new IllegalArgumentException(&quot;Invalid date time zone offset &quot; + str);</span>
      }
<span class="nc" id="L499">      int pos = 1;</span>
      // Parse hours
<span class="nc" id="L501">      offset += DateTimeConstants.MILLIS_PER_HOUR * parseInteger(str, pos, 2);</span>
<span class="nc" id="L502">      pos += 2;</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">      if (pos &lt; str.length()) {</span>
        // Parse minutes
<span class="nc bnc" id="L505" title="All 2 branches missed.">        if (!Character.isDigit(str.charAt(pos))) { pos++; }</span>
<span class="nc" id="L506">        offset += DateTimeConstants.MILLIS_PER_MINUTE * parseInteger(str, pos, 2);</span>
<span class="nc" id="L507">        pos += 2;</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">        if (pos &lt; str.length()) {</span>
          // Parse seconds
<span class="nc bnc" id="L510" title="All 2 branches missed.">          if (!Character.isDigit(str.charAt(pos))) { pos++; }</span>
<span class="nc" id="L511">          offset += DateTimeConstants.MILLIS_PER_SECOND * parseInteger(str, pos, 2);</span>
<span class="nc" id="L512">          pos += 2;</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">          if (pos &lt; str.length()) {</span>
            // Parse fraction of seconds
<span class="nc bnc" id="L515" title="All 2 branches missed.">            if (!Character.isDigit(str.charAt(pos))) { pos++; }</span>
<span class="nc" id="L516">            int digits = str.length()-pos;</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">            if (digits &gt; 0) {</span>
<span class="nc bnc" id="L518" title="All 2 branches missed.">              if (digits &lt;= 3) {</span>
<span class="nc" id="L519">                int frac = parseInteger(str, pos, digits);</span>
<span class="nc bnc" id="L520" title="All 2 branches missed.">                if (digits == 1) {</span>
<span class="nc" id="L521">                  offset += frac*100;</span>
<span class="nc bnc" id="L522" title="All 2 branches missed.">                } else if (digits == 2) {</span>
<span class="nc" id="L523">                  offset += frac*10;</span>
<span class="nc bnc" id="L524" title="All 2 branches missed.">                } else if (digits == 3) {</span>
<span class="nc" id="L525">                  offset += frac;</span>
                }
<span class="nc" id="L527">              } else {</span>
<span class="nc" id="L528">                throw new IllegalArgumentException(&quot;Invalid date time zone offset &quot; + str);</span>
              }
            }
          }
        }
      }
<span class="nc bnc" id="L534" title="All 2 branches missed.">      if (negative) offset = -offset;</span>
<span class="nc" id="L535">      return offset;</span>
    }
    public SUTime.Temporal updateTemporal(SUTime.Temporal t, String fieldValueStr) {
<span class="nc" id="L538">      int offset = parseOffsetMillis(fieldValueStr);</span>
<span class="nc" id="L539">      DateTimeZone dtz = DateTimeZone.forOffsetMillis(offset);</span>
<span class="nc" id="L540">      return t.setTimeZone(dtz);</span>
    }
  }

  private static String makeRegex(List&lt;String&gt; strs) {
<span class="nc" id="L545">    StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L546">    boolean first = true;</span>
<span class="nc bnc" id="L547" title="All 2 branches missed.">    for (String v:strs) {</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">      if (first) {</span>
<span class="nc" id="L549">        first = false;</span>
      } else {
<span class="nc" id="L551">        sb.append(&quot;|&quot;);</span>
      }
<span class="nc" id="L553">      sb.append(Pattern.quote(v));</span>
<span class="nc" id="L554">    }</span>
<span class="nc" id="L555">    return sb.toString();</span>
  }

  // Timezones
  //  ID - US/Pacific
  //  Name - Pacific Standard Time (or Pacific Daylight Time)
  //  ShortName  PST (or PDT depending on input milliseconds)
  //  NameKey    PST (or PDT depending on input milliseconds)
  private static class TimeZoneIdComponent extends FormatComponent
  {
    static final Map&lt;String, DateTimeZone&gt; timeZonesById;
    static final List&lt;String&gt; timeZoneIds;
    static final String timeZoneIdsRegex;
    static {
<span class="nc" id="L569">      timeZoneIds = new ArrayList&lt;&gt;(DateTimeZone.getAvailableIDs());</span>
<span class="nc" id="L570">      timeZonesById = Generics.newHashMap();</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">      for (String str:timeZoneIds) {</span>
<span class="nc" id="L572">        DateTimeZone dtz = DateTimeZone.forID(str);</span>
<span class="nc" id="L573">        timeZonesById.put(str.toLowerCase(), dtz);</span>
//        System.out.println(str);
//        long time = System.currentTimeMillis();
//        System.out.println(dtz.getShortName(time));
//        System.out.println(dtz.getName(time));
//        System.out.println(dtz.getNameKey(time));
//        System.out.println();
<span class="nc" id="L580">      }</span>
      // Order by length for regex
<span class="nc" id="L582">      Collections.sort(timeZoneIds, STRING_LENGTH_REV_COMPARATOR);</span>
<span class="nc" id="L583">      timeZoneIdsRegex = makeRegex(timeZoneIds);</span>
<span class="nc" id="L584">    }</span>

    public TimeZoneIdComponent()
<span class="nc" id="L587">    {</span>
<span class="nc" id="L588">    }</span>

    private static DateTimeZone parseDateTimeZone(String str) {
<span class="nc" id="L591">      str = str.toLowerCase();</span>
<span class="nc" id="L592">      DateTimeZone v = timeZonesById.get(str);</span>
<span class="nc" id="L593">      return v;</span>
    }

    protected StringBuilder appendRegex0(StringBuilder sb) {
<span class="nc" id="L597">      sb.append(timeZoneIdsRegex);</span>
<span class="nc" id="L598">      return sb;</span>
    }

    public SUTime.Temporal updateTemporal(SUTime.Temporal t, String fieldValueStr) {
<span class="nc bnc" id="L602" title="All 2 branches missed.">      if (fieldValueStr != null) {</span>
<span class="nc" id="L603">        DateTimeZone dtz = parseDateTimeZone(fieldValueStr);</span>
<span class="nc" id="L604">        return t.setTimeZone(dtz);</span>
      }
<span class="nc" id="L606">      return t;</span>
    }
  }

  private static class TimeZoneComponent extends FormatComponent
  {
    Locale locale;

<span class="nc" id="L614">    static Map&lt;Locale, CollectionValuedMap&lt;String, DateTimeZone&gt;&gt; timeZonesByName = Generics.newHashMap();</span>
<span class="nc" id="L615">    static Map&lt;Locale, List&lt;String&gt;&gt; timeZoneNames = Generics.newHashMap();</span>
<span class="nc" id="L616">    static Map&lt;Locale, String&gt; timeZoneRegexes = Generics.newHashMap();</span>

    public TimeZoneComponent(Locale locale)
<span class="nc" id="L619">    {</span>
<span class="nc" id="L620">      this.locale = locale;</span>
<span class="nc" id="L621">      synchronized (TimeZoneComponent.class) {</span>
<span class="nc" id="L622">        String regex = timeZoneRegexes.get(locale);</span>
<span class="nc bnc" id="L623" title="All 2 branches missed.">        if (regex == null) {</span>
<span class="nc" id="L624">          updateTimeZoneNames(locale);</span>
        }
<span class="nc" id="L626">      }</span>
<span class="nc" id="L627">    }</span>

    private static void updateTimeZoneNames(Locale locale) {
<span class="nc" id="L630">      long time1 = new SUTime.IsoDate(2013,1,1).getJodaTimeInstant().getMillis();</span>
<span class="nc" id="L631">      long time2 = new SUTime.IsoDate(2013,6,1).getJodaTimeInstant().getMillis();</span>
<span class="nc" id="L632">      CollectionValuedMap&lt;String,DateTimeZone&gt; tzMap = new CollectionValuedMap&lt;&gt;();</span>
<span class="nc bnc" id="L633" title="All 2 branches missed.">      for (DateTimeZone dtz:TimeZoneIdComponent.timeZonesById.values()) {</span>
        // standard timezones
<span class="nc" id="L635">        tzMap.add(dtz.getShortName(time1, locale).toLowerCase(), dtz);</span>
<span class="nc" id="L636">        tzMap.add(dtz.getName(time1, locale).toLowerCase(), dtz);</span>
        // Add about half a year to get day light savings timezones...
<span class="nc" id="L638">        tzMap.add(dtz.getShortName(time2, locale).toLowerCase(), dtz);</span>
<span class="nc" id="L639">        tzMap.add(dtz.getName(time2, locale).toLowerCase(), dtz);</span>
//      tzMap.add(dtz.getNameKey(time).toLowerCase(), dtz);
//      tzMap.add(dtz.getID().toLowerCase(), dtz);
<span class="nc" id="L642">      }</span>
      // Order by length for regex
<span class="nc" id="L644">      List&lt;String&gt; tzNames = new ArrayList&lt;&gt;(tzMap.keySet());</span>
<span class="nc" id="L645">      Collections.sort(tzNames, STRING_LENGTH_REV_COMPARATOR);</span>
<span class="nc" id="L646">      String tzRegex = makeRegex(tzNames);</span>
<span class="nc" id="L647">      synchronized (TimeZoneComponent.class) {</span>
<span class="nc" id="L648">        timeZoneNames.put(locale,tzNames);</span>
<span class="nc" id="L649">        timeZonesByName.put(locale,tzMap);</span>
<span class="nc" id="L650">        timeZoneRegexes.put(locale,tzRegex);</span>
<span class="nc" id="L651">      }</span>
<span class="nc" id="L652">    }</span>

    public DateTimeZone parseDateTimeZone(String str) {
      // TODO: do something about these multiple timezones that match the same name...
      // pick one based on location
<span class="nc" id="L657">      str = str.toLowerCase();</span>
<span class="nc" id="L658">      CollectionValuedMap&lt;String,DateTimeZone&gt; tzMap = timeZonesByName.get(locale);</span>
<span class="nc" id="L659">      Collection&lt;DateTimeZone&gt; v = tzMap.get(str);</span>
<span class="nc bnc" id="L660" title="All 4 branches missed.">      if (v == null || v.isEmpty()) return null;</span>
<span class="nc" id="L661">      else return v.iterator().next();</span>
    }

    protected StringBuilder appendRegex0(StringBuilder sb) {
<span class="nc" id="L665">      String regex = timeZoneRegexes.get(locale);</span>
<span class="nc" id="L666">      sb.append(regex);</span>
<span class="nc" id="L667">      return sb;</span>
    }

    public SUTime.Temporal updateTemporal(SUTime.Temporal t, String fieldValueStr) {
<span class="nc bnc" id="L671" title="All 2 branches missed.">      if (fieldValueStr != null) {</span>
<span class="nc" id="L672">        DateTimeZone dtz = parseDateTimeZone(fieldValueStr);</span>
<span class="nc" id="L673">        return t.setTimeZone(dtz);</span>
      }
<span class="nc" id="L675">      return t;</span>
    }
  }


  private static class LiteralComponent extends FormatComponent {

    private final String text;

<span class="nc" id="L684">    public LiteralComponent(String str) {</span>
<span class="nc" id="L685">      this.text = str;</span>
<span class="nc" id="L686">    }</span>

    @Override
    protected StringBuilder appendRegex0(StringBuilder sb) {
<span class="nc" id="L690">      sb.append(Pattern.quote(text));</span>
<span class="nc" id="L691">      return sb;</span>
    }

  }


  private static class RegexComponent extends FormatComponent {

    private final String regex;

<span class="nc" id="L701">    public RegexComponent(String regex) {</span>
<span class="nc" id="L702">      this.regex = regex;</span>
<span class="nc" id="L703">    }</span>

    @Override
    protected StringBuilder appendRegex0(StringBuilder sb) {
<span class="nc" id="L707">      sb.append(regex);</span>
<span class="nc" id="L708">      return sb;</span>
    }

  }


<span class="nc" id="L714">  private static class FormatterBuilder {</span>

<span class="nc" id="L716">    boolean useRelaxedHour = true;</span>
    Locale locale;
<span class="nc" id="L718">    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();</span>
<span class="nc" id="L719">    List&lt;FormatComponent&gt; pieces = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L720">    int curGroup = 0;</span>

    public DateTimeFormatter toFormatter() {
<span class="nc" id="L723">      return builder.toFormatter();</span>
    }

    public String toTextRegex() {
<span class="nc" id="L727">      StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L728">      sb.append(&quot;\\b&quot;);</span>
<span class="nc bnc" id="L729" title="All 2 branches missed.">      for (FormatComponent fc:pieces) {</span>
<span class="nc" id="L730">        fc.appendRegex(sb);</span>
<span class="nc" id="L731">      }</span>
<span class="nc" id="L732">      sb.append(&quot;\\b&quot;);</span>
<span class="nc" id="L733">      return sb.toString();</span>
    }

    public Pattern toTextPattern() {
<span class="nc" id="L737">      return Pattern.compile(toTextRegex(), Pattern.CASE_INSENSITIVE);</span>
    }

    private void appendNumericFields(DateTimeFieldType[] fieldTypes, int digits) {
<span class="nc" id="L741">      appendNumericFields(fieldTypes, digits, digits);</span>
<span class="nc" id="L742">    }</span>

    private void appendNumericFields(DateTimeFieldType[] fieldTypes, int minDigits, int maxDigits) {
<span class="nc" id="L745">      appendComponent(new RelaxedNumericDateComponent(fieldTypes, minDigits, maxDigits), true);</span>
<span class="nc" id="L746">    }</span>

    private void appendNumericField(DateTimeFieldType fieldType, int digits) {
<span class="nc" id="L749">      appendNumericField(fieldType, digits, digits);</span>
<span class="nc" id="L750">    }</span>

    private void appendNumericField(DateTimeFieldType fieldType, int minDigits, int maxDigits) {
<span class="nc" id="L753">      appendComponent(new NumericDateComponent(fieldType, minDigits, maxDigits), true);</span>
<span class="nc" id="L754">    }</span>

    private void appendTextField(DateTimeFieldType fieldType, boolean isShort) {
<span class="nc" id="L757">      appendComponent(new TextDateComponent(fieldType, locale, isShort), true);</span>
<span class="nc" id="L758">    }</span>

    private void appendComponent(FormatComponent fc, boolean hasGroup)
    {
<span class="nc bnc" id="L762" title="All 2 branches missed.">      if (hasGroup) {</span>
<span class="nc" id="L763">        fc.group = ++curGroup;</span>
      }
<span class="nc" id="L765">      pieces.add(fc);</span>
<span class="nc" id="L766">    }</span>

    private void appendLiteralField(String s) {
<span class="nc" id="L769">      appendComponent(new LiteralComponent(s), false);</span>
<span class="nc" id="L770">    }</span>

    private void appendRegexPart(String s) {
<span class="nc" id="L773">      appendComponent(new RegexComponent(s), false);</span>
<span class="nc" id="L774">    }</span>

    protected void appendEraText() {
<span class="nc" id="L777">      builder.appendEraText();</span>
<span class="nc" id="L778">      appendTextField(DateTimeFieldType.era(), false);</span>
<span class="nc" id="L779">    }</span>
    protected void appendCenturyOfEra(int minDigits, int maxDigits) {
<span class="nc" id="L781">      builder.appendCenturyOfEra(minDigits, maxDigits);</span>
<span class="nc" id="L782">      appendNumericField(DateTimeFieldType.centuryOfEra(), minDigits, maxDigits);</span>
<span class="nc" id="L783">    }</span>
    protected void appendYearOfEra(int minDigits, int maxDigits) {
<span class="nc" id="L785">      builder.appendYearOfEra(minDigits, maxDigits);</span>
<span class="nc" id="L786">      appendNumericField(DateTimeFieldType.yearOfEra(), minDigits, maxDigits);</span>
<span class="nc" id="L787">    }</span>
    protected void appendYear(int minDigits, int maxDigits) {
<span class="nc" id="L789">      builder.appendYear(minDigits, maxDigits);</span>
<span class="nc" id="L790">      appendNumericField(DateTimeFieldType.year(), minDigits, maxDigits);</span>
<span class="nc" id="L791">    }</span>
    protected void appendTwoDigitYear(int pivot, boolean lenient) {
<span class="nc" id="L793">      builder.appendTwoDigitYear(pivot, lenient);</span>
<span class="nc" id="L794">      appendNumericField(DateTimeFieldType.yearOfCentury(), 2);</span>
<span class="nc" id="L795">    }</span>
    protected void appendWeekyear(int minDigits, int maxDigits) {
<span class="nc" id="L797">      builder.appendWeekyear(minDigits, maxDigits);</span>
<span class="nc" id="L798">      appendNumericField(DateTimeFieldType.weekyear(), minDigits, maxDigits);</span>
<span class="nc" id="L799">    }</span>
    protected void appendTwoDigitWeekyear(int pivot, boolean lenient) {
<span class="nc" id="L801">      builder.appendTwoDigitYear(pivot, lenient);</span>
<span class="nc" id="L802">      appendNumericField(DateTimeFieldType.yearOfCentury(), 2);</span>
<span class="nc" id="L803">    }</span>
    protected void appendWeekOfWeekyear(int digits) {
<span class="nc" id="L805">      builder.appendWeekOfWeekyear(digits);</span>
<span class="nc" id="L806">      appendNumericField(DateTimeFieldType.weekOfWeekyear(), digits);</span>
<span class="nc" id="L807">    }</span>

    protected void appendMonthOfYear(int digits) {
<span class="nc" id="L810">      builder.appendMonthOfYear(digits);</span>
<span class="nc" id="L811">      appendNumericField(DateTimeFieldType.monthOfYear(), digits);</span>
<span class="nc" id="L812">    }</span>
    protected void appendMonthOfYearShortText() {
<span class="nc" id="L814">      builder.appendMonthOfYearShortText();</span>
<span class="nc" id="L815">      appendTextField(DateTimeFieldType.monthOfYear(), true);</span>
<span class="nc" id="L816">    }</span>
    protected void appendMonthOfYearText() {
<span class="nc" id="L818">      builder.appendMonthOfYearText();</span>
<span class="nc" id="L819">      appendTextField(DateTimeFieldType.monthOfYear(), false);</span>
<span class="nc" id="L820">    }</span>

    protected void appendDayOfYear(int digits) {
<span class="nc" id="L823">      builder.appendDayOfYear(digits);</span>
<span class="nc" id="L824">      appendNumericField(DateTimeFieldType.dayOfYear(), digits);</span>
<span class="nc" id="L825">    }</span>
    protected void appendDayOfMonth(int digits) {
<span class="nc" id="L827">      builder.appendDayOfMonth(digits);</span>
<span class="nc" id="L828">      appendNumericField(DateTimeFieldType.dayOfMonth(), digits);</span>
<span class="nc" id="L829">    }</span>
    protected void appendDayOfWeek(int digits) {
<span class="nc" id="L831">      builder.appendDayOfWeek(digits);</span>
<span class="nc" id="L832">      appendNumericField(DateTimeFieldType.dayOfWeek(), digits);</span>
<span class="nc" id="L833">    }</span>
    protected void appendDayOfWeekText() {
<span class="nc" id="L835">      builder.appendDayOfWeekText();</span>
<span class="nc" id="L836">      appendTextField(DateTimeFieldType.dayOfWeek(), false);</span>
<span class="nc" id="L837">    }</span>
    protected void appendDayOfWeekShortText() {
<span class="nc" id="L839">      builder.appendDayOfWeekShortText();</span>
<span class="nc" id="L840">      appendTextField(DateTimeFieldType.dayOfWeek(), true);</span>
<span class="nc" id="L841">    }</span>
    protected void appendHalfdayOfDayText() {
<span class="nc" id="L843">      builder.appendHalfdayOfDayText();</span>
<span class="nc" id="L844">      appendTextField(DateTimeFieldType.halfdayOfDay(), false);</span>
<span class="nc" id="L845">    }</span>
    protected void appendClockhourOfDay(int digits) {
<span class="nc" id="L847">      builder.appendDayOfYear(digits);</span>
<span class="nc" id="L848">      appendNumericField(DateTimeFieldType.clockhourOfDay(), digits);</span>
<span class="nc" id="L849">    }</span>
    protected void appendClockhourOfHalfday(int digits) {
<span class="nc" id="L851">      builder.appendClockhourOfHalfday(digits);</span>
<span class="nc" id="L852">      appendNumericField(DateTimeFieldType.clockhourOfHalfday(), digits);</span>
<span class="nc" id="L853">    }</span>
    protected void appendHourOfDay(int digits) {
<span class="nc bnc" id="L855" title="All 2 branches missed.">      if (useRelaxedHour) {</span>
<span class="nc" id="L856">        builder.appendHourOfDay(digits);</span>
<span class="nc" id="L857">        appendNumericFields(new DateTimeFieldType[]{DateTimeFieldType.hourOfDay(), DateTimeFieldType.clockhourOfDay()}, digits);</span>
      } else {
<span class="nc" id="L859">        builder.appendHourOfDay(digits);</span>
<span class="nc" id="L860">        appendNumericField(DateTimeFieldType.hourOfDay(), digits);</span>
      }
<span class="nc" id="L862">    }</span>
    protected void appendHourOfHalfday(int digits) {
<span class="nc" id="L864">      builder.appendHourOfHalfday(digits);</span>
<span class="nc" id="L865">      appendNumericField(DateTimeFieldType.hourOfHalfday(), digits);</span>
<span class="nc" id="L866">    }</span>
    protected void appendMinuteOfHour(int digits) {
<span class="nc" id="L868">      builder.appendMinuteOfHour(digits);</span>
<span class="nc" id="L869">      appendNumericField(DateTimeFieldType.minuteOfHour(), digits);</span>
<span class="nc" id="L870">    }</span>
    protected void appendSecondOfMinute(int digits) {
<span class="nc" id="L872">      builder.appendSecondOfMinute(digits);</span>
<span class="nc" id="L873">      appendNumericField(DateTimeFieldType.secondOfMinute(), digits);</span>
<span class="nc" id="L874">    }</span>
    protected void appendFractionOfSecond(int minDigits, int maxDigits) {
<span class="nc" id="L876">      builder.appendFractionOfSecond(minDigits, maxDigits);</span>
<span class="nc" id="L877">      appendNumericField(DateTimeFieldType.millisOfSecond(), minDigits, maxDigits);</span>
<span class="nc" id="L878">    }</span>

    protected void appendTimeZoneOffset(String zeroOffsetText, String zeroOffsetParseText, boolean showSeparators,
                                        int minFields, int maxFields) {
<span class="nc" id="L882">      builder.appendTimeZoneOffset(zeroOffsetText, zeroOffsetParseText, showSeparators, minFields, maxFields);</span>
<span class="nc" id="L883">      appendComponent(new TimeZoneOffsetComponent(zeroOffsetParseText), true);</span>
<span class="nc" id="L884">    }</span>
    protected void appendTimeZoneId() {
<span class="nc" id="L886">      builder.appendTimeZoneId();</span>
<span class="nc" id="L887">      appendComponent(new TimeZoneIdComponent(), true);</span>
<span class="nc" id="L888">    }</span>
    protected void appendTimeZoneName() {
<span class="nc" id="L890">      builder.appendTimeZoneName();</span>
      // TODO: TimeZoneName
<span class="nc" id="L892">      appendComponent(new TimeZoneComponent(locale), true);</span>
<span class="nc" id="L893">    }</span>
    protected void appendTimeZoneShortName() {
<span class="nc" id="L895">      builder.appendTimeZoneShortName();</span>
      // TODO: TimeZoneName
<span class="nc" id="L897">      appendComponent(new TimeZoneComponent(locale), true);</span>
<span class="nc" id="L898">    }</span>

    protected void appendQuantifier(String str) {
<span class="nc bnc" id="L901" title="All 2 branches missed.">      if (pieces.size() &gt; 0) {</span>
<span class="nc" id="L902">        FormatComponent last = pieces.get(pieces.size() - 1);</span>
<span class="nc" id="L903">        last.appendQuantifier(str);</span>
<span class="nc" id="L904">      } else {</span>
<span class="nc" id="L905">        throw new IllegalArgumentException(&quot;Illegal quantifier at beginning of pattern: &quot; + str);</span>
      }
<span class="nc" id="L907">    }</span>
<span class="nc" id="L908">    protected void appendGroupStart() { appendRegexPart(&quot;(?:&quot;);}</span>
<span class="nc" id="L909">    protected void appendGroupEnd() { appendRegexPart(&quot;)&quot;); }</span>
    protected void appendLiteral(char c) {
<span class="nc" id="L911">      builder.appendLiteral(c);</span>
<span class="nc" id="L912">      appendLiteralField(String.valueOf(c));}</span>
    protected void appendLiteral(String s) {
<span class="nc" id="L914">      builder.appendLiteral(s);</span>
<span class="nc" id="L915">      appendLiteralField(s); }</span>
  }

  private static void parsePatternTo(FormatterBuilder builder, String pattern) {
<span class="nc" id="L919">    int length = pattern.length();</span>
<span class="nc" id="L920">    int[] indexRef = new int[1];</span>

<span class="nc bnc" id="L922" title="All 2 branches missed.">    for (int i=0; i&lt;length; i++) {</span>
<span class="nc" id="L923">      indexRef[0] = i;</span>
<span class="nc" id="L924">      String token = parseToken(pattern, indexRef);</span>
<span class="nc" id="L925">      i = indexRef[0];</span>

<span class="nc" id="L927">      int tokenLen = token.length();</span>
<span class="nc bnc" id="L928" title="All 2 branches missed.">      if (tokenLen == 0) {</span>
<span class="nc" id="L929">        break;</span>
      }
<span class="nc" id="L931">      char c = token.charAt(0);</span>

<span class="nc bnc" id="L933" title="All 25 branches missed.">      switch (c) {</span>
        case 'G': // era designator (text)
<span class="nc" id="L935">          builder.appendEraText();</span>
<span class="nc" id="L936">          break;</span>
        case 'C': // century of era (number)
<span class="nc" id="L938">          builder.appendCenturyOfEra(tokenLen, tokenLen);</span>
<span class="nc" id="L939">          break;</span>
        case 'x': // weekyear (number)
        case 'y': // year (number)
        case 'Y': // year of era (number)
<span class="nc bnc" id="L943" title="All 2 branches missed.">          if (tokenLen == 2) {</span>
<span class="nc" id="L944">            boolean lenientParse = true;</span>

            // Peek ahead to next token.
<span class="nc bnc" id="L947" title="All 2 branches missed.">            if (i + 1 &lt; length) {</span>
<span class="nc" id="L948">              indexRef[0]++;</span>
<span class="nc bnc" id="L949" title="All 2 branches missed.">              if (isNumericToken(parseToken(pattern, indexRef))) {</span>
                // If next token is a number, cannot support
                // lenient parse, because it will consume digits
                // that it should not.
<span class="nc" id="L953">                lenientParse = false;</span>
              }
<span class="nc" id="L955">              indexRef[0]--;</span>
            }

            // TODO: fixed pivots doesn't make sense, we want pivots that can change....
            // Use pivots which are compatible with SimpleDateFormat.
<span class="nc bnc" id="L960" title="All 2 branches missed.">            switch (c) {</span>
              case 'x':
<span class="nc" id="L962">                builder.appendTwoDigitWeekyear(new DateTime().getWeekyear() - 30, lenientParse);</span>
<span class="nc" id="L963">                break;</span>
              case 'y':
              case 'Y':
              default:
<span class="nc" id="L967">                builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);</span>
                break;
            }
<span class="nc" id="L970">          } else {</span>
           /* // Try to support long year values.
            int maxDigits = 9;

            // Peek ahead to next token.
            if (i + 1 &lt; length) {
              indexRef[0]++;
              if (isNumericToken(parseToken(pattern, indexRef))) {
                // If next token is a number, cannot support long years.
                maxDigits = tokenLen;
              }
              indexRef[0]--;
            } */
<span class="nc" id="L983">            int maxDigits = 4;</span>

<span class="nc bnc" id="L985" title="All 4 branches missed.">            switch (c) {</span>
              case 'x':
<span class="nc" id="L987">                builder.appendWeekyear(tokenLen, maxDigits);</span>
<span class="nc" id="L988">                break;</span>
              case 'y':
<span class="nc" id="L990">                builder.appendYear(tokenLen, maxDigits);</span>
<span class="nc" id="L991">                break;</span>
              case 'Y':
<span class="nc" id="L993">                builder.appendYearOfEra(tokenLen, maxDigits);</span>
                break;
            }
          }
<span class="nc" id="L997">          break;</span>
        case 'M': // month of year (text and number)
<span class="nc bnc" id="L999" title="All 2 branches missed.">          if (tokenLen &gt;= 3) {</span>
<span class="nc bnc" id="L1000" title="All 2 branches missed.">            if (tokenLen &gt;= 4) {</span>
<span class="nc" id="L1001">              builder.appendMonthOfYearText();</span>
            } else {
<span class="nc" id="L1003">              builder.appendMonthOfYearShortText();</span>
            }
          } else {
<span class="nc" id="L1006">            builder.appendMonthOfYear(tokenLen);</span>
          }
<span class="nc" id="L1008">          break;</span>
        case 'd': // day of month (number)
<span class="nc" id="L1010">          builder.appendDayOfMonth(tokenLen);</span>
<span class="nc" id="L1011">          break;</span>
        case 'a': // am/pm marker (text)
<span class="nc" id="L1013">          builder.appendHalfdayOfDayText();</span>
<span class="nc" id="L1014">          break;</span>
        case 'h': // clockhour of halfday (number, 1..12)
<span class="nc" id="L1016">          builder.appendClockhourOfHalfday(tokenLen);</span>
<span class="nc" id="L1017">          break;</span>
        case 'H': // hour of day (number, 0..23)
<span class="nc" id="L1019">          builder.appendHourOfDay(tokenLen);</span>
<span class="nc" id="L1020">          break;</span>
        case 'k': // clockhour of day (1..24)
<span class="nc" id="L1022">          builder.appendClockhourOfDay(tokenLen);</span>
<span class="nc" id="L1023">          break;</span>
        case 'K': // hour of halfday (0..11)
<span class="nc" id="L1025">          builder.appendHourOfHalfday(tokenLen);</span>
<span class="nc" id="L1026">          break;</span>
        case 'm': // minute of hour (number)
<span class="nc" id="L1028">          builder.appendMinuteOfHour(tokenLen);</span>
<span class="nc" id="L1029">          break;</span>
        case 's': // second of minute (number)
<span class="nc" id="L1031">          builder.appendSecondOfMinute(tokenLen);</span>
<span class="nc" id="L1032">          break;</span>
        case 'S': // fraction of second (number)
<span class="nc" id="L1034">          builder.appendFractionOfSecond(tokenLen, tokenLen);</span>
<span class="nc" id="L1035">          break;</span>
        case 'e': // day of week (number)
<span class="nc" id="L1037">          builder.appendDayOfWeek(tokenLen);</span>
<span class="nc" id="L1038">          break;</span>
        case 'E': // dayOfWeek (text)
<span class="nc bnc" id="L1040" title="All 2 branches missed.">          if (tokenLen &gt;= 4) {</span>
<span class="nc" id="L1041">            builder.appendDayOfWeekText();</span>
          } else {
<span class="nc" id="L1043">            builder.appendDayOfWeekShortText();</span>
          }
<span class="nc" id="L1045">          break;</span>
        case 'D': // day of year (number)
<span class="nc" id="L1047">          builder.appendDayOfYear(tokenLen);</span>
<span class="nc" id="L1048">          break;</span>
        case 'w': // week of weekyear (number)
<span class="nc" id="L1050">          builder.appendWeekOfWeekyear(tokenLen);</span>
<span class="nc" id="L1051">          break;</span>
        case 'z': // time zone (text)
<span class="nc bnc" id="L1053" title="All 2 branches missed.">          if (tokenLen &gt;= 4) {</span>
<span class="nc" id="L1054">            builder.appendTimeZoneName();</span>
          } else {
<span class="nc" id="L1056">            builder.appendTimeZoneShortName();</span>
          }
<span class="nc" id="L1058">          break;</span>
        case 'Z': // time zone offset
<span class="nc bnc" id="L1060" title="All 2 branches missed.">          if (tokenLen == 1) {</span>
<span class="nc" id="L1061">            builder.appendTimeZoneOffset(null, &quot;Z&quot;, false, 2, 2);</span>
<span class="nc bnc" id="L1062" title="All 2 branches missed.">          } else if (tokenLen == 2) {</span>
<span class="nc" id="L1063">            builder.appendTimeZoneOffset(null, &quot;Z&quot;, true, 2, 2);</span>
          } else {
<span class="nc" id="L1065">            builder.appendTimeZoneId();</span>
          }
<span class="nc" id="L1067">          break;</span>
        case '(':
<span class="nc" id="L1069">          builder.appendGroupStart();</span>
<span class="nc" id="L1070">          break;</span>
        case ')':
<span class="nc" id="L1072">          builder.appendGroupEnd();</span>
<span class="nc" id="L1073">          break;</span>
        case '{':
        case '*':
        case '?':
<span class="nc" id="L1077">          builder.appendQuantifier(token);</span>
<span class="nc" id="L1078">          break;</span>
        case '[':
        case '.':
        case '|':
        case '\\':
<span class="nc" id="L1083">          builder.appendRegexPart(token);</span>
<span class="nc" id="L1084">          break;</span>
        case '\'': // literal text
<span class="nc" id="L1086">          String sub = token.substring(1);</span>
<span class="nc bnc" id="L1087" title="All 2 branches missed.">          if (sub.length() == 1) {</span>
<span class="nc" id="L1088">            builder.appendLiteral(sub.charAt(0));</span>
          } else {
            // Create copy of sub since otherwise the temporary quoted
            // string would still be referenced internally.
<span class="nc" id="L1092">            builder.appendLiteral(new String(sub));</span>
          }
<span class="nc" id="L1094">          break;</span>
        default:
<span class="nc" id="L1096">          throw new IllegalArgumentException</span>
                  (&quot;Illegal pattern component: &quot; + token);
      }
    }
<span class="nc" id="L1100">  }</span>

<span class="nc" id="L1102">  private static final char[] SPECIAL_REGEX_CHARS = new char[]{'[', ']', '(', ')', '{', '}', '?', '*', '.', '|','\\'};</span>
  private static boolean isSpecialRegexChar(char c)
  {
<span class="nc bnc" id="L1105" title="All 2 branches missed.">    for (char SPECIAL_REGEX_CHAR : SPECIAL_REGEX_CHARS) {</span>
<span class="nc bnc" id="L1106" title="All 2 branches missed.">      if (c == SPECIAL_REGEX_CHAR) return true;</span>
    }
<span class="nc" id="L1108">    return false;</span>
  }

  /**
   * Parses an individual token.
   *
   * @param pattern  the pattern string
   * @param indexRef  a single element array, where the input is the start
   *  location and the output is the location after parsing the token
   * @return the parsed token
   */
  private static String parseToken(String pattern, int[] indexRef) {
<span class="nc" id="L1120">    StringBuilder buf = new StringBuilder();</span>

<span class="nc" id="L1122">    int i = indexRef[0];</span>
<span class="nc" id="L1123">    int length = pattern.length();</span>

<span class="nc" id="L1125">    char c = pattern.charAt(i);</span>
<span class="nc bnc" id="L1126" title="All 8 branches missed.">    if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z' || c &gt;= 'a' &amp;&amp; c &lt;= 'z') {</span>
      // Scan a run of the same character, which indicates a time
      // pattern.
<span class="nc" id="L1129">      buf.append(c);</span>

<span class="nc bnc" id="L1131" title="All 2 branches missed.">      while (i + 1 &lt; length) {</span>
<span class="nc" id="L1132">        char peek = pattern.charAt(i + 1);</span>
<span class="nc bnc" id="L1133" title="All 2 branches missed.">        if (peek == c) {</span>
<span class="nc" id="L1134">          buf.append(c);</span>
<span class="nc" id="L1135">          i++;</span>
        } else {
          break;
        }
<span class="nc" id="L1139">      }</span>
<span class="nc bnc" id="L1140" title="All 2 branches missed.">    } else if (isSpecialRegexChar(c)) {</span>
<span class="nc" id="L1141">      buf.append(c);</span>
<span class="nc bnc" id="L1142" title="All 2 branches missed.">      if (c == '[') {</span>
        // Look for end ']'
        // Assume no nesting
<span class="nc" id="L1145">        i++;</span>
<span class="nc bnc" id="L1146" title="All 2 branches missed.">        for (; i &lt; length; i++) {</span>
<span class="nc" id="L1147">          c = pattern.charAt(i);</span>
<span class="nc" id="L1148">          buf.append(c);</span>
<span class="nc bnc" id="L1149" title="All 2 branches missed.">          if (c == ']') {</span>
<span class="nc" id="L1150">            break;</span>
          }
        }
<span class="nc bnc" id="L1153" title="All 2 branches missed.">      } else if (c == '{') {</span>
        // Look for end '}'
        // Assume no nesting
<span class="nc" id="L1156">        i++;</span>
<span class="nc bnc" id="L1157" title="All 2 branches missed.">        for (; i &lt; length; i++) {</span>
<span class="nc" id="L1158">          c = pattern.charAt(i);</span>
<span class="nc" id="L1159">          buf.append(c);</span>
<span class="nc bnc" id="L1160" title="All 2 branches missed.">          if (c == '}') {</span>
<span class="nc" id="L1161">            break;</span>
          }
        }
<span class="nc bnc" id="L1164" title="All 2 branches missed.">      } else if (c == '\\') {</span>
        // Used to escape characters
<span class="nc" id="L1166">        i++;</span>
<span class="nc bnc" id="L1167" title="All 2 branches missed.">        if (i &lt; length) {</span>
<span class="nc" id="L1168">          c = pattern.charAt(i);</span>
<span class="nc" id="L1169">          buf.append(c);</span>
        }
      }
    } else {
      // This will identify token as text.
<span class="nc" id="L1174">      buf.append('\'');</span>

<span class="nc" id="L1176">      boolean inLiteral = false;</span>

<span class="nc bnc" id="L1178" title="All 2 branches missed.">      for (; i &lt; length; i++) {</span>
<span class="nc" id="L1179">        c = pattern.charAt(i);</span>

<span class="nc bnc" id="L1181" title="All 2 branches missed.">        if (c == '\'') {</span>
<span class="nc bnc" id="L1182" title="All 4 branches missed.">          if (i + 1 &lt; length &amp;&amp; pattern.charAt(i + 1) == '\'') {</span>
            // '' is treated as escaped '
<span class="nc" id="L1184">            i++;</span>
<span class="nc" id="L1185">            buf.append(c);</span>
          } else {
<span class="nc bnc" id="L1187" title="All 2 branches missed.">            inLiteral = !inLiteral;</span>
          }
<span class="nc bnc" id="L1189" title="All 2 branches missed.">        } else if (!inLiteral &amp;&amp;</span>
<span class="nc bnc" id="L1190" title="All 10 branches missed.">                (isSpecialRegexChar(c) ||</span>
                (c &gt;= 'A' &amp;&amp; c &lt;= 'Z' || c &gt;= 'a' &amp;&amp; c &lt;= 'z'))) {
<span class="nc" id="L1192">          i--;</span>
<span class="nc" id="L1193">          break;</span>
        } else {
<span class="nc" id="L1195">          buf.append(c);</span>
        }
      }
    }

<span class="nc" id="L1200">    indexRef[0] = i;</span>
<span class="nc" id="L1201">    return buf.toString();</span>
  }

  /**
   * Returns true if token should be parsed as a numeric field.
   *
   * @param token  the token to parse
   * @return true if numeric field
   */
  private static boolean isNumericToken(String token) {
<span class="nc" id="L1211">    int tokenLen = token.length();</span>
<span class="nc bnc" id="L1212" title="All 2 branches missed.">    if (tokenLen &gt; 0) {</span>
<span class="nc" id="L1213">      char c = token.charAt(0);</span>
<span class="nc bnc" id="L1214" title="All 3 branches missed.">      switch (c) {</span>
        case 'c': // century (number)
        case 'C': // century of era (number)
        case 'x': // weekyear (number)
        case 'y': // year (number)
        case 'Y': // year of era (number)
        case 'd': // day of month (number)
        case 'h': // hour of day (number, 1..12)
        case 'H': // hour of day (number, 0..23)
        case 'm': // minute of hour (number)
        case 's': // second of minute (number)
        case 'S': // fraction of second (number)
        case 'e': // day of week (number)
        case 'D': // day of year (number)
        case 'F': // day of week in month (number)
        case 'w': // week of year (number)
        case 'W': // week of month (number)
        case 'k': // hour of day (1..24)
        case 'K': // hour of day (0..11)
<span class="nc" id="L1233">          return true;</span>
        case 'M': // month of year (text and number)
<span class="nc bnc" id="L1235" title="All 2 branches missed.">          if (tokenLen &lt;= 2) {</span>
<span class="nc" id="L1236">            return true;</span>
          }
      }
    }

<span class="nc" id="L1241">    return false;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>