<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Ssurgeon.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.semgraph.semgrex.ssurgeon</a> &gt; <span class="el_source">Ssurgeon.java</span></div><h1>Ssurgeon.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.semgraph.semgrex.ssurgeon;

import java.io.*;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.text.DateFormat;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import edu.stanford.nlp.util.StringUtils;
import edu.stanford.nlp.util.logging.RedwoodConfiguration;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import edu.stanford.nlp.trees.GrammaticalRelation;
import edu.stanford.nlp.semgraph.SemanticGraph;
import edu.stanford.nlp.semgraph.SemanticGraphUtils;
import edu.stanford.nlp.semgraph.semgrex.ssurgeon.pred.*;
import edu.stanford.nlp.semgraph.semgrex.SemgrexPattern;
import edu.stanford.nlp.util.Generics;
import edu.stanford.nlp.util.logging.Redwood;


/**
 * This is the primary class for loading and saving out Ssurgeon patterns.
 * This is also the class that maintains the current list of resources loaded into Ssurgeon: any pattern
 * loaded can reference these resources.
 *
 * @author Eric Yeh
 */
public class Ssurgeon  {

  private static final boolean VERBOSE = false;

  // singleton, to ensure all use the same resources
<span class="nc" id="L45">  private static Ssurgeon instance = null;</span>

<span class="nc" id="L47">  private Ssurgeon() {}</span>

  public static Ssurgeon inst() {
<span class="nc" id="L50">    synchronized(Ssurgeon.class) {</span>
<span class="nc bnc" id="L51" title="All 2 branches missed.">      if (instance == null)</span>
<span class="nc" id="L52">        instance = new Ssurgeon();</span>
<span class="nc" id="L53">    }</span>
<span class="nc" id="L54">    return instance;</span>
  }

  // Logging to file facilities.
  // The prefix is used to append stuff in front of the logging messages
  /** A logger for this class */
<span class="nc" id="L60">  private static final Redwood.RedwoodChannels log = Redwood.channels(Ssurgeon.class);</span>

<span class="nc" id="L62">  private String logPrefix = null;</span>
  public void initLog(File logFilePath) throws IOException {
<span class="nc" id="L64">    RedwoodConfiguration.empty()</span>
<span class="nc" id="L65">      .handlers(RedwoodConfiguration.Handlers.chain(</span>
<span class="nc" id="L66">        RedwoodConfiguration.Handlers.showAllChannels(), RedwoodConfiguration.Handlers.stderr),</span>
<span class="nc" id="L67">        RedwoodConfiguration.Handlers.file(logFilePath.toString())</span>
<span class="nc" id="L68">      ).apply();</span>
    // fh.setFormatter(new NewlineLogFormatter());

<span class="nc" id="L71">    System.out.println(&quot;Starting Ssurgeon log, at &quot;+logFilePath.getAbsolutePath()+&quot; date=&quot; + DateFormat.getDateInstance(DateFormat.FULL).format(new Date()));</span>
<span class="nc" id="L72">    log.info(&quot;Starting Ssurgeon log, date=&quot; + DateFormat.getDateInstance(DateFormat.FULL).format(new Date()));</span>
<span class="nc" id="L73">  }</span>

  public void setLogPrefix(String logPrefix) {
<span class="nc" id="L76">    this.logPrefix = logPrefix;</span>
<span class="nc" id="L77">  }</span>



  /**
   * Given a list of SsurgeonPattern edit scripts, and a SemanticGraph
   * to operate over, returns a list of expansions of that graph, with
   * the result of each edit applied against a copy of the graph.
   */
  public  List&lt;SemanticGraph&gt; expandFromPatterns(List&lt;SsurgeonPattern&gt; patternList, SemanticGraph sg) throws Exception {
<span class="nc" id="L87">    List&lt;SemanticGraph&gt; retList = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L88" title="All 2 branches missed.">    for (SsurgeonPattern pattern :patternList) {</span>
<span class="nc" id="L89">      Collection&lt;SemanticGraph&gt; generated = pattern.execute(sg);</span>
<span class="nc bnc" id="L90" title="All 2 branches missed.">      for (SemanticGraph orderedGraph : generated) {</span>
        //orderedGraph.vertexList(true);
        //orderedGraph.edgeList(true);
<span class="nc" id="L93">        retList.add(orderedGraph);</span>
<span class="nc" id="L94">        System.out.println(&quot;\ncompact = &quot;+orderedGraph.toCompactString());</span>
<span class="nc" id="L95">        System.out.println(&quot;regular=&quot; + orderedGraph);</span>
<span class="nc" id="L96">      }</span>

<span class="nc bnc" id="L98" title="All 2 branches missed.">      if (generated.size() &gt; 0) {</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">        if (log != null) {</span>
<span class="nc" id="L100">          log.info(&quot;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *&quot;);</span>
<span class="nc" id="L101">          log.info(&quot;Pre remove duplicates, num=&quot;+generated.size());</span>
        }
<span class="nc" id="L103">        SemanticGraphUtils.removeDuplicates(generated, sg);</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">        if (log != null) {</span>
<span class="nc" id="L105">          log.info(&quot;Expand from patterns&quot;);</span>
<span class="nc bnc" id="L106" title="All 2 branches missed.">          if (logPrefix != null) log.info(logPrefix);</span>
<span class="nc" id="L107">          log.info(&quot;Pattern = '&quot;+pattern.getUID()+&quot;' generated &quot;+generated.size()+&quot; matches&quot;);</span>
<span class="nc" id="L108">          log.info(&quot;= = = = = = = = = =\nSrc graph:\n&quot; + sg + &quot;\n= = = = = = = = = =\n&quot;);</span>
<span class="nc" id="L109">          int index=1;</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">          for (SemanticGraph genSg : generated) {</span>
<span class="nc" id="L111">            log.info(&quot;REWRITE &quot;+(index++));</span>
<span class="nc" id="L112">            log.info(genSg.toString());</span>
<span class="nc" id="L113">            log.info(&quot;. . . . .\n&quot;);</span>
<span class="nc" id="L114">          }</span>
        }
      }
<span class="nc" id="L117">    }</span>
<span class="nc" id="L118">    return retList;</span>
  }

  /**
   * Similar to the expandFromPatterns, but performs an exhaustive
   * search, performing simplifications on the graphs until exhausted.
   *
   * TODO: ensure cycles do not occur
   * NOTE: put in an arbitrary depth limit of 3, to prevent churning way too much (heuristic)
   *
   */
  public  Collection&lt;SemanticGraph&gt; exhaustFromPatterns(List&lt;SsurgeonPattern&gt; patternList, SemanticGraph sg) throws Exception {
<span class="nc" id="L130">    Collection&lt;SemanticGraph&gt; generated = exhaustFromPatterns(patternList, sg, 1);</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">    if (generated.size() &gt; 1) {</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">      if (log != null)</span>
<span class="nc" id="L133">        log.info(&quot;Before remove dupe, size=&quot;+generated.size());</span>
<span class="nc" id="L134">      generated = SemanticGraphUtils.removeDuplicates(generated, sg);</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">      if (log != null)</span>
<span class="nc" id="L136">        log.info(&quot;AFTER remove dupe, size=&quot;+generated.size());</span>
    }
<span class="nc" id="L138">    return generated;</span>
  }
  private  List&lt;SemanticGraph&gt; exhaustFromPatterns(List&lt;SsurgeonPattern&gt; patternList, SemanticGraph sg, int depth) throws Exception {
<span class="nc" id="L141">    List&lt;SemanticGraph&gt; retList = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">    for (SsurgeonPattern pattern : patternList) {</span>
<span class="nc" id="L143">      Collection&lt;SemanticGraph&gt; generated = pattern.execute(sg);</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">      for (SemanticGraph modGraph : generated) {</span>
        //modGraph = SemanticGraphUtils.resetVerticeOrdering(modGraph);
        //modGraph.vertexList(true);
        //modGraph.edgeList(true);
<span class="nc" id="L148">        retList.add(modGraph);</span>
<span class="nc" id="L149">      }</span>

<span class="nc bnc" id="L151" title="All 4 branches missed.">      if (log != null &amp;&amp; generated.size() &gt; 0) {</span>
<span class="nc" id="L152">        log.info(&quot;* * * * * * * * * ** * * * * * * * * *&quot;);</span>
<span class="nc" id="L153">        log.info(&quot;Exhaust from patterns, depth=&quot;+depth);</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">        if (logPrefix != null) log.info(logPrefix);</span>
<span class="nc" id="L155">        log.info(&quot;Pattern = '&quot;+pattern.getUID()+&quot;' generated &quot;+generated.size()+&quot; matches&quot;);</span>
<span class="nc" id="L156">        log.info(&quot;= = = = = = = = = =\nSrc graph:\n&quot;+sg.toString()+&quot;\n= = = = = = = = = =\n&quot;);</span>
<span class="nc" id="L157">        int index=1;</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">        for (SemanticGraph genSg : generated) {</span>
<span class="nc" id="L159">          log.info(&quot;REWRITE &quot;+(index++));</span>
<span class="nc" id="L160">          log.info(genSg.toString());</span>
<span class="nc" id="L161">          log.info(&quot;. . . . .\n&quot;);</span>
<span class="nc" id="L162">        }</span>
      }
<span class="nc" id="L164">    }</span>

<span class="nc bnc" id="L166" title="All 2 branches missed.">    if (retList.size() &gt; 0) {</span>
<span class="nc" id="L167">      List&lt;SemanticGraph&gt; referenceList = new ArrayList&lt;&gt;(retList);</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">      for (SemanticGraph childGraph : referenceList) {</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">        if (depth &lt; 3)</span>
<span class="nc" id="L170">          retList.addAll(exhaustFromPatterns(patternList, childGraph, depth + 1));</span>
<span class="nc" id="L171">      }</span>
    }
<span class="nc" id="L173">    return retList;</span>
  }


  /**
   * Given a path to a file, converts it into a SsurgeonPattern
   * TODO: finish implementing this stub.
   */
  public static SsurgeonPattern getOperationFromFile(String path) {
<span class="nc" id="L182">    return null;</span>
  }

  //
  // Resource management
  //
<span class="nc" id="L188">  private Map&lt;String, SsurgeonWordlist&gt; wordListResources = Generics.newHashMap();</span>

  /**
   * Places the given word list resource under the given ID.
   * Note: can overwrite existing one in place.
   */
  private void addResource(SsurgeonWordlist resource) {
<span class="nc" id="L195">    wordListResources.put(resource.getID(), resource);</span>
<span class="nc" id="L196">  }</span>

  /**
   * Returns the given resource with the id.
   * If does not exist, will throw exception.
   */
  public SsurgeonWordlist getResource(String id) {
<span class="nc" id="L203">    return wordListResources.get(id);</span>
  }

  public Collection&lt;SsurgeonWordlist&gt; getResources() {
<span class="nc" id="L207">    return wordListResources.values();</span>
  }


  public static final String GOV_NODENAME_ARG = &quot;-gov&quot;;
  public static final String DEP_NODENAME_ARG = &quot;-dep&quot;;
  public static final String EDGE_NAME_ARG = &quot;-edge&quot;;
  public static final String NODENAME_ARG = &quot;-node&quot;;
  public static final String RELN_ARG = &quot;-reln&quot;;
  public static final String NODE_PROTO_ARG = &quot;-nodearg&quot;;
  public static final String WEIGHT_ARG = &quot;-weight&quot;;
  public static final String NAME_ARG = &quot;-name&quot;;


  // args for Ssurgeon edits, allowing us to not
  // worry about arg order (and to make things appear less confusing)
<span class="nc" id="L223">  protected static class SsurgeonArgs {</span>
    // Below are values keyed by Semgrex name
<span class="nc" id="L225">    public String govNodeName = null;</span>

<span class="nc" id="L227">    public String dep = null;</span>

<span class="nc" id="L229">    public String edge = null;</span>

<span class="nc" id="L231">    public String reln = null;</span>

<span class="nc" id="L233">    public String node = null;</span>

    // below are string representations of the intended values
<span class="nc" id="L236">    public String nodeString = null;</span>

<span class="nc" id="L238">    public double weight = 1.0;</span>

<span class="nc" id="L240">    public String name = null;</span>
  }

  /**
   * This is a specialized args parser, as we want to split on
   * whitespace, but retain everything inside quotes, so we can pass
   * in hashmaps in String form.
   */
  private static String[] parseArgs(String argsString) {
<span class="nc" id="L249">    List&lt;String&gt; retList = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L250">    String patternString = &quot;(?:[^\\s\\\&quot;]++|\\\&quot;[^\\\&quot;]*+\\\&quot;|(\\\&quot;))++&quot;;</span>
<span class="nc" id="L251">    Pattern pattern = Pattern.compile(patternString);</span>
<span class="nc" id="L252">    Matcher matcher = pattern.matcher(argsString);</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">    while (matcher.find()) {</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">      if (matcher.group(1) == null) {</span>
<span class="nc" id="L255">        String matched = matcher.group();</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">        if (matched.charAt(0) == '&quot;' &amp;&amp;</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">            matched.charAt(matched.length()-1) == '&quot;')</span>
<span class="nc" id="L258">          retList.add(matched.substring(1, matched.length()-1));</span>
        else
<span class="nc" id="L260">          retList.add(matched);</span>
<span class="nc" id="L261">      }  else</span>
<span class="nc" id="L262">        throw new IllegalArgumentException(&quot;Unmatched quote in string to parse&quot;);</span>
    }
<span class="nc" id="L264">    return retList.toArray(StringUtils.EMPTY_STRING_ARRAY);</span>
  }

  /**
   * Given a string entry, converts it into a SsurgeonEdit object.
   */
  public static SsurgeonEdit parseEditLine(String editLine) {
    // Extract the operation name first
<span class="nc" id="L272">    String[] tuples1 = editLine.split(&quot;\\s+&quot;, 2);</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">    if (tuples1.length &lt; 2) {</span>
<span class="nc" id="L274">      throw new IllegalArgumentException(&quot;Error in SsurgeonEdit.parseEditLine: invalid number of arguments&quot;);</span>
    }
<span class="nc" id="L276">    String command = tuples1[0];</span>
<span class="nc" id="L277">    String[] argsArray = parseArgs(tuples1[1]);</span>
<span class="nc" id="L278">    SsurgeonArgs argsBox = new SsurgeonArgs();</span>

<span class="nc bnc" id="L280" title="All 2 branches missed.">    for (int argIndex = 0; argIndex &lt; argsArray.length; ++argIndex) {</span>
<span class="nc bnc" id="L281" title="All 34 branches missed.">      switch (argsArray[argIndex]) {</span>
        case GOV_NODENAME_ARG:
<span class="nc" id="L283">          argsBox.govNodeName = argsArray[argIndex + 1];</span>
<span class="nc" id="L284">          argIndex += 2;</span>
<span class="nc" id="L285">          break;</span>
        case DEP_NODENAME_ARG:
<span class="nc" id="L287">          argsBox.dep = argsArray[argIndex + 1];</span>
<span class="nc" id="L288">          argIndex += 2;</span>
<span class="nc" id="L289">          break;</span>
        case EDGE_NAME_ARG:
<span class="nc" id="L291">          argsBox.edge = argsArray[argIndex + 1];</span>
<span class="nc" id="L292">          argIndex += 2;</span>
<span class="nc" id="L293">          break;</span>
        case RELN_ARG:
<span class="nc" id="L295">          argsBox.reln = argsArray[argIndex + 1];</span>
<span class="nc" id="L296">          argIndex += 2;</span>
<span class="nc" id="L297">          break;</span>
        case NODENAME_ARG:
<span class="nc" id="L299">          argsBox.node = argsArray[argIndex + 1];</span>
<span class="nc" id="L300">          argIndex += 2;</span>
<span class="nc" id="L301">          break;</span>
        case NODE_PROTO_ARG:
<span class="nc" id="L303">          argsBox.nodeString = argsArray[argIndex + 1];</span>
<span class="nc" id="L304">          argIndex += 2;</span>
<span class="nc" id="L305">          break;</span>
        case WEIGHT_ARG:
<span class="nc" id="L307">          argsBox.weight = Double.valueOf(argsArray[argIndex + 1]);</span>
<span class="nc" id="L308">          argIndex += 2;</span>
<span class="nc" id="L309">          break;</span>
        case NAME_ARG:
<span class="nc" id="L311">          argsBox.name = argsArray[argIndex + 1];</span>
<span class="nc" id="L312">          argIndex += 2;</span>
<span class="nc" id="L313">          break;</span>
        default:
<span class="nc" id="L315">          throw new IllegalArgumentException(&quot;Parsing Ssurgeon args: unknown flag &quot; + argsArray[argIndex]);</span>
      }
    }


    // Parse the arguments based upon the type of command to execute.
    // TODO: this logic really should be moved into the individual classes.  The string--&gt;class
    // mappings should also be stored in more appropriate data structure.
    SsurgeonEdit retEdit;
<span class="nc bnc" id="L324" title="All 2 branches missed.">    if (command.equalsIgnoreCase(AddDep.LABEL)) {</span>
<span class="nc" id="L325">      retEdit = AddDep.createEngAddDep(argsBox.govNodeName, argsBox.reln, argsBox.nodeString);</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">    } else if (command.equalsIgnoreCase(AddNode.LABEL)) {</span>
<span class="nc" id="L327">      retEdit = AddNode.createAddNode(argsBox.nodeString, argsBox.name);</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">    } else if (command.equalsIgnoreCase(AddEdge.LABEL)) {</span>
<span class="nc" id="L329">      retEdit = AddEdge.createEngAddEdge(argsBox.govNodeName, argsBox.dep, argsBox.reln);</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">    } else if (command.equalsIgnoreCase(DeleteGraphFromNode.LABEL)) {</span>
<span class="nc" id="L331">      retEdit = new DeleteGraphFromNode(argsBox.node);</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">    } else if (command.equalsIgnoreCase(RemoveEdge.LABEL)) {</span>
<span class="nc" id="L333">      retEdit = new RemoveEdge(GrammaticalRelation.valueOf(argsBox.reln), argsBox.govNodeName, argsBox.dep);</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">    } else if (command.equalsIgnoreCase(RemoveNamedEdge.LABEL)) {</span>
<span class="nc" id="L335">      retEdit = new RemoveNamedEdge(argsBox.edge, argsBox.govNodeName, argsBox.dep);</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">    } else if (command.equalsIgnoreCase(SetRoots.LABEL)) {</span>
<span class="nc" id="L337">      String[] names = tuples1[1].split(&quot;\\s+&quot;);</span>
<span class="nc" id="L338">      List&lt;String&gt; newRoots = Arrays.asList(names);</span>
<span class="nc" id="L339">      retEdit = new SetRoots(newRoots);</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">    } else if (command.equalsIgnoreCase(KillNonRootedNodes.LABEL)) {</span>
<span class="nc" id="L341">      retEdit = new KillNonRootedNodes();</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">    } else if (command.equalsIgnoreCase(KillAllIncomingEdges.LABEL)) {</span>
<span class="nc" id="L343">      retEdit = new KillAllIncomingEdges(argsBox.node);</span>
    } else {
<span class="nc" id="L345">      throw new IllegalArgumentException(&quot;Error in SsurgeonEdit.parseEditLine: command '&quot;+command+&quot;' is not supported&quot;);</span>
    }
<span class="nc" id="L347">    return retEdit;</span>
  }

  //public static SsurgeonPattern fromXML(String xmlString) throws Exception {
  //SAXBuilder builder = new SAXBuilder();
  //Document jdomDoc = builder.build(xmlString);
  //jdomDoc.getRootElement().getChildren(SsurgeonPattern.SSURGEON_ELEM_TAG);
  //}

  /**
   * Given a target filepath and a list of Ssurgeon patterns, writes them out as XML forms.
   */
  public static void writeToFile(File tgtFile, List&lt;SsurgeonPattern&gt; patterns) {
    try {
<span class="nc" id="L361">      Document domDoc = createPatternXMLDoc(patterns);</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">      if (domDoc != null) {</span>
<span class="nc" id="L363">        Transformer tformer = TransformerFactory.newInstance().newTransformer();</span>
<span class="nc" id="L364">        tformer.setOutputProperty(OutputKeys.INDENT, &quot;yes&quot;);</span>
<span class="nc" id="L365">        tformer.transform(new DOMSource(domDoc), new StreamResult(tgtFile));</span>
<span class="nc" id="L366">      } else {</span>
<span class="nc" id="L367">        log.warning(&quot;Was not able to create XML document for pattern list, file not written.&quot;);</span>
      }
<span class="nc" id="L369">    } catch (Exception e) {</span>
<span class="nc" id="L370">      log.error(Ssurgeon.class.getName(), &quot;writeToFile&quot;);</span>
<span class="nc" id="L371">      log.error(e);</span>
<span class="nc" id="L372">    }</span>
<span class="nc" id="L373">  }</span>

  public static String writeToString(SsurgeonPattern pattern) {
    try {
<span class="nc" id="L377">      List&lt;SsurgeonPattern&gt; patterns = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L378">      patterns.add(pattern);</span>
<span class="nc" id="L379">      Document domDoc = createPatternXMLDoc(patterns);</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">      if (domDoc != null) {</span>
<span class="nc" id="L381">        Transformer tformer = TransformerFactory.newInstance().newTransformer();</span>
<span class="nc" id="L382">        tformer.setOutputProperty(OutputKeys.INDENT, &quot;yes&quot;);</span>
<span class="nc" id="L383">        StringWriter sw = new StringWriter();</span>
<span class="nc" id="L384">        tformer.transform(new DOMSource(domDoc), new StreamResult(sw));</span>
<span class="nc" id="L385">        return sw.toString();</span>
      } else {
<span class="nc" id="L387">        log.warning(&quot;Was not able to create XML document for pattern list.&quot;);</span>
      }
<span class="nc" id="L389">    } catch (Exception e) {</span>
<span class="nc" id="L390">      log.info(&quot;Error in writeToString, could not process pattern=&quot;+pattern);</span>
<span class="nc" id="L391">      log.info(e);</span>
<span class="nc" id="L392">      return null;</span>
<span class="nc" id="L393">    }</span>
<span class="nc" id="L394">    return &quot;&quot;;</span>
  }


  private static Document createPatternXMLDoc(List&lt;SsurgeonPattern&gt; patterns) {
    try {
<span class="nc" id="L400">      DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span>
<span class="nc" id="L401">      DocumentBuilder db = dbf.newDocumentBuilder();</span>
<span class="nc" id="L402">      Document domDoc = db.newDocument();</span>
<span class="nc" id="L403">      Element rootElt = domDoc.createElement(SsurgeonPattern.ELT_LIST_TAG);</span>
<span class="nc" id="L404">      domDoc.appendChild(rootElt);</span>
<span class="nc" id="L405">      int ordinal = 1;</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">      for (SsurgeonPattern pattern : patterns) {</span>
<span class="nc" id="L407">        Element patElt = domDoc.createElement(SsurgeonPattern.SSURGEON_ELEM_TAG);</span>
<span class="nc" id="L408">        patElt.setAttribute(SsurgeonPattern.ORDINAL_ATTR, String.valueOf(ordinal));</span>
<span class="nc" id="L409">        Element semgrexElt = domDoc.createElement(SsurgeonPattern.SEMGREX_ELEM_TAG);</span>
<span class="nc" id="L410">        semgrexElt.appendChild(domDoc.createTextNode(pattern.getSemgrexPattern().pattern()));</span>
<span class="nc" id="L411">        patElt.appendChild(semgrexElt);</span>
<span class="nc" id="L412">        Element uidElem = domDoc.createElement(SsurgeonPattern.UID_ELEM_TAG);</span>
<span class="nc" id="L413">        uidElem.appendChild(domDoc.createTextNode(pattern.getUID()));</span>
<span class="nc" id="L414">        patElt.appendChild(uidElem);</span>
<span class="nc" id="L415">        Element notesElem = domDoc.createElement(SsurgeonPattern.NOTES_ELEM_TAG);</span>
<span class="nc" id="L416">        notesElem.appendChild(domDoc.createTextNode(pattern.getNotes()));</span>
<span class="nc" id="L417">        patElt.appendChild(notesElem);</span>

<span class="nc" id="L419">        SemanticGraph semgrexGraph = pattern.getSemgrexGraph();</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">        if (semgrexGraph != null) {</span>
<span class="nc" id="L421">          Element patNode = domDoc.createElement(SsurgeonPattern.SEMGREX_GRAPH_ELEM_TAG);</span>
<span class="nc" id="L422">          patNode.appendChild(domDoc.createTextNode(semgrexGraph.toCompactString()));</span>
        }
<span class="nc" id="L424">        Element editList = domDoc.createElement(SsurgeonPattern.EDIT_LIST_ELEM_TAG);</span>
<span class="nc" id="L425">        patElt.appendChild(editList);</span>
<span class="nc" id="L426">        int editOrdinal = 1;</span>
<span class="nc bnc" id="L427" title="All 2 branches missed.">        for (SsurgeonEdit edit : pattern.getEditScript()) {</span>
<span class="nc" id="L428">          Element editElem = domDoc.createElement(SsurgeonPattern.EDIT_ELEM_TAG);</span>
<span class="nc" id="L429">          editElem.setAttribute(SsurgeonPattern.ORDINAL_ATTR, String.valueOf(editOrdinal));</span>
<span class="nc" id="L430">          editElem.appendChild(domDoc.createTextNode(edit.toEditString()));</span>
<span class="nc" id="L431">          editList.appendChild(editElem);</span>
<span class="nc" id="L432">          editOrdinal++;</span>
<span class="nc" id="L433">        }</span>
<span class="nc" id="L434">        rootElt.appendChild(patElt);</span>
<span class="nc" id="L435">        ordinal++;</span>
<span class="nc" id="L436">      }</span>
<span class="nc" id="L437">      return domDoc;</span>
<span class="nc" id="L438">    } catch (Exception e) {</span>
<span class="nc" id="L439">      log.error(Ssurgeon.class.getName(), &quot;createPatternXML&quot;);</span>
<span class="nc" id="L440">      log.error(e);</span>
<span class="nc" id="L441">      return null;</span>
    }
  }


  /**
   * Given a path to a file containing a list of SsurgeonPatterns, returns
   *
   * TODO: deal with resources
   * @throws Exception
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public List&lt;SsurgeonPattern&gt; readFromFile(File file) throws Exception {
<span class="nc" id="L454">    List&lt;SsurgeonPattern&gt; retList = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L455">    Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(file);</span>

    if (VERBOSE)
      System.out.println(&quot;Reading ssurgeon file=&quot;+file.getAbsolutePath());

<span class="nc" id="L460">    NodeList patternNodes = doc.getElementsByTagName(SsurgeonPattern.SSURGEON_ELEM_TAG);</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">    for (int i=0; i&lt;patternNodes.getLength(); i++) {</span>
<span class="nc" id="L462">      Node node = patternNodes.item(i);</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">      if (node.getNodeType() == Node.ELEMENT_NODE) {</span>
<span class="nc" id="L464">        Element elt = (Element) node;</span>
<span class="nc" id="L465">        SsurgeonPattern pattern = ssurgeonPatternFromXML(elt);</span>
<span class="nc" id="L466">        retList.add(pattern);</span>
      }
    }

<span class="nc" id="L470">    NodeList resourceNodes = doc.getElementsByTagName(SsurgeonPattern.RESOURCE_TAG);</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">    for (int i=0; i &lt; resourceNodes.getLength(); i++) {</span>
<span class="nc" id="L472">      Node node = patternNodes.item(i);</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">      if (node.getNodeType() == Node.ELEMENT_NODE) {</span>
<span class="nc" id="L474">        Element resourceElt = (Element) node;</span>
<span class="nc" id="L475">        SsurgeonWordlist wlRsrc = new SsurgeonWordlist(resourceElt);</span>
<span class="nc" id="L476">        addResource(wlRsrc);</span>
      }
    }

<span class="nc" id="L480">    return retList;</span>
  }

  /**
   * Reads all Ssurgeon patterns from file.
   * @throws Exception
   */
  public List&lt;SsurgeonPattern&gt; readFromDirectory(File dir) throws Exception {
<span class="nc bnc" id="L488" title="All 2 branches missed.">    if (!dir.isDirectory()) throw new Exception(&quot;Given path not a directory, path=&quot;+dir.getAbsolutePath());</span>
    if (VERBOSE)
      System.out.println(&quot;Reading Ssurgeon patterns from directory = &quot;+dir.getAbsolutePath());
<span class="nc" id="L491">    File[] files = dir.listFiles((dir1, name) -&gt; name.toLowerCase().endsWith(&quot;.xml&quot;));</span>
<span class="nc" id="L492">    List&lt;SsurgeonPattern&gt; patterns = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">    for (File file : files) {</span>
      try {
<span class="nc" id="L495">        patterns.addAll(readFromFile(file));</span>
<span class="nc" id="L496">      } catch (Exception e) {</span>
<span class="nc" id="L497">        log.error(e);</span>
<span class="nc" id="L498">      }</span>
    }
<span class="nc" id="L500">    return patterns;</span>
  }

  /**
   * Given the root Element for a SemgrexPattern (SSURGEON_ELEM_TAG), converts
   * it into its corresponding SemgrexPattern object.
   * @throws Exception
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static SsurgeonPattern ssurgeonPatternFromXML(Element elt) throws Exception {
<span class="nc" id="L510">    String uid = getTagText(elt, SsurgeonPattern.UID_ELEM_TAG);</span>
<span class="nc" id="L511">    String notes = getTagText(elt, SsurgeonPattern.NOTES_ELEM_TAG);</span>
<span class="nc" id="L512">    String semgrexString = getTagText(elt, SsurgeonPattern.SEMGREX_ELEM_TAG);</span>
<span class="nc" id="L513">    SemgrexPattern semgrexPattern = SemgrexPattern.compile(semgrexString);</span>
<span class="nc" id="L514">    SsurgeonPattern retPattern = new SsurgeonPattern(uid, semgrexPattern);</span>
<span class="nc" id="L515">    retPattern.setNotes(notes);</span>
<span class="nc" id="L516">    NodeList editNodes = elt.getElementsByTagName(SsurgeonPattern.EDIT_LIST_ELEM_TAG);</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">    for (int i=0; i&lt;editNodes.getLength(); i++) {</span>
<span class="nc" id="L518">      Node node = editNodes.item(i);</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">      if (node.getNodeType() == Node.ELEMENT_NODE) {</span>
<span class="nc" id="L520">        Element editElt = (Element) node;</span>
<span class="nc" id="L521">        String editVal = getEltText(editElt);</span>
<span class="nc" id="L522">        retPattern.addEdit(Ssurgeon.parseEditLine(editVal));</span>
      }
    }


    // If predicate available, parse
<span class="nc" id="L528">    Element predElt = getFirstTag(elt, SsurgeonPattern.PREDICATE_TAG);</span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">    if (predElt != null) {</span>
<span class="nc" id="L530">      SsurgPred pred = assemblePredFromXML(getFirstChildElement(predElt));</span>
<span class="nc" id="L531">      retPattern.setPredicate(pred);</span>
    }
<span class="nc" id="L533">    return retPattern;</span>
  }

  /**
   * Constructs a {@code SsurgPred} structure from file, given the root element.
   * @throws Exception
   */
  public static SsurgPred assemblePredFromXML(Element elt) throws Exception {
<span class="nc" id="L541">    String eltName = elt.getTagName();</span>
<span class="nc bnc" id="L542" title="All 14 branches missed.">    switch (eltName) {</span>
      case SsurgeonPattern.PREDICATE_AND_TAG:
<span class="nc" id="L544">        SsurgAndPred andPred = new SsurgAndPred();</span>
<span class="nc bnc" id="L545" title="All 2 branches missed.">        for (Element childElt : getChildElements(elt)) {</span>
<span class="nc" id="L546">          SsurgPred childPred = assemblePredFromXML(childElt);</span>
<span class="nc" id="L547">          andPred.add(childPred);</span>
<span class="nc" id="L548">          return andPred;</span>
        }
<span class="nc" id="L550">        break;</span>
      case SsurgeonPattern.PREDICATE_OR_TAG:
<span class="nc" id="L552">        SsurgOrPred orPred = new SsurgOrPred();</span>
<span class="nc bnc" id="L553" title="All 2 branches missed.">        for (Element childElt : getChildElements(elt)) {</span>
<span class="nc" id="L554">          SsurgPred childPred = assemblePredFromXML(childElt);</span>
<span class="nc" id="L555">          orPred.add(childPred);</span>
<span class="nc" id="L556">          return orPred;</span>
        }
<span class="nc" id="L558">        break;</span>
      case SsurgeonPattern.PRED_WORDLIST_TEST_TAG:
<span class="nc" id="L560">        String id = elt.getAttribute(SsurgeonPattern.PRED_ID_ATTR);</span>
<span class="nc" id="L561">        String resourceID = elt.getAttribute(&quot;resourceID&quot;);</span>
<span class="nc" id="L562">        String typeStr = elt.getAttribute(&quot;type&quot;);</span>
<span class="nc" id="L563">        String matchName = getEltText(elt).trim(); // node name to match on</span>

<span class="nc bnc" id="L565" title="All 2 branches missed.">        if (matchName == null) {</span>
<span class="nc" id="L566">          throw new Exception(&quot;Could not find match name for &quot; + elt);</span>
        }
<span class="nc bnc" id="L568" title="All 2 branches missed.">        if (id == null) {</span>
<span class="nc" id="L569">          throw new Exception(&quot;No ID attribute for element = &quot; + elt);</span>
        }
<span class="nc" id="L571">        return new WordlistTest(id, resourceID, typeStr, matchName);</span>
    }

    // Not a valid node, error out!
<span class="nc" id="L575">    throw new Exception(&quot;Invalid node encountered during Ssurgeon predicate processing, node name=&quot;+eltName);</span>
  }



  /**
   * Reads in the test file and prints readable to string (for debugging).
   * Input file consists of semantic graphs, in compact form.
   */
  public void testRead(File tgtDirPath) throws Exception {
<span class="nc" id="L585">    List&lt;SsurgeonPattern&gt; patterns = readFromDirectory(tgtDirPath);</span>

<span class="nc" id="L587">    System.out.println(&quot;Patterns, num = &quot;+patterns.size());</span>
<span class="nc" id="L588">    int num = 1;</span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">    for (SsurgeonPattern pattern : patterns) {</span>
<span class="nc" id="L590">      System.out.println(&quot;\n# &quot;+(num++));</span>
<span class="nc" id="L591">      System.out.println(pattern);</span>
<span class="nc" id="L592">    }</span>

<span class="nc" id="L594">    System.out.println(&quot;\n\nRESOURCES &quot;);</span>
<span class="nc bnc" id="L595" title="All 2 branches missed.">    for (SsurgeonWordlist rsrc : inst().getResources()) {</span>
<span class="nc" id="L596">      System.out.println(rsrc+&quot;* * * * *&quot;);</span>
<span class="nc" id="L597">    }</span>

<span class="nc" id="L599">    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));</span>
<span class="nc" id="L600">    boolean runFlag = true;</span>
<span class="nc" id="L601">    Ssurgeon.inst().initLog(new File(&quot;./ssurgeon_run.log&quot;));</span>
<span class="nc bnc" id="L602" title="All 2 branches missed.">    while (runFlag) {</span>
      try {
<span class="nc" id="L604">        System.out.println(&quot;Enter a sentence:&quot;);</span>
<span class="nc" id="L605">        String line = in.readLine();</span>
<span class="nc bnc" id="L606" title="All 2 branches missed.">        if (line.isEmpty()) {</span>
<span class="nc" id="L607">          System.exit(0);</span>
        }
<span class="nc" id="L609">        System.out.println(&quot;Parsing...&quot;);</span>
<span class="nc" id="L610">        SemanticGraph sg = SemanticGraph.valueOf(line);</span>
<span class="nc" id="L611">        System.out.println(&quot;Graph = &quot;+sg);</span>
<span class="nc" id="L612">        Collection&lt;SemanticGraph&gt; generated = Ssurgeon.inst().exhaustFromPatterns(patterns, sg);</span>
<span class="nc" id="L613">        System.out.println(&quot;# generated = &quot;+generated.size());</span>
<span class="nc" id="L614">        int index = 1;</span>
<span class="nc bnc" id="L615" title="All 2 branches missed.">        for (SemanticGraph gsg : generated) {</span>
<span class="nc" id="L616">          System.out.println(&quot;\n# &quot;+index);</span>
<span class="nc" id="L617">          System.out.println(gsg);</span>
<span class="nc" id="L618">          index++;</span>
<span class="nc" id="L619">        }</span>
<span class="nc" id="L620">      } catch (Exception e) {</span>
<span class="nc" id="L621">        log.error(e);</span>
<span class="nc" id="L622">      }</span>
    }
<span class="nc" id="L624">  }</span>


  /*
   * XML convenience routines
   */
  // todo [cdm 2016]: Aren't some of these methods available as generic XML methods elsewhere??

  /**
   * For the given element, returns the text for the first child Element with
   * the given tag.
   */
  public static String getTagText(Element element, String tag) {
    try {
      // From root element, identify first with tag, then find the
      // first child under that, which we treat as a TEXT node.
<span class="nc" id="L640">      Element firstElt = getFirstTag(element, tag);</span>
<span class="nc bnc" id="L641" title="All 2 branches missed.">      if (firstElt == null) return &quot;&quot;;</span>
<span class="nc" id="L642">      return getEltText(firstElt);</span>
<span class="nc" id="L643">    } catch (Exception e) {</span>
<span class="nc" id="L644">      log.warning(&quot;Exception thrown attempting to get tag text for tag=&quot;+tag+&quot;, from element=&quot;+element);</span>
    }
<span class="nc" id="L646">    return &quot;&quot;;</span>
  }

  /**
   * For a given Element, treats the first child as a text element
   * and returns its value.
   */
  public static String getEltText(Element element) {
    try {
<span class="nc" id="L655">      NodeList childNodeList = element.getChildNodes();</span>
<span class="nc bnc" id="L656" title="All 2 branches missed.">      if (childNodeList.getLength() == 0) return &quot;&quot;;</span>
<span class="nc" id="L657">      return childNodeList.item(0).getNodeValue();</span>
<span class="nc" id="L658">    } catch (Exception e) {</span>
<span class="nc" id="L659">      log.warning(&quot;Exception e=&quot; + e.getMessage() + &quot; thrown calling getEltText on element=&quot; + element);</span>
    }
<span class="nc" id="L661">    return &quot;&quot;;</span>
  }

  /**
   * For the given element, finds the first child Element with the given tag.
   */
  private static Element getFirstTag(Element element, String tag) {
    try {
<span class="nc" id="L669">      NodeList nodeList = element.getElementsByTagName(tag);</span>
<span class="nc bnc" id="L670" title="All 2 branches missed.">      if (nodeList.getLength() == 0) return null;</span>
<span class="nc bnc" id="L671" title="All 2 branches missed.">      for (int i=0; i &lt; nodeList.getLength(); i++) {</span>
<span class="nc" id="L672">        Node node = nodeList.item(i);</span>
<span class="nc bnc" id="L673" title="All 2 branches missed.">        if (node.getNodeType() == Node.ELEMENT_NODE)</span>
<span class="nc" id="L674">          return (Element) node;</span>
      }
<span class="nc" id="L676">    } catch (Exception e) {</span>
<span class="nc" id="L677">      log.warning(&quot;Error getting first tag &quot;+tag+&quot; under element=&quot;+element);</span>
<span class="nc" id="L678">    }</span>
<span class="nc" id="L679">    return null;</span>
  }

  /**
   * Returns the first child whose node type is Element under the given Element.
   */
  private static Element getFirstChildElement(Element element) {
    try {
<span class="nc" id="L687">      NodeList nodeList = element.getChildNodes();</span>
<span class="nc bnc" id="L688" title="All 2 branches missed.">      for (int i=0; i&lt;nodeList.getLength(); i++) {</span>
<span class="nc" id="L689">        Node node = nodeList.item(i);</span>
<span class="nc bnc" id="L690" title="All 2 branches missed.">        if (node.getNodeType() == Node.ELEMENT_NODE)</span>
<span class="nc" id="L691">          return (Element) node;</span>
      }
<span class="nc" id="L693">    } catch (Exception e) {</span>
<span class="nc" id="L694">      log.warning(&quot;Error getting first child Element for element=&quot; + element+&quot;, exception=&quot; + e);</span>
<span class="nc" id="L695">    }</span>
<span class="nc" id="L696">    return null;</span>
  }


  /**
   * Returns all of the Element typed children from the given element.  Note: disregards
   * other node types.
   */
  private static List&lt;Element&gt; getChildElements(Element element) {
<span class="nc" id="L705">    LinkedList&lt;Element&gt; childElements = new LinkedList&lt;&gt;();</span>
    try {
<span class="nc" id="L707">      NodeList nodeList = element.getChildNodes();</span>
<span class="nc bnc" id="L708" title="All 2 branches missed.">      for (int i=0; i&lt;nodeList.getLength(); i++) {</span>
<span class="nc" id="L709">        Node node = nodeList.item(i);</span>
<span class="nc bnc" id="L710" title="All 2 branches missed.">        if (node.getNodeType() == Node.ELEMENT_NODE) {</span>
<span class="nc" id="L711">          childElements.add((Element) node);</span>
        }
      }
<span class="nc" id="L714">    } catch (Exception e) {</span>
<span class="nc" id="L715">      log.warning(&quot;Exception thrown getting all children for element=&quot; + element+ &quot;, e=&quot; + e);</span>
<span class="nc" id="L716">    }</span>
<span class="nc" id="L717">    return childElements;</span>
  }

  /*
   * Main class evocation stuff
   */


<span class="nc" id="L725">  public enum RUNTYPE {</span>
<span class="nc" id="L726">    interactive, // interactively test contents of pattern directory against entered sentences</span>
<span class="nc" id="L727">    testinfo // test against a given infofile (RTE), generating rewrites for hypotheses</span>
  }


<span class="nc" id="L731">  public static class ArgsBox {</span>
<span class="nc" id="L732">    public RUNTYPE type = RUNTYPE.interactive;</span>

<span class="nc" id="L734">    public String patternDirStr = null;</span>
<span class="nc" id="L735">    public File patternDir = null;</span>

<span class="nc" id="L737">    public String info = null;</span>
<span class="nc" id="L738">    public File infoPath = null;</span>

    public void init() {
<span class="nc" id="L741">      patternDir = new File(patternDirStr);</span>
<span class="nc bnc" id="L742" title="All 2 branches missed.">      if (type == RUNTYPE.testinfo)</span>
<span class="nc" id="L743">        infoPath = new File(info);</span>
<span class="nc" id="L744">    }</span>

    @Override
    public String toString() {
<span class="nc" id="L748">      StringWriter buf = new StringWriter();</span>
<span class="nc" id="L749">      buf.write(&quot;type =&quot;+type+&quot;\n&quot;);</span>
<span class="nc" id="L750">      buf.write(&quot;pattern dir = &quot;+patternDir.getAbsolutePath());</span>
<span class="nc bnc" id="L751" title="All 2 branches missed.">      if (type == RUNTYPE.testinfo) {</span>
<span class="nc" id="L752">        buf.write(&quot;info file = &quot;+info);</span>
<span class="nc bnc" id="L753" title="All 2 branches missed.">        if (info != null)</span>
<span class="nc" id="L754">          buf.write(&quot;, path = &quot;+infoPath.getAbsolutePath());</span>
      }
<span class="nc" id="L756">      return buf.toString();</span>
    }
  }

<span class="nc" id="L760">  protected static ArgsBox argsBox = new ArgsBox();</span>

  /**
   * Performs a simple test and print of a given file.
   * Usage Ssurgeon [-info infoFile] -patterns patternDir [-type interactive|testinfo]
   */
  public static void main(String[] args) {
<span class="nc bnc" id="L767" title="All 2 branches missed.">    for (int argIndex = 0; argIndex &lt; args.length; ++argIndex) {</span>
<span class="nc bnc" id="L768" title="All 2 branches missed.">      if (args[argIndex].equalsIgnoreCase(&quot;-info&quot;)) {</span>
<span class="nc" id="L769">        argsBox.info = args[argIndex + 1];</span>
<span class="nc" id="L770">        argIndex += 2;</span>
<span class="nc bnc" id="L771" title="All 2 branches missed.">      } else if (args[argIndex].equalsIgnoreCase(&quot;-patterns&quot;)) {</span>
<span class="nc" id="L772">        argsBox.patternDirStr = args[argIndex + 1];</span>
<span class="nc" id="L773">        argIndex += 2;</span>
<span class="nc bnc" id="L774" title="All 2 branches missed.">      } else if (args[argIndex].equalsIgnoreCase(&quot;-type&quot;)) {</span>
<span class="nc" id="L775">        argsBox.type = RUNTYPE.valueOf(args[argIndex + 1]);</span>
<span class="nc" id="L776">        argIndex += 2;</span>
      }
    }
<span class="nc bnc" id="L779" title="All 2 branches missed.">    if (argsBox.patternDirStr == null) {</span>
<span class="nc" id="L780">      throw new IllegalArgumentException(&quot;Need to give a pattern location with -patterns&quot;);</span>
    }
<span class="nc" id="L782">    argsBox.init();</span>

<span class="nc" id="L784">    System.out.println(argsBox);</span>
    try {
<span class="nc bnc" id="L786" title="All 2 branches missed.">      if (argsBox.type == RUNTYPE.interactive) {</span>
<span class="nc" id="L787">        Ssurgeon.inst().testRead(argsBox.patternDir);</span>
      }
<span class="nc" id="L789">    } catch (Exception e) {</span>
<span class="nc" id="L790">      log.error(e);</span>
<span class="nc" id="L791">    }</span>
<span class="nc" id="L792">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>