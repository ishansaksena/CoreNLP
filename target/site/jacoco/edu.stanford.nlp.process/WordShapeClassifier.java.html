<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WordShapeClassifier.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.process</a> &gt; <span class="el_source">WordShapeClassifier.java</span></div><h1>WordShapeClassifier.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.process; 
import edu.stanford.nlp.util.logging.Redwood;

import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import edu.stanford.nlp.trees.international.pennchinese.ChineseUtils;

import edu.stanford.nlp.objectbank.ObjectBank;
import edu.stanford.nlp.util.Generics;
import edu.stanford.nlp.util.Timing;

// TODO: put in a regexp for ordinals, fraction num/num and perhaps even 30-5/8


/**
 * Provides static methods which
 * map any String to another String indicative of its &quot;word shape&quot; -- e.g.,
 * whether capitalized, numeric, etc.  Different implementations may
 * implement quite different, normally language specific ideas of what
 * word shapes are useful.
 *
 * @author Christopher Manning
 * @author Dan Klein
 */
public class WordShapeClassifier  {

  /** A logger for this class */
<span class="fc" id="L29">  private static Redwood.RedwoodChannels log = Redwood.channels(WordShapeClassifier.class);</span>

  public static final int NOWORDSHAPE = -1;
  public static final int WORDSHAPEDAN1 = 0;
  public static final int WORDSHAPECHRIS1 = 1;
  public static final int WORDSHAPEDAN2 = 2;
  public static final int WORDSHAPEDAN2USELC = 3;
  public static final int WORDSHAPEDAN2BIO = 4;
  public static final int WORDSHAPEDAN2BIOUSELC = 5;
  public static final int WORDSHAPEJENNY1 = 6;
  public static final int WORDSHAPEJENNY1USELC = 7;
  public static final int WORDSHAPECHRIS2 = 8;
  public static final int WORDSHAPECHRIS2USELC = 9;
  public static final int WORDSHAPECHRIS3 = 10;
  public static final int WORDSHAPECHRIS3USELC = 11;
  public static final int WORDSHAPECHRIS4 = 12;
  public static final int WORDSHAPEDIGITS = 13;
  public static final int WORDSHAPECHINESE = 14;
  public static final int WORDSHAPECLUSTER1 = 15;


  // This class cannot be instantiated
<span class="nc" id="L51">  private WordShapeClassifier() {</span>
<span class="nc" id="L52">  }</span>


  /** Look up a shaper by a short String name.
   *
   * @param name Shaper name.  Known names have patterns along the lines of:
   *             dan[12](bio)?(UseLC)?, jenny1(useLC)?, chris[1234](useLC)?, cluster1.
   * @return An integer constant for the shaper
   */
  public static int lookupShaper(String name) {
<span class="nc bnc" id="L62" title="All 2 branches missed.">    if (name == null) {</span>
<span class="nc" id="L63">      return NOWORDSHAPE;</span>
<span class="nc bnc" id="L64" title="All 2 branches missed.">    } else if (name.equalsIgnoreCase(&quot;dan1&quot;)) {</span>
<span class="nc" id="L65">      return WORDSHAPEDAN1;</span>
<span class="nc bnc" id="L66" title="All 2 branches missed.">    } else if (name.equalsIgnoreCase(&quot;chris1&quot;)) {</span>
<span class="nc" id="L67">      return WORDSHAPECHRIS1;</span>
<span class="nc bnc" id="L68" title="All 2 branches missed.">    } else if (name.equalsIgnoreCase(&quot;dan2&quot;)) {</span>
<span class="nc" id="L69">      return WORDSHAPEDAN2;</span>
<span class="nc bnc" id="L70" title="All 2 branches missed.">    } else if (name.equalsIgnoreCase(&quot;dan2useLC&quot;)) {</span>
<span class="nc" id="L71">      return WORDSHAPEDAN2USELC;</span>
<span class="nc bnc" id="L72" title="All 2 branches missed.">    } else if (name.equalsIgnoreCase(&quot;dan2bio&quot;)) {</span>
<span class="nc" id="L73">      return WORDSHAPEDAN2BIO;</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">    } else if (name.equalsIgnoreCase(&quot;dan2bioUseLC&quot;)) {</span>
<span class="nc" id="L75">      return WORDSHAPEDAN2BIOUSELC;</span>
<span class="nc bnc" id="L76" title="All 2 branches missed.">    } else if (name.equalsIgnoreCase(&quot;jenny1&quot;)) {</span>
<span class="nc" id="L77">      return WORDSHAPEJENNY1;</span>
<span class="nc bnc" id="L78" title="All 2 branches missed.">    } else if (name.equalsIgnoreCase(&quot;jenny1useLC&quot;)) {</span>
<span class="nc" id="L79">      return WORDSHAPEJENNY1USELC;</span>
<span class="nc bnc" id="L80" title="All 2 branches missed.">    } else if (name.equalsIgnoreCase(&quot;chris2&quot;)) {</span>
<span class="nc" id="L81">      return WORDSHAPECHRIS2;</span>
<span class="nc bnc" id="L82" title="All 2 branches missed.">    } else if (name.equalsIgnoreCase(&quot;chris2useLC&quot;)) {</span>
<span class="nc" id="L83">      return WORDSHAPECHRIS2USELC;</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">    } else if (name.equalsIgnoreCase(&quot;chris3&quot;)) {</span>
<span class="nc" id="L85">      return WORDSHAPECHRIS3;</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">    } else if (name.equalsIgnoreCase(&quot;chris3useLC&quot;)) {</span>
<span class="nc" id="L87">      return WORDSHAPECHRIS3USELC;</span>
<span class="nc bnc" id="L88" title="All 2 branches missed.">    } else if (name.equalsIgnoreCase(&quot;chris4&quot;)) {</span>
<span class="nc" id="L89">      return WORDSHAPECHRIS4;</span>
<span class="nc bnc" id="L90" title="All 2 branches missed.">    } else if (name.equalsIgnoreCase(&quot;digits&quot;)) {</span>
<span class="nc" id="L91">      return WORDSHAPEDIGITS;</span>
<span class="nc bnc" id="L92" title="All 2 branches missed.">    } else if (name.equalsIgnoreCase(&quot;chinese&quot;)) {</span>
<span class="nc" id="L93">      return WORDSHAPECHINESE;</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">    } else if (name.equalsIgnoreCase(&quot;cluster1&quot;)) {</span>
<span class="nc" id="L95">      return WORDSHAPECLUSTER1;</span>
    } else {
<span class="nc" id="L97">      return NOWORDSHAPE;</span>
    }
  }

  /**
   * Returns true if the specified word shaper doesn't use
   * known lower case words, even if a list of them is present.
   * This is used for backwards compatibility. It is suggested that
   * new word shape functions are either passed a non-null list of
   * lowercase words or not, depending on whether you want knownLC marking
   * (if it is available in a shaper).  This is how chris4 works.
   *
   * @param shape One of the defined shape constants
   * @return true if the specified word shaper uses
   *     known lower case words.
   */
  private static boolean dontUseLC(int shape) {
<span class="pc bpc" id="L114" title="5 of 10 branches missed.">    return shape == WORDSHAPEDAN2 ||</span>
            shape == WORDSHAPEDAN2BIO ||
            shape == WORDSHAPEJENNY1 ||
            shape == WORDSHAPECHRIS2 ||
            shape == WORDSHAPECHRIS3;
  }


  /**
   * Specify the String and the int identifying which word shaper to
   * use and this returns the result of using that wordshaper on the String.
   *
   * @param inStr String to calculate word shape of
   * @param wordShaper Constant for which shaping formula to use
   * @return The wordshape String
   */
  public static String wordShape(String inStr, int wordShaper) {
<span class="nc" id="L131">    return wordShape(inStr, wordShaper, null);</span>
  }


  /**
   * Specify the string and the int identifying which word shaper to
   * use and this returns the result of using that wordshaper on the String.
   *
   * @param inStr String to calculate word shape of
   * @param wordShaper Constant for which shaping formula to use
   * @param knownLCWords A Collection of known lowercase words, which some shapers use
   *           to decide the class of capitalized words.
   *           &lt;i&gt;Note: while this code works with any Collection, you should
   *           provide a Set for decent performance.&lt;/i&gt;  If this parameter is
   *           null or empty, then this option is not used (capitalized words
   *           are treated the same, regardless of whether the lowercased
   *           version of the String has been seen).
   * @return The wordshape String
   */
  public static String wordShape(String inStr, int wordShaper, Collection&lt;String&gt; knownLCWords) {
    // this first bit is for backwards compatibility with how things were first
    // implemented, where the word shaper name encodes whether to useLC.
    // If the shaper is in the old compatibility list, then a specified
    // list of knownLCwords is ignored
<span class="pc bpc" id="L155" title="1 of 4 branches missed.">    if (knownLCWords != null &amp;&amp; dontUseLC(wordShaper)) {</span>
<span class="nc" id="L156">      knownLCWords = null;</span>
    }
<span class="pc bpc" id="L158" title="11 of 18 branches missed.">    switch (wordShaper) {</span>
      case NOWORDSHAPE:
<span class="nc" id="L160">        return inStr;</span>
      case WORDSHAPEDAN1:
<span class="nc" id="L162">        return wordShapeDan1(inStr);</span>
      case WORDSHAPECHRIS1:
<span class="fc" id="L164">        return wordShapeChris1(inStr);</span>
      case WORDSHAPEDAN2:
<span class="nc" id="L166">        return wordShapeDan2(inStr, knownLCWords);</span>
      case WORDSHAPEDAN2USELC:
<span class="nc" id="L168">        return wordShapeDan2(inStr, knownLCWords);</span>
      case WORDSHAPEDAN2BIO:
<span class="nc" id="L170">        return wordShapeDan2Bio(inStr, knownLCWords);</span>
      case WORDSHAPEDAN2BIOUSELC:
<span class="nc" id="L172">        return wordShapeDan2Bio(inStr, knownLCWords);</span>
      case WORDSHAPEJENNY1:
<span class="nc" id="L174">        return wordShapeJenny1(inStr, knownLCWords);</span>
      case WORDSHAPEJENNY1USELC:
<span class="nc" id="L176">        return wordShapeJenny1(inStr, knownLCWords);</span>
      case WORDSHAPECHRIS2:
<span class="fc" id="L178">        return wordShapeChris2(inStr, false, knownLCWords);</span>
      case WORDSHAPECHRIS2USELC:
<span class="fc" id="L180">        return wordShapeChris2(inStr, false, knownLCWords);</span>
      case WORDSHAPECHRIS3:
<span class="fc" id="L182">        return wordShapeChris2(inStr, true, knownLCWords);</span>
      case WORDSHAPECHRIS3USELC:
<span class="fc" id="L184">        return wordShapeChris2(inStr, true, knownLCWords);</span>
      case WORDSHAPECHRIS4:
<span class="fc" id="L186">        return wordShapeChris4(inStr, false, knownLCWords);</span>
      case WORDSHAPEDIGITS:
<span class="fc" id="L188">        return wordShapeDigits(inStr);</span>
      case WORDSHAPECHINESE:
<span class="nc" id="L190">        return wordShapeChinese(inStr);</span>
      case WORDSHAPECLUSTER1:
<span class="nc" id="L192">        return wordShapeCluster1(inStr);</span>
      default:
<span class="nc" id="L194">        throw new IllegalStateException(&quot;Bad WordShapeClassifier&quot;);</span>
    }
  }

  /**
   * A fairly basic 5-way classifier, that notes digits, and upper
   * and lower case, mixed, and non-alphanumeric.
   *
   * @param s String to find word shape of
   * @return Its word shape: a 5 way classification
   */
  private static String wordShapeDan1(String s) {
<span class="nc" id="L206">    boolean digit = true;</span>
<span class="nc" id="L207">    boolean upper = true;</span>
<span class="nc" id="L208">    boolean lower = true;</span>
<span class="nc" id="L209">    boolean mixed = true;</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">    for (int i = 0; i &lt; s.length(); i++) {</span>
<span class="nc" id="L211">      char c = s.charAt(i);</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">      if (!Character.isDigit(c)) {</span>
<span class="nc" id="L213">        digit = false;</span>
      }
<span class="nc bnc" id="L215" title="All 2 branches missed.">      if (!Character.isLowerCase(c)) {</span>
<span class="nc" id="L216">        lower = false;</span>
      }
<span class="nc bnc" id="L218" title="All 2 branches missed.">      if (!Character.isUpperCase(c)) {</span>
<span class="nc" id="L219">        upper = false;</span>
      }
<span class="nc bnc" id="L221" title="All 8 branches missed.">      if ((i == 0 &amp;&amp; !Character.isUpperCase(c)) || (i &gt;= 1 &amp;&amp; !Character.isLowerCase(c))) {</span>
<span class="nc" id="L222">        mixed = false;</span>
      }
    }
<span class="nc bnc" id="L225" title="All 2 branches missed.">    if (digit) {</span>
<span class="nc" id="L226">      return &quot;ALL-DIGITS&quot;;</span>
    }
<span class="nc bnc" id="L228" title="All 2 branches missed.">    if (upper) {</span>
<span class="nc" id="L229">      return &quot;ALL-UPPER&quot;;</span>
    }
<span class="nc bnc" id="L231" title="All 2 branches missed.">    if (lower) {</span>
<span class="nc" id="L232">      return &quot;ALL-LOWER&quot;;</span>
    }
<span class="nc bnc" id="L234" title="All 2 branches missed.">    if (mixed) {</span>
<span class="nc" id="L235">      return &quot;MIXED-CASE&quot;;</span>
    }
<span class="nc" id="L237">    return &quot;OTHER&quot;;</span>
  }


  /**
   * A fine-grained word shape classifier, that equivalence classes
   * lower and upper case and digits, and collapses sequences of the
   * same type, but keeps all punctuation, etc. &lt;p&gt;
   * &lt;i&gt;Note:&lt;/i&gt; We treat '_' as a lowercase letter, sort of like many
   * programming languages.  We do this because we use '_' joining of
   * tokens in some applications like RTE.
   *
   * @param s           The String whose shape is to be returned
   * @param knownLCWords If this is non-null and non-empty, mark words whose
   *                    lower case form is found in the
   *                    Collection of known lower case words
   * @return The word shape
   */
  private static String wordShapeDan2(String s, Collection&lt;String&gt; knownLCWords) {
<span class="nc" id="L256">    StringBuilder sb = new StringBuilder(&quot;WT-&quot;);</span>
<span class="nc" id="L257">    char lastM = '~';</span>
<span class="nc" id="L258">    boolean nonLetters = false;</span>
<span class="nc" id="L259">    int len = s.length();</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">    for (int i = 0; i &lt; len; i++) {</span>
<span class="nc" id="L261">      char c = s.charAt(i);</span>
<span class="nc" id="L262">      char m = c;</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">      if (Character.isDigit(c)) {</span>
<span class="nc" id="L264">        m = 'd';</span>
<span class="nc bnc" id="L265" title="All 4 branches missed.">      } else if (Character.isLowerCase(c) || c == '_') {</span>
<span class="nc" id="L266">        m = 'x';</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">      } else if (Character.isUpperCase(c)) {</span>
<span class="nc" id="L268">        m = 'X';</span>
      }
<span class="nc bnc" id="L270" title="All 4 branches missed.">      if (m != 'x' &amp;&amp; m != 'X') {</span>
<span class="nc" id="L271">        nonLetters = true;</span>
      }
<span class="nc bnc" id="L273" title="All 2 branches missed.">      if (m != lastM) {</span>
<span class="nc" id="L274">        sb.append(m);</span>
      }
<span class="nc" id="L276">      lastM = m;</span>
    }
<span class="nc bnc" id="L278" title="All 2 branches missed.">    if (len &lt;= 3) {</span>
<span class="nc" id="L279">      sb.append(':').append(len);</span>
    }
<span class="nc bnc" id="L281" title="All 2 branches missed.">    if (knownLCWords != null) {</span>
<span class="nc bnc" id="L282" title="All 4 branches missed.">      if (!nonLetters &amp;&amp; knownLCWords.contains(s.toLowerCase())) {</span>
<span class="nc" id="L283">        sb.append('k');</span>
      }
    }
    // log.info(&quot;wordShapeDan2: &quot; + s + &quot; became &quot; + sb);
<span class="nc" id="L287">    return sb.toString();</span>
  }

  private static String wordShapeJenny1(String s, Collection&lt;String&gt; knownLCWords) {
<span class="nc" id="L291">    StringBuilder sb = new StringBuilder(&quot;WT-&quot;);</span>
<span class="nc" id="L292">    char lastM = '~';</span>
<span class="nc" id="L293">    boolean nonLetters = false;</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">    for (int i = 0; i &lt; s.length(); i++) {</span>
<span class="nc" id="L295">      char c = s.charAt(i);</span>
<span class="nc" id="L296">      char m = c;</span>

<span class="nc bnc" id="L298" title="All 2 branches missed.">      if (Character.isDigit(c)) {</span>
<span class="nc" id="L299">        m = 'd';</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">      } else if (Character.isLowerCase(c)) {</span>
<span class="nc" id="L301">        m = 'x';</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">      } else if (Character.isUpperCase(c)) {</span>
<span class="nc" id="L303">        m = 'X';</span>
      }

<span class="nc bnc" id="L306" title="All 2 branches missed.">      for (String gr : greek) {</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">        if (s.startsWith(gr, i)) {</span>
<span class="nc" id="L308">          m = 'g';</span>
<span class="nc" id="L309">          i = i + gr.length() - 1;</span>
          //System.out.println(s + &quot;  ::  &quot; + s.substring(i+1));
<span class="nc" id="L311">          break;</span>
        }
      }

<span class="nc bnc" id="L315" title="All 4 branches missed.">      if (m != 'x' &amp;&amp; m != 'X') {</span>
<span class="nc" id="L316">        nonLetters = true;</span>
      }
<span class="nc bnc" id="L318" title="All 2 branches missed.">      if (m != lastM) {</span>
<span class="nc" id="L319">        sb.append(m);</span>
      }
<span class="nc" id="L321">      lastM = m;</span>


    }
<span class="nc bnc" id="L325" title="All 2 branches missed.">    if (s.length() &lt;= 3) {</span>
<span class="nc" id="L326">      sb.append(':').append(s.length());</span>
    }
<span class="nc bnc" id="L328" title="All 2 branches missed.">    if (knownLCWords != null) {</span>
<span class="nc bnc" id="L329" title="All 4 branches missed.">      if ( ! nonLetters &amp;&amp; knownLCWords.contains(s.toLowerCase())) {</span>
<span class="nc" id="L330">        sb.append('k');</span>
      }
    }
    //System.out.println(s+&quot; became &quot;+sb);
<span class="nc" id="L334">    return sb.toString();</span>
  }


  /** Note: the optimizations in wordShapeChris2 would break if BOUNDARY_SIZE
   * was greater than the shortest greek word, so valid values are: 0, 1, 2, 3.
   */
  private static final int BOUNDARY_SIZE = 2;

  /**
   * This one picks up on Dan2 ideas, but seeks to make less distinctions
   * mid sequence by sorting for long words, but to maintain extra
   * distinctions for short words. It exactly preserves the character shape
   * of the first and last 2 (i.e., BOUNDARY_SIZE) characters and then
   * will record shapes that occur between them (perhaps only if they are
   * different)
   *
   * @param s The String to find the word shape of
   * @param omitIfInBoundary If true, character classes present in the
   *                         first or last two (i.e., BOUNDARY_SIZE) letters
   *                         of the word are not also registered
   *                         as classes that appear in the middle of the word.
   * @param knownLCWords If non-null and non-empty, tag with a &quot;k&quot; suffix words
   *                    that are in this list when lowercased (representing
   *                    that the word is &quot;known&quot; as a lowercase word).
   * @return A word shape for the word.
   */
  private static String wordShapeChris2(String s, boolean omitIfInBoundary, Collection&lt;String&gt; knownLCWords) {
<span class="fc" id="L362">    int len = s.length();</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">    if (len &lt;= BOUNDARY_SIZE * 2) {</span>
<span class="fc" id="L364">      return wordShapeChris2Short(s, len, knownLCWords);</span>
    } else {
<span class="fc" id="L366">      return wordShapeChris2Long(s, omitIfInBoundary, len, knownLCWords);</span>
    }
  }

  // Do the simple case of words &lt;= BOUNDARY_SIZE * 2 (i.e., 4) with only 1 object allocation!
  private static String wordShapeChris2Short(String s, int len, Collection&lt;String&gt; knownLCWords) {
<span class="fc bfc" id="L372" title="All 2 branches covered.">    int sbLen = (knownLCWords != null) ? len + 1: len;  // markKnownLC makes String 1 longer</span>
<span class="fc" id="L373">    final StringBuilder sb = new StringBuilder(sbLen);</span>
<span class="fc" id="L374">    boolean nonLetters = false;</span>

<span class="fc bfc" id="L376" title="All 2 branches covered.">    for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L377">      char c = s.charAt(i);</span>
<span class="fc" id="L378">      char m = c;</span>
<span class="fc bfc" id="L379" title="All 2 branches covered.">      if (Character.isDigit(c)) {</span>
<span class="fc" id="L380">        m = 'd';</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">      } else if (Character.isLowerCase(c)) {</span>
<span class="fc" id="L382">        m = 'x';</span>
<span class="pc bpc" id="L383" title="1 of 4 branches missed.">      } else if (Character.isUpperCase(c) || Character.isTitleCase(c)) {</span>
<span class="fc" id="L384">        m = 'X';</span>
      }
<span class="fc bfc" id="L386" title="All 2 branches covered.">      for (String gr : greek) {</span>
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">        if (s.startsWith(gr, i)) {</span>
<span class="nc" id="L388">          m = 'g';</span>
          //System.out.println(s + &quot;  ::  &quot; + s.substring(i+1));
<span class="nc" id="L390">          i += gr.length() - 1;</span>
          // System.out.println(&quot;Position skips to &quot; + i);
<span class="nc" id="L392">          break;</span>
        }
      }
<span class="fc bfc" id="L395" title="All 4 branches covered.">      if (m != 'x' &amp;&amp; m != 'X') {</span>
<span class="fc" id="L396">        nonLetters = true;</span>
      }

<span class="fc" id="L399">      sb.append(m);</span>
    }

<span class="fc bfc" id="L402" title="All 2 branches covered.">    if (knownLCWords != null) {</span>
<span class="fc bfc" id="L403" title="All 4 branches covered.">      if ( ! nonLetters &amp;&amp; knownLCWords.contains(s.toLowerCase())) {</span>
<span class="fc" id="L404">        sb.append('k');</span>
      }
    }
    // System.out.println(s + &quot; became &quot; + sb);
<span class="fc" id="L408">    return sb.toString();</span>
  }

  // introduce sizes and optional allocation to reduce memory churn demands;
  // this class could blow a lot of memory if used in a tight loop,
  // as the naive version allocates lots of kind of heavyweight objects
  // endSB should be of length BOUNDARY_SIZE
  // sb is maximally of size s.length() + 1, but is usually (much) shorter. The +1 might happen if markKnownLC is true and it applies
  // boundSet is maximally of size BOUNDARY_SIZE * 2 (and is often smaller)
  // seenSet is maximally of size s.length() - BOUNDARY_SIZE * 2, but might often be of size &lt;= 4. But it has no initial size allocation
  // But we want the initial size to be greater than BOUNDARY_SIZE * 2 * (4/3) since the default loadfactor is 3/4.
  // That is, of size 6, which become 8, since HashMaps are powers of 2.  Still, it's half the size
  private static String wordShapeChris2Long(String s, boolean omitIfInBoundary, int len, Collection&lt;String&gt; knownLCWords) {
<span class="fc" id="L421">    final char[] beginChars = new char[BOUNDARY_SIZE];</span>
<span class="fc" id="L422">    final char[] endChars = new char[BOUNDARY_SIZE];</span>
<span class="fc" id="L423">    int beginUpto = 0;</span>
<span class="fc" id="L424">    int endUpto = 0;</span>
<span class="fc" id="L425">    final Set&lt;Character&gt; seenSet = new TreeSet&lt;&gt;();  // TreeSet guarantees stable ordering; has no size parameter</span>

<span class="fc" id="L427">    boolean nonLetters = false;</span>

<span class="fc bfc" id="L429" title="All 2 branches covered.">    for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L430">      int iIncr = 0;</span>
<span class="fc" id="L431">      char c = s.charAt(i);</span>
<span class="fc" id="L432">      char m = c;</span>
<span class="fc bfc" id="L433" title="All 2 branches covered.">      if (Character.isDigit(c)) {</span>
<span class="fc" id="L434">        m = 'd';</span>
<span class="fc bfc" id="L435" title="All 2 branches covered.">      } else if (Character.isLowerCase(c)) {</span>
<span class="fc" id="L436">        m = 'x';</span>
<span class="pc bpc" id="L437" title="1 of 4 branches missed.">      } else if (Character.isUpperCase(c) || Character.isTitleCase(c)) {</span>
<span class="fc" id="L438">        m = 'X';</span>
      }
<span class="fc bfc" id="L440" title="All 2 branches covered.">      for (String gr : greek) {</span>
<span class="fc bfc" id="L441" title="All 2 branches covered.">        if (s.startsWith(gr, i)) {</span>
<span class="fc" id="L442">          m = 'g';</span>
          //System.out.println(s + &quot;  ::  &quot; + s.substring(i+1));
<span class="fc" id="L444">          iIncr = gr.length() - 1;</span>
<span class="fc" id="L445">          break;</span>
        }
      }
<span class="fc bfc" id="L448" title="All 4 branches covered.">      if (m != 'x' &amp;&amp; m != 'X') {</span>
<span class="fc" id="L449">        nonLetters = true;</span>
      }

<span class="fc bfc" id="L452" title="All 2 branches covered.">      if (i &lt; BOUNDARY_SIZE) {</span>
<span class="fc" id="L453">        beginChars[beginUpto++] = m;</span>
<span class="fc bfc" id="L454" title="All 2 branches covered.">      } else if (i &lt; len - BOUNDARY_SIZE) {</span>
<span class="fc" id="L455">        seenSet.add(Character.valueOf(m));</span>
      } else {
<span class="fc" id="L457">        endChars[endUpto++] = m;</span>
      }
<span class="fc" id="L459">      i += iIncr;</span>
      // System.out.println(&quot;Position skips to &quot; + i);
    }

    // Calculate size. This may be an upperbound, but is often correct
<span class="fc" id="L464">    int sbSize = beginUpto + endUpto + seenSet.size();</span>
<span class="fc bfc" id="L465" title="All 2 branches covered.">    if (knownLCWords != null) { sbSize++; }</span>
<span class="fc" id="L466">    final StringBuilder sb = new StringBuilder(sbSize);</span>
    // put in the beginning chars
<span class="fc" id="L468">    sb.append(beginChars, 0, beginUpto);</span>
    // put in the stored ones sorted
<span class="fc bfc" id="L470" title="All 2 branches covered.">    if (omitIfInBoundary) {</span>
<span class="fc bfc" id="L471" title="All 2 branches covered.">      for (Character chr : seenSet) {</span>
<span class="fc" id="L472">        char ch = chr.charValue();</span>
<span class="fc" id="L473">        boolean insert = true;</span>
<span class="fc bfc" id="L474" title="All 2 branches covered.">        for (int i = 0; i &lt; beginUpto; i++) {</span>
<span class="fc bfc" id="L475" title="All 2 branches covered.">          if (beginChars[i] == ch) {</span>
<span class="fc" id="L476">            insert = false;</span>
<span class="fc" id="L477">            break;</span>
          }
        }
<span class="fc bfc" id="L480" title="All 2 branches covered.">        for (int i = 0; i &lt; endUpto; i++) {</span>
<span class="fc bfc" id="L481" title="All 2 branches covered.">          if (endChars[i] == ch) {</span>
<span class="fc" id="L482">            insert = false;</span>
<span class="fc" id="L483">            break;</span>
          }
        }
<span class="fc bfc" id="L486" title="All 2 branches covered.">        if (insert) {</span>
<span class="fc" id="L487">          sb.append(ch);</span>
        }
<span class="fc" id="L489">      }</span>
    } else {
<span class="fc bfc" id="L491" title="All 2 branches covered.">      for (Character chr : seenSet) {</span>
<span class="fc" id="L492">        sb.append(chr.charValue());</span>
<span class="fc" id="L493">      }</span>
    }
    // and add end ones
<span class="fc" id="L496">    sb.append(endChars, 0, endUpto);</span>

<span class="fc bfc" id="L498" title="All 2 branches covered.">    if (knownLCWords != null) {</span>
<span class="fc bfc" id="L499" title="All 4 branches covered.">      if (!nonLetters &amp;&amp; knownLCWords.contains(s.toLowerCase())) {</span>
<span class="fc" id="L500">        sb.append('k');</span>
      }
    }
    // System.out.println(s + &quot; became &quot; + sb);
<span class="fc" id="L504">    return sb.toString();</span>
  }


  private static char chris4equivalenceClass(final char c) {
<span class="fc" id="L509">    int type = Character.getType(c);</span>
<span class="pc bpc" id="L510" title="2 of 6 branches missed.">    if (Character.isDigit(c) || type == Character.LETTER_NUMBER</span>
            || type == Character.OTHER_NUMBER
<span class="fc bfc" id="L512" title="All 2 branches covered.">            || &quot;一二三四五六七八九十零〇百千万亿兩○◯&quot;.indexOf(c) &gt; 0) {</span>
      // include Chinese numbers that are just of unicode type OTHER_LETTER (and a couple of round symbols often used (by mistake?) for zeroes)
<span class="fc" id="L514">      return 'd';</span>
<span class="pc bpc" id="L515" title="1 of 2 branches missed.">    } else if (c == '第') {</span>
<span class="nc" id="L516">      return 'o'; // detect those Chinese ordinals!</span>
<span class="pc bpc" id="L517" title="3 of 6 branches missed.">    } else if (c == '年' || c == '月' || c == '日') { // || c == '号') {</span>
<span class="nc" id="L518">      return 'D'; // Chinese date characters.</span>
<span class="fc bfc" id="L519" title="All 2 branches covered.">    } else if (Character.isLowerCase(c)) {</span>
<span class="fc" id="L520">      return 'x';</span>
<span class="pc bpc" id="L521" title="1 of 4 branches missed.">    } else if (Character.isUpperCase(c) || Character.isTitleCase(c)) {</span>
<span class="fc" id="L522">      return 'X';</span>
<span class="pc bpc" id="L523" title="2 of 4 branches missed.">    } else if (Character.isWhitespace(c) || Character.isSpaceChar(c)) {</span>
<span class="nc" id="L524">      return 's';</span>
<span class="fc bfc" id="L525" title="All 2 branches covered.">    } else if (type == Character.OTHER_LETTER) {</span>
<span class="fc" id="L526">      return 'c'; // Chinese characters, etc. without case</span>
<span class="fc bfc" id="L527" title="All 2 branches covered.">    } else if (type == Character.CURRENCY_SYMBOL) {</span>
<span class="fc" id="L528">      return '$';</span>
<span class="pc bpc" id="L529" title="1 of 2 branches missed.">    } else if (type == Character.MATH_SYMBOL) {</span>
<span class="nc" id="L530">      return '+';</span>
<span class="pc bpc" id="L531" title="2 of 4 branches missed.">    } else if (type == Character.OTHER_SYMBOL || c == '|') {</span>
<span class="nc" id="L532">      return '|';</span>
<span class="fc bfc" id="L533" title="All 2 branches covered.">    } else if (type == Character.START_PUNCTUATION) {</span>
<span class="fc" id="L534">      return '(';</span>
<span class="fc bfc" id="L535" title="All 2 branches covered.">    } else if (type == Character.END_PUNCTUATION) {</span>
<span class="fc" id="L536">      return ')';</span>
<span class="pc bpc" id="L537" title="1 of 2 branches missed.">    } else if (type == Character.INITIAL_QUOTE_PUNCTUATION) {</span>
<span class="nc" id="L538">      return '`';</span>
<span class="pc bpc" id="L539" title="1 of 4 branches missed.">    } else if (type == Character.FINAL_QUOTE_PUNCTUATION || c == '\'') {</span>
<span class="fc" id="L540">      return '\'';</span>
<span class="fc bfc" id="L541" title="All 2 branches covered.">    } else if (c == '%') {</span>
<span class="fc" id="L542">      return '%';</span>
<span class="fc bfc" id="L543" title="All 2 branches covered.">    } else if (type == Character.OTHER_PUNCTUATION) {</span>
<span class="fc" id="L544">      return '.';</span>
<span class="pc bpc" id="L545" title="1 of 2 branches missed.">    } else if (type == Character.CONNECTOR_PUNCTUATION) {</span>
<span class="nc" id="L546">      return '_';</span>
<span class="pc bpc" id="L547" title="1 of 2 branches missed.">    } else if (type == Character.DASH_PUNCTUATION) {</span>
<span class="fc" id="L548">      return '-';</span>
    } else {
<span class="nc" id="L550">      return 'q';</span>
    }
  }

  public static String wordShapeChris4(String s) {
<span class="nc" id="L555">    return wordShapeChris4(s, false, null);</span>
  }

  /**
   * This one picks up on Dan2 ideas, but seeks to make less distinctions
   * mid sequence by sorting for long words, but to maintain extra
   * distinctions for short words, by always recording the class of the
   * first and last two characters of the word.
   * Compared to chris2 on which it is based,
   * it uses more Unicode classes, and so collapses things like
   * punctuation more, and might work better with real unicode.
   *
   * @param s The String to find the word shape of
   * @param omitIfInBoundary If true, character classes present in the
   *                         first or last two (i.e., BOUNDARY_SIZE) letters
   *                         of the word are not also registered
   *                         as classes that appear in the middle of the word.
   * @param knownLCWords If non-null and non-empty, tag with a &quot;k&quot; suffix words
   *                    that are in this list when lowercased (representing
   *                    that the word is &quot;known&quot; as a lowercase word).
   * @return A word shape for the word.
   */
  private static String wordShapeChris4(String s, boolean omitIfInBoundary, Collection&lt;String&gt; knownLCWords) {
<span class="fc" id="L578">    int len = s.length();</span>
<span class="fc bfc" id="L579" title="All 2 branches covered.">    if (len &lt;= BOUNDARY_SIZE * 2) {</span>
<span class="fc" id="L580">      return wordShapeChris4Short(s, len, knownLCWords);</span>
    } else {
<span class="fc" id="L582">      return wordShapeChris4Long(s, omitIfInBoundary, len, knownLCWords);</span>
    }
  }

  // Do the simple case of words &lt;= BOUNDARY_SIZE * 2 (i.e., 4) with only 1 object allocation!
  private static String wordShapeChris4Short(String s, int len, Collection&lt;String&gt; knownLCWords) {
<span class="fc bfc" id="L588" title="All 2 branches covered.">    int sbLen = (knownLCWords != null) ? len + 1: len;  // markKnownLC makes String 1 longer</span>
<span class="fc" id="L589">    final StringBuilder sb = new StringBuilder(sbLen);</span>
<span class="fc" id="L590">    boolean nonLetters = false;</span>

<span class="fc bfc" id="L592" title="All 2 branches covered.">    for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L593">      char c = s.charAt(i);</span>
<span class="fc" id="L594">      char m = chris4equivalenceClass(c);</span>
<span class="fc bfc" id="L595" title="All 2 branches covered.">      for (String gr : greek) {</span>
<span class="pc bpc" id="L596" title="1 of 2 branches missed.">        if (s.startsWith(gr, i)) {</span>
<span class="nc" id="L597">          m = 'g';</span>
          //System.out.println(s + &quot;  ::  &quot; + s.substring(i+1));
<span class="nc" id="L599">          i += gr.length() - 1;</span>
          // System.out.println(&quot;Position skips to &quot; + i);
<span class="nc" id="L601">          break;</span>
        }
      }
<span class="fc bfc" id="L604" title="All 4 branches covered.">      if (m != 'x' &amp;&amp; m != 'X') {</span>
<span class="fc" id="L605">        nonLetters = true;</span>
      }

<span class="fc" id="L608">      sb.append(m);</span>
    }

<span class="fc bfc" id="L611" title="All 2 branches covered.">    if (knownLCWords != null) {</span>
<span class="fc bfc" id="L612" title="All 4 branches covered.">      if ( ! nonLetters &amp;&amp; knownLCWords.contains(s.toLowerCase())) {</span>
<span class="fc" id="L613">        sb.append('k');</span>
      }
    }
    // System.out.println(s + &quot; became &quot; + sb);
<span class="fc" id="L617">    return sb.toString();</span>
  }


  private static String wordShapeChris4Long(String s, boolean omitIfInBoundary, int len, Collection&lt;String&gt; knownLCWords) {
<span class="fc" id="L622">    StringBuilder sb = new StringBuilder(s.length() + 1);</span>
<span class="fc" id="L623">    StringBuilder endSB = new StringBuilder(BOUNDARY_SIZE);</span>
<span class="fc" id="L624">    Set&lt;Character&gt; boundSet = Generics.newHashSet(BOUNDARY_SIZE * 2);</span>
<span class="fc" id="L625">    Set&lt;Character&gt; seenSet = new TreeSet&lt;&gt;();  // TreeSet guarantees stable ordering</span>
<span class="fc" id="L626">    boolean nonLetters = false;</span>
<span class="fc bfc" id="L627" title="All 2 branches covered.">    for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L628">      char c = s.charAt(i);</span>
<span class="fc" id="L629">      char m = chris4equivalenceClass(c);</span>
<span class="fc" id="L630">      int iIncr = 0;</span>
<span class="fc bfc" id="L631" title="All 2 branches covered.">      for (String gr : greek) {</span>
<span class="fc bfc" id="L632" title="All 2 branches covered.">        if (s.startsWith(gr, i)) {</span>
<span class="fc" id="L633">          m = 'g';</span>
<span class="fc" id="L634">          iIncr = gr.length() - 1;</span>
          //System.out.println(s + &quot;  ::  &quot; + s.substring(i+1));
<span class="fc" id="L636">          break;</span>
        }
      }
<span class="fc bfc" id="L639" title="All 4 branches covered.">      if (m != 'x' &amp;&amp; m != 'X') {</span>
<span class="fc" id="L640">        nonLetters = true;</span>
      }

<span class="fc bfc" id="L643" title="All 2 branches covered.">      if (i &lt; BOUNDARY_SIZE) {</span>
<span class="fc" id="L644">        sb.append(m);</span>
<span class="fc" id="L645">        boundSet.add(Character.valueOf(m));</span>
<span class="fc bfc" id="L646" title="All 2 branches covered.">      } else if (i &lt; len - BOUNDARY_SIZE) {</span>
<span class="fc" id="L647">        seenSet.add(Character.valueOf(m));</span>
      } else {
<span class="fc" id="L649">        boundSet.add(Character.valueOf(m));</span>
<span class="fc" id="L650">        endSB.append(m);</span>
      }
      // System.out.println(&quot;Position &quot; + i + &quot; --&gt; &quot; + m);
<span class="fc" id="L653">      i += iIncr;</span>
    }
    // put in the stored ones sorted and add end ones
<span class="fc bfc" id="L656" title="All 2 branches covered.">    for (Character chr : seenSet) {</span>
<span class="pc bpc" id="L657" title="3 of 4 branches missed.">      if (!omitIfInBoundary || !boundSet.contains(chr)) {</span>
<span class="fc" id="L658">        char ch = chr.charValue();</span>
<span class="fc" id="L659">        sb.append(ch);</span>
      }
<span class="fc" id="L661">    }</span>
<span class="fc" id="L662">    sb.append(endSB);</span>

<span class="fc bfc" id="L664" title="All 2 branches covered.">    if (knownLCWords != null) {</span>
<span class="fc bfc" id="L665" title="All 4 branches covered.">      if (!nonLetters &amp;&amp; knownLCWords.contains(s.toLowerCase())) {</span>
<span class="fc" id="L666">        sb.append('k');</span>
      }
    }
    // System.out.println(s + &quot; became &quot; + sb);
<span class="fc" id="L670">    return sb.toString();</span>
  }


  /**
   * Returns a fine-grained word shape classifier, that equivalence classes
   * lower and upper case and digits, and collapses sequences of the
   * same type, but keeps all punctuation.  This adds an extra recognizer
   * for a greek letter embedded in the String, which is useful for bio.
   */
  private static String wordShapeDan2Bio(String s, Collection&lt;String&gt; knownLCWords) {
<span class="nc bnc" id="L681" title="All 2 branches missed.">    if (containsGreekLetter(s)) {</span>
<span class="nc" id="L682">      return wordShapeDan2(s, knownLCWords) + &quot;-GREEK&quot;;</span>
    } else {
<span class="nc" id="L684">      return wordShapeDan2(s, knownLCWords);</span>
    }
  }


  /** List of greek letters for bio.  We omit eta, mu, nu, xi, phi, chi, psi.
   *  Maybe should omit rho too, but it is used in bio &quot;Rho kinase inhibitor&quot;.
   */
<span class="fc" id="L692">  private static final String[] greek = {&quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;, &quot;delta&quot;, &quot;epsilon&quot;, &quot;zeta&quot;, &quot;theta&quot;, &quot;iota&quot;, &quot;kappa&quot;, &quot;lambda&quot;, &quot;omicron&quot;, &quot;rho&quot;, &quot;sigma&quot;, &quot;tau&quot;, &quot;upsilon&quot;, &quot;omega&quot;};</span>
<span class="fc" id="L693">  private static final Pattern biogreek = Pattern.compile(&quot;alpha|beta|gamma|delta|epsilon|zeta|theta|iota|kappa|lambda|omicron|rho|sigma|tau|upsilon|omega&quot;, Pattern.CASE_INSENSITIVE);</span>


  /**
   * Somewhat ad-hoc list of only greek letters that bio people use, partly
   * to avoid false positives on short ones.
   * @param s String to check for Greek
   * @return true iff there is a greek lette embedded somewhere in the String
   */
  private static boolean containsGreekLetter(String s) {
<span class="nc" id="L703">    Matcher m = biogreek.matcher(s);</span>
<span class="nc" id="L704">    return m.find();</span>
  }


  /** This one equivalence classes all strings into one of 24 semantically
   *  informed classes, somewhat similarly to the function specified in the
   *  BBN Nymble NER paper (Bikel et al. 1997).
   *  &lt;p&gt;
   *  Note that it regards caseless non-Latin letters as lowercase.
   *
   *  @param s String to word class
   *  @return The string's class
   */
  private static String wordShapeChris1(String s) {
<span class="fc" id="L718">    int length = s.length();</span>
<span class="fc bfc" id="L719" title="All 2 branches covered.">    if (length == 0) {</span>
<span class="fc" id="L720">      return &quot;SYMBOL&quot;; // unclear if this is sensible, but it's what a length 0 String becomes....</span>
    }

<span class="fc" id="L723">    boolean cardinal = false;</span>
<span class="fc" id="L724">    boolean number = true;</span>
<span class="fc" id="L725">    boolean seenDigit = false;</span>
<span class="fc" id="L726">    boolean seenNonDigit = false;</span>

<span class="fc bfc" id="L728" title="All 2 branches covered.">    for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L729">      char ch = s.charAt(i);</span>
<span class="fc" id="L730">      boolean digit = Character.isDigit(ch);</span>
<span class="fc bfc" id="L731" title="All 2 branches covered.">      if (digit) {</span>
<span class="fc" id="L732">        seenDigit = true;</span>
      } else {
<span class="fc" id="L734">        seenNonDigit = true;</span>
      }
      // allow commas, decimals, and negative numbers
<span class="pc bpc" id="L737" title="1 of 12 branches missed.">      digit = digit || ch == '.' || ch == ',' || (i == 0 &amp;&amp; (ch == '-' || ch == '+'));</span>
<span class="fc bfc" id="L738" title="All 2 branches covered.">      if (!digit) {</span>
<span class="fc" id="L739">        number = false;</span>
      }
    }

<span class="fc bfc" id="L743" title="All 2 branches covered.">    if ( ! seenDigit) {</span>
<span class="fc" id="L744">      number = false;</span>
<span class="fc bfc" id="L745" title="All 2 branches covered.">    } else if ( ! seenNonDigit) {</span>
<span class="fc" id="L746">      cardinal = true;</span>
    }

<span class="fc bfc" id="L749" title="All 2 branches covered.">    if (cardinal) {</span>
<span class="fc bfc" id="L750" title="All 2 branches covered.">      if (length &lt; 4) {</span>
<span class="fc" id="L751">        return &quot;CARDINAL13&quot;;</span>
<span class="fc bfc" id="L752" title="All 2 branches covered.">      } else if (length == 4) {</span>
<span class="fc" id="L753">        return &quot;CARDINAL4&quot;;</span>
      } else {
<span class="fc" id="L755">        return &quot;CARDINAL5PLUS&quot;;</span>
      }
<span class="fc bfc" id="L757" title="All 2 branches covered.">    } else if (number) {</span>
<span class="fc" id="L758">      return &quot;NUMBER&quot;;</span>
    }

<span class="fc" id="L761">    boolean seenLower = false;</span>
<span class="fc" id="L762">    boolean seenUpper = false;</span>
<span class="fc" id="L763">    boolean allCaps = true;</span>
<span class="fc" id="L764">    boolean allLower = true;</span>
<span class="fc" id="L765">    boolean initCap = false;</span>
<span class="fc" id="L766">    boolean dash = false;</span>
<span class="fc" id="L767">    boolean period = false;</span>

<span class="fc bfc" id="L769" title="All 2 branches covered.">    for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L770">      char ch = s.charAt(i);</span>
<span class="fc" id="L771">      boolean up = Character.isUpperCase(ch);</span>
<span class="fc" id="L772">      boolean let = Character.isLetter(ch);</span>
<span class="fc" id="L773">      boolean tit = Character.isTitleCase(ch);</span>
<span class="fc bfc" id="L774" title="All 2 branches covered.">      if (ch == '-') {</span>
<span class="fc" id="L775">        dash = true;</span>
<span class="fc bfc" id="L776" title="All 2 branches covered.">      } else if (ch == '.') {</span>
<span class="fc" id="L777">        period = true;</span>
      }

<span class="pc bpc" id="L780" title="1 of 2 branches missed.">      if (tit) {</span>
<span class="nc" id="L781">        seenUpper = true;</span>
<span class="nc" id="L782">        allLower = false;</span>
<span class="nc" id="L783">        seenLower = true;</span>
<span class="nc" id="L784">        allCaps = false;</span>
<span class="fc bfc" id="L785" title="All 2 branches covered.">      } else if (up) {</span>
<span class="fc" id="L786">        seenUpper = true;</span>
<span class="fc" id="L787">        allLower = false;</span>
<span class="fc bfc" id="L788" title="All 2 branches covered.">      } else if (let) {</span>
<span class="fc" id="L789">        seenLower = true;</span>
<span class="fc" id="L790">        allCaps = false;</span>
      }
<span class="pc bpc" id="L792" title="1 of 6 branches missed.">      if (i == 0 &amp;&amp; (up || tit)) {</span>
<span class="fc" id="L793">        initCap = true;</span>
      }
    }

<span class="fc bfc" id="L797" title="All 6 branches covered.">    if (length == 2 &amp;&amp; initCap &amp;&amp; period) {</span>
<span class="fc" id="L798">      return &quot;ACRONYM1&quot;;</span>
<span class="fc bfc" id="L799" title="All 8 branches covered.">    } else if (seenUpper &amp;&amp; allCaps &amp;&amp; !seenDigit &amp;&amp; period) {</span>
<span class="fc" id="L800">      return &quot;ACRONYM&quot;;</span>
<span class="pc bpc" id="L801" title="1 of 8 branches missed.">    } else if (seenDigit &amp;&amp; dash &amp;&amp; !seenUpper &amp;&amp; !seenLower) {</span>
<span class="fc" id="L802">      return &quot;DIGIT-DASH&quot;;</span>
<span class="fc bfc" id="L803" title="All 8 branches covered.">    } else if (initCap &amp;&amp; seenLower &amp;&amp; seenDigit &amp;&amp; dash) {</span>
<span class="fc" id="L804">      return &quot;CAPITALIZED-DIGIT-DASH&quot;;</span>
<span class="fc bfc" id="L805" title="All 6 branches covered.">    } else if (initCap &amp;&amp; seenLower &amp;&amp; seenDigit) {</span>
<span class="fc" id="L806">      return &quot;CAPITALIZED-DIGIT&quot;;</span>
<span class="fc bfc" id="L807" title="All 6 branches covered.">    } else if (initCap &amp;&amp; seenLower &amp;&amp; dash) {</span>
<span class="fc" id="L808">      return &quot;CAPITALIZED-DASH&quot;;</span>
<span class="fc bfc" id="L809" title="All 4 branches covered.">    } else if (initCap &amp;&amp; seenLower) {</span>
<span class="fc" id="L810">      return &quot;CAPITALIZED&quot;;</span>
<span class="fc bfc" id="L811" title="All 8 branches covered.">    } else if (seenUpper &amp;&amp; allCaps &amp;&amp; seenDigit &amp;&amp; dash) {</span>
<span class="fc" id="L812">      return &quot;ALLCAPS-DIGIT-DASH&quot;;</span>
<span class="fc bfc" id="L813" title="All 6 branches covered.">    } else if (seenUpper &amp;&amp; allCaps &amp;&amp; seenDigit) {</span>
<span class="fc" id="L814">      return &quot;ALLCAPS-DIGIT&quot;;</span>
<span class="pc bpc" id="L815" title="1 of 6 branches missed.">    } else if (seenUpper &amp;&amp; allCaps &amp;&amp; dash) {</span>
<span class="nc" id="L816">      return &quot;ALLCAPS&quot;;</span>
<span class="fc bfc" id="L817" title="All 4 branches covered.">    } else if (seenUpper &amp;&amp; allCaps) {</span>
<span class="fc" id="L818">      return &quot;ALLCAPS&quot;;</span>
<span class="pc bpc" id="L819" title="3 of 8 branches missed.">    } else if (seenLower &amp;&amp; allLower &amp;&amp; seenDigit &amp;&amp; dash) {</span>
<span class="nc" id="L820">      return &quot;LOWERCASE-DIGIT-DASH&quot;;</span>
<span class="pc bpc" id="L821" title="1 of 6 branches missed.">    } else if (seenLower &amp;&amp; allLower &amp;&amp; seenDigit) {</span>
<span class="nc" id="L822">      return &quot;LOWERCASE-DIGIT&quot;;</span>
<span class="fc bfc" id="L823" title="All 6 branches covered.">    } else if (seenLower &amp;&amp; allLower &amp;&amp; dash) {</span>
<span class="fc" id="L824">      return &quot;LOWERCASE-DASH&quot;;</span>
<span class="fc bfc" id="L825" title="All 4 branches covered.">    } else if (seenLower &amp;&amp; allLower) {</span>
<span class="fc" id="L826">      return &quot;LOWERCASE&quot;;</span>
<span class="pc bpc" id="L827" title="1 of 4 branches missed.">    } else if (seenLower &amp;&amp; seenDigit) {</span>
<span class="nc" id="L828">      return &quot;MIXEDCASE-DIGIT&quot;;</span>
<span class="fc bfc" id="L829" title="All 2 branches covered.">    } else if (seenLower) {</span>
<span class="fc" id="L830">      return &quot;MIXEDCASE&quot;;</span>
<span class="fc bfc" id="L831" title="All 2 branches covered.">    } else if (seenDigit) {</span>
<span class="fc" id="L832">      return &quot;SYMBOL-DIGIT&quot;;</span>
    } else {
<span class="fc" id="L834">      return &quot;SYMBOL&quot;;</span>
    }
  }


  /**
   * Just collapses digits to 9 characters.
   * Does lazy copying of String.
   *
   * @param s String to find word shape of
   * @return The same string except digits are equivalence classed to 9.
   */
  private static String wordShapeDigits(final String s) {
<span class="fc" id="L847">    char[] outChars = null;</span>

<span class="fc bfc" id="L849" title="All 2 branches covered.">    for (int i = 0; i &lt; s.length(); i++) {</span>
<span class="fc" id="L850">      char c = s.charAt(i);</span>
<span class="fc bfc" id="L851" title="All 2 branches covered.">      if (Character.isDigit(c)) {</span>
<span class="fc bfc" id="L852" title="All 2 branches covered.">        if (outChars == null) {</span>
<span class="fc" id="L853">          outChars = s.toCharArray();</span>
        }
<span class="fc" id="L855">        outChars[i] = '9';</span>
      }
    }
<span class="fc bfc" id="L858" title="All 2 branches covered.">    if (outChars == null) {</span>
      // no digit found
<span class="fc" id="L860">      return s;</span>
    } else {
<span class="fc" id="L862">      return new String(outChars);</span>
    }
  }


  /**
   * Uses distributional similarity clusters for unknown words.  Except that
   * numbers are just turned into NUMBER.
   * This one uses ones from a fixed file that we've used for NER.
   *
   * @param s String to find word shape of
   * @return Its word shape
   */
  private static String wordShapeCluster1(String s) {
<span class="nc" id="L876">    boolean digit = true;</span>
<span class="nc bnc" id="L877" title="All 2 branches missed.">    for (int i = 0; i &lt; s.length(); i++) {</span>
<span class="nc" id="L878">      char c = s.charAt(i);</span>
<span class="nc bnc" id="L879" title="All 12 branches missed.">      if ( ! (Character.isDigit(c) || c == '.' || c == ',' || (i == 0 &amp;&amp; (c == '-' || c == '+')))) {</span>
<span class="nc" id="L880">        digit = false;</span>
      }
    }
<span class="nc bnc" id="L883" title="All 2 branches missed.">    if (digit) {</span>
<span class="nc" id="L884">      return &quot;NUMBER&quot;;</span>
    } else {
<span class="nc" id="L886">      String cluster = DistributionalClusters.cluster1.get(s);</span>
<span class="nc bnc" id="L887" title="All 2 branches missed.">      if (cluster == null) {</span>
<span class="nc" id="L888">        cluster = &quot;NULL&quot;;</span>
      }
<span class="nc" id="L890">      return cluster;</span>
    }
  }

  private static String wordShapeChinese(final String s) {
<span class="nc" id="L895">    return ChineseUtils.shapeOf(s, true, true);</span>
  }


  private static class DistributionalClusters {

<span class="nc" id="L901">    private DistributionalClusters() {}</span>

<span class="nc" id="L903">    public static Map&lt;String,String&gt; cluster1  = loadWordClusters(&quot;/u/nlp/data/pos_tags_are_useless/egw.bnc.200&quot;,</span>
                                                           &quot;alexClark&quot;);

<span class="nc" id="L906">    private static class LcMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; {</span>

      private static final long serialVersionUID = -457913281600751901L;

      @Override
      public V get(Object key) {
<span class="nc" id="L912">        return super.get(key.toString().toLowerCase());</span>
      }
    }

    public static Map&lt;String,String&gt; loadWordClusters(String file, String format) {
<span class="nc" id="L917">      Timing.startDoing(&quot;Loading distsim lexicon from &quot; + file);</span>
<span class="nc" id="L918">      Map&lt;String,String&gt; lexicon = new LcMap&lt;&gt;();</span>
<span class="nc bnc" id="L919" title="All 2 branches missed.">      if (&quot;terryKoo&quot;.equals(format)) {</span>
<span class="nc bnc" id="L920" title="All 2 branches missed.">        for (String line : ObjectBank.getLineIterator(file)) {</span>
<span class="nc" id="L921">          String[] bits = line.split(&quot;\\t&quot;);</span>
<span class="nc" id="L922">          String word = bits[1];</span>
          // for now, always lowercase, but should revisit this
<span class="nc" id="L924">          word = word.toLowerCase();</span>
<span class="nc" id="L925">          String wordClass = bits[0];</span>
<span class="nc" id="L926">          lexicon.put(word, wordClass);</span>
<span class="nc" id="L927">        }</span>
      } else {
        // &quot;alexClark&quot;
<span class="nc bnc" id="L930" title="All 2 branches missed.">        for (String line : ObjectBank.getLineIterator(file)) {</span>
<span class="nc" id="L931">          String[] bits = line.split(&quot;\\s+&quot;);</span>
<span class="nc" id="L932">          String word = bits[0];</span>
          // for now, always lowercase, but should revisit this
<span class="nc" id="L934">          word = word.toLowerCase();</span>
<span class="nc" id="L935">          lexicon.put(word, bits[1]);</span>
<span class="nc" id="L936">        }</span>
      }
<span class="nc" id="L938">      Timing.endDoing();</span>
<span class="nc" id="L939">      return lexicon;</span>
    }

  }


  /**
   * Usage: &lt;code&gt;java edu.stanford.nlp.process.WordShapeClassifier
   * [-wordShape name] string+ &lt;/code&gt;&lt;br&gt;
   * where &lt;code&gt;name&lt;/code&gt; is an argument to &lt;code&gt;lookupShaper&lt;/code&gt;.
   * Known names have patterns along the lines of: dan[12](bio)?(UseLC)?,
   * jenny1(useLC)?, chris[1234](useLC)?, cluster1.
   * If you don't specify a word shape function, you get chris1.
   *
   * @param args Command-line arguments, as above.
   */
  public static void main(String[] args) {
<span class="nc" id="L956">    int i = 0;</span>
<span class="nc" id="L957">    int classifierToUse = WORDSHAPECHRIS1;</span>
<span class="nc bnc" id="L958" title="All 2 branches missed.">    if (args.length == 0) {</span>
<span class="nc" id="L959">      System.out.println(&quot;edu.stanford.nlp.process.WordShapeClassifier [-wordShape name] string+&quot;);</span>
<span class="nc bnc" id="L960" title="All 2 branches missed.">    } else if (args[0].charAt(0) == '-') {</span>
<span class="nc bnc" id="L961" title="All 4 branches missed.">      if (args[0].equals(&quot;-wordShape&quot;) &amp;&amp; args.length &gt;= 2) {</span>
<span class="nc" id="L962">        classifierToUse = lookupShaper(args[1]);</span>
<span class="nc" id="L963">        i += 2;</span>
      } else {
<span class="nc" id="L965">        log.info(&quot;Unknown flag: &quot; + args[0]);</span>
<span class="nc" id="L966">        i++;</span>
      }
    }

<span class="nc bnc" id="L970" title="All 2 branches missed.">    for (; i &lt; args.length; i++) {</span>
<span class="nc" id="L971">      System.out.print(args[i] + &quot;: &quot;);</span>
<span class="nc" id="L972">      System.out.println(wordShape(args[i], classifierToUse));</span>
    }
<span class="nc" id="L974">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>