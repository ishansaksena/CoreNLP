<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PhraseTable.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.ling.tokensregex</a> &gt; <span class="el_source">PhraseTable.java</span></div><h1>PhraseTable.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.ling.tokensregex; 
import edu.stanford.nlp.util.logging.Redwood;

import edu.stanford.nlp.io.IOUtils;
import edu.stanford.nlp.ling.CoreAnnotations;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.pipeline.Annotation;
import edu.stanford.nlp.pipeline.Annotator;
import edu.stanford.nlp.stats.ClassicCounter;
import edu.stanford.nlp.stats.Counter;
import edu.stanford.nlp.util.*;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.Serializable;
import java.util.*;
import java.util.regex.Pattern;

/**
 * Table used to lookup multi-word phrases.
 * This class provides functions for looking up all instances of known phrases in a document in an efficient manner.
 *
 * Phrases can be added to the phrase table using
 * &lt;ul&gt;
 *   &lt;li&gt;readPhrases&lt;/li&gt;
 *   &lt;li&gt;readPhrasesWithTagScores&lt;/li&gt;
 *   &lt;li&gt;addPhrase&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * You can lookup phrases in the table using
 * &lt;ul&gt;
 *   &lt;li&gt;get&lt;/li&gt;
 *   &lt;li&gt;lookup&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * You can find phrases occurring in a piece of text using
 * &lt;ul&gt;
 *   &lt;li&gt;findAllMatches&lt;/li&gt;
 *   &lt;li&gt;findNonOverlappingPhrases&lt;/li&gt;
 * &lt;/ul&gt;
 * @author Angel Chang
 */
<span class="pc bpc" id="L43" title="1 of 2 branches missed.">public class PhraseTable implements Serializable</span>
{

  /** A logger for this class */
<span class="fc" id="L47">  private static Redwood.RedwoodChannels log = Redwood.channels(PhraseTable.class);</span>

  private static final String PHRASE_END = &quot;&quot;;
  private static final long serialVersionUID = 1L;
  Map&lt;String,Object&gt; rootTree;

<span class="pc" id="L53">  public boolean normalize = true;</span>
<span class="pc" id="L54">  public boolean caseInsensitive = false;</span>
<span class="pc" id="L55">  public boolean ignorePunctuation = false;</span>
<span class="pc" id="L56">  public boolean ignorePunctuationTokens = true;</span>
  public Annotator tokenizer;  // tokenizing annotator

<span class="pc" id="L59">  int nPhrases = 0;</span>
<span class="pc" id="L60">  int nStrings = 0;</span>

<span class="pc" id="L62">  transient CacheMap&lt;String,String&gt; normalizedCache = new CacheMap&lt;&gt;(5000);</span>

<span class="fc" id="L64">  public PhraseTable() {}</span>

<span class="nc" id="L66">  public PhraseTable(int initSize) { rootTree = new HashMap&lt;&gt;(initSize); }</span>

<span class="nc" id="L68">  public PhraseTable(boolean normalize, boolean caseInsensitive, boolean ignorePunctuation) {</span>
<span class="nc" id="L69">    this.normalize = normalize;</span>
<span class="nc" id="L70">    this.caseInsensitive = caseInsensitive;</span>
<span class="nc" id="L71">    this.ignorePunctuation = ignorePunctuation;</span>
<span class="nc" id="L72">  }</span>

  public boolean isEmpty() {
<span class="nc bnc" id="L75" title="All 2 branches missed.">    return (nPhrases == 0);</span>
  }

  public boolean containsKey(Object key) {
<span class="nc bnc" id="L79" title="All 2 branches missed.">    return get(key) != null;</span>
  }

  public Phrase get(Object key) {
<span class="nc bnc" id="L83" title="All 2 branches missed.">    if (key instanceof String) {</span>
<span class="nc" id="L84">      return lookup((String) key);</span>
<span class="nc bnc" id="L85" title="All 2 branches missed.">    } else if (key instanceof WordList) {</span>
<span class="nc" id="L86">      return lookup((WordList) key);</span>
    } else {
<span class="nc" id="L88">      return null;</span>
    }
  }

  /**
   * Clears this table
   */
  public void clear()
  {
<span class="nc" id="L97">    rootTree = null;</span>
<span class="nc" id="L98">    nPhrases = 0;</span>
<span class="nc" id="L99">    nStrings = 0;</span>
<span class="nc" id="L100">  }</span>

  public void setNormalizationCacheSize(int cacheSize)
  {
<span class="nc" id="L104">    CacheMap&lt;String,String&gt; newNormalizedCache = new CacheMap&lt;&gt;(cacheSize);</span>
<span class="nc" id="L105">    newNormalizedCache.putAll(normalizedCache);</span>
<span class="nc" id="L106">    normalizedCache = newNormalizedCache;</span>
<span class="nc" id="L107">  }</span>

  /**
   * Input functions to read in phrases to the table
   */

<span class="fc" id="L113">  private static final Pattern tabPattern = Pattern.compile(&quot;\t&quot;);</span>

  /**
   * Read in phrases from a file (assumed to be tab delimited)
   * @param filename - Name of file
   * @param checkTag - Indicates if there is a tag column (assumed to be 2nd column)
   *                   If false, treats entire line as the phrase
   * @throws IOException
   */
  public void readPhrases(String filename, boolean checkTag) throws IOException
  {
<span class="nc" id="L124">    readPhrases(filename, checkTag, tabPattern);</span>
<span class="nc" id="L125">  }</span>

  /**
   * Read in phrases from a file.  Column delimiters are matched using regex
   * @param filename - Name of file
   * @param checkTag - Indicates if there is a tag column (assumed to be 2nd column)
   *                   If false, treats entire line as the phrase
   * @param delimiterRegex - Regex for identifying column delimiter
   * @throws IOException
   */
  public void readPhrases(String filename, boolean checkTag, String delimiterRegex) throws IOException
  {
<span class="nc" id="L137">    readPhrases(filename, checkTag, Pattern.compile(delimiterRegex));</span>
<span class="nc" id="L138">  }</span>

  public void readPhrases(String filename, boolean checkTag, Pattern delimiterPattern) throws IOException
  {
<span class="nc" id="L142">    Timing timer = new Timing();</span>
<span class="nc" id="L143">    timer.doing(&quot;Reading phrases: &quot; + filename);</span>
<span class="nc" id="L144">    BufferedReader br = IOUtils.getBufferedFileReader(filename);</span>
    String line;
<span class="nc bnc" id="L146" title="All 2 branches missed.">    while ((line = br.readLine()) != null) {</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">      if (checkTag) {</span>
<span class="nc" id="L148">        String[] columns = delimiterPattern.split(line, 2);</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">        if (columns.length == 1) {</span>
<span class="nc" id="L150">          addPhrase(columns[0]);</span>
        } else {
<span class="nc" id="L152">          addPhrase(columns[0], columns[1]);</span>
        }
<span class="nc" id="L154">      } else {</span>
<span class="nc" id="L155">        addPhrase(line);</span>
      }
    }
<span class="nc" id="L158">    br.close();</span>
<span class="nc" id="L159">    timer.done();</span>
<span class="nc" id="L160">  }</span>

  /**
   * Read in phrases where there is each pattern has a score of being associated with a certain tag.
   * The file format is assumed to be
   *   phrase\ttag1 count\ttag2 count...
   * where the phrases and tags are delimited by tabs, and each tag and count is delimited by whitespaces
   * @param filename
   * @throws IOException
   */
  public void readPhrasesWithTagScores(String filename) throws IOException
  {
<span class="nc" id="L172">    readPhrasesWithTagScores(filename, tabPattern, whitespacePattern);</span>
<span class="nc" id="L173">  }</span>

  public void readPhrasesWithTagScores(String filename, String fieldDelimiterRegex,
                                    String countDelimiterRegex) throws IOException
  {
<span class="nc" id="L178">    readPhrasesWithTagScores(filename, Pattern.compile(fieldDelimiterRegex), Pattern.compile(countDelimiterRegex));</span>
<span class="nc" id="L179">  }</span>

  public void readPhrasesWithTagScores(String filename, Pattern fieldDelimiterPattern, Pattern countDelimiterPattern) throws IOException
  {
<span class="nc" id="L183">    Timing timer = new Timing();</span>
<span class="nc" id="L184">    timer.doing(&quot;Reading phrases: &quot; + filename);</span>
<span class="nc" id="L185">    BufferedReader br = IOUtils.getBufferedFileReader(filename);</span>
    String line;
<span class="nc" id="L187">    int lineno = 0;</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">    while ((line = br.readLine()) != null) {</span>
<span class="nc" id="L189">      String[] columns = fieldDelimiterPattern.split(line);</span>
<span class="nc" id="L190">      String phrase = columns[0];</span>
      // Pick map factory to use depending on number of tags we have
<span class="nc bnc" id="L192" title="All 2 branches missed.">      MapFactory&lt;String,MutableDouble&gt; mapFactory = (columns.length &lt; 20)?</span>
<span class="nc" id="L193">              MapFactory.&lt;String,MutableDouble&gt;arrayMapFactory(): MapFactory.&lt;String,MutableDouble&gt;linkedHashMapFactory();</span>
<span class="nc" id="L194">      Counter&lt;String&gt; counts = new ClassicCounter&lt;&gt;(mapFactory);</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">      for (int i = 1; i &lt; columns.length; i++) {</span>
<span class="nc" id="L196">        String[] tagCount = countDelimiterPattern.split(columns[i], 2);</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">        if (tagCount.length == 2) {</span>
          try {
<span class="nc" id="L199">            counts.setCount(tagCount[0], Double.parseDouble(tagCount[1]));</span>
<span class="nc" id="L200">          } catch (NumberFormatException ex) {</span>
<span class="nc" id="L201">            throw new RuntimeException(&quot;Error processing field &quot; + i + &quot;: '&quot; + columns[i] +</span>
                    &quot;' from (&quot; + filename + &quot;:&quot; + lineno + &quot;): &quot; + line, ex);
<span class="nc" id="L203">          }</span>
        } else {
<span class="nc" id="L205">          throw new RuntimeException(&quot;Error processing field &quot; + i + &quot;: '&quot; + columns[i] +</span>
                  &quot;' from + (&quot; + filename + &quot;:&quot; + lineno + &quot;): &quot; + line);
        }
      }
<span class="nc" id="L209">      addPhrase(phrase, null, counts);</span>
<span class="nc" id="L210">      lineno++;</span>
<span class="nc" id="L211">    }</span>
<span class="nc" id="L212">    br.close();</span>
<span class="nc" id="L213">    timer.done();</span>
<span class="nc" id="L214">  }</span>

  public void readPhrases(String filename, int phraseColIndex, int tagColIndex) throws IOException
  {
<span class="nc bnc" id="L218" title="All 2 branches missed.">    if (phraseColIndex &lt; 0) {</span>
<span class="nc" id="L219">      throw new IllegalArgumentException(&quot;Invalid phraseColIndex &quot; + phraseColIndex);</span>
    }
<span class="nc" id="L221">    Timing timer = new Timing();</span>
<span class="nc" id="L222">    timer.doing(&quot;Reading phrases: &quot; + filename);</span>
<span class="nc" id="L223">    BufferedReader br = IOUtils.getBufferedFileReader(filename);</span>
    String line;
<span class="nc bnc" id="L225" title="All 2 branches missed.">    while ((line = br.readLine()) != null) {</span>
<span class="nc" id="L226">      String[] columns = tabPattern.split(line);</span>
<span class="nc" id="L227">      String phrase = columns[phraseColIndex];</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">      String tag = (tagColIndex &gt;= 0)? columns[tagColIndex]: null;</span>
<span class="nc" id="L229">      addPhrase(phrase, tag);</span>
<span class="nc" id="L230">    }</span>
<span class="nc" id="L231">    br.close();</span>
<span class="nc" id="L232">    timer.done();</span>
<span class="nc" id="L233">  }</span>

  public static Phrase getLongestPhrase(List&lt;Phrase&gt; phrases)
  {
<span class="nc" id="L237">    Phrase longest = null;</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">    for (Phrase phrase:phrases) {</span>
<span class="nc bnc" id="L239" title="All 4 branches missed.">      if (longest == null || phrase.isLonger(longest)) {</span>
<span class="nc" id="L240">        longest = phrase;</span>
      }
<span class="nc" id="L242">    }</span>
<span class="nc" id="L243">    return longest;</span>
  }

  public String[] splitText(String phraseText)
  {
    String[] words;
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">    if (tokenizer != null) {</span>
<span class="nc" id="L250">      Annotation annotation = new Annotation(phraseText);</span>
<span class="nc" id="L251">      tokenizer.annotate(annotation);</span>
<span class="nc" id="L252">      List&lt;CoreLabel&gt; tokens = annotation.get(CoreAnnotations.TokensAnnotation.class);</span>
<span class="nc" id="L253">      words = new String[tokens.size()];</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">      for (int i = 0; i &lt; tokens.size(); i++) {</span>
<span class="nc" id="L255">        words[i] = tokens.get(i).word();</span>
      }
<span class="nc" id="L257">    } else {</span>
<span class="fc" id="L258">      phraseText = possPattern.matcher(phraseText).replaceAll(&quot; 's$1&quot;);</span>
<span class="fc" id="L259">      words = delimPattern.split(phraseText);</span>
    }
<span class="fc" id="L261">    return words;</span>
  }

  public WordList toWordList(String phraseText)
  {
<span class="nc" id="L266">    String[] words = splitText(phraseText);</span>
<span class="nc" id="L267">    return new StringList(words);</span>
  }

  public WordList toNormalizedWordList(String phraseText)
  {
<span class="fc" id="L272">    String[] words = splitText(phraseText);</span>
<span class="fc" id="L273">    List&lt;String&gt; list = new ArrayList&lt;&gt;(words.length);</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">    for (String word:words) {</span>
<span class="fc" id="L275">      word = getNormalizedForm(word);</span>
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">      if (word.length() &gt; 0) {</span>
<span class="fc" id="L277">        list.add(word);</span>
      }
    }
<span class="fc" id="L280">    return new StringList(list);</span>
  }

  public void addPhrases(Collection&lt;String&gt; phraseTexts)
  {
<span class="fc bfc" id="L285" title="All 2 branches covered.">    for (String phraseText:phraseTexts) {</span>
<span class="fc" id="L286">      addPhrase(phraseText, null);</span>
<span class="fc" id="L287">    }</span>
<span class="fc" id="L288">  }</span>

  public void addPhrases(Map&lt;String,String&gt; taggedPhraseTexts)
  {
<span class="nc bnc" id="L292" title="All 2 branches missed.">    for (String phraseText:taggedPhraseTexts.keySet()) {</span>
<span class="nc" id="L293">      addPhrase(phraseText, taggedPhraseTexts.get(phraseText));</span>
<span class="nc" id="L294">    }</span>
<span class="nc" id="L295">  }</span>

  public boolean addPhrase(String phraseText)
  {
<span class="nc" id="L299">    return addPhrase(phraseText, null);</span>
  }

  public boolean addPhrase(String phraseText, String tag)
  {
<span class="fc" id="L304">    return addPhrase(phraseText, tag, null);</span>
  }

  public boolean addPhrase(String phraseText, String tag, Object phraseData)
  {
<span class="fc" id="L309">    WordList wordList = toNormalizedWordList(phraseText);</span>
<span class="fc" id="L310">    return addPhrase(phraseText, tag, wordList, phraseData);</span>
  }

  public boolean addPhrase(List&lt;String&gt; tokens)
  {
<span class="nc" id="L315">    return addPhrase(tokens, null);</span>
  }

  public boolean addPhrase(List&lt;String&gt; tokens, String tag)
  {
<span class="nc" id="L320">    return addPhrase(tokens, tag, null);</span>
  }

  public boolean addPhrase(List&lt;String&gt; tokens, String tag, Object phraseData)
  {
<span class="nc" id="L325">    WordList wordList = new StringList(tokens);</span>
<span class="nc" id="L326">    return addPhrase(StringUtils.join(tokens, &quot; &quot;), tag, wordList, phraseData);</span>
  }

<span class="pc" id="L329">  private int MAX_LIST_SIZE = 20;</span>
  private synchronized boolean addPhrase(String phraseText, String tag, WordList wordList, Object phraseData)
  {
<span class="fc bfc" id="L332" title="All 2 branches covered.">    if (rootTree == null) {</span>
<span class="fc" id="L333">      rootTree = new HashMap&lt;&gt;();</span>
    }
<span class="fc" id="L335">    return addPhrase(rootTree, phraseText, tag, wordList, phraseData, 0);</span>
  }

  private synchronized void addPhrase(Map&lt;String,Object&gt; tree, Phrase phrase, int wordIndex)
  {
<span class="fc bfc" id="L340" title="All 2 branches covered.">    String word = (phrase.wordList.size() &lt;= wordIndex)? PHRASE_END:phrase.wordList.getWord(wordIndex);</span>
<span class="fc" id="L341">    Object node = tree.get(word);</span>
<span class="pc bpc" id="L342" title="1 of 2 branches missed.">    if (node == null) {</span>
<span class="fc" id="L343">      tree.put(word, phrase);</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">    } else if (node instanceof Phrase) {</span>
      // create list with this phrase and other and put it here
<span class="nc" id="L346">      List list = new ArrayList(2);</span>
<span class="nc" id="L347">      list.add(phrase);</span>
<span class="nc" id="L348">      list.add(node);</span>
<span class="nc" id="L349">      tree.put(word, list);</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">    } else if (node instanceof Map) {</span>
<span class="nc" id="L351">      addPhrase((Map&lt;String,Object&gt;) node, phrase, wordIndex+1);</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">    } else if (node instanceof List) {</span>
<span class="nc" id="L353">      ((List) node).add(phrase);</span>
    } else {
<span class="nc" id="L355">      throw new RuntimeException(&quot;Unexpected class &quot; + node.getClass() + &quot; while adding word &quot;</span>
<span class="nc" id="L356">              + wordIndex + &quot;(&quot; + word + &quot;) in phrase &quot; + phrase.getText());</span>
    }
<span class="fc" id="L358">  }</span>

  private synchronized boolean addPhrase(Map&lt;String,Object&gt; tree,
                                         String phraseText, String tag, WordList wordList, Object phraseData, int wordIndex)
  {
    // Find place to insert this item
<span class="fc" id="L364">    boolean phraseAdded = false;  // True if this phrase was successfully added to the phrase table</span>
<span class="fc" id="L365">    boolean newPhraseAdded = false;    // True if the phrase was a new phrase</span>
<span class="fc" id="L366">    boolean oldPhraseNewFormAdded = false;      // True if the phrase already exists, and this was new form added to old phrase</span>
<span class="pc bpc" id="L367" title="1 of 2 branches missed.">    for (int i = wordIndex; i &lt; wordList.size(); i++) {</span>
<span class="fc" id="L368">      String word = Interner.globalIntern(wordList.getWord(i));</span>
<span class="fc" id="L369">      Object node = tree.get(word);</span>
<span class="fc bfc" id="L370" title="All 2 branches covered.">      if (node == null) {</span>
        // insert here
<span class="fc" id="L372">        Phrase phrase = new Phrase(wordList, phraseText, tag, phraseData);</span>
<span class="fc" id="L373">        tree.put(word, phrase);</span>
<span class="fc" id="L374">        phraseAdded = true;</span>
<span class="fc" id="L375">        newPhraseAdded = true;</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">      } else if (node instanceof Phrase) {</span>
        // check rest of the phrase matches
<span class="fc" id="L378">        Phrase oldphrase = (Phrase) node;</span>
<span class="fc" id="L379">        int matchedTokenEnd = checkWordListMatch(</span>
<span class="fc" id="L380">          oldphrase, wordList, 0, wordList.size(), i+1, true);</span>
<span class="pc bpc" id="L381" title="1 of 2 branches missed.">        if (matchedTokenEnd &gt;= 0) {</span>
<span class="nc" id="L382">          oldPhraseNewFormAdded = oldphrase.addForm(phraseText);</span>
        } else {
          // create list with this phrase and other and put it here
<span class="fc" id="L385">          Phrase newphrase = new Phrase(wordList, phraseText, tag, phraseData);</span>
<span class="fc" id="L386">          List list = new ArrayList(2);</span>
<span class="fc" id="L387">          list.add(oldphrase);</span>
<span class="fc" id="L388">          list.add(newphrase);</span>
<span class="fc" id="L389">          tree.put(word, list);</span>
<span class="fc" id="L390">          newPhraseAdded = true;</span>
        }
<span class="fc" id="L392">        phraseAdded = true;</span>
<span class="fc bfc" id="L393" title="All 2 branches covered.">      } else if (node instanceof Map) {</span>
<span class="fc" id="L394">        tree = (Map&lt;String, Object&gt;) node;</span>
<span class="pc bpc" id="L395" title="1 of 2 branches missed.">      } else if (node instanceof List) {</span>
        // Search through list for matches to word (at this point, the table is small, so no Map)
<span class="fc" id="L397">        List lookupList = (List) node;</span>
<span class="fc" id="L398">        int nMaps = 0;</span>
<span class="fc bfc" id="L399" title="All 2 branches covered.">        for (Object obj:lookupList) {</span>
<span class="pc bpc" id="L400" title="1 of 2 branches missed.">          if (obj instanceof Phrase) {</span>
            // check rest of the phrase matches
<span class="fc" id="L402">            Phrase oldphrase = (Phrase) obj;</span>
<span class="fc" id="L403">            int matchedTokenEnd = checkWordListMatch(</span>
<span class="fc" id="L404">              oldphrase, wordList, 0, wordList.size(), i, true);</span>
<span class="pc bpc" id="L405" title="1 of 2 branches missed.">            if (matchedTokenEnd &gt;= 0) {</span>
<span class="nc" id="L406">              oldPhraseNewFormAdded = oldphrase.addForm(phraseText);</span>
<span class="nc" id="L407">              phraseAdded = true;</span>
<span class="nc" id="L408">              break;</span>
            }
<span class="pc bnc" id="L410" title="All 2 branches missed.">          } else if (obj instanceof Map) {</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">            if (nMaps == 1) {</span>
<span class="nc" id="L412">              throw new RuntimeException(&quot;More than one map in list while adding word &quot;</span>
                      + i + &quot;(&quot; + word + &quot;) in phrase &quot; + phraseText);
            }
<span class="nc" id="L415">            tree = (Map&lt;String, Object&gt;) obj;</span>
<span class="nc" id="L416">            nMaps++;</span>
          } else  {
<span class="nc" id="L418">            throw new RuntimeException(&quot;Unexpected class in list &quot; + obj.getClass() + &quot; while adding word &quot;</span>
                    + i + &quot;(&quot; + word + &quot;) in phrase &quot; + phraseText);
          }
<span class="fc" id="L421">        }</span>
<span class="pc bpc" id="L422" title="2 of 4 branches missed.">        if (!phraseAdded &amp;&amp; nMaps == 0) {</span>
          // add to list
<span class="fc" id="L424">          Phrase newphrase = new Phrase(wordList, phraseText, tag, phraseData);</span>
<span class="fc" id="L425">          lookupList.add(newphrase);</span>
<span class="fc" id="L426">          newPhraseAdded = true;</span>
<span class="fc" id="L427">          phraseAdded = true;</span>
<span class="fc bfc" id="L428" title="All 2 branches covered.">          if (lookupList.size() &gt; MAX_LIST_SIZE) {</span>
            // convert lookupList (should consist only of phrases) to map
<span class="fc" id="L430">            Map newMap = new HashMap&lt;String,Object&gt;(lookupList.size());</span>
<span class="fc bfc" id="L431" title="All 2 branches covered.">            for (Object obj:lookupList) {</span>
<span class="pc bpc" id="L432" title="1 of 2 branches missed.">              if (obj instanceof Phrase) {</span>
<span class="fc" id="L433">                Phrase oldphrase = (Phrase) obj;</span>
<span class="fc" id="L434">                addPhrase(newMap, oldphrase, i+1);</span>
<span class="fc" id="L435">              } else  {</span>
<span class="nc" id="L436">                throw new RuntimeException(&quot;Unexpected class in list &quot; + obj.getClass() + &quot; while converting list to map&quot;);</span>
              }
<span class="fc" id="L438">            }</span>
<span class="fc" id="L439">            tree.put(word,newMap);</span>
          }
        }
<span class="fc" id="L442">      } else {</span>
<span class="nc" id="L443">        throw new RuntimeException(&quot;Unexpected class in list &quot; + node.getClass() + &quot; while adding word &quot;</span>
                + i + &quot;(&quot; + word + &quot;) in phrase &quot; + phraseText);
      }
<span class="fc bfc" id="L446" title="All 2 branches covered.">      if (phraseAdded) {</span>
<span class="fc" id="L447">        break;</span>
      }
    }
<span class="pc bpc" id="L450" title="1 of 2 branches missed.">    if (!phraseAdded) {</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">      if (wordList.size() == 0) {</span>
<span class="nc" id="L452">        log.warn(phraseText + &quot; not added&quot;);</span>
      } else {
<span class="nc" id="L454">        Phrase oldphrase = (Phrase) tree.get(PHRASE_END);</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">        if (oldphrase != null) {</span>
<span class="nc" id="L456">          int matchedTokenEnd = checkWordListMatch(</span>
<span class="nc" id="L457">                  oldphrase, wordList, 0, wordList.size(), wordList.size(), true);</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">          if (matchedTokenEnd &gt;= 0) {</span>
<span class="nc" id="L459">            oldPhraseNewFormAdded = oldphrase.addForm(phraseText);</span>
          } else {
            // create list with this phrase and other and put it here
<span class="nc" id="L462">            Phrase newphrase = new Phrase(wordList, phraseText, tag, phraseData);</span>
<span class="nc" id="L463">            List list = new ArrayList(2);</span>
<span class="nc" id="L464">            list.add(oldphrase);</span>
<span class="nc" id="L465">            list.add(newphrase);</span>
<span class="nc" id="L466">            tree.put(PHRASE_END, list);</span>
<span class="nc" id="L467">            newPhraseAdded = true;</span>
          }
<span class="nc" id="L469">        } else {</span>
<span class="nc" id="L470">          Phrase newphrase = new Phrase(wordList, phraseText, tag, phraseData);</span>
<span class="nc" id="L471">          tree.put(PHRASE_END, newphrase);</span>
<span class="nc" id="L472">          newPhraseAdded = true;</span>
        }
      }
    }
<span class="pc bpc" id="L476" title="1 of 2 branches missed.">    if (newPhraseAdded) {</span>
<span class="fc" id="L477">      nPhrases++;</span>
<span class="fc" id="L478">      nStrings++;</span>
    } else {
<span class="nc" id="L480">      nStrings++;</span>
    }
<span class="pc bpc" id="L482" title="3 of 4 branches missed.">    return (newPhraseAdded || oldPhraseNewFormAdded);</span>
  }

  public String getNormalizedForm(String word)
  {
<span class="fc" id="L487">    String normalized = normalizedCache.get(word);</span>
<span class="fc bfc" id="L488" title="All 2 branches covered.">    if (normalized == null) {</span>
<span class="fc" id="L489">      normalized = createNormalizedForm(word);</span>
<span class="fc" id="L490">      synchronized (this) {</span>
<span class="fc" id="L491">        normalizedCache.put(word, normalized);</span>
<span class="pc" id="L492">      }</span>
    }
<span class="fc" id="L494">    return normalized;</span>
  }

<span class="fc" id="L497">  private static final Pattern punctWhitespacePattern = Pattern.compile(&quot;\\s*(\\p{Punct})\\s*&quot;);</span>
<span class="fc" id="L498">  private static final Pattern whitespacePattern = Pattern.compile(&quot;\\s+&quot;);</span>
<span class="fc" id="L499">  private static final Pattern delimPattern = Pattern.compile(&quot;[\\s_-]+&quot;);</span>
<span class="fc" id="L500">  private static final Pattern possPattern = Pattern.compile(&quot;'s(\\s+|$)&quot;);</span>
  private String createNormalizedForm(String word)
  {
<span class="pc bpc" id="L503" title="1 of 2 branches missed.">    if (normalize) {</span>
<span class="fc" id="L504">      word = StringUtils.normalize(word);</span>
    }
<span class="pc bpc" id="L506" title="1 of 2 branches missed.">    if (caseInsensitive) {</span>
<span class="fc" id="L507">      word = word.toLowerCase();</span>
    }
<span class="pc bpc" id="L509" title="1 of 2 branches missed.">    if (ignorePunctuation) {</span>
<span class="nc" id="L510">      word = punctWhitespacePattern.matcher(word).replaceAll(&quot;&quot;);</span>
<span class="pc bpc" id="L511" title="1 of 2 branches missed.">    } else if (ignorePunctuationTokens) {</span>
<span class="pc bpc" id="L512" title="1 of 2 branches missed.">      if (punctWhitespacePattern.matcher(word).matches()) {</span>
<span class="nc" id="L513">        word = &quot;&quot;;</span>
      }
    }
<span class="fc" id="L516">    word = whitespacePattern.matcher(word).replaceAll(&quot;&quot;);</span>
<span class="fc" id="L517">    return word;</span>
  }

  public Phrase lookup(String phrase)
  {
<span class="nc" id="L522">    return lookup(toWordList(phrase));</span>
  }

  public Phrase lookupNormalized(String phrase)
  {
<span class="fc" id="L527">    return lookup(toNormalizedWordList(phrase));</span>
  }

  public Phrase lookup(WordList wordList)
  {
<span class="pc bpc" id="L532" title="2 of 4 branches missed.">    if (wordList == null || rootTree == null) return null;</span>
<span class="fc" id="L533">    Map&lt;String,Object&gt; tree = rootTree;</span>
<span class="fc bfc" id="L534" title="All 2 branches covered.">    for (int i = 0; i &lt; wordList.size(); i++) {</span>
<span class="fc" id="L535">      String word = wordList.getWord(i);</span>
<span class="fc" id="L536">      Object node = tree.get(word);</span>
<span class="pc bpc" id="L537" title="1 of 2 branches missed.">      if (node == null) {</span>
<span class="nc" id="L538">        return null;</span>
<span class="pc bpc" id="L539" title="1 of 2 branches missed.">      } else if (node instanceof Phrase) {</span>
<span class="nc" id="L540">        Phrase phrase = (Phrase) node;</span>
<span class="nc" id="L541">        int matchedTokenEnd = checkWordListMatch(</span>
<span class="nc" id="L542">          phrase, wordList, 0, wordList.size(), i, true);</span>

<span class="nc bnc" id="L544" title="All 2 branches missed.">        if (matchedTokenEnd &gt;= 0) {</span>
<span class="nc" id="L545">          return phrase;</span>
        }
<span class="pc bpc" id="L547" title="1 of 2 branches missed.">      } else if (node instanceof Map) {</span>
<span class="fc" id="L548">        tree = (Map&lt;String, Object&gt;) node;</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">      } else if (node instanceof List) {</span>
        // Search through list for matches to word (at this point, the table is small, so no Map)
<span class="nc" id="L551">        List lookupList = (List) node;</span>
<span class="nc" id="L552">        int nMaps = 0;</span>
<span class="nc bnc" id="L553" title="All 2 branches missed.">        for (Object obj:lookupList) {</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">          if (obj instanceof Phrase) {</span>
            // check rest of the phrase matches
<span class="nc" id="L556">            Phrase phrase = (Phrase) obj;</span>
<span class="nc" id="L557">            int matchedTokenEnd = checkWordListMatch(</span>
<span class="nc" id="L558">              phrase, wordList, 0, wordList.size(), i, true);</span>

<span class="nc bnc" id="L560" title="All 2 branches missed.">            if (matchedTokenEnd &gt;= 0) {</span>
<span class="nc" id="L561">              return phrase;</span>
            }
<span class="nc bnc" id="L563" title="All 2 branches missed.">          } else if (obj instanceof Map) {</span>
<span class="nc bnc" id="L564" title="All 2 branches missed.">            if (nMaps == 1) {</span>
<span class="nc" id="L565">              throw new RuntimeException(&quot;More than one map in list while looking up word &quot;</span>
<span class="nc" id="L566">                      + i + &quot;(&quot; + word + &quot;) in phrase &quot; + wordList.toString());</span>
            }
<span class="nc" id="L568">            tree = (Map&lt;String, Object&gt;) obj;</span>
<span class="nc" id="L569">            nMaps++;</span>
          } else  {
<span class="nc" id="L571">            throw new RuntimeException(&quot;Unexpected class in list &quot; + obj.getClass() + &quot; while looking up word &quot;</span>
<span class="nc" id="L572">                    + i + &quot;(&quot; + word + &quot;) in phrase &quot; + wordList.toString());</span>
          }
<span class="nc" id="L574">        }</span>
<span class="nc bnc" id="L575" title="All 2 branches missed.">        if (nMaps == 0) {</span>
<span class="nc" id="L576">          return null;</span>
        }
<span class="nc" id="L578">      } else {</span>
<span class="nc" id="L579">        throw new RuntimeException(&quot;Unexpected class in list &quot; + node.getClass() + &quot; while looking up word &quot;</span>
<span class="nc" id="L580">                + i + &quot;(&quot; + word + &quot;) in phrase &quot; + wordList.toString());</span>
      }
    }
<span class="fc" id="L583">    Phrase phrase = (Phrase) tree.get(PHRASE_END);</span>
<span class="pc bpc" id="L584" title="1 of 2 branches missed.">    if (phrase != null) {</span>
<span class="fc" id="L585">      int matchedTokenEnd = checkWordListMatch(</span>
<span class="fc" id="L586">        phrase, wordList, 0, wordList.size(), wordList.size(), true);</span>
<span class="pc bpc" id="L587" title="1 of 2 branches missed.">      return (matchedTokenEnd &gt;= 0)? phrase:null;</span>
    } else {
<span class="nc" id="L589">      return null;</span>
    }
  }

  /**
   * Given a segment of text, returns list of spans (PhraseMatch) that corresponds
   *  to a phrase in the table
   * @param text Input text to search over
   * @return List of all matched spans
   */
  public List&lt;PhraseMatch&gt; findAllMatches(String text)
  {
<span class="fc" id="L601">    WordList tokens = toNormalizedWordList(text);</span>
<span class="fc" id="L602">    return findAllMatches(tokens, 0, tokens.size(), false);</span>
  }

  /**
   * Given a list of tokens, returns list of spans (PhraseMatch) that corresponds
   *  to a phrase in the table
   * @param tokens List of tokens to search over
   * @return List of all matched spans
   */
  public List&lt;PhraseMatch&gt; findAllMatches(WordList tokens)
  {
<span class="nc" id="L613">    return findAllMatches(tokens, 0, tokens.size(), true);</span>
  }

  /**
   * Given a segment of text, returns list of spans (PhraseMatch) that corresponds
   *  to a phrase in the table (filtered by the list of acceptable phrase)
   * @param acceptablePhrases - What phrases to look for (need to be subset of phrases already in table)
   * @param text Input text to search over
   * @return List of all matched spans
   */
  public List&lt;PhraseMatch&gt; findAllMatches(List&lt;Phrase&gt; acceptablePhrases, String text)
  {
<span class="nc" id="L625">    WordList tokens = toNormalizedWordList(text);</span>
<span class="nc" id="L626">    return findAllMatches(acceptablePhrases, tokens, 0, tokens.size(), false);</span>
  }

  /**
   * Given a list of tokens, returns list of spans (PhraseMatch) that corresponds
   *  to a phrase in the table (filtered by the list of acceptable phrase)
   * @param acceptablePhrases - What phrases to look for (need to be subset of phrases already in table)
   * @param tokens List of tokens to search over
   * @return List of all matched spans
   */
  public List&lt;PhraseMatch&gt; findAllMatches(List&lt;Phrase&gt; acceptablePhrases, WordList tokens)
  {
<span class="nc" id="L638">    return findAllMatches(acceptablePhrases, tokens, 0, tokens.size(), true);</span>
  }

  public List&lt;PhraseMatch&gt; findAllMatches(WordList tokens,
                                          int tokenStart, int tokenEnd,
                                          boolean needNormalization)
  {
<span class="fc" id="L645">    return findMatches(null, tokens, tokenStart, tokenEnd,</span>
            needNormalization,
            true /* find all */,
            false /* don't need to match end exactly */);
  }

  public List&lt;PhraseMatch&gt; findAllMatches(List&lt;Phrase&gt; acceptablePhrases,
                                          WordList tokens,
                                          int tokenStart, int tokenEnd,
                                          boolean needNormalization)
  {
<span class="nc" id="L656">    return findMatches(acceptablePhrases, tokens, tokenStart, tokenEnd,</span>
            needNormalization,
            true /* find all */,
            false /* don't need to match end exactly */);
  }

  public List&lt;PhraseMatch&gt; findMatches(String text)
  {
<span class="nc" id="L664">    WordList tokens = toNormalizedWordList(text);</span>
<span class="nc" id="L665">    return findMatches(tokens, 0, tokens.size(), false);</span>
  }

  public List&lt;PhraseMatch&gt; findMatches(WordList tokens)
  {
<span class="nc" id="L670">    return findMatches(tokens, 0, tokens.size(), true);</span>
  }

  public List&lt;PhraseMatch&gt; findMatches(WordList tokens,
                                       int tokenStart, int tokenEnd,
                                       boolean needNormalization)
  {
<span class="fc" id="L677">    return findMatches(null, tokens, tokenStart, tokenEnd,</span>
            needNormalization,
            false /* don't need to find all */,
            false /* don't need to match end exactly */);
  }

  public List&lt;PhraseMatch&gt; findMatches(String text,
                                       int tokenStart, int tokenEnd,
                                       boolean needNormalization)
  {
<span class="fc" id="L687">    WordList tokens = toNormalizedWordList(text);</span>
<span class="fc" id="L688">    return findMatches(tokens, tokenStart, tokenEnd, false);</span>
  }

  protected int checkWordListMatch(Phrase phrase, WordList tokens,
                                   int tokenStart, int tokenEnd,
                                   int checkStart,
                                   boolean matchEnd)
  {
<span class="pc bpc" id="L696" title="1 of 2 branches missed.">    if (checkStart &lt; tokenStart) return -1;</span>
    int i;
<span class="fc" id="L698">    int phraseSize = phrase.wordList.size();</span>
<span class="fc bfc" id="L699" title="All 4 branches covered.">    for (i = checkStart; i &lt; tokenEnd &amp;&amp; i - tokenStart &lt; phraseSize; i++) {</span>
<span class="fc" id="L700">      String word = tokens.getWord(i);</span>
<span class="fc" id="L701">      String phraseWord = phrase.wordList.getWord(i - tokenStart);</span>
<span class="fc bfc" id="L702" title="All 2 branches covered.">      if (!phraseWord.equals(word)) {</span>
<span class="fc" id="L703">        return -1;</span>
      }
    }
<span class="pc bpc" id="L706" title="1 of 2 branches missed.">    if (i - tokenStart == phraseSize) {</span>
      // All tokens in phrase has been matched!
<span class="fc bfc" id="L708" title="All 2 branches covered.">      if (matchEnd) {</span>
<span class="fc bfc" id="L709" title="All 2 branches covered.">        return (i == tokenEnd)? i:-1;</span>
      } else {
<span class="fc" id="L711">        return i;</span>
      }
    } else {
<span class="nc" id="L714">      return -1;</span>
    }
  }

  public List&lt;PhraseMatch&gt; findNonOverlappingPhrases(List&lt;PhraseMatch&gt; phraseMatches)
  {
<span class="nc bnc" id="L720" title="All 2 branches missed.">    if (phraseMatches.size() &gt; 1) {</span>
<span class="nc" id="L721">      return IntervalTree.getNonOverlapping(phraseMatches, PHRASEMATCH_LENGTH_ENDPOINTS_COMPARATOR);</span>
    } else {
<span class="nc" id="L723">      return phraseMatches;</span>
    }
  }

  protected List&lt;PhraseMatch&gt; findMatches(Collection&lt;Phrase&gt; acceptablePhrases,
                                          WordList tokens, int tokenStart, int tokenEnd,
                                          boolean needNormalization, boolean findAll, boolean matchEnd)
  {
<span class="pc bpc" id="L731" title="1 of 2 branches missed.">    if (needNormalization) {</span>
<span class="nc bnc" id="L732" title="All 4 branches missed.">      assert(tokenStart &gt;= 0);</span>
<span class="nc bnc" id="L733" title="All 4 branches missed.">      assert(tokenEnd &gt; tokenStart);</span>
<span class="nc" id="L734">      int n = tokenEnd - tokenStart;</span>
<span class="nc" id="L735">      List&lt;String&gt; normalized = new ArrayList&lt;&gt;(n);</span>
<span class="nc" id="L736">      int[] tokenIndexMap = new int[n+1];</span>
<span class="nc" id="L737">      int j = 0, last = 0;</span>
<span class="nc bnc" id="L738" title="All 2 branches missed.">      for (int i = tokenStart; i &lt; tokenEnd; i++) {</span>
<span class="nc" id="L739">        String word = tokens.getWord(i);</span>
<span class="nc" id="L740">        word = getNormalizedForm(word);</span>
<span class="nc bnc" id="L741" title="All 2 branches missed.">        if (word.length() != 0) {</span>
<span class="nc" id="L742">          normalized.add(word);</span>
<span class="nc" id="L743">          tokenIndexMap[j] = i;</span>
<span class="nc" id="L744">          last = i;</span>
<span class="nc" id="L745">          j++;</span>
        }
      }
<span class="nc" id="L748">      tokenIndexMap[j] = Math.min(last+1, tokenEnd);</span>
<span class="nc" id="L749">      List&lt;PhraseMatch&gt; matched = findMatchesNormalized(acceptablePhrases, new StringList(normalized),</span>
<span class="nc" id="L750">              0, normalized.size(), findAll, matchEnd);</span>
<span class="nc bnc" id="L751" title="All 2 branches missed.">      for (PhraseMatch pm:matched) {</span>
<span class="nc bnc" id="L752" title="All 4 branches missed.">        assert(pm.tokenBegin &gt;= 0);</span>
<span class="nc bnc" id="L753" title="All 4 branches missed.">        assert(pm.tokenEnd &gt;= pm.tokenBegin);</span>
<span class="nc bnc" id="L754" title="All 4 branches missed.">        assert(pm.tokenEnd &lt;= normalized.size());</span>
<span class="nc bnc" id="L755" title="All 4 branches missed.">        if (pm.tokenEnd &gt; 0 &amp;&amp; pm.tokenEnd &gt; pm.tokenBegin) {</span>
<span class="nc" id="L756">          pm.tokenEnd = tokenIndexMap[pm.tokenEnd-1]+1;</span>
        } else {
<span class="nc" id="L758">          pm.tokenEnd = tokenIndexMap[pm.tokenEnd];</span>
        }
<span class="nc" id="L760">        pm.tokenBegin = tokenIndexMap[pm.tokenBegin];</span>
<span class="nc bnc" id="L761" title="All 4 branches missed.">        assert(pm.tokenBegin &gt;= 0);</span>
<span class="nc bnc" id="L762" title="All 4 branches missed.">        assert(pm.tokenEnd &gt;= pm.tokenBegin);</span>
<span class="nc" id="L763">      }</span>
<span class="nc" id="L764">      return matched;</span>
    } else {
<span class="fc" id="L766">      return findMatchesNormalized(acceptablePhrases, tokens, tokenStart, tokenEnd, findAll, matchEnd);</span>
    }
  }

  protected List&lt;PhraseMatch&gt; findMatchesNormalized(Collection&lt;Phrase&gt; acceptablePhrases,
                                                    WordList tokens, int tokenStart, int tokenEnd,
                                                    boolean findAll, boolean matchEnd)
  {
<span class="fc" id="L774">    List&lt;PhraseMatch&gt; matched = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L775">    Stack&lt;StackEntry&gt; todoStack = new Stack&lt;&gt;();</span>
<span class="fc bfc" id="L776" title="All 2 branches covered.">    todoStack.push(new StackEntry(rootTree, tokenStart, tokenStart, tokenEnd, findAll? tokenStart+1:-1));</span>
<span class="fc bfc" id="L777" title="All 2 branches covered.">    while (!todoStack.isEmpty()) {</span>
<span class="fc" id="L778">      StackEntry cur = todoStack.pop();</span>
<span class="fc" id="L779">      Map&lt;String, Object&gt; tree = cur.tree;</span>
<span class="pc bpc" id="L780" title="1 of 2 branches missed.">      for (int i = cur.tokenNext; i &lt;= cur.tokenEnd; i++) {</span>
<span class="fc bfc" id="L781" title="All 2 branches covered.">        if (tree.containsKey(PHRASE_END)) {</span>
<span class="fc" id="L782">          Phrase phrase = (Phrase) tree.get(PHRASE_END);</span>
<span class="pc bpc" id="L783" title="3 of 4 branches missed.">          if (acceptablePhrases == null || acceptablePhrases.contains(phrase)) {</span>
<span class="fc" id="L784">            int matchedTokenEnd = checkWordListMatch(</span>
              phrase, tokens, cur.tokenStart, cur.tokenEnd, i, matchEnd);
<span class="pc bpc" id="L786" title="1 of 2 branches missed.">            if (matchedTokenEnd &gt;= 0) {</span>
<span class="fc" id="L787">              matched.add(new PhraseMatch(phrase, cur.tokenStart, matchedTokenEnd));</span>
            }
          }
        }
<span class="pc bpc" id="L791" title="1 of 2 branches missed.">        if (i == cur.tokenEnd) break;</span>
<span class="fc" id="L792">        String word = tokens.getWord(i);</span>
<span class="fc" id="L793">        Object node = tree.get(word);</span>
<span class="fc bfc" id="L794" title="All 2 branches covered.">        if (node == null) {</span>
<span class="fc" id="L795">          break;</span>
<span class="fc bfc" id="L796" title="All 2 branches covered.">        } else if (node instanceof Phrase) {</span>
          // check rest of the phrase matches
<span class="fc" id="L798">          Phrase phrase = (Phrase) node;</span>
<span class="pc bpc" id="L799" title="3 of 4 branches missed.">          if (acceptablePhrases == null || acceptablePhrases.contains(phrase)) {</span>
<span class="fc" id="L800">            int matchedTokenEnd = checkWordListMatch(</span>
              phrase, tokens, cur.tokenStart, cur.tokenEnd, i+1, matchEnd);
<span class="fc bfc" id="L802" title="All 2 branches covered.">            if (matchedTokenEnd &gt;= 0) {</span>
<span class="fc" id="L803">              matched.add(new PhraseMatch(phrase, cur.tokenStart, matchedTokenEnd));</span>
            }
<span class="fc" id="L805">          }</span>
          break;
<span class="pc bpc" id="L807" title="1 of 2 branches missed.">        } else if (node instanceof Map) {</span>
<span class="fc" id="L808">          tree = (Map&lt;String, Object&gt;) node;</span>
<span class="nc bnc" id="L809" title="All 2 branches missed.">        } else if (node instanceof List) {</span>
          // Search through list for matches to word (at this point, the table is small, so no Map)
<span class="nc" id="L811">          List lookupList = (List) node;</span>
<span class="nc bnc" id="L812" title="All 2 branches missed.">          for (Object obj:lookupList) {</span>
<span class="nc bnc" id="L813" title="All 2 branches missed.">            if (obj instanceof Phrase) {</span>
              // check rest of the phrase matches
<span class="nc" id="L815">              Phrase phrase = (Phrase) obj;</span>
<span class="nc bnc" id="L816" title="All 4 branches missed.">              if (acceptablePhrases == null || acceptablePhrases.contains(phrase)) {</span>
<span class="nc" id="L817">                int matchedTokenEnd = checkWordListMatch(</span>
                  phrase, tokens, cur.tokenStart, cur.tokenEnd, i+1, matchEnd);
<span class="nc bnc" id="L819" title="All 2 branches missed.">                if (matchedTokenEnd &gt;= 0) {</span>
<span class="nc" id="L820">                  matched.add(new PhraseMatch(phrase, cur.tokenStart, matchedTokenEnd));</span>
                }
              }
<span class="nc bnc" id="L823" title="All 2 branches missed.">            } else if (obj instanceof Map) {</span>
<span class="nc" id="L824">              todoStack.push(new StackEntry((Map&lt;String,Object&gt;) obj, cur.tokenStart, i+1, cur.tokenEnd, -1));</span>
            } else  {
<span class="nc" id="L826">              throw new RuntimeException(&quot;Unexpected class in list &quot; + obj.getClass() + &quot; while looking up &quot; + word);</span>
            }
<span class="nc" id="L828">          }</span>
<span class="nc" id="L829">          break;</span>
        } else {
<span class="nc" id="L831">          throw new RuntimeException(&quot;Unexpected class &quot; + node.getClass() + &quot; while looking up &quot; + word);</span>
        }
      }
<span class="fc bfc" id="L834" title="All 2 branches covered.">      if (cur.continueAt &gt;= 0) {</span>
<span class="pc bpc" id="L835" title="1 of 2 branches missed.">        int newStart = (cur.continueAt &gt; cur.tokenStart)? cur.continueAt: cur.tokenStart+1;</span>
<span class="fc bfc" id="L836" title="All 2 branches covered.">        if (newStart &lt; cur.tokenEnd) {</span>
<span class="fc" id="L837">          todoStack.push(new StackEntry(cur.tree, newStart, newStart, cur.tokenEnd, newStart+1));</span>
        }
      }
<span class="fc" id="L840">    }</span>
<span class="fc" id="L841">    return matched;</span>
  }

  public Iterator&lt;Phrase&gt; iterator() {
<span class="fc" id="L845">    return new PhraseTableIterator(this);</span>
  }

  private static class PhraseTableIterator extends AbstractIterator&lt;Phrase&gt; {
    private PhraseTable phraseTable;
<span class="fc" id="L850">    private Stack&lt;Iterator&lt;Object&gt;&gt; iteratorStack = new Stack&lt;&gt;();</span>
<span class="fc" id="L851">    private Phrase next = null;</span>

<span class="fc" id="L853">    public PhraseTableIterator(PhraseTable phraseTable) {</span>
<span class="fc" id="L854">      this.phraseTable = phraseTable;</span>
<span class="fc" id="L855">      this.iteratorStack.push(this.phraseTable.rootTree.values().iterator());</span>
<span class="fc" id="L856">      this.next = getNext();</span>
<span class="fc" id="L857">    }</span>

    private Phrase getNext() {
<span class="fc bfc" id="L860" title="All 2 branches covered.">      while (!iteratorStack.isEmpty()) {</span>
<span class="fc" id="L861">        Iterator&lt;Object&gt; iter = iteratorStack.peek();</span>
<span class="fc bfc" id="L862" title="All 2 branches covered.">        if (iter.hasNext()) {</span>
<span class="fc" id="L863">          Object obj = iter.next();</span>
<span class="fc bfc" id="L864" title="All 2 branches covered.">          if (obj instanceof Phrase) {</span>
<span class="fc" id="L865">            return (Phrase) obj;</span>
<span class="pc bpc" id="L866" title="1 of 2 branches missed.">          } else if (obj instanceof Map) {</span>
<span class="fc" id="L867">            iteratorStack.push(((Map) obj).values().iterator());</span>
<span class="nc bnc" id="L868" title="All 2 branches missed.">          } else if (obj instanceof List) {</span>
<span class="nc" id="L869">            iteratorStack.push(((List) obj).iterator());</span>
          } else {
<span class="nc" id="L871">            throw new RuntimeException(&quot;Unexpected class in phrase table &quot; + obj.getClass());</span>
          }
<span class="fc" id="L873">        } else {</span>
<span class="fc" id="L874">          iteratorStack.pop();</span>
        }
<span class="fc" id="L876">      }</span>
<span class="fc" id="L877">      return null;</span>
    }

    @Override
    public boolean hasNext() {
<span class="fc bfc" id="L882" title="All 2 branches covered.">      return next != null;</span>
    }

    @Override
    public Phrase next() {
<span class="fc" id="L887">      Phrase res = next;</span>
<span class="fc" id="L888">      next = getNext();</span>
<span class="fc" id="L889">      return res;</span>
    }
  }

  private static class StackEntry
  {
    Map&lt;String, Object&gt; tree;
    int tokenStart;
    int tokenNext;
    int tokenEnd;
    int continueAt;

<span class="fc" id="L901">    private StackEntry(Map&lt;String, Object&gt; tree, int tokenStart, int tokenNext, int tokenEnd, int continueAt) {</span>
<span class="fc" id="L902">      this.tree = tree;</span>
<span class="fc" id="L903">      this.tokenStart = tokenStart;</span>
<span class="fc" id="L904">      this.tokenNext = tokenNext;</span>
<span class="fc" id="L905">      this.tokenEnd = tokenEnd;</span>
<span class="fc" id="L906">      this.continueAt = continueAt;</span>
<span class="fc" id="L907">    }</span>
  }

  /**
   * A phrase is a multiword expression
   */
  public static class Phrase
  {
    /**
     * List of words in this phrase
     */
    WordList wordList;
    String text;
    String tag;
    Object data; // additional data associated with the phrase

    // Alternate forms that can be used for lookup elsewhere
    private Set&lt;String&gt; alternateForms;

<span class="fc" id="L926">    public Phrase(WordList wordList, String text, String tag, Object data) {</span>
<span class="fc" id="L927">      this.wordList = wordList;</span>
<span class="fc" id="L928">      this.text = text;</span>
<span class="fc" id="L929">      this.tag = tag;</span>
<span class="fc" id="L930">      this.data = data;</span>
<span class="fc" id="L931">    }</span>

    public boolean isLonger(Phrase phrase)
    {
<span class="nc bnc" id="L935" title="All 2 branches missed.">      return (this.getWordList().size() &gt; phrase.getWordList().size()</span>
<span class="nc bnc" id="L936" title="All 2 branches missed.">             || (this.getWordList().size() == phrase.getWordList().size()</span>
<span class="nc bnc" id="L937" title="All 2 branches missed.">                 &amp;&amp; this.getText().length() &gt; phrase.getText().length()));</span>
    }

    public boolean addForm(String form) {
<span class="nc bnc" id="L941" title="All 2 branches missed.">      if (alternateForms == null) {</span>
<span class="nc" id="L942">        alternateForms = new HashSet&lt;&gt;(4);</span>
<span class="nc" id="L943">        alternateForms.add(text);</span>
      }
<span class="nc" id="L945">      return alternateForms.add(form);</span>
    }

    public WordList getWordList() {
<span class="nc" id="L949">      return wordList;</span>
    }

    public String getText() {
<span class="fc" id="L953">      return text;</span>
    }

    public String getTag() {
<span class="nc" id="L957">      return tag;</span>
    }

    public Object getData() {
<span class="nc" id="L961">      return data;</span>
    }

    public Collection&lt;String&gt; getAlternateForms() {
<span class="nc bnc" id="L965" title="All 2 branches missed.">      if (alternateForms == null) {</span>
<span class="nc" id="L966">        List&lt;String&gt; forms = new ArrayList(1);</span>
<span class="nc" id="L967">        forms.add(text);</span>
<span class="nc" id="L968">        return forms;</span>
      }
<span class="nc" id="L970">      return alternateForms;</span>
    }

    public String toString()
    {
<span class="nc" id="L975">      return text;</span>
    }
  }

<span class="fc" id="L979">  public final static Comparator&lt;PhraseMatch&gt; PHRASEMATCH_LENGTH_ENDPOINTS_COMPARATOR =</span>
<span class="fc" id="L980">          Comparators.chain(HasInterval.LENGTH_GT_COMPARATOR, HasInterval.ENDPOINTS_COMPARATOR);</span>

  /**
   * Represents a matched phrase
   */
  public static class PhraseMatch implements HasInterval&lt;Integer&gt;
  {
    Phrase phrase;
    int tokenBegin;
    int tokenEnd;
    transient Interval&lt;Integer&gt; span;

<span class="fc" id="L992">    public PhraseMatch(Phrase phrase, int tokenBegin, int tokenEnd) {</span>
<span class="fc" id="L993">      this.phrase = phrase;</span>
<span class="fc" id="L994">      this.tokenBegin = tokenBegin;</span>
<span class="fc" id="L995">      this.tokenEnd = tokenEnd;</span>
<span class="fc" id="L996">    }</span>

    public Phrase getPhrase() {
<span class="nc" id="L999">      return phrase;</span>
    }

    public int getTokenBegin() {
<span class="nc" id="L1003">      return tokenBegin;</span>
    }

    public int getTokenEnd() {
<span class="nc" id="L1007">      return tokenEnd;</span>
    }

    public String toString() {
<span class="nc" id="L1011">      StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L1012">      sb.append(phrase);</span>
<span class="nc" id="L1013">      sb.append(&quot; at (&quot;).append(tokenBegin);</span>
<span class="nc" id="L1014">      sb.append(&quot;,&quot;).append(tokenEnd).append(&quot;)&quot;);</span>
<span class="nc" id="L1015">      return sb.toString();</span>
    }

    public Interval&lt;Integer&gt; getInterval() {
<span class="nc bnc" id="L1019" title="All 2 branches missed.">      if (span == null) span = Interval.toInterval(tokenBegin, tokenEnd, Interval.INTERVAL_OPEN_END);</span>
<span class="nc" id="L1020">      return span;</span>
    }
  }

  public static String toString(WordList wordList)
  {
<span class="nc" id="L1026">    StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L1027" title="All 2 branches missed.">    for (int i = 0; i &lt; wordList.size(); i++) {</span>
<span class="nc bnc" id="L1028" title="All 2 branches missed.">      if (sb.length() &gt; 0) {</span>
<span class="nc" id="L1029">        sb.append(&quot; &quot;);</span>
      }
<span class="nc" id="L1031">      sb.append(wordList.getWord(i));</span>
    }
<span class="nc" id="L1033">    return sb.toString();</span>
  }

  public static interface WordList
  {
    String getWord(int i);
    int size();
  }

  public static class TokenList implements WordList
  {
    private List&lt;? extends CoreMap&gt; tokens;
<span class="nc" id="L1045">    private Class textKey = CoreAnnotations.TextAnnotation.class;</span>

<span class="nc" id="L1047">    public TokenList(List&lt;CoreLabel&gt; tokens) {</span>
<span class="nc" id="L1048">      this.tokens = tokens;</span>
<span class="nc" id="L1049">    }</span>

    public TokenList(List&lt;? extends CoreMap&gt; tokens, Class key)
<span class="nc" id="L1052">    {</span>
<span class="nc" id="L1053">      this.tokens = tokens;</span>
<span class="nc" id="L1054">      this.textKey = key;</span>
<span class="nc" id="L1055">    }</span>

    public String getWord(int i)
    {
<span class="nc" id="L1059">      return (String) tokens.get(i).get(textKey);</span>
    }

    public int size()
    {
<span class="nc" id="L1064">      return tokens.size();</span>
    }

    public String toString()
    {
<span class="nc" id="L1069">      return PhraseTable.toString(this);</span>
    }
  }

  public static class StringList implements WordList
  {
    private List&lt;String&gt; words;

<span class="fc" id="L1077">    public StringList(List&lt;String&gt; words) {</span>
<span class="fc" id="L1078">      this.words = words;</span>
<span class="fc" id="L1079">    }</span>

<span class="nc" id="L1081">    public StringList(String[] wordsArray) {</span>
<span class="nc" id="L1082">      this.words = Arrays.asList(wordsArray);</span>
<span class="nc" id="L1083">    }</span>

    public String getWord(int i) {
<span class="fc" id="L1086">      return words.get(i);</span>
    }

    public int size()
    {
<span class="fc" id="L1091">      return words.size();</span>
    }

    public String toString()
    {
<span class="nc" id="L1096">      return PhraseTable.toString(this);</span>
    }
  }

/*  public static class PhraseCollection implements Collection&lt;Phrase&gt;
  {

  } */

  public static class PhraseStringCollection implements Collection&lt;String&gt;
  {
    PhraseTable phraseTable;
    boolean useNormalizedLookup;

    public PhraseStringCollection(PhraseTable phraseTable, boolean useNormalizedLookup)
<span class="nc" id="L1111">    {</span>
<span class="nc" id="L1112">      this.phraseTable = phraseTable;</span>
<span class="nc" id="L1113">      this.useNormalizedLookup = useNormalizedLookup;</span>
<span class="nc" id="L1114">    }</span>

    public int size() {
<span class="nc" id="L1117">      return phraseTable.nStrings;</span>
    }

    public boolean isEmpty() {
<span class="nc bnc" id="L1121" title="All 2 branches missed.">      return phraseTable.nStrings == 0;</span>
    }

    public boolean contains(Object o) {
<span class="nc bnc" id="L1125" title="All 2 branches missed.">      if (o instanceof String) {</span>
<span class="nc bnc" id="L1126" title="All 2 branches missed.">        if (useNormalizedLookup) {</span>
<span class="nc bnc" id="L1127" title="All 2 branches missed.">          return (phraseTable.lookupNormalized((String) o) != null);</span>
        } else {
<span class="nc bnc" id="L1129" title="All 2 branches missed.">          return (phraseTable.lookup((String) o) != null);</span>
        }
      } else {
<span class="nc" id="L1132">        return false;</span>
      }
    }

    public Iterator&lt;String&gt; iterator() {
<span class="nc" id="L1137">      throw new UnsupportedOperationException(&quot;iterator is not supported for PhraseTable.PhraseStringCollection&quot;);</span>
//      return new FunctionApplyingIterator( phraseTable.iterator(), new Function&lt;Phrase,String&gt;() {
//        @Override
//        public String apply(Phrase in) {
//          return in.getText();
//        }
//      });
    }

    public Object[] toArray() {
<span class="nc" id="L1147">      throw new UnsupportedOperationException(&quot;toArray is not supported for PhraseTable.PhraseStringCollection&quot;);</span>
    }

    public &lt;T&gt; T[] toArray(T[] a) {
<span class="nc" id="L1151">      throw new UnsupportedOperationException(&quot;toArray is not supported for PhraseTable.PhraseStringCollection&quot;);</span>
    }

    public boolean add(String s) {
<span class="nc" id="L1155">      return phraseTable.addPhrase(s);</span>
    }

    public boolean remove(Object o) {
<span class="nc" id="L1159">      throw new UnsupportedOperationException(&quot;Remove is not supported for PhraseTable.PhraseStringCollection&quot;);</span>
    }

    public boolean containsAll(Collection&lt;?&gt; c) {
<span class="nc bnc" id="L1163" title="All 2 branches missed.">      for (Object o:c) {</span>
<span class="nc bnc" id="L1164" title="All 2 branches missed.">        if (!contains(o)) {</span>
<span class="nc" id="L1165">          return false;</span>
        }
<span class="nc" id="L1167">      }</span>
<span class="nc" id="L1168">      return true;</span>
    }

    public boolean addAll(Collection&lt;? extends String&gt; c) {
<span class="nc" id="L1172">      boolean modified = false;</span>
<span class="nc bnc" id="L1173" title="All 2 branches missed.">      for (String s:c) {</span>
<span class="nc bnc" id="L1174" title="All 2 branches missed.">        if (add(s)) {</span>
<span class="nc" id="L1175">          modified = true;</span>
        }
<span class="nc" id="L1177">      }</span>
<span class="nc" id="L1178">      return modified;</span>
    }

    public boolean removeAll(Collection&lt;?&gt; c) {
<span class="nc" id="L1182">      boolean modified = false;</span>
<span class="nc bnc" id="L1183" title="All 2 branches missed.">      for (Object o:c) {</span>
<span class="nc bnc" id="L1184" title="All 2 branches missed.">        if (remove(o)) {</span>
<span class="nc" id="L1185">          modified = true;</span>
        }
<span class="nc" id="L1187">      }</span>
<span class="nc" id="L1188">      return modified;</span>
    }

    public boolean retainAll(Collection&lt;?&gt; c) {
<span class="nc" id="L1192">      throw new UnsupportedOperationException(&quot;retainAll is not supported for PhraseTable.PhraseStringCollection&quot;);</span>
    }

    public void clear() {
<span class="nc" id="L1196">      phraseTable.clear();</span>
<span class="nc" id="L1197">    }</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>