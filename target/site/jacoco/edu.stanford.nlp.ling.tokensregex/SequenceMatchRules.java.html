<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SequenceMatchRules.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.ling.tokensregex</a> &gt; <span class="el_source">SequenceMatchRules.java</span></div><h1>SequenceMatchRules.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.ling.tokensregex;

import edu.stanford.nlp.ling.tokensregex.types.AssignableExpression;
import edu.stanford.nlp.ling.tokensregex.types.Expression;
import edu.stanford.nlp.ling.tokensregex.types.Expressions;
import edu.stanford.nlp.ling.tokensregex.types.Value;
import edu.stanford.nlp.util.*;

import java.io.Serializable;
import java.util.*;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.regex.MatchResult;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Rules for matching sequences using regular expressions
 * &lt;p&gt;
 * There are 2 types of rules:
 * &lt;ol&gt;
 * &lt;li&gt;&lt;b&gt;Assignment rules&lt;/b&gt; which assign a value to a variable for later use.
 * &lt;/li&gt;
 * &lt;li&gt;&lt;b&gt;Extraction rules&lt;/b&gt; which specifies how regular expression patterns are to be matched against text,
 *   which matched text expressions are to extracted, and what value to assign to the matched expression.&lt;/li&gt;
 * &lt;/ol&gt;
 * &lt;/p&gt;
 *
 * NOTE: {@code #} or {@code //} can be used to indicates one-line comments
 *
 * &lt;p&gt;&lt;b&gt;Assignment Rules&lt;/b&gt; are used to assign values to variables.
 *     The basic format is: {@code variable = value}
 * &lt;/p&gt;
 * &lt;p&gt;
 * &lt;em&gt;Variable Names&lt;/em&gt;:
 *   &lt;ul&gt;
 *     &lt;li&gt;Variable names should follow the pattern [A-Za-z_][A-Za-z0-9_]*&lt;/li&gt;
 *     &lt;li&gt;Variable names for use in regular expressions (to be expanded later) must start with {@code $}&lt;/li&gt;
 *   &lt;/ul&gt;
 * &lt;/p&gt;
 * &lt;p&gt;
 * &lt;em&gt;Value Types&lt;/em&gt;:
 * &lt;table&gt;
 *   &lt;tr&gt;&lt;th&gt;Type&lt;/th&gt;&lt;th&gt;Format&lt;/th&gt;&lt;th&gt;Example&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;{@code BOOLEAN}&lt;/td&gt;&lt;td&gt;{@code TRUE | FALSE}&lt;/td&gt;&lt;td&gt;{@code TRUE}&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;{@code STRING}&lt;/td&gt;&lt;td&gt;{@code &quot;...&quot;}&lt;/td&gt;&lt;td&gt;{@code &quot;red&quot;}&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;{@code INTEGER}&lt;/td&gt;&lt;td&gt;{@code [+-]\d+}&lt;/td&gt;&lt;td&gt;{@code 1500}&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;{@code LONG}&lt;/td&gt;&lt;td&gt;{@code [+-]\d+L}&lt;/td&gt;&lt;td&gt;{@code 1500000000000L}&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;{@code DOUBLE}&lt;/td&gt;&lt;td&gt;{@code [+-]\d*\.\d+}&lt;/td&gt;&lt;td&gt;{@code 6.98}&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;{@code REGEX}&lt;/td&gt;&lt;td&gt;{@code /.../}&lt;/td&gt;&lt;td&gt;{@code /[Aa]pril/}&lt;/td&gt;
 *       &lt;td&gt;String regular expression {@link Pattern}&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;{@code TOKENS_REGEX}&lt;/td&gt;&lt;td&gt;{@code ( [...] [...] ... ) }&lt;/td&gt;&lt;td&gt;{@code ( /up/ /to/ /4/ /months/ )}&lt;/td&gt;
 *       &lt;td&gt;Tokens regular expression {@link TokenSequencePattern}&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;{@code LIST}&lt;/td&gt;&lt;td&gt;{@code ( [item1] , [item2], ... )}&lt;/td&gt;&lt;td&gt;{@code (&quot;red&quot;, &quot;blue&quot;, &quot;yellow&quot; )}&lt;/td&gt;
 *       &lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;
 * &lt;/p&gt;
 * &lt;p&gt;
 * Some typical uses and examples for assignment rules include:
 * &lt;ol&gt;
 *  &lt;li&gt;Assignment of value to variables for use in later rules&lt;/li&gt;
 *  &lt;li&gt;Binding of text key to annotation key (as {@code Class}).
 *    &lt;pre&gt;
 *      tokens = { type: &quot;CLASS&quot;, value: &quot;edu.stanford.nlp.ling.CoreAnnotations$TokensAnnotation&quot; }
 *    &lt;/pre&gt;
 *  &lt;/li&gt;
 *  &lt;li&gt;Defining regular expressions macros to be embedded in other regular expressions
 *    &lt;pre&gt;
 *      $SEASON = &quot;/spring|summer|fall|autumn|winter/&quot;
 *      $NUM = ( [ { numcomptype:NUMBER } ] )
 *    &lt;/pre&gt;
 *  &lt;/li&gt;
 *  &lt;li&gt;Setting default environment variables.
 *      Rules are applied with respect to an environment ({@link Env}), which can be accessed using the variable {@code ENV}.
 *      Members of the Environment can be set as needed.
 *    &lt;pre&gt;
 *      # Set default parameters to be used when reading rules
 *      ENV.defaults[&quot;ruleType&quot;] = &quot;tokens&quot;
 *      # Set default string pattern flags (to case-insensitive)
 *      ENV.defaultStringPatternFlags = 2
 *      # Specifies that the result should go into the {@code tokens}  key (as defined above).
 *      ENV.defaultResultAnnotationKey = tokens
 *    &lt;/pre&gt;
 *  &lt;/li&gt;
 *  &lt;li&gt;Defining options&lt;/li&gt;
 * &lt;/ol&gt;
 * &lt;/p&gt;
 *
 * Predefined values are:
 * &lt;table&gt;
 *   &lt;tr&gt;&lt;th&gt;Variable&lt;/th&gt;&lt;th&gt;Type&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;{@code ENV}&lt;/td&gt;&lt;td&gt;{@link Env}&lt;/td&gt;&lt;td&gt;The environment with respect to which the rules are applied.&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;{@code TRUE}&lt;/td&gt;&lt;td&gt;{@code BOOLEAN}&lt;/td&gt;&lt;td&gt;The {@code Boolean}  value {@code true}.&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;{@code FALSE}&lt;/td&gt;&lt;td&gt;{@code BOOLEAN}&lt;/td&gt;&lt;td&gt;The {@code Boolean} value {@code false}.&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;{@code NIL}&lt;/td&gt;&lt;td&gt;{@code}&lt;/td&gt;&lt;td&gt;The {@code null} value.&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;{@code tags}&lt;/td&gt;&lt;td&gt;{@code Class}&lt;/td&gt;&lt;td&gt;The annotation key {@link edu.stanford.nlp.ling.tokensregex.types.Tags.TagsAnnotation}.&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;
 * &lt;/p&gt;

 * &lt;p&gt;&lt;b&gt;Extraction Rules&lt;/b&gt; specifies how regular expression patterns are to be matched against text.
 * See {@link CoreMapExpressionExtractor} for more information on the types of the rules, and in what sequence the rules are applied.
 * A basic rule can be specified using the following template:
 * &lt;pre&gt;{
 *        # Type of the rule
 *        ruleType: &quot;tokens&quot; | &quot;text&quot; | &quot;composite&quot; | &quot;filter&quot;,
 *        # Pattern to match against
 *        pattern: ( &amp;lt;TokenSequencePattern&amp;gt; ) | /&amp;lt;TextPattern&amp;gt;/,
 *        # Resulting value to go into the resulting annotation
 *        result: ...
 *
 *        # More fields following...
 *      }
 * &lt;/pre&gt;
 * Example:
 * &lt;pre&gt;
 *   {
 *     ruleType: &quot;tokens&quot;,
 *     pattern: ( /one/ ),
 *     result: 1
 *   }
 * &lt;/pre&gt;
 * &lt;/p&gt;
 * Extraction rule fields (most fields are optional):
 * &lt;table&gt;
 *   &lt;tr&gt;&lt;th&gt;Field&lt;/th&gt;&lt;th&gt;Values&lt;/th&gt;&lt;th&gt;Example&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;{@code ruleType}&lt;/td&gt;&lt;td&gt;{@code &quot;tokens&quot; | &quot;text&quot; | &quot;composite&quot; | &quot;filter&quot; }&lt;/td&gt;
 *      &lt;td&gt;{@code tokens}&lt;/td&gt;&lt;td&gt;Type of the rule (required).&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;{@code pattern}&lt;/td&gt;&lt;td&gt;{@code &lt;Token Sequence Pattern&gt; = (...) | &lt;Text Pattern&gt; = /.../}&lt;/td&gt;
 *      &lt;td&gt;{@code ( /winter/ /of/ $YEAR )}&lt;/td&gt;&lt;td&gt;Pattern to match against.
 *      See {@link TokenSequencePattern} and {@link Pattern} for
 *      how to specify patterns over tokens and strings (required).&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;{@code action}&lt;/td&gt;&lt;td&gt;{@code &lt;Action List&gt; = (...)}&lt;/td&gt;
 *      &lt;td&gt;{@code ( Annotate($0, ner, &quot;DATE&quot;) )}&lt;/td&gt;&lt;td&gt;List of actions to apply when the pattern is triggered.
 *      Each action is a {@link Expressions TokensRegex Expression}&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;{@code result}&lt;/td&gt;&lt;td&gt;{@code &lt;Expression&gt;}&lt;/td&gt;
 *      &lt;td&gt;{@code}&lt;/td&gt;&lt;td&gt;Resulting value to go into the resulting annotation.  See {@link Expressions} for how to specify the result.&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;{@code name}&lt;/td&gt;&lt;td&gt;{@code STRING}&lt;/td&gt;
 *      &lt;td&gt;{@code}&lt;/td&gt;&lt;td&gt;Name to identify the extraction rule.&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;{@code stage}&lt;/td&gt;&lt;td&gt;{@code INTEGER}&lt;/td&gt;
 *      &lt;td&gt;{@code}&lt;/td&gt;&lt;td&gt;Stage at which the rule is to be applied.  Rules are grouped in stages, which are applied from lowest to highest.&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;{@code active}&lt;/td&gt;&lt;td&gt;{@code Boolean}&lt;/td&gt;
 *      &lt;td&gt;{@code}&lt;/td&gt;&lt;td&gt;Whether this rule is enabled (active) or not (default true).&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;{@code priority}&lt;/td&gt;&lt;td&gt;{@code DOUBLE}&lt;/td&gt;
 *      &lt;td&gt;{@code}&lt;/td&gt;&lt;td&gt;Priority of rule.  Within a stage, matches from higher priority rules are preferred.&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;{@code weight}&lt;/td&gt;&lt;td&gt;{@code DOUBLE}&lt;/td&gt;
 *      &lt;td&gt;{@code}&lt;/td&gt;&lt;td&gt;Weight of rule (not currently used).&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;{@code over}&lt;/td&gt;&lt;td&gt;{@code CLASS}&lt;/td&gt;
 *      &lt;td&gt;{@code}&lt;/td&gt;&lt;td&gt;Annotation field to check pattern against.&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;{@code matchFindType}&lt;/td&gt;&lt;td&gt;{@code FIND_NONOVERLAPPING | FIND_ALL}&lt;/td&gt;
 *      &lt;td&gt;{@code}&lt;/td&gt;&lt;td&gt;Whether to find all matched expression or just the nonoverlapping ones (default {@code FIND_NONOVERLAPPING}).&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;{@code matchWithResults}&lt;/td&gt;&lt;td&gt;{@code Boolean}&lt;/td&gt;
 *      &lt;td&gt;{@code}&lt;/td&gt;&lt;td&gt;Whether results of the matches should be returned (default false).
 *        Set to true to access captured groups of embedded regular expressions.&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;{@code matchedExpressionGroup}&lt;/td&gt;&lt;td&gt;{@code Integer}&lt;/td&gt;
 *      &lt;td&gt;{@code 2}&lt;/td&gt;&lt;td&gt;What group should be treated as the matched expression group (default 0).&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;
 *
 * @author Angel Chang
 * @see CoreMapExpressionExtractor
 * @see TokenSequencePattern
 */
public class SequenceMatchRules {

<span class="nc" id="L164">  private SequenceMatchRules() { } // static class with inner classes</span>

  /** A sequence match rule */
  public interface Rule {
  }

  /**
   * Rule that specifies what value to assign to a variable
   */
  public static class AssignmentRule implements Rule {
    Expression expr;

<span class="nc" id="L176">    public AssignmentRule(AssignableExpression varExpr, Expression value) {</span>
<span class="nc" id="L177">      expr = varExpr.assign(value);</span>
<span class="nc" id="L178">    }</span>

    public void evaluate(Env env) {
<span class="nc" id="L181">      expr.evaluate(env);</span>
<span class="nc" id="L182">    }</span>
  }

  /**
   * Rule that specifies how to extract sequence of MatchedExpression from an annotation (CoreMap).
   * @param &lt;T&gt; Output type (MatchedExpression)
   */
<span class="nc" id="L189">  public static class AnnotationExtractRule&lt;S, T extends MatchedExpression&gt; implements Rule, ExtractRule&lt;S,T&gt;, Predicate&lt;T&gt;, Serializable {</span>

    private static final long serialVersionUID = -2148125332223720424L;

    /** Name of the rule */
    public String name;
    /** Stage in which this rule should be applied with respect to others */
<span class="nc" id="L196">    public int stage = 1;</span>
    /** Priority in which this rule should be applied with respect to others */
    public double priority;
    /** Weight given to the rule (how likely is this rule to fire) */
    public double weight;
    /** Annotation field to apply rule over: text or tokens or numerizedtokens */
    public Class annotationField;
    public Class tokensAnnotationField;
    /**  Annotation field(s) on individual tokens to put new annotation */
    public List&lt;Class&gt; tokensResultAnnotationField;
    /**  Annotation field(s) to put new annotation */
    public List&lt;Class&gt; resultAnnotationField;
    /** Annotation field for child/nested annotations */
    public Class resultNestedAnnotationField;
    public SequenceMatcher.FindType matchFindType;
    /** Which group to take as the matched expression - default is 0 */
    public int matchedExpressionGroup;
    public boolean matchWithResults;
    // TODO: Combine ruleType and isComposite
    /** Type of rule to apply: token string match, pattern string match */
    public String ruleType;
    public boolean isComposite;
<span class="nc" id="L218">    public boolean includeNested = true;  // TODO: Get parameter from somewhere....</span>
<span class="nc" id="L219">    public boolean active = true;</span>
    /** Actual rule performing the extraction (converting annotation to MatchedExpression) */
    public ExtractRule&lt;S, T&gt; extractRule;
    public Predicate&lt;T&gt; filterRule;
    /** Pattern - the type of which is dependent on the rule type */
    public Object pattern;
    public Expression result;

    public void update(Env env, Map&lt;String, Object&gt; attributes) {
<span class="nc bnc" id="L228" title="All 2 branches missed.">      for (Map.Entry&lt;String, Object&gt; stringObjectEntry : attributes.entrySet()) {</span>
<span class="nc" id="L229">        String key = stringObjectEntry.getKey();</span>
<span class="nc" id="L230">        Object obj = stringObjectEntry.getValue();</span>
<span class="nc bnc" id="L231" title="All 42 branches missed.">        switch (key) {</span>
          case &quot;name&quot;:
<span class="nc" id="L233">            name = (String) Expressions.asObject(env, obj);</span>
<span class="nc" id="L234">            break;</span>
          case &quot;priority&quot;:
<span class="nc" id="L236">            priority = ((Number) Expressions.asObject(env, obj)).doubleValue();</span>
<span class="nc" id="L237">            break;</span>
          case &quot;stage&quot;:
<span class="nc" id="L239">            stage = ((Number) Expressions.asObject(env, obj)).intValue();</span>
<span class="nc" id="L240">            break;</span>
          case &quot;weight&quot;:
<span class="nc" id="L242">            weight = ((Number) Expressions.asObject(env, obj)).doubleValue();</span>
<span class="nc" id="L243">            break;</span>
          case &quot;over&quot;:
<span class="nc" id="L245">            Object annoKey = Expressions.asObject(env, obj);</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">            if (annoKey instanceof Class) {</span>
<span class="nc" id="L247">              annotationField = (Class) annoKey;</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">            } else if (annoKey instanceof String) {</span>
<span class="nc" id="L249">              annotationField = EnvLookup.lookupAnnotationKeyWithClassname(env, (String) annoKey);</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">            } else if (annotationField == null) {</span>
<span class="nc" id="L251">              annotationField = CoreMap.class;</span>
            } else {
<span class="nc" id="L253">              throw new IllegalArgumentException(&quot;Invalid annotation key &quot; + annoKey);</span>
            }
            break;
          case &quot;active&quot;:
<span class="nc" id="L257">            active = (Boolean) Expressions.asObject(env, obj);</span>
<span class="nc" id="L258">            break;</span>
          case &quot;ruleType&quot;:
<span class="nc" id="L260">            ruleType = (String) Expressions.asObject(env, obj);</span>
<span class="nc" id="L261">            break;</span>
          case &quot;matchFindType&quot;:
<span class="nc" id="L263">            matchFindType = SequenceMatcher.FindType.valueOf((String) Expressions.asObject(env, obj));</span>
<span class="nc" id="L264">            break;</span>
          case &quot;matchWithResults&quot;:
<span class="nc" id="L266">            matchWithResults = ((Boolean) Expressions.asObject(env, obj)).booleanValue();</span>
<span class="nc" id="L267">            break;</span>
          case &quot;matchedExpressionGroup&quot;:
<span class="nc" id="L269">            matchedExpressionGroup = ((Number) Expressions.asObject(env, obj)).intValue();</span>
            break;
        }
<span class="nc" id="L272">      }</span>
<span class="nc" id="L273">    }</span>

    @Override
    public boolean extract(S in, List&lt;T&gt; out) {
<span class="nc" id="L277">      return extractRule.extract(in, out);</span>
    }

    @Override
    public boolean test(T obj) {
<span class="nc" id="L282">      return filterRule.test(obj);</span>
    }

    public boolean isMostlyCompatible(AnnotationExtractRule&lt;S, T&gt; aer) {
      // TODO: Check tokensResultAnnotationField, resultAnnotationField, resultNestedAnnotationField?
<span class="nc bnc" id="L287" title="All 2 branches missed.">      return (stage == aer.stage</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">        &amp;&amp; Objects.equals(annotationField, aer.annotationField)</span>
<span class="nc bnc" id="L289" title="All 8 branches missed.">        &amp;&amp; Objects.equals(tokensAnnotationField, aer.tokensAnnotationField)</span>
        &amp;&amp; matchedExpressionGroup == 0
        &amp;&amp; aer.matchedExpressionGroup == 0
        &amp;&amp; matchWithResults == aer.matchWithResults
<span class="nc bnc" id="L293" title="All 6 branches missed.">        &amp;&amp; Objects.equals(ruleType, aer.ruleType)</span>
        &amp;&amp; isComposite == aer.isComposite
        &amp;&amp; active == aer.active
<span class="nc bnc" id="L296" title="All 2 branches missed.">        &amp;&amp; Objects.equals(result, aer.result));</span>
    }

    public boolean hasTokensRegexPattern() {
<span class="nc bnc" id="L300" title="All 4 branches missed.">      return pattern != null &amp;&amp; pattern instanceof TokenSequencePattern;</span>
    }

<span class="nc" id="L303">    public String toString() { return getClass().getSimpleName() + '[' + pattern.toString() + ']'; }</span>

  } // end static class AnnotationExtractRule


  public static AssignmentRule createAssignmentRule(Env env, AssignableExpression var, Expression result) {
<span class="nc" id="L309">    AssignmentRule ar = new AssignmentRule(var, result);</span>
<span class="nc" id="L310">    ar.evaluate(env);</span>
<span class="nc" id="L311">    return ar;</span>
  }

  public static Rule createRule(Env env, Expressions.CompositeValue cv) {
    Map&lt;String, Object&gt; attributes;
<span class="nc" id="L316">    cv = cv.simplifyNoTypeConversion(env);</span>
<span class="nc" id="L317">    attributes = new HashMap&lt;&gt;();//Generics.newHashMap();</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">    for (String s:cv.getAttributes()) {</span>
<span class="nc" id="L319">      attributes.put(s, cv.getExpression(s));</span>
<span class="nc" id="L320">    }</span>
<span class="nc" id="L321">    return createExtractionRule(env, attributes);</span>
  }

  protected static AnnotationExtractRule createExtractionRule(Env env, Map&lt;String,Object&gt; attributes) {
<span class="nc" id="L325">    String ruleType = (String) Expressions.asObject(env, attributes.get(&quot;ruleType&quot;));</span>
<span class="nc bnc" id="L326" title="All 4 branches missed.">    if (ruleType == null &amp;&amp; env != null) {</span>
<span class="nc" id="L327">      ruleType = (String) env.getDefaults().get(&quot;ruleType&quot;);</span>
    }
<span class="nc" id="L329">    AnnotationExtractRuleCreator ruleCreator = lookupExtractRuleCreator(env, ruleType);</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">    if (ruleCreator != null) {</span>
<span class="nc" id="L331">      return ruleCreator.create(env, attributes);</span>
    } else {
<span class="nc" id="L333">      throw new IllegalArgumentException(&quot;Unknown rule type: &quot; + ruleType);</span>
    }
  }

  public static AnnotationExtractRule createExtractionRule(Env env, String ruleType, Object pattern, Expression result) {
<span class="nc bnc" id="L338" title="All 4 branches missed.">    if (ruleType == null &amp;&amp; env != null) {</span>
<span class="nc" id="L339">      ruleType = (String) env.getDefaults().get(&quot;ruleType&quot;);</span>
    }
<span class="nc" id="L341">    AnnotationExtractRuleCreator ruleCreator = lookupExtractRuleCreator(env, ruleType);</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">    if (ruleCreator != null) {</span>
<span class="nc" id="L343">      Map&lt;String,Object&gt; attributes = new HashMap&lt;&gt;();//Generics.newHashMap();</span>
<span class="nc" id="L344">      attributes.put(&quot;ruleType&quot;, ruleType);</span>
<span class="nc" id="L345">      attributes.put(&quot;pattern&quot;, pattern);</span>
<span class="nc" id="L346">      attributes.put(&quot;result&quot;, result);</span>
<span class="nc" id="L347">      return ruleCreator.create(env, attributes);</span>
    } else {
<span class="nc" id="L349">      throw new IllegalArgumentException(&quot;Unknown rule type: &quot; + ruleType);</span>
    }
  }

  public static final String COMPOSITE_RULE_TYPE = &quot;composite&quot;;
  public static final String TOKEN_PATTERN_RULE_TYPE = &quot;tokens&quot;;
  public static final String TEXT_PATTERN_RULE_TYPE = &quot;text&quot;;
  public static final String FILTER_RULE_TYPE = &quot;filter&quot;;
<span class="nc" id="L357">  public static final TokenPatternExtractRuleCreator TOKEN_PATTERN_EXTRACT_RULE_CREATOR = new TokenPatternExtractRuleCreator();</span>
<span class="nc" id="L358">  public static final CompositeExtractRuleCreator COMPOSITE_EXTRACT_RULE_CREATOR = new CompositeExtractRuleCreator();</span>
<span class="nc" id="L359">  public static final TextPatternExtractRuleCreator TEXT_PATTERN_EXTRACT_RULE_CREATOR = new TextPatternExtractRuleCreator();</span>
<span class="nc" id="L360">  public static final MultiTokenPatternExtractRuleCreator MULTI_TOKEN_PATTERN_EXTRACT_RULE_CREATOR = new MultiTokenPatternExtractRuleCreator();</span>
<span class="nc" id="L361">  public static final AnnotationExtractRuleCreator DEFAULT_EXTRACT_RULE_CREATOR = TOKEN_PATTERN_EXTRACT_RULE_CREATOR;</span>
<span class="nc" id="L362">  private static final Map&lt;String, AnnotationExtractRuleCreator&gt; registeredRuleTypes = new HashMap&lt;&gt;();//Generics.newHashMap();</span>
  static {
<span class="nc" id="L364">    registeredRuleTypes.put(TOKEN_PATTERN_RULE_TYPE, TOKEN_PATTERN_EXTRACT_RULE_CREATOR);</span>
<span class="nc" id="L365">    registeredRuleTypes.put(COMPOSITE_RULE_TYPE, COMPOSITE_EXTRACT_RULE_CREATOR);</span>
<span class="nc" id="L366">    registeredRuleTypes.put(TEXT_PATTERN_RULE_TYPE, TEXT_PATTERN_EXTRACT_RULE_CREATOR);</span>
<span class="nc" id="L367">    registeredRuleTypes.put(FILTER_RULE_TYPE, TOKEN_PATTERN_EXTRACT_RULE_CREATOR);</span>
<span class="nc" id="L368">  }</span>

  private static AnnotationExtractRuleCreator lookupExtractRuleCreator(Env env, String ruleType) {
<span class="nc bnc" id="L371" title="All 2 branches missed.">    if (env != null) {</span>
<span class="nc" id="L372">      Object obj = env.get(ruleType);</span>
<span class="nc bnc" id="L373" title="All 4 branches missed.">      if (obj != null &amp;&amp; obj instanceof AnnotationExtractRuleCreator) {</span>
<span class="nc" id="L374">        return (AnnotationExtractRuleCreator) obj;</span>
      }
    }
<span class="nc bnc" id="L377" title="All 2 branches missed.">    if (ruleType == null) {</span>
<span class="nc" id="L378">      return DEFAULT_EXTRACT_RULE_CREATOR;</span>
    } else {
<span class="nc" id="L380">      return registeredRuleTypes.get(ruleType);</span>
    }
  }

  public static AnnotationExtractRule createTokenPatternRule(Env env, SequencePattern.PatternExpr expr, Expression result) {
<span class="nc" id="L385">    return TOKEN_PATTERN_EXTRACT_RULE_CREATOR.create(env, expr, result);</span>
  }

  public static AnnotationExtractRule createTextPatternRule(Env env, String expr, Expression result) {
<span class="nc" id="L389">    return TEXT_PATTERN_EXTRACT_RULE_CREATOR.create(env, expr, result);</span>
  }

  public static AnnotationExtractRule createMultiTokenPatternRule(Env env, AnnotationExtractRule template, List&lt;TokenSequencePattern&gt; patterns) {
<span class="nc" id="L393">    return MULTI_TOKEN_PATTERN_EXTRACT_RULE_CREATOR.create(env, template, patterns);</span>
  }

<span class="nc" id="L396">  public static class AnnotationExtractRuleCreator {</span>
    public AnnotationExtractRule create(Env env) {
<span class="nc" id="L398">      AnnotationExtractRule r = new AnnotationExtractRule();</span>
<span class="nc" id="L399">      r.resultAnnotationField = EnvLookup.getDefaultResultAnnotationKey(env);</span>
<span class="nc" id="L400">      r.resultNestedAnnotationField = EnvLookup.getDefaultNestedResultsAnnotationKey(env);</span>
<span class="nc" id="L401">      r.tokensAnnotationField = EnvLookup.getDefaultTokensAnnotationKey(env);</span>
<span class="nc" id="L402">      r.tokensResultAnnotationField = EnvLookup.getDefaultTokensResultAnnotationKey(env);</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">      if (env != null) {</span>
<span class="nc" id="L404">        r.update(env, env.getDefaults());</span>
      }
<span class="nc" id="L406">      return r;</span>
    }

    public AnnotationExtractRule create(Env env, Map&lt;String,Object&gt; attributes) {
      // Get default annotation extract rule from env
<span class="nc" id="L411">      AnnotationExtractRule r = create(env);</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">      if (attributes != null) {</span>
<span class="nc" id="L413">        r.update(env, attributes);</span>
      }
<span class="nc" id="L415">      return r;</span>
    }
  }

  public static MatchedExpression.SingleAnnotationExtractor createAnnotationExtractor(Env env, AnnotationExtractRule r) {
<span class="nc" id="L420">    MatchedExpression.SingleAnnotationExtractor extractor = new MatchedExpression.SingleAnnotationExtractor();</span>
<span class="nc" id="L421">    extractor.name = r.name;</span>
<span class="nc" id="L422">    extractor.tokensAnnotationField = r.tokensAnnotationField;</span>
<span class="nc" id="L423">    extractor.tokensResultAnnotationField = r.tokensResultAnnotationField;</span>
<span class="nc" id="L424">    extractor.resultAnnotationField = r.resultAnnotationField;</span>
<span class="nc" id="L425">    extractor.resultNestedAnnotationField = r.resultNestedAnnotationField;</span>
<span class="nc" id="L426">    extractor.priority = r.priority;</span>
<span class="nc" id="L427">    extractor.weight = r.weight;</span>
<span class="nc" id="L428">    extractor.includeNested = r.includeNested;</span>
<span class="nc" id="L429">    extractor.resultAnnotationExtractor = EnvLookup.getDefaultResultAnnotationExtractor(env);</span>
<span class="nc" id="L430">    extractor.tokensAggregator = EnvLookup.getDefaultTokensAggregator(env);</span>
<span class="nc" id="L431">    return extractor;</span>
  }


<span class="nc" id="L435">  public static class CompositeExtractRuleCreator extends AnnotationExtractRuleCreator {</span>

    protected static void updateExtractRule(AnnotationExtractRule r,
                                     Env env,
                                     SequencePattern.PatternExpr expr,
                                     Expression action,
                                     Expression result) {
<span class="nc" id="L442">      TokenSequencePattern pattern = TokenSequencePattern.compile(expr);</span>
<span class="nc" id="L443">      updateExtractRule(r, env, pattern, action, result);</span>
<span class="nc" id="L444">    }</span>

    protected static void updateExtractRule(AnnotationExtractRule r,
                                     Env env,
                                     TokenSequencePattern pattern,
                                     Expression action,
                                     Expression result) {
<span class="nc" id="L451">      MatchedExpression.SingleAnnotationExtractor annotationExtractor = createAnnotationExtractor(env, r);</span>
<span class="nc" id="L452">      SequenceMatchResultExtractor&lt;CoreMap&gt; valueExtractor = new SequenceMatchResultExtractor&lt;&gt;(env, action, result);</span>
<span class="nc" id="L453">      SequencePatternExtractRule&lt;CoreMap,Value&gt; valueExtractRule = new SequencePatternExtractRule&lt;&gt;(pattern, valueExtractor, r.matchFindType, r.matchWithResults);</span>
<span class="nc" id="L454">      SequenceMatchedExpressionExtractor exprExtractor = new SequenceMatchedExpressionExtractor( annotationExtractor, r.matchedExpressionGroup );</span>
<span class="nc" id="L455">      SequencePatternExtractRule&lt;CoreMap, MatchedExpression&gt; exprExtractRule =</span>
        new SequencePatternExtractRule&lt;&gt;(pattern, exprExtractor, r.matchFindType, r.matchWithResults);

<span class="nc" id="L458">      annotationExtractor.expressionToValue = matched -&gt; {</span>
<span class="nc bnc" id="L459" title="All 6 branches missed.">        if (matched != null &amp;&amp; matched.context != null &amp;&amp; matched.context instanceof SequenceMatchResult ) {</span>
<span class="nc" id="L460">          return valueExtractor.apply( (SequenceMatchResult&lt;CoreMap&gt;) matched.context);</span>
<span class="nc" id="L461">        } else return null;</span>
      };
<span class="nc" id="L463">      annotationExtractor.valueExtractor = new CoreMapFunctionApplier&lt;&gt;(env, r.annotationField, valueExtractRule);</span>
<span class="nc" id="L464">      r.extractRule = exprExtractRule;</span>
<span class="nc" id="L465">      r.filterRule = new AnnotationMatchedFilter(annotationExtractor);</span>
<span class="nc" id="L466">      r.pattern = pattern;</span>
<span class="nc" id="L467">      r.result = result;</span>
<span class="nc" id="L468">      pattern.weight = r.weight;</span>
<span class="nc" id="L469">      pattern.priority = r.priority;</span>
<span class="nc" id="L470">    }</span>

    protected AnnotationExtractRule create(Env env, SequencePattern.PatternExpr expr, Expression result) {
<span class="nc" id="L473">      AnnotationExtractRule r = super.create(env, null);</span>
<span class="nc" id="L474">      r.isComposite = true;</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">      if (r.annotationField == null) { r.annotationField = r.resultNestedAnnotationField;  }</span>
<span class="nc bnc" id="L476" title="All 2 branches missed.">      if (r.annotationField == null) { throw new IllegalArgumentException(&quot;Error creating composite rule: no annotation field&quot;); }</span>
<span class="nc" id="L477">      r.ruleType = TOKEN_PATTERN_RULE_TYPE;</span>
<span class="nc" id="L478">      updateExtractRule(r, env, expr, null, result);</span>
<span class="nc" id="L479">      return r;</span>
    }

    @Override
    public AnnotationExtractRule create(Env env, Map&lt;String,Object&gt; attributes) {
<span class="nc" id="L484">      AnnotationExtractRule r = super.create(env, attributes);</span>
<span class="nc" id="L485">      r.isComposite = true;</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">      if (r.annotationField == null) { r.annotationField = r.resultNestedAnnotationField;  }</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">      if (r.annotationField == null) { throw new IllegalArgumentException(&quot;Error creating composite rule: no annotation field&quot;); }</span>
<span class="nc bnc" id="L488" title="All 2 branches missed.">      if (r.ruleType == null) { r.ruleType = TOKEN_PATTERN_RULE_TYPE; }</span>
      //SequencePattern.PatternExpr expr = (SequencePattern.PatternExpr) attributes.get(&quot;pattern&quot;);
<span class="nc" id="L490">      TokenSequencePattern expr = (TokenSequencePattern) Expressions.asObject(env, attributes.get(&quot;pattern&quot;));</span>
<span class="nc" id="L491">      Expression action = Expressions.asExpression(env, attributes.get(&quot;action&quot;));</span>
<span class="nc" id="L492">      Expression result = Expressions.asExpression(env, attributes.get(&quot;result&quot;));</span>
<span class="nc" id="L493">      updateExtractRule(r, env, expr, action, result);</span>
<span class="nc" id="L494">      return r;</span>
    }

  }


<span class="nc" id="L500">  public static class TokenPatternExtractRuleCreator extends AnnotationExtractRuleCreator {</span>

    protected static void updateExtractRule(AnnotationExtractRule r,
                                     Env env,
                                     SequencePattern.PatternExpr expr,
                                     Expression action,
                                     Expression result)
    {
<span class="nc" id="L508">      TokenSequencePattern pattern = TokenSequencePattern.compile(expr);</span>
<span class="nc" id="L509">      updateExtractRule(r, env, pattern, action, result);</span>
<span class="nc" id="L510">    }</span>

    protected static void updateExtractRule(AnnotationExtractRule r,
                                     Env env,
                                     TokenSequencePattern pattern,
                                     Expression action,
                                     Expression result) {
<span class="nc" id="L517">      MatchedExpression.SingleAnnotationExtractor annotationExtractor = createAnnotationExtractor(env, r);</span>
<span class="nc" id="L518">      SequenceMatchResultExtractor&lt;CoreMap&gt; valueExtractor = new SequenceMatchResultExtractor&lt;&gt;(env, action, result);</span>
<span class="nc" id="L519">      SequencePatternExtractRule&lt;CoreMap,Value&gt; valueExtractRule = new SequencePatternExtractRule&lt;&gt;(pattern, valueExtractor, r.matchFindType, r.matchWithResults);</span>
<span class="nc" id="L520">      SequenceMatchedExpressionExtractor exprExtractor = new SequenceMatchedExpressionExtractor( annotationExtractor, r.matchedExpressionGroup );</span>
<span class="nc" id="L521">      SequencePatternExtractRule&lt;CoreMap, MatchedExpression&gt; exprExtractRule =</span>
        new SequencePatternExtractRule&lt;&gt;(pattern, exprExtractor, r.matchFindType, r.matchWithResults);

<span class="nc" id="L524">      annotationExtractor.expressionToValue = matched -&gt; {</span>
<span class="nc bnc" id="L525" title="All 6 branches missed.">        if (matched != null &amp;&amp; matched.context != null &amp;&amp; matched.context instanceof SequenceMatchResult ) {</span>
<span class="nc" id="L526">          return valueExtractor.apply( (SequenceMatchResult&lt;CoreMap&gt;) matched.context);</span>
<span class="nc" id="L527">        } else return null;</span>
      };
<span class="nc bnc" id="L529" title="All 4 branches missed.">      if (r.annotationField != null &amp;&amp; r.annotationField != CoreMap.class) {</span>
<span class="nc" id="L530">        annotationExtractor.valueExtractor = new CoreMapFunctionApplier&lt;&gt;(env, r.annotationField, valueExtractRule);</span>
<span class="nc" id="L531">        r.extractRule = new CoreMapExtractRule&lt;&gt;(env, r.annotationField, exprExtractRule);</span>
      } else {
<span class="nc" id="L533">        annotationExtractor.valueExtractor = new CoreMapToListFunctionApplier&lt;&gt;(env, valueExtractRule);</span>
<span class="nc" id="L534">        r.extractRule = new CoreMapToListExtractRule&lt;&gt;(exprExtractRule);</span>
      }
<span class="nc" id="L536">      r.filterRule = new AnnotationMatchedFilter(annotationExtractor);</span>
<span class="nc" id="L537">      r.pattern = pattern;</span>
<span class="nc" id="L538">      r.result = result;</span>
<span class="nc" id="L539">      pattern.weight = r.weight;</span>
<span class="nc" id="L540">      pattern.priority = r.priority;</span>
<span class="nc" id="L541">    }</span>

    protected AnnotationExtractRule create(Env env, SequencePattern.PatternExpr expr, Expression result) {
<span class="nc" id="L544">      AnnotationExtractRule r = super.create(env, null);</span>
<span class="nc bnc" id="L545" title="All 2 branches missed.">      if (r.annotationField == null) { r.annotationField = r.tokensAnnotationField;  }</span>
<span class="nc" id="L546">      r.ruleType = TOKEN_PATTERN_RULE_TYPE;</span>
<span class="nc" id="L547">      updateExtractRule(r, env, expr, null, result);</span>
<span class="nc" id="L548">      return r;</span>
    }

    @Override
    public AnnotationExtractRule create(Env env, Map&lt;String,Object&gt; attributes) {
<span class="nc" id="L553">      AnnotationExtractRule r = super.create(env, attributes);</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">      if (r.annotationField == null) { r.annotationField = r.tokensAnnotationField;  }</span>
<span class="nc bnc" id="L555" title="All 2 branches missed.">      if (r.ruleType == null) { r.ruleType = TOKEN_PATTERN_RULE_TYPE; }</span>
      //SequencePattern.PatternExpr expr = (SequencePattern.PatternExpr) attributes.get(&quot;pattern&quot;);
<span class="nc" id="L557">      TokenSequencePattern expr = (TokenSequencePattern) Expressions.asObject(env, attributes.get(&quot;pattern&quot;));</span>
<span class="nc" id="L558">      Expression action = Expressions.asExpression(env, attributes.get(&quot;action&quot;));</span>
<span class="nc" id="L559">      Expression result = Expressions.asExpression(env, attributes.get(&quot;result&quot;));</span>
<span class="nc" id="L560">      updateExtractRule(r, env, expr, action, result);</span>
<span class="nc" id="L561">      return r;</span>
    }
  }


<span class="nc" id="L566">  public static class MultiTokenPatternExtractRuleCreator extends AnnotationExtractRuleCreator {</span>

    protected static void updateExtractRule(AnnotationExtractRule r,
                                     Env env,
                                     MultiPatternMatcher&lt;CoreMap&gt; pattern,
                                     Expression action,
                                     Expression result) {
<span class="nc" id="L573">      MatchedExpression.SingleAnnotationExtractor annotationExtractor = createAnnotationExtractor(env, r);</span>
<span class="nc" id="L574">      SequenceMatchResultExtractor&lt;CoreMap&gt; valueExtractor = new SequenceMatchResultExtractor&lt;&gt;(env, action, result);</span>
<span class="nc" id="L575">      MultiSequencePatternExtractRule&lt;CoreMap,Value&gt; valueExtractRule = new MultiSequencePatternExtractRule&lt;&gt;(pattern, valueExtractor);</span>
<span class="nc" id="L576">      SequenceMatchedExpressionExtractor exprExtractor = new SequenceMatchedExpressionExtractor( annotationExtractor, r.matchedExpressionGroup );</span>
<span class="nc" id="L577">      MultiSequencePatternExtractRule&lt;CoreMap, MatchedExpression&gt; exprExtractRule =</span>
        new MultiSequencePatternExtractRule&lt;&gt;(pattern, exprExtractor);

<span class="nc" id="L580">      annotationExtractor.expressionToValue = matched -&gt; {</span>
<span class="nc bnc" id="L581" title="All 6 branches missed.">        if (matched != null &amp;&amp; matched.context != null &amp;&amp; matched.context instanceof SequenceMatchResult ) {</span>
<span class="nc" id="L582">          return valueExtractor.apply( (SequenceMatchResult&lt;CoreMap&gt;) matched.context);</span>
<span class="nc" id="L583">        } else return null;</span>
      };
<span class="nc bnc" id="L585" title="All 4 branches missed.">      if (r.annotationField != null &amp;&amp; r.annotationField != CoreMap.class) {</span>
<span class="nc" id="L586">        annotationExtractor.valueExtractor = new CoreMapFunctionApplier&lt;&gt;(env, r.annotationField, valueExtractRule);</span>
<span class="nc" id="L587">        r.extractRule = new CoreMapExtractRule&lt;&gt;(env, r.annotationField, exprExtractRule);</span>
      } else {
<span class="nc" id="L589">        annotationExtractor.valueExtractor = new CoreMapToListFunctionApplier&lt;&gt;(env, valueExtractRule);</span>
<span class="nc" id="L590">        r.extractRule = new CoreMapToListExtractRule&lt;&gt;(exprExtractRule);</span>
      }
<span class="nc" id="L592">      r.filterRule = new AnnotationMatchedFilter(annotationExtractor);</span>
<span class="nc" id="L593">      r.pattern = pattern;</span>
<span class="nc" id="L594">      r.result = result;</span>
<span class="nc" id="L595">    }</span>

    protected static AnnotationExtractRule create(Env env, SequenceMatchRules.AnnotationExtractRule aerTemplate, List&lt;TokenSequencePattern&gt; patterns) {
<span class="nc" id="L598">      AnnotationExtractRule r = new AnnotationExtractRule();</span>
<span class="nc" id="L599">      r.stage = aerTemplate.stage;</span>
<span class="nc" id="L600">      r.active = aerTemplate.active;</span>
<span class="nc" id="L601">      r.priority = Double.NaN; // Priority from patterns?</span>
<span class="nc" id="L602">      r.weight = Double.NaN;  // weight from patterns?</span>
<span class="nc" id="L603">      r.annotationField = aerTemplate.annotationField;</span>
<span class="nc" id="L604">      r.tokensAnnotationField = aerTemplate.tokensAnnotationField;</span>
<span class="nc" id="L605">      r.tokensResultAnnotationField = aerTemplate.tokensResultAnnotationField;</span>
<span class="nc" id="L606">      r.resultAnnotationField = aerTemplate.resultAnnotationField;</span>
<span class="nc" id="L607">      r.resultNestedAnnotationField = aerTemplate.resultNestedAnnotationField;</span>
<span class="nc" id="L608">      r.matchFindType = aerTemplate.matchFindType;</span>
<span class="nc" id="L609">      r.matchedExpressionGroup = aerTemplate.matchedExpressionGroup;</span>
<span class="nc" id="L610">      r.matchWithResults = aerTemplate.matchWithResults;</span>
<span class="nc" id="L611">      r.ruleType = aerTemplate.ruleType;</span>
<span class="nc" id="L612">      r.isComposite = aerTemplate.isComposite;</span>
<span class="nc" id="L613">      r.includeNested = aerTemplate.includeNested;</span>
<span class="nc" id="L614">      r.active = aerTemplate.active;</span>
<span class="nc" id="L615">      r.result = aerTemplate.result;</span>

<span class="nc bnc" id="L617" title="All 2 branches missed.">      if (r.annotationField == null) { r.annotationField = r.tokensAnnotationField;  }</span>
<span class="nc" id="L618">      r.ruleType = TOKEN_PATTERN_RULE_TYPE;</span>
<span class="nc" id="L619">      MultiPatternMatcher&lt;CoreMap&gt; multiPatternMatcher = TokenSequencePattern.getMultiPatternMatcher(patterns);</span>
<span class="nc" id="L620">      multiPatternMatcher.setMatchWithResult(r.matchWithResults);</span>
<span class="nc" id="L621">      updateExtractRule(r, env, multiPatternMatcher, null, r.result);</span>
<span class="nc" id="L622">      return r;</span>
    }

    @Override
    public AnnotationExtractRule create(Env env, Map&lt;String,Object&gt; attributes) {
<span class="nc" id="L627">      throw new UnsupportedOperationException();</span>
    }
  }


<span class="nc" id="L632">  public static class TextPatternExtractRuleCreator extends AnnotationExtractRuleCreator {</span>

    protected static void updateExtractRule(AnnotationExtractRule r,
                                     Env env,
                                     String expr,
                                     Expression action,
                                     Expression result) {
<span class="nc" id="L639">      final MatchedExpression.SingleAnnotationExtractor annotationExtractor = createAnnotationExtractor(env, r);</span>
<span class="nc" id="L640">      Pattern pattern = env.getStringPattern(expr);</span>
<span class="nc" id="L641">      StringMatchResultExtractor valueExtractor = new StringMatchResultExtractor(env, action, result);</span>
<span class="nc" id="L642">      StringPatternExtractRule&lt;Value&gt; valueExtractRule = new StringPatternExtractRule&lt;&gt;(pattern, valueExtractor);</span>
<span class="nc" id="L643">      StringMatchedExpressionExtractor exprExtractor = new StringMatchedExpressionExtractor( annotationExtractor, r.matchedExpressionGroup );</span>
<span class="nc" id="L644">      StringPatternExtractRule&lt;MatchedExpression&gt; exprExtractRule = new StringPatternExtractRule&lt;&gt;(pattern, exprExtractor);</span>

<span class="nc" id="L646">      annotationExtractor.valueExtractor = new CoreMapFunctionApplier&lt;&gt;(env, r.annotationField, valueExtractRule);</span>
<span class="nc" id="L647">      r.extractRule = new CoreMapExtractRule&lt;&gt;(env, r.annotationField, exprExtractRule);</span>
<span class="nc" id="L648">      r.filterRule = new AnnotationMatchedFilter(annotationExtractor);</span>
<span class="nc" id="L649">      r.pattern = pattern;</span>
<span class="nc" id="L650">      r.result = result;</span>
<span class="nc" id="L651">    }</span>

    protected AnnotationExtractRule create(Env env, String expr, Expression result) {
<span class="nc" id="L654">      AnnotationExtractRule r = super.create(env, null);</span>
<span class="nc bnc" id="L655" title="All 2 branches missed.">      if (r.annotationField == null) { r.annotationField = EnvLookup.getDefaultTextAnnotationKey(env);  }</span>
<span class="nc" id="L656">      r.ruleType = TEXT_PATTERN_RULE_TYPE;</span>
<span class="nc" id="L657">      updateExtractRule(r, env, expr, null, result);</span>
<span class="nc" id="L658">      return r;</span>
    }

    @Override
    public AnnotationExtractRule create(Env env, Map&lt;String,Object&gt; attributes) {
<span class="nc" id="L663">      AnnotationExtractRule r = super.create(env, attributes);</span>
<span class="nc bnc" id="L664" title="All 2 branches missed.">      if (r.annotationField == null) { r.annotationField = EnvLookup.getDefaultTextAnnotationKey(env);  }</span>
<span class="nc bnc" id="L665" title="All 2 branches missed.">      if (r.ruleType == null) { r.ruleType = TEXT_PATTERN_RULE_TYPE; }</span>
<span class="nc" id="L666">      String expr = (String) Expressions.asObject(env, attributes.get(&quot;pattern&quot;));</span>
<span class="nc" id="L667">      Expression action = Expressions.asExpression(env, attributes.get(&quot;action&quot;));</span>
<span class="nc" id="L668">      Expression result = Expressions.asExpression(env, attributes.get(&quot;result&quot;));</span>
<span class="nc" id="L669">      updateExtractRule(r, env, expr, action, result);</span>
<span class="nc" id="L670">      return r;</span>
    }
  }

  public static class AnnotationMatchedFilter implements Predicate&lt;MatchedExpression&gt;, Serializable {

    MatchedExpression.SingleAnnotationExtractor extractor;

<span class="nc" id="L678">    public AnnotationMatchedFilter(MatchedExpression.SingleAnnotationExtractor extractor) {</span>
<span class="nc" id="L679">      this.extractor = extractor;</span>
<span class="nc" id="L680">    }</span>

    @Override
    public boolean test(MatchedExpression me) {
<span class="nc" id="L684">      CoreMap cm = me.getAnnotation();</span>
<span class="nc" id="L685">      Value v = extractor.apply(cm);</span>
<span class="nc bnc" id="L686" title="All 2 branches missed.">      if (v != null) {</span>
<span class="nc bnc" id="L687" title="All 2 branches missed.">        if (v.get() == null) {</span>
<span class="nc" id="L688">          return true;</span>
        } else {
<span class="nc" id="L690">          extractor.annotate(me);</span>
<span class="nc" id="L691">          return false;</span>
        }
        //return v.get() == null;
      } else {
<span class="nc" id="L695">        return false;</span>
      }
    }
  }

  public static class StringMatchResultExtractor implements Function&lt;MatchResult,Value&gt; {
    Env env;
    Expression action;
    Expression result;

<span class="nc" id="L705">    public StringMatchResultExtractor(Env env, Expression action, Expression result) {</span>
<span class="nc" id="L706">      this.env = env;</span>
<span class="nc" id="L707">      this.action = action;</span>
<span class="nc" id="L708">      this.result = result;</span>
<span class="nc" id="L709">    }</span>

<span class="nc" id="L711">    public StringMatchResultExtractor(Env env, Expression result) {</span>
<span class="nc" id="L712">      this.env = env;</span>
<span class="nc" id="L713">      this.result = result;</span>
<span class="nc" id="L714">    }</span>

    @Override
    public Value apply(MatchResult matchResult) {
<span class="nc" id="L718">      Value v = null;</span>
<span class="nc bnc" id="L719" title="All 2 branches missed.">      if (action != null) {</span>
<span class="nc" id="L720">        action.evaluate(env, matchResult);</span>
      }
<span class="nc bnc" id="L722" title="All 2 branches missed.">      if (result != null) {</span>
<span class="nc" id="L723">        v = result.evaluate(env, matchResult);</span>
      }
<span class="nc" id="L725">      return v;</span>
    }
  }

  public static class SequenceMatchResultExtractor&lt;T&gt; implements Function&lt;SequenceMatchResult&lt;T&gt;,Value&gt; {
    Env env;
    Expression action;
    Expression result;

<span class="nc" id="L734">    public SequenceMatchResultExtractor(Env env, Expression action, Expression result) {</span>
<span class="nc" id="L735">      this.env = env;</span>
<span class="nc" id="L736">      this.action = action;</span>
<span class="nc" id="L737">      this.result = result;</span>
<span class="nc" id="L738">    }</span>

<span class="nc" id="L740">    public SequenceMatchResultExtractor(Env env, Expression result) {</span>
<span class="nc" id="L741">      this.env = env;</span>
<span class="nc" id="L742">      this.result = result;</span>
<span class="nc" id="L743">    }</span>

    @Override
    public Value apply(SequenceMatchResult&lt;T&gt; matchResult) {
<span class="nc" id="L747">      Value v = null;</span>
<span class="nc bnc" id="L748" title="All 2 branches missed.">      if (action != null) {</span>
<span class="nc" id="L749">        action.evaluate(env, matchResult);</span>
      }
<span class="nc bnc" id="L751" title="All 2 branches missed.">      if (result != null) {</span>
<span class="nc" id="L752">        v = result.evaluate(env, matchResult);</span>
      }
<span class="nc" id="L754">      return v;</span>
    }
  }

  /**
   * Interface for a rule that extracts a list of matched items from an input.
   *
   * @param &lt;I&gt; input type
   * @param &lt;O&gt; output type
   */
  public interface ExtractRule&lt;I,O&gt; {

    boolean extract(I in, List&lt;O&gt; out);

  }

  /**
   * Extraction rule that filters the input before passing it on to the next extractor
   * @param &lt;I&gt; input type
   * @param &lt;O&gt; output type
   */
  public static class FilterExtractRule&lt;I,O&gt; implements ExtractRule&lt;I,O&gt; {

    Predicate&lt;I&gt; filter;
    ExtractRule&lt;I,O&gt; rule;

<span class="nc" id="L780">    public FilterExtractRule(Predicate&lt;I&gt; filter, ExtractRule&lt;I,O&gt; rule) {</span>
<span class="nc" id="L781">      this.filter = filter;</span>
<span class="nc" id="L782">      this.rule = rule;</span>
<span class="nc" id="L783">    }</span>

    @SafeVarargs
<span class="nc" id="L786">    public FilterExtractRule(Predicate&lt;I&gt; filter, ExtractRule&lt;I,O&gt;... rules) {</span>
<span class="nc" id="L787">      this.filter = filter;</span>
<span class="nc" id="L788">      this.rule = new ListExtractRule&lt;&gt;(rules);</span>
<span class="nc" id="L789">    }</span>

    @Override
    public boolean extract(I in, List&lt;O&gt; out) {
<span class="nc bnc" id="L793" title="All 2 branches missed.">      if (filter.test(in)) {</span>
<span class="nc" id="L794">        return rule.extract(in,out);</span>
      } else {
<span class="nc" id="L796">        return false;</span>
      }
    }
  }

  /**
   * Extraction rule that applies a list of rules in sequence and aggregates
   * all matches found.
   *
   * @param &lt;I&gt; input type
   * @param &lt;O&gt; output type
   */
  public static class ListExtractRule&lt;I,O&gt; implements ExtractRule&lt;I,O&gt; {

    List&lt;ExtractRule&lt;I,O&gt;&gt; rules;

<span class="nc" id="L812">    public ListExtractRule(Collection&lt;ExtractRule&lt;I,O&gt;&gt; rules) {</span>
<span class="nc" id="L813">      this.rules = new ArrayList&lt;&gt;(rules);</span>
<span class="nc" id="L814">    }</span>

    @SafeVarargs
<span class="nc" id="L817">    public ListExtractRule(ExtractRule&lt;I,O&gt;... rules) {</span>
<span class="nc" id="L818">      this.rules = new ArrayList&lt;&gt;(rules.length);</span>
<span class="nc" id="L819">      Collections.addAll(this.rules, rules);</span>
<span class="nc" id="L820">    }</span>

    @Override
    public boolean extract(I in, List&lt;O&gt; out) {
<span class="nc" id="L824">      boolean extracted = false;</span>
<span class="nc bnc" id="L825" title="All 2 branches missed.">      for (ExtractRule&lt;I,O&gt; rule:rules) {</span>
<span class="nc bnc" id="L826" title="All 2 branches missed.">        if (rule.extract(in,out)) {</span>
<span class="nc" id="L827">          extracted = true;</span>
        }
<span class="nc" id="L829">      }</span>
<span class="nc" id="L830">      return extracted;</span>
    }

    @SafeVarargs
    public final void addRules(ExtractRule&lt;I, O&gt;... rules) {
<span class="nc" id="L835">      Collections.addAll(this.rules, rules);</span>
<span class="nc" id="L836">    }</span>

    public void addRules(Collection&lt;ExtractRule&lt;I,O&gt;&gt; rules) {
<span class="nc" id="L839">      this.rules.addAll(rules);</span>
<span class="nc" id="L840">    }</span>

    public String ruleList() {
<span class="nc" id="L843">      List&lt;String&gt; names = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L844" title="All 2 branches missed.">      for (ExtractRule rule: rules) {</span>
<span class="nc bnc" id="L845" title="All 2 branches missed.">        if (rule instanceof AnnotationExtractRule) {</span>
<span class="nc" id="L846">          AnnotationExtractRule aer = (AnnotationExtractRule) rule;</span>
<span class="nc" id="L847">          String ruleString = null;</span>
<span class="nc bnc" id="L848" title="All 2 branches missed.">          if (aer.pattern != null) {</span>
<span class="nc" id="L849">            ruleString = aer.pattern.toString();</span>
<span class="nc bnc" id="L850" title="All 2 branches missed.">          } else if (aer.extractRule != null) {</span>
<span class="nc" id="L851">            ruleString = aer.extractRule.toString();</span>
<span class="nc bnc" id="L852" title="All 2 branches missed.">          } else if (aer.filterRule != null) {</span>
<span class="nc" id="L853">            ruleString = aer.filterRule.toString();</span>
          } else {
<span class="nc" id="L855">            ruleString = aer.toString();</span>
          }
<span class="nc" id="L857">          names.add(ruleString);</span>
<span class="nc" id="L858">        } else {</span>
<span class="nc" id="L859">          names.add(rule.getClass().getName());</span>
        }
<span class="nc" id="L861">      }</span>
<span class="nc" id="L862">      return names.toString();</span>
    }

    public String toString() {
<span class="nc" id="L866">      return &quot;ListExtractRule[&quot; + ruleList() + &quot;]&quot;;</span>
    }

  }

  /**
   * Extraction rule to apply a extraction rule on a particular CoreMap field
   * Input is of type CoreMap, output is templated type O.
   * @param &lt;T&gt; type of the annotation field
   * @param &lt;O&gt; output type
   */
  public static class CoreMapExtractRule&lt;T,O&gt; implements ExtractRule&lt;CoreMap, O&gt;
  {
    Env env;
    Class annotationField;
    ExtractRule&lt;T,O&gt; extractRule;

<span class="nc" id="L883">    public CoreMapExtractRule(Env env, Class annotationField, ExtractRule&lt;T,O&gt; extractRule) {</span>
<span class="nc" id="L884">      this.annotationField = annotationField;</span>
<span class="nc" id="L885">      this.extractRule = extractRule;</span>
<span class="nc" id="L886">      this.env = env;</span>
<span class="nc" id="L887">    }</span>

    @Override
    public boolean extract(CoreMap cm, List&lt;O&gt; out) {
<span class="nc" id="L891">      env.push(Expressions.VAR_SELF, cm);</span>
<span class="nc" id="L892">      T field = (T) cm.get(annotationField);</span>
<span class="nc" id="L893">      boolean res = extractRule.extract(field, out);</span>
<span class="nc" id="L894">      env.pop(Expressions.VAR_SELF);</span>
<span class="nc" id="L895">      return res;</span>
    }

  }

  /**
   * Extraction rule that treats a single CoreMap as a list/sequence of CoreMaps
   * (convenience class, for use with BasicSequenceExtractRule)
   * Input is of type CoreMap, output is templated type O.
   * @param &lt;O&gt; output type
   */
  public static class CoreMapToListExtractRule&lt;O&gt; implements ExtractRule&lt;CoreMap, O&gt;
  {
    ExtractRule&lt;List&lt;? extends CoreMap&gt;,O&gt; extractRule;

<span class="nc" id="L910">    public CoreMapToListExtractRule(ExtractRule&lt;List&lt;? extends CoreMap&gt;,O&gt; extractRule) {</span>
<span class="nc" id="L911">      this.extractRule = extractRule;</span>
<span class="nc" id="L912">    }</span>

    @Override
    public boolean extract(CoreMap cm, List&lt;O&gt; out) {
<span class="nc" id="L916">      return extractRule.extract(Arrays.asList(cm), out);</span>
    }
  }

  /**
   * Extraction rule.
   * Input is of type CoreMap, output is MatchedExpression.
   */
  public static class BasicSequenceExtractRule implements ExtractRule&lt; List&lt;? extends CoreMap&gt;, MatchedExpression&gt;
  {
    MatchedExpression.SingleAnnotationExtractor extractor;

<span class="nc" id="L928">    public BasicSequenceExtractRule(MatchedExpression.SingleAnnotationExtractor extractor) {</span>
<span class="nc" id="L929">      this.extractor = extractor;</span>
<span class="nc" id="L930">    }</span>

    @Override
    public boolean extract(List&lt;? extends CoreMap&gt; seq, List&lt;MatchedExpression&gt; out) {
<span class="nc" id="L934">      boolean extracted = false;</span>
<span class="nc bnc" id="L935" title="All 2 branches missed.">      for (int i = 0; i &lt; seq.size(); i++) {</span>
<span class="nc" id="L936">        CoreMap t = seq.get(i);</span>
<span class="nc" id="L937">        Value v = extractor.apply(t);</span>
<span class="nc bnc" id="L938" title="All 2 branches missed.">        if (v != null) {</span>
<span class="nc" id="L939">          MatchedExpression te = extractor.createMatchedExpression(Interval.toInterval(i, i + 1, Interval.INTERVAL_OPEN_END), null);</span>
<span class="nc" id="L940">          out.add(te);</span>
<span class="nc" id="L941">          extracted = true;</span>
        }
      }
<span class="nc" id="L944">      return extracted;</span>
    }
  }


  public static class SequencePatternExtractRule&lt;T,O&gt; implements ExtractRule&lt; List&lt;? extends T&gt;, O&gt;, Function&lt;List&lt;? extends T&gt;, O&gt; {

    SequencePattern&lt;T&gt; pattern;
    Function&lt;SequenceMatchResult&lt;T&gt;, O&gt; extractor;
<span class="nc" id="L953">    SequenceMatcher.FindType findType = null;</span>
<span class="nc" id="L954">    boolean matchWithResult = false;</span>

<span class="nc" id="L956">    public SequencePatternExtractRule(Env env, String regex, Function&lt;SequenceMatchResult&lt;T&gt;, O&gt; extractor) {</span>
<span class="nc" id="L957">      this.extractor = extractor;</span>
<span class="nc" id="L958">      this.pattern = SequencePattern.compile(env, regex);</span>
<span class="nc" id="L959">    }</span>

<span class="nc" id="L961">    public SequencePatternExtractRule(SequencePattern&lt;T&gt; p, Function&lt;SequenceMatchResult&lt;T&gt;, O&gt; extractor) {</span>
<span class="nc" id="L962">      this.extractor = extractor;</span>
<span class="nc" id="L963">      this.pattern = p;</span>
<span class="nc" id="L964">    }</span>

    public SequencePatternExtractRule(SequencePattern&lt;T&gt; p, Function&lt;SequenceMatchResult&lt;T&gt;, O&gt; extractor,
<span class="nc" id="L967">                                      SequenceMatcher.FindType findType, boolean matchWithResult) {</span>
<span class="nc" id="L968">      this.extractor = extractor;</span>
<span class="nc" id="L969">      this.pattern = p;</span>
<span class="nc" id="L970">      this.findType = findType;</span>
<span class="nc" id="L971">      this.matchWithResult = matchWithResult;</span>
<span class="nc" id="L972">    }</span>

    @Override
    public boolean extract(List&lt;? extends T&gt; seq, List&lt;O&gt; out) {
<span class="nc bnc" id="L976" title="All 2 branches missed.">      if (seq == null) return false;</span>
<span class="nc" id="L977">      boolean extracted = false;</span>
<span class="nc" id="L978">      SequenceMatcher&lt;T&gt; m = pattern.getMatcher(seq);</span>
<span class="nc bnc" id="L979" title="All 2 branches missed.">      if (findType != null) {</span>
<span class="nc" id="L980">        m.setFindType(findType);</span>
      }
<span class="nc" id="L982">      m.setMatchWithResult(matchWithResult);</span>
<span class="nc bnc" id="L983" title="All 2 branches missed.">      while (m.find()) {</span>
<span class="nc" id="L984">        out.add(extractor.apply(m));</span>
<span class="nc" id="L985">        extracted = true;</span>
      }
      // System.err.println(&quot;SequencePattern &quot; + pattern + &quot; of type &quot; + pattern.getClass() + &quot; matched on &quot; + extracted);
<span class="nc" id="L988">      return extracted;</span>
    }

    @Override
    public O apply(List&lt;? extends T&gt; seq) {
<span class="nc bnc" id="L993" title="All 2 branches missed.">      if (seq == null) return null;</span>
<span class="nc" id="L994">      SequenceMatcher&lt;T&gt; m = pattern.getMatcher(seq);</span>
<span class="nc" id="L995">      m.setMatchWithResult(matchWithResult);</span>
<span class="nc bnc" id="L996" title="All 2 branches missed.">      if (m.matches()) {</span>
<span class="nc" id="L997">        return extractor.apply(m);</span>
      } else {
<span class="nc" id="L999">        return null;</span>
      }
    }

  } // end static class


  public static class MultiSequencePatternExtractRule&lt;T,O&gt; implements ExtractRule&lt; List&lt;? extends T&gt;, O&gt;, Function&lt;List&lt;? extends T&gt;, O&gt; {
    MultiPatternMatcher&lt;T&gt; matcher;
    Function&lt;SequenceMatchResult&lt;T&gt;, O&gt; extractor;

<span class="nc" id="L1010">    public MultiSequencePatternExtractRule(MultiPatternMatcher&lt;T&gt; matcher, Function&lt;SequenceMatchResult&lt;T&gt;, O&gt; extractor) {</span>
<span class="nc" id="L1011">      this.extractor = extractor;</span>
<span class="nc" id="L1012">      this.matcher = matcher;</span>
<span class="nc" id="L1013">    }</span>

    @Override
    public boolean extract(List&lt;? extends T&gt; seq, List&lt;O&gt; out) {
<span class="nc bnc" id="L1017" title="All 2 branches missed.">      if (seq == null) return false;</span>
<span class="nc" id="L1018">      boolean extracted = false;</span>
<span class="nc" id="L1019">      List&lt;SequenceMatchResult&lt;T&gt;&gt; matched = matcher.findNonOverlappingMaxScore(seq);</span>
<span class="nc bnc" id="L1020" title="All 2 branches missed.">      for (SequenceMatchResult&lt;T&gt; m : matched) {</span>
<span class="nc" id="L1021">        out.add(extractor.apply(m));</span>
<span class="nc" id="L1022">        extracted = true;</span>
<span class="nc" id="L1023">      }</span>
<span class="nc" id="L1024">      return extracted;</span>
    }

    @Override
    public O apply(List&lt;? extends T&gt; seq) {
<span class="nc bnc" id="L1029" title="All 2 branches missed.">      if (seq == null) return null;</span>
<span class="nc" id="L1030">      List&lt;SequenceMatchResult&lt;T&gt;&gt; matched = matcher.findNonOverlappingMaxScore(seq);</span>
<span class="nc bnc" id="L1031" title="All 2 branches missed.">      if (matched.size() &gt; 0) {</span>
<span class="nc" id="L1032">        return extractor.apply(matched.get(0));</span>
      } else {
<span class="nc" id="L1034">        return null;</span>
      }
    }
  }


  public static class StringPatternExtractRule&lt;O&gt; implements ExtractRule&lt;String, O&gt;, Function&lt;String, O&gt; {

    private final Pattern pattern;
    private final Function&lt;MatchResult, O&gt; extractor;

<span class="nc" id="L1045">    public StringPatternExtractRule(Pattern pattern, Function&lt;MatchResult, O&gt; extractor) {</span>
<span class="nc" id="L1046">      this.pattern = pattern;</span>
<span class="nc" id="L1047">      this.extractor = extractor;</span>
<span class="nc" id="L1048">    }</span>

    public StringPatternExtractRule(Env env, String regex, Function&lt;MatchResult, O&gt; extractor) {
<span class="nc" id="L1051">      this(env, regex, extractor, false);</span>
<span class="nc" id="L1052">    }</span>

    public StringPatternExtractRule(String regex, Function&lt;MatchResult, O&gt; extractor) {
<span class="nc" id="L1055">      this(null, regex, extractor, false);</span>
<span class="nc" id="L1056">    }</span>

    public StringPatternExtractRule(Env env, String regex, Function&lt;MatchResult, O&gt; extractor,
<span class="nc" id="L1059">                                    boolean addWordBoundaries) {</span>
<span class="nc" id="L1060">      this.extractor = extractor;</span>
<span class="nc bnc" id="L1061" title="All 2 branches missed.">      if (addWordBoundaries) { regex = &quot;\\b&quot; + regex + &quot;\\b&quot;; }</span>
<span class="nc bnc" id="L1062" title="All 2 branches missed.">      if (env != null) {</span>
<span class="nc" id="L1063">        pattern = env.getStringPattern(regex);</span>
      } else {
<span class="nc" id="L1065">        pattern = Pattern.compile(regex);</span>
      }
<span class="nc" id="L1067">    }</span>

    @Override
    public boolean extract(String str, List&lt;O&gt; out) {
<span class="nc bnc" id="L1071" title="All 2 branches missed.">      if (str == null) return false;</span>
<span class="nc" id="L1072">      boolean extracted = false;</span>
<span class="nc" id="L1073">      Matcher m = pattern.matcher(str);</span>
<span class="nc bnc" id="L1074" title="All 2 branches missed.">      while (m.find()) {</span>
<span class="nc" id="L1075">        out.add(extractor.apply( m ));</span>
        // System.err.println(&quot;StringPatternExtractRule: &quot; + pattern + &quot; extracted &quot; + out.get(out.size() - 1)); // XXXX
<span class="nc" id="L1077">        extracted = true;</span>
      }
<span class="nc" id="L1079">      return extracted;</span>
    }

    @Override
    public O apply(String str) {
<span class="nc bnc" id="L1084" title="All 2 branches missed.">      if (str == null) return null;</span>
<span class="nc" id="L1085">      Matcher m = pattern.matcher(str);</span>
<span class="nc bnc" id="L1086" title="All 2 branches missed.">      if (m.matches()) {</span>
<span class="nc" id="L1087">        return extractor.apply(m);</span>
      } else {
<span class="nc" id="L1089">        return null;</span>
      }
    }

  } // end static class StringPatternExtractRule

  public static class StringMatchedExpressionExtractor implements Function&lt;MatchResult, MatchedExpression&gt;
  {
    MatchedExpression.SingleAnnotationExtractor extractor;
<span class="nc" id="L1098">    int group = 0;</span>

<span class="nc" id="L1100">    public StringMatchedExpressionExtractor(MatchedExpression.SingleAnnotationExtractor extractor, int group) {</span>
<span class="nc" id="L1101">      this.extractor = extractor;</span>
<span class="nc" id="L1102">      this.group = group;</span>
<span class="nc" id="L1103">    }</span>

    @Override
    public MatchedExpression apply(MatchResult matched) {
<span class="nc" id="L1107">      MatchedExpression te = extractor.createMatchedExpression(Interval.toInterval(matched.start(group), matched.end(group), Interval.INTERVAL_OPEN_END), null);</span>
<span class="nc" id="L1108">      return te;</span>
    }
  }

  public static class SequenceMatchedExpressionExtractor implements Function&lt;SequenceMatchResult&lt;CoreMap&gt;, MatchedExpression&gt;
  {
    MatchedExpression.SingleAnnotationExtractor extractor;
<span class="nc" id="L1115">    int group = 0;</span>

<span class="nc" id="L1117">    public SequenceMatchedExpressionExtractor(MatchedExpression.SingleAnnotationExtractor extractor, int group) {</span>
<span class="nc" id="L1118">      this.extractor = extractor;</span>
<span class="nc" id="L1119">      this.group = group;</span>
<span class="nc" id="L1120">    }</span>
    @Override
    public MatchedExpression apply(SequenceMatchResult&lt;CoreMap&gt; matched) {
<span class="nc" id="L1123">      MatchedExpression te = extractor.createMatchedExpression(null, Interval.toInterval(matched.start(group), matched.end(group), Interval.INTERVAL_OPEN_END));</span>
<span class="nc bnc" id="L1124" title="All 2 branches missed.">      if (Double.isNaN(te.priority)) {</span>
<span class="nc" id="L1125">        te.priority = matched.priority();</span>
      }
<span class="nc bnc" id="L1127" title="All 2 branches missed.">      if (Double.isNaN(te.weight)) {</span>
<span class="nc" id="L1128">        te.weight = matched.score();</span>
      }
<span class="nc bnc" id="L1130" title="All 2 branches missed.">      if (this.group != 0) {</span>
        // Save context so value evaluation can happen
<span class="nc" id="L1132">        te.context = matched.toBasicSequenceMatchResult();</span>
      }
<span class="nc" id="L1134">      return te;</span>
    }
  }

  public static class CoreMapFunctionApplier&lt;T,O&gt; implements Function&lt;CoreMap, O&gt;
  {
    Env env;
    Class annotationField;
    Function&lt;T,O&gt; func;

<span class="nc" id="L1144">    public CoreMapFunctionApplier(Env env, Class annotationField, Function&lt;T,O&gt; func) {</span>
<span class="nc" id="L1145">      this.annotationField = annotationField;</span>
<span class="nc bnc" id="L1146" title="All 2 branches missed.">      if (annotationField == null) {</span>
<span class="nc" id="L1147">        throw new IllegalArgumentException(&quot;Annotation field cannot be null&quot;);</span>
      }
<span class="nc" id="L1149">      this.func = func;</span>
<span class="nc" id="L1150">      this.env = env;</span>
<span class="nc" id="L1151">    }</span>

    @Override
    public O apply(CoreMap cm) {
<span class="nc bnc" id="L1155" title="All 2 branches missed.">      if (env != null) { env.push(Expressions.VAR_SELF, cm); }</span>
<span class="nc" id="L1156">      T field = (T) cm.get(annotationField);</span>
<span class="nc" id="L1157">      O res = func.apply(field);</span>
<span class="nc bnc" id="L1158" title="All 2 branches missed.">      if (env != null) { env.pop(Expressions.VAR_SELF); }</span>
<span class="nc" id="L1159">      return res;</span>
    }
  }

  public static class CoreMapToListFunctionApplier&lt;O&gt; implements Function&lt;CoreMap, O&gt;
  {
    Env env;
    Function&lt;List&lt;? extends CoreMap&gt;,O&gt; func;

<span class="nc" id="L1168">    public CoreMapToListFunctionApplier(Env env, Function&lt;List&lt;? extends CoreMap&gt;,O&gt; func) {</span>
<span class="nc" id="L1169">      this.func = func;</span>
<span class="nc" id="L1170">      this.env = env;</span>
<span class="nc" id="L1171">    }</span>

    @Override
    public O apply(CoreMap cm) {
<span class="nc bnc" id="L1175" title="All 2 branches missed.">      if (env != null) { env.push(Expressions.VAR_SELF, cm); }</span>
<span class="nc" id="L1176">      O res = func.apply(Collections.singletonList(cm));</span>
<span class="nc bnc" id="L1177" title="All 2 branches missed.">      if (env != null) { env.pop(Expressions.VAR_SELF); }</span>
<span class="nc" id="L1178">      return res;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>