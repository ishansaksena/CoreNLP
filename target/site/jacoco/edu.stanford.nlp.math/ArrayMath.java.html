<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ArrayMath.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.math</a> &gt; <span class="el_source">ArrayMath.java</span></div><h1>ArrayMath.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.math;

import java.io.IOException;
import java.text.NumberFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Random;

import edu.stanford.nlp.io.IOUtils;
import edu.stanford.nlp.util.RuntimeInterruptedException;
import edu.stanford.nlp.util.StringUtils;

/**
 * Class ArrayMath
 *
 * @author Teg Grenager
 */
<span class="pc bpc" id="L19" title="1 of 2 branches missed.">public class ArrayMath {</span>

<span class="fc" id="L21">  private static final Random rand = new Random();</span>


<span class="nc" id="L24">  private ArrayMath() { } // not instantiable</span>


  // BASIC INFO -----------------------------------------------------------------

  public static int numRows(double[] v) {
<span class="fc" id="L30">    return v.length;</span>
  }

  // GENERATION -----------------------------------------------------------------

  /**
   * Generate a range of integers from start (inclusive) to end (exclusive).
   * Similar to the Python range() builtin function.
   *
   * @param start
   * @param end
   * @return integers from [start...end)
   */
  public static int[] range(int start, int end) {
<span class="nc bnc" id="L44" title="All 4 branches missed.">    assert end &gt; start;</span>
<span class="nc" id="L45">    int len = end - start;</span>
<span class="nc" id="L46">    int[] range = new int[len];</span>
<span class="nc bnc" id="L47" title="All 2 branches missed.">    for (int i = 0; i &lt; range.length; ++i) range[i] = i+start;</span>
<span class="nc" id="L48">    return range;</span>
  }


  // CASTS ----------------------------------------------------------------------

  public static float[] doubleArrayToFloatArray(double[] a) {
<span class="nc" id="L55">    float[] result = new float[a.length];</span>
<span class="nc bnc" id="L56" title="All 2 branches missed.">    for (int i = 0; i &lt; a.length; i++) {</span>
<span class="nc" id="L57">      result[i] = (float) a[i];</span>
    }
<span class="nc" id="L59">    return result;</span>
  }

  public static double[] floatArrayToDoubleArray(float[] a) {
<span class="nc" id="L63">    double[] result = new double[a.length];</span>
<span class="nc bnc" id="L64" title="All 2 branches missed.">    for (int i = 0; i &lt; a.length; i++) {</span>
<span class="nc" id="L65">      result[i] = a[i];</span>
    }
<span class="nc" id="L67">    return result;</span>
  }

  public static double[][] floatArrayToDoubleArray(float[][] a) {
<span class="nc" id="L71">    double[][] result = new double[a.length][];</span>
<span class="nc bnc" id="L72" title="All 2 branches missed.">    for (int i = 0; i &lt; a.length; i++) {</span>
<span class="nc" id="L73">      result[i] = new double[a[i].length];</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">      for (int j = 0; j &lt; a[i].length; j++) {</span>
<span class="nc" id="L75">        result[i][j] = a[i][j];</span>
      }
    }
<span class="nc" id="L78">    return result;</span>
  }

  public static float[][] doubleArrayToFloatArray(double[][] a) {
<span class="nc" id="L82">    float[][] result = new float[a.length][];</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">    for (int i = 0; i &lt; a.length; i++) {</span>
<span class="nc" id="L84">      result[i] = new float[a[i].length];</span>
<span class="nc bnc" id="L85" title="All 2 branches missed.">      for (int j = 0; j &lt; a[i].length; j++) {</span>
<span class="nc" id="L86">        result[i][j] = (float) a[i][j];</span>
      }
    }
<span class="nc" id="L89">    return result;</span>
  }

  // OPERATIONS ON AN ARRAY - NONDESTRUCTIVE

  public static double[] exp(double[] a) {
<span class="fc" id="L95">    double[] result = new double[a.length];</span>
<span class="fc bfc" id="L96" title="All 2 branches covered.">    for (int i = 0; i &lt; a.length; i++) {</span>
<span class="fc" id="L97">      result[i] = Math.exp(a[i]);</span>
    }
<span class="fc" id="L99">    return result;</span>
  }

  public static double[] log(double[] a) {
<span class="fc" id="L103">    double[] result = new double[a.length];</span>
<span class="fc bfc" id="L104" title="All 2 branches covered.">    for (int i = 0; i &lt; a.length; i++) {</span>
<span class="fc" id="L105">      result[i] = Math.log(a[i]);</span>
    }
<span class="fc" id="L107">    return result;</span>
  }

  // OPERATIONS ON AN ARRAY - DESTRUCTIVE

  public static void expInPlace(double[] a) {
<span class="fc bfc" id="L113" title="All 2 branches covered.">    for (int i = 0; i &lt; a.length; i++) {</span>
<span class="fc" id="L114">      a[i] = Math.exp(a[i]);</span>
    }
<span class="fc" id="L116">  }</span>

  public static void logInPlace(double[] a) {
<span class="fc bfc" id="L119" title="All 2 branches covered.">    for (int i = 0; i &lt; a.length; i++) {</span>
<span class="fc" id="L120">      a[i] = Math.log(a[i]);</span>
    }
<span class="fc" id="L122">  }</span>

  public static double[] softmax(double[] scales) {
<span class="nc" id="L125">    double[] newScales = new double[scales.length];</span>
<span class="nc" id="L126">    double sum = 0;</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">    for (int i = 0; i &lt; scales.length; i++) {</span>
<span class="nc" id="L128">      newScales[i] = Math.exp(scales[i]);</span>
<span class="nc" id="L129">      sum += newScales[i];</span>
    }
<span class="nc bnc" id="L131" title="All 2 branches missed.">    for (int i = 0; i &lt; scales.length; i++) {</span>
<span class="nc" id="L132">      newScales[i] /= sum;</span>
    }
<span class="nc" id="L134">    return newScales;</span>
  }

  // OPERATIONS WITH SCALAR - DESTRUCTIVE

  /**
   * Increases the values in this array by b. Does it in place.
   *
   * @param a The array
   * @param b The amount by which to increase each item
   */
  public static void addInPlace(double[] a, double b) {
<span class="fc bfc" id="L146" title="All 2 branches covered.">    for (int i = 0; i &lt; a.length; i++) {</span>
<span class="fc" id="L147">      a[i] = a[i] + b;</span>
    }
<span class="fc" id="L149">  }</span>

  /**
   * Increases the values in this array by b. Does it in place.
   *
   * @param a The array
   * @param b The amount by which to increase each item
   */
  public static void addInPlace(float[] a, double b) {
<span class="nc bnc" id="L158" title="All 2 branches missed.">    for (int i = 0; i &lt; a.length; i++) {</span>
<span class="nc" id="L159">      a[i] = (float) (a[i] + b);</span>
    }
<span class="nc" id="L161">  }</span>

  /**
   * Add c times the array b to array a. Does it in place.
   */
  public static void addMultInPlace(double[] a, double[] b, double c) {
<span class="nc bnc" id="L167" title="All 2 branches missed.">    for (int i=0; i&lt;a.length; i++) {</span>
<span class="nc" id="L168">      a[i] += b[i] * c;</span>
    }
<span class="nc" id="L170">  }</span>

  /**
   * Scales the values in this array by b. Does it in place.
   */
  public static void multiplyInPlace(double[] a, double b) {
<span class="fc bfc" id="L176" title="All 2 branches covered.">    for (int i = 0; i &lt; a.length; i++) {</span>
<span class="fc" id="L177">      a[i] = a[i] * b;</span>
    }
<span class="fc" id="L179">  }</span>

  /**
   * Scales the values in this array by b. Does it in place.
   */
  public static void multiplyInPlace(float[] a, double b) {
<span class="nc bnc" id="L185" title="All 2 branches missed.">    for (int i = 0; i &lt; a.length; i++) {</span>
<span class="nc" id="L186">      a[i] = (float) (a[i] * b);</span>
    }
<span class="nc" id="L188">  }</span>

  /**
   * Divides the values in this array by b. Does it in place.
   */
  public static void divideInPlace(double[] a, double b) {
<span class="nc bnc" id="L194" title="All 2 branches missed.">    for (int i = 0; i &lt; a.length; i++) {</span>
<span class="nc" id="L195">      a[i] = a[i] / b;</span>
    }
<span class="nc" id="L197">  }</span>


  /**
   * Scales the values in this array by c.
   */
  public static void powInPlace(double[] a, double c) {
<span class="fc bfc" id="L204" title="All 2 branches covered.">    for (int i = 0; i &lt; a.length; i++) {</span>
<span class="fc" id="L205">      a[i] = Math.pow(a[i], c);</span>
    }
<span class="fc" id="L207">  }</span>

  /**
   * Sets the values in this array by to their value taken to cth power.
   */
  public static void powInPlace(float[] a, float c) {
<span class="nc bnc" id="L213" title="All 2 branches missed.">    for (int i = 0; i &lt; a.length; i++) {</span>
<span class="nc" id="L214">      a[i] = (float) Math.pow(a[i], c);</span>
    }
<span class="nc" id="L216">  }</span>

  // OPERATIONS WITH SCALAR - NONDESTRUCTIVE

  public static double[] add(double[] a, double c) {
<span class="fc" id="L221">    double[] result = new double[a.length];</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">    for (int i = 0; i &lt; a.length; i++) {</span>
<span class="fc" id="L223">      result[i] = a[i] + c;</span>
    }
<span class="fc" id="L225">    return result;</span>
  }

  public static float[] add(float[] a, double c) {
<span class="nc" id="L229">    float[] result = new float[a.length];</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">    for (int i = 0; i &lt; a.length; i++) {</span>
<span class="nc" id="L231">      result[i] = (float) (a[i] + c);</span>
    }
<span class="nc" id="L233">    return result;</span>
  }

  /**
   * Scales the values in this array by c.
   */
  public static double[] multiply(double[] a, double c) {
<span class="fc" id="L240">    double[] result = new double[a.length];</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">    for (int i = 0; i &lt; a.length; i++) {</span>
<span class="fc" id="L242">      result[i] = a[i] * c;</span>
    }
<span class="fc" id="L244">    return result;</span>
  }

  /**
   * Scales the values in this array by c.
   */
  public static float[] multiply(float[] a, float c) {
<span class="nc" id="L251">    float[] result = new float[a.length];</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">    for (int i = 0; i &lt; a.length; i++) {</span>
<span class="nc" id="L253">      result[i] = a[i] * c;</span>
    }
<span class="nc" id="L255">    return result;</span>
  }

  /**
   * raises each entry in array a by power c
   */
  public static double[] pow(double[] a, double c) {
<span class="fc" id="L262">    double[] result = new double[a.length];</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">    for (int i = 0; i &lt; a.length; i++) {</span>
<span class="fc" id="L264">      result[i] = Math.pow(a[i], c);</span>
    }
<span class="fc" id="L266">    return result;</span>
  }

  /**
   * raises each entry in array a by power c
   */
  public static float[] pow(float[] a, float c) {
<span class="nc" id="L273">    float[] result = new float[a.length];</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">    for (int i = 0; i &lt; a.length; i++) {</span>
<span class="nc" id="L275">      result[i] = (float) Math.pow(a[i], c);</span>
    }
<span class="nc" id="L277">    return result;</span>
  }

  // OPERATIONS WITH TWO ARRAYS - DESTRUCTIVE

  public static void pairwiseAddInPlace(float[] to, float[] from) {
<span class="nc bnc" id="L283" title="All 2 branches missed.">    if (to.length != from.length) {</span>
<span class="nc" id="L284">      throw new RuntimeException(&quot;to length:&quot; + to.length + &quot; from length:&quot; + from.length);</span>
    }
<span class="nc bnc" id="L286" title="All 2 branches missed.">    for (int i = 0; i &lt; to.length; i++) {</span>
<span class="nc" id="L287">      to[i] = to[i] + from[i];</span>
    }
<span class="nc" id="L289">  }</span>
  public static void pairwiseAddInPlace(double[] to, double[] from) {
<span class="nc bnc" id="L291" title="All 2 branches missed.">    if (to.length != from.length) {</span>
<span class="nc" id="L292">      throw new RuntimeException(&quot;to length:&quot; + to.length + &quot; from length:&quot; + from.length);</span>
    }
<span class="nc bnc" id="L294" title="All 2 branches missed.">    for (int i = 0; i &lt; to.length; i++) {</span>
<span class="nc" id="L295">      to[i] = to[i] + from[i];</span>
    }
<span class="nc" id="L297">  }</span>

  public static void pairwiseAddInPlace(double[] to, int[] from) {
<span class="nc bnc" id="L300" title="All 2 branches missed.">    if (to.length != from.length) {</span>
<span class="nc" id="L301">      throw new RuntimeException();</span>
    }
<span class="nc bnc" id="L303" title="All 2 branches missed.">    for (int i = 0; i &lt; to.length; i++) {</span>
<span class="nc" id="L304">      to[i] = to[i] + from[i];</span>
    }
<span class="nc" id="L306">  }</span>

  public static void pairwiseAddInPlace(double[] to, short[] from) {
<span class="nc bnc" id="L309" title="All 2 branches missed.">    if (to.length != from.length) {</span>
<span class="nc" id="L310">      throw new RuntimeException();</span>
    }
<span class="nc bnc" id="L312" title="All 2 branches missed.">    for (int i = 0; i &lt; to.length; i++) {</span>
<span class="nc" id="L313">      to[i] = to[i] + from[i];</span>
    }
<span class="nc" id="L315">  }</span>

  public static void pairwiseSubtractInPlace(double[] to, double[] from) {
<span class="pc bpc" id="L318" title="1 of 2 branches missed.">    if (to.length != from.length) {</span>
<span class="nc" id="L319">      throw new RuntimeException();</span>
    }
<span class="fc bfc" id="L321" title="All 2 branches covered.">    for (int i = 0; i &lt; to.length; i++) {</span>
<span class="fc" id="L322">      to[i] = to[i] - from[i];</span>
    }
<span class="fc" id="L324">  }</span>

  public static void pairwiseScaleAddInPlace(double[] to, double[] from, double fromScale) {
<span class="nc bnc" id="L327" title="All 2 branches missed.">    if (to.length != from.length) {</span>
<span class="nc" id="L328">      throw new RuntimeException();</span>
    }
<span class="nc bnc" id="L330" title="All 2 branches missed.">    for (int i = 0; i &lt; to.length; i++) {</span>
<span class="nc" id="L331">      to[i] = to[i] + fromScale * from[i];</span>
    }
<span class="nc" id="L333">  }</span>

  // OPERATIONS WITH TWO ARRAYS - NONDESTRUCTIVE

  public static int[] pairwiseAdd(int[] a, int[] b) {
<span class="nc" id="L338">    int[] result = new int[a.length];</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">    for (int i = 0; i &lt; a.length; i++) {</span>
<span class="nc" id="L340">      result[i] = a[i] + b[i];</span>
    }
<span class="nc" id="L342">    return result;</span>
  }

  public static double[] pairwiseAdd(double[] a, double[] b) {
<span class="fc" id="L346">    double[] result = new double[a.length];</span>
<span class="fc bfc" id="L347" title="All 2 branches covered.">    for (int i = 0; i &lt; a.length; i++) {</span>
<span class="pc bpc" id="L348" title="1 of 2 branches missed.">      if (i &lt; b.length) {</span>
<span class="fc" id="L349">        result[i] = a[i] + b[i];</span>
      } else {
<span class="nc" id="L351">        result[i] = a[i];</span>
      }
    }
<span class="fc" id="L354">    return result;</span>
  }

  public static float[] pairwiseAdd(float[] a, float[] b) {
<span class="nc" id="L358">    float[] result = new float[a.length];</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">    for (int i = 0; i &lt; a.length; i++) {</span>
<span class="nc" id="L360">      result[i] = a[i] + b[i];</span>
    }
<span class="nc" id="L362">    return result;</span>
  }

  public static double[] pairwiseScaleAdd(double[] a, double[] b, double bScale) {
<span class="nc" id="L366">    double[] result = new double[a.length];</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">    for (int i = 0; i &lt; a.length; i++) {</span>
<span class="nc" id="L368">      result[i] = a[i] + bScale * b[i];</span>
    }
<span class="nc" id="L370">    return result;</span>
  }


  public static double[] pairwiseSubtract(double[] a, double[] b) {
<span class="fc" id="L375">    double[] c = new double[a.length];</span>

<span class="fc bfc" id="L377" title="All 2 branches covered.">    for (int i = 0; i &lt; a.length; i++) {</span>
<span class="fc" id="L378">      c[i] = a[i] - b[i];</span>
    }
<span class="fc" id="L380">    return c;</span>
  }

  public static float[] pairwiseSubtract(float[] a, float[] b) {
<span class="nc" id="L384">    float[] c = new float[a.length];</span>

<span class="nc bnc" id="L386" title="All 2 branches missed.">    for (int i = 0; i &lt; a.length; i++) {</span>
<span class="nc" id="L387">      c[i] = a[i] - b[i];</span>
    }
<span class="nc" id="L389">    return c;</span>
  }

  /**
   * Assumes that both arrays have same length.
   */
  public static double dotProduct(double[] a, double[] b) {
<span class="nc bnc" id="L396" title="All 2 branches missed.">    if (a.length != b.length) {</span>
<span class="nc" id="L397">      throw new RuntimeException(&quot;Can't calculate dot product of multiple different lengths: a.length=&quot; + a.length + &quot; b.length=&quot; + b.length);</span>
    }
<span class="nc" id="L399">    double result = 0;</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">    for (int i = 0; i &lt; a.length; i++) {</span>
<span class="nc" id="L401">      result += a[i] * b[i];</span>
    }
<span class="nc" id="L403">    return result;</span>
  }



  /**
   * Assumes that both arrays have same length.
   */
  public static double[] pairwiseMultiply(double[] a, double[] b) {
<span class="pc bpc" id="L412" title="1 of 2 branches missed.">    if (a.length != b.length) {</span>
<span class="nc" id="L413">      throw new RuntimeException(&quot;Can't pairwise multiple different lengths: a.length=&quot; + a.length + &quot; b.length=&quot; + b.length);</span>
    }
<span class="fc" id="L415">    double[] result = new double[a.length];</span>
<span class="fc bfc" id="L416" title="All 2 branches covered.">    for (int i = 0; i &lt; result.length; i++) {</span>
<span class="fc" id="L417">      result[i] = a[i] * b[i];</span>
    }
<span class="fc" id="L419">    return result;</span>
  }

  /**
   * Assumes that both arrays have same length.
   */
  public static float[] pairwiseMultiply(float[] a, float[] b) {
<span class="nc bnc" id="L426" title="All 2 branches missed.">    if (a.length != b.length) {</span>
<span class="nc" id="L427">      throw new RuntimeException();</span>
    }
<span class="nc" id="L429">    float[] result = new float[a.length];</span>
<span class="nc bnc" id="L430" title="All 2 branches missed.">    for (int i = 0; i &lt; result.length; i++) {</span>
<span class="nc" id="L431">      result[i] = a[i] * b[i];</span>
    }
<span class="nc" id="L433">    return result;</span>
  }

  /**
   * Puts the result in the result array.
   * Assumes that all arrays have same length.
   */
  public static void pairwiseMultiply(double[] a, double[] b, double[] result) {
<span class="nc bnc" id="L441" title="All 2 branches missed.">    if (a.length != b.length) {</span>
<span class="nc" id="L442">      throw new RuntimeException();</span>
    }
<span class="nc bnc" id="L444" title="All 2 branches missed.">    for (int i = 0; i &lt; result.length; i++) {</span>
<span class="nc" id="L445">      result[i] = a[i] * b[i];</span>
    }
<span class="nc" id="L447">  }</span>

  /**
   * Puts the result in the result array.
   * Assumes that all arrays have same length.
   */
  public static void pairwiseMultiply(float[] a, float[] b, float[] result) {
<span class="nc bnc" id="L454" title="All 2 branches missed.">    if (a.length != b.length) {</span>
<span class="nc" id="L455">      throw new RuntimeException();</span>
    }
<span class="nc bnc" id="L457" title="All 2 branches missed.">    for (int i = 0; i &lt; result.length; i++) {</span>
<span class="nc" id="L458">      result[i] = a[i] * b[i];</span>
    }
<span class="nc" id="L460">  }</span>

  /**
   * Divide the first array by the second elementwise,
   * and store results in place. Assume arrays have
   * the same length
   */
  public static void pairwiseDivideInPlace(double[] a, double[] b) {
<span class="nc bnc" id="L468" title="All 2 branches missed.">    if (a.length != b.length) {</span>
<span class="nc" id="L469">      throw new RuntimeException();</span>
    }
<span class="nc bnc" id="L471" title="All 2 branches missed.">    for (int i = 0; i &lt; a.length; i++) {</span>
<span class="nc" id="L472">      a[i] = a[i] / b[i];</span>
    }
<span class="nc" id="L474">  }</span>

  // ERROR CHECKING

  public static boolean hasNaN(double[] a) {
<span class="fc bfc" id="L479" title="All 2 branches covered.">    for (double x : a) {</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">      if (Double.isNaN(x)) return true;</span>
    }
<span class="fc" id="L482">    return false;</span>
  }

  public static boolean hasInfinite(double[] a) {
<span class="fc bfc" id="L486" title="All 2 branches covered.">    for (double anA : a) {</span>
<span class="fc bfc" id="L487" title="All 2 branches covered.">      if (Double.isInfinite(anA)) return true;</span>
    }
<span class="fc" id="L489">    return false;</span>
  }

  public static boolean hasNaN(float[] a) {
<span class="nc bnc" id="L493" title="All 2 branches missed.">    for (float x : a) {</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">      if (Float.isNaN(x)) return true;</span>
    }
<span class="nc" id="L496">    return false;</span>
  }

  // methods for filtering vectors ------------------------------------------

  public static int countNaN(double[] v) {
<span class="fc" id="L502">    int c = 0;</span>
<span class="fc bfc" id="L503" title="All 2 branches covered.">    for (double d : v) {</span>
<span class="fc bfc" id="L504" title="All 2 branches covered.">      if (Double.isNaN(d)) {</span>
<span class="fc" id="L505">        c++;</span>
      }
    }
<span class="fc" id="L508">    return c;</span>
  }

  public static double[] filterNaN(double[] v) {
<span class="fc" id="L512">    double[] u = new double[numRows(v) - countNaN(v)];</span>
<span class="fc" id="L513">    int j = 0;</span>
<span class="fc bfc" id="L514" title="All 2 branches covered.">    for (double d : v) {</span>
<span class="fc bfc" id="L515" title="All 2 branches covered.">      if ( ! Double.isNaN(d)) {</span>
<span class="fc" id="L516">        u[j++] = d;</span>
      }
    }
<span class="fc" id="L519">    return u;</span>
  }

  public static int countInfinite(double[] v) {
<span class="fc" id="L523">    int c = 0;</span>
<span class="fc bfc" id="L524" title="All 2 branches covered.">    for (double aV : v)</span>
<span class="fc bfc" id="L525" title="All 2 branches covered.">      if (Double.isInfinite(aV))</span>
<span class="fc" id="L526">        c++;</span>
<span class="fc" id="L527">    return c;</span>
  }

  public static int countNonZero(double[] v) {
<span class="nc" id="L531">    int c = 0;</span>
<span class="nc bnc" id="L532" title="All 2 branches missed.">    for (double aV : v)</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">      if (aV != 0.0)</span>
<span class="nc" id="L534">        ++c;</span>
<span class="nc" id="L535">    return c;</span>
  }

  public static int countCloseToZero(double[] v, double epsilon) {
<span class="nc" id="L539">    int c = 0;</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">    for (double aV : v)</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">      if (Math.abs(aV) &lt; epsilon)</span>
<span class="nc" id="L542">        ++c;</span>
<span class="nc" id="L543">    return c;</span>
  }

  public static int countPositive(double[] v) {
<span class="nc" id="L547">    int c = 0;</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">    for (double a : v) {</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">      if (a &gt; 0.0) {</span>
<span class="nc" id="L550">        ++c;</span>
      }
    }
<span class="nc" id="L553">    return c;</span>
  }

  public static int countNegative(double[] v) {
<span class="nc" id="L557">    int c = 0;</span>
<span class="nc bnc" id="L558" title="All 2 branches missed.">    for (double aV : v)</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">      if (aV &lt; 0.0)</span>
<span class="nc" id="L560">        ++c;</span>
<span class="nc" id="L561">    return c;</span>
  }

  public static double[] filterInfinite(double[] v) {
<span class="fc" id="L565">    double[] u = new double[numRows(v) - countInfinite(v)];</span>
<span class="fc" id="L566">    int j = 0;</span>
<span class="fc bfc" id="L567" title="All 2 branches covered.">    for (double aV : v) {</span>
<span class="fc bfc" id="L568" title="All 2 branches covered.">      if (!Double.isInfinite(aV)) {</span>
<span class="fc" id="L569">        u[j++] = aV;</span>
      }
    }
<span class="fc" id="L572">    return u;</span>
  }

  public static double[] filterNaNAndInfinite(double[] v) {
<span class="fc" id="L576">    return filterInfinite(filterNaN(v));</span>
  }


  // VECTOR PROPERTIES

  /**
   * Returns the sum of an array of numbers.
   */
  public static double sum(double[] a) {
<span class="fc" id="L586">    return sum(a,0,a.length);</span>
  }

  /**
   * Returns the sum of the portion of an array of numbers between
   * &lt;code&gt;fromIndex&lt;/code&gt;, inclusive, and &lt;code&gt;toIndex&lt;/code&gt;, exclusive.
   * Returns 0 if &lt;code&gt;fromIndex&lt;/code&gt; &amp;gt;= &lt;code&gt;toIndex&lt;/code&gt;.
   */
  public static double sum(double[] a, int fromIndex, int toIndex) {
<span class="fc" id="L595">    double result = 0.0;</span>
<span class="fc bfc" id="L596" title="All 2 branches covered.">    for (int i = fromIndex; i &lt; toIndex; i++) {</span>
<span class="fc" id="L597">      result += a[i];</span>
    }
<span class="fc" id="L599">    return result;</span>
  }



  public static int sum(int[] a) {
<span class="nc" id="L605">    int result = 0;</span>
<span class="nc bnc" id="L606" title="All 2 branches missed.">    for (int i : a) {</span>
<span class="nc" id="L607">      result += i;</span>
    }
<span class="nc" id="L609">    return result;</span>
  }

  public static float sum(float[] a) {
<span class="nc" id="L613">    float result = 0.0F;</span>
<span class="nc bnc" id="L614" title="All 2 branches missed.">    for (float f : a) {</span>
<span class="nc" id="L615">      result += f;</span>
    }
<span class="nc" id="L617">    return result;</span>
  }

  public static int sum(int[][] a) {
<span class="nc" id="L621">    int result = 0;</span>
<span class="nc bnc" id="L622" title="All 2 branches missed.">    for (int[] v : a) {</span>
<span class="nc bnc" id="L623" title="All 2 branches missed.">      for (int item : v) {</span>
<span class="nc" id="L624">        result += item;</span>
      }
    }
<span class="nc" id="L627">    return result;</span>
  }

  /**
   * Returns diagonal elements of the given (square) matrix.
   */
  public static int[] diag(int[][] a) {
<span class="nc" id="L634">    int[] rv = new int[a.length];</span>
<span class="nc bnc" id="L635" title="All 2 branches missed.">    for (int i = 0; i &lt; a.length; i++) {</span>
<span class="nc" id="L636">      rv[i] = a[i][i];</span>
    }
<span class="nc" id="L638">    return rv;</span>
  }

  public static double average(double[] a) {
<span class="nc" id="L642">    double total = ArrayMath.sum(a);</span>
<span class="nc" id="L643">    return total / a.length;</span>
  }

  /** This version avoids any possibility of overflow. */
  public static double iterativeAverage(double[] a) {
<span class="nc" id="L648">    double avg = 0.0;</span>
<span class="nc" id="L649">    int t = 1;</span>
<span class="nc bnc" id="L650" title="All 2 branches missed.">    for (double x : a) {</span>
<span class="nc" id="L651">      avg += (x - avg) / t;</span>
<span class="nc" id="L652">      t++;</span>
    }
<span class="nc" id="L654">    return avg;</span>
  }

  /**
   * Computes inf-norm of vector.
   * This is just the largest absolute value of an element.
   *
   * @param a Array of double
   * @return inf-norm of a
   */
  public static double norm_inf(double[] a) {
<span class="fc" id="L665">    double max = Double.NEGATIVE_INFINITY;</span>
<span class="fc bfc" id="L666" title="All 2 branches covered.">    for (double d : a) {</span>
<span class="fc bfc" id="L667" title="All 2 branches covered.">      if (Math.abs(d) &gt; max) {</span>
<span class="fc" id="L668">        max = Math.abs(d);</span>
      }
    }
<span class="fc" id="L671">    return max;</span>
  }


  /**
   * Computes inf-norm of vector.
   *
   * @return inf-norm of a
   */
  public static double norm_inf(float[] a) {
<span class="nc" id="L681">    double max = Double.NEGATIVE_INFINITY;</span>
<span class="nc bnc" id="L682" title="All 2 branches missed.">    for (float anA : a) {</span>
<span class="nc bnc" id="L683" title="All 2 branches missed.">      if (Math.abs(anA) &gt; max) {</span>
<span class="nc" id="L684">        max = Math.abs(anA);</span>
      }
    }
<span class="nc" id="L687">    return max;</span>
  }

  /**
   * Computes 1-norm of vector.
   *
   * @param a A vector of double
   * @return 1-norm of a
   */
  public static double norm_1(double[] a) {
<span class="fc" id="L697">    double sum = 0;</span>
<span class="fc bfc" id="L698" title="All 2 branches covered.">    for (double anA : a) {</span>
<span class="fc bfc" id="L699" title="All 2 branches covered.">      sum += (anA &lt; 0 ? -anA : anA);</span>
    }
<span class="fc" id="L701">    return sum;</span>
  }

  /**
   * Computes 1-norm of vector.
   *
   * @param a A vector of floats
   * @return 1-norm of a
   */
  public static double norm_1(float[] a) {
<span class="nc" id="L711">    double sum = 0;</span>
<span class="nc bnc" id="L712" title="All 2 branches missed.">    for (float anA : a) {</span>
<span class="nc bnc" id="L713" title="All 2 branches missed.">      sum += (anA &lt; 0 ? -anA : anA);</span>
    }
<span class="nc" id="L715">    return sum;</span>
  }


  /**
   * Computes 2-norm of vector.
   *
   * @param a A vector of double
   * @return Euclidean norm of a
   */
  public static double norm(double[] a) {
<span class="fc" id="L726">    double squaredSum = 0;</span>
<span class="fc bfc" id="L727" title="All 2 branches covered.">    for (double anA : a) {</span>
<span class="fc" id="L728">      squaredSum += anA * anA;</span>
    }
<span class="fc" id="L730">    return Math.sqrt(squaredSum);</span>
  }

  /**
   * Computes 2-norm of vector.
   *
   * @param a A vector of floats
   * @return Euclidean norm of a
   */
  public static double norm(float[] a) {
<span class="nc" id="L740">    double squaredSum = 0;</span>
<span class="nc bnc" id="L741" title="All 2 branches missed.">    for (float anA : a) {</span>
<span class="nc" id="L742">      squaredSum += anA * anA;</span>
    }
<span class="nc" id="L744">    return Math.sqrt(squaredSum);</span>
  }

  /**
   * @return the index of the max value; if max is a tie, returns the first one.
   */
  public static int argmax(double[] a) {
<span class="fc" id="L751">    double max = Double.NEGATIVE_INFINITY;</span>
<span class="fc" id="L752">    int argmax = 0;</span>
<span class="fc bfc" id="L753" title="All 2 branches covered.">    for (int i = 0; i &lt; a.length; i++) {</span>
<span class="fc bfc" id="L754" title="All 2 branches covered.">      if (a[i] &gt; max) {</span>
<span class="fc" id="L755">        max = a[i];</span>
<span class="fc" id="L756">        argmax = i;</span>
      }
    }
<span class="fc" id="L759">    return argmax;</span>
  }

  /**
   * @return the index of the max value; if max is a tie, returns the last one.
   */
  public static int argmax_tieLast(double[] a) {
<span class="nc" id="L766">    double max = Double.NEGATIVE_INFINITY;</span>
<span class="nc" id="L767">    int argmax = 0;</span>
<span class="nc bnc" id="L768" title="All 2 branches missed.">    for (int i = 0; i &lt; a.length; i++) {</span>
<span class="nc bnc" id="L769" title="All 2 branches missed.">      if (a[i] &gt;= max) {</span>
<span class="nc" id="L770">        max = a[i];</span>
<span class="nc" id="L771">        argmax = i;</span>
      }
    }
<span class="nc" id="L774">    return argmax;</span>
  }

  public static double max(double[] a) {
<span class="fc" id="L778">    return a[argmax(a)];</span>
  }

  public static double max(Collection&lt;Double&gt; a) {
<span class="nc" id="L782">    double max = Double.NEGATIVE_INFINITY;</span>
<span class="nc bnc" id="L783" title="All 2 branches missed.">    for (double d : a) {</span>
<span class="nc bnc" id="L784" title="All 2 branches missed.">      if (d &gt; max) { max = d; }</span>
<span class="nc" id="L785">    }</span>
<span class="nc" id="L786">    return max;</span>
  }

  /**
   * @return the index of the max value; if max is a tie, returns the first one.
   */
  public static int argmax(float[] a) {
<span class="nc" id="L793">    float max = Float.NEGATIVE_INFINITY;</span>
<span class="nc" id="L794">    int argmax = 0;</span>
<span class="nc bnc" id="L795" title="All 2 branches missed.">    for (int i = 0; i &lt; a.length; i++) {</span>
<span class="nc bnc" id="L796" title="All 2 branches missed.">      if (a[i] &gt; max) {</span>
<span class="nc" id="L797">        max = a[i];</span>
<span class="nc" id="L798">        argmax = i;</span>
      }
    }
<span class="nc" id="L801">    return argmax;</span>
  }

  public static float max(float[] a) {
<span class="nc" id="L805">    return a[argmax(a)];</span>
  }

  /**
   * @return the index of the min value; if min is a tie, returns the first one.
   */
  public static int argmin(double[] a) {
<span class="fc" id="L812">    double min = Double.POSITIVE_INFINITY;</span>
<span class="fc" id="L813">    int argmin = 0;</span>
<span class="fc bfc" id="L814" title="All 2 branches covered.">    for (int i = 0; i &lt; a.length; i++) {</span>
<span class="fc bfc" id="L815" title="All 2 branches covered.">      if (a[i] &lt; min) {</span>
<span class="fc" id="L816">        min = a[i];</span>
<span class="fc" id="L817">        argmin = i;</span>
      }
    }
<span class="fc" id="L820">    return argmin;</span>
  }

  /**
   * @return The minimum value in an array.
   */
  public static double min(double[] a) {
<span class="fc" id="L827">    return a[argmin(a)];</span>
  }

  /**
   * Returns the smallest value in a vector of doubles.  Any values which
   * are NaN or infinite are ignored.  If the vector is empty, 0.0 is
   * returned.
   */
  public static double safeMin(double[] v) {
<span class="nc" id="L836">    double[] u = filterNaNAndInfinite(v);</span>
<span class="nc bnc" id="L837" title="All 2 branches missed.">    if (numRows(u) == 0) return 0.0;</span>
<span class="nc" id="L838">    return min(u);</span>
  }

  /**
   * @return the index of the min value; if min is a tie, returns the first one.
   */
  public static int argmin(float[] a) {
<span class="nc" id="L845">    float min = Float.POSITIVE_INFINITY;</span>
<span class="nc" id="L846">    int argmin = 0;</span>
<span class="nc bnc" id="L847" title="All 2 branches missed.">    for (int i = 0; i &lt; a.length; i++) {</span>
<span class="nc bnc" id="L848" title="All 2 branches missed.">      if (a[i] &lt; min) {</span>
<span class="nc" id="L849">        min = a[i];</span>
<span class="nc" id="L850">        argmin = i;</span>
      }
    }
<span class="nc" id="L853">    return argmin;</span>
  }

  public static float min(float[] a) {
<span class="nc" id="L857">    return a[argmin(a)];</span>
  }

  /**
   * @return the index of the min value; if min is a tie, returns the first one.
   */
  public static int argmin(int[] a) {
<span class="nc" id="L864">    int min = Integer.MAX_VALUE;</span>
<span class="nc" id="L865">    int argmin = 0;</span>
<span class="nc bnc" id="L866" title="All 2 branches missed.">    for (int i = 0; i &lt; a.length; i++) {</span>
<span class="nc bnc" id="L867" title="All 2 branches missed.">      if (a[i] &lt; min) {</span>
<span class="nc" id="L868">        min = a[i];</span>
<span class="nc" id="L869">        argmin = i;</span>
      }
    }
<span class="nc" id="L872">    return argmin;</span>
  }

  public static int min(int[] a) {
<span class="nc" id="L876">    return a[argmin(a)];</span>
  }

  /**
   * @return the index of the max value; if max is a tie, returns the first one.
   */
  public static int argmax(int[] a) {
<span class="nc" id="L883">    int max = Integer.MIN_VALUE;</span>
<span class="nc" id="L884">    int argmax = 0;</span>
<span class="nc bnc" id="L885" title="All 2 branches missed.">    for (int i = 0; i &lt; a.length; i++) {</span>
<span class="nc bnc" id="L886" title="All 2 branches missed.">      if (a[i] &gt; max) {</span>
<span class="nc" id="L887">        max = a[i];</span>
<span class="nc" id="L888">        argmax = i;</span>
      }
    }
<span class="nc" id="L891">    return argmax;</span>
  }

  public static int max(int[] a) {
<span class="nc" id="L895">    return a[argmax(a)];</span>
  }

  /** Returns the smallest element of the matrix */
  public static int min(int[][] matrix) {
<span class="nc" id="L900">    int min = Integer.MAX_VALUE;</span>
<span class="nc bnc" id="L901" title="All 2 branches missed.">    for (int[] row : matrix) {</span>
<span class="nc bnc" id="L902" title="All 2 branches missed.">      for (int elem : row) {</span>
<span class="nc" id="L903">        min = Math.min(min, elem);</span>
      }
    }
<span class="nc" id="L906">    return min;</span>
  }

  /** Returns the smallest element of the matrix */
  public static int max(int[][] matrix) {
<span class="nc" id="L911">    int max = Integer.MIN_VALUE;</span>
<span class="nc bnc" id="L912" title="All 2 branches missed.">    for (int[] row : matrix) {</span>
<span class="nc bnc" id="L913" title="All 2 branches missed.">      for (int elem : row) {</span>
<span class="nc" id="L914">        max = Math.max(max, elem);</span>
      }
    }
<span class="nc" id="L917">    return max;</span>
  }

  /**
   * Returns the largest value in a vector of doubles.  Any values which
   * are NaN or infinite are ignored.  If the vector is empty, 0.0 is
   * returned.
   */
  public static double safeMax(double[] v) {
<span class="nc" id="L926">    double[] u = filterNaNAndInfinite(v);</span>
<span class="nc bnc" id="L927" title="All 2 branches missed.">    if (numRows(u) == 0) return 0.0;</span>
<span class="nc" id="L928">    return max(u);</span>
  }

  /**
   * Returns the log of the sum of an array of numbers, which are
   * themselves input in log form.  This is all natural logarithms.
   * Reasonable care is taken to do this as efficiently as possible
   * (under the assumption that the numbers might differ greatly in
   * magnitude), with high accuracy, and without numerical overflow.
   *
   * @param logInputs An array of numbers [log(x1), ..., log(xn)]
   * @return {@literal log(x1 + ... + xn)}
   */
  public static double logSum(double... logInputs) {
<span class="fc" id="L942">    return logSum(logInputs,0,logInputs.length);</span>
  }

  /**
   * Returns the log of the portion between &lt;code&gt;fromIndex&lt;/code&gt;, inclusive, and
   * &lt;code&gt;toIndex&lt;/code&gt;, exclusive, of an array of numbers, which are
   * themselves input in log form.  This is all natural logarithms.
   * Reasonable care is taken to do this as efficiently as possible
   * (under the assumption that the numbers might differ greatly in
   * magnitude), with high accuracy, and without numerical overflow.  Throws an
   * {@link IllegalArgumentException} if &lt;code&gt;logInputs&lt;/code&gt; is of length zero.
   * Otherwise, returns Double.NEGATIVE_INFINITY if &lt;code&gt;fromIndex&lt;/code&gt; &amp;gt;=
   * &lt;code&gt;toIndex&lt;/code&gt;.
   *
   * @param logInputs An array of numbers [log(x1), ..., log(xn)]
   * @param fromIndex The array index to start the sum from
   * @param toIndex The array index after the last element to be summed
   * @return {@literal log(x1 + ... + xn)}
   */
  public static double logSum(double[] logInputs, int fromIndex, int toIndex) {
<span class="pc bpc" id="L962" title="1 of 2 branches missed.">    if (Thread.interrupted()) {  // A good place to check for interrupts -- many functions call this</span>
<span class="nc" id="L963">      throw new RuntimeInterruptedException();</span>
    }
<span class="pc bpc" id="L965" title="1 of 2 branches missed.">    if (logInputs.length == 0)</span>
<span class="nc" id="L966">      throw new IllegalArgumentException();</span>
<span class="pc bpc" id="L967" title="4 of 6 branches missed.">    if(fromIndex &gt;= 0 &amp;&amp; toIndex &lt; logInputs.length &amp;&amp; fromIndex &gt;= toIndex)</span>
<span class="nc" id="L968">      return Double.NEGATIVE_INFINITY;</span>
<span class="fc" id="L969">    int maxIdx = fromIndex;</span>
<span class="fc" id="L970">    double max = logInputs[fromIndex];</span>
<span class="fc bfc" id="L971" title="All 2 branches covered.">    for (int i = fromIndex+1; i &lt; toIndex; i++) {</span>
<span class="fc bfc" id="L972" title="All 2 branches covered.">      if (logInputs[i] &gt; max) {</span>
<span class="fc" id="L973">        maxIdx = i;</span>
<span class="fc" id="L974">        max = logInputs[i];</span>
      }
    }
<span class="fc" id="L977">    boolean haveTerms = false;</span>
<span class="fc" id="L978">    double intermediate = 0.0;</span>
<span class="fc" id="L979">    double cutoff = max - SloppyMath.LOGTOLERANCE;</span>
    // we avoid rearranging the array and so test indices each time!
<span class="fc bfc" id="L981" title="All 2 branches covered.">    for (int i = fromIndex; i &lt; toIndex; i++) {</span>
<span class="pc bpc" id="L982" title="1 of 4 branches missed.">      if (i != maxIdx &amp;&amp; logInputs[i] &gt; cutoff) {</span>
<span class="fc" id="L983">        haveTerms = true;</span>
<span class="fc" id="L984">        intermediate += Math.exp(logInputs[i] - max);</span>
      }
    }
<span class="pc bpc" id="L987" title="1 of 2 branches missed.">    if (haveTerms) {</span>
<span class="fc" id="L988">      return max + Math.log(1.0 + intermediate);</span>
    } else {
<span class="nc" id="L990">      return max;</span>
    }
  }

  /**
   * Returns the log of the portion between &lt;code&gt;fromIndex&lt;/code&gt;, inclusive, and
   * &lt;code&gt;toIndex&lt;/code&gt;, exclusive, of an array of numbers, which are
   * themselves input in log form.  This is all natural logarithms.
   * This version incorporates a stride, so you can sum only select numbers.
   * Reasonable care is taken to do this as efficiently as possible
   * (under the assumption that the numbers might differ greatly in
   * magnitude), with high accuracy, and without numerical overflow.  Throws an
   * {@link IllegalArgumentException} if &lt;code&gt;logInputs&lt;/code&gt; is of length zero.
   * Otherwise, returns Double.NEGATIVE_INFINITY if &lt;code&gt;fromIndex&lt;/code&gt; &amp;gt;=
   * &lt;code&gt;toIndex&lt;/code&gt;.
   *
   * @param logInputs An array of numbers [log(x1), ..., log(xn)]
   * @param fromIndex The array index to start the sum from
   * @param afterIndex The array index after the last element to be summed
   * @return {@literal log(x1 + ... + xn)}
   */
  public static double logSum(double[] logInputs, int fromIndex, int afterIndex, int stride) {
<span class="nc bnc" id="L1012" title="All 2 branches missed.">    if (logInputs.length == 0)</span>
<span class="nc" id="L1013">      throw new IllegalArgumentException();</span>
<span class="nc bnc" id="L1014" title="All 6 branches missed.">    if (fromIndex &gt;= 0 &amp;&amp; afterIndex &lt; logInputs.length &amp;&amp; fromIndex &gt;= afterIndex)</span>
<span class="nc" id="L1015">      return Double.NEGATIVE_INFINITY;</span>
<span class="nc" id="L1016">    int maxIdx = fromIndex;</span>
<span class="nc" id="L1017">    double max = logInputs[fromIndex];</span>
<span class="nc bnc" id="L1018" title="All 2 branches missed.">    for (int i = fromIndex + stride; i &lt; afterIndex; i += stride) {</span>
<span class="nc bnc" id="L1019" title="All 2 branches missed.">      if (logInputs[i] &gt; max) {</span>
<span class="nc" id="L1020">        maxIdx = i;</span>
<span class="nc" id="L1021">        max = logInputs[i];</span>
      }
    }
<span class="nc" id="L1024">    boolean haveTerms = false;</span>
<span class="nc" id="L1025">    double intermediate = 0.0;</span>
<span class="nc" id="L1026">    double cutoff = max - SloppyMath.LOGTOLERANCE;</span>
    // we avoid rearranging the array and so test indices each time!
<span class="nc bnc" id="L1028" title="All 2 branches missed.">    for (int i = fromIndex; i &lt; afterIndex; i += stride) {</span>
<span class="nc bnc" id="L1029" title="All 4 branches missed.">      if (i != maxIdx &amp;&amp; logInputs[i] &gt; cutoff) {</span>
<span class="nc" id="L1030">        haveTerms = true;</span>
<span class="nc" id="L1031">        intermediate += Math.exp(logInputs[i] - max);</span>
      }
    }
<span class="nc bnc" id="L1034" title="All 2 branches missed.">    if (haveTerms) {</span>
<span class="nc" id="L1035">      return max + Math.log(1.0 + intermediate);  // using Math.log1p(intermediate) may be more accurate, but is slower</span>
    } else {
<span class="nc" id="L1037">      return max;</span>
    }
  }

  public static double logSum(List&lt;Double&gt; logInputs) {
<span class="nc" id="L1042">    return logSum(logInputs, 0, logInputs.size());</span>
  }

  public static double logSum(List&lt;Double&gt; logInputs, int fromIndex, int toIndex) {
<span class="nc" id="L1046">    int length = logInputs.size();</span>
<span class="nc bnc" id="L1047" title="All 2 branches missed.">    if (length == 0)</span>
<span class="nc" id="L1048">      throw new IllegalArgumentException();</span>
<span class="nc bnc" id="L1049" title="All 6 branches missed.">    if(fromIndex &gt;= 0 &amp;&amp; toIndex &lt; length &amp;&amp; fromIndex &gt;= toIndex)</span>
<span class="nc" id="L1050">      return Double.NEGATIVE_INFINITY;</span>
<span class="nc" id="L1051">    int maxIdx = fromIndex;</span>
<span class="nc" id="L1052">    double max = logInputs.get(fromIndex);</span>
<span class="nc bnc" id="L1053" title="All 2 branches missed.">    for (int i = fromIndex+1; i &lt; toIndex; i++) {</span>
<span class="nc" id="L1054">      double d = logInputs.get(i);</span>
<span class="nc bnc" id="L1055" title="All 2 branches missed.">      if (d &gt; max) {</span>
<span class="nc" id="L1056">        maxIdx = i;</span>
<span class="nc" id="L1057">        max = d;</span>
      }
    }
<span class="nc" id="L1060">    boolean haveTerms = false;</span>
<span class="nc" id="L1061">    double intermediate = 0.0;</span>
<span class="nc" id="L1062">    double cutoff = max - SloppyMath.LOGTOLERANCE;</span>
    // we avoid rearranging the array and so test indices each time!
<span class="nc bnc" id="L1064" title="All 2 branches missed.">    for (int i = fromIndex; i &lt; toIndex; i++) {</span>
<span class="nc" id="L1065">      double d = logInputs.get(i);</span>
<span class="nc bnc" id="L1066" title="All 4 branches missed.">      if (i != maxIdx &amp;&amp; d &gt; cutoff) {</span>
<span class="nc" id="L1067">        haveTerms = true;</span>
<span class="nc" id="L1068">        intermediate += Math.exp(d - max);</span>
      }
    }
<span class="nc bnc" id="L1071" title="All 2 branches missed.">    if (haveTerms) {</span>
<span class="nc" id="L1072">      return max + Math.log(1.0 + intermediate);</span>
    } else {
<span class="nc" id="L1074">      return max;</span>
    }
  }


  /**
   * Returns the log of the sum of an array of numbers, which are
   * themselves input in log form.  This is all natural logarithms.
   * Reasonable care is taken to do this as efficiently as possible
   * (under the assumption that the numbers might differ greatly in
   * magnitude), with high accuracy, and without numerical overflow.
   *
   * @param logInputs An array of numbers [log(x1), ..., log(xn)]
   * @return log(x1 + ... + xn)
   */
  public static float logSum(float[] logInputs) {
<span class="nc" id="L1090">    int leng = logInputs.length;</span>
<span class="nc bnc" id="L1091" title="All 2 branches missed.">    if (leng == 0) {</span>
<span class="nc" id="L1092">      throw new IllegalArgumentException();</span>
    }
<span class="nc" id="L1094">    int maxIdx = 0;</span>
<span class="nc" id="L1095">    float max = logInputs[0];</span>
<span class="nc bnc" id="L1096" title="All 2 branches missed.">    for (int i = 1; i &lt; leng; i++) {</span>
<span class="nc bnc" id="L1097" title="All 2 branches missed.">      if (logInputs[i] &gt; max) {</span>
<span class="nc" id="L1098">        maxIdx = i;</span>
<span class="nc" id="L1099">        max = logInputs[i];</span>
      }
    }
<span class="nc" id="L1102">    boolean haveTerms = false;</span>
<span class="nc" id="L1103">    double intermediate = 0.0f;</span>
<span class="nc" id="L1104">    float cutoff = max - SloppyMath.LOGTOLERANCE_F;</span>
    // we avoid rearranging the array and so test indices each time!
<span class="nc bnc" id="L1106" title="All 2 branches missed.">    for (int i = 0; i &lt; leng; i++) {</span>
<span class="nc bnc" id="L1107" title="All 4 branches missed.">      if (i != maxIdx &amp;&amp; logInputs[i] &gt; cutoff) {</span>
<span class="nc" id="L1108">        haveTerms = true;</span>
<span class="nc" id="L1109">        intermediate += Math.exp(logInputs[i] - max);</span>
      }
    }
<span class="nc bnc" id="L1112" title="All 2 branches missed.">    if (haveTerms) {</span>
<span class="nc" id="L1113">      return max + (float) Math.log(1.0 + intermediate);</span>
    } else {
<span class="nc" id="L1115">      return max;</span>
    }
  }

  // LINEAR ALGEBRAIC FUNCTIONS

  public static double innerProduct(double[] a, double[] b) {
<span class="fc" id="L1122">    double result = 0.0;</span>
<span class="fc" id="L1123">    int len = Math.min(a.length, b.length);</span>
<span class="fc bfc" id="L1124" title="All 2 branches covered.">    for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L1125">      result += a[i] * b[i];</span>
    }
<span class="fc" id="L1127">    return result;</span>
  }

  public static double innerProduct(float[] a, float[] b) {
<span class="nc" id="L1131">    double result = 0.0;</span>
<span class="nc" id="L1132">    int len = Math.min(a.length, b.length);</span>
<span class="nc bnc" id="L1133" title="All 2 branches missed.">    for (int i = 0; i &lt; len; i++) {</span>
<span class="nc" id="L1134">      result += a[i] * b[i];</span>
    }
<span class="nc" id="L1136">    return result;</span>
  }

  // UTILITIES

  public static double[][] load2DMatrixFromFile(String filename) throws IOException {
<span class="nc" id="L1142">    String s = IOUtils.slurpFile(filename);</span>
<span class="nc" id="L1143">    String[] rows = s.split(&quot;[\r\n]+&quot;);</span>
<span class="nc" id="L1144">    double[][] result = new double[rows.length][];</span>
<span class="nc bnc" id="L1145" title="All 2 branches missed.">    for (int i=0; i&lt;result.length; i++) {</span>
<span class="nc" id="L1146">      String[] columns = rows[i].split(&quot;\\s+&quot;);</span>
<span class="nc" id="L1147">      result[i] = new double[columns.length];</span>
<span class="nc bnc" id="L1148" title="All 2 branches missed.">      for (int j=0; j&lt;result[i].length; j++) {</span>
<span class="nc" id="L1149">        result[i][j] = Double.parseDouble(columns[j]);</span>
      }
    }
<span class="nc" id="L1152">    return result;</span>
  }

  public static Integer[] box(int[] assignment) {
<span class="nc" id="L1156">    Integer[] result = new Integer[assignment.length];</span>
<span class="nc bnc" id="L1157" title="All 2 branches missed.">    for (int i=0; i&lt;assignment.length; i++) {</span>
<span class="nc" id="L1158">      result[i] = Integer.valueOf(assignment[i]);</span>
    }
<span class="nc" id="L1160">    return result;</span>
  }

  public static int[] unboxToInt(Collection&lt;Integer&gt; list) {
<span class="nc" id="L1164">    int[] result = new int[list.size()];</span>
<span class="nc" id="L1165">    int i = 0;</span>
<span class="nc bnc" id="L1166" title="All 2 branches missed.">    for (int v : list) {</span>
<span class="nc" id="L1167">      result[i++] = v;</span>
<span class="nc" id="L1168">    }</span>
<span class="nc" id="L1169">    return result;</span>
  }

  public static Double[] box(double[] assignment) {
<span class="nc" id="L1173">    Double[] result = new Double[assignment.length];</span>
<span class="nc bnc" id="L1174" title="All 2 branches missed.">    for (int i=0; i&lt;assignment.length; i++) {</span>
<span class="nc" id="L1175">      result[i] = Double.valueOf(assignment[i]);</span>
    }
<span class="nc" id="L1177">    return result;</span>
  }

  public static double[] unbox(Collection&lt;Double&gt; list) {
<span class="fc" id="L1181">    double[] result = new double[list.size()];</span>
<span class="fc" id="L1182">    int i = 0;</span>
<span class="fc bfc" id="L1183" title="All 2 branches covered.">    for (double v : list) {</span>
<span class="fc" id="L1184">      result[i++] = v;</span>
<span class="fc" id="L1185">    }</span>
<span class="fc" id="L1186">    return result;</span>
  }

  public static int indexOf(int n, int[] a) {
<span class="nc bnc" id="L1190" title="All 2 branches missed.">    for (int i=0; i&lt;a.length; i++) {</span>
<span class="nc bnc" id="L1191" title="All 2 branches missed.">      if (a[i]==n) return i;</span>
    }
<span class="nc" id="L1193">    return -1;</span>
  }

  public static int[][] castToInt(double[][] doubleCounts) {
<span class="nc" id="L1197">    int[][] result = new int[doubleCounts.length][];</span>
<span class="nc bnc" id="L1198" title="All 2 branches missed.">    for (int i=0; i&lt;doubleCounts.length; i++) {</span>
<span class="nc" id="L1199">      result[i] = new int[doubleCounts[i].length];</span>
<span class="nc bnc" id="L1200" title="All 2 branches missed.">      for (int j=0; j&lt;doubleCounts[i].length; j++) {</span>
<span class="nc" id="L1201">        result[i][j] = (int) doubleCounts[i][j];</span>
      }
    }
<span class="nc" id="L1204">    return result;</span>
  }

  // PROBABILITY FUNCTIONS

  /**
   * Makes the values in this array sum to 1.0. Does it in place.
   * If the total is 0.0 or NaN, throws an RuntimeException.
   */
  public static void normalize(double[] a) {
<span class="fc" id="L1214">    double total = sum(a);</span>
<span class="pc bpc" id="L1215" title="2 of 4 branches missed.">    if (total == 0.0 || Double.isNaN(total)) {</span>
<span class="nc" id="L1216">      throw new RuntimeException(&quot;Can't normalize an array with sum 0.0 or NaN: &quot; + Arrays.toString(a));</span>
    }
<span class="fc" id="L1218">    multiplyInPlace(a, 1.0/total); // divide each value by total</span>
<span class="fc" id="L1219">  }</span>

  public static void L1normalize(double[] a) {
<span class="nc" id="L1222">    double total = L1Norm(a);</span>
<span class="nc bnc" id="L1223" title="All 4 branches missed.">    if (total == 0.0 || Double.isNaN(total)) {</span>
<span class="nc bnc" id="L1224" title="All 2 branches missed.">      if (a.length &lt; 100) {</span>
<span class="nc" id="L1225">        throw new RuntimeException(&quot;Can't normalize an array with sum 0.0 or NaN: &quot; + Arrays.toString(a));</span>
      } else {
<span class="nc" id="L1227">        double[] aTrunc = new double[100];</span>
<span class="nc" id="L1228">        System.arraycopy(a, 0, aTrunc, 0, 100);</span>
<span class="nc" id="L1229">        throw new RuntimeException(&quot;Can't normalize an array with sum 0.0 or NaN: &quot; + Arrays.toString(aTrunc) + &quot; ... &quot;);</span>
      }

    }
<span class="nc" id="L1233">    multiplyInPlace(a, 1.0/total); // divide each value by total</span>
<span class="nc" id="L1234">  }</span>
  public static void L2normalize(double[] a) {
<span class="nc" id="L1236">    double total = L2Norm(a);</span>
<span class="nc bnc" id="L1237" title="All 4 branches missed.">    if (total == 0.0 || Double.isNaN(total)) {</span>
<span class="nc bnc" id="L1238" title="All 2 branches missed.">      if (a.length &lt; 100) {</span>
<span class="nc" id="L1239">        throw new RuntimeException(&quot;Can't normalize an array with sum 0.0 or NaN: &quot; + Arrays.toString(a));</span>
      } else {
<span class="nc" id="L1241">        double[] aTrunc = new double[100];</span>
<span class="nc" id="L1242">        System.arraycopy(a, 0, aTrunc, 0, 100);</span>
<span class="nc" id="L1243">        throw new RuntimeException(&quot;Can't normalize an array with sum 0.0 or NaN: &quot; + Arrays.toString(aTrunc) + &quot; ... &quot;);</span>
      }

    }
<span class="nc" id="L1247">    multiplyInPlace(a, 1.0/total); // divide each value by total</span>
<span class="nc" id="L1248">  }</span>

  /**
   * Makes the values in this array sum to 1.0. Does it in place.
   * If the total is 0.0 or NaN, throws an RuntimeException.
   */
  public static void normalize(float[] a) {
<span class="nc" id="L1255">    float total = sum(a);</span>
<span class="nc bnc" id="L1256" title="All 4 branches missed.">    if (total == 0.0f || Double.isNaN(total)) {</span>
<span class="nc" id="L1257">      throw new RuntimeException(&quot;Can't normalize an array with sum 0.0 or NaN&quot;);</span>
    }
<span class="nc" id="L1259">    multiplyInPlace(a, 1.0f/total); // divide each value by total</span>
<span class="nc" id="L1260">  }</span>
  public static void L2normalize(float[] a) {
<span class="nc" id="L1262">    float total = L2Norm(a);</span>
<span class="nc bnc" id="L1263" title="All 4 branches missed.">    if (total == 0.0 || Float.isNaN(total)) {</span>
<span class="nc bnc" id="L1264" title="All 2 branches missed.">      if (a.length &lt; 100) {</span>
<span class="nc" id="L1265">        throw new RuntimeException(&quot;Can't normalize an array with sum 0.0 or NaN: &quot; + Arrays.toString(a));</span>
      } else {
<span class="nc" id="L1267">        float[] aTrunc = new float[100];</span>
<span class="nc" id="L1268">        System.arraycopy(a, 0, aTrunc, 0, 100);</span>
<span class="nc" id="L1269">        throw new RuntimeException(&quot;Can't normalize an array with sum 0.0 or NaN: &quot; + Arrays.toString(aTrunc) + &quot; ... &quot;);</span>
      }

    }
<span class="nc" id="L1273">    multiplyInPlace(a, 1.0/total); // divide each value by total</span>
<span class="nc" id="L1274">  }</span>

  /**
   * Standardize values in this array, i.e., subtract the mean and divide by the standard deviation.
   * If standard deviation is 0.0, throws a RuntimeException.
   */
  public static void standardize(double[] a) {
<span class="nc" id="L1281">    double m = mean(a);</span>
<span class="nc bnc" id="L1282" title="All 2 branches missed.">    if (Double.isNaN(m)) {</span>
<span class="nc" id="L1283">      throw new RuntimeException(&quot;Can't standardize array whose mean is NaN&quot;);</span>
    }
<span class="nc" id="L1285">    double s = stdev(a);</span>
<span class="nc bnc" id="L1286" title="All 4 branches missed.">    if (s == 0.0 || Double.isNaN(s)) {</span>
<span class="nc" id="L1287">      throw new RuntimeException(&quot;Can't standardize array whose standard deviation is 0.0 or NaN&quot;);</span>
    }
<span class="nc" id="L1289">    addInPlace(a, -m); // subtract mean</span>
<span class="nc" id="L1290">    multiplyInPlace(a, 1.0/s); // divide by standard deviation</span>
<span class="nc" id="L1291">  }</span>

  public static double L2Norm(double[] a) {
<span class="nc" id="L1294">    double result = 0.0;</span>
<span class="nc bnc" id="L1295" title="All 2 branches missed.">    for(double d: a) {</span>
<span class="nc" id="L1296">      result += Math.pow(d,2);</span>
    }
<span class="nc" id="L1298">    return Math.sqrt(result);</span>
  }
  public static float L2Norm(float[] a) {
<span class="nc" id="L1301">    double result = 0;</span>
<span class="nc bnc" id="L1302" title="All 2 branches missed.">    for(float d: a) {</span>
<span class="nc" id="L1303">      result += Math.pow(d,2);</span>
    }
<span class="nc" id="L1305">    return (float) Math.sqrt(result);</span>
  }

  public static double L1Norm(double[] a) {
<span class="nc" id="L1309">    double result = 0.0;</span>
<span class="nc bnc" id="L1310" title="All 2 branches missed.">    for (double d: a) {</span>
<span class="nc" id="L1311">      result += Math.abs(d);</span>
    }
<span class="nc" id="L1313">    return result;</span>
  }

  /**
   * Makes the values in this array sum to 1.0. Does it in place.
   * If the total is 0.0, throws a RuntimeException.
   * If the total is Double.NEGATIVE_INFINITY, then it replaces the
   * array with a normalized uniform distribution. CDM: This last bit is
   * weird!  Do we really want that?
   */
  public static void logNormalize(double[] a) {
<span class="nc" id="L1324">    double logTotal = logSum(a);</span>
<span class="nc bnc" id="L1325" title="All 2 branches missed.">    if (logTotal == Double.NEGATIVE_INFINITY) {</span>
      // to avoid NaN values
<span class="nc" id="L1327">      double v = -Math.log(a.length);</span>
<span class="nc bnc" id="L1328" title="All 2 branches missed.">      for (int i = 0; i &lt; a.length; i++) {</span>
<span class="nc" id="L1329">        a[i] = v;</span>
      }
<span class="nc" id="L1331">      return;</span>
    }
<span class="nc" id="L1333">    addInPlace(a, -logTotal); // subtract log total from each value</span>
<span class="nc" id="L1334">  }</span>

  /**
   * Samples from the distribution over values 0 through d.length given by d.
   * Assumes that the distribution sums to 1.0.
   *
   * @param d the distribution to sample from
   * @return a value from 0 to d.length
   */
  public static int sampleFromDistribution(double[] d) {
<span class="fc" id="L1344">    return sampleFromDistribution(d, rand);</span>
  }

  /**
   * Samples from the distribution over values 0 through d.length given by d.
   * Assumes that the distribution sums to 1.0.
   *
   * @param d the distribution to sample from
   * @return a value from 0 to d.length
   */
  public static int sampleFromDistribution(double[] d, Random random) {
    // sample from the uniform [0,1]
<span class="fc" id="L1356">    double r = random.nextDouble();</span>
    // now compare its value to cumulative values to find what interval it falls in
<span class="fc" id="L1358">    double total = 0;</span>
<span class="fc bfc" id="L1359" title="All 2 branches covered.">    for (int i = 0; i &lt; d.length - 1; i++) {</span>
<span class="pc bpc" id="L1360" title="1 of 2 branches missed.">      if (Double.isNaN(d[i])) {</span>
<span class="nc" id="L1361">        throw new RuntimeException(&quot;Can't sample from NaN&quot;);</span>
      }
<span class="fc" id="L1363">      total += d[i];</span>
<span class="fc bfc" id="L1364" title="All 2 branches covered.">      if (r &lt; total) {</span>
<span class="fc" id="L1365">        return i;</span>
      }
    }
<span class="fc" id="L1368">    return d.length - 1; // in case the &quot;double-math&quot; didn't total to exactly 1.0</span>
  }

  /**
   * Samples from the distribution over values 0 through d.length given by d.
   * Assumes that the distribution sums to 1.0.
   *
   * @param d the distribution to sample from
   * @return a value from 0 to d.length
   */
  public static int sampleFromDistribution(float[] d, Random random) {
    // sample from the uniform [0,1]
<span class="nc" id="L1380">    double r = random.nextDouble();</span>
    // now compare its value to cumulative values to find what interval it falls in
<span class="nc" id="L1382">    double total = 0;</span>
<span class="nc bnc" id="L1383" title="All 2 branches missed.">    for (int i = 0; i &lt; d.length - 1; i++) {</span>
<span class="nc bnc" id="L1384" title="All 2 branches missed.">      if (Float.isNaN(d[i])) {</span>
<span class="nc" id="L1385">        throw new RuntimeException(&quot;Can't sample from NaN&quot;);</span>
      }
<span class="nc" id="L1387">      total += d[i];</span>
<span class="nc bnc" id="L1388" title="All 2 branches missed.">      if (r &lt; total) {</span>
<span class="nc" id="L1389">        return i;</span>
      }
    }
<span class="nc" id="L1392">    return d.length - 1; // in case the &quot;double-math&quot; didn't total to exactly 1.0</span>
  }

  public static double klDivergence(double[] from, double[] to) {
<span class="fc" id="L1396">    double kl = 0.0;</span>
<span class="fc" id="L1397">    double tot = sum(from);</span>
<span class="fc" id="L1398">    double tot2 = sum(to);</span>
    // System.out.println(&quot;tot is &quot; + tot + &quot; tot2 is &quot; + tot2);
<span class="fc bfc" id="L1400" title="All 2 branches covered.">    for (int i = 0; i &lt; from.length; i++) {</span>
<span class="fc bfc" id="L1401" title="All 2 branches covered.">      if (from[i] == 0.0) {</span>
<span class="fc" id="L1402">        continue;</span>
      }
<span class="fc" id="L1404">      double num = from[i] / tot;</span>
<span class="fc" id="L1405">      double num2 = to[i] / tot2;</span>
      // System.out.println(&quot;num is &quot; + num + &quot; num2 is &quot; + num2);
<span class="fc" id="L1407">      kl += num * (Math.log(num / num2) / Math.log(2.0));</span>
    }
<span class="fc" id="L1409">    return kl;</span>
  }

  /**
   * Returns the Jensen Shannon divergence (information radius) between
   * a and b, defined as the average of the kl divergences from a to b
   * and from b to a.
   */
  public static double jensenShannonDivergence(double[] a, double[] b) {
<span class="fc" id="L1418">    double[] average = pairwiseAdd(a, b);</span>
<span class="fc" id="L1419">    multiplyInPlace(average, .5);</span>
<span class="fc" id="L1420">    return .5 * klDivergence(a, average) + .5 * klDivergence(b, average);</span>
  }

  public static void setToLogDeterministic(float[] a, int i) {
<span class="nc bnc" id="L1424" title="All 2 branches missed.">    for (int j = 0; j &lt; a.length; j++) {</span>
<span class="nc bnc" id="L1425" title="All 2 branches missed.">      if (j == i) {</span>
<span class="nc" id="L1426">        a[j] = 0.0F;</span>
      } else {
<span class="nc" id="L1428">        a[j] = Float.NEGATIVE_INFINITY;</span>
      }
    }
<span class="nc" id="L1431">  }</span>

  public static void setToLogDeterministic(double[] a, int i) {
<span class="nc bnc" id="L1434" title="All 2 branches missed.">    for (int j = 0; j &lt; a.length; j++) {</span>
<span class="nc bnc" id="L1435" title="All 2 branches missed.">      if (j == i) {</span>
<span class="nc" id="L1436">        a[j] = 0.0;</span>
      } else {
<span class="nc" id="L1438">        a[j] = Double.NEGATIVE_INFINITY;</span>
      }
    }
<span class="nc" id="L1441">  }</span>

  // SAMPLE ANALYSIS

  public static double mean(double[] a) {
<span class="fc" id="L1446">    return sum(a) / a.length;</span>
  }

  /** Return the mean of an array of int. */
  public static double mean(int[] a) {
<span class="nc" id="L1451">    return ((double) sum(a)) / a.length;</span>
  }

  public static double median(double[] a) {
<span class="nc" id="L1455">    double[] b = new double[a.length];</span>
<span class="nc" id="L1456">    System.arraycopy(a, 0, b, 0, b.length);</span>
<span class="nc" id="L1457">    Arrays.sort(b);</span>
<span class="nc" id="L1458">    int mid = b.length / 2;</span>
<span class="nc bnc" id="L1459" title="All 2 branches missed.">    if (b.length % 2 == 0) {</span>
<span class="nc" id="L1460">      return (b[mid - 1] + b[mid]) / 2.0;</span>
    } else {
<span class="nc" id="L1462">      return b[mid];</span>
    }
  }

  /**
   * Returns the mean of a vector of doubles.  Any values which are NaN or
   * infinite are ignored.  If the vector is empty, 0.0 is returned.
   */
  public static double safeMean(double[] v) {
<span class="fc" id="L1471">    double[] u = filterNaNAndInfinite(v);</span>
<span class="pc bpc" id="L1472" title="1 of 2 branches missed.">    if (numRows(u) == 0) return 0.0;</span>
<span class="fc" id="L1473">    return mean(u);</span>
  }

  public static double sumSquaredError(double[] a) {
<span class="nc" id="L1477">    double mean = mean(a);</span>
<span class="nc" id="L1478">    double result = 0.0;</span>
<span class="nc bnc" id="L1479" title="All 2 branches missed.">    for (double anA : a) {</span>
<span class="nc" id="L1480">      double diff = anA - mean;</span>
<span class="nc" id="L1481">      result += (diff * diff);</span>
    }
<span class="nc" id="L1483">    return result;</span>
  }

  public static double sumSquared(double[] a) {
<span class="nc" id="L1487">    double result = 0.0;</span>
<span class="nc bnc" id="L1488" title="All 2 branches missed.">    for (double anA : a) {</span>
<span class="nc" id="L1489">      result += (anA * anA);</span>
    }
<span class="nc" id="L1491">    return result;</span>
  }

  public static double variance(double[] a) {
<span class="nc" id="L1495">    return sumSquaredError(a) / (a.length - 1);</span>
  }

  public static double stdev(double[] a) {
<span class="nc" id="L1499">    return Math.sqrt(variance(a));</span>
  }

  /**
   * Returns the standard deviation of a vector of doubles.  Any values which
   * are NaN or infinite are ignored.  If the vector contains fewer than two
   * values, 1.0 is returned.
   */
  public static double safeStdev(double[] v) {
<span class="nc" id="L1508">    double[] u = filterNaNAndInfinite(v);</span>
<span class="nc bnc" id="L1509" title="All 2 branches missed.">    if (numRows(u) &lt; 2) return 1.0;</span>
<span class="nc" id="L1510">    return stdev(u);</span>
  }

  public static double standardErrorOfMean(double[] a) {
<span class="nc" id="L1514">    return stdev(a) / Math.sqrt(a.length);</span>
  }


  /**
   * Fills the array with sample from 0 to numArgClasses-1 without replacement.
   */
  public static void sampleWithoutReplacement(int[] array, int numArgClasses) {
<span class="nc" id="L1522">    sampleWithoutReplacement(array, numArgClasses, rand);</span>
<span class="nc" id="L1523">  }</span>
  /**
   * Fills the array with sample from 0 to numArgClasses-1 without replacement.
   */
  public static void sampleWithoutReplacement(int[] array, int numArgClasses, Random rand) {
<span class="nc" id="L1528">    int[] temp = new int[numArgClasses];</span>
<span class="nc bnc" id="L1529" title="All 2 branches missed.">    for (int i = 0; i &lt; temp.length; i++) {</span>
<span class="nc" id="L1530">      temp[i] = i;</span>
    }
<span class="nc" id="L1532">    shuffle(temp, rand);</span>
<span class="nc" id="L1533">    System.arraycopy(temp, 0, array, 0, array.length);</span>
<span class="nc" id="L1534">  }</span>

  public static void shuffle(int[] a) {
<span class="nc" id="L1537">    shuffle(a, rand);</span>
<span class="nc" id="L1538">  }</span>

  /* Shuffle the integers in an array using a source of randomness.
   * Uses the Fisher-Yates shuffle. Makes all orderings equally likely, iff
   * the randomizer is good.
   *
   * @param a The array to shuffle
   * @param rand The source of randomness
   */
  public static void shuffle(int[] a, Random rand) {
<span class="nc bnc" id="L1548" title="All 2 branches missed.">    for (int i = a.length - 1; i &gt; 0; i--) {</span>
<span class="nc" id="L1549">      int j = rand.nextInt(i+1); // a random index from 0 to i inclusive, may shuffle with itself</span>
<span class="nc" id="L1550">      int tmp = a[i];</span>
<span class="nc" id="L1551">      a[i] = a[j];</span>
<span class="nc" id="L1552">      a[j] = tmp;</span>
    }
<span class="nc" id="L1554">  }</span>

  public static void reverse(int[] a) {
<span class="nc bnc" id="L1557" title="All 2 branches missed.">    for (int i=0; i&lt;a.length/2; i++) {</span>
<span class="nc" id="L1558">      int j = a.length - i - 1;</span>
<span class="nc" id="L1559">      int tmp = a[i];</span>
<span class="nc" id="L1560">      a[i] = a[j];</span>
<span class="nc" id="L1561">      a[j] = tmp;</span>
    }
<span class="nc" id="L1563">  }</span>

  public static boolean contains(int[] a, int i) {
<span class="nc bnc" id="L1566" title="All 2 branches missed.">    for (int k : a) {</span>
<span class="nc bnc" id="L1567" title="All 2 branches missed.">      if (k == i) return true;</span>
    }
<span class="nc" id="L1569">    return false;</span>
  }

  public static boolean containsInSubarray(int[] a, int begin, int end, int i) {
<span class="nc bnc" id="L1573" title="All 2 branches missed.">    for (int j = begin; j &lt; end; j++) {</span>
<span class="nc bnc" id="L1574" title="All 2 branches missed.">      if (a[j]==i) return true;</span>
    }
<span class="nc" id="L1576">    return false;</span>
  }

  /**
   * Direct computation of Pearson product-moment correlation coefficient.
   * Note that if x and y are involved in several computations of
   * pearsonCorrelation, it is perhaps more advisable to first standardize
   * x and y, then compute innerProduct(x,y)/(x.length-1).
   */
  public static double pearsonCorrelation(double[] x, double[] y) {
    double result;
<span class="fc" id="L1587">    double sum_sq_x = 0, sum_sq_y = 0;</span>
<span class="fc" id="L1588">    double mean_x = x[0], mean_y = y[0];</span>
<span class="fc" id="L1589">    double sum_coproduct = 0;</span>
<span class="fc bfc" id="L1590" title="All 2 branches covered.">    for(int i=2; i&lt;x.length+1;++i) {</span>
<span class="fc" id="L1591">      double w = (i - 1)*1.0/i;</span>
<span class="fc" id="L1592">      double delta_x = x[i-1] - mean_x;</span>
<span class="fc" id="L1593">      double delta_y = y[i-1] - mean_y;</span>
<span class="fc" id="L1594">      sum_sq_x += delta_x * delta_x*w;</span>
<span class="fc" id="L1595">      sum_sq_y += delta_y * delta_y*w;</span>
<span class="fc" id="L1596">      sum_coproduct += delta_x * delta_y*w;</span>
<span class="fc" id="L1597">      mean_x += delta_x / i;</span>
<span class="fc" id="L1598">      mean_y += delta_y / i;</span>
    }
<span class="fc" id="L1600">    double pop_sd_x = Math.sqrt(sum_sq_x/x.length);</span>
<span class="fc" id="L1601">    double pop_sd_y = Math.sqrt(sum_sq_y/y.length);</span>
<span class="fc" id="L1602">    double cov_x_y = sum_coproduct / x.length;</span>
<span class="fc" id="L1603">    double denom = pop_sd_x*pop_sd_y;</span>
<span class="pc bpc" id="L1604" title="1 of 2 branches missed.">    if(denom == 0.0)</span>
<span class="nc" id="L1605">      return 0.0;</span>
<span class="fc" id="L1606">    result = cov_x_y/denom;</span>
<span class="fc" id="L1607">    return result;</span>
  }

  /**
   * Computes the significance level by approximate randomization, using a
   * default value of 1000 iterations.  See documentation for other version
   * of method.
   */
  public static double sigLevelByApproxRand(double[] A, double[] B) {
<span class="nc" id="L1616">    return sigLevelByApproxRand(A, B, 1000);</span>
  }

  /**
   * Takes a pair of arrays, A and B, which represent corresponding
   * outcomes of a pair of random variables: say, results for two different
   * classifiers on a sequence of inputs.  Returns the estimated
   * probability that the difference between the means of A and B is not
   * significant, that is, the significance level.  This is computed by
   * &quot;approximate randomization&quot;.  The test statistic is the absolute
   * difference between the means of the two arrays.  A randomized test
   * statistic is computed the same way after initially randomizing the
   * arrays by swapping each pair of elements with 50% probability.  For
   * the given number of iterations, we generate a randomized test
   * statistic and compare it to the actual test statistic.  The return
   * value is the proportion of iterations in which a randomized test
   * statistic was found to exceed the actual test statistic.
   *
   * @param A Outcome of one r.v.
   * @param B Outcome of another r.v.
   * @return Significance level by randomization
   */
  public static double sigLevelByApproxRand(double[] A, double[] B, int iterations) {
<span class="nc bnc" id="L1639" title="All 2 branches missed.">    if (A.length == 0)</span>
<span class="nc" id="L1640">      throw new IllegalArgumentException(&quot;Input arrays must not be empty!&quot;);</span>
<span class="nc bnc" id="L1641" title="All 2 branches missed.">    if (A.length != B.length)</span>
<span class="nc" id="L1642">      throw new IllegalArgumentException(&quot;Input arrays must have equal length!&quot;);</span>
<span class="nc bnc" id="L1643" title="All 2 branches missed.">    if (iterations &lt;= 0)</span>
<span class="nc" id="L1644">      throw new IllegalArgumentException(&quot;Number of iterations must be positive!&quot;);</span>
<span class="nc" id="L1645">    double testStatistic = absDiffOfMeans(A, B, false); // not randomized</span>
<span class="nc" id="L1646">    int successes = 0;</span>
<span class="nc bnc" id="L1647" title="All 2 branches missed.">    for (int i = 0; i &lt; iterations; i++) {</span>
<span class="nc" id="L1648">      double t =  absDiffOfMeans(A, B, true); // randomized</span>
<span class="nc bnc" id="L1649" title="All 2 branches missed.">      if (t &gt;= testStatistic) successes++;</span>
    }
<span class="nc" id="L1651">    return (double) (successes + 1) / (double) (iterations + 1);</span>
  }

  public static double sigLevelByApproxRand(int[] A, int[] B) {
<span class="nc" id="L1655">    return sigLevelByApproxRand(A, B, 1000);</span>
  }

  public static double sigLevelByApproxRand(int[] A, int[] B, int iterations) {
<span class="nc bnc" id="L1659" title="All 2 branches missed.">    if (A.length == 0)</span>
<span class="nc" id="L1660">      throw new IllegalArgumentException(&quot;Input arrays must not be empty!&quot;);</span>
<span class="nc bnc" id="L1661" title="All 2 branches missed.">    if (A.length != B.length)</span>
<span class="nc" id="L1662">      throw new IllegalArgumentException(&quot;Input arrays must have equal length!&quot;);</span>
<span class="nc bnc" id="L1663" title="All 2 branches missed.">    if (iterations &lt;= 0)</span>
<span class="nc" id="L1664">      throw new IllegalArgumentException(&quot;Number of iterations must be positive!&quot;);</span>
<span class="nc" id="L1665">    double[] X = new double[A.length];</span>
<span class="nc" id="L1666">    double[] Y = new double[B.length];</span>
<span class="nc bnc" id="L1667" title="All 2 branches missed.">    for (int i = 0; i &lt; A.length; i++) {</span>
<span class="nc" id="L1668">      X[i] = A[i];</span>
<span class="nc" id="L1669">      Y[i] = B[i];</span>
    }
<span class="nc" id="L1671">    return sigLevelByApproxRand(X, Y, iterations);</span>
  }

  public static double sigLevelByApproxRand(boolean[] A, boolean[] B) {
<span class="nc" id="L1675">    return sigLevelByApproxRand(A, B, 1000);</span>
  }

  public static double sigLevelByApproxRand(boolean[] A, boolean[] B, int iterations) {
<span class="nc bnc" id="L1679" title="All 2 branches missed.">    if (A.length == 0)</span>
<span class="nc" id="L1680">      throw new IllegalArgumentException(&quot;Input arrays must not be empty!&quot;);</span>
<span class="nc bnc" id="L1681" title="All 2 branches missed.">    if (A.length != B.length)</span>
<span class="nc" id="L1682">      throw new IllegalArgumentException(&quot;Input arrays must have equal length!&quot;);</span>
<span class="nc bnc" id="L1683" title="All 2 branches missed.">    if (iterations &lt;= 0)</span>
<span class="nc" id="L1684">      throw new IllegalArgumentException(&quot;Number of iterations must be positive!&quot;);</span>
<span class="nc" id="L1685">    double[] X = new double[A.length];</span>
<span class="nc" id="L1686">    double[] Y = new double[B.length];</span>
<span class="nc bnc" id="L1687" title="All 2 branches missed.">    for (int i = 0; i &lt; A.length; i++) {</span>
<span class="nc bnc" id="L1688" title="All 2 branches missed.">      X[i] = (A[i] ? 1.0 : 0.0);</span>
<span class="nc bnc" id="L1689" title="All 2 branches missed.">      Y[i] = (B[i] ? 1.0 : 0.0);</span>
    }
<span class="nc" id="L1691">    return sigLevelByApproxRand(X, Y, iterations);</span>
  }


  // Returns the absolute difference between the means of arrays A and B.
  // If 'randomize' is true, swaps matched A &amp; B entries with 50% probability
  // Assumes input arrays have equal, non-zero length.
  private static double absDiffOfMeans(double[] A, double[] B, boolean randomize) {
<span class="nc" id="L1699">    Random random = new Random();</span>
<span class="nc" id="L1700">    double aTotal = 0.0;</span>
<span class="nc" id="L1701">    double bTotal = 0.0;</span>
<span class="nc bnc" id="L1702" title="All 2 branches missed.">    for (int i = 0; i &lt; A.length; i++) {</span>
<span class="nc bnc" id="L1703" title="All 4 branches missed.">      if (randomize &amp;&amp; random.nextBoolean()) {</span>
<span class="nc" id="L1704">        aTotal += B[i];</span>
<span class="nc" id="L1705">        bTotal += A[i];</span>
      } else {
<span class="nc" id="L1707">        aTotal += A[i];</span>
<span class="nc" id="L1708">        bTotal += B[i];</span>
      }
    }
<span class="nc" id="L1711">    double aMean = aTotal / A.length;</span>
<span class="nc" id="L1712">    double bMean = bTotal / B.length;</span>
<span class="nc" id="L1713">    return Math.abs(aMean - bMean);</span>
  }

  // PRINTING FUNCTIONS

  public static String toBinaryString(byte[] b) {
<span class="nc" id="L1719">    StringBuilder s = new StringBuilder();</span>
<span class="nc bnc" id="L1720" title="All 2 branches missed.">    for (byte by : b) {</span>
<span class="nc bnc" id="L1721" title="All 2 branches missed.">      for (int j = 7; j &gt;= 0; j--) {</span>
<span class="nc bnc" id="L1722" title="All 2 branches missed.">        if ((by &amp; (1 &lt;&lt; j)) &gt; 0) {</span>
<span class="nc" id="L1723">          s.append('1');</span>
        } else {
<span class="nc" id="L1725">          s.append('0');</span>
        }
      }
<span class="nc" id="L1728">      s.append(' ');</span>
    }
<span class="nc" id="L1730">    return s.toString();</span>
  }

  public static String toString(double[] a) {
<span class="nc" id="L1734">    return toString(a, null);</span>
  }

  public static String toString(double[] a, NumberFormat nf) {
<span class="nc bnc" id="L1738" title="All 2 branches missed.">    if (a == null) return null;</span>
<span class="nc bnc" id="L1739" title="All 2 branches missed.">    if (a.length == 0) return &quot;[]&quot;;</span>
<span class="nc" id="L1740">    StringBuilder b = new StringBuilder();</span>
<span class="nc" id="L1741">    b.append('[');</span>
<span class="nc bnc" id="L1742" title="All 2 branches missed.">    for (int i = 0; i &lt; a.length - 1; i++) {</span>
      String s;
<span class="nc bnc" id="L1744" title="All 2 branches missed.">      if (nf == null) {</span>
<span class="nc" id="L1745">        s = String.valueOf(a[i]);</span>
      } else {
<span class="nc" id="L1747">        s = nf.format(a[i]);</span>
      }
<span class="nc" id="L1749">      b.append(s);</span>
<span class="nc" id="L1750">      b.append(&quot;, &quot;);</span>
    }
    String s;
<span class="nc bnc" id="L1753" title="All 2 branches missed.">    if (nf == null) {</span>
<span class="nc" id="L1754">      s = String.valueOf(a[a.length - 1]);</span>
    } else {
<span class="nc" id="L1756">      s = nf.format(a[a.length - 1]);</span>
    }
<span class="nc" id="L1758">    b.append(s);</span>
<span class="nc" id="L1759">    b.append(']');</span>
<span class="nc" id="L1760">    return b.toString();</span>
  }

  public static String toString(float[] a) {
<span class="nc" id="L1764">    return toString(a, null);</span>
  }

  public static String toString(float[] a, NumberFormat nf) {
<span class="nc bnc" id="L1768" title="All 2 branches missed.">    if (a == null) return null;</span>
<span class="nc bnc" id="L1769" title="All 2 branches missed.">    if (a.length == 0) return &quot;[]&quot;;</span>
<span class="nc" id="L1770">    StringBuilder b = new StringBuilder();</span>
<span class="nc" id="L1771">    b.append('[');</span>
<span class="nc bnc" id="L1772" title="All 2 branches missed.">    for (int i = 0; i &lt; a.length - 1; i++) {</span>
      String s;
<span class="nc bnc" id="L1774" title="All 2 branches missed.">      if (nf == null) {</span>
<span class="nc" id="L1775">        s = String.valueOf(a[i]);</span>
      } else {
<span class="nc" id="L1777">        s = nf.format(a[i]);</span>
      }
<span class="nc" id="L1779">      b.append(s);</span>
<span class="nc" id="L1780">      b.append(&quot;, &quot;);</span>
    }
    String s;
<span class="nc bnc" id="L1783" title="All 2 branches missed.">    if (nf == null) {</span>
<span class="nc" id="L1784">      s = String.valueOf(a[a.length - 1]);</span>
    } else {
<span class="nc" id="L1786">      s = nf.format(a[a.length - 1]);</span>
    }
<span class="nc" id="L1788">    b.append(s);</span>
<span class="nc" id="L1789">    b.append(']');</span>
<span class="nc" id="L1790">    return b.toString();</span>
  }

  public static String toString(int[] a) {
<span class="nc" id="L1794">    return toString(a, null);</span>
  }

  public static String toString(int[] a, NumberFormat nf) {
<span class="nc bnc" id="L1798" title="All 2 branches missed.">    if (a == null) return null;</span>
<span class="nc bnc" id="L1799" title="All 2 branches missed.">    if (a.length == 0) return &quot;[]&quot;;</span>
<span class="nc" id="L1800">    StringBuilder b = new StringBuilder();</span>
<span class="nc" id="L1801">    b.append('[');</span>
<span class="nc bnc" id="L1802" title="All 2 branches missed.">    for (int i = 0; i &lt; a.length - 1; i++) {</span>
      String s;
<span class="nc bnc" id="L1804" title="All 2 branches missed.">      if (nf == null) {</span>
<span class="nc" id="L1805">        s = String.valueOf(a[i]);</span>
      } else {
<span class="nc" id="L1807">        s = nf.format(a[i]);</span>
      }
<span class="nc" id="L1809">      b.append(s);</span>
<span class="nc" id="L1810">      b.append(&quot;, &quot;);</span>
    }
    String s;
<span class="nc bnc" id="L1813" title="All 2 branches missed.">    if (nf == null) {</span>
<span class="nc" id="L1814">      s = String.valueOf(a[a.length - 1]);</span>
    } else {
<span class="nc" id="L1816">      s = nf.format(a[a.length - 1]);</span>
    }
<span class="nc" id="L1818">    b.append(s);</span>
<span class="nc" id="L1819">    b.append(']');</span>
<span class="nc" id="L1820">    return b.toString();</span>
  }

  public static String toString(byte[] a) {
<span class="nc" id="L1824">    return toString(a, null);</span>
  }

  public static String toString(byte[] a, NumberFormat nf) {
<span class="nc bnc" id="L1828" title="All 2 branches missed.">    if (a == null) return null;</span>
<span class="nc bnc" id="L1829" title="All 2 branches missed.">    if (a.length == 0) return &quot;[]&quot;;</span>
<span class="nc" id="L1830">    StringBuilder b = new StringBuilder();</span>
<span class="nc" id="L1831">    b.append('[');</span>
<span class="nc bnc" id="L1832" title="All 2 branches missed.">    for (int i = 0; i &lt; a.length - 1; i++) {</span>
      String s;
<span class="nc bnc" id="L1834" title="All 2 branches missed.">      if (nf == null) {</span>
<span class="nc" id="L1835">        s = String.valueOf(a[i]);</span>
      } else {
<span class="nc" id="L1837">        s = nf.format(a[i]);</span>
      }
<span class="nc" id="L1839">      b.append(s);</span>
<span class="nc" id="L1840">      b.append(&quot;, &quot;);</span>
    }
    String s;
<span class="nc bnc" id="L1843" title="All 2 branches missed.">    if (nf == null) {</span>
<span class="nc" id="L1844">      s = String.valueOf(a[a.length - 1]);</span>
    } else {
<span class="nc" id="L1846">      s = nf.format(a[a.length - 1]);</span>
    }
<span class="nc" id="L1848">    b.append(s);</span>
<span class="nc" id="L1849">    b.append(']');</span>
<span class="nc" id="L1850">    return b.toString();</span>
  }

  public static String toString(int[][] counts) {
<span class="nc" id="L1854">    return toString(counts, null, null, 10, 10, NumberFormat.getInstance(), false);</span>
  }

  public static String toString(int[][] counts, Object[] rowLabels, Object[] colLabels, int labelSize, int cellSize, NumberFormat nf, boolean printTotals) {
    // first compute row totals and column totals
<span class="nc bnc" id="L1859" title="All 4 branches missed.">    if (counts.length==0 || counts[0].length==0) return &quot;&quot;;</span>
<span class="nc" id="L1860">    int[] rowTotals = new int[counts.length];</span>
<span class="nc" id="L1861">    int[] colTotals = new int[counts[0].length]; // assume it's square</span>
<span class="nc" id="L1862">    int total = 0;</span>
<span class="nc bnc" id="L1863" title="All 2 branches missed.">    for (int i = 0; i &lt; counts.length; i++) {</span>
<span class="nc bnc" id="L1864" title="All 2 branches missed.">      for (int j = 0; j &lt; counts[i].length; j++) {</span>
<span class="nc" id="L1865">        rowTotals[i] += counts[i][j];</span>
<span class="nc" id="L1866">        colTotals[j] += counts[i][j];</span>
<span class="nc" id="L1867">        total += counts[i][j];</span>
      }
    }
<span class="nc" id="L1870">    StringBuilder result = new StringBuilder();</span>
    // column labels
<span class="nc bnc" id="L1872" title="All 2 branches missed.">    if (colLabels != null) {</span>
<span class="nc" id="L1873">      result.append(StringUtils.padLeft(&quot;&quot;, labelSize)); // spacing for the row labels!</span>
<span class="nc bnc" id="L1874" title="All 2 branches missed.">      for (int j = 0; j &lt; counts[0].length; j++) {</span>
<span class="nc bnc" id="L1875" title="All 2 branches missed.">        String s = (colLabels[j]==null ? &quot;null&quot; : colLabels[j].toString());</span>
<span class="nc bnc" id="L1876" title="All 2 branches missed.">        if (s.length() &gt; cellSize - 1) {</span>
<span class="nc" id="L1877">          s = s.substring(0, cellSize - 1);</span>
        }
<span class="nc" id="L1879">        s = StringUtils.padLeft(s, cellSize);</span>
<span class="nc" id="L1880">        result.append(s);</span>
      }
<span class="nc bnc" id="L1882" title="All 2 branches missed.">      if (printTotals) {</span>
<span class="nc" id="L1883">        result.append(StringUtils.padLeftOrTrim(&quot;Total&quot;, cellSize));</span>
      }
<span class="nc" id="L1885">      result.append('\n');</span>
    }
<span class="nc bnc" id="L1887" title="All 2 branches missed.">    for (int i = 0; i &lt; counts.length; i++) {</span>
      // row label
<span class="nc bnc" id="L1889" title="All 2 branches missed.">      if (rowLabels != null) {</span>
<span class="nc bnc" id="L1890" title="All 2 branches missed.">        String s = (rowLabels[i]==null ? &quot;null&quot; : rowLabels[i].toString());</span>
<span class="nc" id="L1891">        s = StringUtils.padOrTrim(s, labelSize); // left align this guy only</span>
<span class="nc" id="L1892">        result.append(s);</span>
      }
      // value
<span class="nc bnc" id="L1895" title="All 2 branches missed.">      for (int j = 0; j &lt; counts[i].length; j++) {</span>
<span class="nc" id="L1896">        result.append(StringUtils.padLeft(nf.format(counts[i][j]), cellSize));</span>
      }
      // the row total
<span class="nc bnc" id="L1899" title="All 2 branches missed.">      if (printTotals) {</span>
<span class="nc" id="L1900">        result.append(StringUtils.padLeft(nf.format(rowTotals[i]), cellSize));</span>
      }
<span class="nc" id="L1902">      result.append('\n');</span>
    }
    // the col totals
<span class="nc bnc" id="L1905" title="All 2 branches missed.">    if (printTotals) {</span>
<span class="nc" id="L1906">      result.append(StringUtils.pad(&quot;Total&quot;, labelSize));</span>
<span class="nc bnc" id="L1907" title="All 2 branches missed.">      for (int colTotal : colTotals) {</span>
<span class="nc" id="L1908">        result.append(StringUtils.padLeft(nf.format(colTotal), cellSize));</span>
      }
<span class="nc" id="L1910">      result.append(StringUtils.padLeft(nf.format(total), cellSize));</span>
    }
<span class="nc" id="L1912">    return result.toString();</span>
  }


  public static String toString(double[][] counts) {
<span class="nc" id="L1917">    return toString(counts, 10, null, null, NumberFormat.getInstance(), false);</span>
  }

  public static String toString(double[][] counts, int cellSize, Object[] rowLabels, Object[] colLabels, NumberFormat nf, boolean printTotals) {
<span class="nc bnc" id="L1921" title="All 2 branches missed.">    if (counts==null) return null;</span>
    // first compute row totals and column totals
<span class="nc" id="L1923">    double[] rowTotals = new double[counts.length];</span>
<span class="nc" id="L1924">    double[] colTotals = new double[counts[0].length]; // assume it's square</span>
<span class="nc" id="L1925">    double total = 0.0;</span>
<span class="nc bnc" id="L1926" title="All 2 branches missed.">    for (int i = 0; i &lt; counts.length; i++) {</span>
<span class="nc bnc" id="L1927" title="All 2 branches missed.">      for (int j = 0; j &lt; counts[i].length; j++) {</span>
<span class="nc" id="L1928">        rowTotals[i] += counts[i][j];</span>
<span class="nc" id="L1929">        colTotals[j] += counts[i][j];</span>
<span class="nc" id="L1930">        total += counts[i][j];</span>
      }
    }
<span class="nc" id="L1933">    StringBuilder result = new StringBuilder();</span>
    // column labels
<span class="nc bnc" id="L1935" title="All 2 branches missed.">    if (colLabels != null) {</span>
<span class="nc" id="L1936">      result.append(StringUtils.padLeft(&quot;&quot;, cellSize));</span>
<span class="nc bnc" id="L1937" title="All 2 branches missed.">      for (int j = 0; j &lt; counts[0].length; j++) {</span>
<span class="nc" id="L1938">        String s = colLabels[j].toString();</span>
<span class="nc bnc" id="L1939" title="All 2 branches missed.">        if (s.length() &gt; cellSize - 1) {</span>
<span class="nc" id="L1940">          s = s.substring(0, cellSize - 1);</span>
        }
<span class="nc" id="L1942">        s = StringUtils.padLeft(s, cellSize);</span>
<span class="nc" id="L1943">        result.append(s);</span>
      }
<span class="nc bnc" id="L1945" title="All 2 branches missed.">      if (printTotals) {</span>
<span class="nc" id="L1946">        result.append(StringUtils.padLeftOrTrim(&quot;Total&quot;, cellSize));</span>
      }
<span class="nc" id="L1948">      result.append('\n');</span>
    }
<span class="nc bnc" id="L1950" title="All 2 branches missed.">    for (int i = 0; i &lt; counts.length; i++) {</span>
      // row label
<span class="nc bnc" id="L1952" title="All 2 branches missed.">      if (rowLabels != null) {</span>
<span class="nc" id="L1953">        String s = rowLabels[i].toString();</span>
<span class="nc" id="L1954">        s = StringUtils.padOrTrim(s, cellSize); // left align this guy only</span>
<span class="nc" id="L1955">        result.append(s);</span>
      }
      // value
<span class="nc bnc" id="L1958" title="All 2 branches missed.">      for (int j = 0; j &lt; counts[i].length; j++) {</span>
<span class="nc" id="L1959">        result.append(StringUtils.padLeft(nf.format(counts[i][j]), cellSize));</span>
      }
      // the row total
<span class="nc bnc" id="L1962" title="All 2 branches missed.">      if (printTotals) {</span>
<span class="nc" id="L1963">        result.append(StringUtils.padLeft(nf.format(rowTotals[i]), cellSize));</span>
      }
<span class="nc" id="L1965">      result.append('\n');</span>
    }
    // the col totals
<span class="nc bnc" id="L1968" title="All 2 branches missed.">    if (printTotals) {</span>
<span class="nc" id="L1969">      result.append(StringUtils.pad(&quot;Total&quot;, cellSize));</span>
<span class="nc bnc" id="L1970" title="All 2 branches missed.">      for (double colTotal : colTotals) {</span>
<span class="nc" id="L1971">        result.append(StringUtils.padLeft(nf.format(colTotal), cellSize));</span>
      }
<span class="nc" id="L1973">      result.append(StringUtils.padLeft(nf.format(total), cellSize));</span>
    }
<span class="nc" id="L1975">    return result.toString();</span>
  }

  public static String toString(float[][] counts) {
<span class="nc" id="L1979">    return toString(counts, 10, null, null, NumberFormat.getIntegerInstance(), false);</span>
  }

  public static String toString(float[][] counts, int cellSize, Object[] rowLabels, Object[] colLabels, NumberFormat nf, boolean printTotals) {
    // first compute row totals and column totals
<span class="nc" id="L1984">    double[] rowTotals = new double[counts.length];</span>
<span class="nc" id="L1985">    double[] colTotals = new double[counts[0].length]; // assume it's square</span>
<span class="nc" id="L1986">    double total = 0.0;</span>
<span class="nc bnc" id="L1987" title="All 2 branches missed.">    for (int i = 0; i &lt; counts.length; i++) {</span>
<span class="nc bnc" id="L1988" title="All 2 branches missed.">      for (int j = 0; j &lt; counts[i].length; j++) {</span>
<span class="nc" id="L1989">        rowTotals[i] += counts[i][j];</span>
<span class="nc" id="L1990">        colTotals[j] += counts[i][j];</span>
<span class="nc" id="L1991">        total += counts[i][j];</span>
      }
    }
<span class="nc" id="L1994">    StringBuilder result = new StringBuilder();</span>
    // column labels
<span class="nc bnc" id="L1996" title="All 2 branches missed.">    if (colLabels != null) {</span>
<span class="nc" id="L1997">      result.append(StringUtils.padLeft(&quot;&quot;, cellSize));</span>
<span class="nc bnc" id="L1998" title="All 2 branches missed.">      for (int j = 0; j &lt; counts[0].length; j++) {</span>
<span class="nc" id="L1999">        String s = colLabels[j].toString();</span>
<span class="nc" id="L2000">        s = StringUtils.padLeftOrTrim(s, cellSize);</span>
<span class="nc" id="L2001">        result.append(s);</span>
      }
<span class="nc bnc" id="L2003" title="All 2 branches missed.">      if (printTotals) {</span>
<span class="nc" id="L2004">        result.append(StringUtils.padLeftOrTrim(&quot;Total&quot;, cellSize));</span>
      }
<span class="nc" id="L2006">      result.append('\n');</span>
    }
<span class="nc bnc" id="L2008" title="All 2 branches missed.">    for (int i = 0; i &lt; counts.length; i++) {</span>
      // row label
<span class="nc bnc" id="L2010" title="All 2 branches missed.">      if (rowLabels != null) {</span>
<span class="nc" id="L2011">        String s = rowLabels[i].toString();</span>
<span class="nc" id="L2012">        s = StringUtils.pad(s, cellSize); // left align this guy only</span>
<span class="nc" id="L2013">        result.append(s);</span>
      }
      // value
<span class="nc bnc" id="L2016" title="All 2 branches missed.">      for (int j = 0; j &lt; counts[i].length; j++) {</span>
<span class="nc" id="L2017">        result.append(StringUtils.padLeft(nf.format(counts[i][j]), cellSize));</span>
      }
      // the row total
<span class="nc bnc" id="L2020" title="All 2 branches missed.">      if (printTotals) {</span>
<span class="nc" id="L2021">        result.append(StringUtils.padLeft(nf.format(rowTotals[i]), cellSize));</span>
      }
<span class="nc" id="L2023">      result.append('\n');</span>
    }
    // the col totals
<span class="nc bnc" id="L2026" title="All 2 branches missed.">    if (printTotals) {</span>
<span class="nc" id="L2027">      result.append(StringUtils.pad(&quot;Total&quot;, cellSize));</span>
<span class="nc bnc" id="L2028" title="All 2 branches missed.">      for (double colTotal : colTotals) {</span>
<span class="nc" id="L2029">        result.append(StringUtils.padLeft(nf.format(colTotal), cellSize));</span>
      }
<span class="nc" id="L2031">      result.append(StringUtils.padLeft(nf.format(total), cellSize));</span>
    }
<span class="nc" id="L2033">    return result.toString();</span>
  }

  /**
   * For testing only.
   * @param args Ignored
   */
  public static void main(String[] args) {
<span class="nc" id="L2041">    Random random = new Random();</span>
<span class="nc" id="L2042">    int length = 100;</span>
<span class="nc" id="L2043">    double[] A = new double[length];</span>
<span class="nc" id="L2044">    double[] B = new double[length];</span>
<span class="nc" id="L2045">    double aAvg = 70.0;</span>
<span class="nc" id="L2046">    double bAvg = 70.5;</span>
<span class="nc bnc" id="L2047" title="All 2 branches missed.">    for (int i = 0; i &lt; length; i++) {</span>
<span class="nc" id="L2048">      A[i] = aAvg + random.nextGaussian();</span>
<span class="nc" id="L2049">      B[i] = bAvg + random.nextGaussian();</span>
    }
<span class="nc" id="L2051">    System.out.println(&quot;A has length &quot; + A.length + &quot; and mean &quot; + mean(A));</span>
<span class="nc" id="L2052">    System.out.println(&quot;B has length &quot; + B.length + &quot; and mean &quot; + mean(B));</span>
<span class="nc bnc" id="L2053" title="All 2 branches missed.">    for (int t = 0; t &lt; 10; t++) {</span>
<span class="nc" id="L2054">      System.out.println(&quot;p-value: &quot; + sigLevelByApproxRand(A, B));</span>
    }
<span class="nc" id="L2056">  }</span>

  public static int[][] deepCopy(int[][] counts) {
<span class="nc" id="L2059">    int[][] result = new int[counts.length][];</span>
<span class="nc bnc" id="L2060" title="All 2 branches missed.">    for (int i=0; i&lt;counts.length; i++) {</span>
<span class="nc" id="L2061">      result[i] = new int[counts[i].length];</span>
<span class="nc" id="L2062">      System.arraycopy(counts[i], 0, result[i], 0, counts[i].length);</span>
    }
<span class="nc" id="L2064">    return result;</span>
  }

  public static double[][] covariance(double[][] data) {
<span class="nc" id="L2068">    double[] means = new double[data.length];</span>
<span class="nc bnc" id="L2069" title="All 2 branches missed.">    for (int i = 0; i &lt; means.length; i++) {</span>
<span class="nc" id="L2070">      means[i] = mean(data[i]);</span>
    }

<span class="nc" id="L2073">    double[][] covariance = new double[means.length][means.length];</span>
<span class="nc bnc" id="L2074" title="All 2 branches missed.">    for (int i = 0; i &lt; data[0].length; i++) {</span>
<span class="nc bnc" id="L2075" title="All 2 branches missed.">      for (int j = 0; j &lt; means.length; j++) {</span>
<span class="nc bnc" id="L2076" title="All 2 branches missed.">        for (int k = 0; k &lt; means.length; k++) {</span>
<span class="nc" id="L2077">          covariance[j][k] += (means[j]-data[j][i])*(means[k]-data[k][i]);</span>
        }
      }
    }

<span class="nc bnc" id="L2082" title="All 2 branches missed.">    for (int i = 0; i &lt; covariance.length; i++) {</span>
<span class="nc bnc" id="L2083" title="All 2 branches missed.">      for (int j = 0; j &lt; covariance[i].length; j++) {</span>
<span class="nc" id="L2084">        covariance[i][j] = Math.sqrt(covariance[i][j])/(data[0].length);</span>
      }
    }
<span class="nc" id="L2087">    return covariance;</span>
  }


  public static void addMultInto(double[] a, double[] b, double[] c, double d) {
<span class="nc bnc" id="L2092" title="All 2 branches missed.">    for (int i=0; i&lt;a.length; i++) {</span>
<span class="nc" id="L2093">      a[i] = b[i] + c[i] * d;</span>
    }
<span class="nc" id="L2095">  }</span>

  public static void multiplyInto(double[] a, double[] b, double c) {
<span class="nc bnc" id="L2098" title="All 2 branches missed.">    for (int i=0; i&lt;a.length; i++) {</span>
<span class="nc" id="L2099">      a[i] = b[i] * c;</span>
    }
<span class="nc" id="L2101">  }</span>

  public static double entropy(double[] probs) {
<span class="nc" id="L2104">    double e = 0.0;</span>
<span class="nc bnc" id="L2105" title="All 2 branches missed.">    for (double p : probs) {</span>
<span class="nc bnc" id="L2106" title="All 2 branches missed.">      if (p != 0.0)</span>
<span class="nc" id="L2107">        e -= p * Math.log(p);</span>
    }
<span class="nc" id="L2109">    return e;</span>
  }

  public static void assertFinite(double[] vector, String vectorName) throws InvalidElementException {
<span class="nc bnc" id="L2113" title="All 2 branches missed.">    for(int i=0; i&lt;vector.length; i++){</span>
<span class="nc bnc" id="L2114" title="All 2 branches missed.">      if (Double.isNaN(vector[i])) {</span>
<span class="nc" id="L2115">        throw new InvalidElementException(&quot;NaN found in &quot; + vectorName + &quot; element &quot; + i);</span>
<span class="nc bnc" id="L2116" title="All 2 branches missed.">      } else if (Double.isInfinite(vector[i])) {</span>
<span class="nc" id="L2117">        throw new InvalidElementException(&quot;Infinity found in &quot; + vectorName + &quot; element &quot; + i);</span>
      }
    }
<span class="nc" id="L2120">  }</span>

  public static class InvalidElementException extends RuntimeException {

    private static final long serialVersionUID = 1647150702529757545L;

    public InvalidElementException(String s) {
<span class="nc" id="L2127">      super(s);</span>
<span class="nc" id="L2128">    }</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>