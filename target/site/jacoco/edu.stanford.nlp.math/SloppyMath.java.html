<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SloppyMath.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.math</a> &gt; <span class="el_source">SloppyMath.java</span></div><h1>SloppyMath.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.math;
import edu.stanford.nlp.util.Triple;
import edu.stanford.nlp.util.logging.Redwood;

import java.util.Collection;

/**
 * The class {@code SloppyMath} contains methods for performing basic
 * numeric operations.  In some cases, such as max and min, they cut a few
 * corners in
 * the implementation for the sake of efficiency.  In particular, they may
 * not handle special notions like NaN and -0.0 correctly.  This was the
 * origin of the class name, but many other methods are just useful
 * math additions, such as logAdd.  This class just has static math methods.
 *
 * @author Christopher Manning
 * @version 2003/01/02
 */
public final class SloppyMath  {

  /** A logger for this class */
<span class="fc" id="L22">  private static Redwood.RedwoodChannels log = Redwood.channels(SloppyMath.class);</span>

<span class="nc" id="L24">  private SloppyMath() {}  // this class is just static methods.</span>

  /** Round a double to the nearest integer, via conventional rules
   *  (.5 rounds up, .49 rounds down), and return the result, still as a double.
   *
   *  @param x What to round
   *  @return The rounded value
   */
  public static double round(double x) {
<span class="fc" id="L33">    return Math.floor(x + 0.5d);</span>
  }

  /** Round a double to the given number of decimal places,
   *  rounding to the nearest value via conventional rules (5 rounds up, 49
   *  rounds down).
   *  E.g. round(3.1416, 2) == 3.14, round(431.5, -2) == 400,
   *  round(431.5, 0) = 432
   */
  public static double round(double x, int precision) {
<span class="fc" id="L43">    double power = Math.pow(10.0, precision);</span>
<span class="fc" id="L44">    return round(x * power) / power;</span>
  }

  /**
   * max() that works on three integers.  Like many of the other max() functions in this class,
   * doesn't perform special checks like NaN or -0.0f to save time.
   *
   * @return The maximum of three int values.
   */
  public static int max(int a, int b, int c) {
    int ma;
<span class="fc" id="L55">    ma = a;</span>
<span class="fc bfc" id="L56" title="All 2 branches covered.">    if (b &gt; ma) {</span>
<span class="fc" id="L57">      ma = b;</span>
    }
<span class="fc bfc" id="L59" title="All 2 branches covered.">    if (c &gt; ma) {</span>
<span class="fc" id="L60">      ma = c;</span>
    }
<span class="fc" id="L62">    return ma;</span>
  }

  public static int max(Collection&lt;Integer&gt; vals) {
<span class="nc bnc" id="L66" title="All 2 branches missed.">    if (vals.isEmpty()) { throw new RuntimeException(); }</span>
<span class="nc" id="L67">    int max = Integer.MIN_VALUE;</span>

<span class="nc bnc" id="L69" title="All 2 branches missed.">    for (int i : vals) {</span>
<span class="nc bnc" id="L70" title="All 2 branches missed.">      if (i &gt; max) { max = i; }</span>
<span class="nc" id="L71">    }</span>

<span class="nc" id="L73">    return max;</span>
  }

  /**
   * Returns the greater of two &lt;code&gt;int&lt;/code&gt; values.  That
   * is, the result is the argument closer to positive infinity. If
   * the arguments have the same value, the result is that same
   * value.  Does none of the special checks for NaN or -0.0f that
   * &lt;code&gt;Math.max&lt;/code&gt; does.
   *
   * @param a an argument.
   * @param b another argument.
   * @return the larger of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.
   */
  public static int max(int a, int b) {
<span class="nc bnc" id="L88" title="All 2 branches missed.">    return (a &gt;= b) ? a : b;</span>
  }

  /**
   * Returns the greater of two &lt;code&gt;float&lt;/code&gt; values.  That is,
   * the result is the argument closer to positive infinity. If the
   * arguments have the same value, the result is that same
   * value.  Does none of the special checks for NaN or -0.0f that
   * &lt;code&gt;Math.max&lt;/code&gt; does.
   *
   * @param a an argument.
   * @param b another argument.
   * @return the larger of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.
   */
  public static float max(float a, float b) {
<span class="nc bnc" id="L103" title="All 2 branches missed.">    return (a &gt;= b) ? a : b;</span>
  }

  /**
   * Returns the greater of two &lt;code&gt;double&lt;/code&gt; values.  That
   * is, the result is the argument closer to positive infinity. If
   * the arguments have the same value, the result is that same
   * value.  Does none of the special checks for NaN or -0.0f that
   * &lt;code&gt;Math.max&lt;/code&gt; does.
   *
   * @param a an argument.
   * @param b another argument.
   * @return the larger of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.
   */
  public static double max(double a, double b) {
<span class="nc bnc" id="L118" title="All 2 branches missed.">    return (a &gt;= b) ? a : b;</span>
  }

  /**
   * Returns the minimum of three int values.
   */
  public static int min(int a, int b, int c) {
    int mi;

<span class="fc" id="L127">    mi = a;</span>
<span class="fc bfc" id="L128" title="All 2 branches covered.">    if (b &lt; mi) {</span>
<span class="fc" id="L129">      mi = b;</span>
    }
<span class="fc bfc" id="L131" title="All 2 branches covered.">    if (c &lt; mi) {</span>
<span class="fc" id="L132">      mi = c;</span>
    }
<span class="fc" id="L134">    return mi;</span>
  }

  /**
   * Returns the smaller of two &lt;code&gt;float&lt;/code&gt; values.  That is,
   * the result is the value closer to negative infinity. If the
   * arguments have the same value, the result is that same
   * value.  Does none of the special checks for NaN or -0.0f that
   * &lt;code&gt;Math.max&lt;/code&gt; does.
   *
   * @param a an argument.
   * @param b another argument.
   * @return the smaller of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b.&lt;/code&gt;
   */
  public static float min(float a, float b) {
<span class="nc bnc" id="L149" title="All 2 branches missed.">    return (a &lt;= b) ? a : b;</span>
  }


  /**
   * Returns the smaller of two &lt;code&gt;double&lt;/code&gt; values.  That
   * is, the result is the value closer to negative infinity. If the
   * arguments have the same value, the result is that same
   * value.  Does none of the special checks for NaN or -0.0f that
   * &lt;code&gt;Math.max&lt;/code&gt; does.
   *
   * @param a an argument.
   * @param b another argument.
   * @return the smaller of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.
   */
  public static double min(double a, double b) {
<span class="nc bnc" id="L165" title="All 2 branches missed.">    return (a &lt;= b) ? a : b;</span>
  }

  /** Returns a mod where the sign of the answer is the same as the sign of the second
   *  argument.  This is how languages like Python do it. Helpful for array accesses.
   *
   * @param num The number
   * @param modulus The modulus
   * @return num mod modulus, where the sign of the answer is the same as the sign of modulus
   */
  public static int pythonMod(int num, int modulus) {
    // This is: num &lt; 0 ? num % modulus + modulus: num % modulus, but avoids a test-and-branch
<span class="fc" id="L177">    return (num % modulus + modulus) % modulus;</span>
  }

  /**
   * @return an approximation of the log of the Gamma function of x.  Laczos Approximation
   * Reference: Numerical Recipes in C
   * http://www.library.cornell.edu/nr/cbookcpdf.html
   * from www.cs.berkeley.edu/~milch/blog/versions/blog-0.1.3/blog/distrib
   */
  public static double lgamma(double x) {
<span class="nc" id="L187">    double[] cof = {76.18009172947146, -86.50532032941677,</span>
      24.01409824083091,-1.231739572450155,
      0.1208650973866179e-2,-0.5395239384953e-5};
<span class="nc" id="L190">    double xxx = x;</span>
<span class="nc" id="L191">    double tmp = x + 5.5;</span>
<span class="nc" id="L192">    tmp -= ((x + 0.5) * Math.log(tmp));</span>
<span class="nc" id="L193">    double ser = 1.000000000190015;</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">    for (int j = 0; j &lt; 6; j++) {</span>
<span class="nc" id="L195">      xxx++;</span>
<span class="nc" id="L196">      ser += cof[j] / xxx;</span>
    }
<span class="nc" id="L198">    return -tmp + Math.log(2.5066282746310005*ser / x);</span>
  }

  /**
   * Returns true if the argument is a &quot;dangerous&quot; double to have
   * around, namely one that is infinite, NaN or zero.
   */
  public static boolean isDangerous(double d) {
<span class="pc bpc" id="L206" title="1 of 6 branches missed.">    return Double.isInfinite(d) || Double.isNaN(d) || d == 0.0;</span>
  }

  /**
   * Returns true if the argument is a &quot;very dangerous&quot; double to have
   * around, namely one that is infinite or NaN.
   */
  public static boolean isVeryDangerous(double d) {
<span class="nc bnc" id="L214" title="All 4 branches missed.">    return Double.isInfinite(d) || Double.isNaN(d);</span>
  }

  public static boolean isCloseTo(double a, double b) {
<span class="nc bnc" id="L218" title="All 2 branches missed.">    if (a&gt;b) {</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">      return (a-b)&lt;1e-4;</span>
    } else {
<span class="nc bnc" id="L221" title="All 2 branches missed.">      return (b-a)&lt;1e-4;</span>
    }
  }

  /**
   * If a difference is bigger than this in log terms, then the sum or
   * difference of them will just be the larger (to 12 or so decimal
   * places for double, and 7 or 8 for float).
   */
  static final double LOGTOLERANCE = 30.0;
  static final float LOGTOLERANCE_F = 20.0f;


  /** Approximation to gamma function.  See e.g., http://www.rskey.org/CMS/index.php/the-library/11 .
   *  Fairly accurate, especially for n greater than 8.
   */
  public static double gamma(double n) {
<span class="nc" id="L238">    return Math.sqrt(2.0*Math.PI/n) * Math.pow((n/Math.E)*Math.sqrt(n*Math.sinh((1.0/n)+(1/(810*Math.pow(n,6))))),n);</span>
  }

  /**
   * Convenience method for log to a different base
   */
  public static double log(double num, double base) {
<span class="nc" id="L245">    return Math.log(num)/Math.log(base);</span>
  }

  /**
   * Returns the log of the sum of two numbers, which are
   * themselves input in log form.  This uses natural logarithms.
   * Reasonable care is taken to do this as efficiently as possible
   * (under the assumption that the numbers might differ greatly in
   * magnitude), with high accuracy, and without numerical overflow.
   * Also, handle correctly the case of arguments being -Inf (e.g.,
   * probability 0).
   *
   * @param lx First number, in log form
   * @param ly Second number, in log form
   * @return {@code log(exp(lx) + exp(ly))}
   */
  public static float logAdd(float lx, float ly) {
    float max, negDiff;
<span class="nc bnc" id="L263" title="All 2 branches missed.">    if (lx &gt; ly) {</span>
<span class="nc" id="L264">      max = lx;</span>
<span class="nc" id="L265">      negDiff = ly - lx;</span>
    } else {
<span class="nc" id="L267">      max = ly;</span>
<span class="nc" id="L268">      negDiff = lx - ly;</span>
    }
<span class="nc bnc" id="L270" title="All 2 branches missed.">    if (max == Double.NEGATIVE_INFINITY) {</span>
<span class="nc" id="L271">      return max;</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">    } else if (negDiff &lt; -LOGTOLERANCE_F) {</span>
<span class="nc" id="L273">      return max;</span>
    } else {
<span class="nc" id="L275">      return max + (float) Math.log(1.0 + Math.exp(negDiff));</span>
    }
  }

  /**
   * Returns the log of the sum of two numbers, which are
   * themselves input in log form.  This uses natural logarithms.
   * Reasonable care is taken to do this as efficiently as possible
   * (under the assumption that the numbers might differ greatly in
   * magnitude), with high accuracy, and without numerical overflow.
   * Also, handle correctly the case of arguments being -Inf (e.g.,
   * probability 0).
   *
   * @param lx First number, in log form
   * @param ly Second number, in log form
   * @return {@code log(exp(lx) + exp(ly))}
   */
  public static double logAdd(double lx, double ly) {
    double max, negDiff;
<span class="fc bfc" id="L294" title="All 2 branches covered.">    if (lx &gt; ly) {</span>
<span class="fc" id="L295">      max = lx;</span>
<span class="fc" id="L296">      negDiff = ly - lx;</span>
    } else {
<span class="fc" id="L298">      max = ly;</span>
<span class="fc" id="L299">      negDiff = lx - ly;</span>
    }
<span class="pc bpc" id="L301" title="1 of 2 branches missed.">    if (max == Double.NEGATIVE_INFINITY) {</span>
<span class="nc" id="L302">      return max;</span>
<span class="pc bpc" id="L303" title="1 of 2 branches missed.">    } else if (negDiff &lt; -LOGTOLERANCE) {</span>
<span class="nc" id="L304">      return max;</span>
    } else {
<span class="fc" id="L306">      return max + Math.log(1.0 + Math.exp(negDiff));</span>
    }
  }

  /**
   * Computes n choose k in an efficient way.  Works with
   * k == 0 or k == n but undefined if k &amp;lt; 0 or k &amp;gt; n
   *
   * @return fact(n) / fact(k) * fact(n-k)
   */
  public static int nChooseK(int n, int k) {
<span class="nc" id="L317">    k = Math.min(k, n - k);</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">    if (k == 0) {</span>
<span class="nc" id="L319">      return 1;</span>
    }
<span class="nc" id="L321">    int accum = n;</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">    for (int i = 1; i &lt; k; i++) {</span>
<span class="nc" id="L323">      accum *= (n - i);</span>
<span class="nc" id="L324">      accum /= i;</span>
    }
<span class="nc" id="L326">    return accum / k;</span>
  }

  /**
   * Returns an approximation to Math.pow(a,b) that is ~27x faster
   * with a margin of error possibly around ~10%.  From
   * http://martin.ankerl.com/2007/10/04/optimized-pow-approximation-for-java-and-c-c/
   */
  public static double pow(final double a, final double b) {
<span class="nc" id="L335">    final int x = (int) (Double.doubleToLongBits(a) &gt;&gt; 32);</span>
<span class="nc" id="L336">    final int y = (int) (b * (x - 1072632447) + 1072632447);</span>
<span class="nc" id="L337">    return Double.longBitsToDouble(((long) y) &lt;&lt; 32);</span>
  }

  /**
   * Exponentiation like we learned in grade school:
   * multiply b by itself e times.  Uses power of two trick.
   * e must be nonnegative!!!  no checking!!!  For e &amp;lt;= 0,
   * the exponent is treated as 0, and 1 is returned.  0^0 also
   * returns 1. Biased to do quickly small exponents, like the CRF needs.
   * Note that some code claims you can get more speed ups with special cases:
   * http://sourceforge.net/p/jafama/code/ci/master/tree/src/net/jafama/FastMath.java
   * but I couldn't verify any gains beyond special casing 2. May depend on workload.
   *
   * @param b base
   * @param e exponent
   * @return b^e
   */
  public static int intPow(int b, int e) {
<span class="fc bfc" id="L355" title="All 2 branches covered.">    if (e &lt;= 1) {</span>
<span class="fc bfc" id="L356" title="All 2 branches covered.">      if (e == 1) {</span>
<span class="fc" id="L357">        return b;</span>
      } else {
<span class="fc" id="L359">        return 1; // this is also what you get for e &lt; 0 !</span>
      }
    } else {
<span class="pc bpc" id="L362" title="1 of 2 branches missed.">      if (e == 2) {</span>
<span class="nc" id="L363">        return b * b;</span>
      } else {
<span class="fc" id="L365">        int result = 1;</span>
<span class="fc bfc" id="L366" title="All 2 branches covered.">        while (e &gt; 0) {</span>
<span class="fc bfc" id="L367" title="All 2 branches covered.">          if ((e &amp; 1) != 0) {</span>
<span class="fc" id="L368">            result *= b;</span>
          }
<span class="fc" id="L370">          b *= b;</span>
<span class="fc" id="L371">          e &gt;&gt;= 1;</span>
        }
<span class="fc" id="L373">        return result;</span>
      }
    }
  }

  /**
     * Exponentiation like we learned in grade school:
     * multiply b by itself e times.  Uses power of two trick.
     * e must be nonnegative!!!  no checking!!!
     *
     * @param b base
     * @param e exponent
     * @return b^e
     */
  public static float intPow(float b, int e) {
<span class="fc" id="L388">    float result = 1.0f;</span>
<span class="fc" id="L389">    float currPow = b;</span>
<span class="fc bfc" id="L390" title="All 2 branches covered.">    while (e &gt; 0) {</span>
<span class="fc bfc" id="L391" title="All 2 branches covered.">      if ((e &amp; 1) != 0) {</span>
<span class="fc" id="L392">        result *= currPow;</span>
      }
<span class="fc" id="L394">      currPow *= currPow;</span>
<span class="fc" id="L395">      e &gt;&gt;= 1;</span>
    }
<span class="fc" id="L397">    return result;</span>
  }

  /**
   * Exponentiation like we learned in grade school:
   * multiply b by itself e times.  Uses power of two trick.
   * e must be nonnegative!!!  no checking!!!
   * @param b base
   * @param e exponent
   * @return b^e
   */
  public static double intPow(double b, int e) {
<span class="fc" id="L409">    double result = 1.0;</span>
<span class="fc" id="L410">    double currPow = b;</span>
<span class="fc bfc" id="L411" title="All 2 branches covered.">    while (e &gt; 0) {</span>
<span class="fc bfc" id="L412" title="All 2 branches covered.">      if ((e &amp; 1) != 0) {</span>
<span class="fc" id="L413">        result *= currPow;</span>
      }
<span class="fc" id="L415">      currPow *= currPow;</span>
<span class="fc" id="L416">      e &gt;&gt;= 1;</span>
    }
<span class="fc" id="L418">    return result;</span>
  }

  /**
   * Find a hypergeometric distribution.  This uses exact math, trying
   * fairly hard to avoid numeric overflow by interleaving
   * multiplications and divisions.
   * (To do: make it even better at avoiding overflow, by using loops
   * that will do either a multiple or divide based on the size of the
   * intermediate result.)
   *
   * @param k The number of black balls drawn
   * @param n The total number of balls
   * @param r The number of black balls
   * @param m The number of balls drawn
   * @return The hypergeometric value
   */
  public static double hypergeometric(int k, int n, int r, int m) {
<span class="nc bnc" id="L436" title="All 12 branches missed.">    if (k &lt; 0 || r &gt; n || m &gt; n || n &lt;= 0 || m &lt; 0 || r &lt; 0) {</span>
<span class="nc" id="L437">      throw new IllegalArgumentException(&quot;Invalid hypergeometric&quot;);</span>
    }

    // exploit symmetry of problem
<span class="nc bnc" id="L441" title="All 2 branches missed.">    if (m &gt; n / 2) {</span>
<span class="nc" id="L442">      m = n - m;</span>
<span class="nc" id="L443">      k = r - k;</span>
    }
<span class="nc bnc" id="L445" title="All 2 branches missed.">    if (r &gt; n / 2) {</span>
<span class="nc" id="L446">      r = n - r;</span>
<span class="nc" id="L447">      k = m - k;</span>
    }
<span class="nc bnc" id="L449" title="All 2 branches missed.">    if (m &gt; r) {</span>
<span class="nc" id="L450">      int temp = m;</span>
<span class="nc" id="L451">      m = r;</span>
<span class="nc" id="L452">      r = temp;</span>
    }
    // now we have that k &lt;= m &lt;= r &lt;= n/2

<span class="nc bnc" id="L456" title="All 4 branches missed.">    if (k &lt; (m + r) - n || k &gt; m) {</span>
<span class="nc" id="L457">      return 0.0;</span>
    }

    // Do limit cases explicitly
    // It's unclear whether this is a good idea.  I put it in fearing
    // numerical errors when the numbers seemed off, but actually there
    // was a bug in the Fisher's exact routine.
<span class="nc bnc" id="L464" title="All 2 branches missed.">    if (r == n) {</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">      if (k == m) {</span>
<span class="nc" id="L466">        return 1.0;</span>
      } else {
<span class="nc" id="L468">        return 0.0;</span>
      }
<span class="nc bnc" id="L470" title="All 2 branches missed.">    } else if (r == n - 1) {</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">      if (k == m) {</span>
<span class="nc" id="L472">        return (n - m) / (double) n;</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">      } else if (k == m - 1) {</span>
<span class="nc" id="L474">        return m / (double) n;</span>
      } else {
<span class="nc" id="L476">        return 0.0;</span>
      }
<span class="nc bnc" id="L478" title="All 2 branches missed.">    } else if (m == 1) {</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">      if (k == 0) {</span>
<span class="nc" id="L480">        return (n - r) / (double) n;</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">      } else if (k == 1) {</span>
<span class="nc" id="L482">        return r / (double) n;</span>
      } else {
<span class="nc" id="L484">        return 0.0;</span>
      }
<span class="nc bnc" id="L486" title="All 2 branches missed.">    } else if (m == 0) {</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">      if (k == 0) {</span>
<span class="nc" id="L488">        return 1.0;</span>
      } else {
<span class="nc" id="L490">        return 0.0;</span>
      }
<span class="nc bnc" id="L492" title="All 2 branches missed.">    } else if (k == 0) {</span>
<span class="nc" id="L493">      double ans = 1.0;</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">      for (int m0 = 0; m0 &lt; m; m0++) {</span>
<span class="nc" id="L495">        ans *= ((n - r) - m0);</span>
<span class="nc" id="L496">        ans /= (n - m0);</span>
      }
<span class="nc" id="L498">      return ans;</span>
    }

<span class="nc" id="L501">    double ans = 1.0;</span>
    // do (n-r)x...x((n-r)-((m-k)-1))/n x...x (n-((m-k-1)))
    // leaving rest of denominator to get to multiply by (n-(m-1))
    // that's k things which goes into next loop
<span class="nc bnc" id="L505" title="All 2 branches missed.">    for (int nr = n - r, n0 = n; nr &gt; (n - r) - (m - k); nr--, n0--) {</span>
      // System.out.println(&quot;Multiplying by &quot; + nr);
<span class="nc" id="L507">      ans *= nr;</span>
      // System.out.println(&quot;Dividing by &quot; + n0);
<span class="nc" id="L509">      ans /= n0;</span>
    }
    // System.out.println(&quot;Done phase 1&quot;);
<span class="nc bnc" id="L512" title="All 2 branches missed.">    for (int k0 = 0; k0 &lt; k; k0++) {</span>
<span class="nc" id="L513">      ans *= (m - k0);</span>
      // System.out.println(&quot;Multiplying by &quot; + (m-k0));
<span class="nc" id="L515">      ans /= ((n - (m - k0)) + 1);</span>
      // System.out.println(&quot;Dividing by &quot; + ((n-(m+k0)+1)));
<span class="nc" id="L517">      ans *= (r - k0);</span>
      // System.out.println(&quot;Multiplying by &quot; + (r-k0));
<span class="nc" id="L519">      ans /= (k0 + 1);</span>
      // System.out.println(&quot;Dividing by &quot; + (k0+1));
    }
<span class="nc" id="L522">    return ans;</span>
  }


  /**
   * Find a one tailed exact binomial test probability.  Finds the chance
   * of this or a higher result
   *
   * @param k number of successes
   * @param n Number of trials
   * @param p Probability of a success
   */
  public static double exactBinomial(int k, int n, double p) {
<span class="nc" id="L535">    double total = 0.0;</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">    for (int m = k; m &lt;= n; m++) {</span>
<span class="nc" id="L537">      double nChooseM = 1.0;</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">      for (int r = 1; r &lt;= m; r++) {</span>
<span class="nc" id="L539">        nChooseM *= (n - r) + 1;</span>
<span class="nc" id="L540">        nChooseM /= r;</span>
      }
      // System.out.println(n + &quot; choose &quot; + m + &quot; is &quot; + nChooseM);
      // System.out.println(&quot;prob contribution is &quot; +
      //	       (nChooseM * Math.pow(p, m) * Math.pow(1.0-p, n - m)));
<span class="nc" id="L545">      total += nChooseM * Math.pow(p, m) * Math.pow(1.0 - p, n - m);</span>
    }
<span class="nc" id="L547">    return total;</span>
  }


  /**
   * Find a one-tailed Fisher's exact probability.  Chance of having seen
   * this or a more extreme departure from what you would have expected
   * given independence.  I.e., k &amp;ge; the value passed in.
   * Warning: this was done just for collocations, where you are
   * concerned with the case of k being larger than predicted.  It doesn't
   * correctly handle other cases, such as k being smaller than expected.
   *
   * @param k The number of black balls drawn
   * @param n The total number of balls
   * @param r The number of black balls
   * @param m The number of balls drawn
   * @return The Fisher's exact p-value
   */
  public static double oneTailedFishersExact(int k, int n, int r, int m) {
<span class="nc bnc" id="L566" title="All 12 branches missed.">    if (k &lt; 0 || k &lt; (m + r) - n || k &gt; r || k &gt; m || r &gt; n || m &gt; n) {</span>
<span class="nc bnc" id="L567" title="All 12 branches missed.">      throw new IllegalArgumentException(&quot;Invalid Fisher's exact: &quot; + &quot;k=&quot; + k + &quot; n=&quot; + n + &quot; r=&quot; + r + &quot; m=&quot; + m + &quot; k&lt;0=&quot; + (k &lt; 0) + &quot; k&lt;(m+r)-n=&quot; + (k &lt; (m + r) - n) + &quot; k&gt;r=&quot; + (k &gt; r) + &quot; k&gt;m=&quot; + (k &gt; m) + &quot; r&gt;n=&quot; + (r &gt; n) + &quot;m&gt;n=&quot; + (m &gt; n));</span>
    }
    // exploit symmetry of problem
<span class="nc bnc" id="L570" title="All 2 branches missed.">    if (m &gt; n / 2) {</span>
<span class="nc" id="L571">      m = n - m;</span>
<span class="nc" id="L572">      k = r - k;</span>
    }
<span class="nc bnc" id="L574" title="All 2 branches missed.">    if (r &gt; n / 2) {</span>
<span class="nc" id="L575">      r = n - r;</span>
<span class="nc" id="L576">      k = m - k;</span>
    }
<span class="nc bnc" id="L578" title="All 2 branches missed.">    if (m &gt; r) {</span>
<span class="nc" id="L579">      int temp = m;</span>
<span class="nc" id="L580">      m = r;</span>
<span class="nc" id="L581">      r = temp;</span>
    }
    // now we have that k &lt;= m &lt;= r &lt;= n/2

<span class="nc" id="L585">    double total = 0.0;</span>
<span class="nc bnc" id="L586" title="All 2 branches missed.">    if (k &gt; m / 2) {</span>
      // sum from k to m
<span class="nc bnc" id="L588" title="All 2 branches missed.">      for (int k0 = k; k0 &lt;= m; k0++) {</span>
        // System.out.println(&quot;Calling hypg(&quot; + k0 + &quot;; &quot; + n +
        // 		   &quot;, &quot; + r + &quot;, &quot; + m + &quot;)&quot;);
<span class="nc" id="L591">        total += SloppyMath.hypergeometric(k0, n, r, m);</span>
      }
    } else {
      // sum from max(0, (m+r)-n) to k-1, and then subtract from 1
<span class="nc" id="L595">      int min = Math.max(0, (m + r) - n);</span>
<span class="nc bnc" id="L596" title="All 2 branches missed.">      for (int k0 = min; k0 &lt; k; k0++) {</span>
        // System.out.println(&quot;Calling hypg(&quot; + k0 + &quot;; &quot; + n +
        // 		   &quot;, &quot; + r + &quot;, &quot; + m + &quot;)&quot;);
<span class="nc" id="L599">        total += SloppyMath.hypergeometric(k0, n, r, m);</span>
      }
<span class="nc" id="L601">      total = 1.0 - total;</span>
    }
<span class="nc" id="L603">    return total;</span>
  }

  /**
   * Find a 2x2 chi-square value.
   * Note: could do this more neatly using simplified formula for 2x2 case.
   *
   * @param k The number of black balls drawn
   * @param n The total number of balls
   * @param r The number of black balls
   * @param m The number of balls drawn
   * @return The Fisher's exact p-value
   */
  public static double chiSquare2by2(int k, int n, int r, int m) {
<span class="nc" id="L617">    int[][] cg = {{k, r - k}, {m - k, n - (k + (r - k) + (m - k))}};</span>
<span class="nc" id="L618">    int[] cgr = {r, n - r};</span>
<span class="nc" id="L619">    int[] cgc = {m, n - m};</span>
<span class="nc" id="L620">    double total = 0.0;</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">    for (int i = 0; i &lt; 2; i++) {</span>
<span class="nc bnc" id="L622" title="All 2 branches missed.">      for (int j = 0; j &lt; 2; j++) {</span>
<span class="nc" id="L623">        double exp = (double) cgr[i] * cgc[j] / n;</span>
<span class="nc" id="L624">        total += (cg[i][j] - exp) * (cg[i][j] - exp) / exp;</span>
      }
    }
<span class="nc" id="L627">    return total;</span>
  }

  /**
   * Compute the sigmoid function with mean zero.
   * Care is taken to compute an accurate answer without
   * numerical overflow. (Added by rajatr)
   *
   * @param x Point to compute sigmoid at.
   * @return Value of the sigmoid, given by 1/(1+exp(-x))
   */
  public static double sigmoid(double x) {
<span class="nc bnc" id="L639" title="All 2 branches missed.">    if (x&lt;0) {</span>
<span class="nc" id="L640">      double num = Math.exp(x);</span>
<span class="nc" id="L641">      return num / (1.0 + num);</span>
    }
    else {
<span class="nc" id="L644">      double den = 1.0 + Math.exp(-x);</span>
<span class="nc" id="L645">      return 1.0 / den;</span>
    }
  }


  private static float[] acosCache; // = null;

  /**
   * Compute acos very quickly by directly looking up the value.
   * @param cosValue The cosine of the angle to fine.
   * @return The angle corresponding to the cosine value.
   * @throws IllegalArgumentException if cosValue is not between -1 and 1
   */
  public static double acos(double cosValue) {
<span class="fc bfc" id="L659" title="All 4 branches covered.">    if (cosValue &lt; -1.0 || cosValue &gt; 1.0) {</span>
<span class="fc" id="L660">      throw new IllegalArgumentException(&quot;Cosine is not between -1 and 1: &quot; + cosValue);</span>
    }
<span class="fc" id="L662">    int numSamples = 10000;</span>
<span class="fc bfc" id="L663" title="All 2 branches covered.">    if (acosCache == null) {</span>
<span class="fc" id="L664">      acosCache = new float[numSamples + 1];</span>
<span class="fc bfc" id="L665" title="All 2 branches covered.">      for (int i = 0; i &lt;= numSamples; ++i) {</span>
<span class="fc" id="L666">        double x = 2.0 / ((double) numSamples) * ((double) i) - 1.0;</span>
<span class="fc" id="L667">        acosCache[i] = (float) Math.acos(x);</span>
      }
    }

<span class="fc" id="L671">    int i = ((int) (((cosValue + 1.0) / 2.0) * ((double) numSamples)));</span>
<span class="fc" id="L672">    return acosCache[i];</span>
  }


  public static double poisson(int x, double lambda) {
<span class="nc bnc" id="L677" title="All 4 branches missed.">    if (x&lt;0 || lambda&lt;=0.0) throw new RuntimeException(&quot;Bad arguments: &quot; + x + &quot; and &quot; + lambda);</span>
<span class="nc" id="L678">    double p = (Math.exp(-lambda) * Math.pow(lambda, x)) / factorial(x);</span>
<span class="nc bnc" id="L679" title="All 4 branches missed.">    if (Double.isInfinite(p) || p&lt;=0.0) throw new RuntimeException(Math.exp(-lambda) +&quot; &quot;+ Math.pow(lambda, x) + ' ' + factorial(x));</span>
<span class="nc" id="L680">    return p;</span>
  }

  /**
   * Uses floating point so that it can represent the really big numbers that come up.
   * @param x Argument to take factorial of
   * @return Factorial of argument
   */
  public static double factorial(int x) {
<span class="nc" id="L689">    double result = 1.0;</span>
<span class="nc bnc" id="L690" title="All 2 branches missed.">    for (int i=x; i&gt;1; i--) {</span>
<span class="nc" id="L691">      result *= i;</span>
    }
<span class="nc" id="L693">    return result;</span>
  }


  /**
   * Taken from http://nerds-central.blogspot.com/2011/05/high-speed-parse-double-for-jvm.html
   */
<span class="fc" id="L700">  private final static double exps[] = new double[617];</span>
  static {
<span class="fc bfc" id="L702" title="All 2 branches covered.">    for(int i=-308;i&lt;308;++i) {</span>
<span class="fc" id="L703">      String toParse = &quot;1.0e&quot; + i;</span>
<span class="fc" id="L704">      exps[(i + 308)]=Double.parseDouble(&quot;1.0e&quot; + i);</span>
    }
<span class="fc" id="L706">  }</span>


  /**
   * Taken from http://nerds-central.blogspot.com/2011/05/high-speed-parse-double-for-jvm.html
   */
  public static double parseDouble(boolean negative, long mantissa, int  exponent) {
     // Do this with no locals other than the arguments to make it stupid easy
     // for the JIT compiler to inline the code.
<span class="fc" id="L715">    int e = -16;</span>
<span class="fc bfc" id="L716" title="All 2 branches covered.">    return (negative ? -1. : 1.) * (((double)mantissa) * exps[(e + 308)]) * exps[(exponent + 308)];</span>
  }


  /**
   * Segment a double into a mantissa and exponent.
   */
  public static Triple&lt;Boolean, Long, Integer&gt; segmentDouble(double d) {
<span class="pc bpc" id="L724" title="2 of 4 branches missed.">    if (Double.isInfinite(d) || Double.isNaN(d)) {</span>
<span class="nc" id="L725">      throw new IllegalArgumentException(&quot;Cannot handle weird double: &quot; + d);</span>
    }
<span class="fc bfc" id="L727" title="All 2 branches covered.">    boolean negative = d &lt; 0;</span>
<span class="fc" id="L728">    d = Math.abs(d);</span>
<span class="fc" id="L729">    int exponent = 0;</span>
<span class="fc bfc" id="L730" title="All 2 branches covered.">    while (d &gt;= 10.0) {</span>
<span class="fc" id="L731">      exponent += 1;</span>
<span class="fc" id="L732">      d = d / 10.;</span>
    }
<span class="fc bfc" id="L734" title="All 2 branches covered.">    while (d &lt; 1.0) {</span>
<span class="fc" id="L735">      exponent -= 1;</span>
<span class="fc" id="L736">      d = d * 10.;</span>
    }
<span class="fc" id="L738">    return Triple.makeTriple(negative, (long) (d * 10000000000000000.), exponent);</span>
  }


  /**
   * From http://nadeausoftware.com/articles/2009/08/java_tip_how_parse_integers_quickly
   *
   * Parse an integer very quickly, without sanity checks.
   */
  public static long parseInt( final String s ) {
    // Check for a sign.
<span class="fc" id="L749">    long num  = 0;</span>
<span class="fc" id="L750">    long sign = -1;</span>
<span class="fc" id="L751">    final int len  = s.length( );</span>
<span class="fc" id="L752">    final char ch  = s.charAt( 0 );</span>
<span class="fc bfc" id="L753" title="All 2 branches covered.">    if ( ch == '-' ) {</span>
<span class="fc" id="L754">      sign = 1;</span>
    }
    else {
<span class="fc" id="L757">      final long d = ch - '0';</span>
<span class="fc" id="L758">      num = -d;</span>
    }
    // Build the number.
<span class="fc bfc" id="L761" title="All 2 branches covered.">    final long max = (sign == -1) ?</span>
        -Long.MAX_VALUE : Long.MIN_VALUE;
<span class="fc" id="L763">    final long multmax = max / 10;</span>
<span class="fc" id="L764">    int i = 1;</span>
<span class="fc bfc" id="L765" title="All 2 branches covered.">    while ( i &lt; len ) {</span>
<span class="fc" id="L766">      long d = s.charAt(i++) - '0';</span>
<span class="fc" id="L767">      num *= 10;</span>
<span class="fc" id="L768">      num -= d;</span>
<span class="fc" id="L769">    }</span>
<span class="fc" id="L770">    return sign * num;</span>
  }

  /**
   * Tests the hypergeometric distribution code, or other functions
   * provided in this module.
   *
   * @param args Either none, and the log add routines are tested, or the
   *             following 4 arguments: k (cell), n (total), r (row), m (col)
   */
  public static void main(String[] args) {
<span class="nc bnc" id="L781" title="All 2 branches missed.">    if (args.length == 0) {</span>
<span class="nc" id="L782">      log.info(&quot;Usage: java edu.stanford.nlp.math.SloppyMath &quot; + &quot;[-logAdd|-fishers k n r m|-binomial r n p&quot;);</span>
<span class="nc bnc" id="L783" title="All 2 branches missed.">    } else if (args[0].equals(&quot;-logAdd&quot;)) {</span>
<span class="nc" id="L784">      System.out.println(&quot;Log adds of neg infinity numbers, etc.&quot;);</span>
<span class="nc" id="L785">      System.out.println(&quot;(logs) -Inf + -Inf = &quot; + logAdd(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY));</span>
<span class="nc" id="L786">      System.out.println(&quot;(logs) -Inf + -7 = &quot; + logAdd(Double.NEGATIVE_INFINITY, -7.0));</span>
<span class="nc" id="L787">      System.out.println(&quot;(logs) -7 + -Inf = &quot; + logAdd(-7.0, Double.NEGATIVE_INFINITY));</span>
<span class="nc" id="L788">      System.out.println(&quot;(logs) -50 + -7 = &quot; + logAdd(-50.0, -7.0));</span>
<span class="nc" id="L789">      System.out.println(&quot;(logs) -11 + -7 = &quot; + logAdd(-11.0, -7.0));</span>
<span class="nc" id="L790">      System.out.println(&quot;(logs) -7 + -11 = &quot; + logAdd(-7.0, -11.0));</span>
<span class="nc" id="L791">      System.out.println(&quot;real 1/2 + 1/2 = &quot; + logAdd(Math.log(0.5), Math.log(0.5)));</span>
<span class="nc bnc" id="L792" title="All 2 branches missed.">    } else if (args[0].equals(&quot;-fishers&quot;)) {</span>
<span class="nc" id="L793">      int k = Integer.parseInt(args[1]);</span>
<span class="nc" id="L794">      int n = Integer.parseInt(args[2]);</span>
<span class="nc" id="L795">      int r = Integer.parseInt(args[3]);</span>
<span class="nc" id="L796">      int m = Integer.parseInt(args[4]);</span>
<span class="nc" id="L797">      double ans = SloppyMath.hypergeometric(k, n, r, m);</span>
<span class="nc" id="L798">      System.out.println(&quot;hypg(&quot; + k + &quot;; &quot; + n + &quot;, &quot; + r + &quot;, &quot; + m + &quot;) = &quot; + ans);</span>
<span class="nc" id="L799">      ans = SloppyMath.oneTailedFishersExact(k, n, r, m);</span>
<span class="nc" id="L800">      System.out.println(&quot;1-tailed Fisher's exact(&quot; + k + &quot;; &quot; + n + &quot;, &quot; + r + &quot;, &quot; + m + &quot;) = &quot; + ans);</span>
<span class="nc" id="L801">      double ansChi = SloppyMath.chiSquare2by2(k, n, r, m);</span>
<span class="nc" id="L802">      System.out.println(&quot;chiSquare(&quot; + k + &quot;; &quot; + n + &quot;, &quot; + r + &quot;, &quot; + m + &quot;) = &quot; + ansChi);</span>

<span class="nc" id="L804">      System.out.println(&quot;Swapping arguments should give same hypg:&quot;);</span>
<span class="nc" id="L805">      ans = SloppyMath.hypergeometric(k, n, r, m);</span>
<span class="nc" id="L806">      System.out.println(&quot;hypg(&quot; + k + &quot;; &quot; + n + &quot;, &quot; + m + &quot;, &quot; + r + &quot;) = &quot; + ans);</span>
<span class="nc" id="L807">      int othrow = n - m;</span>
<span class="nc" id="L808">      int othcol = n - r;</span>
<span class="nc" id="L809">      int cell12 = m - k;</span>
<span class="nc" id="L810">      int cell21 = r - k;</span>
<span class="nc" id="L811">      int cell22 = othrow - (r - k);</span>
<span class="nc" id="L812">      ans = SloppyMath.hypergeometric(cell12, n, othcol, m);</span>
<span class="nc" id="L813">      System.out.println(&quot;hypg(&quot; + cell12 + &quot;; &quot; + n + &quot;, &quot; + othcol + &quot;, &quot; + m + &quot;) = &quot; + ans);</span>
<span class="nc" id="L814">      ans = SloppyMath.hypergeometric(cell21, n, r, othrow);</span>
<span class="nc" id="L815">      System.out.println(&quot;hypg(&quot; + cell21 + &quot;; &quot; + n + &quot;, &quot; + r + &quot;, &quot; + othrow + &quot;) = &quot; + ans);</span>
<span class="nc" id="L816">      ans = SloppyMath.hypergeometric(cell22, n, othcol, othrow);</span>
<span class="nc" id="L817">      System.out.println(&quot;hypg(&quot; + cell22 + &quot;; &quot; + n + &quot;, &quot; + othcol + &quot;, &quot; + othrow + &quot;) = &quot; + ans);</span>
<span class="nc bnc" id="L818" title="All 2 branches missed.">    } else if (args[0].equals(&quot;-binomial&quot;)) {</span>
<span class="nc" id="L819">      int k = Integer.parseInt(args[1]);</span>
<span class="nc" id="L820">      int n = Integer.parseInt(args[2]);</span>
<span class="nc" id="L821">      double p = Double.parseDouble(args[3]);</span>
<span class="nc" id="L822">      double ans = SloppyMath.exactBinomial(k, n, p);</span>
<span class="nc" id="L823">      System.out.println(&quot;Binomial p(X &gt;= &quot; + k + &quot;; &quot; + n + &quot;, &quot; + p + &quot;) = &quot; + ans);</span>
<span class="nc" id="L824">    } else {</span>
<span class="nc" id="L825">      log.info(&quot;Unknown option: &quot; + args[0]);</span>
    }
<span class="nc" id="L827">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>