<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>QuestionToStatementTranslator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.naturalli</a> &gt; <span class="el_source">QuestionToStatementTranslator.java</span></div><h1>QuestionToStatementTranslator.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.naturalli;

import edu.stanford.nlp.ling.CoreAnnotation;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.ling.tokensregex.TokenSequenceMatcher;
import edu.stanford.nlp.ling.tokensregex.TokenSequencePattern;

import java.util.*;

/**
 * &lt;p&gt;
 * Translate a question to a statement. For example, &quot;where was Obama born?&quot; to &quot;Obama was born in ?&quot;.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * This class was developed for, and therefore likely performs best on (read: &quot;over-fits gloriously to&quot;)
 * the webquestions dataset (http://www-nlp.stanford.edu/software/sempre/).
 * The rules were created based off of the webquestions
 * training set, and tested against the sentences in the QuestionToStatementTranslatorTest.
 * If something fails, please add it to the test when you fix it!
 * If you change something here, please validate it wit the test!
 * &lt;/p&gt;
 *
 * @author Gabor Angeli
 */
@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L27">public class QuestionToStatementTranslator {</span>

<span class="nc" id="L29">  public static class UnknownTokenMarker implements CoreAnnotation&lt;Boolean&gt; {</span>
    @Override
<span class="nc" id="L31">    public Class&lt;Boolean&gt; getType() { return Boolean.class; }</span>
  }

  /** The missing word marker, when the object of the sentence is not type constrained. */
<span class="fc" id="L35">  private final CoreLabel WORD_MISSING = new CoreLabel(){{</span>
<span class="fc" id="L36">    setWord(&quot;thing&quot;);</span>
<span class="fc" id="L37">    setValue(&quot;thing&quot;);</span>
<span class="fc" id="L38">    setLemma(&quot;thing&quot;);</span>
<span class="fc" id="L39">    setTag(&quot;NN&quot;);</span>
<span class="fc" id="L40">    setNER(&quot;O&quot;);</span>
<span class="fc" id="L41">    setIndex(-1);</span>
<span class="fc" id="L42">    setBeginPosition(-1);</span>
<span class="fc" id="L43">    setEndPosition(-1);</span>
<span class="fc" id="L44">    set(UnknownTokenMarker.class, true);</span>
<span class="fc" id="L45">  }};</span>

  /** The missing word marker typed as a location. */
<span class="fc" id="L48">  private final CoreLabel WORD_MISSING_LOCATION = new CoreLabel(){{</span>
<span class="fc" id="L49">    setWord(&quot;location&quot;);</span>
<span class="fc" id="L50">    setValue(&quot;location&quot;);</span>
<span class="fc" id="L51">    setLemma(&quot;location&quot;);</span>
<span class="fc" id="L52">    setTag(&quot;NNP&quot;);</span>
<span class="fc" id="L53">    setNER(&quot;O&quot;);</span>
<span class="fc" id="L54">    setIndex(-1);</span>
<span class="fc" id="L55">    setBeginPosition(-1);</span>
<span class="fc" id="L56">    setEndPosition(-1);</span>
<span class="fc" id="L57">    set(UnknownTokenMarker.class, true);</span>
<span class="fc" id="L58">  }};</span>

  /** The missing word marker typed as a person. */
<span class="fc" id="L61">  private final CoreLabel WORD_MISSING_PERSON = new CoreLabel(){{</span>
<span class="fc" id="L62">    setWord(&quot;person&quot;);</span>
<span class="fc" id="L63">    setValue(&quot;person&quot;);</span>
<span class="fc" id="L64">    setLemma(&quot;person&quot;);</span>
<span class="fc" id="L65">    setTag(&quot;NNP&quot;);</span>
<span class="fc" id="L66">    setNER(&quot;O&quot;);</span>
<span class="fc" id="L67">    setIndex(-1);</span>
<span class="fc" id="L68">    setBeginPosition(-1);</span>
<span class="fc" id="L69">    setEndPosition(-1);</span>
<span class="fc" id="L70">    set(UnknownTokenMarker.class, true);</span>
<span class="fc" id="L71">  }};</span>

  /** The missing word marker typed as a time. */
<span class="fc" id="L74">  private final CoreLabel WORD_MISSING_TIME = new CoreLabel(){{</span>
<span class="fc" id="L75">    setWord(&quot;time&quot;);</span>
<span class="fc" id="L76">    setValue(&quot;time&quot;);</span>
<span class="fc" id="L77">    setLemma(&quot;time&quot;);</span>
<span class="fc" id="L78">    setTag(&quot;NN&quot;);</span>
<span class="fc" id="L79">    setNER(&quot;O&quot;);</span>
<span class="fc" id="L80">    setIndex(-1);</span>
<span class="fc" id="L81">    setBeginPosition(-1);</span>
<span class="fc" id="L82">    setEndPosition(-1);</span>
<span class="fc" id="L83">    set(UnknownTokenMarker.class, true);</span>
<span class="fc" id="L84">  }};</span>

  /** The word &quot;,&quot; as a CoreLabel */
<span class="fc" id="L87">  private final CoreLabel WORD_COMMA = new CoreLabel(){{</span>
<span class="fc" id="L88">    setWord(&quot;,&quot;);</span>
<span class="fc" id="L89">    setValue(&quot;,&quot;);</span>
<span class="fc" id="L90">    setLemma(&quot;,&quot;);</span>
<span class="fc" id="L91">    setTag(&quot;,&quot;);</span>
<span class="fc" id="L92">    setNER(&quot;O&quot;);</span>
<span class="fc" id="L93">    setIndex(-1);</span>
<span class="fc" id="L94">    setBeginPosition(-1);</span>
<span class="fc" id="L95">    setEndPosition(-1);</span>
<span class="fc" id="L96">  }};</span>

  /** The word &quot;from&quot; as a CoreLabel */
<span class="fc" id="L99">  private final CoreLabel WORD_FROM = new CoreLabel(){{</span>
<span class="fc" id="L100">    setWord(&quot;from&quot;);</span>
<span class="fc" id="L101">    setValue(&quot;from&quot;);</span>
<span class="fc" id="L102">    setLemma(&quot;from&quot;);</span>
<span class="fc" id="L103">    setTag(&quot;IN&quot;);</span>
<span class="fc" id="L104">    setNER(&quot;O&quot;);</span>
<span class="fc" id="L105">    setIndex(-1);</span>
<span class="fc" id="L106">    setBeginPosition(-1);</span>
<span class="fc" id="L107">    setEndPosition(-1);</span>
<span class="fc" id="L108">  }};</span>

  /** The word &quot;at&quot; as a CoreLabel */
<span class="fc" id="L111">  private final CoreLabel WORD_AT = new CoreLabel(){{</span>
<span class="fc" id="L112">    setWord(&quot;at&quot;);</span>
<span class="fc" id="L113">    setValue(&quot;at&quot;);</span>
<span class="fc" id="L114">    setLemma(&quot;at&quot;);</span>
<span class="fc" id="L115">    setTag(&quot;IN&quot;);</span>
<span class="fc" id="L116">    setNER(&quot;O&quot;);</span>
<span class="fc" id="L117">    setIndex(-1);</span>
<span class="fc" id="L118">    setBeginPosition(-1);</span>
<span class="fc" id="L119">    setEndPosition(-1);</span>
<span class="fc" id="L120">  }};</span>

  /** The word &quot;in&quot; as a CoreLabel */
<span class="fc" id="L123">  private final CoreLabel WORD_IN = new CoreLabel(){{</span>
<span class="fc" id="L124">    setWord(&quot;in&quot;);</span>
<span class="fc" id="L125">    setValue(&quot;in&quot;);</span>
<span class="fc" id="L126">    setLemma(&quot;in&quot;);</span>
<span class="fc" id="L127">    setTag(&quot;IN&quot;);</span>
<span class="fc" id="L128">    setNER(&quot;O&quot;);</span>
<span class="fc" id="L129">    setIndex(-1);</span>
<span class="fc" id="L130">    setBeginPosition(-1);</span>
<span class="fc" id="L131">    setEndPosition(-1);</span>
<span class="fc" id="L132">  }};</span>

<span class="fc" id="L134">  private final Set&lt;String&gt; fromNotAtDict = Collections.unmodifiableSet(new HashSet&lt;String&gt;() {{</span>
<span class="fc" id="L135">    add(&quot;funding&quot;); add(&quot;oil&quot;);</span>
<span class="fc" id="L136">  }});</span>


  /**
   * The pattern for &quot;what is ...&quot; sentences.
   * @see edu.stanford.nlp.naturalli.QuestionToStatementTranslator#processWhatIs(edu.stanford.nlp.ling.tokensregex.TokenSequenceMatcher)
   */
<span class="fc" id="L143">  private final TokenSequencePattern triggerWhatIs = TokenSequencePattern.compile(</span>
      &quot;[{lemma:/what|which/; tag:/W.*/}] &quot; +
          &quot;(?$answer_type [tag:/N.*/]+)? &quot; +
          &quot;(?$be [{lemma:be}] )&quot; +
          &quot;(?: /the/ (?$answer_type [word:/name/]) [tag:/[PW].*/])? &quot; +
          &quot;(?$statement_body []+?) &quot; +
          &quot;(?$prep_num [!{tag:IN}] [tag:CD] )? &quot; +
          &quot;(?$suffix [tag:/[RI].*/] )? &quot; +
          &quot;(?$punct [word:/[?\\.!]/])&quot;);

  /**
   * Process sentences matching the &quot;what is ...&quot; pattern.
   *
   * @param matcher The matcher that matched the pattern.
   *
   * @return The converted statement.
   *
   * @see edu.stanford.nlp.naturalli.QuestionToStatementTranslator#triggerWhatIs
   */
  private List&lt;CoreLabel&gt; processWhatIs(TokenSequenceMatcher matcher) {
    // Grab the body of the sentence
<span class="fc" id="L164">    List&lt;CoreLabel&gt; body = (List&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$statement_body&quot;);</span>

    // Add the &quot;be&quot; token
    // [Gabor]: This is black magic -- if the &quot;be&quot; got misplaced, God help us all.
    // [Gabor]: Mostly you. You'll need most of the help.
<span class="fc" id="L169">    List&lt;CoreLabel&gt; be = (List&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$be&quot;);</span>
<span class="fc" id="L170">    List&lt;CoreLabel&gt; suffix = (List&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$suffix&quot;);</span>
<span class="fc" id="L171">    boolean addedBe = false;</span>
<span class="fc" id="L172">    boolean addedSuffix = false;</span>
<span class="fc bfc" id="L173" title="All 2 branches covered.">    for (int i = 1; i &lt; body.size(); ++i) {</span>
<span class="fc" id="L174">      CoreLabel tokI = body.get(i);</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">      if (tokI.tag() != null &amp;&amp;</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">          (tokI.tag().startsWith(&quot;V&quot;) ||</span>
<span class="fc bfc" id="L177" title="All 4 branches covered.">              (tokI.tag().startsWith(&quot;J&quot;) &amp;&amp; suffix != null) ||</span>
<span class="fc bfc" id="L178" title="All 4 branches covered.">              (tokI.tag().startsWith(&quot;D&quot;) &amp;&amp; suffix != null) ||</span>
<span class="pc bpc" id="L179" title="1 of 4 branches missed.">              (tokI.tag().startsWith(&quot;R&quot;) &amp;&amp; suffix != null) )) {</span>
<span class="fc" id="L180">        body.add(i, be.get(0)); i += 1;</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">        if (suffix != null) {</span>
<span class="pc bpc" id="L182" title="1 of 4 branches missed.">          while (i &lt; body.size() &amp;&amp; body.get(i).tag() != null &amp;&amp;</span>
<span class="fc bfc" id="L183" title="All 6 branches covered.">              (body.get(i).tag().startsWith(&quot;J&quot;) || body.get(i).tag().startsWith(&quot;V&quot;) || body.get(i).tag().startsWith(&quot;R&quot;) ||</span>
<span class="pc bpc" id="L184" title="1 of 4 branches missed.">               body.get(i).tag().startsWith(&quot;N&quot;) || body.get(i).tag().startsWith(&quot;D&quot;)) &amp;&amp;</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">              !body.get(i).tag().equals(&quot;VBG&quot;)) {</span>
<span class="fc" id="L186">            i += 1;</span>
          }
<span class="fc" id="L188">          body.add(i, suffix.get(0));</span>
<span class="fc" id="L189">          addedSuffix = true;</span>
        }
<span class="fc" id="L191">        addedBe = true;</span>
<span class="fc" id="L192">        break;</span>
      }
    }
    // Tweak to handle dropped prepositions
<span class="fc" id="L196">    List&lt;CoreLabel&gt; prepNum = (List&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$prep_num&quot;);</span>
<span class="fc bfc" id="L197" title="All 2 branches covered.">    if (prepNum != null) {</span>
<span class="fc" id="L198">      body.add(prepNum.get(0));</span>
<span class="fc" id="L199">      body.add(WORD_IN);</span>
<span class="fc" id="L200">      body.add(prepNum.get(1));</span>
    }
    // Add the &quot;be&quot; and suffix
<span class="fc bfc" id="L203" title="All 2 branches covered.">    if (!addedBe) {</span>
<span class="fc" id="L204">      body.addAll(be);</span>
    }
<span class="fc bfc" id="L206" title="All 4 branches covered.">    if (!addedSuffix &amp;&amp; suffix != null) {</span>
<span class="fc" id="L207">      body.addAll(suffix);</span>
    }


    // Grab the object
<span class="fc" id="L212">    List&lt;CoreLabel&gt; objType = (List&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$answer_type&quot;);</span>
    // (try to insert the object earlier)
<span class="fc" id="L214">    int i = body.size() - 1;</span>
<span class="pc bpc" id="L215" title="2 of 4 branches missed.">    while (i &gt;= 1 &amp;&amp; body.get(i).tag() != null &amp;&amp;</span>
<span class="pc bpc" id="L216" title="1 of 4 branches missed.">        (body.get(i).tag().startsWith(&quot;N&quot;) || body.get(i).tag().startsWith(&quot;J&quot;))) {</span>
<span class="fc" id="L217">      i -= 1;</span>
    }
    // (actually insert the object)
<span class="pc bpc" id="L220" title="1 of 4 branches missed.">    if (objType == null || objType.isEmpty() ||</span>
<span class="pc bpc" id="L221" title="1 of 4 branches missed.">        (objType.size() == 1 &amp;&amp; objType.get(0).word().equals(&quot;name&quot;))) {</span>
      // (case: untyped)
<span class="pc bpc" id="L223" title="2 of 6 branches missed.">      if (i &lt; body.size() - 1 &amp;&amp; body.get(i).tag() != null &amp;&amp; body.get(i).tag().startsWith(&quot;IN&quot;)) {</span>
<span class="fc" id="L224">        body.add(i, WORD_MISSING);</span>
      } else {
<span class="fc" id="L226">        body.add(WORD_MISSING);</span>
      }
    } else {
      // (case: typed)
<span class="fc bfc" id="L230" title="All 2 branches covered.">      for (CoreLabel obj : objType) {</span>
<span class="fc" id="L231">        obj.set(UnknownTokenMarker.class, true);</span>
<span class="fc" id="L232">      }</span>
<span class="fc" id="L233">      body.addAll(objType);</span>
    }

    // Return
<span class="fc" id="L237">    return body;</span>
  }

  /**
   * The pattern for &quot;what/which NN is ...&quot; sentences.
   * @see edu.stanford.nlp.naturalli.QuestionToStatementTranslator#processWhNNIs(edu.stanford.nlp.ling.tokensregex.TokenSequenceMatcher)
   */
<span class="fc" id="L244">  private final TokenSequencePattern triggerWhNNIs = TokenSequencePattern.compile(</span>
      &quot;[{lemma:/what|which/; tag:/W.*/}] &quot; +
          &quot;(?$answer_type [!{lemma:be}]+) &quot; +
          &quot;(?$be [{lemma:be}] [{tag:/[VRIJ].*/}] ) &quot; +
          &quot;(?$statement_body []+?) &quot; +
          &quot;(?$punct [word:/[?\\.!]/])&quot;);

  /**
   * Process sentences matching the &quot;what NN is ...&quot; pattern.
   *
   * @param matcher The matcher that matched the pattern.
   *
   * @return The converted statement.
   *
   * @see edu.stanford.nlp.naturalli.QuestionToStatementTranslator#triggerWhNNIs
   */
  private List&lt;CoreLabel&gt; processWhNNIs(TokenSequenceMatcher matcher) {
<span class="fc" id="L261">    List&lt;CoreLabel&gt; sentence = (List&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$answer_type&quot;);</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">    for (CoreLabel lbl : sentence) {</span>
<span class="fc" id="L263">      lbl.set(UnknownTokenMarker.class, true);</span>
<span class="fc" id="L264">    }</span>
<span class="fc" id="L265">    sentence.addAll((Collection&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$be&quot;));</span>
<span class="fc" id="L266">    sentence.addAll((Collection&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$statement_body&quot;));</span>
<span class="fc" id="L267">    return sentence;</span>
  }

  /**
   * The pattern for &quot;what/which NN have ...&quot; sentences.
   * @see edu.stanford.nlp.naturalli.QuestionToStatementTranslator#processWhNNHave(edu.stanford.nlp.ling.tokensregex.TokenSequenceMatcher)
   */
<span class="fc" id="L274">  private final TokenSequencePattern triggerWhNNHave = TokenSequencePattern.compile(</span>
      &quot;[{lemma:/what|which/; tag:/W.*/}] &quot; +
          &quot;(?$answer_type [!{tag:/V.*/}]+) &quot; +
          &quot;(?$have [{lemma:have} | {lemma:do}] ) &quot; +
          &quot;(?$pre_verb [!{tag:/V.*/}]+ ) &quot; +
          &quot;(?$verb [{tag:/V.*/}] [{tag:IN}]? ) &quot; +
          &quot;(?$post_verb []+ )? &quot; +
          &quot;(?$punct [word:/[?\\.!]/])&quot;);

  /**
   * Process sentences matching the &quot;what NN has ...&quot; pattern.
   *
   * @param matcher The matcher that matched the pattern.
   *
   * @return The converted statement.
   *
   * @see edu.stanford.nlp.naturalli.QuestionToStatementTranslator#triggerWhNNHave
   */
  private List&lt;CoreLabel&gt; processWhNNHave(TokenSequenceMatcher matcher) {
<span class="fc" id="L293">    List&lt;CoreLabel&gt; sentence = new ArrayList&lt;&gt;();</span>
    // Add prefix
<span class="fc" id="L295">    sentence.addAll((Collection&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$pre_verb&quot;));</span>

    // Add have/do
<span class="fc" id="L298">    List&lt;CoreLabel&gt; have = (List&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$have&quot;);</span>
<span class="pc bpc" id="L299" title="3 of 8 branches missed.">    if (have != null &amp;&amp; have.size() &gt; 0 &amp;&amp; have.get(0).lemma() != null &amp;&amp; have.get(0).lemma().equals(&quot;have&quot;)) {</span>
<span class="fc" id="L300">      sentence.addAll((Collection&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$have&quot;));</span>
    }

    // Compute answer type
<span class="fc" id="L304">    List&lt;CoreLabel&gt; answer = (List&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$answer_type&quot;);</span>
<span class="pc bpc" id="L305" title="1 of 2 branches missed.">    if (answer != null) {</span>
<span class="fc bfc" id="L306" title="All 2 branches covered.">      for (CoreLabel lbl : answer) {</span>
<span class="fc" id="L307">        lbl.set(UnknownTokenMarker.class, true);</span>
<span class="fc" id="L308">      }</span>
    }

    // Add verb + Answer
<span class="fc" id="L312">    List&lt;CoreLabel&gt; verb = (List&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$verb&quot;);</span>
<span class="fc" id="L313">    List&lt;CoreLabel&gt; post = (List&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$post_verb&quot;);</span>
<span class="pc bpc" id="L314" title="2 of 10 branches missed.">    if (verb.size() &lt; 2 || post == null || post.size() == 0 || post.get(0).tag() == null || post.get(0).tag().equals(&quot;CD&quot;)) {</span>
<span class="fc" id="L315">      sentence.addAll(verb);</span>
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">      if (answer == null) {</span>
<span class="nc" id="L317">        sentence.add(WORD_MISSING);</span>
      } else {
<span class="fc" id="L319">        sentence.addAll(answer);</span>
      }
    } else {
<span class="fc" id="L322">      sentence.add(verb.get(0));</span>
<span class="pc bpc" id="L323" title="1 of 2 branches missed.">      if (answer == null) {</span>
<span class="nc" id="L324">        sentence.add(WORD_MISSING);</span>
      } else {
<span class="fc" id="L326">        sentence.addAll(answer);</span>
      }
<span class="fc" id="L328">      sentence.addAll(verb.subList(1, verb.size()));</span>
    }

    // Add postfix
<span class="fc bfc" id="L332" title="All 2 branches covered.">    if (post != null) {</span>
<span class="pc bpc" id="L333" title="2 of 6 branches missed.">      if (post.size() == 1 &amp;&amp; post.get(0).tag() != null &amp;&amp; post.get(0).tag().equals(&quot;CD&quot;)) {</span>
<span class="fc" id="L334">        sentence.add(WORD_IN);</span>
      }
<span class="fc" id="L336">      sentence.addAll(post);</span>
    }

    // Return
<span class="fc" id="L340">    return sentence;</span>
  }

  /**
   * The pattern for &quot;what/which NN have NN ...&quot; sentences.
   * @see edu.stanford.nlp.naturalli.QuestionToStatementTranslator#processWhNNHaveNN(edu.stanford.nlp.ling.tokensregex.TokenSequenceMatcher)
   */
<span class="fc" id="L347">  private final TokenSequencePattern triggerWhNNHaveNN = TokenSequencePattern.compile(</span>
      &quot;[{lemma:/what|which/; tag:/W.*/}] &quot; +
          &quot;(?$answer_type [tag:/N.*/]+) &quot; +
          &quot;(?$have [{lemma:have}] ) &quot; +
          &quot;(?$statement_body [!{tag:/V.*/}]+?) &quot; +
          &quot;(?$punct [word:/[?\\.!]/])&quot;);

  /**
   * Process sentences matching the &quot;what NN have NN ...&quot; pattern.
   *
   * @param matcher The matcher that matched the pattern.
   *
   * @return The converted statement.
   *
   * @see edu.stanford.nlp.naturalli.QuestionToStatementTranslator#triggerWhNNHaveNN
   */
  private List&lt;CoreLabel&gt; processWhNNHaveNN(TokenSequenceMatcher matcher) {
<span class="fc" id="L364">    List&lt;CoreLabel&gt; sentence = (List&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$answer_type&quot;);</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">    for (CoreLabel lbl : sentence) {</span>
<span class="fc" id="L366">      lbl.set(UnknownTokenMarker.class, true);</span>
<span class="fc" id="L367">    }</span>
<span class="fc" id="L368">    sentence.addAll((Collection&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$have&quot;));</span>
<span class="fc" id="L369">    sentence.addAll((Collection&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$statement_body&quot;));</span>
<span class="fc" id="L370">    return sentence;</span>
  }

  /**
   * The pattern for &quot;what is there ...&quot; sentences.
   * @see edu.stanford.nlp.naturalli.QuestionToStatementTranslator#processWhatIsThere(edu.stanford.nlp.ling.tokensregex.TokenSequenceMatcher)
   */
<span class="fc" id="L377">  private final TokenSequencePattern triggerWhatIsThere = TokenSequencePattern.compile(</span>
      &quot;[{lemma:/what|which/; tag:/W.*/}] &quot; +
          &quot;(?$answer_type [tag:/N.*/]+)? &quot; +
          &quot;(?$be [{lemma:be}] )&quot; +
          &quot;(?$there [{lemma:there; tag:RB}] ) &quot; +
          &quot;(?$adjmod [{tag:/[JN].*/}] )? &quot; +
          &quot;(?$to_verb [{tag:TO}] [{tag:/V.*/}] )? &quot; +
          &quot;(?$statement_body [{tag:IN}] []+?) &quot; +
          &quot;(?$punct [word:/[?\\.!]/])&quot;);

  /**
   * Process sentences matching the &quot;what is ...&quot; pattern.
   *
   * @param matcher The matcher that matched the pattern.
   *
   * @return The converted statement.
   *
   * @see edu.stanford.nlp.naturalli.QuestionToStatementTranslator#triggerWhatIsThere
   */
  private List&lt;CoreLabel&gt; processWhatIsThere(TokenSequenceMatcher matcher) {
    List&lt;CoreLabel&gt; optSpan;

    // Grab the prefix of the sentence
<span class="fc" id="L400">    List&lt;CoreLabel&gt; sentence = (List&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$there&quot;);</span>
<span class="fc" id="L401">    sentence.addAll((List&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$be&quot;));</span>

    // Grab the unknown term
<span class="fc bfc" id="L404" title="All 2 branches covered.">    if ((optSpan = (List&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$adjmod&quot;)) != null) {</span>
<span class="fc" id="L405">      sentence.addAll(optSpan);</span>
    }
<span class="fc" id="L407">    sentence.add(WORD_MISSING);</span>

    // Add body
<span class="fc bfc" id="L410" title="All 2 branches covered.">    if ((optSpan = (List&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$to_verb&quot;)) != null) {</span>
<span class="fc" id="L411">      sentence.addAll(optSpan);</span>
    }
<span class="fc" id="L413">    sentence.addAll((Collection&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$statement_body&quot;));</span>

    // Return
<span class="fc" id="L416">    return sentence;</span>
  }

  /**
   * The pattern for &quot;where do...&quot;  sentences.
   * @see edu.stanford.nlp.naturalli.QuestionToStatementTranslator#processWhereDo(edu.stanford.nlp.ling.tokensregex.TokenSequenceMatcher)
   */
<span class="fc" id="L423">  private final TokenSequencePattern triggerWhereDo = TokenSequencePattern.compile(</span>
      &quot;[{lemma:where; tag:/W.*/}] &quot; +
          &quot;(?$do [ {lemma:/do/} ]) &quot; +
          &quot;(?$statement_body []+?) &quot; +
          &quot;(?$at [tag:/[IT].*/] )? &quot; +
          &quot;(?$loc [tag:/N.*/] )*? &quot; +
          &quot;(?$punct [word:/[?\\.!]/])&quot; );

  /**
   *
   * Process sentences matching the &quot;where do ...&quot; pattern.
   *
   * @param matcher The matcher that matched the pattern.
   *
   * @return The converted statement.
   *
   * @see edu.stanford.nlp.naturalli.QuestionToStatementTranslator#triggerWhereDo
   */
  private List&lt;CoreLabel&gt; processWhereDo(TokenSequenceMatcher matcher) {
    // Get the &quot;at&quot; preposition and the &quot;location&quot; missing marker to use
<span class="fc" id="L443">    List&lt;CoreLabel&gt; specloc = (List&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$loc&quot;);</span>
<span class="fc" id="L444">    CoreLabel wordAt = WORD_AT;</span>
<span class="fc" id="L445">    CoreLabel missing = WORD_MISSING_LOCATION;</span>
<span class="fc bfc" id="L446" title="All 4 branches covered.">    if (specloc != null &amp;&amp; fromNotAtDict.contains(specloc.get(0).word())) {</span>
<span class="fc" id="L447">      wordAt = WORD_FROM;</span>
<span class="fc" id="L448">      missing = WORD_MISSING;</span>
    }

    // Grab the prefix of the sentence
<span class="fc" id="L452">    List&lt;CoreLabel&gt; sentence = (List&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$statement_body&quot;);</span>
    // (check if we should be looking for a location)
<span class="fc bfc" id="L454" title="All 2 branches covered.">    for (CoreLabel lbl : sentence) {</span>
<span class="fc bfc" id="L455" title="All 2 branches covered.">      if (&quot;name&quot;.equals(lbl.word())) {</span>
<span class="fc" id="L456">        missing = WORD_MISSING;</span>
      }
<span class="fc" id="L458">    }</span>

    // Add the &quot;at&quot; part
<span class="fc" id="L461">    List&lt;CoreLabel&gt; at = (List&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$at&quot;);</span>
<span class="pc bpc" id="L462" title="1 of 4 branches missed.">    if (at != null &amp;&amp; at.size() &gt; 0) {</span>
<span class="fc" id="L463">      sentence.addAll(at);</span>
    } else {
<span class="fc bfc" id="L465" title="All 2 branches covered.">      if (specloc != null) {</span>
<span class="fc" id="L466">        sentence.addAll(specloc);</span>
      }
<span class="fc" id="L468">      sentence.add(wordAt);</span>
    }

    // Add the location
<span class="fc" id="L472">    sentence.add(missing);</span>

    // Add an optional specifier location
<span class="fc bfc" id="L475" title="All 4 branches covered.">    if (specloc != null &amp;&amp; at != null) {</span>
<span class="fc" id="L476">      sentence.add(WORD_COMMA);</span>
<span class="fc" id="L477">      sentence.addAll(specloc);</span>
    }

    // Return
<span class="fc" id="L481">    return sentence;</span>
  }

  /**
   * The pattern for &quot;where is...&quot;  sentences.
   * @see edu.stanford.nlp.naturalli.QuestionToStatementTranslator#processWhereIs(edu.stanford.nlp.ling.tokensregex.TokenSequenceMatcher)
   */
<span class="fc" id="L488">  private final TokenSequencePattern triggerWhereIs = TokenSequencePattern.compile(</span>
      &quot;[{lemma:where; tag:/W.*/}] &quot; +
          &quot;(?$be [ {lemma:/be/} ]) &quot; +
          &quot;(?$initial_verb [tag:/[VJ].*/] )? &quot; +
          &quot;(?$statement_body []+?) &quot; +
          &quot;(?$ignored [lemma:locate] [tag:IN] [word:a]? [word:map]? )? &quot; +
          &quot;(?$final_verb [tag:/[VJ].*/] )? &quot; +
          &quot;(?$at [tag:IN] )? &quot; +
          &quot;(?$punct [word:/[?\\.!]/])&quot; );

  /**
   *
   * Process sentences matching the &quot;where is ...&quot; pattern.
   *
   * @param matcher The matcher that matched the pattern.
   *
   * @return The converted statement.
   *
   * @see edu.stanford.nlp.naturalli.QuestionToStatementTranslator#triggerWhereIs
   */
  private List&lt;CoreLabel&gt; processWhereIs(TokenSequenceMatcher matcher) {
    // Grab the prefix of the sentence
<span class="fc" id="L510">    List&lt;CoreLabel&gt; sentence = (List&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$statement_body&quot;);</span>

    // Add the &quot;is&quot; part
<span class="fc" id="L513">    List&lt;CoreLabel&gt; be = (List&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$be&quot;);</span>
<span class="fc" id="L514">    sentence.addAll(be);</span>

    // Add the optional final verb
<span class="fc" id="L517">    List&lt;CoreLabel&gt; verb = (List&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$final_verb&quot;);</span>
<span class="fc bfc" id="L518" title="All 2 branches covered.">    if (verb != null) {</span>
<span class="fc" id="L519">      sentence.addAll(verb);</span>
    }
    // Add the optional initial verb (from disfluent questions!)
<span class="fc" id="L522">    verb = (List&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$initial_verb&quot;);</span>
<span class="fc bfc" id="L523" title="All 2 branches covered.">    if (verb != null) {</span>
<span class="fc" id="L524">      sentence.addAll(verb);</span>
    }

    // Add the &quot;at&quot; part
<span class="fc" id="L528">    List&lt;CoreLabel&gt; at = (List&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$at&quot;);</span>
<span class="pc bpc" id="L529" title="1 of 4 branches missed.">    if (at != null &amp;&amp; at.size() &gt; 0) {</span>
<span class="fc" id="L530">      sentence.addAll(at);</span>
    } else {
<span class="fc" id="L532">      sentence.add(WORD_AT);</span>
    }

    // Add the location
<span class="fc" id="L536">    sentence.add(WORD_MISSING_LOCATION);</span>

    // Return
<span class="fc" id="L539">    return sentence;</span>
  }

  /**
   * The pattern for &quot;who is...&quot;  sentences.
   * @see edu.stanford.nlp.naturalli.QuestionToStatementTranslator#processWhoIs(edu.stanford.nlp.ling.tokensregex.TokenSequenceMatcher)
   */
<span class="fc" id="L546">  private final TokenSequencePattern triggerWhoIs = TokenSequencePattern.compile(</span>
      &quot;[{lemma:who; tag:/W.*/}] &quot; +
          &quot;(?$be [ {lemma:/be/} ] ) &quot; +
          &quot;(?$prep [ {tag:/IN|V.*/} ] )? &quot; +
          &quot;(?$statement_body []+?) &quot; +
          &quot;(?$final_verb [tag:/V.*/] [tag:/[IRT].*/] )? &quot; +
          &quot;(?$final_verb [tag:VBG] )? &quot; +
          &quot;(?$now [tag:RB] )? &quot; +
          &quot;(?$prep_num [!{tag:IN}] [tag:CD] )? &quot; +
          &quot;(?$punct [word:/[?\\.!]/])&quot; );

  /**
   *
   * Process sentences matching the &quot;who is ...&quot; pattern.
   *
   * @param matcher The matcher that matched the pattern.
   *
   * @return The converted statement.
   *
   * @see edu.stanford.nlp.naturalli.QuestionToStatementTranslator#triggerWhoIs
   */
  private List&lt;CoreLabel&gt; processWhoIs(TokenSequenceMatcher matcher) {
<span class="fc" id="L568">    List&lt;CoreLabel&gt; sentence = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L569">    List&lt;CoreLabel&gt; prep = (List&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$prep&quot;);</span>
<span class="fc" id="L570">    boolean addedBe = false;</span>

<span class="pc bpc" id="L572" title="1 of 4 branches missed.">    if (prep != null &amp;&amp; !prep.isEmpty()) {</span>
      // Add the person
<span class="fc" id="L574">      sentence.add(WORD_MISSING_PERSON);</span>

      // Add the &quot;is&quot; part
<span class="fc" id="L577">      List&lt;CoreLabel&gt; be = (List&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$be&quot;);</span>
<span class="fc" id="L578">      sentence.addAll(be);</span>
<span class="fc" id="L579">      addedBe = true;</span>

      // Add the preposition
<span class="fc" id="L582">      sentence.addAll(prep);</span>

      // Grab the prefix of the sentence
<span class="fc" id="L585">      sentence.addAll((List&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$statement_body&quot;));</span>

<span class="fc" id="L587">    } else {</span>

      // Grab the prefix of the sentence
<span class="fc" id="L590">      sentence.addAll((List&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$statement_body&quot;));</span>

      // Tweak to handle dropped prepositions
<span class="fc" id="L593">      List&lt;CoreLabel&gt; prepNum = (List&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$prep_num&quot;);</span>
<span class="fc bfc" id="L594" title="All 2 branches covered.">      if (prepNum != null) {</span>
<span class="fc" id="L595">        sentence.add(prepNum.get(0));</span>
<span class="fc" id="L596">        sentence.add(WORD_IN);</span>
<span class="fc" id="L597">        sentence.add(prepNum.get(1));</span>
      }

      // Add the &quot;is&quot; part
<span class="fc" id="L601">      List&lt;CoreLabel&gt; be = (List&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$be&quot;);</span>
<span class="fc bfc" id="L602" title="All 2 branches covered.">      if (sentence.size() &gt; 1 &amp;&amp;</span>
<span class="fc bfc" id="L603" title="All 2 branches covered.">          !sentence.get(sentence.size() - 1).word().equals(&quot;be&quot;)) {</span>
<span class="fc" id="L604">        sentence.addAll(be);</span>
<span class="fc" id="L605">        addedBe = true;</span>
      }

      // Add the final verb part
<span class="fc" id="L609">      List&lt;CoreLabel&gt; verb = (List&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$final_verb&quot;);</span>
<span class="fc bfc" id="L610" title="All 2 branches covered.">      if (verb != null) {</span>
<span class="fc bfc" id="L611" title="All 4 branches covered.">        if (verb.size() &gt; 1 &amp;&amp; verb.get(verb.size() - 1).word().equals(&quot;too&quot;)) {  // Fix common typo</span>
<span class="fc" id="L612">          verb.get(verb.size() - 1).setWord(&quot;to&quot;);</span>
<span class="fc" id="L613">          verb.get(verb.size() - 1).setValue(&quot;to&quot;);</span>
<span class="fc" id="L614">          verb.get(verb.size() - 1).setLemma(&quot;to&quot;);</span>
<span class="fc" id="L615">          verb.get(verb.size() - 1).setTag(&quot;IN&quot;);</span>
        }
<span class="fc" id="L617">        sentence.addAll(verb);</span>
      }

      // Add the person
<span class="fc" id="L621">      sentence.add(WORD_MISSING_PERSON);</span>
    }

    // Add a final modifier (e.g., &quot;now&quot;)
<span class="fc" id="L625">    List&lt;CoreLabel&gt; now = (List&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$now&quot;);</span>
<span class="fc bfc" id="L626" title="All 2 branches covered.">    if (now != null) {</span>
<span class="fc" id="L627">      sentence.addAll(now);</span>
    }

    // Insert &quot;was&quot; before first verb, if applicable
<span class="fc bfc" id="L631" title="All 2 branches covered.">    if (!addedBe) {</span>
<span class="pc bpc" id="L632" title="1 of 2 branches missed.">      for (int i = 0; i &lt; sentence.size(); ++i) {</span>
<span class="pc bpc" id="L633" title="1 of 4 branches missed.">        if (sentence.get(i).tag() != null &amp;&amp; sentence.get(i).tag().startsWith(&quot;V&quot;)) {</span>
<span class="fc" id="L634">          sentence.add(i, (CoreLabel) matcher.groupNodes(&quot;$be&quot;).get(0));</span>
<span class="fc" id="L635">          break;</span>
        }
      }
    }

    // Return
<span class="fc" id="L641">    return sentence;</span>
  }

  /**
   * The pattern for &quot;who did...&quot;  sentences.
   * @see edu.stanford.nlp.naturalli.QuestionToStatementTranslator#processWhoDid(edu.stanford.nlp.ling.tokensregex.TokenSequenceMatcher)
   */
<span class="fc" id="L648">  private final TokenSequencePattern triggerWhoDid = TokenSequencePattern.compile(</span>
      &quot;[{lemma:who; tag:/W.*/}] &quot; +
          &quot;(?$do [ {lemma:/do/} ] ) &quot; +
          &quot;(?$statement_body []+?) &quot; +
          &quot;(?$now [tag:RB] )? &quot; +
          &quot;(?$punct [word:/[?\\.!]/])&quot; );

  /**
   *
   * Process sentences matching the &quot;who did ...&quot; pattern.
   *
   * @param matcher The matcher that matched the pattern.
   *
   * @return The converted statement.
   *
   * @see edu.stanford.nlp.naturalli.QuestionToStatementTranslator#triggerWhoDid
   */
  private List&lt;CoreLabel&gt; processWhoDid(TokenSequenceMatcher matcher) {
    // Get the body
<span class="fc" id="L667">    List&lt;CoreLabel&gt; sentence = (List&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$statement_body&quot;);</span>

    // Check if there is no main verb other than &quot;do&quot;
    // If it doesn't, then the sentence should be &quot;person do ....&quot;
<span class="fc" id="L671">    boolean hasVerb = false;</span>
<span class="fc bfc" id="L672" title="All 2 branches covered.">    for (CoreLabel w : sentence) {</span>
<span class="pc bpc" id="L673" title="1 of 4 branches missed.">      if (w.tag() != null &amp;&amp; w.tag().startsWith(&quot;V&quot;)) {</span>
<span class="fc" id="L674">        hasVerb = true;</span>
      }
<span class="fc" id="L676">    }</span>
<span class="fc bfc" id="L677" title="All 2 branches covered.">    if (!hasVerb) {</span>
<span class="fc" id="L678">      sentence.add(0, WORD_MISSING_PERSON);</span>
<span class="fc" id="L679">      sentence.add(1, (CoreLabel) matcher.groupNodes(&quot;$do&quot;).get(0));</span>
<span class="fc" id="L680">      return sentence;</span>
    }

    // Add the missing word
    // (in front of the PPs)
<span class="fc" id="L685">    boolean addedPerson = false;</span>
<span class="pc bpc" id="L686" title="2 of 6 branches missed.">    if (sentence.size() &gt; 0 &amp;&amp; sentence.get(sentence.size() - 1).tag() != null &amp;&amp; !sentence.get(sentence.size() - 1).tag().startsWith(&quot;I&quot;)) {</span>
<span class="fc bfc" id="L687" title="All 2 branches covered.">      for (int i = 0; i &lt; sentence.size() - 1; ++i) {</span>
<span class="pc bpc" id="L688" title="1 of 2 branches missed.">        if (sentence.get(i).tag() != null &amp;&amp;</span>
<span class="pc bpc" id="L689" title="2 of 8 branches missed.">            (sentence.get(i).tag().equals(&quot;IN&quot;) || sentence.get(i).word().equals(&quot;last&quot;) || sentence.get(i).word().equals(&quot;next&quot;) || sentence.get(i).word().equals(&quot;this&quot;))) {</span>
<span class="fc" id="L690">          sentence.add(i, WORD_MISSING_PERSON);</span>
<span class="fc" id="L691">          addedPerson = true;</span>
<span class="fc" id="L692">          break;</span>
        }
      }
    }
    // (at the end of the sentence)
<span class="fc bfc" id="L697" title="All 2 branches covered.">    if (!addedPerson) {</span>
<span class="fc" id="L698">      sentence.add(WORD_MISSING_PERSON);</span>
    }

    // Add &quot;now&quot; / &quot;first&quot; / etc.
<span class="fc" id="L702">    List&lt;CoreLabel&gt; now = (List&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$now&quot;);</span>
<span class="fc bfc" id="L703" title="All 2 branches covered.">    if (now != null) {</span>
<span class="fc" id="L704">      sentence.addAll(now);</span>
    }

    // Return
<span class="fc" id="L708">    return sentence;</span>
  }

  /**
   * The pattern for &quot;where is...&quot;  sentences.
   * @see edu.stanford.nlp.naturalli.QuestionToStatementTranslator#processWhatDo(edu.stanford.nlp.ling.tokensregex.TokenSequenceMatcher)
   */
<span class="fc" id="L715">  private final TokenSequencePattern triggerWhatDo = TokenSequencePattern.compile(</span>
      &quot;[{lemma:/what|which/; tag:/W.*/}] &quot; +
          &quot;(?$do [ {lemma:/do/} ]) &quot; +
          &quot;(?$pre_do [ !{lemma:do} &amp; !{tag:IN} ]+) &quot; +
          &quot;(?$mid_do [ {lemma:do} ] )? &quot; +
          &quot;(?$in [ {tag:IN} ] )? &quot; +
          &quot;(?$post_do []+ )? &quot; +
          &quot;(?$punct [word:/[?\\.!]/])&quot; );

  /**
   *
   * Process sentences matching the &quot;what do ...&quot; pattern.
   *
   * @param matcher The matcher that matched the pattern.
   *
   * @return The converted statement.
   *
   * @see edu.stanford.nlp.naturalli.QuestionToStatementTranslator#triggerWhatDo
   */
  private List&lt;CoreLabel&gt; processWhatDo(TokenSequenceMatcher matcher) {
    // Grab the prefix of the sentence
<span class="fc" id="L736">    List&lt;CoreLabel&gt; sentence = (List&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$pre_do&quot;);</span>

    // Add the optional middle do
<span class="fc" id="L739">    List&lt;CoreLabel&gt; midDo = (List&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$mid_do&quot;);</span>
<span class="fc bfc" id="L740" title="All 2 branches covered.">    if (midDo != null) {</span>
<span class="fc" id="L741">      sentence.addAll((List&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$do&quot;));</span>
    }

    // Add the thing (not end of sentence)
<span class="fc bfc" id="L745" title="All 2 branches covered.">    if (matcher.groupNodes(&quot;$post_do&quot;) != null) {</span>
<span class="fc" id="L746">      sentence.add(WORD_MISSING);</span>
    }

    // Add IN token
<span class="fc" id="L750">    List&lt;CoreLabel&gt; midIN = (List&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$in&quot;);</span>
<span class="fc bfc" id="L751" title="All 2 branches covered.">    if (midIN != null) {</span>
<span class="fc" id="L752">      sentence.addAll(midIN);</span>
    }

    // Add the thing (end of sentence)
<span class="fc bfc" id="L756" title="All 2 branches covered.">    if (matcher.groupNodes(&quot;$post_do&quot;) == null) {</span>
<span class="pc bpc" id="L757" title="1 of 4 branches missed.">      if (sentence.size() &gt; 1 &amp;&amp; &quot;off&quot;.equals(sentence.get(sentence.size() - 1).word())) { // Fix common typo</span>
<span class="fc" id="L758">        sentence.get(sentence.size() - 1).setWord(&quot;of&quot;);</span>
<span class="fc" id="L759">        sentence.get(sentence.size() - 1).setValue(&quot;of&quot;);</span>
<span class="fc" id="L760">        sentence.get(sentence.size() - 1).setLemma(&quot;of&quot;);</span>
<span class="fc" id="L761">        sentence.get(sentence.size() - 1).setTag(&quot;IN&quot;);</span>
      }
<span class="fc" id="L763">      sentence.add(WORD_MISSING);</span>
    }

    // Add post do
<span class="fc" id="L767">    List&lt;CoreLabel&gt; postDo = (List&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$post_do&quot;);</span>
<span class="fc bfc" id="L768" title="All 2 branches covered.">    if (postDo != null) {</span>
<span class="fc" id="L769">      sentence.addAll(postDo);</span>
    }

    // Tweak to handle dropped prepositions
<span class="pc bpc" id="L773" title="1 of 2 branches missed.">    if (sentence.size() &gt; 2 &amp;&amp;</span>
<span class="fc bfc" id="L774" title="All 2 branches covered.">        !&quot;IN&quot;.equals(sentence.get(sentence.size() - 2).tag()) &amp;&amp;</span>
<span class="fc bfc" id="L775" title="All 2 branches covered.">        &quot;CD&quot;.equals(sentence.get(sentence.size() - 1).tag())) {</span>
<span class="fc" id="L776">      sentence.add(sentence.size() - 1, WORD_IN);</span>
    }

    // Return
<span class="fc" id="L780">    return sentence;</span>
  }

  /**
   * The pattern for &quot;when do...&quot;  sentences.
   * @see edu.stanford.nlp.naturalli.QuestionToStatementTranslator#processWhenDo(edu.stanford.nlp.ling.tokensregex.TokenSequenceMatcher)
   */
<span class="fc" id="L787">  private final TokenSequencePattern triggerWhenDo = TokenSequencePattern.compile(</span>
      &quot;[{lemma:when; tag:/W.*/}] &quot; +
          &quot;(?$do [ {lemma:/do/} ]) &quot; +
          &quot;(?$statement_body []+?) &quot; +
          &quot;(?$in [tag:/[IT].*/] )? &quot; +
          &quot;(?$punct [word:/[?\\.!]/])&quot; );

  /**
   *
   * Process sentences matching the &quot;when do ...&quot; pattern.
   *
   * @param matcher The matcher that matched the pattern.
   *
   * @return The converted statement.
   *
   * @see edu.stanford.nlp.naturalli.QuestionToStatementTranslator#triggerWhenDo
   */
  private List&lt;CoreLabel&gt; processWhenDo(TokenSequenceMatcher matcher) {
    // Grab the prefix of the sentence
<span class="fc" id="L806">    List&lt;CoreLabel&gt; sentence = (List&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$statement_body&quot;);</span>

    // Add the &quot;at&quot; part
<span class="fc" id="L809">    List&lt;CoreLabel&gt; in = (List&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$in&quot;);</span>
<span class="pc bpc" id="L810" title="1 of 4 branches missed.">    if (in != null &amp;&amp; in.size() &gt; 0) {</span>
<span class="fc" id="L811">      sentence.addAll(in);</span>
    } else {
<span class="fc" id="L813">      sentence.add(WORD_IN);</span>
    }

    // Add the location
<span class="fc" id="L817">    sentence.add(WORD_MISSING_TIME);</span>

    // Return
<span class="fc" id="L820">    return sentence;</span>
  }

  /**
   * The pattern for &quot;what have...&quot;  sentences.
   * @see edu.stanford.nlp.naturalli.QuestionToStatementTranslator#processWhereIs(edu.stanford.nlp.ling.tokensregex.TokenSequenceMatcher)
   */
<span class="fc" id="L827">  private final TokenSequencePattern triggerWhatHave = TokenSequencePattern.compile(</span>
      &quot;[{lemma:what; tag:/W.*/}] &quot; +
          &quot;(?$have [ {lemma:/have/} ]) &quot; +
          &quot;(?$pre_verb [!{tag:/V.*/}]+ )? &quot; +
          &quot;(?$verb [tag:/V.*/] [tag:IN]? ) &quot; +
          &quot;(?$post_verb []+ )? &quot; +
          &quot;(?$punct [word:/[?\\.!]/])&quot; );

  /**
   *
   * Process sentences matching the &quot;when do ...&quot; pattern.
   *
   * @param matcher The matcher that matched the pattern.
   *
   * @return The converted statement.
   *
   * @see edu.stanford.nlp.naturalli.QuestionToStatementTranslator#triggerWhenDo
   */
  private List&lt;CoreLabel&gt; processWhatHave(TokenSequenceMatcher matcher) {
<span class="fc" id="L846">    List&lt;CoreLabel&gt; sentence = new ArrayList&lt;&gt;();</span>

    // Grab the prefix of the sentence
<span class="fc" id="L849">    List&lt;CoreLabel&gt; preVerb = (List&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$pre_verb&quot;);</span>
<span class="fc bfc" id="L850" title="All 2 branches covered.">    if (preVerb != null) {</span>
<span class="fc" id="L851">      sentence.addAll(preVerb);</span>
    }

    // Add &quot;thing have verb&quot; or &quot;have verb thing&quot;
<span class="fc bfc" id="L855" title="All 2 branches covered.">    if (sentence.size() == 0) {</span>
<span class="fc" id="L856">      sentence.add(WORD_MISSING);</span>
<span class="fc" id="L857">      sentence.addAll( (List&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$have&quot;) );</span>
<span class="fc" id="L858">      sentence.addAll( (List&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$verb&quot;) );</span>
    } else {
<span class="fc" id="L860">      sentence.addAll( (List&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$have&quot;) );</span>
<span class="fc" id="L861">      sentence.addAll( (List&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$verb&quot;) );</span>
<span class="fc" id="L862">      sentence.add(WORD_MISSING);</span>
    }

<span class="fc" id="L865">    List&lt;CoreLabel&gt; postVerb = (List&lt;CoreLabel&gt;) matcher.groupNodes(&quot;$post_verb&quot;);</span>
<span class="fc bfc" id="L866" title="All 2 branches covered.">    if (postVerb != null) {</span>
<span class="fc" id="L867">      sentence.addAll(postVerb);</span>
    }

<span class="fc" id="L870">    return sentence;</span>
  }

  /**
   * Convert a question to a statement, if possible.
   * &lt;ul&gt;
   *   &lt;li&gt;The question must have words, lemmas, and part of speech tags.&lt;/li&gt;
   *   &lt;li&gt;The question must have valid punctuation.&lt;/li&gt;
   * &lt;/ul&gt;
   *
   * @param question The question to convert to a statement.
   * @return A list of statement translations of the question. This is usually a singleton list.
   */
  public List&lt;List&lt;CoreLabel&gt;&gt; toStatement(List&lt;CoreLabel&gt; question) {
    TokenSequenceMatcher matcher;
<span class="fc bfc" id="L885" title="All 2 branches covered.">    if ((matcher = triggerWhatIsThere.matcher(question)).matches()) {  // must come before triggerWhatIs</span>
<span class="fc" id="L886">      return Collections.singletonList(processWhatIsThere(matcher));</span>
<span class="fc bfc" id="L887" title="All 2 branches covered.">    } else if ((matcher = triggerWhNNIs.matcher(question)).matches()) {  // must come before triggerWhatIs</span>
<span class="fc" id="L888">      return Collections.singletonList(processWhNNIs(matcher));</span>
<span class="fc bfc" id="L889" title="All 2 branches covered.">    } else if ((matcher = triggerWhNNHave.matcher(question)).matches()) {  // must come before triggerWhatHave</span>
<span class="fc" id="L890">      return Collections.singletonList(processWhNNHave(matcher));</span>
<span class="fc bfc" id="L891" title="All 2 branches covered.">    } else if ((matcher = triggerWhNNHaveNN.matcher(question)).matches()) {  // must come before triggerWhatHave</span>
<span class="fc" id="L892">      return Collections.singletonList(processWhNNHaveNN(matcher));</span>
<span class="fc bfc" id="L893" title="All 2 branches covered.">    } else if ((matcher = triggerWhatIs.matcher(question)).matches()) {</span>
<span class="fc" id="L894">      return Collections.singletonList(processWhatIs(matcher));</span>
<span class="fc bfc" id="L895" title="All 2 branches covered.">    } else if ((matcher = triggerWhatHave.matcher(question)).matches()) {</span>
<span class="fc" id="L896">      return Collections.singletonList(processWhatHave(matcher));</span>
<span class="fc bfc" id="L897" title="All 2 branches covered.">    } else if ((matcher = triggerWhereDo.matcher(question)).matches()) {</span>
<span class="fc" id="L898">      return Collections.singletonList(processWhereDo(matcher));</span>
<span class="fc bfc" id="L899" title="All 2 branches covered.">    } else if ((matcher = triggerWhereIs.matcher(question)).matches()) {</span>
<span class="fc" id="L900">      return Collections.singletonList(processWhereIs(matcher));</span>
<span class="fc bfc" id="L901" title="All 2 branches covered.">    } else if ((matcher = triggerWhoIs.matcher(question)).matches()) {</span>
<span class="fc" id="L902">      return Collections.singletonList(processWhoIs(matcher));</span>
<span class="fc bfc" id="L903" title="All 2 branches covered.">    } else if ((matcher = triggerWhoDid.matcher(question)).matches()) {</span>
<span class="fc" id="L904">      return Collections.singletonList(processWhoDid(matcher));</span>
<span class="fc bfc" id="L905" title="All 2 branches covered.">    } else if ((matcher = triggerWhatDo.matcher(question)).matches()) {</span>
<span class="fc" id="L906">      return Collections.singletonList(processWhatDo(matcher));</span>
<span class="pc bpc" id="L907" title="1 of 2 branches missed.">    } else if ((matcher = triggerWhenDo.matcher(question)).matches()) {</span>
<span class="fc" id="L908">      return Collections.singletonList(processWhenDo(matcher));</span>
    } else {
<span class="nc" id="L910">      return Collections.emptyList();</span>
    }
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>