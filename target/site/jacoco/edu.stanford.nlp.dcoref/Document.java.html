<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Document.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.dcoref</a> &gt; <span class="el_source">Document.java</span></div><h1>Document.java</h1><pre class="source lang-java linenums">//
// StanfordCoreNLP -- a suite of NLP tools
// Copyright (c) 2009-2010 The Board of Trustees of
// The Leland Stanford Junior University. All Rights Reserved.
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
//
// For more information, bug reports, fixes, contact:
//    Christopher Manning
//    Dept of Computer Science, Gates 1A
//    Stanford CA 94305-9010
//    USA
//

package edu.stanford.nlp.dcoref;

import java.io.Serializable;
import java.util.*;

import edu.stanford.nlp.dcoref.Dictionaries.Number;
import edu.stanford.nlp.dcoref.Dictionaries.Person;
import edu.stanford.nlp.ling.CoreAnnotations;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.ling.IndexedWord;
import edu.stanford.nlp.math.NumberMatchingRegex;
import edu.stanford.nlp.pipeline.Annotation;
import edu.stanford.nlp.trees.GrammaticalRelation;
import edu.stanford.nlp.semgraph.SemanticGraph;
import edu.stanford.nlp.semgraph.SemanticGraphCoreAnnotations;
import edu.stanford.nlp.util.CollectionValuedMap;
import edu.stanford.nlp.util.CoreMap;
import edu.stanford.nlp.util.Generics;
import edu.stanford.nlp.util.IntPair;
import edu.stanford.nlp.util.IntTuple;
import edu.stanford.nlp.util.Pair;
import edu.stanford.nlp.util.TwoDimensionalMap;
import edu.stanford.nlp.util.TwoDimensionalSet;

<span class="nc bnc" id="L51" title="All 2 branches missed.">public class Document implements Serializable {</span>

  private static final long serialVersionUID = -4139866807494603953L;

<span class="nc" id="L55">  public enum DocType { CONVERSATION, ARTICLE }</span>

  /** The type of document: conversational or article */
  public DocType docType;

  /** Document annotation */
  public Annotation annotation;

  /** for conll shared task 2011  */
  public CoNLL2011DocumentReader.Document conllDoc;

  /** The list of gold mentions */
  public List&lt;List&lt;Mention&gt;&gt; goldOrderedMentionsBySentence;
  /** The list of predicted mentions */
  public List&lt;List&lt;Mention&gt;&gt; predictedOrderedMentionsBySentence;

  /** return the list of predicted mentions */
  public List&lt;List&lt;Mention&gt;&gt; getOrderedMentions() {
<span class="nc" id="L73">    return predictedOrderedMentionsBySentence;</span>
  }

  /** Clusters for coreferent mentions */
  public Map&lt;Integer, CorefCluster&gt; corefClusters;

  /** Gold Clusters for coreferent mentions */
  public Map&lt;Integer, CorefCluster&gt; goldCorefClusters;

  /** For all mentions in a document, map mentionID to mention. */
  public Map&lt;Integer, Mention&gt; allPredictedMentions;
  public Map&lt;Integer, Mention&gt; allGoldMentions;

  /** Set of roles (in role apposition) in a document  */
  public Set&lt;Mention&gt; roleSet;

  /**
   * Position of each mention in the input matrix
   * Each mention occurrence with sentence # and position within sentence
   * (Nth mention, not Nth token)
   */
  public Map&lt;Mention, IntTuple&gt; positions;              // mentions may be removed from this due to post processing
  public Map&lt;Mention, IntTuple&gt; allPositions;           // all mentions (mentions will not be removed from this)

  public final Map&lt;IntTuple, Mention&gt; mentionheadPositions;

  /** List of gold links in a document by positions */
  private List&lt;Pair&lt;IntTuple,IntTuple&gt;&gt; goldLinks;

  /** Map UtteranceAnnotation to String (speaker): mention ID or speaker string  */
  public Map&lt;Integer, String&gt; speakers;

  /** Pair of mention id, and the mention's speaker id  */
  public Set&lt;Pair&lt;Integer, Integer&gt;&gt; speakerPairs;

  public int maxUtter;
  public int numParagraph;
  public int numSentences;

  /** Set of incompatible clusters pairs */
  private TwoDimensionalSet&lt;Integer, Integer&gt; incompatibles;
  private TwoDimensionalSet&lt;Integer, Integer&gt; incompatibleClusters;

  protected TwoDimensionalMap&lt;Integer, Integer, Boolean&gt; acronymCache;

  /** Map of speaker name/id to speaker info */
<span class="nc" id="L119">  transient private Map&lt;String, SpeakerInfo&gt; speakerInfoMap = Generics.newHashMap();</span>

<span class="nc" id="L121">  public Document() {</span>
<span class="nc" id="L122">    positions = Generics.newHashMap();</span>
<span class="nc" id="L123">    mentionheadPositions = Generics.newHashMap();</span>
<span class="nc" id="L124">    roleSet = Generics.newHashSet();</span>
<span class="nc" id="L125">    corefClusters = Generics.newHashMap();</span>
<span class="nc" id="L126">    goldCorefClusters = null;</span>
<span class="nc" id="L127">    allPredictedMentions = Generics.newHashMap();</span>
<span class="nc" id="L128">    allGoldMentions = Generics.newHashMap();</span>
<span class="nc" id="L129">    speakers = Generics.newHashMap();</span>
<span class="nc" id="L130">    speakerPairs = Generics.newHashSet();</span>
<span class="nc" id="L131">    incompatibles = TwoDimensionalSet.hashSet();</span>
<span class="nc" id="L132">    incompatibleClusters = TwoDimensionalSet.hashSet();</span>
<span class="nc" id="L133">    acronymCache = TwoDimensionalMap.hashMap();</span>
<span class="nc" id="L134">  }</span>

  public Document(Annotation anno, List&lt;List&lt;Mention&gt;&gt; predictedMentions,
      List&lt;List&lt;Mention&gt;&gt; goldMentions, Dictionaries dict) {
<span class="nc" id="L138">    this();</span>
<span class="nc" id="L139">    annotation = anno;</span>
<span class="nc" id="L140">    numSentences = anno.get(CoreAnnotations.SentencesAnnotation.class).size();</span>
<span class="nc" id="L141">    predictedOrderedMentionsBySentence = predictedMentions;</span>
<span class="nc" id="L142">    goldOrderedMentionsBySentence = goldMentions;</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">    if(goldMentions!=null) {</span>
<span class="nc" id="L144">      findTwinMentions(true);</span>
      // fill allGoldMentions
<span class="nc bnc" id="L146" title="All 2 branches missed.">      for(List&lt;Mention&gt; l : goldOrderedMentionsBySentence) {</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">        for(Mention g : l) {</span>
<span class="nc" id="L148">          allGoldMentions.put(g.mentionID, g);</span>
<span class="nc" id="L149">        }</span>
<span class="nc" id="L150">      }</span>
    }
    // set original ID, initial coref clusters, paragraph annotation, mention positions
<span class="nc" id="L153">    initialize();</span>
<span class="nc" id="L154">    processDiscourse(dict);</span>
<span class="nc" id="L155">    printMentionDetection();</span>
<span class="nc" id="L156">  }</span>

  /** Process discourse information */
  protected void processDiscourse(Dictionaries dict) {
<span class="nc" id="L160">    docType = findDocType(dict);</span>
<span class="nc" id="L161">    markQuotations(this.annotation.get(CoreAnnotations.SentencesAnnotation.class), false);</span>
<span class="nc" id="L162">    findSpeakers(dict);</span>

    // find 'speaker mention' for each mention
<span class="nc bnc" id="L165" title="All 2 branches missed.">    for(Mention m : allPredictedMentions.values()) {</span>
<span class="nc" id="L166">      int utter = m.headWord.get(CoreAnnotations.UtteranceAnnotation.class);</span>
<span class="nc" id="L167">      String speaker = m.headWord.get(CoreAnnotations.SpeakerAnnotation.class);</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">      if (speaker != null) {</span>
        // Populate speaker info
<span class="nc" id="L170">        SpeakerInfo speakerInfo = speakerInfoMap.get(speaker);</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">        if (speakerInfo == null) {</span>
<span class="nc" id="L172">          speakerInfoMap.put(speaker, speakerInfo = new SpeakerInfo(speaker));</span>
          // span indicates this is the speaker
<span class="nc bnc" id="L174" title="All 2 branches missed.">          if (Rules.mentionMatchesSpeaker(m, speakerInfo, true)) {</span>
<span class="nc" id="L175">            m.speakerInfo = speakerInfo;</span>
          }
        }

<span class="nc bnc" id="L179" title="All 2 branches missed.">        if (NumberMatchingRegex.isDecimalInteger(speaker)) {</span>
          try{
<span class="nc" id="L181">            int speakerMentionID = Integer.parseInt(speaker);</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">            if (utter != 0) {</span>
              // Add pairs of mention id and the mention id of the speaker
<span class="nc" id="L184">              speakerPairs.add(new Pair&lt;&gt;(m.mentionID, speakerMentionID));</span>
//              speakerPairs.add(new Pair&lt;Integer, Integer&gt;(speakerMentionID, m.mentionID));
            }
<span class="nc" id="L187">          } catch (Exception e){</span>
            // no mention found for the speaker
            // nothing to do
<span class="nc" id="L190">          }</span>
        }
      }
      // set generic 'you' : e.g., you know in conversation
<span class="nc bnc" id="L194" title="All 6 branches missed.">      if(docType!=DocType.ARTICLE &amp;&amp; m.person==Person.YOU &amp;&amp; m.endIndex &lt; m.sentenceWords.size()-1</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">          &amp;&amp; m.sentenceWords.get(m.endIndex).get(CoreAnnotations.TextAnnotation.class).equalsIgnoreCase(&quot;know&quot;)) {</span>
<span class="nc" id="L196">        m.generic = true;</span>
      }
<span class="nc" id="L198">    }</span>
    // now that we have identified the speakers, first pass to check if mentions should cluster with the speakers
<span class="nc bnc" id="L200" title="All 2 branches missed.">    for(Mention m : allPredictedMentions.values()) {</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">      if (m.speakerInfo == null) {</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">        for (SpeakerInfo speakerInfo: speakerInfoMap.values()) {</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">          if (speakerInfo.hasRealSpeakerName()) {</span>
            // do loose match - assumes that there isn't that many speakers....
<span class="nc bnc" id="L205" title="All 2 branches missed.">            if (Rules.mentionMatchesSpeaker(m, speakerInfo, false)) {</span>
<span class="nc" id="L206">              m.speakerInfo = speakerInfo;</span>
<span class="nc" id="L207">              break;</span>
            }
          }
<span class="nc" id="L210">        }</span>
      }
<span class="nc" id="L212">    }</span>

<span class="nc" id="L214">  }</span>

  /** Document initialize */
  protected void initialize() {
<span class="nc bnc" id="L218" title="All 2 branches missed.">    if(goldOrderedMentionsBySentence==null) assignOriginalID();</span>
<span class="nc" id="L219">    setParagraphAnnotation();</span>
<span class="nc" id="L220">    initializeCorefCluster();</span>
<span class="nc" id="L221">    this.allPositions = Generics.newHashMap(this.positions);</span>
<span class="nc" id="L222">  }</span>

  /** initialize positions and corefClusters (put each mention in each CorefCluster) */
  private void initializeCorefCluster() {
<span class="nc bnc" id="L226" title="All 2 branches missed.">    for(int i = 0; i &lt; predictedOrderedMentionsBySentence.size(); i ++){</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">      for(int j = 0; j &lt; predictedOrderedMentionsBySentence.get(i).size(); j ++){</span>
<span class="nc" id="L228">        Mention m = predictedOrderedMentionsBySentence.get(i).get(j);</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">        if (allPredictedMentions.containsKey(m.mentionID)) {</span>
<span class="nc" id="L230">          SieveCoreferenceSystem.logger.warning(&quot;WARNING: Already contain mention &quot; + m.mentionID);</span>
<span class="nc" id="L231">          Mention m1 = allPredictedMentions.get(m.mentionID);</span>
<span class="nc" id="L232">          SieveCoreferenceSystem.logger.warning(&quot;OLD mention: &quot; + m1.spanToString() + &quot;[&quot; + m1.startIndex + &quot;,&quot; + m1.endIndex + &quot;]&quot;);</span>
<span class="nc" id="L233">          SieveCoreferenceSystem.logger.warning(&quot;NEW mention: &quot; + m.spanToString() + &quot;[&quot; + m.startIndex + &quot;,&quot; + m.endIndex + &quot;]&quot;);</span>
          //          SieveCoreferenceSystem.debugPrintMentions(System.err, &quot;PREDICTED ORDERED&quot;, predictedOrderedMentionsBySentence);
//          SieveCoreferenceSystem.debugPrintMentions(System.err, &quot;GOLD ORDERED&quot;, goldOrderedMentionsBySentence);
        }
<span class="nc bnc" id="L237" title="All 4 branches missed.">        assert(!allPredictedMentions.containsKey(m.mentionID));</span>
<span class="nc" id="L238">        allPredictedMentions.put(m.mentionID, m);</span>

<span class="nc" id="L240">        IntTuple pos = new IntTuple(2);</span>
<span class="nc" id="L241">        pos.set(0, i);</span>
<span class="nc" id="L242">        pos.set(1, j);</span>
<span class="nc" id="L243">        positions.put(m, pos);</span>
<span class="nc" id="L244">        m.sentNum = i;</span>

<span class="nc bnc" id="L246" title="All 4 branches missed.">        assert(!corefClusters.containsKey(m.mentionID));</span>
<span class="nc" id="L247">        corefClusters.put(m.mentionID, new CorefCluster(m.mentionID, Generics.newHashSet(Collections.singletonList(m))));</span>
<span class="nc" id="L248">        m.corefClusterID = m.mentionID;</span>

<span class="nc" id="L250">        IntTuple headPosition = new IntTuple(2);</span>
<span class="nc" id="L251">        headPosition.set(0, i);</span>
<span class="nc" id="L252">        headPosition.set(1, m.headIndex);</span>
<span class="nc" id="L253">        mentionheadPositions.put(headPosition, m);</span>
      }
    }
<span class="nc" id="L256">  }</span>

  public boolean isIncompatible(CorefCluster c1, CorefCluster c2) {
    // Was any of the pairs of mentions marked as incompatible
<span class="nc" id="L260">    int cid1 = Math.min(c1.clusterID, c2.clusterID);</span>
<span class="nc" id="L261">    int cid2 = Math.max(c1.clusterID, c2.clusterID);</span>
<span class="nc" id="L262">    return incompatibleClusters.contains(cid1,cid2);</span>
  }

  // Update incompatibles for two clusters that are about to be merged
  public void mergeIncompatibles(CorefCluster to, CorefCluster from) {
<span class="nc" id="L267">    List&lt;Pair&lt;Pair&lt;Integer,Integer&gt;, Pair&lt;Integer,Integer&gt;&gt;&gt; replacements =</span>
            new ArrayList&lt;&gt;();
<span class="nc bnc" id="L269" title="All 2 branches missed.">    for (Pair&lt;Integer, Integer&gt; p : incompatibleClusters) {</span>
<span class="nc" id="L270">      Integer other = null;</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">      if (p.first == from.clusterID) {</span>
<span class="nc" id="L272">        other = p.second;</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">      } else if (p.second == from.clusterID) {</span>
<span class="nc" id="L274">        other = p.first;</span>
      }
<span class="nc bnc" id="L276" title="All 4 branches missed.">      if (other != null &amp;&amp; other != to.clusterID) {</span>
<span class="nc" id="L277">        int cid1 = Math.min(other, to.clusterID);</span>
<span class="nc" id="L278">        int cid2 = Math.max(other, to.clusterID);</span>
<span class="nc" id="L279">        replacements.add(Pair.makePair(p, Pair.makePair(cid1, cid2)));</span>
      }
<span class="nc" id="L281">    }</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">    for (Pair&lt;Pair&lt;Integer,Integer&gt;, Pair&lt;Integer,Integer&gt;&gt; r:replacements)  {</span>
<span class="nc" id="L283">      incompatibleClusters.remove(r.first.first(), r.first.second());</span>
<span class="nc" id="L284">      incompatibleClusters.add(r.second.first(), r.second.second());</span>
<span class="nc" id="L285">    }</span>
<span class="nc" id="L286">  }</span>

  public void mergeAcronymCache(CorefCluster to, CorefCluster from) {
<span class="nc" id="L289">    TwoDimensionalSet&lt;Integer, Integer&gt; replacements = TwoDimensionalSet.hashSet();</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">    for (Integer first : acronymCache.firstKeySet()) {</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">      for (Integer second : acronymCache.get(first).keySet()) {</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">        if (acronymCache.get(first, second)) {</span>
<span class="nc" id="L293">          Integer other = null;</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">          if (first == from.clusterID) {</span>
<span class="nc" id="L295">            other = second;</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">          } else if (second == from.clusterID) {</span>
<span class="nc" id="L297">            other = first;</span>
          }
<span class="nc bnc" id="L299" title="All 4 branches missed.">          if (other != null &amp;&amp; other != to.clusterID) {</span>
<span class="nc" id="L300">            int cid1 = Math.min(other, to.clusterID);</span>
<span class="nc" id="L301">            int cid2 = Math.max(other, to.clusterID);</span>
<span class="nc" id="L302">            replacements.add(cid1, cid2);</span>
          }
        }
<span class="nc" id="L305">      }</span>
<span class="nc" id="L306">    }</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">    for (Integer first : replacements.firstKeySet()) {</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">      for (Integer second : replacements.secondKeySet(first)) {</span>
<span class="nc" id="L309">        acronymCache.put(first, second, true);</span>
<span class="nc" id="L310">      }</span>
<span class="nc" id="L311">    }</span>
<span class="nc" id="L312">  }</span>

  public boolean isIncompatible(Mention m1, Mention m2) {
<span class="nc" id="L315">    int mid1 = Math.min(m1.mentionID, m2.mentionID);</span>
<span class="nc" id="L316">    int mid2 = Math.max(m1.mentionID, m2.mentionID);</span>
<span class="nc" id="L317">    return incompatibles.contains(mid1,mid2);</span>
  }

  public void addIncompatible(Mention m1, Mention m2) {
<span class="nc" id="L321">    int mid1 = Math.min(m1.mentionID, m2.mentionID);</span>
<span class="nc" id="L322">    int mid2 = Math.max(m1.mentionID, m2.mentionID);</span>
<span class="nc" id="L323">    incompatibles.add(mid1,mid2);</span>
<span class="nc" id="L324">    int cid1 = Math.min(m1.corefClusterID, m2.corefClusterID);</span>
<span class="nc" id="L325">    int cid2 = Math.max(m1.corefClusterID, m2.corefClusterID);</span>
<span class="nc" id="L326">    incompatibleClusters.add(cid1,cid2);</span>
<span class="nc" id="L327">  }</span>

  /** Mark twin mentions in gold and predicted mentions */
  protected void findTwinMentions(boolean strict){
<span class="nc bnc" id="L331" title="All 2 branches missed.">    if(strict) findTwinMentionsStrict();</span>
<span class="nc" id="L332">    else findTwinMentionsRelaxed();</span>
<span class="nc" id="L333">  }</span>

  /** Mark twin mentions: All mention boundaries should be matched */
  private void findTwinMentionsStrict(){
<span class="nc bnc" id="L337" title="All 2 branches missed.">    for(int sentNum = 0; sentNum &lt; goldOrderedMentionsBySentence.size(); sentNum++) {</span>
<span class="nc" id="L338">      List&lt;Mention&gt; golds = goldOrderedMentionsBySentence.get(sentNum);</span>
<span class="nc" id="L339">      List&lt;Mention&gt; predicts = predictedOrderedMentionsBySentence.get(sentNum);</span>

      // For CoNLL training there are some documents with gold mentions with the same position offsets
      // See /scr/nlp/data/conll-2011/v2/data/train/data/english/annotations/nw/wsj/09/wsj_0990.v2_auto_conll
      //  (Packwood - Roth)
<span class="nc" id="L344">      CollectionValuedMap&lt;IntPair, Mention&gt; goldMentionPositions = new CollectionValuedMap&lt;&gt;();</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">      for(Mention g : golds) {</span>
<span class="nc" id="L346">        IntPair ip = new IntPair(g.startIndex, g.endIndex);</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">        if (goldMentionPositions.containsKey(ip)) {</span>
<span class="nc" id="L348">          StringBuilder existingMentions = new StringBuilder();</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">          for (Mention eg: goldMentionPositions.get(ip)) {</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">            if (existingMentions.length() &gt; 0) {</span>
<span class="nc" id="L351">              existingMentions.append(&quot;,&quot;);</span>
            }
<span class="nc" id="L353">            existingMentions.append(eg.mentionID);</span>
<span class="nc" id="L354">          }</span>
<span class="nc" id="L355">          SieveCoreferenceSystem.logger.warning(&quot;WARNING: gold mentions with the same offsets: &quot; + ip</span>
<span class="nc" id="L356">                  + &quot; mentions=&quot; + g.mentionID + &quot;,&quot; + existingMentions + &quot;, &quot; + g.spanToString());</span>
        }
        //assert(!goldMentionPositions.containsKey(ip));
<span class="nc" id="L359">        goldMentionPositions.add(new IntPair(g.startIndex, g.endIndex), g);</span>
<span class="nc" id="L360">      }</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">      for(Mention p : predicts) {</span>
<span class="nc" id="L362">        IntPair pos = new IntPair(p.startIndex, p.endIndex);</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">        if(goldMentionPositions.containsKey(pos)) {</span>
<span class="nc" id="L364">          Collection&lt;Mention&gt; cm = goldMentionPositions.get(pos);</span>
<span class="nc" id="L365">          Mention g = cm.iterator().next();</span>
<span class="nc" id="L366">          cm.remove(g);</span>
<span class="nc" id="L367">          p.mentionID = g.mentionID;</span>
<span class="nc" id="L368">          p.twinless = false;</span>
<span class="nc" id="L369">          g.twinless = false;</span>
        }
<span class="nc" id="L371">      }</span>
      // temp: for making easy to recognize twinless mention
<span class="nc bnc" id="L373" title="All 2 branches missed.">      for(Mention p : predicts){</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">        if(p.twinless) p.mentionID += 10000;</span>
<span class="nc" id="L375">      }</span>
    }
<span class="nc" id="L377">  }</span>

  /** Mark twin mentions: heads of the mentions are matched */
  private void findTwinMentionsRelaxed() {
<span class="nc bnc" id="L381" title="All 2 branches missed.">    for(int sentNum = 0; sentNum &lt; goldOrderedMentionsBySentence.size(); sentNum++) {</span>
<span class="nc" id="L382">      List&lt;Mention&gt; golds = goldOrderedMentionsBySentence.get(sentNum);</span>
<span class="nc" id="L383">      List&lt;Mention&gt; predicts = predictedOrderedMentionsBySentence.get(sentNum);</span>

<span class="nc" id="L385">      Map&lt;IntPair, Mention&gt; goldMentionPositions = Generics.newHashMap();</span>
<span class="nc" id="L386">      Map&lt;Integer, LinkedList&lt;Mention&gt;&gt; goldMentionHeadPositions = Generics.newHashMap();</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">      for(Mention g : golds) {</span>
<span class="nc" id="L388">        goldMentionPositions.put(new IntPair(g.startIndex, g.endIndex), g);</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">        if(!goldMentionHeadPositions.containsKey(g.headIndex)) {</span>
<span class="nc" id="L390">          goldMentionHeadPositions.put(g.headIndex, new LinkedList&lt;&gt;());</span>
        }
<span class="nc" id="L392">        goldMentionHeadPositions.get(g.headIndex).add(g);</span>
<span class="nc" id="L393">      }</span>

<span class="nc" id="L395">      List&lt;Mention&gt; remains = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">      for (Mention p : predicts) {</span>
<span class="nc" id="L397">        IntPair pos = new IntPair(p.startIndex, p.endIndex);</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">        if(goldMentionPositions.containsKey(pos)) {</span>
<span class="nc" id="L399">          Mention g = goldMentionPositions.get(pos);</span>
<span class="nc" id="L400">          p.mentionID = g.mentionID;</span>
<span class="nc" id="L401">          p.twinless = false;</span>
<span class="nc" id="L402">          g.twinless = false;</span>
<span class="nc" id="L403">          goldMentionHeadPositions.get(g.headIndex).remove(g);</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">          if(goldMentionHeadPositions.get(g.headIndex).isEmpty()) {</span>
<span class="nc" id="L405">            goldMentionHeadPositions.remove(g.headIndex);</span>
          }
<span class="nc" id="L407">        }</span>
<span class="nc" id="L408">        else remains.add(p);</span>
<span class="nc" id="L409">      }</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">      for (Mention r : remains){</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">        if(goldMentionHeadPositions.containsKey(r.headIndex)) {</span>
<span class="nc" id="L412">          Mention g = goldMentionHeadPositions.get(r.headIndex).poll();</span>
<span class="nc" id="L413">          r.mentionID = g.mentionID;</span>
<span class="nc" id="L414">          r.twinless = false;</span>
<span class="nc" id="L415">          g.twinless = false;</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">          if(goldMentionHeadPositions.get(g.headIndex).isEmpty()) {</span>
<span class="nc" id="L417">            goldMentionHeadPositions.remove(g.headIndex);</span>
          }
        }
<span class="nc" id="L420">      }</span>
    }
<span class="nc" id="L422">  }</span>

  /** Set paragraph index */
  private void setParagraphAnnotation() {
<span class="nc" id="L426">    int paragraphIndex = 0;</span>
<span class="nc" id="L427">    int previousOffset = -10;</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">    for(CoreMap sent : annotation.get(CoreAnnotations.SentencesAnnotation.class)) {</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">      for(CoreLabel w : sent.get(CoreAnnotations.TokensAnnotation.class)) {</span>
<span class="nc bnc" id="L430" title="All 2 branches missed.">        if(w.containsKey(CoreAnnotations.CharacterOffsetBeginAnnotation.class)) {</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">          if(w.get(CoreAnnotations.CharacterOffsetBeginAnnotation.class) &gt; previousOffset+2) paragraphIndex++;</span>
<span class="nc" id="L432">          w.set(CoreAnnotations.ParagraphAnnotation.class, paragraphIndex);</span>
<span class="nc" id="L433">          previousOffset = w.get(CoreAnnotations.CharacterOffsetEndAnnotation.class);</span>
        } else {
<span class="nc" id="L435">          w.set(CoreAnnotations.ParagraphAnnotation.class, -1);</span>
        }
<span class="nc" id="L437">      }</span>
<span class="nc" id="L438">    }</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">    for(List&lt;Mention&gt; l : predictedOrderedMentionsBySentence) {</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">      for(Mention m : l){</span>
<span class="nc" id="L441">        m.paragraph = m.headWord.get(CoreAnnotations.ParagraphAnnotation.class);</span>
<span class="nc" id="L442">      }</span>
<span class="nc" id="L443">    }</span>
<span class="nc" id="L444">    numParagraph = paragraphIndex;</span>
<span class="nc" id="L445">  }</span>

  /** Find document type: Conversation or article  */
  private DocType findDocType(Dictionaries dict) {
<span class="nc" id="L449">    boolean speakerChange = false;</span>
<span class="nc" id="L450">    Set&lt;Integer&gt; discourseWithIorYou = Generics.newHashSet();</span>

<span class="nc bnc" id="L452" title="All 2 branches missed.">    for(CoreMap sent : annotation.get(CoreAnnotations.SentencesAnnotation.class)) {</span>
<span class="nc bnc" id="L453" title="All 2 branches missed.">      for(CoreLabel w : sent.get(CoreAnnotations.TokensAnnotation.class)) {</span>
<span class="nc" id="L454">        int utterIndex = w.get(CoreAnnotations.UtteranceAnnotation.class);</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">        if(utterIndex!=0) speakerChange = true;</span>
<span class="nc bnc" id="L456" title="All 4 branches missed.">        if(speakerChange &amp;&amp; utterIndex==0) return DocType.ARTICLE;</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">        if(dict.firstPersonPronouns.contains(w.get(CoreAnnotations.TextAnnotation.class).toLowerCase())</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">            || dict.secondPersonPronouns.contains(w.get(CoreAnnotations.TextAnnotation.class).toLowerCase())) {</span>
<span class="nc" id="L459">          discourseWithIorYou.add(utterIndex);</span>
        }
<span class="nc bnc" id="L461" title="All 2 branches missed.">        if(maxUtter &lt; utterIndex) maxUtter = utterIndex;</span>
<span class="nc" id="L462">      }</span>
<span class="nc" id="L463">    }</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">    if(!speakerChange) return DocType.ARTICLE;</span>
<span class="nc" id="L465">    return DocType.CONVERSATION;  // in conversation, utter index keep increasing.</span>
  }

  /** When there is no mentionID information (without gold annotation), assign mention IDs */
  protected void assignOriginalID(){
<span class="nc" id="L470">    List&lt;List&lt;Mention&gt;&gt; orderedMentionsBySentence = this.getOrderedMentions();</span>
<span class="nc" id="L471">    boolean hasOriginalID = true;</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">    for(List&lt;Mention&gt; l : orderedMentionsBySentence){</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">      if (l.size()==0) continue;</span>
<span class="nc bnc" id="L474" title="All 2 branches missed.">      for(Mention m : l){</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">        if(m.mentionID == -1){</span>
<span class="nc" id="L476">          hasOriginalID = false;</span>
        }
<span class="nc" id="L478">      }</span>
<span class="nc" id="L479">    }</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">    if(!hasOriginalID){</span>
<span class="nc" id="L481">      int id = 0;</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">      for(List&lt;Mention&gt; l : orderedMentionsBySentence){</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">        for(Mention m : l){</span>
<span class="nc" id="L484">          m.mentionID = id++;</span>
<span class="nc" id="L485">        }</span>
<span class="nc" id="L486">      }</span>
    }
<span class="nc" id="L488">  }</span>

  /** Extract gold coref cluster information. */
  public void extractGoldCorefClusters(){
<span class="nc" id="L492">    goldCorefClusters = Generics.newHashMap();</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">    for (List&lt;Mention&gt; mentions : goldOrderedMentionsBySentence) {</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">      for (Mention m : mentions) {</span>
<span class="nc" id="L495">        int id = m.goldCorefClusterID;</span>
<span class="nc bnc" id="L496" title="All 2 branches missed.">        if (id == -1) {</span>
<span class="nc" id="L497">          throw new RuntimeException(&quot;No gold info&quot;);</span>
        }
<span class="nc" id="L499">        CorefCluster c = goldCorefClusters.get(id);</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L501">          c = new CorefCluster(id);</span>
<span class="nc" id="L502">          goldCorefClusters.put(id, c);</span>
        }
<span class="nc" id="L504">        c.corefMentions.add(m);</span>
<span class="nc" id="L505">      }</span>
<span class="nc" id="L506">    }</span>
<span class="nc" id="L507">  }</span>

  protected List&lt;Pair&lt;IntTuple, IntTuple&gt;&gt; getGoldLinks() {
<span class="nc bnc" id="L510" title="All 2 branches missed.">    if(goldLinks==null) this.extractGoldLinks();</span>
<span class="nc" id="L511">    return goldLinks;</span>
  }

  /** Extract gold coref link information */
  protected void extractGoldLinks() {
    //    List&lt;List&lt;Mention&gt;&gt; orderedMentionsBySentence = this.getOrderedMentions();
<span class="nc" id="L517">    List&lt;Pair&lt;IntTuple, IntTuple&gt;&gt; links = new ArrayList&lt;&gt;();</span>

    // position of each mention in the input matrix, by id
<span class="nc" id="L520">    Map&lt;Integer, IntTuple&gt; positions = Generics.newHashMap();</span>
    // positions of antecedents
<span class="nc" id="L522">    Map&lt;Integer, List&lt;IntTuple&gt;&gt; antecedents = Generics.newHashMap();</span>
<span class="nc bnc" id="L523" title="All 2 branches missed.">    for(int i = 0; i &lt; goldOrderedMentionsBySentence.size(); i ++){</span>
<span class="nc bnc" id="L524" title="All 2 branches missed.">      for(int j = 0; j &lt; goldOrderedMentionsBySentence.get(i).size(); j ++){</span>
<span class="nc" id="L525">        Mention m = goldOrderedMentionsBySentence.get(i).get(j);</span>
<span class="nc" id="L526">        int id = m.mentionID;</span>
<span class="nc" id="L527">        IntTuple pos = new IntTuple(2);</span>
<span class="nc" id="L528">        pos.set(0, i);</span>
<span class="nc" id="L529">        pos.set(1, j);</span>
<span class="nc" id="L530">        positions.put(id, pos);</span>
<span class="nc" id="L531">        antecedents.put(id, new ArrayList&lt;&gt;());</span>
      }
    }

//    SieveCoreferenceSystem.debugPrintMentions(System.err, &quot;&quot;, goldOrderedMentionsBySentence);
<span class="nc bnc" id="L536" title="All 2 branches missed.">    for (List&lt;Mention&gt; mentions : goldOrderedMentionsBySentence) {</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">      for (Mention m : mentions) {</span>
<span class="nc" id="L538">        int id = m.mentionID;</span>
<span class="nc" id="L539">        IntTuple src = positions.get(id);</span>

<span class="nc bnc" id="L541" title="All 4 branches missed.">        assert (src != null);</span>
<span class="nc bnc" id="L542" title="All 2 branches missed.">        if (m.originalRef &gt;= 0) {</span>
<span class="nc" id="L543">          IntTuple dst = positions.get(m.originalRef);</span>
<span class="nc bnc" id="L544" title="All 2 branches missed.">          if (dst == null) {</span>
<span class="nc" id="L545">            throw new RuntimeException(&quot;Cannot find gold mention with ID=&quot; + m.originalRef);</span>
          }

          // to deal with cataphoric annotation
<span class="nc bnc" id="L549" title="All 6 branches missed.">          while (dst.get(0) &gt; src.get(0) || (dst.get(0) == src.get(0) &amp;&amp; dst.get(1) &gt; src.get(1))) {</span>
<span class="nc" id="L550">            Mention dstMention = goldOrderedMentionsBySentence.get(dst.get(0)).get(dst.get(1));</span>
<span class="nc" id="L551">            m.originalRef = dstMention.originalRef;</span>
<span class="nc" id="L552">            dstMention.originalRef = id;</span>

<span class="nc bnc" id="L554" title="All 2 branches missed.">            if (m.originalRef &lt; 0) break;</span>
<span class="nc" id="L555">            dst = positions.get(m.originalRef);</span>
<span class="nc" id="L556">          }</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">          if (m.originalRef &lt; 0) continue;</span>

          // A B C: if A&lt;-B, A&lt;-C =&gt; make a link B&lt;-C
<span class="nc bnc" id="L560" title="All 2 branches missed.">          for (int k = dst.get(0); k &lt;= src.get(0); k++) {</span>
<span class="nc bnc" id="L561" title="All 2 branches missed.">            for (int l = 0; l &lt; goldOrderedMentionsBySentence.get(k).size(); l++) {</span>
<span class="nc bnc" id="L562" title="All 4 branches missed.">              if (k == dst.get(0) &amp;&amp; l &lt; dst.get(1)) continue;</span>
<span class="nc bnc" id="L563" title="All 4 branches missed.">              if (k == src.get(0) &amp;&amp; l &gt; src.get(1)) break;</span>
<span class="nc" id="L564">              IntTuple missed = new IntTuple(2);</span>
<span class="nc" id="L565">              missed.set(0, k);</span>
<span class="nc" id="L566">              missed.set(1, l);</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">              if (links.contains(new Pair&lt;&gt;(missed, dst))) {</span>
<span class="nc" id="L568">                antecedents.get(id).add(missed);</span>
<span class="nc" id="L569">                links.add(new Pair&lt;&gt;(src, missed));</span>
              }
            }
          }

<span class="nc" id="L574">          links.add(new Pair&lt;&gt;(src, dst));</span>

<span class="nc bnc" id="L576" title="All 4 branches missed.">          assert (antecedents.get(id) != null);</span>
<span class="nc" id="L577">          antecedents.get(id).add(dst);</span>

<span class="nc" id="L579">          List&lt;IntTuple&gt; ants = antecedents.get(m.originalRef);</span>
<span class="nc bnc" id="L580" title="All 4 branches missed.">          assert (ants != null);</span>
<span class="nc bnc" id="L581" title="All 2 branches missed.">          for (IntTuple ant : ants) {</span>
<span class="nc" id="L582">            antecedents.get(id).add(ant);</span>
<span class="nc" id="L583">            links.add(new Pair&lt;&gt;(src, ant));</span>
<span class="nc" id="L584">          }</span>
        }
<span class="nc" id="L586">      }</span>
<span class="nc" id="L587">    }</span>
<span class="nc" id="L588">    goldLinks = links;</span>
<span class="nc" id="L589">  }</span>

  /** set UtteranceAnnotation for quotations: default UtteranceAnnotation = 0 is given */
  private void markQuotations(List&lt;CoreMap&gt; results, boolean normalQuotationType) {
<span class="nc" id="L593">    boolean insideQuotation = false;</span>
<span class="nc bnc" id="L594" title="All 2 branches missed.">    for(CoreMap m : results) {</span>
<span class="nc bnc" id="L595" title="All 2 branches missed.">      for(CoreLabel l : m.get(CoreAnnotations.TokensAnnotation.class)) {</span>
<span class="nc" id="L596">        String w = l.get(CoreAnnotations.TextAnnotation.class);</span>

<span class="nc bnc" id="L598" title="All 2 branches missed.">        boolean noSpeakerInfo = !l.containsKey(CoreAnnotations.SpeakerAnnotation.class)</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">        || l.get(CoreAnnotations.SpeakerAnnotation.class).equals(&quot;&quot;)</span>
<span class="nc bnc" id="L600" title="All 2 branches missed.">        || l.get(CoreAnnotations.SpeakerAnnotation.class).startsWith(&quot;PER&quot;);</span>

<span class="nc bnc" id="L602" title="All 6 branches missed.">        if(w.equals(&quot;``&quot;)</span>
<span class="nc bnc" id="L603" title="All 2 branches missed.">            || (!insideQuotation &amp;&amp; normalQuotationType &amp;&amp; w.equals(&quot;\&quot;&quot;))) {</span>
<span class="nc" id="L604">          insideQuotation = true;</span>
<span class="nc" id="L605">          maxUtter++;</span>
<span class="nc" id="L606">          continue;</span>
<span class="nc bnc" id="L607" title="All 6 branches missed.">        } else if(w.equals(&quot;''&quot;)</span>
<span class="nc bnc" id="L608" title="All 2 branches missed.">            || (insideQuotation &amp;&amp; normalQuotationType &amp;&amp; w.equals(&quot;\&quot;&quot;))) {</span>
<span class="nc" id="L609">          insideQuotation = false;</span>
        }
<span class="nc bnc" id="L611" title="All 2 branches missed.">        if(insideQuotation) {</span>
<span class="nc" id="L612">          l.set(CoreAnnotations.UtteranceAnnotation.class, maxUtter);</span>
        }
<span class="nc bnc" id="L614" title="All 2 branches missed.">        if(noSpeakerInfo){</span>
<span class="nc" id="L615">          l.set(CoreAnnotations.SpeakerAnnotation.class, &quot;PER&quot;+l.get(CoreAnnotations.UtteranceAnnotation.class));</span>
        }
<span class="nc" id="L617">      }</span>
<span class="nc" id="L618">    }</span>
<span class="nc bnc" id="L619" title="All 4 branches missed.">    if(maxUtter==0 &amp;&amp; !normalQuotationType) markQuotations(results, true);</span>
<span class="nc" id="L620">  }</span>

  /** Speaker extraction */
  private void findSpeakers(Dictionaries dict) {
<span class="nc" id="L624">    Boolean useMarkedDiscourseBoolean = annotation.get(CoreAnnotations.UseMarkedDiscourseAnnotation.class);</span>
<span class="nc bnc" id="L625" title="All 2 branches missed.">    boolean useMarkedDiscourse = (useMarkedDiscourseBoolean != null)? useMarkedDiscourseBoolean: false;</span>
<span class="nc bnc" id="L626" title="All 2 branches missed.">    if (Constants.USE_GOLD_SPEAKER_TAGS || useMarkedDiscourse) {</span>
<span class="nc bnc" id="L627" title="All 2 branches missed.">      for(CoreMap sent : annotation.get(CoreAnnotations.SentencesAnnotation.class)) {</span>
<span class="nc bnc" id="L628" title="All 2 branches missed.">        for(CoreLabel w : sent.get(CoreAnnotations.TokensAnnotation.class)) {</span>
<span class="nc" id="L629">          int utterIndex = w.get(CoreAnnotations.UtteranceAnnotation.class);</span>
<span class="nc" id="L630">          speakers.put(utterIndex, w.get(CoreAnnotations.SpeakerAnnotation.class));</span>
<span class="nc" id="L631">        }</span>
<span class="nc" id="L632">      }</span>
    } else {
<span class="nc bnc" id="L634" title="All 2 branches missed.">      if(docType==DocType.CONVERSATION) findSpeakersInConversation(dict);</span>
<span class="nc bnc" id="L635" title="All 2 branches missed.">      else if (docType==DocType.ARTICLE) findSpeakersInArticle(dict);</span>

      // set speaker info to annotation
<span class="nc bnc" id="L638" title="All 2 branches missed.">      for(CoreMap sent : annotation.get(CoreAnnotations.SentencesAnnotation.class)) {</span>
<span class="nc bnc" id="L639" title="All 2 branches missed.">        for(CoreLabel w : sent.get(CoreAnnotations.TokensAnnotation.class)) {</span>
<span class="nc" id="L640">          int utterIndex = w.get(CoreAnnotations.UtteranceAnnotation.class);</span>
<span class="nc bnc" id="L641" title="All 2 branches missed.">          if(speakers.containsKey(utterIndex)) {</span>
<span class="nc" id="L642">            w.set(CoreAnnotations.SpeakerAnnotation.class, speakers.get(utterIndex));</span>
          }
<span class="nc" id="L644">        }</span>
<span class="nc" id="L645">      }</span>
    }
<span class="nc" id="L647">  }</span>
  private void findSpeakersInArticle(Dictionaries dict) {
<span class="nc" id="L649">    List&lt;CoreMap&gt; sentences = annotation.get(CoreAnnotations.SentencesAnnotation.class);</span>
<span class="nc" id="L650">    Pair&lt;Integer, Integer&gt; beginQuotation = new Pair&lt;&gt;();</span>
<span class="nc" id="L651">    Pair&lt;Integer, Integer&gt; endQuotation = new Pair&lt;&gt;();</span>
<span class="nc" id="L652">    boolean insideQuotation = false;</span>
<span class="nc" id="L653">    int utterNum = -1;</span>

<span class="nc bnc" id="L655" title="All 2 branches missed.">    for (int i = 0 ; i &lt; sentences.size(); i++) {</span>
<span class="nc" id="L656">      List&lt;CoreLabel&gt; sent = sentences.get(i).get(CoreAnnotations.TokensAnnotation.class);</span>
<span class="nc bnc" id="L657" title="All 2 branches missed.">      for(int j = 0 ; j &lt; sent.size() ; j++) {</span>
<span class="nc" id="L658">        int utterIndex = sent.get(j).get(CoreAnnotations.UtteranceAnnotation.class);</span>

<span class="nc bnc" id="L660" title="All 4 branches missed.">        if(utterIndex != 0 &amp;&amp; !insideQuotation) {</span>
<span class="nc" id="L661">          utterNum = utterIndex;</span>
<span class="nc" id="L662">          insideQuotation = true;</span>
<span class="nc" id="L663">          beginQuotation.setFirst(i);</span>
<span class="nc" id="L664">          beginQuotation.setSecond(j);</span>
<span class="nc bnc" id="L665" title="All 4 branches missed.">        } else if (utterIndex == 0 &amp;&amp; insideQuotation) {</span>
<span class="nc" id="L666">          insideQuotation = false;</span>
<span class="nc" id="L667">          endQuotation.setFirst(i);</span>
<span class="nc" id="L668">          endQuotation.setSecond(j);</span>
<span class="nc" id="L669">          findQuotationSpeaker(utterNum, sentences, beginQuotation, endQuotation, dict);</span>
        }
      }
    }
<span class="nc" id="L673">  }</span>

  private void findQuotationSpeaker(int utterNum, List&lt;CoreMap&gt; sentences,
      Pair&lt;Integer, Integer&gt; beginQuotation, Pair&lt;Integer, Integer&gt; endQuotation, Dictionaries dict) {

<span class="nc bnc" id="L678" title="All 2 branches missed.">    if(findSpeaker(utterNum, beginQuotation.first(), sentences, 0, beginQuotation.second(), dict))</span>
<span class="nc" id="L679">      return ;</span>

<span class="nc bnc" id="L681" title="All 2 branches missed.">    if(findSpeaker(utterNum, endQuotation.first(), sentences, endQuotation.second(),</span>
<span class="nc" id="L682">        sentences.get(endQuotation.first()).get(CoreAnnotations.TokensAnnotation.class).size(), dict))</span>
<span class="nc" id="L683">      return;</span>

<span class="nc bnc" id="L685" title="All 4 branches missed.">    if(beginQuotation.second() &lt;= 1 &amp;&amp; beginQuotation.first() &gt; 0) {</span>
<span class="nc bnc" id="L686" title="All 2 branches missed.">      if(findSpeaker(utterNum, beginQuotation.first()-1, sentences, 0,</span>
<span class="nc" id="L687">          sentences.get(beginQuotation.first()-1).get(CoreAnnotations.TokensAnnotation.class).size(), dict))</span>
<span class="nc" id="L688">        return;</span>
    }

<span class="nc bnc" id="L691" title="All 2 branches missed.">    if(endQuotation.second() == sentences.get(endQuotation.first()).size()-1</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">        &amp;&amp; sentences.size() &gt; endQuotation.first()+1) {</span>
<span class="nc bnc" id="L693" title="All 2 branches missed.">      if(findSpeaker(utterNum, endQuotation.first()+1, sentences, 0,</span>
<span class="nc" id="L694">          sentences.get(endQuotation.first()+1).get(CoreAnnotations.TokensAnnotation.class).size(), dict))</span>
<span class="nc" id="L695">        return;</span>
    }
<span class="nc" id="L697">  }</span>

  private boolean findSpeaker(int utterNum, int sentNum, List&lt;CoreMap&gt; sentences,
      int startIndex, int endIndex, Dictionaries dict) {
<span class="nc" id="L701">    List&lt;CoreLabel&gt; sent = sentences.get(sentNum).get(CoreAnnotations.TokensAnnotation.class);</span>
<span class="nc bnc" id="L702" title="All 2 branches missed.">    for(int i = startIndex ; i &lt; endIndex ; i++) {</span>
<span class="nc bnc" id="L703" title="All 2 branches missed.">      if(sent.get(i).get(CoreAnnotations.UtteranceAnnotation.class)!=0) continue;</span>
<span class="nc" id="L704">      String lemma = sent.get(i).get(CoreAnnotations.LemmaAnnotation.class);</span>
<span class="nc" id="L705">      String word = sent.get(i).get(CoreAnnotations.TextAnnotation.class);</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">      if(dict.reportVerb.contains(lemma)) {</span>
        // find subject
<span class="nc" id="L708">        SemanticGraph dependency = sentences.get(sentNum).get(SemanticGraphCoreAnnotations.EnhancedDependenciesAnnotation.class);</span>
<span class="nc" id="L709">        IndexedWord w = dependency.getNodeByWordPattern(word);</span>

<span class="nc bnc" id="L711" title="All 2 branches missed.">        if (w != null) {</span>
<span class="nc bnc" id="L712" title="All 2 branches missed.">          for(Pair&lt;GrammaticalRelation,IndexedWord&gt; child : dependency.childPairs(w)){</span>
<span class="nc bnc" id="L713" title="All 2 branches missed.">            if(child.first().getShortName().equals(&quot;nsubj&quot;)) {</span>
<span class="nc" id="L714">              String subjectString = child.second().word();</span>
<span class="nc" id="L715">              int subjectIndex = child.second().index();  // start from 1</span>
<span class="nc" id="L716">              IntTuple headPosition = new IntTuple(2);</span>
<span class="nc" id="L717">              headPosition.set(0, sentNum);</span>
<span class="nc" id="L718">              headPosition.set(1, subjectIndex-1);</span>
              String speaker;
<span class="nc bnc" id="L720" title="All 2 branches missed.">              if(mentionheadPositions.containsKey(headPosition)) {</span>
<span class="nc" id="L721">                speaker = Integer.toString(mentionheadPositions.get(headPosition).mentionID);</span>
              } else {
<span class="nc" id="L723">                speaker = subjectString;</span>
              }
<span class="nc" id="L725">              speakers.put(utterNum, speaker);</span>
<span class="nc" id="L726">              return true;</span>
            }
<span class="nc" id="L728">          }</span>
        } else {
<span class="nc" id="L730">          SieveCoreferenceSystem.logger.warning(&quot;Cannot find node in dependency for word &quot; + word);</span>
        }
      }
    }
<span class="nc" id="L734">    return false;</span>
  }

  private void findSpeakersInConversation(Dictionaries dict) {
<span class="nc bnc" id="L738" title="All 2 branches missed.">    for(List&lt;Mention&gt; l : predictedOrderedMentionsBySentence) {</span>
<span class="nc bnc" id="L739" title="All 2 branches missed.">      for(Mention m : l){</span>
<span class="nc bnc" id="L740" title="All 2 branches missed.">        if(m.predicateNominatives == null) continue;</span>
<span class="nc bnc" id="L741" title="All 2 branches missed.">        for (Mention a : m.predicateNominatives){</span>
<span class="nc bnc" id="L742" title="All 2 branches missed.">          if(a.spanToString().toLowerCase().equals(&quot;i&quot;)) {</span>
<span class="nc" id="L743">            speakers.put(m.headWord.get(CoreAnnotations.UtteranceAnnotation.class), Integer.toString(m.mentionID));</span>
          }
<span class="nc" id="L745">        }</span>
<span class="nc" id="L746">      }</span>
<span class="nc" id="L747">    }</span>
<span class="nc" id="L748">    List&lt;CoreMap&gt; paragraph = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L749">    int paragraphUtterIndex = 0;</span>
<span class="nc" id="L750">    String nextParagraphSpeaker = &quot;&quot;;</span>
<span class="nc" id="L751">    int paragraphOffset = 0;</span>
<span class="nc bnc" id="L752" title="All 2 branches missed.">    for(CoreMap sent : annotation.get(CoreAnnotations.SentencesAnnotation.class)) {</span>
<span class="nc" id="L753">      int currentUtter = sent.get(CoreAnnotations.TokensAnnotation.class).get(0).get(CoreAnnotations.UtteranceAnnotation.class);</span>
<span class="nc bnc" id="L754" title="All 2 branches missed.">      if(paragraphUtterIndex!=currentUtter) {</span>
<span class="nc" id="L755">        nextParagraphSpeaker = findParagraphSpeaker(paragraph, paragraphUtterIndex, nextParagraphSpeaker, paragraphOffset, dict);</span>
<span class="nc" id="L756">        paragraphUtterIndex = currentUtter;</span>
<span class="nc" id="L757">        paragraphOffset += paragraph.size();</span>
<span class="nc" id="L758">        paragraph = new ArrayList&lt;&gt;();</span>
      }
<span class="nc" id="L760">      paragraph.add(sent);</span>
<span class="nc" id="L761">    }</span>
<span class="nc" id="L762">    findParagraphSpeaker(paragraph, paragraphUtterIndex, nextParagraphSpeaker, paragraphOffset, dict);</span>
<span class="nc" id="L763">  }</span>

  private String findParagraphSpeaker(List&lt;CoreMap&gt; paragraph,
      int paragraphUtterIndex, String nextParagraphSpeaker, int paragraphOffset, Dictionaries dict) {
<span class="nc bnc" id="L767" title="All 2 branches missed.">    if(!speakers.containsKey(paragraphUtterIndex)) {</span>
<span class="nc bnc" id="L768" title="All 2 branches missed.">      if(!nextParagraphSpeaker.equals(&quot;&quot;)) {</span>
<span class="nc" id="L769">        speakers.put(paragraphUtterIndex, nextParagraphSpeaker);</span>
      } else {  // find the speaker of this paragraph (John, nbc news)
<span class="nc" id="L771">        CoreMap lastSent = paragraph.get(paragraph.size()-1);</span>
<span class="nc" id="L772">        String speaker = &quot;&quot;;</span>
<span class="nc" id="L773">        boolean hasVerb = false;</span>
<span class="nc bnc" id="L774" title="All 2 branches missed.">        for(int i = 0 ; i &lt; lastSent.get(CoreAnnotations.TokensAnnotation.class).size() ; i++){</span>
<span class="nc" id="L775">          CoreLabel w = lastSent.get(CoreAnnotations.TokensAnnotation.class).get(i);</span>
<span class="nc" id="L776">          String pos = w.get(CoreAnnotations.PartOfSpeechAnnotation.class);</span>
<span class="nc" id="L777">          String ner = w.get(CoreAnnotations.NamedEntityTagAnnotation.class);</span>
<span class="nc bnc" id="L778" title="All 2 branches missed.">          if(pos.startsWith(&quot;V&quot;)) {</span>
<span class="nc" id="L779">            hasVerb = true;</span>
<span class="nc" id="L780">            break;</span>
          }
<span class="nc bnc" id="L782" title="All 2 branches missed.">          if(ner.startsWith(&quot;PER&quot;)) {</span>
<span class="nc" id="L783">            IntTuple headPosition = new IntTuple(2);</span>
<span class="nc" id="L784">            headPosition.set(0, paragraph.size()-1 + paragraphOffset);</span>
<span class="nc" id="L785">            headPosition.set(1, i);</span>
<span class="nc bnc" id="L786" title="All 2 branches missed.">            if(mentionheadPositions.containsKey(headPosition)) {</span>
<span class="nc" id="L787">              speaker = Integer.toString(mentionheadPositions.get(headPosition).mentionID);</span>
            }
          }
        }
<span class="nc bnc" id="L791" title="All 4 branches missed.">        if(!hasVerb &amp;&amp; !speaker.equals(&quot;&quot;)) {</span>
<span class="nc" id="L792">          speakers.put(paragraphUtterIndex, speaker);</span>
        }
      }
    }
<span class="nc" id="L796">    return findNextParagraphSpeaker(paragraph, paragraphOffset, dict);</span>
  }

  private String findNextParagraphSpeaker(List&lt;CoreMap&gt; paragraph, int paragraphOffset, Dictionaries dict) {
<span class="nc" id="L800">    CoreMap lastSent = paragraph.get(paragraph.size()-1);</span>
<span class="nc" id="L801">    String speaker = &quot;&quot;;</span>
<span class="nc bnc" id="L802" title="All 2 branches missed.">    for(CoreLabel w : lastSent.get(CoreAnnotations.TokensAnnotation.class)) {</span>
<span class="nc bnc" id="L803" title="All 4 branches missed.">      if(w.get(CoreAnnotations.LemmaAnnotation.class).equals(&quot;report&quot;) || w.get(CoreAnnotations.LemmaAnnotation.class).equals(&quot;say&quot;)) {</span>
<span class="nc" id="L804">        String word = w.get(CoreAnnotations.TextAnnotation.class);</span>
<span class="nc" id="L805">        SemanticGraph dependency = lastSent.get(SemanticGraphCoreAnnotations.EnhancedDependenciesAnnotation.class);</span>
<span class="nc" id="L806">        IndexedWord t = dependency.getNodeByWordPattern(word);</span>

<span class="nc bnc" id="L808" title="All 2 branches missed.">        for(Pair&lt;GrammaticalRelation,IndexedWord&gt; child : dependency.childPairs(t)){</span>
<span class="nc bnc" id="L809" title="All 2 branches missed.">          if(child.first().getShortName().equals(&quot;nsubj&quot;)) {</span>
<span class="nc" id="L810">            int subjectIndex = child.second().index();  // start from 1</span>
<span class="nc" id="L811">            IntTuple headPosition = new IntTuple(2);</span>
<span class="nc" id="L812">            headPosition.set(0, paragraph.size()-1 + paragraphOffset);</span>
<span class="nc" id="L813">            headPosition.set(1, subjectIndex-1);</span>
<span class="nc bnc" id="L814" title="All 2 branches missed.">            if(mentionheadPositions.containsKey(headPosition)</span>
<span class="nc bnc" id="L815" title="All 2 branches missed.">                &amp;&amp; mentionheadPositions.get(headPosition).nerString.startsWith(&quot;PER&quot;)) {</span>
<span class="nc" id="L816">              speaker = Integer.toString(mentionheadPositions.get(headPosition).mentionID);</span>
            }
          }
<span class="nc" id="L819">        }</span>
      }
<span class="nc" id="L821">    }</span>
<span class="nc" id="L822">    return speaker;</span>
  }

  public SpeakerInfo getSpeakerInfo(String speaker) {
<span class="nc" id="L826">    return speakerInfoMap.get(speaker);</span>
  }

  public int numberOfSpeakers() {
<span class="nc" id="L830">    return speakerInfoMap.size();</span>
  }

  /** Check one mention is the speaker of the other mention */
  public static boolean isSpeaker(Mention m, Mention ant, Dictionaries dict) {

<span class="nc bnc" id="L836" title="All 6 branches missed.">    if(!dict.firstPersonPronouns.contains(ant.spanToString().toLowerCase())</span>
<span class="nc" id="L837">        || ant.number==Number.PLURAL || ant.sentNum!=m.sentNum) return false;</span>

<span class="nc" id="L839">    int countQuotationMark = 0;</span>
<span class="nc bnc" id="L840" title="All 2 branches missed.">    for(int i = Math.min(m.headIndex, ant.headIndex)+1 ; i &lt; Math.max(m.headIndex, ant.headIndex) ; i++) {</span>
<span class="nc" id="L841">      String word = m.sentenceWords.get(i).get(CoreAnnotations.TextAnnotation.class);</span>
<span class="nc bnc" id="L842" title="All 4 branches missed.">      if(word.equals(&quot;``&quot;) || word.equals(&quot;''&quot;)) countQuotationMark++;</span>
    }
<span class="nc bnc" id="L844" title="All 2 branches missed.">    if(countQuotationMark!=1) return false;</span>

<span class="nc" id="L846">    IndexedWord w = m.dependency.getNodeByWordPattern(m.sentenceWords.get(m.headIndex).get(CoreAnnotations.TextAnnotation.class));</span>
<span class="nc bnc" id="L847" title="All 2 branches missed.">    if(w== null) return false;</span>

<span class="nc bnc" id="L849" title="All 2 branches missed.">    for(Pair&lt;GrammaticalRelation,IndexedWord&gt; parent : m.dependency.parentPairs(w)){</span>
<span class="nc bnc" id="L850" title="All 2 branches missed.">      if(parent.first().getShortName().equals(&quot;nsubj&quot;)</span>
<span class="nc bnc" id="L851" title="All 2 branches missed.">          &amp;&amp; dict.reportVerb.contains(parent.second().get(CoreAnnotations.LemmaAnnotation.class))) {</span>
<span class="nc" id="L852">        return true;</span>
      }
<span class="nc" id="L854">    }</span>
<span class="nc" id="L855">    return false;</span>
  }

  protected void printMentionDetection() {
<span class="nc" id="L859">    int foundGoldCount = 0;</span>
<span class="nc bnc" id="L860" title="All 2 branches missed.">    for(Mention g : allGoldMentions.values()) {</span>
<span class="nc bnc" id="L861" title="All 2 branches missed.">      if(!g.twinless) foundGoldCount++;</span>
<span class="nc" id="L862">    }</span>
<span class="nc" id="L863">    SieveCoreferenceSystem.logger.fine(&quot;# of found gold mentions: &quot;+foundGoldCount + &quot; / # of gold mentions: &quot;+allGoldMentions.size());</span>
<span class="nc" id="L864">    SieveCoreferenceSystem.logger.fine(&quot;gold mentions == &quot;);</span>
<span class="nc" id="L865">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>