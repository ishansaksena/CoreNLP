<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CoNLL2011DocumentReader.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.dcoref</a> &gt; <span class="el_source">CoNLL2011DocumentReader.java</span></div><h1>CoNLL2011DocumentReader.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.dcoref; 
import edu.stanford.nlp.util.logging.Redwood;

import edu.stanford.nlp.io.IOUtils;
import edu.stanford.nlp.io.RuntimeIOException;
import edu.stanford.nlp.ling.CoreAnnotation;
import edu.stanford.nlp.ling.CoreAnnotations;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.ling.Label;
import edu.stanford.nlp.pipeline.Annotation;
import edu.stanford.nlp.pipeline.ChunkAnnotationUtils;
import edu.stanford.nlp.stats.Counters;
import edu.stanford.nlp.stats.IntCounter;
import edu.stanford.nlp.trees.*;
import edu.stanford.nlp.util.*;

import java.io.*;
import java.util.*;
import java.util.logging.Logger;
import java.util.regex.Pattern;

/**
 * Read _conll file format from CoNLL2011.  See http://conll.bbn.com/index.php/data.html.
 *
 * CoNLL2011 files are in /scr/nlp/data/conll-2011/v0/data/
 *    dev
 *    train
 * Contains *_auto_conll files (auto generated) and _gold_conll (hand labelled), default reads _gold_conll
 * There is also /scr/nlp/data/conll-2011/v0/conll.trial which has *.conll files (parse has _ at end)
 *
 * Column 	Type 	Description
 * 1   	Document ID 	This is a variation on the document filename
 * 2   	Part number 	Some files are divided into multiple parts numbered as 000, 001, 002, ... etc.
 * 3   	Word number
 * 4   	Word itself
 * 5   	Part-of-Speech
 * 6   	Parse bit 	This is the bracketed structure broken before the first open parenthesis in the parse, and the word/part-of-speech leaf replaced with a *. The full parse can be created by substituting the asterix with the &quot;([pos] [word])&quot; string (or leaf) and concatenating the items in the rows of that column.
 * 7   	Predicate lemma 	The predicate lemma is mentioned for the rows for which we have semantic role information. All other rows are marked with a &quot;-&quot;
 * 8   	Predicate Frameset ID 	This is the PropBank frameset ID of the predicate in Column 7.
 * 9   	Word sense 	This is the word sense of the word in Column 3.
 * 10   	Speaker/Author 	This is the speaker or author name where available. Mostly in Broadcast Conversation and Web Log data.
 * 11   	Named Entities 	These columns identifies the spans representing various named entities.
 * 12:N   	Predicate Arguments 	There is one column each of predicate argument structure information for the predicate mentioned in Column 7.
 * N   	Coreference 	Coreference chain information encoded in a parenthesis structure.
 *
 * @author Angel Chang
 */
public class CoNLL2011DocumentReader  {

  /** A logger for this class */
<span class="nc" id="L51">  private static Redwood.RedwoodChannels log = Redwood.channels(CoNLL2011DocumentReader.class);</span>

  private static final int FIELD_LAST = -1;

  private static final int FIELD_DOC_ID = 0;
  private static final int FIELD_PART_NO = 1;
  private static final int FIELD_WORD_NO = 2;
  private static final int FIELD_WORD = 3;
  private static final int FIELD_POS_TAG = 4;
  private static final int FIELD_PARSE_BIT = 5;
//  private static final int FIELD_PRED_LEMMA = 6;
//  private static final int FIELD_PRED_FRAMESET_ID = 7;
//  private static final int FIELD_WORD_SENSE = 8;
  private static final int FIELD_SPEAKER_AUTHOR = 9;
  private static final int FIELD_NER_TAG = 10;
//  private static final int FIELD_PRED_ARGS = 11;  // Predicate args follow...
  private static final int FIELD_COREF = FIELD_LAST;  // Last field

  private static final int FIELDS_MIN = 12;  // There should be at least 13 fields

  private DocumentIterator docIterator;
//  private String filepath;
  protected final List&lt;File&gt; fileList;
  private int curFileIndex;
  private final Options options;

<span class="nc" id="L77">  public static final Logger logger = Logger.getLogger(CoNLL2011DocumentReader.class.getName());</span>

  public CoNLL2011DocumentReader(String filepath)
  {
<span class="nc" id="L81">    this(filepath, new Options());</span>
<span class="nc" id="L82">  }</span>

  public CoNLL2011DocumentReader(String filepath, Options options)
<span class="nc" id="L85">  {</span>
//    this.filepath = filepath;
<span class="nc" id="L87">    this.fileList = getFiles(filepath, options.filePattern);</span>
<span class="nc" id="L88">    this.options = options;</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">    if (options.sortFiles) {</span>
<span class="nc" id="L90">      Collections.sort(this.fileList);</span>
    }
<span class="nc" id="L92">    curFileIndex = 0;</span>
<span class="nc" id="L93">    logger.info(&quot;Reading &quot; + fileList.size() + &quot; CoNll2011 files from &quot; + filepath);</span>
<span class="nc" id="L94">  }</span>

  private static List&lt;File&gt; getFiles(String filepath, Pattern filter)
  {
<span class="nc" id="L98">    Iterable&lt;File&gt; iter = IOUtils.iterFilesRecursive(new File(filepath), filter);</span>
<span class="nc" id="L99">    List&lt;File&gt; fileList = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">    for (File f:iter) {</span>
<span class="nc" id="L101">      fileList.add(f);</span>
<span class="nc" id="L102">    }</span>
<span class="nc" id="L103">    Collections.sort(fileList);</span>
<span class="nc" id="L104">    return fileList;</span>
  }

  public void reset() {
<span class="nc" id="L108">    curFileIndex = 0;</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">    if (docIterator != null) {</span>
<span class="nc" id="L110">      docIterator.close();</span>
<span class="nc" id="L111">      docIterator = null;</span>
    }
<span class="nc" id="L113">  }</span>

  public Document getNextDocument()
  {
    try {
<span class="nc bnc" id="L118" title="All 2 branches missed.">      if (curFileIndex &gt;= fileList.size()) return null;  // DONE!</span>
<span class="nc" id="L119">      File curFile = fileList.get(curFileIndex);</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">      if (docIterator == null) {</span>
<span class="nc" id="L121">        docIterator = new DocumentIterator(curFile.getAbsolutePath(), options);</span>
      }
<span class="nc bnc" id="L123" title="All 2 branches missed.">      while ( ! docIterator.hasNext()) {</span>
<span class="nc" id="L124">        logger.info(&quot;Processed &quot; + docIterator.docCnt + &quot; documents in &quot; + curFile.getAbsolutePath());</span>
<span class="nc" id="L125">        docIterator.close();</span>
<span class="nc" id="L126">        curFileIndex++;</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">        if (curFileIndex &gt;= fileList.size()) {</span>
<span class="nc" id="L128">          return null;  // DONE!</span>
        }
<span class="nc" id="L130">        curFile = fileList.get(curFileIndex);</span>
<span class="nc" id="L131">        docIterator = new DocumentIterator(curFile.getAbsolutePath(), options);</span>
      }
<span class="nc" id="L133">      Document next = docIterator.next();</span>
<span class="nc" id="L134">      SieveCoreferenceSystem.logger.fine(&quot;Reading document: &quot; + next.getDocumentID());</span>
<span class="nc" id="L135">      return next;</span>
<span class="nc" id="L136">    } catch (IOException ex) {</span>
<span class="nc" id="L137">      throw new RuntimeIOException(ex);</span>
    }
  }

  public void close()
  {
<span class="nc" id="L143">    IOUtils.closeIgnoringExceptions(docIterator);</span>
<span class="nc" id="L144">  }</span>

<span class="nc" id="L146">  public static class NamedEntityAnnotation implements CoreAnnotation&lt;CoreMap&gt; {</span>
    public Class&lt;CoreMap&gt; getType() {
<span class="nc" id="L148">      return CoreMap.class;</span>
    }
  }

<span class="nc" id="L152">  public static class CorefMentionAnnotation implements CoreAnnotation&lt;CoreMap&gt; {</span>
    public Class&lt;CoreMap&gt; getType() {
<span class="nc" id="L154">      return CoreMap.class;</span>
    }
  }

  /** Flags **/
  public static class Options {
<span class="nc" id="L160">    public boolean useCorefBIOESEncoding = false; // Marks Coref mentions with prefix</span>
                                                  // B- begin, I- inside, E- end, S- single
<span class="nc" id="L162">    public boolean annotateTokenCoref = true;    // Annotate token with CorefAnnotation</span>
                                                 // If token belongs to multiple clusters
                                                 // coref clusterid are separted by '|'
<span class="nc" id="L165">    public boolean annotateTokenSpeaker = true;  // Annotate token with SpeakerAnnotation</span>
<span class="nc" id="L166">    public boolean annotateTokenPos = true;      // Annotate token with PartOfSpeechAnnotation</span>
<span class="nc" id="L167">    public boolean annotateTokenNer = true;      // Annotate token with NamedEntityTagAnnotation</span>

<span class="nc" id="L169">    public boolean annotateTreeCoref = false;     // Annotate tree with CorefMentionAnnotation</span>
<span class="nc" id="L170">    public boolean annotateTreeNer = false;       // Annotate tree with NamedEntityAnnotation</span>

<span class="nc" id="L172">    public String backgroundNerTag = &quot;O&quot;;        // Background NER tag</span>

    protected String fileFilter;
    protected Pattern filePattern;
    protected boolean sortFiles;

    public Options() {
<span class="nc" id="L179">      this(&quot;.*_gold_conll$&quot;);      // _gold_conll or _auto_conll   or .conll</span>
<span class="nc" id="L180">    }</span>

<span class="nc" id="L182">    public Options(String filter) {</span>
<span class="nc" id="L183">      fileFilter = filter;</span>
<span class="nc" id="L184">      filePattern = Pattern.compile(fileFilter);</span>
<span class="nc" id="L185">    }</span>

    public void setFilter(String filter) {
<span class="nc" id="L188">      fileFilter = filter;</span>
<span class="nc" id="L189">      filePattern = Pattern.compile(fileFilter);</span>
<span class="nc" id="L190">    }</span>
  }

<span class="nc" id="L193">  public static class Document {</span>
    String documentIdPart;
    String documentID;
    String partNo;
<span class="nc" id="L197">    List&lt;List&lt;String[]&gt;&gt; sentenceWordLists = new ArrayList&lt;&gt;();</span>

    Annotation annotation;
    CollectionValuedMap&lt;String,CoreMap&gt; corefChainMap;
    List&lt;CoreMap&gt; nerChunks;

    public String getDocumentID() {
<span class="nc" id="L204">      return documentID;</span>
    }

    public void setDocumentID(String documentID) {
<span class="nc" id="L208">      this.documentID = documentID;</span>
<span class="nc" id="L209">    }</span>

    public String getPartNo() {
<span class="nc" id="L212">      return partNo;</span>
    }

    public void setPartNo(String partNo) {
<span class="nc" id="L216">      this.partNo = partNo;</span>
<span class="nc" id="L217">    }</span>

    public List&lt;List&lt;String[]&gt;&gt; getSentenceWordLists() {
<span class="nc" id="L220">      return sentenceWordLists;</span>
    }

    public void addSentence(List&lt;String[]&gt; sentence) {
<span class="nc" id="L224">      this.sentenceWordLists.add(sentence);</span>
<span class="nc" id="L225">    }</span>

    public Annotation getAnnotation() {
<span class="nc" id="L228">      return annotation;</span>
    }

    public void setAnnotation(Annotation annotation) {
<span class="nc" id="L232">      this.annotation = annotation;</span>
<span class="nc" id="L233">    }</span>

    public CollectionValuedMap&lt;String,CoreMap&gt; getCorefChainMap()
    {
<span class="nc" id="L237">      return corefChainMap;</span>
    }
  }

  private static String getField(String[] fields, int pos)
  {
<span class="nc bnc" id="L243" title="All 2 branches missed.">    if (pos == FIELD_LAST) {</span>
<span class="nc" id="L244">      return fields[fields.length - 1];</span>
    } else {
<span class="nc" id="L246">      return fields[pos];</span>
    }
  }

  private static String concatField(List&lt;String[]&gt; sentWords, int pos)
  {
<span class="nc" id="L252">    StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">    for (String[] fields:sentWords) {</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">      if (sb.length() &gt; 0) {</span>
<span class="nc" id="L255">        sb.append(' ');</span>
      }
<span class="nc" id="L257">      sb.append(getField(fields, pos));</span>
<span class="nc" id="L258">    }</span>
<span class="nc" id="L259">    return sb.toString();</span>
  }

  /** Helper iterator **/
<span class="nc bnc" id="L263" title="All 2 branches missed.">  private static class DocumentIterator extends AbstractIterator&lt;Document&gt; implements Closeable {</span>

<span class="nc" id="L265">    private static final Pattern delimiterPattern = Pattern.compile(&quot;\\s+&quot;);</span>
<span class="nc" id="L266">    private static final LabeledScoredTreeReaderFactory treeReaderFactory =</span>
            new LabeledScoredTreeReaderFactory((TreeNormalizer) null);

    private final Options options;

    // State
    String filename;
    BufferedReader br;
    Document nextDoc;
<span class="nc" id="L275">    int lineCnt = 0;</span>
<span class="nc" id="L276">    int docCnt = 0;</span>

<span class="nc" id="L278">    public DocumentIterator(String filename, Options options) throws IOException {</span>
<span class="nc" id="L279">      this.options = options;</span>
<span class="nc" id="L280">      this.filename = filename;</span>
<span class="nc" id="L281">      this.br = IOUtils.getBufferedFileReader(filename);</span>
<span class="nc" id="L282">      nextDoc = readNextDocument();</span>
<span class="nc" id="L283">    }</span>

    @Override
    public boolean hasNext() {
<span class="nc bnc" id="L287" title="All 2 branches missed.">      return nextDoc != null;</span>
    }

    @Override
    public Document next() {
<span class="nc bnc" id="L292" title="All 2 branches missed.">      if (nextDoc == null) {</span>
<span class="nc" id="L293">        throw new NoSuchElementException(&quot;DocumentIterator exhausted.&quot;);</span>
      }
<span class="nc" id="L295">      Document curDoc = nextDoc;</span>
<span class="nc" id="L296">      nextDoc = readNextDocument();</span>
<span class="nc" id="L297">      return curDoc;</span>
    }

<span class="nc" id="L300">    private static final Pattern starPattern = Pattern.compile(&quot;\\*&quot;);</span>

    private static Tree wordsToParse(List&lt;String[]&gt; sentWords)
    {
<span class="nc" id="L304">      StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">      for (String[] fields:sentWords) {</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">        if (sb.length() &gt; 0) {</span>
<span class="nc" id="L307">          sb.append(' ');</span>
        }

<span class="nc" id="L310">        String str = fields[FIELD_PARSE_BIT].replace(&quot;NOPARSE&quot;, &quot;X&quot;);</span>
<span class="nc" id="L311">        String tagword = &quot;(&quot; + fields[FIELD_POS_TAG] + &quot; &quot; + fields[FIELD_WORD] + &quot;)&quot;;</span>
        // Replace stars
<span class="nc" id="L313">        int si = str.indexOf('*');</span>
<span class="nc" id="L314">        sb.append(str.substring(0, si));</span>
<span class="nc" id="L315">        sb.append(tagword);</span>
<span class="nc" id="L316">        sb.append(str.substring(si+1));</span>
<span class="nc" id="L317">        si = str.indexOf('*', si+1);</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">        if (si &gt;= 0) {</span>
<span class="nc" id="L319">          logger.warning(&quot; Parse bit with multiple *: &quot; + str);</span>
        }
<span class="nc" id="L321">      }</span>
<span class="nc" id="L322">      String parseStr = sb.toString();</span>
<span class="nc" id="L323">      return Tree.valueOf(parseStr, treeReaderFactory);</span>
    }


    private static List&lt;Triple&lt;Integer,Integer,String&gt;&gt; getCorefSpans(List&lt;String[]&gt; sentWords)
    {
<span class="nc" id="L329">      return getLabelledSpans(sentWords, FIELD_COREF, HYPHEN, true);</span>
    }

    private static List&lt;Triple&lt;Integer,Integer,String&gt;&gt; getNerSpans(List&lt;String[]&gt; sentWords)
    {
<span class="nc" id="L334">      return getLabelledSpans(sentWords, FIELD_NER_TAG, ASTERISK, false);</span>
    }


    private static final String ASTERISK = &quot;*&quot;;
    private static final String HYPHEN = &quot;-&quot;;

    private static List&lt;Triple&lt;Integer,Integer,String&gt;&gt; getLabelledSpans(List&lt;String[]&gt; sentWords, int fieldIndex,
                                                                         String defaultMarker, boolean checkEndLabel)
    {
<span class="nc" id="L344">      List&lt;Triple&lt;Integer,Integer,String&gt;&gt; spans = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L345">      Stack&lt;Triple&lt;Integer,Integer, String&gt;&gt; openSpans = new Stack&lt;&gt;();</span>
<span class="nc" id="L346">      boolean removeStar = (ASTERISK.equals(defaultMarker));</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">      for (int wordPos = 0; wordPos &lt; sentWords.size(); wordPos++) {</span>
<span class="nc" id="L348">        String[] fields = sentWords.get(wordPos);</span>
<span class="nc" id="L349">        String val = getField(fields, fieldIndex);</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">        if (!defaultMarker.equals(val)) {</span>
<span class="nc" id="L351">          int openParenIndex = -1;</span>
<span class="nc" id="L352">          int lastDelimiterIndex = -1;</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">          for (int j = 0; j &lt; val.length(); j++) {</span>
<span class="nc" id="L354">            char c = val.charAt(j);</span>
<span class="nc" id="L355">            boolean isDelimiter = false;</span>
<span class="nc bnc" id="L356" title="All 6 branches missed.">            if (c == '(' || c == ')' || c == '|') {</span>
<span class="nc bnc" id="L357" title="All 2 branches missed.">              if (openParenIndex &gt;= 0) {</span>
<span class="nc" id="L358">                String s = val.substring(openParenIndex+1, j);</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">                if (removeStar) {</span>
<span class="nc" id="L360">                  s = starPattern.matcher(s).replaceAll(&quot;&quot;);</span>
                }
<span class="nc" id="L362">                openSpans.push(new Triple&lt;&gt;(wordPos, -1, s));</span>
<span class="nc" id="L363">                openParenIndex = -1;</span>
              }
<span class="nc" id="L365">              isDelimiter = true;</span>
            }
<span class="nc bnc" id="L367" title="All 2 branches missed.">            if (c == '(') {</span>
<span class="nc" id="L368">              openParenIndex = j;</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">            } else if (c == ')') {</span>
<span class="nc" id="L370">              Triple&lt;Integer, Integer, String&gt; t = openSpans.pop();</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">              if (checkEndLabel) {</span>
                // NOTE: end parens may cross (usually because mention either start or end on the same token
                // and it is just an artifact of the ordering
<span class="nc" id="L374">                String s = val.substring(lastDelimiterIndex+1, j);</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">                if (!s.equals(t.third())) {</span>
<span class="nc" id="L376">                  Stack&lt;Triple&lt;Integer,Integer, String&gt;&gt; saved = new Stack&lt;&gt;();</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">                  while (!s.equals(t.third())) {</span>
                    // find correct match
<span class="nc" id="L379">                    saved.push(t);</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">                    if (openSpans.isEmpty()) {</span>
<span class="nc" id="L381">                      throw new RuntimeException(&quot;Cannot find matching labelled span for &quot; + s);</span>
                    }
<span class="nc" id="L383">                    t = openSpans.pop();</span>
                  }
<span class="nc bnc" id="L385" title="All 2 branches missed.">                  while (!saved.isEmpty()) {</span>
<span class="nc" id="L386">                    openSpans.push(saved.pop());</span>
                  }
<span class="nc bnc" id="L388" title="All 4 branches missed.">                  assert(s.equals(t.third()));</span>
                }
              }
<span class="nc" id="L391">              t.setSecond(wordPos);</span>
<span class="nc" id="L392">              spans.add(t);</span>
            }
<span class="nc bnc" id="L394" title="All 2 branches missed.">            if (isDelimiter) {</span>
<span class="nc" id="L395">              lastDelimiterIndex = j;</span>
            }
          }
<span class="nc bnc" id="L398" title="All 2 branches missed.">          if (openParenIndex &gt;= 0) {</span>
<span class="nc" id="L399">            String s = val.substring(openParenIndex+1, val.length());</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">            if (removeStar) {</span>
<span class="nc" id="L401">              s = starPattern.matcher(s).replaceAll(&quot;&quot;);</span>
            }
<span class="nc" id="L403">            openSpans.push(new Triple&lt;&gt;(wordPos, -1, s));</span>
          }
        }
      }
<span class="nc bnc" id="L407" title="All 2 branches missed.">      if (openSpans.size() != 0) {</span>
<span class="nc" id="L408">        throw new RuntimeException(&quot;Error extracting labelled spans for column &quot; + fieldIndex + &quot;: &quot;</span>
<span class="nc" id="L409">                + concatField(sentWords, fieldIndex));</span>
      }
<span class="nc" id="L411">      return spans;</span>
    }

    private CoreMap wordsToSentence(List&lt;String[]&gt; sentWords)
    {
<span class="nc" id="L416">      String sentText = concatField(sentWords, FIELD_WORD);</span>
<span class="nc" id="L417">      Annotation sentence = new Annotation(sentText);</span>
<span class="nc" id="L418">      Tree tree = wordsToParse(sentWords);</span>
<span class="nc" id="L419">      sentence.set(TreeCoreAnnotations.TreeAnnotation.class, tree);</span>
<span class="nc" id="L420">      List&lt;Tree&gt; leaves = tree.getLeaves();</span>
      // Check leaves == number of words
<span class="nc bnc" id="L422" title="All 4 branches missed.">      assert(leaves.size() == sentWords.size());</span>
<span class="nc" id="L423">      List&lt;CoreLabel&gt; tokens = new ArrayList&lt;&gt;(leaves.size());</span>
<span class="nc" id="L424">      sentence.set(CoreAnnotations.TokensAnnotation.class, tokens);</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">      for (int i = 0; i &lt; sentWords.size(); i++) {</span>
<span class="nc" id="L426">        String[] fields = sentWords.get(i);</span>
<span class="nc" id="L427">        int wordPos = Integer.parseInt(fields[FIELD_WORD_NO]);</span>
<span class="nc bnc" id="L428" title="All 4 branches missed.">        assert(wordPos == i);</span>
<span class="nc" id="L429">        Tree leaf = leaves.get(i);</span>
<span class="nc" id="L430">        CoreLabel token = (CoreLabel) leaf.label();</span>
<span class="nc" id="L431">        tokens.add(token);</span>
<span class="nc bnc" id="L432" title="All 2 branches missed.">        if (options.annotateTokenSpeaker) {</span>
<span class="nc" id="L433">          String speaker = fields[FIELD_SPEAKER_AUTHOR].replace(&quot;_&quot;, &quot; &quot;);</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">          if (!HYPHEN.equals(speaker)) {</span>
<span class="nc" id="L435">            token.set(CoreAnnotations.SpeakerAnnotation.class, speaker);</span>
          }
        }
      }
<span class="nc bnc" id="L439" title="All 2 branches missed.">      if (options.annotateTokenPos) {</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">        for (Tree leaf:leaves) {</span>
<span class="nc" id="L441">          CoreLabel token = (CoreLabel) leaf.label();</span>
<span class="nc" id="L442">          token.set(CoreAnnotations.PartOfSpeechAnnotation.class, leaf.parent(tree).value());</span>
<span class="nc" id="L443">        }</span>
      }
<span class="nc bnc" id="L445" title="All 2 branches missed.">      if (options.annotateTokenNer) {</span>
<span class="nc" id="L446">        List&lt;Triple&lt;Integer,Integer,String&gt;&gt; nerSpans = getNerSpans(sentWords);</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">        for (Triple&lt;Integer,Integer,String&gt; nerSpan:nerSpans) {</span>
<span class="nc" id="L448">          int startToken = nerSpan.first();</span>
<span class="nc" id="L449">          int endToken = nerSpan.second(); /* inclusive */</span>
<span class="nc" id="L450">          String label = nerSpan.third();</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">          for (int i = startToken; i &lt;= endToken; i++) {</span>
<span class="nc" id="L452">            Tree leaf = leaves.get(i);</span>
<span class="nc" id="L453">            CoreLabel token = (CoreLabel) leaf.label();</span>
<span class="nc" id="L454">            String oldLabel = token.get(CoreAnnotations.NamedEntityTagAnnotation.class);</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">            if (oldLabel != null) {</span>
<span class="nc" id="L456">              logger.warning(&quot;Replacing old named entity tag &quot; + oldLabel + &quot; with &quot; + label);</span>
            }
<span class="nc" id="L458">            token.set(CoreAnnotations.NamedEntityTagAnnotation.class, label);</span>
          }
<span class="nc" id="L460">        }</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">        for (CoreLabel token:tokens) {</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">          if (!token.containsKey(CoreAnnotations.NamedEntityTagAnnotation.class)) {</span>
<span class="nc" id="L463">            token.set(CoreAnnotations.NamedEntityTagAnnotation.class, options.backgroundNerTag);</span>
          }
<span class="nc" id="L465">        }</span>
      }
<span class="nc bnc" id="L467" title="All 2 branches missed.">      if (options.annotateTokenCoref) {</span>
<span class="nc" id="L468">        List&lt;Triple&lt;Integer,Integer,String&gt;&gt; corefSpans = getCorefSpans(sentWords);</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">        for (Triple&lt;Integer,Integer,String&gt; corefSpan:corefSpans) {</span>
<span class="nc" id="L470">          int startToken = corefSpan.first();</span>
<span class="nc" id="L471">          int endToken = corefSpan.second(); /* inclusive */</span>
<span class="nc" id="L472">          String label = corefSpan.third();</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">          for (int i = startToken; i &lt;= endToken; i++) {</span>
<span class="nc" id="L474">            Tree leaf = leaves.get(i);</span>
<span class="nc" id="L475">            CoreLabel token = (CoreLabel) leaf.label();</span>
<span class="nc" id="L476">            String curLabel = label;</span>
<span class="nc bnc" id="L477" title="All 2 branches missed.">            if (options.useCorefBIOESEncoding) {</span>
              String prefix;
<span class="nc bnc" id="L479" title="All 2 branches missed.">              if (startToken == endToken) {</span>
<span class="nc" id="L480">                prefix = &quot;S-&quot;;</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">              } else if (i == startToken) {</span>
<span class="nc" id="L482">                prefix = &quot;B-&quot;;</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">              } else if (i == endToken) {</span>
<span class="nc" id="L484">                prefix = &quot;E-&quot;;</span>
              } else {
<span class="nc" id="L486">                prefix = &quot;I-&quot;;</span>
              }
<span class="nc" id="L488">              curLabel = prefix + label;</span>
            }
<span class="nc" id="L490">            String oldLabel = token.get(CorefCoreAnnotations.CorefAnnotation.class);</span>
<span class="nc bnc" id="L491" title="All 2 branches missed.">            if (oldLabel != null) {</span>
<span class="nc" id="L492">              curLabel = oldLabel + &quot;|&quot; + curLabel;</span>
            }
<span class="nc" id="L494">            token.set(CorefCoreAnnotations.CorefAnnotation.class, curLabel);</span>
          }
<span class="nc" id="L496">        }</span>
      }
<span class="nc" id="L498">      return sentence;</span>
    }

    public static Annotation sentencesToDocument(String documentID, List&lt;CoreMap&gt; sentences)
    {
<span class="nc" id="L503">      String docText = null;</span>
<span class="nc" id="L504">      Annotation document = new Annotation(docText);</span>
<span class="nc" id="L505">      document.set(CoreAnnotations.DocIDAnnotation.class, documentID);</span>
<span class="nc" id="L506">      document.set(CoreAnnotations.SentencesAnnotation.class, sentences);</span>


      // Accumulate docTokens and label sentence with overall token begin/end, and sentence index annotations
<span class="nc" id="L510">      List&lt;CoreLabel&gt; docTokens = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L511">      int sentenceIndex = 0;</span>
<span class="nc" id="L512">      int tokenBegin = 0;</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">      for (CoreMap sentenceAnnotation:sentences) {</span>
<span class="nc" id="L514">        List&lt;CoreLabel&gt; sentenceTokens = sentenceAnnotation.get(CoreAnnotations.TokensAnnotation.class);</span>
<span class="nc" id="L515">        docTokens.addAll(sentenceTokens);</span>

<span class="nc" id="L517">        int tokenEnd = tokenBegin + sentenceTokens.size();</span>
<span class="nc" id="L518">        sentenceAnnotation.set(CoreAnnotations.TokenBeginAnnotation.class, tokenBegin);</span>
<span class="nc" id="L519">        sentenceAnnotation.set(CoreAnnotations.TokenEndAnnotation.class, tokenEnd);</span>
<span class="nc" id="L520">        sentenceAnnotation.set(CoreAnnotations.SentenceIndexAnnotation.class, sentenceIndex);</span>
<span class="nc" id="L521">        sentenceIndex++;</span>
<span class="nc" id="L522">        tokenBegin = tokenEnd;</span>
<span class="nc" id="L523">      }</span>
<span class="nc" id="L524">      document.set(CoreAnnotations.TokensAnnotation.class, docTokens);</span>

      // Put in character offsets
<span class="nc" id="L527">      int i = 0;</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">      for (CoreLabel token:docTokens) {</span>
<span class="nc" id="L529">        String tokenText = token.get(CoreAnnotations.TextAnnotation.class);</span>
<span class="nc" id="L530">        token.set(CoreAnnotations.CharacterOffsetBeginAnnotation.class, i);</span>
<span class="nc" id="L531">        i+=tokenText.length();</span>
<span class="nc" id="L532">        token.set(CoreAnnotations.CharacterOffsetEndAnnotation.class, i);</span>
<span class="nc" id="L533">        i++; // Skip space</span>
<span class="nc" id="L534">      }</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">      for (CoreMap sentenceAnnotation:sentences) {</span>
<span class="nc" id="L536">        List&lt;CoreLabel&gt; sentenceTokens = sentenceAnnotation.get(CoreAnnotations.TokensAnnotation.class);</span>
<span class="nc" id="L537">        sentenceAnnotation.set(CoreAnnotations.CharacterOffsetBeginAnnotation.class,</span>
<span class="nc" id="L538">                sentenceTokens.get(0).get(CoreAnnotations.CharacterOffsetBeginAnnotation.class));</span>
<span class="nc" id="L539">        sentenceAnnotation.set(CoreAnnotations.CharacterOffsetEndAnnotation.class,</span>
<span class="nc" id="L540">                sentenceTokens.get(sentenceTokens.size()-1).get(CoreAnnotations.CharacterOffsetEndAnnotation.class));</span>
<span class="nc" id="L541">      }</span>

<span class="nc" id="L543">      return document;</span>
    }

    private static Tree getLowestCommonAncestor(Tree root, int startToken, int endToken)
    {
<span class="nc" id="L548">      Tree leftLeaf = Trees.getLeaf(root, startToken);</span>
<span class="nc" id="L549">      Tree rightLeaf = Trees.getLeaf(root, endToken);</span>
      // todo [cdm 2013]: It might be good to climb certain unaries here, like VP or S under NP, but it's not good to climb all unaries (e.g., NP under FRAG)
<span class="nc" id="L551">      return Trees.getLowestCommonAncestor(leftLeaf, rightLeaf, root);</span>
    }

    private static Tree getTreeNonTerminal(Tree root, int startToken, int endToken, boolean acceptPreTerminals)
    {
<span class="nc" id="L556">      Tree t = getLowestCommonAncestor(root, startToken, endToken);</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">      if (t.isLeaf()) {</span>
<span class="nc" id="L558">        t = t.parent(root);</span>
      }
<span class="nc bnc" id="L560" title="All 4 branches missed.">      if (!acceptPreTerminals &amp;&amp; t.isPreTerminal()) {</span>
<span class="nc" id="L561">        t = t.parent(root);</span>
      }
<span class="nc" id="L563">      return t;</span>
    }

    public void annotateDocument(Document document)
    {
<span class="nc" id="L568">      List&lt;CoreMap&gt; sentences = new ArrayList&lt;&gt;(document.sentenceWordLists.size());</span>
<span class="nc bnc" id="L569" title="All 2 branches missed.">      for (List&lt;String[]&gt; sentWords:document.sentenceWordLists) {</span>
<span class="nc" id="L570">        sentences.add(wordsToSentence(sentWords));</span>
<span class="nc" id="L571">      }</span>

<span class="nc" id="L573">      Annotation docAnnotation = sentencesToDocument(document.documentIdPart /*document.documentID + &quot;.&quot; + document.partNo */, sentences);</span>
<span class="nc" id="L574">      document.setAnnotation(docAnnotation);</span>

      // Do this here so we have updated character offsets and all
<span class="nc" id="L577">      CollectionValuedMap&lt;String, CoreMap&gt; corefChainMap = new CollectionValuedMap&lt;&gt;(CollectionFactory.&lt;CoreMap&gt;arrayListFactory());</span>
<span class="nc" id="L578">      List&lt;CoreMap&gt; nerChunks = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L579" title="All 2 branches missed.">      for (int i = 0; i &lt; sentences.size(); i++) {</span>
<span class="nc" id="L580">        CoreMap sentence = sentences.get(i);</span>
<span class="nc" id="L581">        Tree tree = sentence.get(TreeCoreAnnotations.TreeAnnotation.class);</span>
<span class="nc" id="L582">        tree.setSpans();</span>
<span class="nc" id="L583">        List&lt;String[]&gt; sentWords = document.sentenceWordLists.get(i);</span>

        // Get NER chunks
<span class="nc" id="L586">        List&lt;Triple&lt;Integer,Integer,String&gt;&gt; nerSpans = getNerSpans(sentWords);</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">        for (Triple&lt;Integer,Integer,String&gt; nerSpan:nerSpans) {</span>
<span class="nc" id="L588">          int startToken = nerSpan.first();</span>
<span class="nc" id="L589">          int endToken = nerSpan.second(); /* inclusive */</span>
<span class="nc" id="L590">          String label = nerSpan.third();</span>
<span class="nc" id="L591">          CoreMap nerChunk = ChunkAnnotationUtils.getAnnotatedChunk(sentence, startToken, endToken+1);</span>
<span class="nc" id="L592">          nerChunk.set(CoreAnnotations.NamedEntityTagAnnotation.class, label);</span>
<span class="nc" id="L593">          nerChunk.set(CoreAnnotations.SentenceIndexAnnotation.class, sentence.get(CoreAnnotations.SentenceIndexAnnotation.class));</span>
<span class="nc" id="L594">          nerChunks.add(nerChunk);</span>
<span class="nc" id="L595">          Tree t = getTreeNonTerminal(tree, startToken, endToken, true);</span>
<span class="nc bnc" id="L596" title="All 4 branches missed.">          if (t.getSpan().getSource() == startToken &amp;&amp; t.getSpan().getTarget() == endToken) {</span>
<span class="nc" id="L597">            nerChunk.set(TreeCoreAnnotations.TreeAnnotation.class, t);</span>
<span class="nc bnc" id="L598" title="All 2 branches missed.">            if (options.annotateTreeNer) {</span>
<span class="nc" id="L599">              Label tlabel = t.label();</span>
<span class="nc bnc" id="L600" title="All 2 branches missed.">              if (tlabel instanceof CoreLabel) {</span>
<span class="nc" id="L601">                ((CoreLabel) tlabel).set(NamedEntityAnnotation.class, nerChunk);</span>
              }
            }
          }
<span class="nc" id="L605">        }</span>

<span class="nc" id="L607">        List&lt;Triple&lt;Integer,Integer,String&gt;&gt; corefSpans = getCorefSpans(sentWords);</span>
<span class="nc bnc" id="L608" title="All 2 branches missed.">        for (Triple&lt;Integer,Integer,String&gt; corefSpan:corefSpans) {</span>
<span class="nc" id="L609">          int startToken = corefSpan.first();</span>
<span class="nc" id="L610">          int endToken = corefSpan.second(); /* inclusive */</span>
<span class="nc" id="L611">          String corefId = corefSpan.third();</span>
<span class="nc" id="L612">          CoreMap mention = ChunkAnnotationUtils.getAnnotatedChunk(sentence, startToken, endToken+1);</span>
<span class="nc" id="L613">          mention.set(CorefCoreAnnotations.CorefAnnotation.class, corefId);</span>
<span class="nc" id="L614">          mention.set(CoreAnnotations.SentenceIndexAnnotation.class, sentence.get(CoreAnnotations.SentenceIndexAnnotation.class));</span>
<span class="nc" id="L615">          corefChainMap.add(corefId, mention);</span>
<span class="nc" id="L616">          Tree t = getTreeNonTerminal(tree, startToken, endToken, true);</span>
<span class="nc" id="L617">          mention.set(TreeCoreAnnotations.TreeAnnotation.class, t);</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">          if (options.annotateTreeCoref) {</span>
<span class="nc" id="L619">            Label tlabel = t.label();</span>
<span class="nc bnc" id="L620" title="All 2 branches missed.">            if (tlabel instanceof CoreLabel) {</span>
<span class="nc" id="L621">              ((CoreLabel) tlabel).set(CorefMentionAnnotation.class, mention);</span>
            }
          }
<span class="nc" id="L624">        }</span>

      }
<span class="nc" id="L627">      document.corefChainMap = corefChainMap;</span>
<span class="nc" id="L628">      document.nerChunks = nerChunks;</span>
<span class="nc" id="L629">    }</span>

    private static final String docStart = &quot;#begin document &quot;;
<span class="nc" id="L632">    private static final int docStartLength = docStart.length();</span>

    public Document readNextDocument() {
      try {
<span class="nc" id="L636">        List&lt;String[]&gt; curSentWords = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L637">        Document document = null;</span>
<span class="nc bnc" id="L638" title="All 2 branches missed.">        for (String line; (line = br.readLine()) != null; ) {</span>
<span class="nc" id="L639">          lineCnt++;</span>
<span class="nc" id="L640">          line = line.trim();</span>
<span class="nc bnc" id="L641" title="All 2 branches missed.">          if (line.length() != 0) {</span>
<span class="nc bnc" id="L642" title="All 2 branches missed.">            if (line.startsWith(docStart)) {</span>
              // Start of new document
<span class="nc bnc" id="L644" title="All 2 branches missed.">              if (document != null) {</span>
<span class="nc" id="L645">                logger.warning(&quot;Unexpected begin document at line (\&quot; + filename + \&quot;,\&quot; + lineCnt + \&quot;)&quot;);</span>
              }
<span class="nc" id="L647">              document = new Document();</span>
<span class="nc" id="L648">              document.documentIdPart = line.substring(docStartLength);</span>
<span class="nc bnc" id="L649" title="All 2 branches missed.">            } else if (line.startsWith(&quot;#end document&quot;)) {</span>
<span class="nc" id="L650">              annotateDocument(document);</span>
<span class="nc" id="L651">              docCnt++;</span>
<span class="nc" id="L652">              return document;</span>
              // End of document
            } else {
<span class="nc bnc" id="L655" title="All 4 branches missed.">              assert document != null;</span>
<span class="nc" id="L656">              String[] fields = delimiterPattern.split(line);</span>
<span class="nc bnc" id="L657" title="All 2 branches missed.">              if (fields.length &lt; FIELDS_MIN) {</span>
<span class="nc" id="L658">                throw new RuntimeException(&quot;Unexpected number of field &quot; + fields.length +</span>
                        &quot;, expected &gt;= &quot; + FIELDS_MIN + &quot; for line (&quot; + filename + &quot;,&quot; + lineCnt + &quot;): &quot; + line);
              }
<span class="nc" id="L661">              String curDocId = fields[FIELD_DOC_ID];</span>
<span class="nc" id="L662">              String partNo = fields[FIELD_PART_NO];</span>
<span class="nc bnc" id="L663" title="All 2 branches missed.">              if (document.getDocumentID() == null) {</span>
<span class="nc" id="L664">                document.setDocumentID(curDocId);</span>
<span class="nc" id="L665">                document.setPartNo(partNo);</span>
              } else {
                // Check documentID didn't suddenly change on us
<span class="nc bnc" id="L668" title="All 4 branches missed.">                assert(document.getDocumentID().equals(curDocId));</span>
<span class="nc bnc" id="L669" title="All 4 branches missed.">                assert(document.getPartNo().equals(partNo));</span>
              }
<span class="nc" id="L671">              curSentWords.add(fields);</span>
<span class="nc" id="L672">            }</span>
          } else {
            // Current sentence has ended, new sentence is about to be started
<span class="nc bnc" id="L675" title="All 2 branches missed.">            if (curSentWords.size() &gt; 0) {</span>
<span class="nc bnc" id="L676" title="All 4 branches missed.">              assert document != null;</span>
<span class="nc" id="L677">              document.addSentence(curSentWords);</span>
<span class="nc" id="L678">              curSentWords = new ArrayList&lt;&gt;();</span>
            }
          }
        }
<span class="nc" id="L682">      } catch (IOException ex) {</span>
<span class="nc" id="L683">        throw new RuntimeIOException(ex);</span>
<span class="nc" id="L684">      }</span>
<span class="nc" id="L685">      return null;</span>
    }

    public void close() {
<span class="nc" id="L689">      IOUtils.closeIgnoringExceptions(br);</span>
<span class="nc" id="L690">    }</span>

  } // end static class DocumentIterator

  public static void usage()
  {
<span class="nc" id="L696">    log.info(&quot;java edu.stanford.nlp.dcoref.CoNLL2011DocumentReader [-ext &lt;extension to match&gt;] -i &lt;inputpath&gt; -o &lt;outputfile&gt;&quot;);</span>
<span class="nc" id="L697">  }</span>

  public static Pair&lt;Integer,Integer&gt; getMention(Integer index, String corefG, List&lt;CoreLabel&gt; sentenceAnno) {

<span class="nc" id="L701">    Integer i = -1;</span>
<span class="nc" id="L702">    Integer end = index;</span>
<span class="nc bnc" id="L703" title="All 2 branches missed.">    for (CoreLabel newAnno : sentenceAnno) {</span>
<span class="nc" id="L704">      i += 1;</span>
<span class="nc bnc" id="L705" title="All 2 branches missed.">      if (i &gt; index) {</span>
<span class="nc" id="L706">        String corefS = newAnno.get(CorefCoreAnnotations.CorefAnnotation.class);</span>
<span class="nc bnc" id="L707" title="All 2 branches missed.">        if (corefS != null) {</span>
<span class="nc" id="L708">          String[] allC = corefS.split(&quot;\\|&quot;);</span>
<span class="nc bnc" id="L709" title="All 2 branches missed.">          if (Arrays.asList(allC).contains(corefG)) {</span>
<span class="nc" id="L710">            end = i;</span>
          } else {
            break;
          }
        } else {
          break;
        }
      }
<span class="nc" id="L718">    }</span>
<span class="nc" id="L719">    return Pair.makePair(index, end);</span>
  }

  public static boolean include(Map&lt;Pair&lt;Integer,Integer&gt;,String&gt; sentenceInfo,
                                Pair&lt;Integer,Integer&gt; mention,
                                String corefG) {
<span class="nc" id="L725">    Set&lt;Pair&lt;Integer,Integer&gt;&gt; keys = sentenceInfo.keySet();</span>
<span class="nc bnc" id="L726" title="All 2 branches missed.">    for (Pair&lt;Integer, Integer&gt; key : keys) {</span>
<span class="nc" id="L727">      String corefS = sentenceInfo.get(key);</span>
<span class="nc bnc" id="L728" title="All 4 branches missed.">      if (corefS != null &amp;&amp; corefS.equals(corefG)) {</span>
<span class="nc bnc" id="L729" title="All 4 branches missed.">        if (key.first &lt; mention.first &amp;&amp; key.second.equals(mention.second)) {</span>
<span class="nc" id="L730">          return true;</span>
        }
      }
<span class="nc" id="L733">    }</span>
<span class="nc" id="L734">    return false;</span>
  }

  public static void writeTabSep(PrintWriter pw, CoreMap sentence, CollectionValuedMap&lt;String,CoreMap&gt; chainmap)
  {
<span class="nc" id="L739">    HeadFinder headFinder = new ModCollinsHeadFinder();</span>

<span class="nc" id="L741">    List&lt;CoreLabel&gt; sentenceAnno = sentence.get(CoreAnnotations.TokensAnnotation.class);</span>

<span class="nc" id="L743">    Tree sentenceTree = sentence.get(TreeCoreAnnotations.TreeAnnotation.class);</span>
<span class="nc" id="L744">    Map&lt;Pair&lt;Integer,Integer&gt;,String&gt; sentenceInfo = Generics.newHashMap();</span>

<span class="nc" id="L746">    Set&lt;Tree&gt; sentenceSubTrees = sentenceTree.subTrees();</span>
<span class="nc" id="L747">    sentenceTree.setSpans();</span>
<span class="nc" id="L748">    Map&lt;Pair&lt;Integer,Integer&gt;,Tree&gt; treeSpanMap = Generics.newHashMap();</span>
<span class="nc" id="L749">    Map&lt;Pair&lt;Integer,Integer&gt;,List&lt;Tree&gt;&gt; wordSpanMap = Generics.newHashMap();</span>

<span class="nc bnc" id="L751" title="All 2 branches missed.">    for (Tree ctree : sentenceSubTrees) {</span>
<span class="nc" id="L752">      IntPair span = ctree.getSpan();</span>
<span class="nc bnc" id="L753" title="All 2 branches missed.">      if (span != null) {</span>
<span class="nc" id="L754">        treeSpanMap.put(Pair.makePair(span.getSource(), span.getTarget()), ctree);</span>
<span class="nc" id="L755">        wordSpanMap.put(Pair.makePair(span.getSource(), span.getTarget()), ctree.getLeaves());</span>
      }
<span class="nc" id="L757">    }</span>

    String[][] finalSentence;
<span class="nc" id="L760">    finalSentence = new String [sentenceAnno.size()][];</span>
<span class="nc" id="L761">    Map&lt;Pair&lt;Integer,Integer&gt;,String&gt; allHeads = Generics.newHashMap();</span>

<span class="nc" id="L763">    int index = -1;</span>
<span class="nc bnc" id="L764" title="All 2 branches missed.">    for (CoreLabel newAnno : sentenceAnno) {</span>
<span class="nc" id="L765">      index += 1;</span>
<span class="nc" id="L766">      String word = newAnno.word();</span>
<span class="nc" id="L767">      String tag = newAnno.tag();</span>
<span class="nc" id="L768">      String cat = newAnno.ner();</span>
<span class="nc" id="L769">      String coref = newAnno.get(CorefCoreAnnotations.CorefAnnotation.class);</span>
<span class="nc" id="L770">      finalSentence[index] = new String[4];</span>
<span class="nc" id="L771">      finalSentence[index][0] = word;</span>
<span class="nc" id="L772">      finalSentence[index][1] = tag;</span>
<span class="nc" id="L773">      finalSentence[index][2] = cat;</span>
<span class="nc" id="L774">      finalSentence[index][3] = coref;</span>

<span class="nc bnc" id="L776" title="All 2 branches missed.">      if (coref == null) {</span>
<span class="nc" id="L777">        sentenceInfo.put(Pair.makePair(index, index), coref);</span>
<span class="nc" id="L778">        finalSentence[index][3] = &quot;O&quot;;</span>

      } else {
<span class="nc" id="L781">        String[] allC = coref.split(&quot;\\|&quot;);</span>
<span class="nc bnc" id="L782" title="All 2 branches missed.">        for (String corefG : allC) {</span>
<span class="nc" id="L783">          Pair&lt;Integer, Integer&gt; mention = getMention(index, corefG, sentenceAnno);</span>

<span class="nc bnc" id="L785" title="All 2 branches missed.">          if ( ! include(sentenceInfo, mention, corefG)) {</span>
            // find largest NP in mention
<span class="nc" id="L787">            sentenceInfo.put(mention, corefG);</span>
<span class="nc" id="L788">            Tree mentionTree = treeSpanMap.get(mention);</span>
<span class="nc" id="L789">            String head = null;</span>
<span class="nc bnc" id="L790" title="All 2 branches missed.">            if (mentionTree != null) {</span>
<span class="nc" id="L791">              head = mentionTree.headTerminal(headFinder).nodeString();</span>
<span class="nc bnc" id="L792" title="All 2 branches missed.">            } else if (mention.first.equals(mention.second)) {</span>
<span class="nc" id="L793">              head = word;</span>
            }
<span class="nc" id="L795">            allHeads.put(mention, head);</span>
          }
        }

<span class="nc bnc" id="L799" title="All 2 branches missed.">        if (allHeads.values().contains(word)) {</span>
<span class="nc" id="L800">          finalSentence[index][3] = &quot;MENTION&quot;;</span>
        } else {
<span class="nc" id="L802">          finalSentence[index][3] = &quot;O&quot;;</span>
        }
      }
<span class="nc" id="L805">    }</span>
<span class="nc bnc" id="L806" title="All 2 branches missed.">    for (int i=0;i&lt;finalSentence.length;i++){</span>
<span class="nc" id="L807">      String[] wordInfo = finalSentence[i];</span>
<span class="nc bnc" id="L808" title="All 2 branches missed.">      if (i&lt;finalSentence.length-1){</span>
<span class="nc" id="L809">        String[] nextWordInfo = finalSentence[i+1];</span>
<span class="nc bnc" id="L810" title="All 4 branches missed.">        if (nextWordInfo[3].equals(&quot;MENTION&quot;) &amp;&amp; nextWordInfo[0].equals(&quot;'s&quot;)){</span>
<span class="nc" id="L811">          wordInfo[3] = &quot;MENTION&quot;;</span>
<span class="nc" id="L812">          finalSentence[i+1][3] = &quot;O&quot;;</span>
        }
      }
<span class="nc" id="L815">      pw.println(wordInfo[0] + &quot;\t&quot; + wordInfo[1] + &quot;\t&quot; + wordInfo[2] + &quot;\t&quot; + wordInfo[3]);</span>
    }

<span class="nc" id="L818">    pw.println(&quot;&quot;);</span>

<span class="nc" id="L820">  }</span>

<span class="nc" id="L822">  public static class CorpusStats</span>
  {
<span class="nc" id="L824">    IntCounter&lt;String&gt; mentionTreeLabelCounter = new IntCounter&lt;&gt;();</span>
<span class="nc" id="L825">    IntCounter&lt;String&gt; mentionTreeNonPretermLabelCounter = new IntCounter&lt;&gt;();</span>
<span class="nc" id="L826">    IntCounter&lt;String&gt; mentionTreePretermNonPretermNoMatchLabelCounter = new IntCounter&lt;&gt;();</span>
<span class="nc" id="L827">    IntCounter&lt;String&gt; mentionTreeMixedLabelCounter = new IntCounter&lt;&gt;();</span>
<span class="nc" id="L828">    IntCounter&lt;Integer&gt; mentionTokenLengthCounter = new IntCounter&lt;&gt;();</span>
<span class="nc" id="L829">    IntCounter&lt;Integer&gt; nerMentionTokenLengthCounter = new IntCounter&lt;&gt;();</span>
<span class="nc" id="L830">    int mentionExactTreeSpan = 0;</span>
<span class="nc" id="L831">    int nonPretermSpanMatches = 0;</span>
<span class="nc" id="L832">    int totalMentions = 0;</span>
<span class="nc" id="L833">    int nestedNerMentions = 0;</span>
<span class="nc" id="L834">    int nerMentions = 0;</span>

    public void process(Document doc)
    {
<span class="nc" id="L838">      List&lt;CoreMap&gt; sentences = doc.getAnnotation().get(CoreAnnotations.SentencesAnnotation.class);</span>
<span class="nc bnc" id="L839" title="All 2 branches missed.">      for (String id:doc.corefChainMap.keySet()) {</span>
<span class="nc" id="L840">        Collection&lt;CoreMap&gt; mentions = doc.corefChainMap.get(id);</span>
<span class="nc bnc" id="L841" title="All 2 branches missed.">        for (CoreMap m:mentions) {</span>
<span class="nc" id="L842">          CoreMap sent = sentences.get(m.get(CoreAnnotations.SentenceIndexAnnotation.class));</span>
<span class="nc" id="L843">          Tree root = sent.get(TreeCoreAnnotations.TreeAnnotation.class);</span>
<span class="nc" id="L844">          Tree t = m.get(TreeCoreAnnotations.TreeAnnotation.class);</span>
<span class="nc" id="L845">          Tree npt = t;</span>
<span class="nc" id="L846">          Tree npt2 = t;</span>
<span class="nc bnc" id="L847" title="All 2 branches missed.">          if (npt.isPreTerminal()) {</span>
<span class="nc" id="L848">            npt = npt.parent(root);</span>
          }
<span class="nc" id="L850">          int sentTokenStart = sent.get(CoreAnnotations.TokenBeginAnnotation.class);</span>
<span class="nc" id="L851">          int tokenStart = m.get(CoreAnnotations.TokenBeginAnnotation.class) - sentTokenStart;</span>
<span class="nc" id="L852">          int tokenEnd = m.get(CoreAnnotations.TokenEndAnnotation.class) - sentTokenStart;</span>
<span class="nc" id="L853">          int length = tokenEnd - tokenStart;</span>
<span class="nc" id="L854">          mentionTokenLengthCounter.incrementCount(length);</span>
          // Check if exact span
<span class="nc" id="L856">          IntPair span = t.getSpan();</span>
<span class="nc bnc" id="L857" title="All 2 branches missed.">          if (span != null) {</span>
<span class="nc bnc" id="L858" title="All 4 branches missed.">            if (span.getSource() == tokenStart &amp;&amp; span.getTarget() == tokenEnd - 1) {</span>
<span class="nc" id="L859">              mentionExactTreeSpan++;</span>
            } else {
<span class="nc" id="L861">              logger.info(&quot;Tree span is &quot; + span + &quot;, tree node is &quot; + t);</span>
<span class="nc" id="L862">              logger.info(&quot;Mention span is &quot; + tokenStart + &quot; &quot; + (tokenEnd - 1) + &quot;, mention is &quot; + m);</span>
            }
          } else {
<span class="nc" id="L865">            logger.warning(&quot;No span for &quot; + t);</span>
          }
<span class="nc" id="L867">          IntPair nptSpan = npt.getSpan();</span>
<span class="nc bnc" id="L868" title="All 4 branches missed.">          if (nptSpan.getSource() == tokenStart &amp;&amp; nptSpan.getTarget() == tokenEnd - 1) {</span>
<span class="nc" id="L869">            nonPretermSpanMatches++;</span>
<span class="nc" id="L870">            npt2 = npt;</span>
          } else {
<span class="nc" id="L872">            mentionTreePretermNonPretermNoMatchLabelCounter.incrementCount(t.label().value());</span>
<span class="nc" id="L873">            logger.info(&quot;NPT: Tree span is &quot; + span + &quot;, tree node is &quot; + npt);</span>
<span class="nc" id="L874">            logger.info(&quot;NPT: Mention span is &quot; + tokenStart + &quot; &quot; + (tokenEnd - 1) + &quot;, mention is &quot; + m);</span>
<span class="nc" id="L875">            Label tlabel = t.label();</span>
<span class="nc bnc" id="L876" title="All 2 branches missed.">            if (tlabel instanceof CoreLabel) {</span>
<span class="nc" id="L877">              CoreMap mention = ((CoreLabel) tlabel).get(CorefMentionAnnotation.class);</span>
<span class="nc" id="L878">              String corefClusterId = mention.get(CorefCoreAnnotations.CorefAnnotation.class);</span>
<span class="nc" id="L879">              Collection&lt;CoreMap&gt; clusteredMentions = doc.corefChainMap.get(corefClusterId);</span>
<span class="nc bnc" id="L880" title="All 2 branches missed.">              for (CoreMap m2:clusteredMentions) {</span>
<span class="nc" id="L881">                logger.info(&quot;NPT: Clustered mention &quot; + m2.get(CoreAnnotations.TextAnnotation.class));</span>
<span class="nc" id="L882">              }</span>
            }

          }
<span class="nc" id="L886">          totalMentions++;</span>
<span class="nc" id="L887">          mentionTreeLabelCounter.incrementCount(t.label().value());</span>
<span class="nc" id="L888">          mentionTreeNonPretermLabelCounter.incrementCount(npt.label().value());</span>
<span class="nc" id="L889">          mentionTreeMixedLabelCounter.incrementCount(npt2.label().value());</span>
<span class="nc" id="L890">          Label tlabel = t.label();</span>
<span class="nc bnc" id="L891" title="All 2 branches missed.">          if (tlabel instanceof CoreLabel) {</span>
<span class="nc bnc" id="L892" title="All 2 branches missed.">            if (((CoreLabel) tlabel).containsKey(NamedEntityAnnotation.class)) {</span>
              // walk up tree
<span class="nc" id="L894">              nerMentions++;</span>
<span class="nc" id="L895">              nerMentionTokenLengthCounter.incrementCount(length);</span>

<span class="nc" id="L897">              Tree parent = t.parent(root);</span>
<span class="nc bnc" id="L898" title="All 2 branches missed.">              while (parent != null) {</span>
<span class="nc" id="L899">                Label plabel = parent.label();</span>
<span class="nc bnc" id="L900" title="All 2 branches missed.">                if (plabel instanceof CoreLabel) {</span>
<span class="nc bnc" id="L901" title="All 2 branches missed.">                  if (((CoreLabel) plabel).containsKey(NamedEntityAnnotation.class)) {</span>
<span class="nc" id="L902">                    logger.info(&quot;NER Mention: &quot; + m);</span>
<span class="nc" id="L903">                    CoreMap parentNerChunk = ((CoreLabel) plabel).get(NamedEntityAnnotation.class);</span>
<span class="nc" id="L904">                    logger.info(&quot;Nested inside NER Mention: &quot; + parentNerChunk);</span>
<span class="nc" id="L905">                    logger.info(&quot;Nested inside NER Mention parent node: &quot; + parent);</span>
<span class="nc" id="L906">                    nestedNerMentions++;</span>
<span class="nc" id="L907">                    break;</span>
                  }
                }
<span class="nc" id="L910">                parent = parent.parent(root);</span>
<span class="nc" id="L911">              }</span>
            }
          }
<span class="nc" id="L914">        }</span>
<span class="nc" id="L915">      }</span>
<span class="nc" id="L916">    }</span>

    private static void appendFrac(StringBuilder sb, String label, int num, int den)
    {
<span class="nc" id="L920">      double frac = ((double) num)/ den;</span>
<span class="nc" id="L921">      sb.append(label).append(&quot;\t&quot;).append(frac).append(&quot;\t(&quot;).append(num).append(&quot;/&quot;).append(den).append(&quot;)&quot;);</span>
<span class="nc" id="L922">    }</span>

    private static &lt;E&gt; void appendIntCountStats(StringBuilder sb, String label, IntCounter&lt;E&gt; counts)
    {
<span class="nc" id="L926">      sb.append(label).append(&quot;\n&quot;);</span>
<span class="nc" id="L927">      List&lt;E&gt; sortedKeys = Counters.toSortedList(counts);</span>
<span class="nc" id="L928">      int total = counts.totalIntCount();</span>
<span class="nc bnc" id="L929" title="All 2 branches missed.">      for (E key:sortedKeys) {</span>
<span class="nc" id="L930">        int count = counts.getIntCount(key);</span>
<span class="nc" id="L931">        appendFrac(sb, key.toString(), count, total);</span>
<span class="nc" id="L932">        sb.append(&quot;\n&quot;);</span>
<span class="nc" id="L933">      }</span>
<span class="nc" id="L934">    }</span>

    public String toString()
    {
<span class="nc" id="L938">      StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L939">      appendIntCountStats(sb, &quot;Mention Tree Labels (no preterminals)&quot;, mentionTreeNonPretermLabelCounter);</span>
<span class="nc" id="L940">      sb.append(&quot;\n&quot;);</span>
<span class="nc" id="L941">      appendIntCountStats(sb, &quot;Mention Tree Labels (with preterminals)&quot;, mentionTreeLabelCounter);</span>
<span class="nc" id="L942">      sb.append(&quot;\n&quot;);</span>
<span class="nc" id="L943">      appendIntCountStats(sb, &quot;Mention Tree Labels (preterminals with parent span not match)&quot;, mentionTreePretermNonPretermNoMatchLabelCounter);</span>
<span class="nc" id="L944">      sb.append(&quot;\n&quot;);</span>
<span class="nc" id="L945">      appendIntCountStats(sb, &quot;Mention Tree Labels (mixed)&quot;, mentionTreeMixedLabelCounter);</span>
<span class="nc" id="L946">      sb.append(&quot;\n&quot;);</span>
<span class="nc" id="L947">      appendIntCountStats(sb, &quot;Mention Lengths&quot;, mentionTokenLengthCounter);</span>
<span class="nc" id="L948">      sb.append(&quot;\n&quot;);</span>
<span class="nc" id="L949">      appendFrac(sb, &quot;Mention Exact Non Preterm Tree Span&quot;, nonPretermSpanMatches, totalMentions);</span>
<span class="nc" id="L950">      sb.append(&quot;\n&quot;);</span>
<span class="nc" id="L951">      appendFrac(sb, &quot;Mention Exact Tree Span&quot;, mentionExactTreeSpan, totalMentions);</span>
<span class="nc" id="L952">      sb.append(&quot;\n&quot;);</span>
<span class="nc" id="L953">      appendFrac(sb, &quot;NER&quot;, nerMentions, totalMentions);</span>
<span class="nc" id="L954">      sb.append(&quot;\n&quot;);</span>
<span class="nc" id="L955">      appendFrac(sb, &quot;Nested NER&quot;, nestedNerMentions, totalMentions);</span>
<span class="nc" id="L956">      sb.append(&quot;\n&quot;);</span>
<span class="nc" id="L957">      appendIntCountStats(sb, &quot;NER Mention Lengths&quot;, nerMentionTokenLengthCounter);</span>
<span class="nc" id="L958">      return sb.toString();</span>
    }

  }

  /** Reads and dumps output, mainly for debugging. */
  public static void main(String[] args) throws IOException {
<span class="nc" id="L965">    Properties props = StringUtils.argsToProperties(args);</span>
<span class="nc" id="L966">    boolean debug = Boolean.parseBoolean(props.getProperty(&quot;debug&quot;, &quot;false&quot;));</span>
<span class="nc" id="L967">    String filepath = props.getProperty(&quot;i&quot;);</span>
<span class="nc" id="L968">    String outfile = props.getProperty(&quot;o&quot;);</span>
<span class="nc bnc" id="L969" title="All 4 branches missed.">    if (filepath == null || outfile == null) {</span>
<span class="nc" id="L970">      usage();</span>
<span class="nc" id="L971">      System.exit(-1);</span>
    }
<span class="nc" id="L973">    PrintWriter fout = new PrintWriter(outfile);</span>
<span class="nc" id="L974">    logger.info(&quot;Writing to &quot; + outfile);</span>
<span class="nc" id="L975">    String ext = props.getProperty(&quot;ext&quot;);</span>
    Options options;
<span class="nc bnc" id="L977" title="All 2 branches missed.">    if (ext != null) {</span>
<span class="nc" id="L978">      options = new Options(&quot;.*&quot; + ext + &quot;$&quot;);</span>
    } else {
<span class="nc" id="L980">      options = new Options();</span>
    }
<span class="nc" id="L982">    options.annotateTreeCoref = true;</span>
<span class="nc" id="L983">    options.annotateTreeNer = true;</span>
<span class="nc" id="L984">    CorpusStats corpusStats = new CorpusStats();</span>
<span class="nc" id="L985">    CoNLL2011DocumentReader reader = new CoNLL2011DocumentReader(filepath, options);</span>
<span class="nc" id="L986">    int docCnt = 0;</span>
<span class="nc" id="L987">    int sentCnt = 0;</span>
<span class="nc" id="L988">    int tokenCnt = 0;</span>
<span class="nc bnc" id="L989" title="All 2 branches missed.">    for (Document doc; (doc = reader.getNextDocument()) != null; ) {</span>
<span class="nc" id="L990">      corpusStats.process(doc);</span>
<span class="nc" id="L991">      docCnt++;</span>
<span class="nc" id="L992">      Annotation anno = doc.getAnnotation();</span>
<span class="nc bnc" id="L993" title="All 2 branches missed.">      if (debug) System.out.println(&quot;Document &quot; + docCnt + &quot;: &quot; + anno.get(CoreAnnotations.DocIDAnnotation.class));</span>
<span class="nc bnc" id="L994" title="All 2 branches missed.">      for (CoreMap sentence:anno.get(CoreAnnotations.SentencesAnnotation.class)) {</span>
<span class="nc bnc" id="L995" title="All 2 branches missed.">        if (debug) System.out.println(&quot;Parse: &quot; + sentence.get(TreeCoreAnnotations.TreeAnnotation.class));</span>
<span class="nc bnc" id="L996" title="All 2 branches missed.">        if (debug) System.out.println(&quot;Sentence Tokens: &quot; + StringUtils.join(sentence.get(CoreAnnotations.TokensAnnotation.class), &quot;,&quot;));</span>
<span class="nc" id="L997">        writeTabSep(fout,sentence,doc.corefChainMap);</span>
<span class="nc" id="L998">        sentCnt++;</span>
<span class="nc" id="L999">        tokenCnt += sentence.get(CoreAnnotations.TokensAnnotation.class).size();</span>
<span class="nc" id="L1000">      }</span>
<span class="nc bnc" id="L1001" title="All 2 branches missed.">      if (debug) {</span>
<span class="nc bnc" id="L1002" title="All 2 branches missed.">        for (CoreMap ner:doc.nerChunks) {</span>
<span class="nc" id="L1003">          System.out.println(&quot;NER Chunk: &quot; + ner);</span>
<span class="nc" id="L1004">        }</span>
<span class="nc bnc" id="L1005" title="All 2 branches missed.">        for (String id:doc.corefChainMap.keySet()) {</span>
<span class="nc" id="L1006">          System.out.println(&quot;Coref: &quot; + id + &quot; = &quot; + StringUtils.join(doc.corefChainMap.get(id), &quot;;&quot;));</span>
<span class="nc" id="L1007">        }</span>
      }
<span class="nc" id="L1009">    }</span>
<span class="nc" id="L1010">    fout.close();</span>
<span class="nc" id="L1011">    System.out.println(&quot;Total document count: &quot; + docCnt);</span>
<span class="nc" id="L1012">    System.out.println(&quot;Total sentence count: &quot; + sentCnt);</span>
<span class="nc" id="L1013">    System.out.println(&quot;Total token count: &quot; + tokenCnt);</span>
<span class="nc" id="L1014">    System.out.println(corpusStats);</span>
<span class="nc" id="L1015">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>