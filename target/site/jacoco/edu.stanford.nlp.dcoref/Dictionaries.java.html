<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Dictionaries.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.dcoref</a> &gt; <span class="el_source">Dictionaries.java</span></div><h1>Dictionaries.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.dcoref;

import java.io.BufferedReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Properties;
import java.util.Set;

import edu.stanford.nlp.io.IOUtils;
import edu.stanford.nlp.io.RuntimeIOException;
import edu.stanford.nlp.pipeline.DefaultPaths;
import edu.stanford.nlp.stats.ClassicCounter;
import edu.stanford.nlp.stats.Counter;
import edu.stanford.nlp.util.Generics;
import edu.stanford.nlp.util.Pair;
import edu.stanford.nlp.util.PropertiesUtils;

/** Provides accessors for various grammatical, semantic, and world knowledge
 *  lexicons and word lists primarily used by the Sieve coreference system,
 *  but sometimes also drawn on from other code.
 *
 *  The source of the dictionaries on Stanford NLP machines is
 *  /u/nlp/data/coref/gazetteers/dcoref/ . In models jars, they live in
 *  edu/stanford/nlp/models/dcoref .
 */
public class Dictionaries {

<span class="nc" id="L33">  public enum MentionType {</span>
<span class="nc" id="L34">    PRONOMINAL(1), NOMINAL(3), PROPER(4), LIST(2);</span>

    /**
     * A higher representativeness means that this type of mention is more preferred for choosing
     * the representative mention. See {@link Mention#moreRepresentativeThan(Mention)}.
     */
    public final int representativeness;
<span class="nc" id="L41">    MentionType(int representativeness) { this.representativeness = representativeness; }</span>
  }

<span class="nc" id="L44">  public enum Gender { MALE, FEMALE, NEUTRAL, UNKNOWN }</span>

<span class="nc" id="L46">  public enum Number { SINGULAR, PLURAL, UNKNOWN }</span>
<span class="nc" id="L47">  public enum Animacy { ANIMATE, INANIMATE, UNKNOWN }</span>
<span class="nc" id="L48">  public enum Person { I, YOU, HE, SHE, WE, THEY, IT, UNKNOWN}</span>

<span class="nc" id="L50">  public final Set&lt;String&gt; reportVerb = Generics.newHashSet(Arrays.asList(</span>
      &quot;accuse&quot;, &quot;acknowledge&quot;, &quot;add&quot;, &quot;admit&quot;, &quot;advise&quot;, &quot;agree&quot;, &quot;alert&quot;,
      &quot;allege&quot;, &quot;announce&quot;, &quot;answer&quot;, &quot;apologize&quot;, &quot;argue&quot;,
      &quot;ask&quot;, &quot;assert&quot;, &quot;assure&quot;, &quot;beg&quot;, &quot;blame&quot;, &quot;boast&quot;,
      &quot;caution&quot;, &quot;charge&quot;, &quot;cite&quot;, &quot;claim&quot;, &quot;clarify&quot;, &quot;command&quot;, &quot;comment&quot;,
      &quot;compare&quot;, &quot;complain&quot;, &quot;concede&quot;, &quot;conclude&quot;, &quot;confirm&quot;, &quot;confront&quot;, &quot;congratulate&quot;,
      &quot;contend&quot;, &quot;contradict&quot;, &quot;convey&quot;, &quot;counter&quot;, &quot;criticize&quot;,
      &quot;debate&quot;, &quot;decide&quot;, &quot;declare&quot;, &quot;defend&quot;, &quot;demand&quot;, &quot;demonstrate&quot;, &quot;deny&quot;,
      &quot;describe&quot;, &quot;determine&quot;, &quot;disagree&quot;, &quot;disclose&quot;, &quot;discount&quot;, &quot;discover&quot;, &quot;discuss&quot;,
      &quot;dismiss&quot;, &quot;dispute&quot;, &quot;disregard&quot;, &quot;doubt&quot;, &quot;emphasize&quot;, &quot;encourage&quot;, &quot;endorse&quot;,
      &quot;equate&quot;, &quot;estimate&quot;, &quot;expect&quot;, &quot;explain&quot;, &quot;express&quot;, &quot;extoll&quot;, &quot;fear&quot;, &quot;feel&quot;,
      &quot;find&quot;, &quot;forbid&quot;, &quot;forecast&quot;, &quot;foretell&quot;, &quot;forget&quot;, &quot;gather&quot;, &quot;guarantee&quot;, &quot;guess&quot;,
      &quot;hear&quot;, &quot;hint&quot;, &quot;hope&quot;, &quot;illustrate&quot;, &quot;imagine&quot;, &quot;imply&quot;, &quot;indicate&quot;, &quot;inform&quot;,
      &quot;insert&quot;, &quot;insist&quot;, &quot;instruct&quot;, &quot;interpret&quot;, &quot;interview&quot;, &quot;invite&quot;, &quot;issue&quot;,
      &quot;justify&quot;, &quot;learn&quot;, &quot;maintain&quot;, &quot;mean&quot;, &quot;mention&quot;, &quot;negotiate&quot;, &quot;note&quot;,
      &quot;observe&quot;, &quot;offer&quot;, &quot;oppose&quot;, &quot;order&quot;, &quot;persuade&quot;, &quot;pledge&quot;, &quot;point&quot;, &quot;point out&quot;,
      &quot;praise&quot;, &quot;pray&quot;, &quot;predict&quot;, &quot;prefer&quot;, &quot;present&quot;, &quot;promise&quot;, &quot;prompt&quot;, &quot;propose&quot;,
      &quot;protest&quot;, &quot;prove&quot;, &quot;provoke&quot;, &quot;question&quot;, &quot;quote&quot;, &quot;raise&quot;, &quot;rally&quot;, &quot;read&quot;,
      &quot;reaffirm&quot;, &quot;realise&quot;, &quot;realize&quot;, &quot;rebut&quot;, &quot;recall&quot;, &quot;reckon&quot;, &quot;recommend&quot;, &quot;refer&quot;,
      &quot;reflect&quot;, &quot;refuse&quot;, &quot;refute&quot;, &quot;reiterate&quot;, &quot;reject&quot;, &quot;relate&quot;, &quot;remark&quot;,
      &quot;remember&quot;, &quot;remind&quot;, &quot;repeat&quot;, &quot;reply&quot;, &quot;report&quot;, &quot;request&quot;, &quot;respond&quot;,
      &quot;restate&quot;, &quot;reveal&quot;, &quot;rule&quot;, &quot;say&quot;, &quot;see&quot;, &quot;show&quot;, &quot;signal&quot;, &quot;sing&quot;,
      &quot;slam&quot;, &quot;speculate&quot;, &quot;spoke&quot;, &quot;spread&quot;, &quot;state&quot;, &quot;stipulate&quot;, &quot;stress&quot;,
      &quot;suggest&quot;, &quot;support&quot;, &quot;suppose&quot;, &quot;surmise&quot;, &quot;suspect&quot;, &quot;swear&quot;, &quot;teach&quot;,
      &quot;tell&quot;, &quot;testify&quot;, &quot;think&quot;, &quot;threaten&quot;, &quot;told&quot;, &quot;uncover&quot;, &quot;underline&quot;,
      &quot;underscore&quot;, &quot;urge&quot;, &quot;voice&quot;, &quot;vow&quot;, &quot;warn&quot;, &quot;welcome&quot;,
      &quot;wish&quot;, &quot;wonder&quot;, &quot;worry&quot;, &quot;write&quot;));

<span class="nc" id="L78">  public final Set&lt;String&gt; reportNoun = Generics.newHashSet(Arrays.asList(</span>
      &quot;acclamation&quot;, &quot;account&quot;, &quot;accusation&quot;, &quot;acknowledgment&quot;, &quot;address&quot;, &quot;addressing&quot;,
      &quot;admission&quot;, &quot;advertisement&quot;, &quot;advice&quot;, &quot;advisory&quot;, &quot;affidavit&quot;, &quot;affirmation&quot;, &quot;alert&quot;,
      &quot;allegation&quot;, &quot;analysis&quot;, &quot;anecdote&quot;, &quot;annotation&quot;, &quot;announcement&quot;, &quot;answer&quot;, &quot;antiphon&quot;,
      &quot;apology&quot;, &quot;applause&quot;, &quot;appreciation&quot;, &quot;argument&quot;, &quot;arraignment&quot;, &quot;article&quot;, &quot;articulation&quot;,
      &quot;aside&quot;, &quot;assertion&quot;, &quot;asseveration&quot;, &quot;assurance&quot;, &quot;attestation&quot;, &quot;attitude&quot;,
      &quot;averment&quot;, &quot;avouchment&quot;, &quot;avowal&quot;, &quot;axiom&quot;, &quot;backcap&quot;, &quot;band-aid&quot;, &quot;basic&quot;, &quot;belief&quot;, &quot;bestowal&quot;,
      &quot;bill&quot;, &quot;blame&quot;, &quot;blow-by-blow&quot;, &quot;bomb&quot;, &quot;book&quot;, &quot;bow&quot;, &quot;break&quot;, &quot;breakdown&quot;, &quot;brief&quot;, &quot;briefing&quot;,
      &quot;broadcast&quot;, &quot;broadcasting&quot;, &quot;bulletin&quot;, &quot;buzz&quot;, &quot;cable&quot;, &quot;calendar&quot;, &quot;call&quot;, &quot;canard&quot;, &quot;canon&quot;,
      &quot;card&quot;, &quot;cause&quot;, &quot;censure&quot;, &quot;certification&quot;, &quot;characterization&quot;, &quot;charge&quot;, &quot;chat&quot;, &quot;chatter&quot;,
      &quot;chitchat&quot;, &quot;chronicle&quot;, &quot;chronology&quot;, &quot;citation&quot;, &quot;claim&quot;, &quot;clarification&quot;, &quot;close&quot;, &quot;cognizance&quot;,
      &quot;comeback&quot;, &quot;comment&quot;, &quot;commentary&quot;, &quot;communication&quot;, &quot;communique&quot;, &quot;composition&quot;, &quot;concept&quot;,
      &quot;concession&quot;, &quot;conference&quot;, &quot;confession&quot;, &quot;confirmation&quot;, &quot;conjecture&quot;, &quot;connotation&quot;, &quot;construal&quot;,
      &quot;construction&quot;, &quot;consultation&quot;, &quot;contention&quot;, &quot;contract&quot;, &quot;convention&quot;, &quot;conversation&quot;, &quot;converse&quot;,
      &quot;conviction&quot;, &quot;counterclaim&quot;, &quot;credenda&quot;, &quot;creed&quot;, &quot;critique&quot;,
      &quot;cry&quot;, &quot;declaration&quot;, &quot;defense&quot;, &quot;definition&quot;, &quot;delineation&quot;, &quot;delivery&quot;, &quot;demonstration&quot;,
      &quot;denial&quot;, &quot;denotation&quot;, &quot;depiction&quot;, &quot;deposition&quot;, &quot;description&quot;, &quot;detail&quot;, &quot;details&quot;, &quot;detention&quot;,
      &quot;dialogue&quot;, &quot;diction&quot;, &quot;dictum&quot;, &quot;digest&quot;, &quot;directive&quot;, &quot;disclosure&quot;, &quot;discourse&quot;, &quot;discovery&quot;,
      &quot;discussion&quot;, &quot;dispatch&quot;, &quot;display&quot;, &quot;disquisition&quot;, &quot;dissemination&quot;, &quot;dissertation&quot;, &quot;divulgence&quot;,
      &quot;dogma&quot;, &quot;editorial&quot;, &quot;ejaculation&quot;, &quot;emphasis&quot;, &quot;enlightenment&quot;,
      &quot;enunciation&quot;, &quot;essay&quot;, &quot;evidence&quot;, &quot;examination&quot;, &quot;example&quot;, &quot;excerpt&quot;, &quot;exclamation&quot;,
      &quot;excuse&quot;, &quot;execution&quot;, &quot;exegesis&quot;, &quot;explanation&quot;, &quot;explication&quot;, &quot;exposing&quot;, &quot;exposition&quot;, &quot;expounding&quot;,
      &quot;expression&quot;, &quot;eye-opener&quot;, &quot;feedback&quot;, &quot;fiction&quot;, &quot;findings&quot;, &quot;fingerprint&quot;, &quot;flash&quot;, &quot;formulation&quot;,
      &quot;fundamental&quot;, &quot;gift&quot;, &quot;gloss&quot;, &quot;goods&quot;, &quot;gospel&quot;, &quot;gossip&quot;, &quot;gratitude&quot;, &quot;greeting&quot;,
      &quot;guarantee&quot;, &quot;hail&quot;, &quot;hailing&quot;, &quot;handout&quot;, &quot;hash&quot;, &quot;headlines&quot;, &quot;hearing&quot;, &quot;hearsay&quot;,
      &quot;ideas&quot;, &quot;idiom&quot;, &quot;illustration&quot;, &quot;impeachment&quot;, &quot;implantation&quot;, &quot;implication&quot;, &quot;imputation&quot;,
      &quot;incrimination&quot;, &quot;indication&quot;, &quot;indoctrination&quot;, &quot;inference&quot;, &quot;info&quot;, &quot;information&quot;,
      &quot;innuendo&quot;, &quot;insinuation&quot;, &quot;insistence&quot;, &quot;instruction&quot;, &quot;intelligence&quot;, &quot;interpretation&quot;, &quot;interview&quot;,
      &quot;intimation&quot;, &quot;intonation&quot;, &quot;issue&quot;, &quot;item&quot;, &quot;itemization&quot;, &quot;justification&quot;, &quot;key&quot;, &quot;knowledge&quot;,
      &quot;leak&quot;, &quot;letter&quot;, &quot;locution&quot;, &quot;manifesto&quot;,
      &quot;meaning&quot;, &quot;meeting&quot;, &quot;mention&quot;, &quot;message&quot;, &quot;missive&quot;, &quot;mitigation&quot;, &quot;monograph&quot;, &quot;motive&quot;, &quot;murmur&quot;,
      &quot;narration&quot;, &quot;narrative&quot;, &quot;news&quot;, &quot;nod&quot;, &quot;note&quot;, &quot;notice&quot;, &quot;notification&quot;, &quot;oath&quot;, &quot;observation&quot;,
      &quot;okay&quot;, &quot;opinion&quot;, &quot;oral&quot;, &quot;outline&quot;, &quot;paper&quot;, &quot;parley&quot;, &quot;particularization&quot;, &quot;phrase&quot;, &quot;phraseology&quot;,
      &quot;phrasing&quot;, &quot;picture&quot;, &quot;piece&quot;, &quot;pipeline&quot;, &quot;pitch&quot;, &quot;plea&quot;, &quot;plot&quot;, &quot;portraiture&quot;, &quot;portrayal&quot;,
      &quot;position&quot;, &quot;potboiler&quot;, &quot;prating&quot;, &quot;precept&quot;, &quot;prediction&quot;, &quot;presentation&quot;, &quot;presentment&quot;, &quot;principle&quot;,
      &quot;proclamation&quot;, &quot;profession&quot;, &quot;program&quot;, &quot;promulgation&quot;, &quot;pronouncement&quot;, &quot;pronunciation&quot;, &quot;propaganda&quot;,
      &quot;prophecy&quot;, &quot;proposal&quot;, &quot;proposition&quot;, &quot;prosecution&quot;, &quot;protestation&quot;, &quot;publication&quot;, &quot;publicity&quot;,
      &quot;publishing&quot;, &quot;quotation&quot;, &quot;ratification&quot;, &quot;reaction&quot;, &quot;reason&quot;, &quot;rebuttal&quot;, &quot;receipt&quot;, &quot;recital&quot;,
      &quot;recitation&quot;, &quot;recognition&quot;, &quot;record&quot;, &quot;recount&quot;, &quot;recountal&quot;, &quot;refutation&quot;, &quot;regulation&quot;, &quot;rehearsal&quot;,
      &quot;rejoinder&quot;, &quot;relation&quot;, &quot;release&quot;, &quot;remark&quot;, &quot;rendition&quot;, &quot;repartee&quot;, &quot;reply&quot;, &quot;report&quot;, &quot;reporting&quot;,
      &quot;representation&quot;, &quot;resolution&quot;, &quot;response&quot;, &quot;result&quot;, &quot;retort&quot;, &quot;return&quot;, &quot;revelation&quot;, &quot;review&quot;,
      &quot;rule&quot;, &quot;rumble&quot;, &quot;rumor&quot;, &quot;rundown&quot;, &quot;saying&quot;, &quot;scandal&quot;, &quot;scoop&quot;,
      &quot;scuttlebutt&quot;, &quot;sense&quot;, &quot;showing&quot;, &quot;sign&quot;, &quot;signature&quot;, &quot;significance&quot;, &quot;sketch&quot;, &quot;skinny&quot;, &quot;solution&quot;,
      &quot;speaking&quot;, &quot;specification&quot;, &quot;speech&quot;, &quot;statement&quot;, &quot;story&quot;, &quot;study&quot;, &quot;style&quot;, &quot;suggestion&quot;,
      &quot;summarization&quot;, &quot;summary&quot;, &quot;summons&quot;, &quot;tale&quot;, &quot;talk&quot;, &quot;talking&quot;, &quot;tattle&quot;, &quot;telecast&quot;,
      &quot;telegram&quot;, &quot;telling&quot;, &quot;tenet&quot;, &quot;term&quot;, &quot;testimonial&quot;, &quot;testimony&quot;, &quot;text&quot;, &quot;theme&quot;, &quot;thesis&quot;,
      &quot;tract&quot;, &quot;tractate&quot;, &quot;tradition&quot;, &quot;translation&quot;, &quot;treatise&quot;, &quot;utterance&quot;, &quot;vent&quot;, &quot;ventilation&quot;,
      &quot;verbalization&quot;, &quot;version&quot;, &quot;vignette&quot;, &quot;vindication&quot;, &quot;warning&quot;,
      &quot;warrant&quot;, &quot;whispering&quot;, &quot;wire&quot;, &quot;word&quot;, &quot;work&quot;, &quot;writ&quot;, &quot;write-up&quot;, &quot;writeup&quot;, &quot;writing&quot;,
      &quot;acceptance&quot;, &quot;complaint&quot;, &quot;concern&quot;, &quot;disappointment&quot;, &quot;disclose&quot;, &quot;estimate&quot;, &quot;laugh&quot;, &quot;pleasure&quot;, &quot;regret&quot;,
      &quot;resentment&quot;, &quot;view&quot;));

<span class="nc" id="L130">  public final Set&lt;String&gt; nonWords = Generics.newHashSet(Arrays.asList(&quot;mm&quot;, &quot;hmm&quot;, &quot;ahem&quot;, &quot;um&quot;));</span>
<span class="nc" id="L131">  public final Set&lt;String&gt; copulas = Generics.newHashSet(Arrays.asList(&quot;is&quot;,&quot;are&quot;,&quot;were&quot;, &quot;was&quot;,&quot;be&quot;, &quot;been&quot;,&quot;become&quot;,&quot;became&quot;,&quot;becomes&quot;,&quot;seem&quot;,&quot;seemed&quot;,&quot;seems&quot;,&quot;remain&quot;,&quot;remains&quot;,&quot;remained&quot;));</span>
<span class="nc" id="L132">  public final Set&lt;String&gt; quantifiers = Generics.newHashSet(Arrays.asList(&quot;not&quot;,&quot;every&quot;,&quot;any&quot;,&quot;none&quot;,&quot;everything&quot;,&quot;anything&quot;,&quot;nothing&quot;,&quot;all&quot;,&quot;enough&quot;));</span>
<span class="nc" id="L133">  public final Set&lt;String&gt; parts = Generics.newHashSet(Arrays.asList(&quot;half&quot;,&quot;one&quot;,&quot;two&quot;,&quot;three&quot;,&quot;four&quot;,&quot;five&quot;,&quot;six&quot;,&quot;seven&quot;,&quot;eight&quot;,&quot;nine&quot;,&quot;ten&quot;,&quot;hundred&quot;,&quot;thousand&quot;,&quot;million&quot;,&quot;billion&quot;,&quot;tens&quot;,&quot;dozens&quot;,&quot;hundreds&quot;,&quot;thousands&quot;,&quot;millions&quot;,&quot;billions&quot;,&quot;group&quot;,&quot;groups&quot;,&quot;bunch&quot;,&quot;number&quot;,&quot;numbers&quot;,&quot;pinch&quot;,&quot;amount&quot;,&quot;amount&quot;,&quot;total&quot;,&quot;all&quot;,&quot;mile&quot;,&quot;miles&quot;,&quot;pounds&quot;));</span>
<span class="nc" id="L134">  public final Set&lt;String&gt; temporals = Generics.newHashSet(Arrays.asList(</span>
      &quot;second&quot;, &quot;minute&quot;, &quot;hour&quot;, &quot;day&quot;, &quot;week&quot;, &quot;month&quot;, &quot;year&quot;, &quot;decade&quot;, &quot;century&quot;, &quot;millennium&quot;,
      &quot;monday&quot;, &quot;tuesday&quot;, &quot;wednesday&quot;, &quot;thursday&quot;, &quot;friday&quot;, &quot;saturday&quot;, &quot;sunday&quot;, &quot;now&quot;,
      &quot;yesterday&quot;, &quot;tomorrow&quot;, &quot;age&quot;, &quot;time&quot;, &quot;era&quot;, &quot;epoch&quot;, &quot;morning&quot;, &quot;evening&quot;, &quot;day&quot;, &quot;night&quot;, &quot;noon&quot;, &quot;afternoon&quot;,
      &quot;semester&quot;, &quot;trimester&quot;, &quot;quarter&quot;, &quot;term&quot;, &quot;winter&quot;, &quot;spring&quot;, &quot;summer&quot;, &quot;fall&quot;, &quot;autumn&quot;, &quot;season&quot;,
      &quot;january&quot;, &quot;february&quot;, &quot;march&quot;, &quot;april&quot;, &quot;may&quot;, &quot;june&quot;, &quot;july&quot;, &quot;august&quot;, &quot;september&quot;, &quot;october&quot;, &quot;november&quot;, &quot;december&quot;));


<span class="nc" id="L142">  public final Set&lt;String&gt; femalePronouns = Generics.newHashSet(Arrays.asList(new String[]{ &quot;her&quot;, &quot;hers&quot;, &quot;herself&quot;, &quot;she&quot; }));</span>
<span class="nc" id="L143">  public final Set&lt;String&gt; malePronouns = Generics.newHashSet(Arrays.asList(new String[]{ &quot;he&quot;, &quot;him&quot;, &quot;himself&quot;, &quot;his&quot; }));</span>
<span class="nc" id="L144">  public final Set&lt;String&gt; neutralPronouns = Generics.newHashSet(Arrays.asList(new String[]{ &quot;it&quot;, &quot;its&quot;, &quot;itself&quot;, &quot;where&quot;, &quot;here&quot;, &quot;there&quot;, &quot;which&quot; }));</span>
<span class="nc" id="L145">  public final Set&lt;String&gt; possessivePronouns = Generics.newHashSet(Arrays.asList(new String[]{ &quot;my&quot;, &quot;your&quot;, &quot;his&quot;, &quot;her&quot;, &quot;its&quot;,&quot;our&quot;,&quot;their&quot;,&quot;whose&quot; }));</span>
<span class="nc" id="L146">  public final Set&lt;String&gt; otherPronouns = Generics.newHashSet(Arrays.asList(new String[]{ &quot;who&quot;, &quot;whom&quot;, &quot;whose&quot;, &quot;where&quot;, &quot;when&quot;,&quot;which&quot; }));</span>
<span class="nc" id="L147">  public final Set&lt;String&gt; thirdPersonPronouns = Generics.newHashSet(Arrays.asList(new String[]{ &quot;he&quot;, &quot;him&quot;, &quot;himself&quot;, &quot;his&quot;, &quot;she&quot;, &quot;her&quot;, &quot;herself&quot;, &quot;hers&quot;, &quot;her&quot;, &quot;it&quot;, &quot;itself&quot;, &quot;its&quot;, &quot;one&quot;, &quot;oneself&quot;, &quot;one's&quot;, &quot;they&quot;, &quot;them&quot;, &quot;themself&quot;, &quot;themselves&quot;, &quot;theirs&quot;, &quot;their&quot;, &quot;they&quot;, &quot;them&quot;, &quot;'em&quot;, &quot;themselves&quot; }));</span>
<span class="nc" id="L148">  public final Set&lt;String&gt; secondPersonPronouns = Generics.newHashSet(Arrays.asList(new String[]{ &quot;you&quot;, &quot;yourself&quot;, &quot;yours&quot;, &quot;your&quot;, &quot;yourselves&quot; }));</span>
<span class="nc" id="L149">  public final Set&lt;String&gt; firstPersonPronouns = Generics.newHashSet(Arrays.asList(new String[]{ &quot;i&quot;, &quot;me&quot;, &quot;myself&quot;, &quot;mine&quot;, &quot;my&quot;, &quot;we&quot;, &quot;us&quot;, &quot;ourself&quot;, &quot;ourselves&quot;, &quot;ours&quot;, &quot;our&quot; }));</span>
<span class="nc" id="L150">  public final Set&lt;String&gt; moneyPercentNumberPronouns = Generics.newHashSet(Arrays.asList(new String[]{ &quot;it&quot;, &quot;its&quot; }));</span>
<span class="nc" id="L151">  public final Set&lt;String&gt; dateTimePronouns = Generics.newHashSet(Arrays.asList(new String[]{ &quot;when&quot; }));</span>
<span class="nc" id="L152">  public final Set&lt;String&gt; organizationPronouns = Generics.newHashSet(Arrays.asList(new String[]{ &quot;it&quot;, &quot;its&quot;, &quot;they&quot;, &quot;their&quot;, &quot;them&quot;, &quot;which&quot;}));</span>
<span class="nc" id="L153">  public final Set&lt;String&gt; locationPronouns = Generics.newHashSet(Arrays.asList(new String[]{ &quot;it&quot;, &quot;its&quot;, &quot;where&quot;, &quot;here&quot;, &quot;there&quot; }));</span>
<span class="nc" id="L154">  public final Set&lt;String&gt; inanimatePronouns = Generics.newHashSet(Arrays.asList(new String[]{ &quot;it&quot;, &quot;itself&quot;, &quot;its&quot;, &quot;where&quot;, &quot;when&quot; }));</span>
<span class="nc" id="L155">  public final Set&lt;String&gt; animatePronouns = Generics.newHashSet(Arrays.asList(new String[]{ &quot;i&quot;, &quot;me&quot;, &quot;myself&quot;, &quot;mine&quot;, &quot;my&quot;, &quot;we&quot;, &quot;us&quot;, &quot;ourself&quot;, &quot;ourselves&quot;, &quot;ours&quot;, &quot;our&quot;, &quot;you&quot;, &quot;yourself&quot;, &quot;yours&quot;, &quot;your&quot;, &quot;yourselves&quot;, &quot;he&quot;, &quot;him&quot;, &quot;himself&quot;, &quot;his&quot;, &quot;she&quot;, &quot;her&quot;, &quot;herself&quot;, &quot;hers&quot;, &quot;her&quot;, &quot;one&quot;, &quot;oneself&quot;, &quot;one's&quot;, &quot;they&quot;, &quot;them&quot;, &quot;themself&quot;, &quot;themselves&quot;, &quot;theirs&quot;, &quot;their&quot;, &quot;they&quot;, &quot;them&quot;, &quot;'em&quot;, &quot;themselves&quot;, &quot;who&quot;, &quot;whom&quot;, &quot;whose&quot; }));</span>
<span class="nc" id="L156">  public final Set&lt;String&gt; indefinitePronouns = Generics.newHashSet(Arrays.asList(new String[]{&quot;another&quot;, &quot;anybody&quot;, &quot;anyone&quot;, &quot;anything&quot;, &quot;each&quot;, &quot;either&quot;, &quot;enough&quot;, &quot;everybody&quot;, &quot;everyone&quot;, &quot;everything&quot;, &quot;less&quot;, &quot;little&quot;, &quot;much&quot;, &quot;neither&quot;, &quot;no one&quot;, &quot;nobody&quot;, &quot;nothing&quot;, &quot;one&quot;, &quot;other&quot;, &quot;plenty&quot;, &quot;somebody&quot;, &quot;someone&quot;, &quot;something&quot;, &quot;both&quot;, &quot;few&quot;, &quot;fewer&quot;, &quot;many&quot;, &quot;others&quot;, &quot;several&quot;, &quot;all&quot;, &quot;any&quot;, &quot;more&quot;, &quot;most&quot;, &quot;none&quot;, &quot;some&quot;, &quot;such&quot;}));</span>
<span class="nc" id="L157">  public final Set&lt;String&gt; relativePronouns = Generics.newHashSet(Arrays.asList(new String[]{&quot;that&quot;,&quot;who&quot;,&quot;which&quot;,&quot;whom&quot;,&quot;where&quot;,&quot;whose&quot;}));</span>
<span class="nc" id="L158">  public final Set&lt;String&gt; GPEPronouns = Generics.newHashSet(Arrays.asList(new String[]{ &quot;it&quot;, &quot;itself&quot;, &quot;its&quot;, &quot;they&quot;,&quot;where&quot; }));</span>
<span class="nc" id="L159">  public final Set&lt;String&gt; pluralPronouns = Generics.newHashSet(Arrays.asList(new String[]{ &quot;we&quot;, &quot;us&quot;, &quot;ourself&quot;, &quot;ourselves&quot;, &quot;ours&quot;, &quot;our&quot;, &quot;yourself&quot;, &quot;yourselves&quot;, &quot;they&quot;, &quot;them&quot;, &quot;themself&quot;, &quot;themselves&quot;, &quot;theirs&quot;, &quot;their&quot; }));</span>
<span class="nc" id="L160">  public final Set&lt;String&gt; singularPronouns = Generics.newHashSet(Arrays.asList(new String[]{ &quot;i&quot;, &quot;me&quot;, &quot;myself&quot;, &quot;mine&quot;, &quot;my&quot;, &quot;yourself&quot;, &quot;he&quot;, &quot;him&quot;, &quot;himself&quot;, &quot;his&quot;, &quot;she&quot;, &quot;her&quot;, &quot;herself&quot;, &quot;hers&quot;, &quot;her&quot;, &quot;it&quot;, &quot;itself&quot;, &quot;its&quot;, &quot;one&quot;, &quot;oneself&quot;, &quot;one's&quot; }));</span>
<span class="nc" id="L161">  public final Set&lt;String&gt; facilityVehicleWeaponPronouns = Generics.newHashSet(Arrays.asList(new String[]{ &quot;it&quot;, &quot;itself&quot;, &quot;its&quot;, &quot;they&quot;, &quot;where&quot; }));</span>
<span class="nc" id="L162">  public final Set&lt;String&gt; miscPronouns = Generics.newHashSet(Arrays.asList(new String[]{&quot;it&quot;, &quot;itself&quot;, &quot;its&quot;, &quot;they&quot;, &quot;where&quot; }));</span>
<span class="nc" id="L163">  public final Set&lt;String&gt; reflexivePronouns = Generics.newHashSet(Arrays.asList(new String[]{&quot;myself&quot;, &quot;yourself&quot;, &quot;yourselves&quot;, &quot;himself&quot;, &quot;herself&quot;, &quot;itself&quot;, &quot;ourselves&quot;, &quot;themselves&quot;, &quot;oneself&quot;}));</span>
<span class="nc" id="L164">  public final Set&lt;String&gt; transparentNouns = Generics.newHashSet(Arrays.asList(new String[]{&quot;bunch&quot;, &quot;group&quot;,</span>
      &quot;breed&quot;, &quot;class&quot;, &quot;ilk&quot;, &quot;kind&quot;, &quot;half&quot;, &quot;segment&quot;, &quot;top&quot;, &quot;bottom&quot;, &quot;glass&quot;, &quot;bottle&quot;,
      &quot;box&quot;, &quot;cup&quot;, &quot;gem&quot;, &quot;idiot&quot;, &quot;unit&quot;, &quot;part&quot;, &quot;stage&quot;, &quot;name&quot;, &quot;division&quot;, &quot;label&quot;, &quot;group&quot;, &quot;figure&quot;,
      &quot;series&quot;, &quot;member&quot;, &quot;members&quot;, &quot;first&quot;, &quot;version&quot;, &quot;site&quot;, &quot;side&quot;, &quot;role&quot;, &quot;largest&quot;, &quot;title&quot;, &quot;fourth&quot;,
      &quot;third&quot;, &quot;second&quot;, &quot;number&quot;, &quot;place&quot;, &quot;trio&quot;, &quot;two&quot;, &quot;one&quot;, &quot;longest&quot;, &quot;highest&quot;, &quot;shortest&quot;,
      &quot;head&quot;, &quot;resident&quot;, &quot;collection&quot;, &quot;result&quot;, &quot;last&quot;
  }));
<span class="nc" id="L171">  public final Set&lt;String&gt; stopWords = Generics.newHashSet(Arrays.asList(new String[]{&quot;a&quot;, &quot;an&quot;, &quot;the&quot;, &quot;of&quot;, &quot;at&quot;,</span>
      &quot;on&quot;, &quot;upon&quot;, &quot;in&quot;, &quot;to&quot;, &quot;from&quot;, &quot;out&quot;, &quot;as&quot;, &quot;so&quot;, &quot;such&quot;, &quot;or&quot;, &quot;and&quot;, &quot;those&quot;, &quot;this&quot;, &quot;these&quot;, &quot;that&quot;,
      &quot;for&quot;, &quot;,&quot;, &quot;is&quot;, &quot;was&quot;, &quot;am&quot;, &quot;are&quot;, &quot;'s&quot;, &quot;been&quot;, &quot;were&quot;}));

<span class="nc" id="L175">  public final Set&lt;String&gt; notOrganizationPRP = Generics.newHashSet(Arrays.asList(new String[]{&quot;i&quot;, &quot;me&quot;, &quot;myself&quot;,</span>
      &quot;mine&quot;, &quot;my&quot;, &quot;yourself&quot;, &quot;he&quot;, &quot;him&quot;, &quot;himself&quot;, &quot;his&quot;, &quot;she&quot;, &quot;her&quot;, &quot;herself&quot;, &quot;hers&quot;, &quot;here&quot;}));

<span class="nc" id="L178">  public final Set&lt;String&gt; quantifiers2 = Generics.newHashSet(Arrays.asList(&quot;all&quot;, &quot;both&quot;, &quot;neither&quot;, &quot;either&quot;));</span>
<span class="nc" id="L179">  public final Set&lt;String&gt; determiners = Generics.newHashSet(Arrays.asList(&quot;the&quot;, &quot;this&quot;, &quot;that&quot;, &quot;these&quot;, &quot;those&quot;, &quot;his&quot;, &quot;her&quot;, &quot;my&quot;, &quot;your&quot;, &quot;their&quot;, &quot;our&quot;));</span>
<span class="nc" id="L180">  public final Set&lt;String&gt; negations = Generics.newHashSet(Arrays.asList(&quot;n't&quot;,&quot;not&quot;, &quot;nor&quot;, &quot;neither&quot;, &quot;never&quot;, &quot;no&quot;, &quot;non&quot;, &quot;any&quot;, &quot;none&quot;, &quot;nobody&quot;, &quot;nothing&quot;, &quot;nowhere&quot;, &quot;nearly&quot;,&quot;almost&quot;,</span>
      &quot;if&quot;, &quot;false&quot;, &quot;fallacy&quot;, &quot;unsuccessfully&quot;, &quot;unlikely&quot;, &quot;impossible&quot;, &quot;improbable&quot;, &quot;uncertain&quot;, &quot;unsure&quot;, &quot;impossibility&quot;, &quot;improbability&quot;, &quot;cancellation&quot;, &quot;breakup&quot;, &quot;lack&quot;,
      &quot;long-stalled&quot;, &quot;end&quot;, &quot;rejection&quot;, &quot;failure&quot;, &quot;avoid&quot;, &quot;bar&quot;, &quot;block&quot;, &quot;break&quot;, &quot;cancel&quot;, &quot;cease&quot;, &quot;cut&quot;, &quot;decline&quot;, &quot;deny&quot;, &quot;deprive&quot;, &quot;destroy&quot;, &quot;excuse&quot;,
      &quot;fail&quot;, &quot;forbid&quot;, &quot;forestall&quot;, &quot;forget&quot;, &quot;halt&quot;, &quot;lose&quot;, &quot;nullify&quot;, &quot;prevent&quot;, &quot;refrain&quot;, &quot;reject&quot;, &quot;rebut&quot;, &quot;remain&quot;, &quot;refuse&quot;, &quot;stop&quot;, &quot;suspend&quot;, &quot;ward&quot;));
<span class="nc" id="L184">  public final Set&lt;String&gt; neg_relations = Generics.newHashSet(Arrays.asList(&quot;nmod:without&quot;, &quot;acl:without&quot;, &quot;advcl:without&quot;,</span>
      &quot;nmod:except&quot;, &quot;acl:except&quot;, &quot;advcl:except&quot;, &quot;nmod:excluding&quot;, &quot;acl:excluding&quot;, &quot;advcl:excluding&quot;, &quot;nmod:if&quot;, &quot;acl:if&quot;,
      &quot;advcl:if&quot;, &quot;nmod:whether&quot;, &quot;acl:whether&quot;, &quot;advcl:whether&quot;,  &quot;nmod:away_from&quot;, &quot;acl:away_from&quot;, &quot;advcl:away_fom&quot;,
      &quot;nmod:instead_of&quot;, &quot;acl:instead_of&quot;, &quot;advcl:instead_of&quot;));
<span class="nc" id="L188">  public final Set&lt;String&gt; modals = Generics.newHashSet(Arrays.asList(&quot;can&quot;, &quot;could&quot;, &quot;may&quot;, &quot;might&quot;, &quot;must&quot;, &quot;should&quot;, &quot;would&quot;, &quot;seem&quot;,</span>
      &quot;able&quot;, &quot;apparently&quot;, &quot;necessarily&quot;, &quot;presumably&quot;, &quot;probably&quot;, &quot;possibly&quot;, &quot;reportedly&quot;, &quot;supposedly&quot;,
      &quot;inconceivable&quot;, &quot;chance&quot;, &quot;impossibility&quot;, &quot;improbability&quot;, &quot;encouragement&quot;, &quot;improbable&quot;, &quot;impossible&quot;,
      &quot;likely&quot;, &quot;necessary&quot;, &quot;probable&quot;, &quot;possible&quot;, &quot;uncertain&quot;, &quot;unlikely&quot;, &quot;unsure&quot;, &quot;likelihood&quot;, &quot;probability&quot;,
      &quot;possibility&quot;, &quot;eventual&quot;, &quot;hypothetical&quot; , &quot;presumed&quot;, &quot;supposed&quot;, &quot;reported&quot;, &quot;apparent&quot;));

<span class="nc" id="L194">  public final Set&lt;String&gt; personPronouns = Generics.newHashSet();</span>
<span class="nc" id="L195">  public final Set&lt;String&gt; allPronouns = Generics.newHashSet();</span>

<span class="nc" id="L197">  public final Map&lt;String, String&gt; statesAbbreviation = Generics.newHashMap();</span>
<span class="nc" id="L198">  private final Map&lt;String, Set&lt;String&gt;&gt; demonyms = Generics.newHashMap();</span>
<span class="nc" id="L199">  public final Set&lt;String&gt; demonymSet = Generics.newHashSet();</span>
<span class="nc" id="L200">  private final Set&lt;String&gt; adjectiveNation = Generics.newHashSet();</span>

<span class="nc" id="L202">  public final Set&lt;String&gt; countries = Generics.newHashSet();</span>
<span class="nc" id="L203">  public final Set&lt;String&gt; statesAndProvinces = Generics.newHashSet();</span>

<span class="nc" id="L205">  public final Set&lt;String&gt; neutralWords = Generics.newHashSet();</span>
<span class="nc" id="L206">  public final Set&lt;String&gt; femaleWords = Generics.newHashSet();</span>
<span class="nc" id="L207">  public final Set&lt;String&gt; maleWords = Generics.newHashSet();</span>

<span class="nc" id="L209">  public final Set&lt;String&gt; pluralWords = Generics.newHashSet();</span>
<span class="nc" id="L210">  public final Set&lt;String&gt; singularWords = Generics.newHashSet();</span>

<span class="nc" id="L212">  public final Set&lt;String&gt; inanimateWords = Generics.newHashSet();</span>
<span class="nc" id="L213">  public final Set&lt;String&gt; animateWords = Generics.newHashSet();</span>

<span class="nc" id="L215">  public final Map&lt;List&lt;String&gt;, Gender&gt; genderNumber = Generics.newHashMap();</span>

<span class="nc" id="L217">  public final ArrayList&lt;Counter&lt;Pair&lt;String, String&gt;&gt;&gt; corefDict = new ArrayList&lt;&gt;(4);</span>
<span class="nc" id="L218">  public final Counter&lt;Pair&lt;String, String&gt;&gt; corefDictPMI = new ClassicCounter&lt;&gt;();</span>
<span class="nc" id="L219">  public final Map&lt;String,Counter&lt;String&gt;&gt; NE_signatures = Generics.newHashMap();</span>

  private void setPronouns() {
<span class="nc bnc" id="L222" title="All 2 branches missed.">    for(String s: animatePronouns){</span>
<span class="nc" id="L223">      personPronouns.add(s);</span>
<span class="nc" id="L224">    }</span>

<span class="nc" id="L226">    allPronouns.addAll(firstPersonPronouns);</span>
<span class="nc" id="L227">    allPronouns.addAll(secondPersonPronouns);</span>
<span class="nc" id="L228">    allPronouns.addAll(thirdPersonPronouns);</span>
<span class="nc" id="L229">    allPronouns.addAll(otherPronouns);</span>

<span class="nc" id="L231">    stopWords.addAll(allPronouns);</span>
<span class="nc" id="L232">  }</span>

  /** The format of each line of this file is
   *     fullStateName ( TAB  abbrev )*
   *  The file is cased and checked cased.
   *  The result is: statesAbbreviation is a hash from each abbrev to the fullStateName.
   */
  public void loadStateAbbreviation(String statesFile) {
<span class="nc" id="L240">    BufferedReader reader = null;</span>
    try {
<span class="nc" id="L242">      reader = IOUtils.readerFromString(statesFile);</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">      for (String line; (line = reader.readLine()) != null; ) {</span>
<span class="nc" id="L244">        String[] tokens = line.split(&quot;\t&quot;);</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">        for (String token : tokens) {</span>
<span class="nc" id="L246">          statesAbbreviation.put(token, tokens[0]);</span>
        }
<span class="nc" id="L248">      }</span>
<span class="nc" id="L249">    } catch (IOException e) {</span>
<span class="nc" id="L250">      throw new RuntimeIOException(e);</span>
    } finally {
<span class="nc" id="L252">      IOUtils.closeIgnoringExceptions(reader);</span>
<span class="nc" id="L253">    }</span>
<span class="nc" id="L254">  }</span>

  /** If the input string is an abbreviation of a U.S. state name
   *  or the canonical name, the canonical name is returned.
   *  Otherwise, null is returned.
   *
   *  @param name Is treated as a cased string. ME != me
   */
  public String lookupCanonicalAmericanStateName(String name) {
<span class="nc" id="L263">    return statesAbbreviation.get(name);</span>
  }

  /** The format of the demonyms file is
   *     countryCityOrState ( TAB demonym )*
   *  Lines starting with # are ignored
   *  The file is cased but stored in in-memory data structures uncased.
   *  The results are:
   *  demonyms is a hash from each country (etc.) to a set of demonymic Strings;
   *  adjectiveNation is a set of demonymic Strings;
   *  demonymSet has all country (etc.) names and all demonymic Strings.
   */
  private void loadDemonymLists(String demonymFile) {
<span class="nc" id="L276">    BufferedReader reader = null;</span>
    try {
<span class="nc" id="L278">      reader = IOUtils.readerFromString(demonymFile);</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">      for (String line; (line = reader.readLine()) != null; ) {</span>
<span class="nc" id="L280">        line = line.toLowerCase(Locale.ENGLISH);</span>
<span class="nc" id="L281">        String[] tokens = line.split(&quot;\t&quot;);</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">        if (tokens[0].startsWith(&quot;#&quot;)) continue;</span>
<span class="nc" id="L283">        Set&lt;String&gt; set = Generics.newHashSet();</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">        for (String s : tokens) {</span>
<span class="nc" id="L285">          set.add(s);</span>
<span class="nc" id="L286">          demonymSet.add(s);</span>
        }
<span class="nc" id="L288">        demonyms.put(tokens[0], set);</span>
<span class="nc" id="L289">      }</span>
<span class="nc" id="L290">      adjectiveNation.addAll(demonymSet);</span>
<span class="nc" id="L291">      adjectiveNation.removeAll(demonyms.keySet());</span>
<span class="nc" id="L292">    } catch (IOException e) {</span>
<span class="nc" id="L293">      throw new RuntimeIOException(e);</span>
    } finally {
<span class="nc" id="L295">      IOUtils.closeIgnoringExceptions(reader);</span>
<span class="nc" id="L296">    }</span>
<span class="nc" id="L297">  }</span>

  /** Returns a set of demonyms for a country (or city or region).
   *  @param name Some string perhaps a country name like &quot;Australia&quot;
   *  @return A Set of demonym Strings, perhaps { &quot;Australian&quot;, &quot;Aussie&quot;, &quot;Aussies&quot; }.
   *     If none are known (including if the argument isn't a country/region name,
   *     then the empty set will be returned.
   */
  public Set&lt;String&gt; getDemonyms(String name) {
<span class="nc" id="L306">    Set&lt;String&gt; result = demonyms.get(name);</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">    if (result == null) {</span>
<span class="nc" id="L308">      result = Collections.emptySet();</span>
    }
<span class="nc" id="L310">    return result;</span>
  }

  /** Returns whether this mention (possibly multi-word) is the
   *  adjectival form of a demonym, like &quot;African&quot; or &quot;Iraqi&quot;.
   *  True if it is an adjectival form, even if also a name for a
   *  person of that country (such as &quot;Iraqi&quot;).
   */
  public boolean isAdjectivalDemonym(String token) {
<span class="nc" id="L319">    return adjectiveNation.contains(token.toLowerCase(Locale.ENGLISH));</span>
  }

  private static void getWordsFromFile(String filename, Set&lt;String&gt; resultSet, boolean lowercase) throws IOException {
<span class="nc bnc" id="L323" title="All 2 branches missed.">    if(filename==null) {</span>
<span class="nc" id="L324">      return ;</span>
    }
<span class="nc" id="L326">    BufferedReader reader = IOUtils.readerFromString(filename);</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">    while(reader.ready()) {</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">      if(lowercase) resultSet.add(reader.readLine().toLowerCase());</span>
<span class="nc" id="L329">      else resultSet.add(reader.readLine());</span>
    }
<span class="nc" id="L331">    IOUtils.closeIgnoringExceptions(reader);</span>
<span class="nc" id="L332">  }</span>

  private void loadAnimacyLists(String animateWordsFile, String inanimateWordsFile) {
    try {
<span class="nc" id="L336">      getWordsFromFile(animateWordsFile, animateWords, false);</span>
<span class="nc" id="L337">      getWordsFromFile(inanimateWordsFile, inanimateWords, false);</span>
<span class="nc" id="L338">    } catch (IOException e) {</span>
<span class="nc" id="L339">      throw new RuntimeIOException(e);</span>
<span class="nc" id="L340">    }</span>
<span class="nc" id="L341">  }</span>

  private void loadGenderLists(String maleWordsFile, String neutralWordsFile, String femaleWordsFile) {
    try {
<span class="nc" id="L345">      getWordsFromFile(maleWordsFile, maleWords, false);</span>
<span class="nc" id="L346">      getWordsFromFile(neutralWordsFile, neutralWords, false);</span>
<span class="nc" id="L347">      getWordsFromFile(femaleWordsFile, femaleWords, false);</span>
<span class="nc" id="L348">    } catch (IOException e) {</span>
<span class="nc" id="L349">      throw new RuntimeIOException(e);</span>
<span class="nc" id="L350">    }</span>
<span class="nc" id="L351">  }</span>

  private void loadNumberLists(String pluralWordsFile, String singularWordsFile) {
    try {
<span class="nc" id="L355">      getWordsFromFile(pluralWordsFile, pluralWords, false);</span>
<span class="nc" id="L356">      getWordsFromFile(singularWordsFile, singularWords, false);</span>
<span class="nc" id="L357">    } catch (IOException e) {</span>
<span class="nc" id="L358">      throw new RuntimeIOException(e);</span>
<span class="nc" id="L359">    }</span>
<span class="nc" id="L360">  }</span>
  private void loadStatesLists(String file) {
    try {
<span class="nc" id="L363">      getWordsFromFile(file, statesAndProvinces, true);</span>
<span class="nc" id="L364">    } catch (IOException e) {</span>
<span class="nc" id="L365">      throw new RuntimeIOException(e);</span>
<span class="nc" id="L366">    }</span>
<span class="nc" id="L367">  }</span>

  private void loadCountriesLists(String file) {
    try{
<span class="nc" id="L371">      BufferedReader reader = IOUtils.readerFromString(file);</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">      for (String line; (line = reader.readLine()) != null; ) {</span>
<span class="nc" id="L373">        countries.add(line.split(&quot;\t&quot;)[1].toLowerCase());</span>
      }
<span class="nc" id="L375">      reader.close();</span>
<span class="nc" id="L376">    } catch (IOException e) {</span>
<span class="nc" id="L377">      throw new RuntimeIOException(e);</span>
<span class="nc" id="L378">    }</span>
<span class="nc" id="L379">  }</span>

  /**
   * Load Bergsma and Lin (2006) gender and number list.
   * &lt;br&gt;
   * The list is converted from raw text and numbers to a serialized
   * map, which saves quite a bit of time loading.
   * See edu.stanford.nlp.dcoref.util.ConvertGenderFile
   */
  private void loadGenderNumber(String file, String neutralWordsFile) {
    try {
<span class="nc" id="L390">      getWordsFromFile(neutralWordsFile, neutralWords, false);</span>
<span class="nc" id="L391">    } catch (IOException e) {</span>
<span class="nc" id="L392">      throw new RuntimeIOException(&quot;Couldn't load &quot; + neutralWordsFile);</span>
<span class="nc" id="L393">    }</span>
    try {
<span class="nc" id="L395">      Map&lt;List&lt;String&gt;, Gender&gt; temp = IOUtils.readObjectFromURLOrClasspathOrFileSystem(file);</span>
<span class="nc" id="L396">      genderNumber.putAll(temp);</span>
<span class="nc" id="L397">    } catch (IOException | ClassNotFoundException e) {</span>
<span class="nc" id="L398">      throw new RuntimeIOException(&quot;Couldn't load &quot; + file);</span>
<span class="nc" id="L399">    }</span>
<span class="nc" id="L400">  }</span>

  private static void loadCorefDict(String[] file,
      ArrayList&lt;Counter&lt;Pair&lt;String, String&gt;&gt;&gt; dict) {

<span class="nc bnc" id="L405" title="All 2 branches missed.">    for(int i = 0; i &lt; 4; i++){</span>
<span class="nc" id="L406">      dict.add(new ClassicCounter&lt;&gt;());</span>

<span class="nc" id="L408">      BufferedReader reader = null;</span>
      try {
<span class="nc" id="L410">        reader = IOUtils.readerFromString(file[i]);</span>
        // Skip the first line (header)
<span class="nc" id="L412">        reader.readLine();</span>

<span class="nc bnc" id="L414" title="All 2 branches missed.">        while(reader.ready()) {</span>
<span class="nc" id="L415">          String[] split = reader.readLine().split(&quot;\t&quot;);</span>
<span class="nc" id="L416">          dict.get(i).setCount(new Pair&lt;&gt;(split[0], split[1]), Double.parseDouble(split[2]));</span>
<span class="nc" id="L417">        }</span>

<span class="nc" id="L419">      } catch (IOException e) {</span>
<span class="nc" id="L420">        throw new RuntimeException(e);</span>
      } finally {
<span class="nc" id="L422">        IOUtils.closeIgnoringExceptions(reader);</span>
<span class="nc" id="L423">      }</span>
    }
<span class="nc" id="L425">  }</span>

  private static void loadCorefDictPMI(String file, Counter&lt;Pair&lt;String, String&gt;&gt; dict) {

<span class="nc" id="L429">      BufferedReader reader = null;</span>
      try {
<span class="nc" id="L431">        reader = IOUtils.readerFromString(file);</span>
        // Skip the first line (header)
<span class="nc" id="L433">        reader.readLine();</span>

<span class="nc bnc" id="L435" title="All 2 branches missed.">        while(reader.ready()) {</span>
<span class="nc" id="L436">          String[] split = reader.readLine().split(&quot;\t&quot;);</span>
<span class="nc" id="L437">          dict.setCount(new Pair&lt;&gt;(split[0], split[1]), Double.parseDouble(split[3]));</span>
<span class="nc" id="L438">        }</span>

<span class="nc" id="L440">      } catch (IOException e) {</span>
<span class="nc" id="L441">        throw new RuntimeException(e);</span>
      } finally {
<span class="nc" id="L443">        IOUtils.closeIgnoringExceptions(reader);</span>
<span class="nc" id="L444">      }</span>
<span class="nc" id="L445">  }</span>

  private static void loadSignatures(String file, Map&lt;String,Counter&lt;String&gt;&gt; sigs) {
<span class="nc" id="L448">    BufferedReader reader = null;</span>
    try {
<span class="nc" id="L450">      reader = IOUtils.readerFromString(file);</span>

<span class="nc bnc" id="L452" title="All 2 branches missed.">      while(reader.ready()) {</span>
<span class="nc" id="L453">        String[] split = reader.readLine().split(&quot;\t&quot;);</span>
<span class="nc" id="L454">        Counter&lt;String&gt; cntr = new ClassicCounter&lt;&gt;();</span>
<span class="nc" id="L455">        sigs.put(split[0], cntr);</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">        for (int i = 1; i &lt; split.length; i=i+2) {</span>
<span class="nc" id="L457">          cntr.setCount(split[i], Double.parseDouble(split[i+1]));</span>
        }
<span class="nc" id="L459">      }</span>
<span class="nc" id="L460">    } catch (IOException e) {</span>
<span class="nc" id="L461">      throw new RuntimeException(e);</span>
    } finally {
<span class="nc" id="L463">      IOUtils.closeIgnoringExceptions(reader);</span>
<span class="nc" id="L464">    }</span>
<span class="nc" id="L465">  }</span>

  public Dictionaries(Properties props) {
<span class="nc" id="L468">    this(props.getProperty(Constants.DEMONYM_PROP, DefaultPaths.DEFAULT_DCOREF_DEMONYM),</span>
<span class="nc" id="L469">        props.getProperty(Constants.ANIMATE_PROP, DefaultPaths.DEFAULT_DCOREF_ANIMATE),</span>
<span class="nc" id="L470">        props.getProperty(Constants.INANIMATE_PROP, DefaultPaths.DEFAULT_DCOREF_INANIMATE),</span>
<span class="nc" id="L471">        props.getProperty(Constants.MALE_PROP),</span>
<span class="nc" id="L472">        props.getProperty(Constants.NEUTRAL_PROP),</span>
<span class="nc" id="L473">        props.getProperty(Constants.FEMALE_PROP),</span>
<span class="nc" id="L474">        props.getProperty(Constants.PLURAL_PROP),</span>
<span class="nc" id="L475">        props.getProperty(Constants.SINGULAR_PROP),</span>
<span class="nc" id="L476">        props.getProperty(Constants.STATES_PROP, DefaultPaths.DEFAULT_DCOREF_STATES),</span>
<span class="nc" id="L477">        props.getProperty(Constants.GENDER_NUMBER_PROP, DefaultPaths.DEFAULT_DCOREF_GENDER_NUMBER),</span>
<span class="nc" id="L478">        props.getProperty(Constants.COUNTRIES_PROP, DefaultPaths.DEFAULT_DCOREF_COUNTRIES),</span>
<span class="nc" id="L479">        props.getProperty(Constants.STATES_PROVINCES_PROP, DefaultPaths.DEFAULT_DCOREF_STATES_AND_PROVINCES),</span>
<span class="nc" id="L480">        props.getProperty(Constants.SIEVES_PROP, Constants.SIEVEPASSES).contains(&quot;CorefDictionaryMatch&quot;),</span>
<span class="nc" id="L481">        PropertiesUtils.getStringArray(props, Constants.DICT_LIST_PROP,</span>
                                       new String[]{DefaultPaths.DEFAULT_DCOREF_DICT1, DefaultPaths.DEFAULT_DCOREF_DICT2,
                                                    DefaultPaths.DEFAULT_DCOREF_DICT3, DefaultPaths.DEFAULT_DCOREF_DICT4}),
<span class="nc" id="L484">        props.getProperty(Constants.DICT_PMI_PROP, DefaultPaths.DEFAULT_DCOREF_DICT1),</span>
<span class="nc" id="L485">        props.getProperty(Constants.SIGNATURES_PROP, DefaultPaths.DEFAULT_DCOREF_NE_SIGNATURES));</span>
<span class="nc" id="L486">  }</span>

  public static String signature(Properties props) {
<span class="nc" id="L489">    StringBuilder os = new StringBuilder();</span>
<span class="nc" id="L490">    os.append(Constants.DEMONYM_PROP + &quot;:&quot; +</span>
<span class="nc" id="L491">            props.getProperty(Constants.DEMONYM_PROP,</span>
                    DefaultPaths.DEFAULT_DCOREF_DEMONYM));
<span class="nc" id="L493">    os.append(Constants.ANIMATE_PROP + &quot;:&quot; +</span>
<span class="nc" id="L494">            props.getProperty(Constants.ANIMATE_PROP,</span>
                    DefaultPaths.DEFAULT_DCOREF_ANIMATE));
<span class="nc" id="L496">    os.append(Constants.INANIMATE_PROP + &quot;:&quot; +</span>
<span class="nc" id="L497">            props.getProperty(Constants.INANIMATE_PROP,</span>
                    DefaultPaths.DEFAULT_DCOREF_INANIMATE));
<span class="nc bnc" id="L499" title="All 2 branches missed.">    if(props.containsKey(Constants.MALE_PROP)) {</span>
<span class="nc" id="L500">      os.append(Constants.MALE_PROP + &quot;:&quot; +</span>
<span class="nc" id="L501">            props.getProperty(Constants.MALE_PROP));</span>
    }
<span class="nc bnc" id="L503" title="All 2 branches missed.">    if(props.containsKey(Constants.NEUTRAL_PROP)) {</span>
<span class="nc" id="L504">      os.append(Constants.NEUTRAL_PROP + &quot;:&quot; +</span>
<span class="nc" id="L505">            props.getProperty(Constants.NEUTRAL_PROP));</span>
    }
<span class="nc bnc" id="L507" title="All 2 branches missed.">    if(props.containsKey(Constants.FEMALE_PROP)) {</span>
<span class="nc" id="L508">      os.append(Constants.FEMALE_PROP + &quot;:&quot; +</span>
<span class="nc" id="L509">            props.getProperty(Constants.FEMALE_PROP));</span>
    }
<span class="nc bnc" id="L511" title="All 2 branches missed.">    if(props.containsKey(Constants.PLURAL_PROP)) {</span>
<span class="nc" id="L512">      os.append(Constants.PLURAL_PROP + &quot;:&quot; +</span>
<span class="nc" id="L513">            props.getProperty(Constants.PLURAL_PROP));</span>
    }
<span class="nc bnc" id="L515" title="All 2 branches missed.">    if(props.containsKey(Constants.SINGULAR_PROP)) {</span>
<span class="nc" id="L516">      os.append(Constants.SINGULAR_PROP + &quot;:&quot; +</span>
<span class="nc" id="L517">            props.getProperty(Constants.SINGULAR_PROP));</span>
    }
<span class="nc" id="L519">    os.append(Constants.STATES_PROP + &quot;:&quot; +</span>
<span class="nc" id="L520">            props.getProperty(Constants.STATES_PROP,</span>
                    DefaultPaths.DEFAULT_DCOREF_STATES));
<span class="nc" id="L522">    os.append(Constants.GENDER_NUMBER_PROP + &quot;:&quot; +</span>
<span class="nc" id="L523">            props.getProperty(Constants.GENDER_NUMBER_PROP,</span>
                    DefaultPaths.DEFAULT_DCOREF_GENDER_NUMBER));
<span class="nc" id="L525">    os.append(Constants.COUNTRIES_PROP + &quot;:&quot; +</span>
<span class="nc" id="L526">            props.getProperty(Constants.COUNTRIES_PROP,</span>
                    DefaultPaths.DEFAULT_DCOREF_COUNTRIES));
<span class="nc" id="L528">    os.append(Constants.STATES_PROVINCES_PROP + &quot;:&quot; +</span>
<span class="nc" id="L529">            props.getProperty(Constants.STATES_PROVINCES_PROP,</span>
                    DefaultPaths.DEFAULT_DCOREF_STATES_AND_PROVINCES));
<span class="nc" id="L531">    os.append(Constants.REPLICATECONLL_PROP + &quot;:&quot; +</span>
<span class="nc" id="L532">            props.getProperty(Constants.REPLICATECONLL_PROP,</span>
                    &quot;false&quot;));
<span class="nc" id="L534">    return os.toString();</span>
  }

  public Dictionaries(
      String demonymWords,
      String animateWords,
      String inanimateWords,
      String maleWords,
      String neutralWords,
      String femaleWords,
      String pluralWords,
      String singularWords,
      String statesWords,
      String genderNumber,
      String countries,
      String states,
      boolean loadCorefDict,
      String[] corefDictFiles,
      String corefDictPMIFile,
<span class="nc" id="L553">      String signaturesFile) {</span>
<span class="nc" id="L554">    loadDemonymLists(demonymWords);</span>
<span class="nc" id="L555">    loadStateAbbreviation(statesWords);</span>
<span class="nc" id="L556">    if(Constants.USE_ANIMACY_LIST) loadAnimacyLists(animateWords, inanimateWords);</span>
<span class="nc" id="L557">    loadGenderLists(maleWords, neutralWords, femaleWords);</span>
<span class="nc" id="L558">    loadNumberLists(pluralWords, singularWords);</span>
<span class="nc" id="L559">    loadGenderNumber(genderNumber, neutralWords);</span>
<span class="nc" id="L560">    loadCountriesLists(countries);</span>
<span class="nc" id="L561">    loadStatesLists(states);</span>
<span class="nc" id="L562">    setPronouns();</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">    if(loadCorefDict){</span>
<span class="nc" id="L564">      loadCorefDict(corefDictFiles, corefDict);</span>
<span class="nc" id="L565">      loadCorefDictPMI(corefDictPMIFile, corefDictPMI);</span>
<span class="nc" id="L566">      loadSignatures(signaturesFile, NE_signatures);</span>
    }
<span class="nc" id="L568">  }</span>

  public Dictionaries() {
<span class="nc" id="L571">    this(new Properties());</span>
<span class="nc" id="L572">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>