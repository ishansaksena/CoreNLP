<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Mention.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.dcoref</a> &gt; <span class="el_source">Mention.java</span></div><h1>Mention.java</h1><pre class="source lang-java linenums">//
// StanfordCoreNLP -- a suite of NLP tools
// Copyright (c) 2009-2010 The Board of Trustees of
// The Leland Stanford Junior University. All Rights Reserved.
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
//
// For more information, bug reports, fixes, contact:
//    Christopher Manning
//    Dept of Computer Science, Gates 1A
//    Stanford CA 94305-9010
//    USA
//

package edu.stanford.nlp.dcoref;

import java.io.Serializable;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Locale;
import java.util.Set;

import edu.stanford.nlp.classify.LogisticClassifier;
import edu.stanford.nlp.dcoref.Dictionaries.Animacy;
import edu.stanford.nlp.dcoref.Dictionaries.Gender;
import edu.stanford.nlp.dcoref.Dictionaries.MentionType;
import edu.stanford.nlp.dcoref.Dictionaries.Number;
import edu.stanford.nlp.dcoref.Dictionaries.Person;
import edu.stanford.nlp.ling.AbstractCoreLabel;
import edu.stanford.nlp.ling.BasicDatum;
import edu.stanford.nlp.ling.CoreAnnotation;
import edu.stanford.nlp.ling.CoreAnnotations;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.ling.IndexedWord;
import edu.stanford.nlp.trees.*;
import edu.stanford.nlp.semgraph.SemanticGraph;
import edu.stanford.nlp.semgraph.semgrex.SemgrexMatcher;
import edu.stanford.nlp.semgraph.semgrex.SemgrexPattern;
import edu.stanford.nlp.trees.tregex.TregexMatcher;
import edu.stanford.nlp.trees.tregex.TregexPattern;
import edu.stanford.nlp.util.*;

/**
 * One mention for the SieveCoreferenceSystem.
 *
 * @author Jenny Finkel, Karthik Raghunathan, Heeyoung Lee, Marta Recasens
 */
<span class="pc bpc" id="L63" title="1 of 2 branches missed.">public class Mention implements CoreAnnotation&lt;Mention&gt;, Serializable {</span>

  private static final long serialVersionUID = -7524485803945717057L;

<span class="nc" id="L67">  public Mention() {</span>
<span class="nc" id="L68">  }</span>

<span class="fc" id="L70">  public Mention(int mentionID, int startIndex, int endIndex, SemanticGraph dependency){</span>
<span class="fc" id="L71">    this.mentionID = mentionID;</span>
<span class="fc" id="L72">    this.startIndex = startIndex;</span>
<span class="fc" id="L73">    this.endIndex = endIndex;</span>
<span class="fc" id="L74">    this.dependency = dependency;</span>
<span class="fc" id="L75">  }</span>

<span class="nc" id="L77">  public Mention(int mentionID, int startIndex, int endIndex, SemanticGraph dependency, List&lt;CoreLabel&gt; mentionSpan){</span>
<span class="nc" id="L78">    this.mentionID = mentionID;</span>
<span class="nc" id="L79">    this.startIndex = startIndex;</span>
<span class="nc" id="L80">    this.endIndex = endIndex;</span>
<span class="nc" id="L81">    this.dependency = dependency;</span>
<span class="nc" id="L82">    this.originalSpan = mentionSpan;</span>
<span class="nc" id="L83">  }</span>

<span class="nc" id="L85">  public Mention(int mentionID, int startIndex, int endIndex, SemanticGraph dependency, List&lt;CoreLabel&gt; mentionSpan, Tree mentionTree){</span>
<span class="nc" id="L86">    this.mentionID = mentionID;</span>
<span class="nc" id="L87">    this.startIndex = startIndex;</span>
<span class="nc" id="L88">    this.endIndex = endIndex;</span>
<span class="nc" id="L89">    this.dependency = dependency;</span>
<span class="nc" id="L90">    this.originalSpan = mentionSpan;</span>
<span class="nc" id="L91">    this.mentionSubTree = mentionTree;</span>
<span class="nc" id="L92">  }</span>

  public MentionType mentionType;
  public Number number;
  public edu.stanford.nlp.dcoref.Dictionaries.Gender gender;
  public Animacy animacy;
  public Person person;
  public String headString;
  public String nerString;

  public int startIndex;
  public int endIndex;
  public int headIndex;
<span class="pc" id="L105">  public int mentionID = -1;</span>
<span class="pc" id="L106">  public int originalRef = -1;</span>
  public IndexedWord headIndexedWord;

<span class="pc" id="L109">  public int goldCorefClusterID = -1;</span>
<span class="pc" id="L110">  public int corefClusterID = -1;</span>
<span class="pc" id="L111">  public int sentNum = -1;</span>
<span class="pc" id="L112">  public int utter = -1;</span>
<span class="pc" id="L113">  public int paragraph = -1;</span>
  public boolean isSubject;
  public boolean isDirectObject;
  public boolean isIndirectObject;
  public boolean isPrepositionObject;
  public IndexedWord dependingVerb;
<span class="pc" id="L119">  public boolean twinless = true;</span>
<span class="pc" id="L120">  public boolean generic = false;   // generic pronoun or generic noun (bare plurals)</span>
  public boolean isSingleton;

  public List&lt;CoreLabel&gt; sentenceWords;
  public List&lt;CoreLabel&gt; originalSpan;

  public Tree mentionSubTree;
  public Tree contextParseTree;
  public CoreLabel headWord;
  public SemanticGraph dependency;
<span class="pc" id="L130">  public Set&lt;String&gt; dependents = Generics.newHashSet();</span>
  public List&lt;String&gt; preprocessedTerms;
  public Object synsets;

  /** Set of other mentions in the same sentence that are syntactic appositions to this */
<span class="pc" id="L135">  public Set&lt;Mention&gt; appositions = null;</span>
<span class="pc" id="L136">  public Set&lt;Mention&gt; predicateNominatives = null;</span>
<span class="pc" id="L137">  public Set&lt;Mention&gt; relativePronouns = null;</span>

  /** Set of other mentions in the same sentence that below to this list */
<span class="pc" id="L140">  public Set&lt;Mention&gt; listMembers = null;</span>
  /** Set of other mentions in the same sentence that I am a member of */
<span class="pc" id="L142">  public Set&lt;Mention&gt; belongToLists = null;</span>

  // Mention is identified as being this speaker....
  public SpeakerInfo speakerInfo;

<span class="pc" id="L147">  transient private String spanString = null;</span>
<span class="pc" id="L148">  transient private String lowercaseNormalizedSpanString = null;</span>

  @Override
  public Class&lt;Mention&gt; getType() {
<span class="nc" id="L152">    return Mention.class;</span>
  }

  public boolean isPronominal() {
<span class="nc bnc" id="L156" title="All 2 branches missed.">    return mentionType == MentionType.PRONOMINAL;</span>
  }

  @Override
  public String toString() {
<span class="nc" id="L161">    return spanToString();</span>
  }

  public String spanToString() {
//    synchronized(this) {
<span class="nc bnc" id="L166" title="All 2 branches missed.">      if (spanString == null) {</span>
<span class="nc" id="L167">        StringBuilder os = new StringBuilder();</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">        for(int i = 0; i &lt; originalSpan.size(); i ++){</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">          if(i &gt; 0) os.append(&quot; &quot;);</span>
<span class="nc" id="L170">          os.append(originalSpan.get(i).get(CoreAnnotations.TextAnnotation.class));</span>
        }
<span class="nc" id="L172">        spanString = os.toString();</span>
      }
//    }
<span class="nc" id="L175">    return spanString;</span>
  }

  public String lowercaseNormalizedSpanString() {
//    synchronized(this) {
<span class="nc bnc" id="L180" title="All 2 branches missed.">      if (lowercaseNormalizedSpanString == null) {</span>
        // We always normalize to lowercase!!!
<span class="nc" id="L182">        lowercaseNormalizedSpanString = spanString.toLowerCase();</span>
      }
//    }
<span class="nc" id="L185">    return lowercaseNormalizedSpanString;</span>
  }

  // Retrieves part of the span that corresponds to the NER (going out from head)
  public List&lt;CoreLabel&gt; nerTokens() {
<span class="nc bnc" id="L190" title="All 4 branches missed.">    if (nerString == null || &quot;O&quot;.equals(nerString)) return null;</span>

<span class="nc" id="L192">    int start = headIndex-startIndex;</span>
<span class="nc" id="L193">    int end = headIndex-startIndex+1;</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">    while (start &gt; 0) {</span>
<span class="nc" id="L195">      CoreLabel prev = originalSpan.get(start-1);</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">      if (nerString.equals(prev.ner())) {</span>
<span class="nc" id="L197">        start--;</span>
      } else {
        break;
      }
<span class="nc" id="L201">    }</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">    while (end &lt; originalSpan.size()) {</span>
<span class="nc" id="L203">      CoreLabel next = originalSpan.get(end);</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">      if (nerString.equals(next.ner())) {</span>
<span class="nc" id="L205">        end++;</span>
      } else {
        break;
      }
<span class="nc" id="L209">    }</span>
<span class="nc" id="L210">    return originalSpan.subList(start, end);</span>
  }

  // Retrieves part of the span that corresponds to the NER (going out from head)
  public String nerName() {
<span class="nc" id="L215">    List&lt;CoreLabel&gt; t = nerTokens();</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">    return (t != null)? StringUtils.joinWords(t, &quot; &quot;):null;</span>
  }

  /** Set attributes of a mention:
   * head string, mention type, NER label, Number, Gender, Animacy
   * @throws Exception
   */
  public void process(Dictionaries dict, Semantics semantics, MentionExtractor mentionExtractor) throws Exception {
<span class="nc" id="L224">    setHeadString();</span>
<span class="nc" id="L225">    setType(dict);</span>
<span class="nc" id="L226">    setNERString();</span>
<span class="nc" id="L227">    List&lt;String&gt; mStr = getMentionString();</span>
<span class="nc" id="L228">    setNumber(dict);</span>
<span class="nc" id="L229">    setGender(dict, getGender(dict, mStr));</span>
<span class="nc" id="L230">    setAnimacy(dict);</span>
<span class="nc" id="L231">    setPerson(dict);</span>
<span class="nc" id="L232">    setDiscourse();</span>
<span class="nc" id="L233">    headIndexedWord = dependency.getNodeByIndexSafe(headWord.index());</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">    if(semantics!=null) setSemantics(dict, semantics, mentionExtractor);</span>
<span class="nc" id="L235">  }</span>

  public void process(Dictionaries dict, Semantics semantics, MentionExtractor mentionExtractor,
      LogisticClassifier&lt;String, String&gt; singletonPredictor) throws Exception {
<span class="nc" id="L239">    process(dict, semantics, mentionExtractor);</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">    if(singletonPredictor != null) setSingleton(singletonPredictor, dict);</span>
<span class="nc" id="L241">  }</span>

  private void setSingleton(LogisticClassifier&lt;String, String&gt; predictor, Dictionaries dict){
<span class="nc" id="L244">    double coreference_score = predictor.probabilityOf(</span>
<span class="nc" id="L245">            new BasicDatum&lt;&gt;(getSingletonFeatures(dict), &quot;1&quot;));</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">    if(coreference_score &lt; 0.2) this.isSingleton = true;</span>
<span class="nc" id="L247">  }</span>

  /**
   * Returns the features used by the singleton predictor (logistic
   * classifier) to decide whether the mention belongs to a singleton entity
   */
  protected ArrayList&lt;String&gt; getSingletonFeatures(Dictionaries dict){
<span class="nc" id="L254">    ArrayList&lt;String&gt; features = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L255">    features.add(mentionType.toString());</span>
<span class="nc" id="L256">    features.add(nerString);</span>
<span class="nc" id="L257">    features.add(animacy.toString());</span>

<span class="nc" id="L259">    int personNum = 3;</span>
<span class="nc bnc" id="L260" title="All 4 branches missed.">    if(person.equals(Person.I) || person.equals(Person.WE)) personNum = 1;</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">    if(person.equals(Person.YOU)) personNum = 2;</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">    if(person.equals(Person.UNKNOWN)) personNum = 0;</span>
<span class="nc" id="L263">    features.add(String.valueOf(personNum));</span>
<span class="nc" id="L264">    features.add(number.toString());</span>
<span class="nc" id="L265">    features.add(getPosition());</span>
<span class="nc" id="L266">    features.add(getRelation());</span>
<span class="nc" id="L267">    features.add(getQuantification(dict));</span>
<span class="nc" id="L268">    features.add(String.valueOf(getModifiers(dict)));</span>
<span class="nc" id="L269">    features.add(String.valueOf(getNegation(dict)));</span>
<span class="nc" id="L270">    features.add(String.valueOf(getModal(dict)));</span>
<span class="nc" id="L271">    features.add(String.valueOf(getReportEmbedding(dict)));</span>
<span class="nc" id="L272">    features.add(String.valueOf(getCoordination()));</span>
<span class="nc" id="L273">    return features;</span>
  }

  private List&lt;String&gt; getMentionString() {
<span class="nc" id="L277">    List&lt;String&gt; mStr = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">    for(CoreLabel l : this.originalSpan) {</span>
<span class="nc" id="L279">      mStr.add(l.get(CoreAnnotations.TextAnnotation.class).toLowerCase());</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">      if(l==this.headWord) break;   // remove words after headword</span>
<span class="nc" id="L281">    }</span>
<span class="nc" id="L282">    return mStr;</span>
  }

  private Gender getGender(Dictionaries dict, List&lt;String&gt; mStr) {
<span class="nc" id="L286">    int len = mStr.size();</span>
<span class="nc" id="L287">    char firstLetter = headWord.get(CoreAnnotations.TextAnnotation.class).charAt(0);</span>
<span class="nc bnc" id="L288" title="All 6 branches missed.">    if(len &gt; 1 &amp;&amp; Character.isUpperCase(firstLetter) &amp;&amp; nerString.startsWith(&quot;PER&quot;)) {</span>
<span class="nc" id="L289">      int firstNameIdx = len-2;</span>
<span class="nc" id="L290">      String secondToLast = mStr.get(firstNameIdx);</span>
<span class="nc bnc" id="L291" title="All 8 branches missed.">      if(firstNameIdx &gt; 1 &amp;&amp; (secondToLast.length()==1 || (secondToLast.length()==2 &amp;&amp; secondToLast.endsWith(&quot;.&quot;)))) {</span>
<span class="nc" id="L292">        firstNameIdx--;</span>
      }

<span class="nc bnc" id="L295" title="All 2 branches missed.">      for(int i = 0 ; i &lt;= firstNameIdx ; i++){</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">        if(dict.genderNumber.containsKey(mStr.subList(i, len))) return dict.genderNumber.get(mStr.subList(i, len));</span>
      }

      // find converted string with ! (e.g., &quot;dr. martin luther king jr. boulevard&quot; -&gt; &quot;dr. !&quot;)
<span class="nc" id="L300">      List&lt;String&gt; convertedStr = new ArrayList&lt;&gt;(2);</span>
<span class="nc" id="L301">      convertedStr.add(mStr.get(firstNameIdx));</span>
<span class="nc" id="L302">      convertedStr.add(&quot;!&quot;);</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">      if(dict.genderNumber.containsKey(convertedStr)) return dict.genderNumber.get(convertedStr);</span>

<span class="nc bnc" id="L305" title="All 2 branches missed.">      if(dict.genderNumber.containsKey(mStr.subList(firstNameIdx, firstNameIdx+1))) return dict.genderNumber.get(mStr.subList(firstNameIdx, firstNameIdx+1));</span>
    }

<span class="nc bnc" id="L308" title="All 4 branches missed.">    if(mStr.size() &gt; 0 &amp;&amp; dict.genderNumber.containsKey(mStr.subList(len-1, len))) return dict.genderNumber.get(mStr.subList(len-1, len));</span>
<span class="nc" id="L309">    return null;</span>
  }
  private void setDiscourse() {
<span class="nc" id="L312">    utter = headWord.get(CoreAnnotations.UtteranceAnnotation.class);</span>

<span class="nc" id="L314">    Pair&lt;IndexedWord, String&gt; verbDependency = findDependentVerb(this);</span>
<span class="nc" id="L315">    String dep = verbDependency.second();</span>
<span class="nc" id="L316">    dependingVerb = verbDependency.first();</span>

<span class="nc" id="L318">    isSubject = false;</span>
<span class="nc" id="L319">    isDirectObject = false;</span>
<span class="nc" id="L320">    isIndirectObject = false;</span>
<span class="nc" id="L321">    isPrepositionObject = false;</span>

<span class="nc bnc" id="L323" title="All 2 branches missed.">    if(dep==null) {</span>
<span class="nc" id="L324">      return;</span>
<span class="nc bnc" id="L325" title="All 4 branches missed.">    } else if(dep.equals(&quot;nsubj&quot;) || dep.equals(&quot;csubj&quot;)) {</span>
<span class="nc" id="L326">      isSubject = true;</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">    } else if(dep.equals(&quot;dobj&quot;)){</span>
<span class="nc" id="L328">      isDirectObject = true;</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">    } else if(dep.equals(&quot;iobj&quot;)){</span>
<span class="nc" id="L330">      isIndirectObject = true;</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">    } else if(dep.startsWith(&quot;nmod&quot;)</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">        &amp;&amp; ! dep.equals(&quot;nmod:npmod&quot;)</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">        &amp;&amp; ! dep.equals(&quot;nmod:tmod&quot;)</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">        &amp;&amp; ! dep.equals(&quot;nmod:poss&quot;)</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">        &amp;&amp; ! dep.equals(&quot;nmod:agent&quot;)){</span>
<span class="nc" id="L336">      isPrepositionObject = true;</span>
    }
<span class="nc" id="L338">  }</span>

  private void setPerson(Dictionaries dict) {
    // only do for pronoun
<span class="nc bnc" id="L342" title="All 2 branches missed.">    if(!this.isPronominal()) person = Person.UNKNOWN;</span>
<span class="nc" id="L343">    String spanToString = this.spanToString().toLowerCase();</span>

<span class="nc bnc" id="L345" title="All 2 branches missed.">    if(dict.firstPersonPronouns.contains(spanToString)) {</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">      if (number == Number.SINGULAR) {</span>
<span class="nc" id="L347">        person = Person.I;</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">      } else if (number == Number.PLURAL) {</span>
<span class="nc" id="L349">        person = Person.WE;</span>
      } else {
<span class="nc" id="L351">        person = Person.UNKNOWN;</span>
      }
<span class="nc bnc" id="L353" title="All 2 branches missed.">    } else if(dict.secondPersonPronouns.contains(spanToString)) {</span>
<span class="nc" id="L354">      person = Person.YOU;</span>
<span class="nc bnc" id="L355" title="All 2 branches missed.">    } else if(dict.thirdPersonPronouns.contains(spanToString)) {</span>
<span class="nc bnc" id="L356" title="All 4 branches missed.">      if (gender == Gender.MALE &amp;&amp; number == Number.SINGULAR) {</span>
<span class="nc" id="L357">        person = Person.HE;</span>
<span class="nc bnc" id="L358" title="All 4 branches missed.">      } else if (gender == Gender.FEMALE &amp;&amp; number == Number.SINGULAR) {</span>
<span class="nc" id="L359">        person = Person.SHE;</span>
<span class="nc bnc" id="L360" title="All 6 branches missed.">      } else if ((gender == Gender.NEUTRAL || animacy == Animacy.INANIMATE) &amp;&amp; number == Number.SINGULAR) {</span>
<span class="nc" id="L361">        person = Person.IT;</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">      } else if (number == Number.PLURAL) {</span>
<span class="nc" id="L363">        person = Person.THEY;</span>
      } else {
<span class="nc" id="L365">        person = Person.UNKNOWN;</span>
      }
    } else {
<span class="nc" id="L368">      person = Person.UNKNOWN;</span>
    }
<span class="nc" id="L370">  }</span>

  private void setSemantics(Dictionaries dict, Semantics semantics, MentionExtractor mentionExtractor) throws Exception {

<span class="nc" id="L374">    preprocessedTerms = this.preprocessSearchTerm();</span>

<span class="nc bnc" id="L376" title="All 2 branches missed.">    if(dict.statesAbbreviation.containsKey(this.spanToString())) {  // states abbreviations</span>
<span class="nc" id="L377">      preprocessedTerms = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L378">      preprocessedTerms.add(dict.statesAbbreviation.get(this.spanToString()));</span>
    }

<span class="nc" id="L381">    Method meth = semantics.wordnet.getClass().getDeclaredMethod(&quot;findSynset&quot;, List.class);</span>
<span class="nc" id="L382">    synsets = meth.invoke(semantics.wordnet, new Object[]{preprocessedTerms});</span>

<span class="nc bnc" id="L384" title="All 2 branches missed.">    if(this.isPronominal()) return;</span>
<span class="nc" id="L385">  }</span>

  /** Check list member? True if this mention is inside the other mention and the other mention is a list */
  public boolean isListMemberOf(Mention m) {
<span class="nc bnc" id="L389" title="All 2 branches missed.">    if (this.equals(m)) return false;</span>
<span class="nc bnc" id="L390" title="All 4 branches missed.">    if (m.mentionType == MentionType.LIST &amp;&amp; this.mentionType == MentionType.LIST) return false; // Don't handle nested lists</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">    if (m.mentionType == MentionType.LIST) {</span>
<span class="nc" id="L392">      return this.includedIn(m);</span>
    }
<span class="nc" id="L394">    return false;</span>
  }

  public void addListMember(Mention m) {
<span class="nc bnc" id="L398" title="All 2 branches missed.">    if(listMembers == null) listMembers = Generics.newHashSet();</span>
<span class="nc" id="L399">    listMembers.add(m);</span>
<span class="nc" id="L400">  }</span>

  public void addBelongsToList(Mention m) {
<span class="nc bnc" id="L403" title="All 2 branches missed.">    if(belongToLists == null) belongToLists = Generics.newHashSet();</span>
<span class="nc" id="L404">    belongToLists.add(m);</span>
<span class="nc" id="L405">  }</span>

  public boolean isMemberOfSameList(Mention m) {
<span class="nc" id="L408">    Set&lt;Mention&gt; l1 = belongToLists;</span>
<span class="nc" id="L409">    Set&lt;Mention&gt; l2 = m.belongToLists;</span>
<span class="nc bnc" id="L410" title="All 6 branches missed.">    if (l1 != null &amp;&amp; l2 != null &amp;&amp; CollectionUtils.containsAny(l1, l2)) {</span>
<span class="nc" id="L411">      return true;</span>
    } else {
<span class="nc" id="L413">      return false;</span>
    }
  }

  private boolean isListLike() {
    // See if this mention looks to be a conjunction of things
    // Check for &quot;or&quot; and &quot;and&quot; and &quot;,&quot;
<span class="nc" id="L420">    int commas = 0;</span>
//    boolean firstLabelLike = false;
//    if (originalSpan.size() &gt; 1) {
//      String w = originalSpan.get(1).word();
//      firstLabelLike = (w.equals(&quot;:&quot;) || w.equals(&quot;-&quot;));
//    }
<span class="nc" id="L426">    String mentionSpanString = spanToString();</span>
<span class="nc" id="L427">    String subTreeSpanString = StringUtils.joinWords(mentionSubTree.yieldWords(), &quot; &quot;);</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">    if (subTreeSpanString.equals(mentionSpanString)) {</span>
      // subtree represents this mention well....
<span class="nc" id="L430">      List&lt;Tree&gt; children = mentionSubTree.getChildrenAsList();</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">      for (Tree t:children) {</span>
<span class="nc" id="L432">        String label = t.value();</span>
<span class="nc" id="L433">        String ner = null;</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">        if (t.isLeaf()) { ner = ((CoreLabel) t.getLeaves().get(0).label()).ner(); }</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">        if (&quot;CC&quot;.equals(label)) {</span>
          // Check NER type
<span class="nc bnc" id="L437" title="All 4 branches missed.">          if (ner == null || &quot;O&quot;.equals(ner)) {</span>
<span class="nc" id="L438">            return true;</span>
          }
<span class="nc bnc" id="L440" title="All 2 branches missed.">        } else if (label.equals(&quot;,&quot;)) {</span>
<span class="nc bnc" id="L441" title="All 4 branches missed.">          if (ner == null || &quot;O&quot;.equals(ner)) {</span>
<span class="nc" id="L442">            commas++;</span>
          }
        }
<span class="nc" id="L445">      }</span>
    }

<span class="nc bnc" id="L448" title="All 2 branches missed.">    if (commas &lt;= 2) {</span>
      // look at the string for and/or
<span class="nc" id="L450">      boolean first = true;</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">      for (CoreLabel t:originalSpan) {</span>
<span class="nc" id="L452">        String tag = t.tag();</span>
<span class="nc" id="L453">        String ner = t.ner();</span>
<span class="nc" id="L454">        String w = t.word();</span>
<span class="nc bnc" id="L455" title="All 6 branches missed.">        if (tag.equals(&quot;TO&quot;) || tag.equals(&quot;IN&quot;) || tag.startsWith(&quot;VB&quot;)) {</span>
          // prepositions and verbs are too hard for us
<span class="nc" id="L457">          return false;</span>
        }
<span class="nc bnc" id="L459" title="All 2 branches missed.">        if (!first) {</span>
<span class="nc bnc" id="L460" title="All 4 branches missed.">          if (w.equalsIgnoreCase(&quot;and&quot;) || w.equalsIgnoreCase(&quot;or&quot;)) {</span>
            // Check NER type
<span class="nc bnc" id="L462" title="All 4 branches missed.">            if (ner == null || &quot;O&quot;.equals(ner)) {</span>
<span class="nc" id="L463">              return true;</span>
            }
          }
        }
<span class="nc" id="L467">        first = false;</span>
<span class="nc" id="L468">      }</span>
    }

<span class="nc bnc" id="L471" title="All 2 branches missed.">    return (commas &gt; 2);</span>
  }

  private void setType(Dictionaries dict) {
<span class="nc bnc" id="L475" title="All 2 branches missed.">    if (isListLike()) {</span>
<span class="nc" id="L476">      mentionType = MentionType.LIST;</span>
<span class="nc" id="L477">      SieveCoreferenceSystem.logger.finer(&quot;IS LIST: &quot; + this);</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">    } else if (headWord.containsKey(CoreAnnotations.EntityTypeAnnotation.class)){    // ACE gold mention type</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">      if (headWord.get(CoreAnnotations.EntityTypeAnnotation.class).equals(&quot;PRO&quot;)) {</span>
<span class="nc" id="L480">        mentionType = MentionType.PRONOMINAL;</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">      } else if (headWord.get(CoreAnnotations.EntityTypeAnnotation.class).equals(&quot;NAM&quot;)) {</span>
<span class="nc" id="L482">        mentionType = MentionType.PROPER;</span>
      } else {
<span class="nc" id="L484">        mentionType = MentionType.NOMINAL;</span>
      }
    } else {    // MUC
<span class="nc bnc" id="L487" title="All 2 branches missed.">      if(!headWord.containsKey(CoreAnnotations.NamedEntityTagAnnotation.class)) {   // temporary fix</span>
<span class="nc" id="L488">        mentionType = MentionType.NOMINAL;</span>
<span class="nc" id="L489">        SieveCoreferenceSystem.logger.finest(&quot;no NamedEntityTagAnnotation: &quot;+headWord);</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">      } else if (headWord.get(CoreAnnotations.PartOfSpeechAnnotation.class).startsWith(&quot;PRP&quot;)</span>
<span class="nc bnc" id="L491" title="All 4 branches missed.">          || (originalSpan.size() == 1 &amp;&amp; headWord.get(CoreAnnotations.NamedEntityTagAnnotation.class).equals(&quot;O&quot;)</span>
<span class="nc bnc" id="L492" title="All 4 branches missed.">              &amp;&amp; (dict.allPronouns.contains(headString) || dict.relativePronouns.contains(headString) ))) {</span>
<span class="nc" id="L493">        mentionType = MentionType.PRONOMINAL;</span>
<span class="nc bnc" id="L494" title="All 4 branches missed.">      } else if (!headWord.get(CoreAnnotations.NamedEntityTagAnnotation.class).equals(&quot;O&quot;) || headWord.get(CoreAnnotations.PartOfSpeechAnnotation.class).startsWith(&quot;NNP&quot;)) {</span>
<span class="nc" id="L495">        mentionType = MentionType.PROPER;</span>
      } else {
<span class="nc" id="L497">        mentionType = MentionType.NOMINAL;</span>
      }
    }
<span class="nc" id="L500">  }</span>

  private void setGender(Dictionaries dict, Gender genderNumberResult) {
<span class="nc" id="L503">    gender = Gender.UNKNOWN;</span>
<span class="nc bnc" id="L504" title="All 4 branches missed.">    if(genderNumberResult!=null &amp;&amp; this.number!=Number.PLURAL){</span>
<span class="nc" id="L505">      gender = genderNumberResult;</span>
<span class="nc" id="L506">      SieveCoreferenceSystem.logger.finer(&quot;[Gender number count] New gender assigned:\t&quot; + gender + &quot;:\t&quot; +  headString + &quot;\tspan:&quot; + spanToString());</span>
    }
<span class="nc bnc" id="L508" title="All 2 branches missed.">    if (mentionType == MentionType.PRONOMINAL) {</span>
<span class="nc bnc" id="L509" title="All 2 branches missed.">      if (dict.malePronouns.contains(headString)) {</span>
<span class="nc" id="L510">        gender = Gender.MALE;</span>
<span class="nc bnc" id="L511" title="All 2 branches missed.">      } else if (dict.femalePronouns.contains(headString)) {</span>
<span class="nc" id="L512">        gender = Gender.FEMALE;</span>
      }
    } else {
      // Bergsma or user provided list
<span class="nc bnc" id="L516" title="All 2 branches missed.">      if(gender == Gender.UNKNOWN)  {</span>
<span class="nc bnc" id="L517" title="All 4 branches missed.">        if (&quot;PERSON&quot;.equals(nerString) || &quot;PER&quot;.equals(nerString)) {</span>
          // Try to get gender of the named entity
          // Start with first name until we get gender...
<span class="nc" id="L520">          List&lt;CoreLabel&gt; nerToks = nerTokens();</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">          for (CoreLabel t:nerToks) {</span>
<span class="nc" id="L522">            String name = t.word().toLowerCase();</span>
<span class="nc bnc" id="L523" title="All 2 branches missed.">            if(dict.maleWords.contains(name)) {</span>
<span class="nc" id="L524">              gender = Gender.MALE;</span>
<span class="nc" id="L525">              SieveCoreferenceSystem.logger.finer(&quot;[Bergsma List] New gender assigned:\tMale:\t&quot; +  name + &quot;\tspan:&quot; + spanToString());</span>
<span class="nc" id="L526">              break;</span>
            }
<span class="nc bnc" id="L528" title="All 2 branches missed.">            else if(dict.femaleWords.contains(name))  {</span>
<span class="nc" id="L529">              gender = Gender.FEMALE;</span>
<span class="nc" id="L530">              SieveCoreferenceSystem.logger.finer(&quot;[Bergsma List] New gender assigned:\tFemale:\t&quot; +  name + &quot;\tspan:&quot; + spanToString());</span>
<span class="nc" id="L531">              break;</span>
            }
<span class="nc" id="L533">          }</span>
<span class="nc" id="L534">        } else {</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">          if(dict.maleWords.contains(headString)) {</span>
<span class="nc" id="L536">            gender = Gender.MALE;</span>
<span class="nc" id="L537">            SieveCoreferenceSystem.logger.finer(&quot;[Bergsma List] New gender assigned:\tMale:\t&quot; +  headString + &quot;\tspan:&quot; + spanToString());</span>
          }
<span class="nc bnc" id="L539" title="All 2 branches missed.">          else if(dict.femaleWords.contains(headString))  {</span>
<span class="nc" id="L540">            gender = Gender.FEMALE;</span>
<span class="nc" id="L541">            SieveCoreferenceSystem.logger.finer(&quot;[Bergsma List] New gender assigned:\tFemale:\t&quot; +  headString + &quot;\tspan:&quot; + spanToString());</span>
          }
<span class="nc bnc" id="L543" title="All 2 branches missed.">          else if(dict.neutralWords.contains(headString))   {</span>
<span class="nc" id="L544">            gender = Gender.NEUTRAL;</span>
<span class="nc" id="L545">            SieveCoreferenceSystem.logger.finer(&quot;[Bergsma List] New gender assigned:\tNeutral:\t&quot; +  headString + &quot;\tspan:&quot; + spanToString());</span>
          }
        }
      }
    }
<span class="nc" id="L550">  }</span>

  protected void setNumber(Dictionaries dict) {
<span class="nc bnc" id="L553" title="All 2 branches missed.">    if (mentionType == MentionType.PRONOMINAL) {</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">      if (dict.pluralPronouns.contains(headString)) {</span>
<span class="nc" id="L555">        number = Number.PLURAL;</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">      } else if (dict.singularPronouns.contains(headString)) {</span>
<span class="nc" id="L557">        number = Number.SINGULAR;</span>
      } else {
<span class="nc" id="L559">        number = Number.UNKNOWN;</span>
      }
<span class="nc bnc" id="L561" title="All 2 branches missed.">    } else if (mentionType == MentionType.LIST) {</span>
<span class="nc" id="L562">      number = Number.PLURAL;</span>
<span class="nc bnc" id="L563" title="All 4 branches missed.">    } else if(! nerString.equals(&quot;O&quot;) &amp;&amp; mentionType!=MentionType.NOMINAL){</span>
      // Check to see if this is a list of things
<span class="nc bnc" id="L565" title="All 4 branches missed.">      if(! (nerString.equals(&quot;ORGANIZATION&quot;) || nerString.startsWith(&quot;ORG&quot;))){</span>
<span class="nc" id="L566">        number = Number.SINGULAR;</span>
      } else {
        // ORGs can be both plural and singular
<span class="nc" id="L569">        number = Number.UNKNOWN;</span>
      }
    } else {
<span class="nc" id="L572">      String tag = headWord.get(CoreAnnotations.PartOfSpeechAnnotation.class);</span>
<span class="nc bnc" id="L573" title="All 4 branches missed.">      if (tag.startsWith(&quot;N&quot;) &amp;&amp; tag.endsWith(&quot;S&quot;)) {</span>
<span class="nc" id="L574">        number = Number.PLURAL;</span>
<span class="nc bnc" id="L575" title="All 2 branches missed.">      } else if (tag.startsWith(&quot;N&quot;)) {</span>
<span class="nc" id="L576">        number = Number.SINGULAR;</span>
      } else {
<span class="nc" id="L578">        number = Number.UNKNOWN;</span>
      }
    }

<span class="nc bnc" id="L582" title="All 2 branches missed.">    if(mentionType != MentionType.PRONOMINAL) {</span>
<span class="nc bnc" id="L583" title="All 2 branches missed.">      if(number == Number.UNKNOWN){</span>
<span class="nc bnc" id="L584" title="All 2 branches missed.">        if(dict.singularWords.contains(headString)) {</span>
<span class="nc" id="L585">          number = Number.SINGULAR;</span>
<span class="nc" id="L586">          SieveCoreferenceSystem.logger.finest(&quot;[Bergsma] Number set to:\tSINGULAR:\t&quot; + headString);</span>
        }
<span class="nc bnc" id="L588" title="All 2 branches missed.">        else if(dict.pluralWords.contains(headString))  {</span>
<span class="nc" id="L589">          number = Number.PLURAL;</span>
<span class="nc" id="L590">          SieveCoreferenceSystem.logger.finest(&quot;[Bergsma] Number set to:\tPLURAL:\t&quot; + headString);</span>
        }
      }

<span class="nc" id="L594">      final String enumerationPattern = &quot;NP &lt; (NP=tmp $.. (/,|CC/ $.. NP))&quot;;</span>

<span class="nc" id="L596">      TregexPattern tgrepPattern = TregexPattern.compile(enumerationPattern);</span>
<span class="nc" id="L597">      TregexMatcher m = tgrepPattern.matcher(this.mentionSubTree);</span>
<span class="nc bnc" id="L598" title="All 2 branches missed.">      while (m.find()) {</span>
        //        Tree t = m.getMatch();
<span class="nc bnc" id="L600" title="All 2 branches missed.">        if(this.mentionSubTree==m.getNode(&quot;tmp&quot;)</span>
<span class="nc bnc" id="L601" title="All 2 branches missed.">           &amp;&amp; this.spanToString().toLowerCase().contains(&quot; and &quot;)) {</span>
<span class="nc" id="L602">          number = Number.PLURAL;</span>
        }
      }
    }
<span class="nc" id="L606">  }</span>

  private void setAnimacy(Dictionaries dict) {
<span class="nc bnc" id="L609" title="All 2 branches missed.">    if (mentionType == MentionType.PRONOMINAL) {</span>
<span class="nc bnc" id="L610" title="All 2 branches missed.">      if (dict.animatePronouns.contains(headString)) {</span>
<span class="nc" id="L611">        animacy = Animacy.ANIMATE;</span>
<span class="nc bnc" id="L612" title="All 2 branches missed.">      } else if (dict.inanimatePronouns.contains(headString)) {</span>
<span class="nc" id="L613">        animacy = Animacy.INANIMATE;</span>
      } else {
<span class="nc" id="L615">        animacy = Animacy.UNKNOWN;</span>
      }
<span class="nc bnc" id="L617" title="All 4 branches missed.">    } else if (nerString.equals(&quot;PERSON&quot;) || nerString.startsWith(&quot;PER&quot;)) {</span>
<span class="nc" id="L618">      animacy = Animacy.ANIMATE;</span>
<span class="nc bnc" id="L619" title="All 4 branches missed.">    } else if (nerString.equals(&quot;LOCATION&quot;)|| nerString.startsWith(&quot;LOC&quot;)) {</span>
<span class="nc" id="L620">      animacy = Animacy.INANIMATE;</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">    } else if (nerString.equals(&quot;MONEY&quot;)) {</span>
<span class="nc" id="L622">      animacy = Animacy.INANIMATE;</span>
<span class="nc bnc" id="L623" title="All 2 branches missed.">    } else if (nerString.equals(&quot;NUMBER&quot;)) {</span>
<span class="nc" id="L624">      animacy = Animacy.INANIMATE;</span>
<span class="nc bnc" id="L625" title="All 2 branches missed.">    } else if (nerString.equals(&quot;PERCENT&quot;)) {</span>
<span class="nc" id="L626">      animacy = Animacy.INANIMATE;</span>
<span class="nc bnc" id="L627" title="All 2 branches missed.">    } else if (nerString.equals(&quot;DATE&quot;)) {</span>
<span class="nc" id="L628">      animacy = Animacy.INANIMATE;</span>
<span class="nc bnc" id="L629" title="All 2 branches missed.">    } else if (nerString.equals(&quot;TIME&quot;)) {</span>
<span class="nc" id="L630">      animacy = Animacy.INANIMATE;</span>
<span class="nc bnc" id="L631" title="All 2 branches missed.">    } else if (nerString.equals(&quot;MISC&quot;)) {</span>
<span class="nc" id="L632">      animacy = Animacy.UNKNOWN;</span>
<span class="nc bnc" id="L633" title="All 2 branches missed.">    } else if (nerString.startsWith(&quot;VEH&quot;)) {</span>
<span class="nc" id="L634">      animacy = Animacy.UNKNOWN;</span>
<span class="nc bnc" id="L635" title="All 2 branches missed.">    } else if (nerString.startsWith(&quot;FAC&quot;)) {</span>
<span class="nc" id="L636">      animacy = Animacy.INANIMATE;</span>
<span class="nc bnc" id="L637" title="All 2 branches missed.">    } else if (nerString.startsWith(&quot;GPE&quot;)) {</span>
<span class="nc" id="L638">      animacy = Animacy.INANIMATE;</span>
<span class="nc bnc" id="L639" title="All 2 branches missed.">    } else if (nerString.startsWith(&quot;WEA&quot;)) {</span>
<span class="nc" id="L640">      animacy = Animacy.INANIMATE;</span>
<span class="nc bnc" id="L641" title="All 2 branches missed.">    } else if (nerString.startsWith(&quot;ORG&quot;)) {</span>
<span class="nc" id="L642">      animacy = Animacy.INANIMATE;</span>
    } else {
<span class="nc" id="L644">      animacy = Animacy.UNKNOWN;</span>
    }
<span class="nc bnc" id="L646" title="All 2 branches missed.">    if(mentionType != MentionType.PRONOMINAL) {</span>
      if(Constants.USE_ANIMACY_LIST){
        // Better heuristics using DekangLin:
<span class="nc bnc" id="L649" title="All 2 branches missed.">        if(animacy == Animacy.UNKNOWN)  {</span>
<span class="nc bnc" id="L650" title="All 2 branches missed.">          if(dict.animateWords.contains(headString))  {</span>
<span class="nc" id="L651">            animacy = Animacy.ANIMATE;</span>
<span class="nc" id="L652">            SieveCoreferenceSystem.logger.finest(&quot;Assigned Dekang Lin animacy:\tANIMATE:\t&quot; + headString);</span>
          }
<span class="nc bnc" id="L654" title="All 2 branches missed.">          else if(dict.inanimateWords.contains(headString)) {</span>
<span class="nc" id="L655">            animacy = Animacy.INANIMATE;</span>
<span class="nc" id="L656">            SieveCoreferenceSystem.logger.finest(&quot;Assigned Dekang Lin animacy:\tINANIMATE:\t&quot; + headString);</span>
          }
        }
      }
    }
<span class="nc" id="L661">  }</span>

<span class="fc" id="L663">  private static final String [] commonNESuffixes = {</span>
    &quot;Corp&quot;, &quot;Co&quot;, &quot;Inc&quot;, &quot;Ltd&quot;
  };

  private static boolean knownSuffix(String s) {
<span class="nc bnc" id="L668" title="All 2 branches missed.">    if(s.endsWith(&quot;.&quot;)) s = s.substring(0, s.length() - 1);</span>
<span class="nc bnc" id="L669" title="All 2 branches missed.">    for(String suff: commonNESuffixes){</span>
<span class="nc bnc" id="L670" title="All 2 branches missed.">      if(suff.equalsIgnoreCase(s)){</span>
<span class="nc" id="L671">        return true;</span>
      }
    }
<span class="nc" id="L674">    return false;</span>
  }

  private void setHeadString() {
<span class="nc" id="L678">    this.headString = headWord.get(CoreAnnotations.TextAnnotation.class).toLowerCase();</span>
<span class="nc" id="L679">    String ner = headWord.get(CoreAnnotations.NamedEntityTagAnnotation.class);</span>
<span class="nc bnc" id="L680" title="All 4 branches missed.">    if (ner != null &amp;&amp; !ner.equals(&quot;O&quot;)) {</span>
      // make sure that the head of a NE is not a known suffix, e.g., Corp.
<span class="nc" id="L682">      int start = headIndex - startIndex;</span>
<span class="nc bnc" id="L683" title="All 4 branches missed.">      if (originalSpan.size() &gt; 0 &amp;&amp; start &gt;= originalSpan.size()) {</span>
<span class="nc" id="L684">        throw new RuntimeException(&quot;Invalid start index &quot; + start + &quot;=&quot; + headIndex + &quot;-&quot; + startIndex</span>
<span class="nc" id="L685">                + &quot;: originalSpan=[&quot; + StringUtils.joinWords(originalSpan, &quot; &quot;) + &quot;], head=&quot; + headWord);</span>
      }
<span class="nc bnc" id="L687" title="All 2 branches missed.">      while (start &gt;= 0) {</span>
<span class="nc bnc" id="L688" title="All 2 branches missed.">        String head = originalSpan.size() &gt; 0 ? originalSpan.get(start).get(CoreAnnotations.TextAnnotation.class).toLowerCase() : &quot;&quot;;</span>
<span class="nc bnc" id="L689" title="All 2 branches missed.">        if (knownSuffix(head)) {</span>
<span class="nc" id="L690">          start --;</span>
        } else {
<span class="nc" id="L692">          this.headString = head;</span>
<span class="nc" id="L693">          this.headWord = originalSpan.get(start);</span>
<span class="nc" id="L694">          this.headIndex = startIndex + start;</span>
<span class="nc" id="L695">          break;</span>
        }
<span class="nc" id="L697">      }</span>
    }
<span class="nc" id="L699">  }</span>

  private void setNERString() {
<span class="nc bnc" id="L702" title="All 2 branches missed.">    if(headWord.containsKey(CoreAnnotations.EntityTypeAnnotation.class)){ // ACE</span>
<span class="nc bnc" id="L703" title="All 2 branches missed.">      if(headWord.containsKey(CoreAnnotations.NamedEntityTagAnnotation.class) &amp;&amp;</span>
<span class="nc bnc" id="L704" title="All 2 branches missed.">              headWord.get(CoreAnnotations.EntityTypeAnnotation.class).equals(&quot;NAM&quot;)){</span>
<span class="nc" id="L705">        this.nerString = headWord.get(CoreAnnotations.NamedEntityTagAnnotation.class);</span>
      } else {
<span class="nc" id="L707">        this.nerString = &quot;O&quot;;</span>
      }
    }
    else{ // MUC
<span class="nc bnc" id="L711" title="All 2 branches missed.">      if (headWord.containsKey(CoreAnnotations.NamedEntityTagAnnotation.class)) {</span>
<span class="nc" id="L712">        this.nerString = headWord.get(CoreAnnotations.NamedEntityTagAnnotation.class);</span>
      } else {
<span class="nc" id="L714">        this.nerString = &quot;O&quot;;</span>
      }
    }
<span class="nc" id="L717">  }</span>

  public boolean sameSentence(Mention m) {
<span class="nc bnc" id="L720" title="All 2 branches missed.">    return m.sentenceWords == sentenceWords;</span>
  }

  private static boolean included(CoreLabel small, List&lt;CoreLabel&gt; big) {
<span class="nc bnc" id="L724" title="All 2 branches missed.">    if(small.tag().equals(&quot;NNP&quot;)){</span>
<span class="nc bnc" id="L725" title="All 2 branches missed.">      for(CoreLabel w: big){</span>
<span class="nc bnc" id="L726" title="All 2 branches missed.">        if(small.word().equals(w.word()) ||</span>
<span class="nc bnc" id="L727" title="All 4 branches missed.">            small.word().length() &gt; 2 &amp;&amp; w.word().startsWith(small.word())){</span>
<span class="nc" id="L728">          return true;</span>
        }
<span class="nc" id="L730">      }</span>
    }
<span class="nc" id="L732">    return false;</span>
  }

  protected boolean headsAgree(Mention m) {
    // we allow same-type NEs to not match perfectly, but rather one could be included in the other, e.g., &quot;George&quot; -&gt; &quot;George Bush&quot;
<span class="nc bnc" id="L737" title="All 6 branches missed.">    if (!nerString.equals(&quot;O&quot;) &amp;&amp; !m.nerString.equals(&quot;O&quot;) &amp;&amp; nerString.equals(m.nerString) &amp;&amp;</span>
<span class="nc bnc" id="L738" title="All 4 branches missed.">            (included(headWord, m.originalSpan) || included(m.headWord, originalSpan))) {</span>
<span class="nc" id="L739">      return true;</span>
    }
<span class="nc" id="L741">    return headString.equals(m.headString);</span>
  }

  public boolean numbersAgree(Mention m){
<span class="nc" id="L745">    return numbersAgree(m, false);</span>
  }
  private boolean numbersAgree(Mention m, boolean strict) {
<span class="nc bnc" id="L748" title="All 2 branches missed.">    if (strict) {</span>
<span class="nc bnc" id="L749" title="All 2 branches missed.">      return number == m.number;</span>
    } else {
<span class="nc bnc" id="L751" title="All 6 branches missed.">      return number == Number.UNKNOWN ||</span>
              m.number == Number.UNKNOWN ||
              number == m.number;
    }
  }

  public boolean gendersAgree(Mention m){
<span class="nc" id="L758">    return gendersAgree(m, false);</span>
  }
  public boolean gendersAgree(Mention m, boolean strict) {
<span class="nc bnc" id="L761" title="All 2 branches missed.">    if (strict) {</span>
<span class="nc bnc" id="L762" title="All 2 branches missed.">      return gender == m.gender;</span>
    } else {
<span class="nc bnc" id="L764" title="All 6 branches missed.">      return gender == Gender.UNKNOWN ||</span>
              m.gender == Gender.UNKNOWN ||
              gender == m.gender;
    }
  }

  public boolean animaciesAgree(Mention m){
<span class="nc" id="L771">    return animaciesAgree(m, false);</span>
  }
  public boolean animaciesAgree(Mention m, boolean strict) {
<span class="nc bnc" id="L774" title="All 2 branches missed.">    if (strict) {</span>
<span class="nc bnc" id="L775" title="All 2 branches missed.">      return animacy == m.animacy;</span>
    } else {
<span class="nc bnc" id="L777" title="All 6 branches missed.">      return animacy == Animacy.UNKNOWN ||</span>
              m.animacy == Animacy.UNKNOWN ||
              animacy == m.animacy;
    }
  }

  public boolean entityTypesAgree(Mention m, Dictionaries dict){
<span class="nc" id="L784">    return entityTypesAgree(m, dict, false);</span>
  }

  public boolean entityTypesAgree(Mention m, Dictionaries dict, boolean strict) {
<span class="nc bnc" id="L788" title="All 2 branches missed.">    if (strict) {</span>
<span class="nc" id="L789">      return nerString.equals(m.nerString);</span>
    } else {
<span class="nc bnc" id="L791" title="All 2 branches missed.">      if (isPronominal()) {</span>
<span class="nc bnc" id="L792" title="All 4 branches missed.">        if (nerString.contains(&quot;-&quot;) || m.nerString.contains(&quot;-&quot;)) { //for ACE with gold NE</span>
<span class="nc bnc" id="L793" title="All 2 branches missed.">          if (m.nerString.equals(&quot;O&quot;)) {</span>
<span class="nc" id="L794">            return true;</span>
<span class="nc bnc" id="L795" title="All 2 branches missed.">          } else if (m.nerString.startsWith(&quot;ORG&quot;)) {</span>
<span class="nc" id="L796">            return dict.organizationPronouns.contains(headString);</span>
<span class="nc bnc" id="L797" title="All 2 branches missed.">          } else if (m.nerString.startsWith(&quot;PER&quot;)) {</span>
<span class="nc" id="L798">            return dict.personPronouns.contains(headString);</span>
<span class="nc bnc" id="L799" title="All 2 branches missed.">          } else if (m.nerString.startsWith(&quot;LOC&quot;)) {</span>
<span class="nc" id="L800">            return dict.locationPronouns.contains(headString);</span>
<span class="nc bnc" id="L801" title="All 2 branches missed.">          } else if (m.nerString.startsWith(&quot;GPE&quot;)) {</span>
<span class="nc" id="L802">            return dict.GPEPronouns.contains(headString);</span>
<span class="nc bnc" id="L803" title="All 6 branches missed.">          } else if (m.nerString.startsWith(&quot;VEH&quot;) || m.nerString.startsWith(&quot;FAC&quot;) || m.nerString.startsWith(&quot;WEA&quot;)) {</span>
<span class="nc" id="L804">            return dict.facilityVehicleWeaponPronouns.contains(headString);</span>
          } else {
<span class="nc" id="L806">            return false;</span>
          }
        } else {  // ACE w/o gold NE or MUC
<span class="nc bnc" id="L809" title="All 39 branches missed.">          switch (m.nerString) {</span>
            case &quot;O&quot;:
<span class="nc" id="L811">              return true;</span>
            case &quot;MISC&quot;:
<span class="nc" id="L813">              return true;</span>
            case &quot;ORGANIZATION&quot;:
<span class="nc" id="L815">              return dict.organizationPronouns.contains(headString);</span>
            case &quot;PERSON&quot;:
<span class="nc" id="L817">              return dict.personPronouns.contains(headString);</span>
            case &quot;LOCATION&quot;:
<span class="nc" id="L819">              return dict.locationPronouns.contains(headString);</span>
            case &quot;DATE&quot;:
            case &quot;TIME&quot;:
<span class="nc" id="L822">              return dict.dateTimePronouns.contains(headString);</span>
            case &quot;MONEY&quot;:
            case &quot;PERCENT&quot;:
            case &quot;NUMBER&quot;:
<span class="nc" id="L826">              return dict.moneyPercentNumberPronouns.contains(headString);</span>
            default:
<span class="nc" id="L828">              return false;</span>
          }
        }
      }
<span class="nc bnc" id="L832" title="All 2 branches missed.">      return nerString.equals(&quot;O&quot;) ||</span>
<span class="nc bnc" id="L833" title="All 2 branches missed.">              m.nerString.equals(&quot;O&quot;) ||</span>
<span class="nc bnc" id="L834" title="All 2 branches missed.">              nerString.equals(m.nerString);</span>
    }
  }



  /**
   * Verifies if this mention's tree is dominated by the tree of the given mention
   */
  public boolean includedIn(Mention m) {
<span class="nc bnc" id="L844" title="All 2 branches missed.">    if (!m.sameSentence(this)) {</span>
<span class="nc" id="L845">      return false;</span>
    }
<span class="nc bnc" id="L847" title="All 4 branches missed.">    if(this.startIndex &lt; m.startIndex || this.endIndex &gt; m.endIndex) return false;</span>
<span class="nc bnc" id="L848" title="All 2 branches missed.">    for (Tree t : m.mentionSubTree.subTrees()) {</span>
<span class="nc bnc" id="L849" title="All 2 branches missed.">      if (t == mentionSubTree) {</span>
<span class="nc" id="L850">        return true;</span>
      }
<span class="nc" id="L852">    }</span>
<span class="nc" id="L853">    return false;</span>
  }

  /**
   * Detects if the mention and candidate antecedent agree on all attributes respectively.
   * @param potentialAntecedent
   * @return true if all attributes agree between both mention and candidate, else false.
   */
  public boolean attributesAgree(Mention potentialAntecedent, Dictionaries dict){
<span class="nc bnc" id="L862" title="All 2 branches missed.">    return (this.animaciesAgree(potentialAntecedent) &amp;&amp;</span>
<span class="nc bnc" id="L863" title="All 2 branches missed.">        this.entityTypesAgree(potentialAntecedent, dict) &amp;&amp;</span>
<span class="nc bnc" id="L864" title="All 2 branches missed.">        this.gendersAgree(potentialAntecedent) &amp;&amp;</span>
<span class="nc bnc" id="L865" title="All 2 branches missed.">        this.numbersAgree(potentialAntecedent));</span>
  }

  /** Find apposition */
  public void addApposition(Mention m) {
<span class="nc bnc" id="L870" title="All 2 branches missed.">    if(appositions == null) appositions = Generics.newHashSet();</span>
<span class="nc" id="L871">    appositions.add(m);</span>
<span class="nc" id="L872">  }</span>

  /** Check apposition */
  public boolean isApposition(Mention m) {
<span class="nc bnc" id="L876" title="All 4 branches missed.">    if(appositions != null &amp;&amp; appositions.contains(m)) return true;</span>
<span class="nc" id="L877">    return false;</span>
  }
  /** Find predicate nominatives */
  public void addPredicateNominatives(Mention m) {
<span class="nc bnc" id="L881" title="All 2 branches missed.">    if(predicateNominatives == null) predicateNominatives = Generics.newHashSet();</span>
<span class="nc" id="L882">    predicateNominatives.add(m);</span>
<span class="nc" id="L883">  }</span>

  /** Check predicate nominatives */
  public boolean isPredicateNominatives(Mention m) {
<span class="nc bnc" id="L887" title="All 4 branches missed.">    if(predicateNominatives != null &amp;&amp; predicateNominatives.contains(m)) return true;</span>
<span class="nc" id="L888">    return false;</span>
  }

  /** Find relative pronouns */
  public void addRelativePronoun(Mention m) {
<span class="nc bnc" id="L893" title="All 2 branches missed.">    if(relativePronouns == null) relativePronouns = Generics.newHashSet();</span>
<span class="nc" id="L894">    relativePronouns.add(m);</span>
<span class="nc" id="L895">  }</span>

  /** Find which mention appears first in a document */
  public boolean appearEarlierThan(Mention m){
<span class="nc bnc" id="L899" title="All 2 branches missed.">    if (this.sentNum &lt; m.sentNum) {</span>
<span class="nc" id="L900">      return true;</span>
<span class="nc bnc" id="L901" title="All 2 branches missed.">    } else if (this.sentNum &gt; m.sentNum) {</span>
<span class="nc" id="L902">      return false;</span>
    } else {
<span class="nc bnc" id="L904" title="All 2 branches missed.">      if (this.startIndex &lt; m.startIndex) {</span>
<span class="nc" id="L905">        return true;</span>
<span class="nc bnc" id="L906" title="All 2 branches missed.">      } else if (this.startIndex &gt; m.startIndex) {</span>
<span class="nc" id="L907">        return false;</span>
      } else {
<span class="nc bnc" id="L909" title="All 2 branches missed.">        if (this.endIndex &gt; m.endIndex) {</span>
<span class="nc" id="L910">          return true;</span>
<span class="nc bnc" id="L911" title="All 2 branches missed.">        } else if (this.endIndex &lt; m.endIndex) {</span>
<span class="nc" id="L912">          return false;</span>
<span class="nc bnc" id="L913" title="All 2 branches missed.">        } else if (this.headIndex != m.headIndex) {</span>
          // Meaningless, but an arbitrary tiebreaker
<span class="nc bnc" id="L915" title="All 2 branches missed.">          return this.headIndex &lt; m.headIndex;</span>
<span class="nc bnc" id="L916" title="All 2 branches missed.">        } else if (this.mentionType != m.mentionType) {</span>
          // Meaningless, but an arbitrary tiebreaker
<span class="nc bnc" id="L918" title="All 2 branches missed.">          return this.mentionType.representativeness &gt; m.mentionType.representativeness;</span>
        } else {
          // Meaningless, but an arbitrary tiebreaker
<span class="nc bnc" id="L921" title="All 2 branches missed.">          return this.hashCode() &lt; m.hashCode();</span>
        }
      }
    }
  }

  public String longestNNPEndsWithHead (){
<span class="nc" id="L928">    String ret = &quot;&quot;;</span>
<span class="nc bnc" id="L929" title="All 2 branches missed.">    for (int i = headIndex; i &gt;=startIndex ; i--){</span>
<span class="nc" id="L930">      String pos = sentenceWords.get(i).get(CoreAnnotations.PartOfSpeechAnnotation.class);</span>
<span class="nc bnc" id="L931" title="All 2 branches missed.">      if(!pos.startsWith(&quot;NNP&quot;)) break;</span>
<span class="nc bnc" id="L932" title="All 2 branches missed.">      if(!ret.equals(&quot;&quot;)) ret = &quot; &quot;+ret;</span>
<span class="nc" id="L933">      ret = sentenceWords.get(i).get(CoreAnnotations.TextAnnotation.class)+ret;</span>
    }
<span class="nc" id="L935">    return ret;</span>
  }

  public String lowestNPIncludesHead (){
<span class="nc" id="L939">    String ret = &quot;&quot;;</span>
<span class="nc" id="L940">    Tree head = this.contextParseTree.getLeaves().get(this.headIndex);</span>
<span class="nc" id="L941">    Tree lowestNP = head;</span>
    String s;
    while(true) {
<span class="nc bnc" id="L944" title="All 2 branches missed.">      if(lowestNP==null) return ret;</span>
<span class="nc" id="L945">      s = ((CoreLabel) lowestNP.label()).get(CoreAnnotations.ValueAnnotation.class);</span>
<span class="nc bnc" id="L946" title="All 4 branches missed.">      if(s.equals(&quot;NP&quot;) || s.equals(&quot;ROOT&quot;)) break;</span>
<span class="nc" id="L947">      lowestNP = lowestNP.ancestor(1, this.contextParseTree);</span>
    }
<span class="nc bnc" id="L949" title="All 2 branches missed.">    if (s.equals(&quot;ROOT&quot;)) lowestNP = head;</span>
<span class="nc bnc" id="L950" title="All 2 branches missed.">    for (Tree t : lowestNP.getLeaves()){</span>
<span class="nc bnc" id="L951" title="All 2 branches missed.">      if (!ret.equals(&quot;&quot;)) ret = ret + &quot; &quot;;</span>
<span class="nc" id="L952">      ret = ret + ((CoreLabel) t.label()).get(CoreAnnotations.TextAnnotation.class);</span>
<span class="nc" id="L953">    }</span>
<span class="nc bnc" id="L954" title="All 2 branches missed.">    if(!this.spanToString().contains(ret)) return this.sentenceWords.get(this.headIndex).get(CoreAnnotations.TextAnnotation.class);</span>
<span class="nc" id="L955">    return ret;</span>
  }

  public String stringWithoutArticle(String str) {
<span class="nc bnc" id="L959" title="All 2 branches missed.">    String ret = (str==null)? this.spanToString() : str;</span>
<span class="nc bnc" id="L960" title="All 4 branches missed.">    if (ret.startsWith(&quot;a &quot;) || ret.startsWith(&quot;A &quot;)) {</span>
<span class="nc" id="L961">      return ret.substring(2);</span>
<span class="nc bnc" id="L962" title="All 4 branches missed.">    } else if (ret.startsWith(&quot;an &quot;) || ret.startsWith(&quot;An &quot;)) {</span>
<span class="nc" id="L963">      return ret.substring(3);</span>
<span class="nc bnc" id="L964" title="All 4 branches missed.">    } else if (ret.startsWith(&quot;the &quot;) || ret.startsWith(&quot;The &quot;))</span>
<span class="nc" id="L965">      return ret.substring(4);</span>
<span class="nc" id="L966">    return ret;</span>
  }

  public List&lt;String&gt; preprocessSearchTerm (){
<span class="nc" id="L970">    List&lt;String&gt; searchTerms = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L971">    String[] terms = new String[4];</span>

<span class="nc" id="L973">    terms[0] = this.stringWithoutArticle(this.removePhraseAfterHead());</span>
<span class="nc" id="L974">    terms[1] = this.stringWithoutArticle(this.lowestNPIncludesHead());</span>
<span class="nc" id="L975">    terms[2] = this.stringWithoutArticle(this.longestNNPEndsWithHead());</span>
<span class="nc" id="L976">    terms[3] = this.headString;</span>

<span class="nc bnc" id="L978" title="All 2 branches missed.">    for (String term : terms){</span>

<span class="nc bnc" id="L980" title="All 2 branches missed.">      if(term.contains(&quot;\&quot;&quot;)) term = term.replace(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;);</span>
<span class="nc bnc" id="L981" title="All 2 branches missed.">      if(term.contains(&quot;(&quot;)) term = term.replace(&quot;(&quot;,&quot;\\(&quot;);</span>
<span class="nc bnc" id="L982" title="All 2 branches missed.">      if(term.contains(&quot;)&quot;)) term = term.replace(&quot;)&quot;, &quot;\\)&quot;);</span>
<span class="nc bnc" id="L983" title="All 2 branches missed.">      if(term.contains(&quot;!&quot;)) term = term.replace(&quot;!&quot;, &quot;\\!&quot;);</span>
<span class="nc bnc" id="L984" title="All 2 branches missed.">      if(term.contains(&quot;:&quot;)) term = term.replace(&quot;:&quot;, &quot;\\:&quot;);</span>
<span class="nc bnc" id="L985" title="All 2 branches missed.">      if(term.contains(&quot;+&quot;)) term = term.replace(&quot;+&quot;, &quot;\\+&quot;);</span>
<span class="nc bnc" id="L986" title="All 2 branches missed.">      if(term.contains(&quot;-&quot;)) term = term.replace(&quot;-&quot;, &quot;\\-&quot;);</span>
<span class="nc bnc" id="L987" title="All 2 branches missed.">      if(term.contains(&quot;~&quot;)) term = term.replace(&quot;~&quot;, &quot;\\~&quot;);</span>
<span class="nc bnc" id="L988" title="All 2 branches missed.">      if(term.contains(&quot;*&quot;)) term = term.replace(&quot;*&quot;, &quot;\\*&quot;);</span>
<span class="nc bnc" id="L989" title="All 2 branches missed.">      if(term.contains(&quot;[&quot;)) term = term.replace(&quot;[&quot;, &quot;\\[&quot;);</span>
<span class="nc bnc" id="L990" title="All 2 branches missed.">      if(term.contains(&quot;]&quot;)) term = term.replace(&quot;]&quot;, &quot;\\]&quot;);</span>
<span class="nc bnc" id="L991" title="All 2 branches missed.">      if(term.contains(&quot;^&quot;)) term = term.replace(&quot;^&quot;, &quot;\\^&quot;);</span>
<span class="nc bnc" id="L992" title="All 2 branches missed.">      if(term.equals(&quot;&quot;)) continue;</span>

<span class="nc bnc" id="L994" title="All 4 branches missed.">      if(term.equals(&quot;&quot;) || searchTerms.contains(term)) continue;</span>
<span class="nc bnc" id="L995" title="All 4 branches missed.">      if(term.equals(terms[3]) &amp;&amp; !terms[2].equals(&quot;&quot;)) continue;</span>
<span class="nc" id="L996">      searchTerms.add(term);</span>
    }
<span class="nc" id="L998">    return searchTerms;</span>
  }
  public static String buildQueryText(List&lt;String&gt; terms) {
<span class="nc" id="L1001">    String query = &quot;&quot;;</span>
<span class="nc bnc" id="L1002" title="All 2 branches missed.">    for (String t : terms){</span>
<span class="nc" id="L1003">      query += t + &quot; &quot;;</span>
<span class="nc" id="L1004">    }</span>
<span class="nc" id="L1005">    return query.trim();</span>
  }

  /** Remove any clause after headword */
  public String removePhraseAfterHead(){
<span class="nc" id="L1010">    String removed =&quot;&quot;;</span>
<span class="nc" id="L1011">    int posComma = -1;</span>
<span class="nc" id="L1012">    int posWH = -1;</span>
<span class="nc bnc" id="L1013" title="All 2 branches missed.">    for(int i = 0 ; i &lt; this.originalSpan.size() ; i++){</span>
<span class="nc" id="L1014">      CoreLabel w = this.originalSpan.get(i);</span>
<span class="nc bnc" id="L1015" title="All 4 branches missed.">      if(posComma == -1 &amp;&amp; w.get(CoreAnnotations.PartOfSpeechAnnotation.class).equals(&quot;,&quot;)) posComma = this.startIndex + i;</span>
<span class="nc bnc" id="L1016" title="All 4 branches missed.">      if(posWH == -1 &amp;&amp; w.get(CoreAnnotations.PartOfSpeechAnnotation.class).startsWith(&quot;W&quot;)) posWH = this.startIndex + i;</span>
    }
<span class="nc bnc" id="L1018" title="All 4 branches missed.">    if(posComma!=-1 &amp;&amp; this.headIndex &lt; posComma){</span>
<span class="nc" id="L1019">      StringBuilder os = new StringBuilder();</span>
<span class="nc bnc" id="L1020" title="All 2 branches missed.">      for(int i = 0; i &lt; posComma-this.startIndex; i++){</span>
<span class="nc bnc" id="L1021" title="All 2 branches missed.">        if(i &gt; 0) os.append(&quot; &quot;);</span>
<span class="nc" id="L1022">        os.append(this.originalSpan.get(i).get(CoreAnnotations.TextAnnotation.class));</span>
      }
<span class="nc" id="L1024">      removed = os.toString();</span>
    }
<span class="nc bnc" id="L1026" title="All 6 branches missed.">    if(posComma==-1 &amp;&amp; posWH != -1 &amp;&amp; this.headIndex &lt; posWH){</span>
<span class="nc" id="L1027">      StringBuilder os = new StringBuilder();</span>
<span class="nc bnc" id="L1028" title="All 2 branches missed.">      for(int i = 0; i &lt; posWH-this.startIndex; i++){</span>
<span class="nc bnc" id="L1029" title="All 2 branches missed.">        if(i &gt; 0) os.append(&quot; &quot;);</span>
<span class="nc" id="L1030">        os.append(this.originalSpan.get(i).get(CoreAnnotations.TextAnnotation.class));</span>
      }
<span class="nc" id="L1032">      removed = os.toString();</span>
    }
<span class="nc bnc" id="L1034" title="All 4 branches missed.">    if(posComma==-1 &amp;&amp; posWH == -1){</span>
<span class="nc" id="L1035">      removed = this.spanToString();</span>
    }
<span class="nc" id="L1037">    return removed;</span>
  }

  public static String removeParenthesis(String text) {
<span class="nc bnc" id="L1041" title="All 2 branches missed.">    if (text.split(&quot;\\(&quot;).length &gt; 0) {</span>
<span class="nc" id="L1042">      return text.split(&quot;\\(&quot;)[0].trim();</span>
    } else {
<span class="nc" id="L1044">      return &quot;&quot;;</span>
    }
  }

  // the mention is 'the + commonNoun' form
  protected boolean isTheCommonNoun() {
<span class="nc bnc" id="L1050" title="All 2 branches missed.">    if (this.mentionType == MentionType.NOMINAL</span>
<span class="nc bnc" id="L1051" title="All 2 branches missed.">         &amp;&amp; this.spanToString().toLowerCase().startsWith(&quot;the &quot;)</span>
<span class="nc bnc" id="L1052" title="All 2 branches missed.">         &amp;&amp; this.spanToString().split(&quot; &quot;).length == 2) {</span>
<span class="nc" id="L1053">      return true;</span>
    } else {
<span class="nc" id="L1055">      return false;</span>
    }
  }

  private static Pair&lt;IndexedWord, String&gt; findDependentVerb(Mention m) {
<span class="nc bnc" id="L1060" title="All 2 branches missed.">    if (m.dependency.getRoots().size() == 0) {</span>
<span class="nc" id="L1061">      return new Pair&lt;&gt;();</span>
    }
    // would be nice to condense this pattern, but sadly =reln
    // always uses the last relation in the sequence, not the first
<span class="nc" id="L1065">    SemgrexPattern pattern = SemgrexPattern.compile(&quot;{idx:&quot; + (m.headIndex+1) + &quot;} [ &lt;=reln {tag:/^V.*/}=verb | &lt;=reln ({} &lt;&lt; {tag:/^V.*/}=verb) ]&quot;);</span>
<span class="nc" id="L1066">    SemgrexMatcher matcher = pattern.matcher(m.dependency);</span>
<span class="nc bnc" id="L1067" title="All 2 branches missed.">    while (matcher.find()) {</span>
<span class="nc" id="L1068">      return Pair.makePair(matcher.getNode(&quot;verb&quot;), matcher.getRelnString(&quot;reln&quot;));</span>
    }
<span class="nc" id="L1070">    return new Pair&lt;&gt;();</span>
  }

  public boolean insideIn(Mention m){
<span class="nc bnc" id="L1074" title="All 6 branches missed.">    return this.sentNum == m.sentNum</span>
            &amp;&amp; m.startIndex &lt;= this.startIndex
            &amp;&amp; this.endIndex &lt;= m.endIndex;
  }

  public boolean moreRepresentativeThan(Mention m){
<span class="nc bnc" id="L1080" title="All 2 branches missed.">    if(m==null) return true;</span>
<span class="nc bnc" id="L1081" title="All 2 branches missed.">    if (mentionType.representativeness &gt; m.mentionType.representativeness) { return true; }</span>
<span class="nc bnc" id="L1082" title="All 2 branches missed.">    else if (m.mentionType.representativeness &gt; mentionType.representativeness) { return false; }</span>
    else {
      // pick mention with better NER
<span class="nc bnc" id="L1085" title="All 4 branches missed.">      if (nerString != null &amp;&amp; m.nerString == null) return true;</span>
<span class="nc bnc" id="L1086" title="All 4 branches missed.">      if (nerString == null &amp;&amp; m.nerString != null) return false;</span>
<span class="nc bnc" id="L1087" title="All 4 branches missed.">      if (nerString != null &amp;&amp; !nerString.equals(m.nerString)) {</span>
<span class="nc bnc" id="L1088" title="All 2 branches missed.">        if (&quot;O&quot;.equals(m.nerString)) return true;</span>
<span class="nc bnc" id="L1089" title="All 2 branches missed.">        if (&quot;O&quot;.equals(nerString)) return false;</span>
<span class="nc bnc" id="L1090" title="All 2 branches missed.">        if (&quot;MISC&quot;.equals(m.nerString)) return true;</span>
<span class="nc bnc" id="L1091" title="All 2 branches missed.">        if (&quot;MISC&quot;.equals(nerString)) return false;</span>
      }
      // Ensure that both NER tags are neither MISC nor O, or are both not existent
<span class="nc bnc" id="L1094" title="All 14 branches missed.">      assert nerString == null || nerString.equals(m.nerString) || (!nerString.equals(&quot;O&quot;) &amp;&amp; !nerString.equals(&quot;MISC&quot;) &amp;&amp; !m.nerString.equals(&quot;O&quot;) &amp;&amp; !m.nerString.equals(&quot;MISC&quot;));</span>
      // Return larger headIndex - startIndex
<span class="nc bnc" id="L1096" title="All 2 branches missed.">      if (headIndex - startIndex &gt; m.headIndex - m.startIndex) { return true; }</span>
<span class="nc bnc" id="L1097" title="All 2 branches missed.">      else if (headIndex - startIndex &lt; m.headIndex - m.startIndex) { return false; }</span>
      // Return earlier sentence number
<span class="nc bnc" id="L1099" title="All 2 branches missed.">      else if (sentNum &lt; m.sentNum) { return true; }</span>
<span class="nc bnc" id="L1100" title="All 2 branches missed.">      else if (sentNum &gt; m.sentNum) { return false; }</span>
      // Return earlier head index
<span class="nc bnc" id="L1102" title="All 2 branches missed.">      else if (headIndex &lt; m.headIndex) { return true; }</span>
<span class="nc bnc" id="L1103" title="All 2 branches missed.">      else if (headIndex &gt; m.headIndex) { return false; }</span>
      // If the mentions are short, take the longer one
<span class="nc bnc" id="L1105" title="All 4 branches missed.">      else if (originalSpan.size() &lt;= 5 &amp;&amp; originalSpan.size() &gt; m.originalSpan.size()) { return true; }</span>
<span class="nc bnc" id="L1106" title="All 4 branches missed.">      else if (originalSpan.size() &lt;= 5 &amp;&amp; originalSpan.size() &lt; m.originalSpan.size()) { return false; }</span>
      // If the mentions are long, take the shorter one (we're getting into the realm of nonsense by here)
<span class="nc bnc" id="L1108" title="All 2 branches missed.">      else if (originalSpan.size() &lt; m.originalSpan.size()) { return true; }</span>
<span class="nc bnc" id="L1109" title="All 2 branches missed.">      else if (originalSpan.size() &gt; m.originalSpan.size()) { return false; }</span>
      else {
<span class="nc" id="L1111">        throw new IllegalStateException(&quot;Comparing a mention with itself for representativeness&quot;);</span>
      }
    }
  }

  // Returns filtered premodifiers (no determiners or numerals)
  public ArrayList&lt;ArrayList&lt;IndexedWord&gt;&gt; getPremodifiers(){

<span class="nc" id="L1119">    ArrayList&lt;ArrayList&lt;IndexedWord&gt;&gt; premod = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L1121" title="All 2 branches missed.">    if(headIndexedWord == null) return premod;</span>
<span class="nc bnc" id="L1122" title="All 2 branches missed.">    for(Pair&lt;GrammaticalRelation,IndexedWord&gt; child : dependency.childPairs(headIndexedWord)){</span>
<span class="nc" id="L1123">      String function = child.first().getShortName();</span>
<span class="nc bnc" id="L1124" title="All 2 branches missed.">      if(child.second().index() &lt; headWord.index()</span>
<span class="nc bnc" id="L1125" title="All 4 branches missed.">          &amp;&amp; !child.second.tag().equals(&quot;DT&quot;) &amp;&amp; !child.second.tag().equals(&quot;WRB&quot;)</span>
<span class="nc bnc" id="L1126" title="All 4 branches missed.">          &amp;&amp; !function.endsWith(&quot;det&quot;) &amp;&amp; !function.equals(&quot;nummod&quot;)</span>
<span class="nc bnc" id="L1127" title="All 4 branches missed.">          &amp;&amp; !function.startsWith(&quot;acl&quot;) &amp;&amp; !function.startsWith(&quot;advcl&quot;)</span>
<span class="nc bnc" id="L1128" title="All 2 branches missed.">          &amp;&amp; !function.equals(&quot;punct&quot;)){</span>
<span class="nc" id="L1129">        ArrayList&lt;IndexedWord&gt; phrase = new ArrayList&lt;&gt;(dependency.descendants(child.second()));</span>
<span class="nc" id="L1130">        Collections.sort(phrase);</span>
<span class="nc" id="L1131">        premod.add(phrase);</span>
      }
<span class="nc" id="L1133">    }</span>
<span class="nc" id="L1134">    return premod;</span>
  }

  // Returns filtered postmodifiers (no relative, -ed or -ing clauses)
  public ArrayList&lt;ArrayList&lt;IndexedWord&gt;&gt; getPostmodifiers(){

<span class="nc" id="L1140">    ArrayList&lt;ArrayList&lt;IndexedWord&gt;&gt; postmod = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L1142" title="All 2 branches missed.">    if(headIndexedWord == null) return postmod;</span>
<span class="nc bnc" id="L1143" title="All 2 branches missed.">    for(Pair&lt;GrammaticalRelation,IndexedWord&gt; child : dependency.childPairs(headIndexedWord)){</span>
<span class="nc" id="L1144">      String function = child.first().getShortName();</span>
<span class="nc bnc" id="L1145" title="All 2 branches missed.">      if(child.second().index() &gt; headWord.index() &amp;&amp;</span>
<span class="nc bnc" id="L1146" title="All 4 branches missed.">          ! function.endsWith(&quot;det&quot;) &amp;&amp; ! function.equals(&quot;nummod&quot;)</span>
<span class="nc bnc" id="L1147" title="All 4 branches missed.">          &amp;&amp; ! function.startsWith(&quot;acl&quot;) &amp;&amp; ! function.startsWith(&quot;advcl&quot;)</span>
<span class="nc bnc" id="L1148" title="All 2 branches missed.">          &amp;&amp; ! function.equals(&quot;punct&quot;) &amp;&amp;</span>
          //possessive clitic
<span class="nc bnc" id="L1150" title="All 4 branches missed.">          ! (function.equals(&quot;case&quot;) &amp;&amp; dependency.descendants(child.second()).size() == 1</span>
<span class="nc bnc" id="L1151" title="All 2 branches missed.">              &amp;&amp; child.second.tag().equals(&quot;POS&quot;))){</span>
<span class="nc" id="L1152">        ArrayList&lt;IndexedWord&gt; phrase = new ArrayList&lt;&gt;(dependency.descendants(child.second()));</span>
<span class="nc" id="L1153">        Collections.sort(phrase);</span>
<span class="nc" id="L1154">        postmod.add(phrase);</span>
      }
<span class="nc" id="L1156">    }</span>
<span class="nc" id="L1157">    return postmod;</span>
  }


  public String[] getSplitPattern(){

<span class="nc" id="L1163">    ArrayList&lt;ArrayList&lt;IndexedWord&gt;&gt; premodifiers = getPremodifiers();</span>

<span class="nc" id="L1165">    String[] components = new String[4];</span>

<span class="nc" id="L1167">    components[0] = headWord.lemma();</span>

<span class="nc bnc" id="L1169" title="All 2 branches missed.">    if(premodifiers.size() == 0){</span>
<span class="nc" id="L1170">      components[1] = headWord.lemma();</span>
<span class="nc" id="L1171">      components[2] = headWord.lemma();</span>
<span class="nc bnc" id="L1172" title="All 2 branches missed.">    } else if(premodifiers.size() == 1){</span>
<span class="nc" id="L1173">      ArrayList&lt;AbstractCoreLabel&gt; premod = Generics.newArrayList();</span>
<span class="nc" id="L1174">      premod.addAll(premodifiers.get(premodifiers.size()-1));</span>
<span class="nc" id="L1175">      premod.add(headWord);</span>
<span class="nc" id="L1176">      components[1] = getPattern(premod);</span>
<span class="nc" id="L1177">      components[2] = getPattern(premod);</span>
<span class="nc" id="L1178">    } else {</span>
<span class="nc" id="L1179">      ArrayList&lt;AbstractCoreLabel&gt; premod1 = Generics.newArrayList();</span>
<span class="nc" id="L1180">      premod1.addAll(premodifiers.get(premodifiers.size()-1));</span>
<span class="nc" id="L1181">      premod1.add(headWord);</span>
<span class="nc" id="L1182">      components[1] = getPattern(premod1);</span>

<span class="nc" id="L1184">      ArrayList&lt;AbstractCoreLabel&gt; premod2 = Generics.newArrayList();</span>
<span class="nc bnc" id="L1185" title="All 2 branches missed.">      for(ArrayList&lt;IndexedWord&gt; premodifier : premodifiers){</span>
<span class="nc" id="L1186">        premod2.addAll(premodifier);</span>
<span class="nc" id="L1187">      }</span>
<span class="nc" id="L1188">      premod2.add(headWord);</span>
<span class="nc" id="L1189">      components[2] = getPattern(premod2);</span>
    }

<span class="nc" id="L1192">    components[3] = getPattern();</span>
<span class="nc" id="L1193">    return components;</span>
  }

  public String getPattern(){

<span class="nc" id="L1198">    ArrayList&lt;AbstractCoreLabel&gt; pattern = Generics.newArrayList();</span>
<span class="nc bnc" id="L1199" title="All 2 branches missed.">    for(ArrayList&lt;IndexedWord&gt; premodifier : getPremodifiers()){</span>
<span class="nc" id="L1200">      pattern.addAll(premodifier);</span>
<span class="nc" id="L1201">    }</span>
<span class="nc" id="L1202">    pattern.add(headWord);</span>
<span class="nc bnc" id="L1203" title="All 2 branches missed.">    for(ArrayList&lt;IndexedWord&gt; postmodifier : getPostmodifiers()){</span>
<span class="nc" id="L1204">      pattern.addAll(postmodifier);</span>
<span class="nc" id="L1205">    }</span>
<span class="nc" id="L1206">    return getPattern(pattern);</span>
  }

  public String getPattern(List&lt;AbstractCoreLabel&gt; pTokens){

<span class="nc" id="L1211">    ArrayList&lt;String&gt; phrase_string = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1212">    String ne = &quot;&quot;;</span>
<span class="nc bnc" id="L1213" title="All 2 branches missed.">    for(AbstractCoreLabel token : pTokens){</span>
<span class="nc bnc" id="L1214" title="All 2 branches missed.">      if(token.index() == headWord.index()){</span>
<span class="nc" id="L1215">        phrase_string.add(token.lemma());</span>
<span class="nc" id="L1216">        ne = &quot;&quot;;</span>

<span class="nc bnc" id="L1218" title="All 4 branches missed.">      } else if( (token.lemma().equals(&quot;and&quot;) || StringUtils.isPunct(token.lemma()))</span>
<span class="nc bnc" id="L1219" title="All 2 branches missed.">          &amp;&amp; pTokens.size() &gt; pTokens.indexOf(token)+1</span>
<span class="nc bnc" id="L1220" title="All 2 branches missed.">          &amp;&amp; pTokens.indexOf(token) &gt; 0</span>
<span class="nc bnc" id="L1221" title="All 2 branches missed.">          &amp;&amp; pTokens.get(pTokens.indexOf(token)+1).ner().equals(pTokens.get(pTokens.indexOf(token)-1).ner())){</span>

<span class="nc bnc" id="L1223" title="All 2 branches missed.">      } else if(token.index() == headWord.index()-1</span>
<span class="nc bnc" id="L1224" title="All 2 branches missed.">          &amp;&amp; token.ner().equals(nerString)){</span>
<span class="nc" id="L1225">        phrase_string.add(token.lemma());</span>
<span class="nc" id="L1226">        ne = &quot;&quot;;</span>

<span class="nc bnc" id="L1228" title="All 2 branches missed.">      } else if(!token.ner().equals(&quot;O&quot;)){</span>
<span class="nc bnc" id="L1229" title="All 2 branches missed.">        if(!token.ner().equals(ne)){</span>
<span class="nc" id="L1230">          ne = token.ner();</span>
<span class="nc" id="L1231">          phrase_string.add(&quot;&lt;&quot;+ne+&quot;&gt;&quot;);</span>
        }

      } else {
<span class="nc" id="L1235">        phrase_string.add(token.lemma());</span>
<span class="nc" id="L1236">        ne = &quot;&quot;;</span>
      }
<span class="nc" id="L1238">    }</span>
<span class="nc" id="L1239">    return StringUtils.join(phrase_string);</span>
  }

  public boolean isCoordinated(){
<span class="nc bnc" id="L1243" title="All 2 branches missed.">    if(headIndexedWord == null) return false;</span>
<span class="nc bnc" id="L1244" title="All 2 branches missed.">    for(Pair&lt;GrammaticalRelation,IndexedWord&gt; child : dependency.childPairs(headIndexedWord)){</span>
<span class="nc bnc" id="L1245" title="All 2 branches missed.">      if(child.first().getShortName().equals(&quot;cc&quot;)) return true;</span>
<span class="nc" id="L1246">    }</span>
<span class="nc" id="L1247">    return false;</span>
  }

  private static List&lt;String&gt; getContextHelper(List&lt;? extends AbstractCoreLabel&gt; words) {
<span class="nc" id="L1251">    List&lt;List&lt;AbstractCoreLabel&gt;&gt; namedEntities = Generics.newArrayList();</span>
<span class="nc" id="L1252">    List&lt;AbstractCoreLabel&gt; ne = Generics.newArrayList();</span>
<span class="nc" id="L1253">    String previousNEType = &quot;&quot;;</span>
<span class="nc" id="L1254">    int previousNEIndex = -1;</span>
<span class="nc bnc" id="L1255" title="All 2 branches missed.">    for (int i = 0; i &lt; words.size(); i++) {</span>
<span class="nc" id="L1256">      AbstractCoreLabel word = words.get(i);</span>
<span class="nc bnc" id="L1257" title="All 2 branches missed.">      if(!word.ner().equals(&quot;O&quot;)) {</span>
<span class="nc bnc" id="L1258" title="All 4 branches missed.">        if (!word.ner().equals(previousNEType) || previousNEIndex != i-1) {</span>
<span class="nc" id="L1259">          ne = Generics.newArrayList();</span>
<span class="nc" id="L1260">          namedEntities.add(ne);</span>
        }
<span class="nc" id="L1262">        ne.add(word);</span>
<span class="nc" id="L1263">        previousNEType = word.ner();</span>
<span class="nc" id="L1264">        previousNEIndex = i;</span>
      }
    }

<span class="nc" id="L1268">    List&lt;String&gt; neStrings = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1269">    Set&lt;String&gt; hs = Generics.newHashSet();</span>
<span class="nc bnc" id="L1270" title="All 2 branches missed.">    for (List&lt;AbstractCoreLabel&gt; namedEntity : namedEntities) {</span>
<span class="nc" id="L1271">      String ne_str = StringUtils.joinWords(namedEntity, &quot; &quot;);</span>
<span class="nc" id="L1272">      hs.add(ne_str);</span>
<span class="nc" id="L1273">    }</span>
<span class="nc" id="L1274">    neStrings.addAll(hs);</span>
<span class="nc" id="L1275">    return neStrings;</span>
  }

  public List&lt;String&gt; getContext() {
<span class="nc" id="L1279">    return getContextHelper(sentenceWords);</span>
  }

  public List&lt;String&gt; getPremodifierContext() {
<span class="nc" id="L1283">    List&lt;String&gt; neStrings = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1284" title="All 2 branches missed.">    for (List&lt;IndexedWord&gt; words : getPremodifiers()) {</span>
<span class="nc" id="L1285">      neStrings.addAll(getContextHelper(words));</span>
<span class="nc" id="L1286">    }</span>
<span class="nc" id="L1287">    return neStrings;</span>
  }

  /** Check relative pronouns */
  public boolean isRelativePronoun(Mention m) {
<span class="nc bnc" id="L1292" title="All 4 branches missed.">    return relativePronouns != null &amp;&amp; relativePronouns.contains(m);</span>
  }

  public boolean isRoleAppositive(Mention m, Dictionaries dict) {
<span class="nc" id="L1296">    String thisString = this.spanToString();</span>
<span class="nc" id="L1297">    String thisStringLower = this.lowercaseNormalizedSpanString();</span>
<span class="nc bnc" id="L1298" title="All 4 branches missed.">    if(this.isPronominal() || dict.allPronouns.contains(thisStringLower)) return false;</span>
<span class="nc bnc" id="L1299" title="All 4 branches missed.">    if(!m.nerString.startsWith(&quot;PER&quot;) &amp;&amp; !m.nerString.equals(&quot;O&quot;)) return false;</span>
<span class="nc bnc" id="L1300" title="All 4 branches missed.">    if(!this.nerString.startsWith(&quot;PER&quot;) &amp;&amp; !this.nerString.equals(&quot;O&quot;)) return false;</span>
<span class="nc bnc" id="L1301" title="All 4 branches missed.">    if(!sameSentence(m) || !m.spanToString().startsWith(thisString)) return false;</span>
<span class="nc bnc" id="L1302" title="All 4 branches missed.">    if(m.spanToString().contains(&quot;'&quot;) || m.spanToString().contains(&quot; and &quot;)) return false;</span>
<span class="nc bnc" id="L1303" title="All 8 branches missed.">    if (!animaciesAgree(m) || this.animacy == Animacy.INANIMATE</span>
         || this.gender == Gender.NEUTRAL || m.gender == Gender.NEUTRAL
<span class="nc bnc" id="L1305" title="All 2 branches missed.">         || !this.numbersAgree(m)) {</span>
<span class="nc" id="L1306">      return false;</span>
    }
<span class="nc bnc" id="L1308" title="All 2 branches missed.">    if (dict.demonymSet.contains(thisStringLower)</span>
<span class="nc bnc" id="L1309" title="All 2 branches missed.">         || dict.demonymSet.contains(m.lowercaseNormalizedSpanString())) {</span>
<span class="nc" id="L1310">      return false;</span>
    }
<span class="nc" id="L1312">    return true;</span>
  }

  public boolean isDemonym(Mention m, Dictionaries dict) {
<span class="nc" id="L1316">    String thisCasedString = this.spanToString();</span>
<span class="nc" id="L1317">    String antCasedString = m.spanToString();</span>

    // The US state matching part (only) is done cased
<span class="nc" id="L1320">    String thisNormed = dict.lookupCanonicalAmericanStateName(thisCasedString);</span>
<span class="nc" id="L1321">    String antNormed = dict.lookupCanonicalAmericanStateName(antCasedString);</span>
<span class="nc bnc" id="L1322" title="All 4 branches missed.">    if (thisNormed != null &amp;&amp; thisNormed.equals(antNormed)) {</span>
<span class="nc" id="L1323">      return true;</span>
    }

    // The rest is done uncased
<span class="nc" id="L1327">    String thisString = thisCasedString.toLowerCase(Locale.ENGLISH);</span>
<span class="nc" id="L1328">    String antString = antCasedString.toLowerCase(Locale.ENGLISH);</span>
<span class="nc bnc" id="L1329" title="All 2 branches missed.">    if (thisString.startsWith(&quot;the &quot;)) {</span>
<span class="nc" id="L1330">      thisString = thisString.substring(4);</span>
    }
<span class="nc bnc" id="L1332" title="All 2 branches missed.">    if (antString.startsWith(&quot;the &quot;)) {</span>
<span class="nc" id="L1333">      antString = antString.substring(4);</span>
    }

<span class="nc" id="L1336">    Set&lt;String&gt; thisDemonyms = dict.getDemonyms(thisString);</span>
<span class="nc" id="L1337">    Set&lt;String&gt; antDemonyms = dict.getDemonyms(antString);</span>
<span class="nc bnc" id="L1338" title="All 4 branches missed.">    if (thisDemonyms.contains(antString) || antDemonyms.contains(thisString)) {</span>
<span class="nc" id="L1339">      return true;</span>
    }
<span class="nc" id="L1341">    return false;</span>
  }

  public String getPosition() {
<span class="nc" id="L1345">    int size = sentenceWords.size();</span>
<span class="nc bnc" id="L1346" title="All 2 branches missed.">    if(headIndex == 0) {</span>
<span class="nc" id="L1347">      return &quot;first&quot;;</span>
<span class="nc bnc" id="L1348" title="All 2 branches missed.">    } else if (headIndex == size -1) {</span>
<span class="nc" id="L1349">      return &quot;last&quot;;</span>
    } else {
<span class="nc bnc" id="L1351" title="All 4 branches missed.">      if(headIndex &gt; 0 &amp;&amp; headIndex &lt; size/3) {</span>
<span class="nc" id="L1352">        return &quot;begin&quot;;</span>
<span class="nc bnc" id="L1353" title="All 4 branches missed.">      } else if (headIndex &gt;= size/3 &amp;&amp; headIndex &lt; 2 * size/3) {</span>
<span class="nc" id="L1354">        return &quot;middle&quot;;</span>
<span class="nc bnc" id="L1355" title="All 4 branches missed.">      } else if (headIndex &gt;= 2 * size/3 &amp;&amp; headIndex &lt; size -1) {</span>
<span class="nc" id="L1356">        return &quot;end&quot;;</span>
      }
    }
<span class="nc" id="L1359">    return null;</span>
  }

  public String getRelation(){

<span class="nc bnc" id="L1364" title="All 2 branches missed.">    if(headIndexedWord == null) return null;</span>

<span class="nc bnc" id="L1366" title="All 2 branches missed.">    if(dependency.getRoots().isEmpty()) return null;</span>
    // root relation
<span class="nc bnc" id="L1368" title="All 2 branches missed.">    if(dependency.getFirstRoot().equals(headIndexedWord)) return &quot;root&quot;;</span>
<span class="nc bnc" id="L1369" title="All 2 branches missed.">    if(!dependency.containsVertex(dependency.getParent(headIndexedWord))) return null;</span>
<span class="nc" id="L1370">    GrammaticalRelation relation = dependency.reln(dependency.getParent(headIndexedWord), headIndexedWord);</span>

    // adjunct relations
<span class="nc bnc" id="L1373" title="All 8 branches missed.">    if(relation != UniversalEnglishGrammaticalRelations.RELATIVE_CLAUSE_MODIFIER //do not match &quot;acl:relcl&quot;</span>
        &amp;&amp; relation != UniversalEnglishGrammaticalRelations.POSSESSION_MODIFIER //do not match &quot;nmod:poss&quot;
        &amp;&amp; relation != UniversalEnglishGrammaticalRelations.NP_ADVERBIAL_MODIFIER //do not match &quot;nmod:npmod&quot;
        &amp;&amp; relation != UniversalEnglishGrammaticalRelations.AGENT //do not match &quot;nmod:agent&quot;
<span class="nc bnc" id="L1377" title="All 2 branches missed.">        &amp;&amp; (relation.toString().startsWith(&quot;nmod&quot;) //matches all regular nmod, nmods with prepositions in relation name, and &quot;nmod:tmod&quot;</span>
<span class="nc bnc" id="L1378" title="All 2 branches missed.">        ||  relation.toString().startsWith(&quot;acl&quot;)</span>
<span class="nc bnc" id="L1379" title="All 4 branches missed.">        ||  relation.toString().startsWith(&quot;advcl&quot;)</span>
        ||  relation == UniversalEnglishGrammaticalRelations.ADVERBIAL_MODIFIER))
<span class="nc" id="L1381">      return &quot;adjunct&quot;;</span>

    // subject relations
<span class="nc bnc" id="L1384" title="All 4 branches missed.">    if(relation == UniversalEnglishGrammaticalRelations.NOMINAL_SUBJECT</span>
        || relation == UniversalEnglishGrammaticalRelations.CLAUSAL_SUBJECT)
<span class="nc" id="L1386">      return &quot;subject&quot;;</span>
<span class="nc bnc" id="L1387" title="All 4 branches missed.">    if(relation == UniversalEnglishGrammaticalRelations.NOMINAL_PASSIVE_SUBJECT</span>
        || relation == UniversalEnglishGrammaticalRelations.CLAUSAL_PASSIVE_SUBJECT)
<span class="nc" id="L1389">      return &quot;subject&quot;;</span>

    // verbal argument relations
<span class="nc bnc" id="L1392" title="All 10 branches missed.">    if(relation == UniversalEnglishGrammaticalRelations.CLAUSAL_COMPLEMENT</span>
        || relation == UniversalEnglishGrammaticalRelations.XCLAUSAL_COMPLEMENT
        || relation == UniversalEnglishGrammaticalRelations.AGENT
        || relation == UniversalEnglishGrammaticalRelations.DIRECT_OBJECT
        || relation == UniversalEnglishGrammaticalRelations.INDIRECT_OBJECT)
<span class="nc" id="L1397">      return &quot;verbArg&quot;;</span>

    // noun argument relations
<span class="nc bnc" id="L1400" title="All 10 branches missed.">    if(relation == UniversalEnglishGrammaticalRelations.RELATIVE_CLAUSE_MODIFIER</span>
        || relation == UniversalEnglishGrammaticalRelations.COMPOUND_MODIFIER
        || relation == UniversalEnglishGrammaticalRelations.ADJECTIVAL_MODIFIER
        || relation == UniversalEnglishGrammaticalRelations.APPOSITIONAL_MODIFIER
        || relation == UniversalEnglishGrammaticalRelations.POSSESSION_MODIFIER)
<span class="nc" id="L1405">      return &quot;nounArg&quot;;</span>

<span class="nc" id="L1407">    return null;</span>
  }

  public int getModifiers(Dictionaries dict){

<span class="nc bnc" id="L1412" title="All 2 branches missed.">    if(headIndexedWord == null) return 0;</span>

<span class="nc" id="L1414">    int count = 0;</span>
<span class="nc" id="L1415">    List&lt;Pair&lt;GrammaticalRelation, IndexedWord&gt;&gt; childPairs = dependency.childPairs(headIndexedWord);</span>
<span class="nc bnc" id="L1416" title="All 2 branches missed.">    for(Pair&lt;GrammaticalRelation, IndexedWord&gt; childPair : childPairs) {</span>
<span class="nc" id="L1417">      GrammaticalRelation gr = childPair.first;</span>
<span class="nc" id="L1418">      IndexedWord word = childPair.second;</span>

      //adjectival modifiers, prepositional modifiers, relative clauses, and possessives if they are not a determiner
<span class="nc bnc" id="L1421" title="All 4 branches missed.">      if((gr == UniversalEnglishGrammaticalRelations.ADJECTIVAL_MODIFIER</span>
          || gr == UniversalEnglishGrammaticalRelations.RELATIVE_CLAUSE_MODIFIER
<span class="nc bnc" id="L1423" title="All 2 branches missed.">          || gr.toString().startsWith(&quot;nmod&quot;)</span>
<span class="nc bnc" id="L1424" title="All 2 branches missed.">          || gr.toString().startsWith(&quot;acl&quot;)</span>
<span class="nc bnc" id="L1425" title="All 2 branches missed.">          || gr.toString().startsWith(&quot;advcl&quot;))</span>
<span class="nc bnc" id="L1426" title="All 2 branches missed.">          &amp;&amp; !dict.determiners.contains(word.lemma())) {</span>
<span class="nc" id="L1427">        count++;</span>
      }
      // add noun modifier when the mention isn't a NER
<span class="nc bnc" id="L1430" title="All 4 branches missed.">      if(nerString.equals(&quot;O&quot;) &amp;&amp; gr == UniversalEnglishGrammaticalRelations.COMPOUND_MODIFIER) {</span>
<span class="nc" id="L1431">        count++;</span>
      }
<span class="nc" id="L1433">    }</span>
<span class="nc" id="L1434">    return count;</span>
  }

  public String getQuantification(Dictionaries dict){

<span class="nc bnc" id="L1439" title="All 2 branches missed.">    if(headIndexedWord == null) return null;</span>

<span class="nc bnc" id="L1441" title="All 2 branches missed.">    if(!nerString.equals(&quot;O&quot;)) return &quot;definite&quot;;</span>

<span class="nc" id="L1443">    Set&lt;IndexedWord&gt; quant = dependency.getChildrenWithReln(headIndexedWord, UniversalEnglishGrammaticalRelations.DETERMINER);</span>
<span class="nc" id="L1444">    Set&lt;IndexedWord&gt; poss = dependency.getChildrenWithReln(headIndexedWord, UniversalEnglishGrammaticalRelations.POSSESSION_MODIFIER);</span>
<span class="nc bnc" id="L1445" title="All 2 branches missed.">    if (!quant.isEmpty()) {</span>
<span class="nc bnc" id="L1446" title="All 2 branches missed.">      for (IndexedWord word : quant) {</span>
<span class="nc" id="L1447">        String det = word.lemma();</span>
<span class="nc bnc" id="L1448" title="All 2 branches missed.">        if (dict.determiners.contains(det)) {</span>
<span class="nc" id="L1449">          return &quot;definite&quot;;</span>
<span class="nc bnc" id="L1450" title="All 2 branches missed.">        } else if (dict.quantifiers2.contains(det)) {</span>
<span class="nc" id="L1451">          return &quot;quantified&quot;;</span>
        }
<span class="nc" id="L1453">      }</span>
<span class="nc bnc" id="L1454" title="All 2 branches missed.">    } else if (!poss.isEmpty()) {</span>
<span class="nc" id="L1455">      return &quot;definite&quot;;</span>
    } else {
<span class="nc" id="L1457">      quant = dependency.getChildrenWithReln(headIndexedWord, UniversalEnglishGrammaticalRelations.NUMERIC_MODIFIER);</span>
<span class="nc bnc" id="L1458" title="All 2 branches missed.">      if (!quant.isEmpty()) {</span>
<span class="nc" id="L1459">        return &quot;quantified&quot;;</span>
      }
    }
<span class="nc" id="L1462">    return &quot;indefinite&quot;;</span>
  }

  public int getNegation(Dictionaries dict) {

<span class="nc bnc" id="L1467" title="All 2 branches missed.">    if(headIndexedWord == null) return 0;</span>

    // direct negation in a child
<span class="nc" id="L1470">    Collection&lt;IndexedWord&gt; children = dependency.getChildren(headIndexedWord);</span>
<span class="nc bnc" id="L1471" title="All 2 branches missed.">    for(IndexedWord child : children) {</span>
<span class="nc bnc" id="L1472" title="All 2 branches missed.">      if(dict.negations.contains(child.lemma())) return 1;</span>
<span class="nc" id="L1473">    }</span>

    // or has a sibling
<span class="nc bnc" id="L1476" title="All 2 branches missed.">    for(IndexedWord sibling : dependency.getSiblings(headIndexedWord)) {</span>
<span class="nc bnc" id="L1477" title="All 2 branches missed.">      if(dict.negations.contains(sibling.lemma())</span>
<span class="nc bnc" id="L1478" title="All 2 branches missed.">          &amp;&amp; !dependency.hasParentWithReln(headIndexedWord, UniversalEnglishGrammaticalRelations.NOMINAL_SUBJECT))</span>
<span class="nc" id="L1479">        return 1;</span>
<span class="nc" id="L1480">    }</span>
    // check the parent
<span class="nc" id="L1482">    List&lt;Pair&lt;GrammaticalRelation,IndexedWord&gt;&gt; parentPairs = dependency.parentPairs(headIndexedWord);</span>
<span class="nc bnc" id="L1483" title="All 2 branches missed.">    if (!parentPairs.isEmpty()) {</span>
<span class="nc" id="L1484">      Pair&lt;GrammaticalRelation,IndexedWord&gt; parentPair = parentPairs.get(0);</span>
<span class="nc" id="L1485">      GrammaticalRelation gr = parentPair.first;</span>
      // check negative prepositions
<span class="nc bnc" id="L1487" title="All 2 branches missed.">      if(dict.neg_relations.contains(gr.toString())) return 1;</span>
    }
<span class="nc" id="L1489">    return 0;</span>
  }

  public int getModal(Dictionaries dict) {

<span class="nc bnc" id="L1494" title="All 2 branches missed.">    if(headIndexedWord == null) return 0;</span>

    // direct modal in a child
<span class="nc" id="L1497">    Collection&lt;IndexedWord&gt; children = dependency.getChildren(headIndexedWord);</span>
<span class="nc bnc" id="L1498" title="All 2 branches missed.">    for(IndexedWord child : children) {</span>
<span class="nc bnc" id="L1499" title="All 2 branches missed.">      if(dict.modals.contains(child.lemma())) return 1;</span>
<span class="nc" id="L1500">    }</span>

    // check the parent
<span class="nc" id="L1503">    IndexedWord parent = dependency.getParent(headIndexedWord);</span>
<span class="nc bnc" id="L1504" title="All 2 branches missed.">    if (parent != null) {</span>
<span class="nc bnc" id="L1505" title="All 2 branches missed.">      if(dict.modals.contains(parent.lemma())) return 1;</span>
      // check the children of the parent (that is needed for modal auxiliaries)
<span class="nc" id="L1507">      IndexedWord child = dependency.getChildWithReln(parent, UniversalEnglishGrammaticalRelations.AUX_MODIFIER);</span>
<span class="nc bnc" id="L1508" title="All 4 branches missed.">      if(!dependency.hasParentWithReln(headIndexedWord, UniversalEnglishGrammaticalRelations.NOMINAL_SUBJECT)</span>
<span class="nc bnc" id="L1509" title="All 2 branches missed.">          &amp;&amp; child != null &amp;&amp; dict.modals.contains(child.lemma())) return 1;</span>
    }

    // look at the path to root
<span class="nc" id="L1513">    List&lt;IndexedWord&gt; path = dependency.getPathToRoot(headIndexedWord);</span>
<span class="nc bnc" id="L1514" title="All 2 branches missed.">    if(path == null) return 0;</span>
<span class="nc bnc" id="L1515" title="All 2 branches missed.">    for(IndexedWord word : path) {</span>
<span class="nc bnc" id="L1516" title="All 2 branches missed.">      if(dict.modals.contains(word.lemma())) return 1;</span>
<span class="nc" id="L1517">    }</span>
<span class="nc" id="L1518">    return 0;</span>
  }

  public int getReportEmbedding(Dictionaries dict) {

<span class="nc bnc" id="L1523" title="All 2 branches missed.">    if(headIndexedWord == null) return 0;</span>

    // check adverbial clause with marker &quot;as&quot;
<span class="nc bnc" id="L1526" title="All 2 branches missed.">    for(IndexedWord sibling : dependency.getSiblings(headIndexedWord)) {</span>
<span class="nc bnc" id="L1527" title="All 4 branches missed.">      if(dict.reportVerb.contains(sibling.lemma()) &amp;&amp; dependency.hasParentWithReln(sibling,UniversalEnglishGrammaticalRelations.ADV_CLAUSE_MODIFIER)) {</span>
<span class="nc" id="L1528">        IndexedWord marker = dependency.getChildWithReln(sibling,UniversalEnglishGrammaticalRelations.MARKER);</span>
<span class="nc bnc" id="L1529" title="All 4 branches missed.">        if (marker != null &amp;&amp; marker.lemma().equals(&quot;as&quot;)) {</span>
<span class="nc" id="L1530">          return 1;</span>
        }
      }
<span class="nc" id="L1533">    }</span>

    // look at the path to root
<span class="nc" id="L1536">    List&lt;IndexedWord&gt; path = dependency.getPathToRoot(headIndexedWord);</span>
<span class="nc bnc" id="L1537" title="All 2 branches missed.">    if(path == null) return 0;</span>
<span class="nc" id="L1538">    boolean isSubject = false;</span>

    // if the node itself is a subject, we will not take into account its parent in the path
<span class="nc bnc" id="L1541" title="All 2 branches missed.">    if(dependency.hasParentWithReln(headIndexedWord, UniversalEnglishGrammaticalRelations.NOMINAL_SUBJECT)) isSubject = true;</span>

<span class="nc bnc" id="L1543" title="All 2 branches missed.">    for (IndexedWord word : path) {</span>
<span class="nc bnc" id="L1544" title="All 6 branches missed.">      if(!isSubject &amp;&amp; (dict.reportVerb.contains(word.lemma()) || dict.reportNoun.contains(word.lemma()))) {</span>
<span class="nc" id="L1545">        return 1;</span>
      }
      // check how to put isSubject
<span class="nc" id="L1548">      isSubject = dependency.hasParentWithReln(word, UniversalEnglishGrammaticalRelations.NOMINAL_SUBJECT);</span>
<span class="nc" id="L1549">    }</span>
<span class="nc" id="L1550">    return 0;</span>
  }

  public int getCoordination() {

<span class="nc bnc" id="L1555" title="All 2 branches missed.">    if(headIndexedWord == null) return 0;</span>

<span class="nc" id="L1557">    Set&lt;GrammaticalRelation&gt; relations = dependency.childRelns(headIndexedWord);</span>
<span class="nc bnc" id="L1558" title="All 2 branches missed.">    for (GrammaticalRelation rel : relations) {</span>
<span class="nc bnc" id="L1559" title="All 2 branches missed.">      if(rel.toString().startsWith(&quot;conj:&quot;)) {</span>
<span class="nc" id="L1560">        return 1;</span>
      }
<span class="nc" id="L1562">    }</span>

<span class="nc" id="L1564">    Set&lt;GrammaticalRelation&gt; parent_relations = dependency.relns(headIndexedWord);</span>
<span class="nc bnc" id="L1565" title="All 2 branches missed.">    for (GrammaticalRelation rel : parent_relations) {</span>
<span class="nc bnc" id="L1566" title="All 2 branches missed.">      if(rel.toString().startsWith(&quot;conj:&quot;)) {</span>
<span class="nc" id="L1567">        return 1;</span>
      }
<span class="nc" id="L1569">    }</span>
<span class="nc" id="L1570">    return 0;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>