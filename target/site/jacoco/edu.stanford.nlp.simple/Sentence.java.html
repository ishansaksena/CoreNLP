<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Sentence.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.simple</a> &gt; <span class="el_source">Sentence.java</span></div><h1>Sentence.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.simple;

import edu.stanford.nlp.coref.data.CorefChain;
import edu.stanford.nlp.ie.util.RelationTriple;
import edu.stanford.nlp.ling.CoreAnnotations;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.ling.tokensregex.TokenSequenceMatcher;
import edu.stanford.nlp.ling.tokensregex.TokenSequencePattern;
import edu.stanford.nlp.naturalli.OperatorSpec;
import edu.stanford.nlp.naturalli.Polarity;
import edu.stanford.nlp.naturalli.SentenceFragment;
import edu.stanford.nlp.pipeline.Annotation;
import edu.stanford.nlp.pipeline.Annotator;
import edu.stanford.nlp.pipeline.CoreNLPProtos;
import edu.stanford.nlp.pipeline.ProtobufAnnotationSerializer;
import edu.stanford.nlp.semgraph.SemanticGraph;
import edu.stanford.nlp.semgraph.SemanticGraphCoreAnnotations;
import edu.stanford.nlp.semgraph.SemanticGraphFactory;
import edu.stanford.nlp.semgraph.semgrex.SemgrexMatcher;
import edu.stanford.nlp.semgraph.semgrex.SemgrexPattern;
import edu.stanford.nlp.trees.Tree;
import edu.stanford.nlp.util.*;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.*;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;


/**
 * A representation of a single Sentence.
 * Although it is possible to create a sentence directly from text, it is advisable to
 * create a document instead and operate on the document directly.
 *
 * @author Gabor Angeli
 */
<span class="pc bpc" id="L42" title="1 of 2 branches missed.">@SuppressWarnings({&quot;UnusedDeclaration&quot;, &quot;WeakerAccess&quot;})</span>
public class Sentence {

  /** A Properties object for creating a document from a single sentence. Used in the constructor {@link Sentence#Sentence(String)} */
<span class="fc" id="L46">  static Properties SINGLE_SENTENCE_DOCUMENT = PropertiesUtils.asProperties(</span>
          &quot;language&quot;, &quot;english&quot;,
          &quot;ssplit.isOneSentence&quot;, &quot;true&quot;,
          &quot;tokenize.class&quot;, &quot;PTBTokenizer&quot;,
          &quot;tokenize.language&quot;, &quot;en&quot;);

  /** A Properties object for creating a document from a single tokenized sentence. */
<span class="fc" id="L53">  private static Properties SINGLE_SENTENCE_TOKENIZED_DOCUMENT = PropertiesUtils.asProperties(</span>
          &quot;language&quot;, &quot;english&quot;,
          &quot;ssplit.isOneSentence&quot;, &quot;true&quot;,
          &quot;tokenize.class&quot;, &quot;WhitespaceTokenizer&quot;,
          &quot;tokenize.language&quot;, &quot;en&quot;,
          &quot;tokenize.whitespace&quot;, &quot;true&quot;);  // redundant?

  /**
   *  The protobuf representation of a Sentence.
   *  Note that this does not necessarily have up to date token information.
   */
  private final CoreNLPProtos.Sentence.Builder impl;
  /** The protobuf representation of the tokens of a sentence. This has up-to-date information on the tokens */
  private final List&lt;CoreNLPProtos.Token.Builder&gt; tokensBuilders;
  /** The document this sentence is derived from */
  public final Document document;
  /** The default properties to use for annotators. */
  private final Properties defaultProps;
  /** The function to use to create a new document. This is used for the cased() and caseless() functions. */
  private final BiFunction&lt;Properties, String, Document&gt; docFn;

  /**
   * Create a new sentence, using the specified properties as the default properties.
   * @param doc The document to link this sentence to.
   * @param props The properties to use for tokenizing the sentence.
   */
<span class="fc" id="L79">  protected Sentence(Document doc, Properties props) {</span>
    // Set document
<span class="fc" id="L81">    this.document = doc;</span>
    // Set sentence
<span class="pc bpc" id="L83" title="1 of 2 branches missed.">    if (props.containsKey(&quot;ssplit.isOneSentence&quot;)) {</span>
<span class="fc" id="L84">      this.impl = this.document.sentence(0, props).impl;</span>
    } else {
<span class="nc" id="L86">      Properties modProps = new Properties(props);</span>
<span class="nc" id="L87">      modProps.setProperty(&quot;ssplit.isOneSentence&quot;, &quot;true&quot;);</span>
<span class="nc" id="L88">      this.impl = this.document.sentence(0, modProps).impl;</span>
    }
    // Set tokens
<span class="fc" id="L91">    this.tokensBuilders = document.sentence(0).tokensBuilders;</span>
    // Asserts
<span class="pc bpc" id="L93" title="2 of 4 branches missed.">    assert (this.document.sentence(0).impl == this.impl);</span>
<span class="pc bpc" id="L94" title="2 of 4 branches missed.">    assert (this.document.sentence(0).tokensBuilders == this.tokensBuilders);</span>
    // Set the default properties
<span class="fc bfc" id="L96" title="All 2 branches covered.">    if (props == SINGLE_SENTENCE_TOKENIZED_DOCUMENT) {</span>
<span class="fc" id="L97">      this.defaultProps = SINGLE_SENTENCE_DOCUMENT;  // no longer care about tokenization</span>
    } else {
<span class="fc" id="L99">      this.defaultProps = props;</span>
    }
<span class="fc" id="L101">    this.docFn = Document::new;</span>
<span class="fc" id="L102">  }</span>

  /**
   * Create a new sentence from some text, and some properties.
   * @param text The text of the sentence.
   * @param props The properties to use for the annotators.
   */
  public Sentence(String text, Properties props) {
<span class="fc" id="L110">    this(new Document(props, text), props);</span>
<span class="fc" id="L111">  }</span>

  /**
   * Create a new sentence from the given text, assuming the entire text is just one sentence.
   * @param text The text of the sentence.
   */
  public Sentence(String text) {
<span class="fc" id="L118">    this(text, SINGLE_SENTENCE_DOCUMENT);</span>
<span class="fc" id="L119">  }</span>


  /** The actual implementation of a tokenized sentence constructor */
  protected Sentence(Function&lt;String, Document&gt; doc, List&lt;String&gt; tokens, Properties props) {
<span class="fc" id="L124">    this(doc.apply(StringUtils.join(tokens.stream().map(x -&gt; x.replace(' ', 'ߝ' /* some random character */)), &quot; &quot;)), props);</span>
    // Clean up whitespace
<span class="fc bfc" id="L126" title="All 2 branches covered.">    for (int i = 0; i &lt; impl.getTokenCount(); ++i) {</span>
<span class="fc" id="L127">      this.impl.getTokenBuilder(i).setWord(this.impl.getTokenBuilder(i).getWord().replace('ߝ', ' '));</span>
<span class="fc" id="L128">      this.impl.getTokenBuilder(i).setValue(this.impl.getTokenBuilder(i).getValue().replace('ߝ', ' '));</span>
<span class="fc" id="L129">      this.tokensBuilders.get(i).setWord(this.tokensBuilders.get(i).getWord().replace('ߝ', ' '));</span>
<span class="fc" id="L130">      this.tokensBuilders.get(i).setValue(this.tokensBuilders.get(i).getValue().replace('ߝ', ' '));</span>
    }
<span class="fc" id="L132">  }</span>


  /**
   * Create a new sentence from the given tokenized text, assuming the entire text is just one sentence.
   * WARNING: This method may in rare cases (mostly when tokens themselves have whitespace in them)
   *          produce strange results; it's a bit of a hack around the default tokenizer.
   *
   * @param tokens The text of the sentence.
   */
  public Sentence(List&lt;String&gt; tokens) {
<span class="fc" id="L143">    this(Document::new, tokens, SINGLE_SENTENCE_TOKENIZED_DOCUMENT);</span>
<span class="fc" id="L144">  }</span>

  /**
   * Create a sentence from a saved protocol buffer.
   */
<span class="nc" id="L149">  protected Sentence(BiFunction&lt;Properties, String, Document&gt; docFn, CoreNLPProtos.Sentence proto, Properties props) {</span>
<span class="nc" id="L150">    this.impl = proto.toBuilder();</span>
    // Set tokens
<span class="nc" id="L152">    tokensBuilders = new ArrayList&lt;&gt;(this.impl.getTokenCount());</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">    for (int i = 0; i &lt; this.impl.getTokenCount(); ++i) {</span>
<span class="nc" id="L154">      tokensBuilders.add(this.impl.getToken(i).toBuilder());</span>
    }
    // Initialize document
<span class="nc" id="L157">    this.document = docFn.apply(props, proto.getText());</span>
<span class="nc" id="L158">    this.document.forceSentences(Collections.singletonList(this));</span>
    // Asserts
<span class="nc bnc" id="L160" title="All 4 branches missed.">    assert (this.document.sentence(0).impl == this.impl);</span>
<span class="nc bnc" id="L161" title="All 4 branches missed.">    assert (this.document.sentence(0).tokensBuilders == this.tokensBuilders);</span>
    // Set default props
<span class="nc" id="L163">    this.defaultProps = props;</span>
<span class="nc" id="L164">    this.docFn = docFn;</span>
<span class="nc" id="L165">  }</span>

  /**
   * Create a sentence from a saved protocol buffer.
   */
  public Sentence(CoreNLPProtos.Sentence proto) {
<span class="nc" id="L171">    this(Document::new, proto, SINGLE_SENTENCE_DOCUMENT);</span>

<span class="nc" id="L173">  }</span>

  /** Helper for creating a sentence from a document at a given index */
<span class="nc" id="L176">  protected Sentence(Document doc, int sentenceIndex) {</span>
<span class="nc" id="L177">    this.document = doc;</span>
<span class="nc" id="L178">    this.impl = doc.sentence(sentenceIndex).impl;</span>
    // Set tokens
<span class="nc" id="L180">    this.tokensBuilders = doc.sentence(sentenceIndex).tokensBuilders;</span>
    // Asserts
<span class="nc bnc" id="L182" title="All 4 branches missed.">    assert (this.document.sentence(sentenceIndex).impl == this.impl);</span>
<span class="nc bnc" id="L183" title="All 4 branches missed.">    assert (this.document.sentence(sentenceIndex).tokensBuilders == this.tokensBuilders);</span>
    // Set default props
<span class="nc" id="L185">    this.defaultProps = Document.EMPTY_PROPS;</span>
<span class="nc" id="L186">    this.docFn = doc.sentence(sentenceIndex).docFn;</span>
<span class="nc" id="L187">  }</span>

  /**
   * The canonical constructor of a sentence from a {@link edu.stanford.nlp.simple.Document}.
   * @param doc The document to link this sentence to.
   * @param proto The sentence implementation to use for this sentence.
   */
<span class="fc" id="L194">  protected Sentence(Document doc, CoreNLPProtos.Sentence.Builder proto, Properties defaultProps) {</span>
<span class="fc" id="L195">    this.document = doc;</span>
<span class="fc" id="L196">    this.impl = proto;</span>
<span class="fc" id="L197">    this.defaultProps = defaultProps;</span>
    // Set tokens
    // This is the _only_ place we are allowed to construct tokens builders
<span class="fc" id="L200">    tokensBuilders = new ArrayList&lt;&gt;(this.impl.getTokenCount());</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">    for (int i = 0; i &lt; this.impl.getTokenCount(); ++i) {</span>
<span class="fc" id="L202">      tokensBuilders.add(this.impl.getToken(i).toBuilder());</span>
    }
<span class="pc" id="L204">    this.docFn = (props, text) -&gt; MetaClass.create(doc.getClass().getName()).createInstance(props, text);</span>
<span class="fc" id="L205">  }</span>

  /**
   * Also sets the the text of the sentence. Used by {@link Document} internally
   *
   * @param doc The document to link this sentence to.
   * @param proto The sentence implementation to use for this sentence.
   * @param text The text for the sentence
   * @param defaultProps The default properties to use when annotating this sentence.
   */
  Sentence(Document doc, CoreNLPProtos.Sentence.Builder proto, String text, Properties defaultProps) {
<span class="fc" id="L216">    this(doc, proto, defaultProps);</span>
<span class="fc" id="L217">    this.impl.setText(text);</span>
<span class="fc" id="L218">  }</span>

  /** Helper for creating a sentence from a document and a CoreMap representation */
<span class="fc" id="L221">  protected Sentence(Document doc, CoreMap sentence) {</span>
<span class="fc" id="L222">    this.document = doc;</span>
<span class="pc bpc" id="L223" title="2 of 4 branches missed.">    assert ! doc.sentences().isEmpty();</span>
<span class="fc" id="L224">    this.impl = doc.sentence(0).impl;</span>
<span class="fc" id="L225">    this.tokensBuilders = doc.sentence(0).tokensBuilders;</span>
<span class="fc" id="L226">    this.defaultProps = Document.EMPTY_PROPS;</span>
<span class="pc" id="L227">    this.docFn = (props, text) -&gt; MetaClass.create(doc.getClass().getName()).createInstance(props, text);</span>
<span class="fc" id="L228">  }</span>

  /**
   * Convert a CoreMap into a simple Sentence object.
   * Note that this is a copy operation -- the implementing CoreMap will not be updated, and all of its
   * contents are copied over to the protocol buffer format backing the {@link Sentence} object.
   *
   * @param sentence The CoreMap representation of the sentence.
   */
  public Sentence(CoreMap sentence) {
<span class="fc" id="L238">    this(new Document(new Annotation(sentence.get(CoreAnnotations.TextAnnotation.class)) {{</span>
<span class="fc" id="L239">      set(CoreAnnotations.SentencesAnnotation.class, Collections.singletonList(sentence));</span>
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">      if (sentence.containsKey(CoreAnnotations.DocIDAnnotation.class)) {</span>
<span class="nc" id="L241">        set(CoreAnnotations.DocIDAnnotation.class, sentence.get(CoreAnnotations.DocIDAnnotation.class));</span>
      }
<span class="fc" id="L243">    }}), sentence);</span>
<span class="fc" id="L244">  }</span>

  /**
   * &lt;p&gt;
   *   Convert a sentence fragment (i.e., entailed sentence) into a simple sentence object.
   *   Like {@link Sentence#Sentence(CoreMap)}, this copies the information in the fragment into the underlying
   *   protobuf backed format.
   * &lt;/p&gt;
   *
   * @param sentence The sentence fragment to convert.
   */
  public Sentence(SentenceFragment sentence) {
<span class="nc" id="L256">    this(new ArrayCoreMap(32) {{</span>
<span class="nc" id="L257">      set(CoreAnnotations.TokensAnnotation.class, sentence.words);</span>
<span class="nc" id="L258">      set(CoreAnnotations.TextAnnotation.class, StringUtils.join(sentence.words.stream().map(CoreLabel::originalText), &quot; &quot;));</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">      if (sentence.words.isEmpty()) {</span>
<span class="nc" id="L260">        set(CoreAnnotations.TokenBeginAnnotation.class, 0);</span>
<span class="nc" id="L261">        set(CoreAnnotations.TokenEndAnnotation.class, 0);</span>
      } else {
<span class="nc" id="L263">        set(CoreAnnotations.TokenBeginAnnotation.class, sentence.words.get(0).get(CoreAnnotations.IndexAnnotation.class));</span>
<span class="nc" id="L264">        set(CoreAnnotations.TokenEndAnnotation.class, sentence.words.get(sentence.words.size() - 1).get(CoreAnnotations.IndexAnnotation.class) + 1);</span>
      }
<span class="nc" id="L266">      set(SemanticGraphCoreAnnotations.BasicDependenciesAnnotation.class, sentence.parseTree);</span>
<span class="nc" id="L267">      set(SemanticGraphCoreAnnotations.EnhancedDependenciesAnnotation.class, sentence.parseTree);</span>
<span class="nc" id="L268">      set(SemanticGraphCoreAnnotations.EnhancedPlusPlusDependenciesAnnotation.class, sentence.parseTree);</span>
<span class="nc" id="L269">    }});</span>
<span class="nc" id="L270">  }</span>


  /**
   * Make this sentence caseless. That is, from now on, run the caseless models
   * on the sentence by default rather than the standard CoreNLP models.
   *
   * @return A new sentence with the default properties swapped out.
   */
  public Sentence caseless() {
<span class="nc" id="L280">    return new Sentence(this.docFn, impl.build(), Document.CASELESS_PROPS);</span>
  }

  /**
   * Make this sentence case sensitive.
   * A sentence is case sensitive by default; this only has an effect if you have previously
   * called {@link Sentence#caseless()}.
   *
   * @return A new sentence with the default properties swapped out.
   */
  public Sentence cased() {
<span class="nc" id="L291">    return new Sentence(this.docFn, impl.build(), Document.EMPTY_PROPS);</span>
  }


  /**
   * Serialize the given sentence (but not the associated document!) into a Protocol Buffer.
   * @return The Protocol Buffer representing this sentence.
   */
  public CoreNLPProtos.Sentence serialize() {
<span class="fc" id="L300">    synchronized (impl) {</span>
<span class="fc" id="L301">      this.impl.clearToken();</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">      for (CoreNLPProtos.Token.Builder token : this.tokensBuilders) {</span>
<span class="fc" id="L303">        this.impl.addToken(token.build());</span>
<span class="fc" id="L304">      }</span>
<span class="fc" id="L305">      return impl.build();</span>
<span class="nc" id="L306">    }</span>
  }

  /**
   * Write this sentence to an output stream.
   * Internally, this stores the sentence as a protocol buffer, and saves that buffer to the output stream.
   * This method does not close the stream after writing.
   *
   * @param out The output stream to write to. The stream is not closed after the method returns.
   * @throws IOException Thrown from the underlying write() implementation.
   */
  public void serialize(OutputStream out) throws IOException {
<span class="nc" id="L318">    serialize().writeDelimitedTo(out);</span>
<span class="nc" id="L319">    out.flush();</span>
<span class="nc" id="L320">  }</span>

  /**
   * Read a sentence from an input stream.
   * This does not close the input stream.
   *
   * @param in The input stream to deserialize from.
   * @return The next sentence encoded in the input stream.
   * @throws IOException Thrown by the underlying parse() implementation.
   *
   * @see Document#serialize(java.io.OutputStream)
   */
  public static Sentence deserialize(InputStream in) throws IOException {
<span class="nc" id="L333">    return new Sentence(CoreNLPProtos.Sentence.parseDelimitedFrom(in));</span>
  }

  /**
   * Return a class that can perform common algorithms on this sentence.
   */
  public SentenceAlgorithms algorithms() {
<span class="nc" id="L340">    return new SentenceAlgorithms(this);</span>
  }

  /** The raw text of the sentence, as input by, e.g., {@link Sentence#Sentence(String)}. */
  public String text() {
<span class="fc" id="L345">    synchronized (impl) {</span>
<span class="fc" id="L346">      return impl.getText();</span>
<span class="nc" id="L347">    }</span>
  }

  //
  // SET AXIOMATICALLY
  //

  /** The index of the sentence within the document. */
  public int sentenceIndex() {
<span class="fc" id="L356">    synchronized (impl) {</span>
<span class="fc" id="L357">      return impl.getSentenceIndex();</span>
<span class="nc" id="L358">    }</span>
  }

  /** THe token offset of the sentence within the document. */
  public int sentenceTokenOffsetBegin() {
<span class="fc" id="L363">    synchronized (impl) {</span>
<span class="fc" id="L364">      return impl.getTokenOffsetBegin();</span>
<span class="nc" id="L365">    }</span>
  }

  /** The token offset of the end of this sentence within the document. */
  public int sentenceTokenOffsetEnd() {
<span class="fc" id="L370">    synchronized (impl) {</span>
<span class="fc" id="L371">      return impl.getTokenOffsetEnd();</span>
<span class="nc" id="L372">    }</span>
  }

  //
  // SET BY TOKENIZER
  //

  /** The words of the sentence, as per {@link edu.stanford.nlp.ling.CoreLabel#word()}. */
  public List&lt;String&gt; words() {
<span class="fc" id="L381">    synchronized (impl) {</span>
<span class="fc" id="L382">      return lazyList(tokensBuilders, CoreNLPProtos.Token.Builder::getWord);</span>
<span class="nc" id="L383">    }</span>
  }

  /** The word at the given index of the sentence. @see Sentence#words() */
  public String word(int index) {
<span class="fc" id="L388">    return words().get(index);</span>
  }

  /** The original (unprocessed) words of the sentence, as per {@link edu.stanford.nlp.ling.CoreLabel#originalText()}. */
  public List&lt;String&gt; originalTexts() {
<span class="fc" id="L393">    synchronized (impl) {</span>
<span class="fc" id="L394">      return lazyList(tokensBuilders, CoreNLPProtos.Token.Builder::getOriginalText);</span>
<span class="nc" id="L395">    }</span>
  }

  /** The original word at the given index. @see Sentence#originalTexts() */
  public String originalText(int index) {
<span class="fc" id="L400">    return originalTexts().get(index);</span>
  }

  /** The character offset of each token in the sentence, as per {@link edu.stanford.nlp.ling.CoreLabel#beginPosition()}. */
  public List&lt;Integer&gt; characterOffsetBegin() {
<span class="fc" id="L405">    synchronized (impl) {</span>
<span class="fc" id="L406">      return lazyList(tokensBuilders, CoreNLPProtos.Token.Builder::getBeginChar);</span>
<span class="nc" id="L407">    }</span>
  }

  /** The character offset of the given index in the sentence. @see Sentence#characterOffsetBegin(). */
  public int characterOffsetBegin(int index) {
<span class="fc" id="L412">    return characterOffsetBegin().get(index);</span>
  }

  /** The end character offset of each token in the sentence, as per {@link edu.stanford.nlp.ling.CoreLabel#endPosition()}. */
  public List&lt;Integer&gt; characterOffsetEnd() {
<span class="fc" id="L417">    synchronized (impl) {</span>
<span class="fc" id="L418">      return lazyList(tokensBuilders, CoreNLPProtos.Token.Builder::getEndChar);</span>
<span class="nc" id="L419">    }</span>
  }

  /** The end character offset of the given index in the sentence. @see Sentence#characterOffsetEnd(). */
  public int characterOffsetEnd(int index) {
<span class="fc" id="L424">    return characterOffsetEnd().get(index);</span>
  }

  //
  // SET BY ANNOTATORS
  //

  /**
   * The part of speech tags of the sentence.
   * @param props The properties to use for the {@link edu.stanford.nlp.pipeline.POSTaggerAnnotator}.
   * @return A list of part of speech tags, one for each token in the sentence.
   */
  public List&lt;String&gt; posTags(Properties props) {
<span class="nc" id="L437">    document.runPOS(props);</span>
<span class="nc" id="L438">    synchronized (impl) {</span>
<span class="nc" id="L439">      return lazyList(tokensBuilders, CoreNLPProtos.Token.Builder::getPos);</span>
<span class="nc" id="L440">    }</span>
  }

  /** @see Sentence#posTags(java.util.Properties) */
  public List&lt;String&gt; posTags() {
<span class="nc" id="L445">    return posTags(this.defaultProps);</span>
  }

  /** @see Sentence#posTags(java.util.Properties) */
  public String posTag(int index) {
<span class="nc" id="L450">    return posTags().get(index);</span>
  }

  /**
   * The lemmas of the sentence.
   * @param props The properties to use for the {@link edu.stanford.nlp.pipeline.MorphaAnnotator}.
   * @return A list of lemmatized words, one for each token in the sentence.
   */
  public List&lt;String&gt; lemmas(Properties props) {
<span class="nc" id="L459">    document.runLemma(props);</span>
<span class="nc" id="L460">    synchronized (impl) {</span>
<span class="nc" id="L461">      return lazyList(tokensBuilders, CoreNLPProtos.Token.Builder::getLemma);</span>
<span class="nc" id="L462">    }</span>
  }

  /** @see Sentence#lemmas(java.util.Properties) */
  public List&lt;String&gt; lemmas() {
<span class="nc" id="L467">    return lemmas(this.defaultProps);</span>
  }

  /** @see Sentence#lemmas(java.util.Properties) */
  public String lemma(int index) {
<span class="nc" id="L472">    return lemmas().get(index);</span>
  }

  /**
   * The named entity tags of the sentence.
   * @param props The properties to use for the {@link edu.stanford.nlp.pipeline.NERCombinerAnnotator}.
   * @return A list of named entity tags, one for each token in the sentence.
   */
  public List&lt;String&gt; nerTags(Properties props) {
<span class="nc" id="L481">    document.runNER(props);</span>
<span class="nc" id="L482">    synchronized (impl) {</span>
<span class="nc" id="L483">      return lazyList(tokensBuilders, CoreNLPProtos.Token.Builder::getNer);</span>
<span class="nc" id="L484">    }</span>
  }

  /** @see Sentence#nerTags(java.util.Properties) */
  public List&lt;String&gt; nerTags() {
<span class="nc" id="L489">    return nerTags(this.defaultProps);</span>
  }

  /**
   * Run RegexNER over this sentence. Note that this is an in place operation, and simply
   * updates the NER tags.
   * Therefore, every time this function is called, it re-runs the annotator!
   *
   * @param mappingFile The regexner mapping file.
   * @param ignorecase If true, run a caseless match on the regexner file.
   *
   */
  public void regexner(String mappingFile, boolean ignorecase) {
<span class="nc" id="L502">    Properties props = new Properties();</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">    for (Object prop : this.defaultProps.keySet()) {</span>
<span class="nc" id="L504">      props.setProperty(prop.toString(), this.defaultProps.getProperty(prop.toString()));</span>
<span class="nc" id="L505">    }</span>
<span class="nc" id="L506">    props.setProperty(Annotator.STANFORD_REGEXNER + &quot;.mapping&quot;, mappingFile);</span>
<span class="nc" id="L507">    props.setProperty(Annotator.STANFORD_REGEXNER + &quot;.ignorecase&quot;, Boolean.toString(ignorecase));</span>
<span class="nc" id="L508">    this.document.runRegexner(props);</span>
<span class="nc" id="L509">  }</span>

  /** @see Sentence#nerTags(java.util.Properties) */
  public String nerTag(int index) {
<span class="nc" id="L513">    return nerTags().get(index);</span>
  }

  /**
   * Get all mentions of the given NER tag, as a list of surface forms.
   * @param nerTag The ner tag to search for, case sensitive.
   * @return A list of surface forms of the entities of this tag. This is using the {@link Sentence#word(int)} function.
   */
  public List&lt;String&gt; mentions(String nerTag) {
<span class="nc" id="L522">    List&lt;String&gt; mentionsOfTag = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L523">    StringBuilder lastMention = new StringBuilder();</span>
<span class="nc" id="L524">    String lastTag = &quot;O&quot;;</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">    for (int i = 0; i &lt; length(); ++i) {</span>
<span class="nc" id="L526">      String ner = nerTag(i);</span>
<span class="nc bnc" id="L527" title="All 4 branches missed.">      if (ner.equals(nerTag) &amp;&amp; !lastTag.equals(nerTag)) {</span>
        // case: beginning of span
<span class="nc" id="L529">        lastMention.append(word(i)).append(' ');</span>
<span class="nc bnc" id="L530" title="All 4 branches missed.">      } else if (ner.equals(nerTag) &amp;&amp; lastTag.equals(nerTag)) {</span>
        // case: in span
<span class="nc" id="L532">        lastMention.append(word(i)).append(' ');</span>
<span class="nc bnc" id="L533" title="All 4 branches missed.">      } else if (!ner.equals(nerTag) &amp;&amp; lastTag.equals(nerTag)) {</span>
        // case: end of span
<span class="nc bnc" id="L535" title="All 2 branches missed.">        if (lastMention.length() &gt; 0) {</span>
<span class="nc" id="L536">          mentionsOfTag.add(lastMention.toString().trim());</span>
        }
<span class="nc" id="L538">        lastMention.setLength(0);</span>
      }
<span class="nc" id="L540">      lastTag = ner;</span>
    }
<span class="nc bnc" id="L542" title="All 2 branches missed.">    if (lastMention.length() &gt; 0) {</span>
<span class="nc" id="L543">      mentionsOfTag.add(lastMention.toString().trim());</span>
    }
<span class="nc" id="L545">    return mentionsOfTag;</span>
  }

  /**
   * Get all mentions of any NER tag, as a list of surface forms.
   * @return A list of surface forms of the entities in this sentence. This is using the {@link Sentence#word(int)} function.
   */
  public List&lt;String&gt; mentions() {
<span class="nc" id="L553">    List&lt;String&gt; mentionsOfTag = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L554">    StringBuilder lastMention = new StringBuilder();</span>
<span class="nc" id="L555">    String lastTag = &quot;O&quot;;</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">    for (int i = 0; i &lt; length(); ++i) {</span>
<span class="nc" id="L557">      String ner = nerTag(i);</span>
<span class="nc bnc" id="L558" title="All 4 branches missed.">      if (!ner.equals(&quot;O&quot;) &amp;&amp; !lastTag.equals(ner)) {</span>
        // case: beginning of span
<span class="nc bnc" id="L560" title="All 2 branches missed.">        if (lastMention.length() &gt; 0) {</span>
<span class="nc" id="L561">          mentionsOfTag.add(lastMention.toString().trim());</span>
        }
<span class="nc" id="L563">        lastMention.setLength(0);</span>
<span class="nc" id="L564">        lastMention.append(word(i)).append(' ');</span>
<span class="nc bnc" id="L565" title="All 4 branches missed.">      } else if (!ner.equals(&quot;O&quot;) &amp;&amp; lastTag.equals(ner)) {</span>
        // case: in span
<span class="nc" id="L567">        lastMention.append(word(i)).append(' ');</span>
<span class="nc bnc" id="L568" title="All 4 branches missed.">      } else if (ner.equals(&quot;O&quot;) &amp;&amp; !lastTag.equals(&quot;O&quot;)) {</span>
        // case: end of span
<span class="nc bnc" id="L570" title="All 2 branches missed.">        if (lastMention.length() &gt; 0) {</span>
<span class="nc" id="L571">          mentionsOfTag.add(lastMention.toString().trim());</span>
        }
<span class="nc" id="L573">        lastMention.setLength(0);</span>
      }
<span class="nc" id="L575">      lastTag = ner;</span>
    }
<span class="nc bnc" id="L577" title="All 2 branches missed.">    if (lastMention.length() &gt; 0) {</span>
<span class="nc" id="L578">      mentionsOfTag.add(lastMention.toString().trim());</span>
    }
<span class="nc" id="L580">    return mentionsOfTag;</span>
  }

  /**
   * Returns the constituency parse of this sentence.
   *
   * @param props The properties to use in the parser annotator.
   * @return A parse tree object.
   */
  public Tree parse(Properties props) {
<span class="nc" id="L590">    document.runParse(props);</span>
<span class="nc" id="L591">    synchronized (document.serializer) {</span>
<span class="nc" id="L592">      return document.serializer.fromProto(impl.getParseTree());</span>
<span class="nc" id="L593">    }</span>
  }

  /** @see Sentence#parse(java.util.Properties) */
  public Tree parse() {
<span class="nc" id="L598">    return parse(this.defaultProps);</span>
  }


  /** An internal helper to get the dependency tree of the given type. */
  private CoreNLPProtos.DependencyGraph dependencies(SemanticGraphFactory.Mode mode) {
<span class="nc bnc" id="L604" title="All 4 branches missed.">    switch (mode) {</span>
      case BASIC:
<span class="nc" id="L606">        return impl.getBasicDependencies();</span>
      case ENHANCED:
<span class="nc" id="L608">        return impl.getEnhancedDependencies();</span>
      case ENHANCED_PLUS_PLUS:
<span class="nc" id="L610">        return impl.getEnhancedPlusPlusDependencies();</span>
      default:
<span class="nc" id="L612">        throw new IllegalArgumentException(&quot;Unsupported dependency type: &quot; + mode);</span>
    }
  }

  /**
   * Returns the governor of the given index, according to the passed dependency type.
   * The root has index -1.
   *
   * @param props The properties to use in the parser annotator.
   * @param index The index of the dependent word ZERO INDEXED. That is, the first word of the sentence
   *              is index 0, not 1 as it would be in the {@link edu.stanford.nlp.semgraph.SemanticGraph} framework.
   * @param mode  The type of dependency to use (e.g., basic, collapsed, collapsed cc processed).
   * @return The index of the governor, if one exists. A value of -1 indicates the root node.
   */
  public Optional&lt;Integer&gt; governor(Properties props, int index, SemanticGraphFactory.Mode mode) {
<span class="nc" id="L627">    document.runDepparse(props);</span>
<span class="nc bnc" id="L628" title="All 2 branches missed.">    for (CoreNLPProtos.DependencyGraph.Edge edge : dependencies(mode).getEdgeList()) {</span>
<span class="nc bnc" id="L629" title="All 2 branches missed.">      if (edge.getTarget() - 1 == index) {</span>
<span class="nc" id="L630">        return Optional.of(edge.getSource() - 1);</span>
      }
<span class="nc" id="L632">    }</span>
<span class="nc bnc" id="L633" title="All 2 branches missed.">    for (int root : impl.getBasicDependencies().getRootList()) {</span>
<span class="nc bnc" id="L634" title="All 2 branches missed.">      if (index == root - 1) { return Optional.of(-1); }</span>
<span class="nc" id="L635">    }</span>
<span class="nc" id="L636">    return Optional.empty();</span>
  }

  /** @see Sentence#governor(java.util.Properties, int, SemanticGraphFactory.Mode) */
  public Optional&lt;Integer&gt; governor(Properties props, int index) {
<span class="nc" id="L641">    return governor(props, index, SemanticGraphFactory.Mode.ENHANCED);</span>
  }

  /** @see Sentence#governor(java.util.Properties, int, SemanticGraphFactory.Mode) */
  public Optional&lt;Integer&gt; governor(int index, SemanticGraphFactory.Mode mode) {
<span class="nc" id="L646">    return governor(this.defaultProps, index, mode);</span>
  }

  /** @see Sentence#governor(java.util.Properties, int) */
  public Optional&lt;Integer&gt; governor(int index) {
<span class="nc" id="L651">    return governor(this.defaultProps, index);</span>
  }

  /**
   * Returns the governors of a sentence, according to the passed dependency type.
   * The resulting list is of the same size as the original sentence, with each element being either
   * the governor (index), or empty if the node has no known governor.
   * The root has index -1.
   *
   * @param props The properties to use in the parser annotator.
   * @param mode  The type of dependency to use (e.g., basic, collapsed, collapsed cc processed).
   * @return A list of the (optional) governors of each token in the sentence.
   */
  public List&lt;Optional&lt;Integer&gt;&gt; governors(Properties props, SemanticGraphFactory.Mode mode) {
<span class="nc" id="L665">    document.runDepparse(props);</span>
<span class="nc" id="L666">    List&lt;Optional&lt;Integer&gt;&gt; governors = new ArrayList&lt;&gt;(this.length());</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">    for (int i = 0; i &lt; this.length(); ++i) { governors.add(Optional.empty()); }</span>
<span class="nc bnc" id="L668" title="All 2 branches missed.">    for (CoreNLPProtos.DependencyGraph.Edge edge : dependencies(mode).getEdgeList()) {</span>
<span class="nc" id="L669">      governors.set(edge.getTarget() - 1, Optional.of(edge.getSource() - 1));</span>
<span class="nc" id="L670">    }</span>
<span class="nc bnc" id="L671" title="All 2 branches missed.">    for (int root : impl.getBasicDependencies().getRootList()) {</span>
<span class="nc" id="L672">      governors.set(root - 1, Optional.of(-1));</span>
<span class="nc" id="L673">    }</span>
<span class="nc" id="L674">    return governors;</span>
  }

  /** @see Sentence#governors(java.util.Properties, SemanticGraphFactory.Mode) */
  public List&lt;Optional&lt;Integer&gt;&gt; governors(Properties props) {
<span class="nc" id="L679">    return governors(props, SemanticGraphFactory.Mode.ENHANCED);</span>
  }

  /** @see Sentence#governors(java.util.Properties, SemanticGraphFactory.Mode) */
  public List&lt;Optional&lt;Integer&gt;&gt; governors(SemanticGraphFactory.Mode mode) {
<span class="nc" id="L684">    return governors(this.defaultProps, mode);</span>
  }

  /** @see Sentence#governors(java.util.Properties, SemanticGraphFactory.Mode) */
  public List&lt;Optional&lt;Integer&gt;&gt; governors() {
<span class="nc" id="L689">    return governors(this.defaultProps, SemanticGraphFactory.Mode.ENHANCED);</span>
  }

  /**
   * Returns the incoming dependency label to a particular index, according to the Basic Dependencies.
   *
   * @param props The properties to use in the parser annotator.
   * @param index The index of the dependent word ZERO INDEXED. That is, the first word of the sentence
   *              is index 0, not 1 as it would be in the {@link edu.stanford.nlp.semgraph.SemanticGraph} framework.
   * @param mode  The type of dependency to use (e.g., basic, collapsed, collapsed cc processed).
   * @return The incoming dependency label, if it exists.
   */
  public Optional&lt;String&gt; incomingDependencyLabel(Properties props, int index, SemanticGraphFactory.Mode mode) {
<span class="nc" id="L702">    document.runDepparse(props);</span>
<span class="nc bnc" id="L703" title="All 2 branches missed.">    for (CoreNLPProtos.DependencyGraph.Edge edge : dependencies(mode).getEdgeList()) {</span>
<span class="nc bnc" id="L704" title="All 2 branches missed.">      if (edge.getTarget() - 1 == index) {</span>
<span class="nc" id="L705">        return Optional.of(edge.getDep());</span>
      }
<span class="nc" id="L707">    }</span>
<span class="nc bnc" id="L708" title="All 2 branches missed.">    for (int root : impl.getBasicDependencies().getRootList()) {</span>
<span class="nc bnc" id="L709" title="All 2 branches missed.">      if (index == root - 1) { return Optional.of(&quot;root&quot;); }</span>
<span class="nc" id="L710">    }</span>
<span class="nc" id="L711">    return Optional.empty();</span>
  }

  /** @see Sentence#incomingDependencyLabel(java.util.Properties, int, SemanticGraphFactory.Mode) */
  public Optional&lt;String&gt; incomingDependencyLabel(Properties props, int index) {
<span class="nc" id="L716">    return incomingDependencyLabel(props, index, SemanticGraphFactory.Mode.ENHANCED);</span>
  }

  /** @see Sentence#incomingDependencyLabel(java.util.Properties, int, SemanticGraphFactory.Mode) */
  public Optional&lt;String&gt; incomingDependencyLabel(int index, SemanticGraphFactory.Mode mode) {
<span class="nc" id="L721">    return incomingDependencyLabel(this.defaultProps, index, mode);</span>
  }

  /** @see Sentence#incomingDependencyLabel(java.util.Properties, int) */
  public Optional&lt;String&gt; incomingDependencyLabel(int index) {
<span class="nc" id="L726">    return incomingDependencyLabel(this.defaultProps, index);</span>
  }

  /** @see Sentence#incomingDependencyLabel(java.util.Properties, int) */
  public List&lt;Optional&lt;String&gt;&gt; incomingDependencyLabels(Properties props, SemanticGraphFactory.Mode mode) {
<span class="nc" id="L731">    document.runDepparse(props);</span>
<span class="nc" id="L732">    List&lt;Optional&lt;String&gt;&gt; labels = new ArrayList&lt;&gt;(this.length());</span>
<span class="nc bnc" id="L733" title="All 2 branches missed.">    for (int i = 0; i &lt; this.length(); ++i) { labels.add(Optional.empty()); }</span>
<span class="nc bnc" id="L734" title="All 2 branches missed.">    for (CoreNLPProtos.DependencyGraph.Edge edge : dependencies(mode).getEdgeList()) {</span>
<span class="nc" id="L735">      labels.set(edge.getTarget() - 1, Optional.of(edge.getDep()));</span>
<span class="nc" id="L736">    }</span>
<span class="nc bnc" id="L737" title="All 2 branches missed.">    for (int root : impl.getBasicDependencies().getRootList()) {</span>
<span class="nc" id="L738">      labels.set(root - 1, Optional.of(&quot;root&quot;));</span>
<span class="nc" id="L739">    }</span>
<span class="nc" id="L740">    return labels;</span>
  }

  /** @see Sentence#incomingDependencyLabels(java.util.Properties, SemanticGraphFactory.Mode) */
  public List&lt;Optional&lt;String&gt;&gt; incomingDependencyLabels(SemanticGraphFactory.Mode mode) {
<span class="nc" id="L745">    return incomingDependencyLabels(this.defaultProps, mode);</span>
  }

  /** @see Sentence#incomingDependencyLabels(java.util.Properties, SemanticGraphFactory.Mode) */
  public List&lt;Optional&lt;String&gt;&gt; incomingDependencyLabels(Properties props) {
<span class="nc" id="L750">    return incomingDependencyLabels(props, SemanticGraphFactory.Mode.ENHANCED);</span>
  }

  /** @see Sentence#incomingDependencyLabels(java.util.Properties, SemanticGraphFactory.Mode) */
  public List&lt;Optional&lt;String&gt;&gt; incomingDependencyLabels() {
<span class="nc" id="L755">    return incomingDependencyLabels(this.defaultProps, SemanticGraphFactory.Mode.ENHANCED);</span>
  }


  /**
   * Returns the dependency graph of the sentence, as a raw {@link SemanticGraph} object.
   * Note that this method is slower than you may expect, as it has to convert the underlying protocol
   * buffer back into a list of CoreLabels with which to populate the {@link SemanticGraph}.
   *
   * @param props The properties to use for running the dependency parser annotator.
   * @param mode The type of graph to return (e.g., basic, collapsed, etc).
   *
   * @return The dependency graph of the sentence.
   */
  public SemanticGraph dependencyGraph(Properties props, SemanticGraphFactory.Mode mode) {
<span class="nc" id="L770">    document.runDepparse(props);</span>
<span class="nc" id="L771">    return ProtobufAnnotationSerializer.fromProto(dependencies(mode), asCoreLabels(), document.docid().orElse(null));</span>
  }

  /** @see Sentence#dependencyGraph(Properties, SemanticGraphFactory.Mode) */
  public SemanticGraph dependencyGraph(Properties props) {
<span class="nc" id="L776">    return dependencyGraph(props, SemanticGraphFactory.Mode.ENHANCED);</span>
  }

  /** @see Sentence#dependencyGraph(Properties, SemanticGraphFactory.Mode) */
  public SemanticGraph dependencyGraph() {
<span class="nc" id="L781">    return dependencyGraph(this.defaultProps, SemanticGraphFactory.Mode.ENHANCED);</span>
  }

  /** @see Sentence#dependencyGraph(Properties, SemanticGraphFactory.Mode) */
  public SemanticGraph dependencyGraph(SemanticGraphFactory.Mode mode) {
<span class="nc" id="L786">    return dependencyGraph(this.defaultProps, mode);</span>
  }

  /** The length of the sentence, in tokens */
  public int length() {
<span class="fc" id="L791">    return impl.getTokenCount();</span>
  }

  /**
   * Get a list of the (possible) Natural Logic operators on each node of the sentence.
   * At each index, the list contains an operator spec if that index is the head word of an operator in the
   * sentence.
   *
   * @param props The properties to pass to the natural logic annotator.
   * @return A list of Optionals, where each element corresponds to a token in the sentence, and the optional is nonempty
   *         if that index is an operator.
   */
  public List&lt;Optional&lt;OperatorSpec&gt;&gt; operators(Properties props) {
<span class="nc" id="L804">    document.runNatlog(props);</span>
<span class="nc" id="L805">    synchronized (impl) {</span>
<span class="nc bnc" id="L806" title="All 2 branches missed.">      return lazyList(tokensBuilders, x -&gt; x.hasOperator() ? Optional.of(ProtobufAnnotationSerializer.fromProto(x.getOperator())) : Optional.empty());</span>
<span class="nc" id="L807">    }</span>
  }

  /** @see Sentence#operators(Properties) */
  public List&lt;Optional&lt;OperatorSpec&gt;&gt; operators() {
<span class="nc" id="L812">    return operators(this.defaultProps);</span>
  }

  /** @see Sentence#operators(Properties) */
  public Optional&lt;OperatorSpec&gt; operatorAt(Properties props, int i) {
<span class="nc" id="L817">    return operators(props).get(i);</span>
  }


  /** @see Sentence#operators(Properties) */
  public Optional&lt;OperatorSpec&gt; operatorAt(int i) {
<span class="nc" id="L823">    return operators(this.defaultProps).get(i);</span>
  }

  /**
   * Returns the list of non-empty Natural Logic operator specifications.
   * This amounts to the actual list of operators in the sentence.
   * Note that the spans of the operators can be retrieved with
   * {@link OperatorSpec#quantifierBegin} and
   * {@link OperatorSpec#quantifierEnd}.
   *
   * @param props The properties to use for the natlog annotator.
   * @return A list of operators in the sentence.
   */
  public List&lt;OperatorSpec&gt; operatorsNonempty(Properties props) {
<span class="nc" id="L837">    return operators(props).stream().filter(Optional::isPresent).map(Optional::get).collect(Collectors.toList());</span>
  }

  /** @see Sentence#operatorsNonempty(Properties) */
  public List&lt;OperatorSpec&gt; operatorsNonempty() {
<span class="nc" id="L842">    return operatorsNonempty(this.defaultProps);</span>
  }

  /**
   * The Natural Logic notion of polarity for each token in a sentence.
   * @param props The properties to use for the natural logic annotator.
   * @return A list of Polarity objects, one for each token of the sentence.
   */
  public List&lt;Polarity&gt; natlogPolarities(Properties props) {
<span class="nc" id="L851">    document.runNatlog(props);</span>
<span class="nc" id="L852">    synchronized (impl) {</span>
<span class="nc" id="L853">      return lazyList(tokensBuilders, x -&gt; ProtobufAnnotationSerializer.fromProto(x.getPolarity()));</span>
<span class="nc" id="L854">    }</span>
  }

  /** @see Sentence#natlogPolarities(Properties) */
  public List&lt;Polarity&gt; natlogPolarities() {
<span class="nc" id="L859">    return natlogPolarities(this.defaultProps);</span>
  }

  /**
   * Get the polarity (the Natural Logic notion of polarity) for a given token in the sentence.
   * @param props The properties to use for the natural logic annotator.
   * @param index The index to return the polarity of.
   * @return A list of Polarity objects, one for each token of the sentence.
   */
  public Polarity natlogPolarity(Properties props, int index) {
<span class="nc" id="L869">    document.runNatlog(props);</span>
<span class="nc" id="L870">    synchronized (impl) {</span>
<span class="nc" id="L871">      return ProtobufAnnotationSerializer.fromProto(tokensBuilders.get(index).getPolarity());</span>
<span class="nc" id="L872">    }</span>
  }

  /** @see Sentence#natlogPolarity(Properties, int) */
  public Polarity natlogPolarity(int index) {
<span class="nc" id="L877">    return natlogPolarity(this.defaultProps, index);</span>
  }


  /**
   * Get the OpenIE triples associated with this sentence.
   * Note that this function may be slower than you would expect, as it has to
   * convert the underlying Protobuf representation back into {@link CoreLabel}s.
   *
   * @param props The properties to use for the OpenIE annotator.
   * @return A collection of {@link RelationTriple} objects representing the OpenIE triples in the sentence.
   */
  public Collection&lt;RelationTriple&gt; openieTriples(Properties props) {
<span class="nc" id="L890">    document.runOpenie(props);</span>
<span class="nc" id="L891">    synchronized (impl) {</span>
<span class="nc" id="L892">      List&lt;CoreLabel&gt; tokens = asCoreLabels();</span>
<span class="nc" id="L893">      Annotation doc = document.asAnnotation();</span>
<span class="nc" id="L894">      return impl.getOpenieTripleList().stream().map(x -&gt; ProtobufAnnotationSerializer.fromProto(x, doc, this.sentenceIndex())).collect(Collectors.toList());</span>
<span class="nc" id="L895">    }</span>
  }

  /** @see Sentence@openieTriples(Properties) */
  public Collection&lt;RelationTriple&gt; openieTriples() {
<span class="nc" id="L900">    return openieTriples(this.defaultProps);</span>
  }

  /**
   * Get a list of Open IE triples as flat (subject, relation, object, confidence) quadruples.
   * This is substantially faster than returning {@link RelationTriple} objects, as it doesn't
   * require converting the underlying representation into {@link CoreLabel}s; but, it also contains
   * significantly less information about the sentence.
   *
   * @see Sentence@openieTriples(Properties)
   */
  public Collection&lt;Quadruple&lt;String, String, String, Double&gt;&gt; openie() {
<span class="nc" id="L912">    document.runOpenie(this.defaultProps);</span>
<span class="nc" id="L913">    return impl.getOpenieTripleList().stream()</span>
<span class="nc bnc" id="L914" title="All 6 branches missed.">        .filter(proto -&gt; proto.hasSubject() &amp;&amp; proto.hasRelation() &amp;&amp; proto.hasObject())</span>
<span class="nc" id="L915">        .map(proto -&gt; Quadruple.makeQuadruple(proto.getSubject(), proto.getRelation(), proto.getObject(),</span>
<span class="nc bnc" id="L916" title="All 2 branches missed.">            proto.hasConfidence() ? proto.getConfidence() : 1.0))</span>
<span class="nc" id="L917">        .collect(Collectors.toList());</span>
  }


  /**
   * Get the KBP triples associated with this sentence.
   * Note that this function may be slower than you would expect, as it has to
   * convert the underlying Protobuf representation back into {@link CoreLabel}s.
   *
   * @param props The properties to use for the KBP annotator.
   * @return A collection of {@link RelationTriple} objects representing the KBP triples in the sentence.
   */
  public Collection&lt;RelationTriple&gt; kbpTriples(Properties props) {
<span class="nc" id="L930">    document.runKBP(props);</span>
<span class="nc" id="L931">    synchronized (impl) {</span>
<span class="nc" id="L932">      List&lt;CoreLabel&gt; tokens = asCoreLabels();</span>
<span class="nc" id="L933">      Annotation doc = document.asAnnotation();</span>
<span class="nc" id="L934">      return impl.getKbpTripleList().stream().map(x -&gt; ProtobufAnnotationSerializer.fromProto(x, doc, this.sentenceIndex())).collect(Collectors.toList());</span>
<span class="nc" id="L935">    }</span>
  }

  /** @see Sentence@kbpTriples(Properties) */
  public Collection&lt;RelationTriple&gt; kbpTriples() {
<span class="nc" id="L940">    return kbpTriples(this.defaultProps);</span>
  }

  /**
   * Get a list of KBP triples as flat (subject, relation, object, confidence) quadruples.
   * This is substantially faster than returning {@link RelationTriple} objects, as it doesn't
   * require converting the underlying representation into {@link CoreLabel}s; but, it also contains
   * significantly less information about the sentence.
   *
   * @see Sentence@kbpTriples(Properties)
   */
  public Collection&lt;Quadruple&lt;String, String, String, Double&gt;&gt; kbp() {
<span class="nc" id="L952">    document.runKBP(this.defaultProps);</span>
<span class="nc" id="L953">    return impl.getKbpTripleList().stream()</span>
<span class="nc bnc" id="L954" title="All 6 branches missed.">        .filter(proto -&gt; proto.hasSubject() &amp;&amp; proto.hasRelation() &amp;&amp; proto.hasObject())</span>
<span class="nc" id="L955">        .map(proto -&gt; Quadruple.makeQuadruple(proto.getSubject(), proto.getRelation(), proto.getObject(),</span>
<span class="nc bnc" id="L956" title="All 2 branches missed.">            proto.hasConfidence() ? proto.getConfidence() : 1.0))</span>
<span class="nc" id="L957">        .collect(Collectors.toList());</span>
  }


  /**
   * The sentiment of this sentence (e.g., positive / negative).
   *
   * @return The {@link SentimentClass} of this sentence, as an enum value.
   */
  public SentimentClass sentiment() {
<span class="nc" id="L967">    return sentiment(this.defaultProps);</span>
  }


  /**
   * The sentiment of this sentence (e.g., positive / negative).
   *
   * @param props The properties to pass to the sentiment classifier.
   *
   * @return The {@link SentimentClass} of this sentence, as an enum value.
   */
  public SentimentClass sentiment(Properties props) {
<span class="nc" id="L979">    document.runSentiment(props);</span>
<span class="nc bnc" id="L980" title="All 22 branches missed.">    switch (impl.getSentiment().toLowerCase()) {</span>
      case &quot;very positive&quot;:
<span class="nc" id="L982">        return SentimentClass.VERY_POSITIVE;</span>
      case &quot;positive&quot;:
<span class="nc" id="L984">        return SentimentClass.POSITIVE;</span>
      case &quot;negative&quot;:
<span class="nc" id="L986">        return SentimentClass.NEGATIVE;</span>
      case &quot;very negative&quot;:
<span class="nc" id="L988">        return SentimentClass.VERY_NEGATIVE;</span>
      case &quot;neutral&quot;:
<span class="nc" id="L990">        return SentimentClass.NEUTRAL;</span>
      default:
<span class="nc" id="L992">        throw new IllegalStateException(&quot;Unknown sentiment class: &quot; + impl.getSentiment());</span>
    }
  }

  /**
   * Get the coreference chain for just this sentence.
   * Note that this method is actually fairly computationally expensive to call, as it constructs and prunes
   * the coreference data structure for the entire document.
   *
   * @return A coreference chain, but only for this sentence
   */
  public Map&lt;Integer, CorefChain&gt; coref() {
    // Get the raw coref structure
<span class="nc" id="L1005">    Map&lt;Integer, CorefChain&gt; allCorefs = document.coref();</span>
    // Delete coreference chains not in this sentence
<span class="nc" id="L1007">    Set&lt;Integer&gt; toDeleteEntirely = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L1008" title="All 2 branches missed.">    for (Map.Entry&lt;Integer, CorefChain&gt; integerCorefChainEntry : allCorefs.entrySet()) {</span>
<span class="nc" id="L1009">      CorefChain chain = integerCorefChainEntry.getValue();</span>
<span class="nc" id="L1010">      List&lt;CorefChain.CorefMention&gt; mentions = new ArrayList&lt;&gt;(chain.getMentionsInTextualOrder());</span>
<span class="nc bnc" id="L1011" title="All 2 branches missed.">      mentions.stream().filter(m -&gt; m.sentNum != this.sentenceIndex() + 1).forEach(chain::deleteMention);</span>
<span class="nc bnc" id="L1012" title="All 2 branches missed.">      if (chain.getMentionsInTextualOrder().isEmpty()) {</span>
<span class="nc" id="L1013">        toDeleteEntirely.add(integerCorefChainEntry.getKey());</span>
      }
<span class="nc" id="L1015">    }</span>
    // Clean up dangling empty chains
<span class="nc" id="L1017">    toDeleteEntirely.forEach(allCorefs::remove);</span>
    // Return
<span class="nc" id="L1019">    return allCorefs;</span>
  }


  //
  // Helpers for CoreNLP interoperability
  //

  /**
   * Returns this sentence as a CoreNLP CoreMap object.
   * Note that, importantly, only the fields which have already been called will be populated in
   * the CoreMap!
   *
   * Therefore, this method is generally NOT recommended.
   *
   * @param functions A list of functions to call before populating the CoreMap.
   *                  For example, you can specify mySentence::posTags, and then posTags will
   *                  be populated.
   */
  @SuppressWarnings(&quot;TypeParameterExplicitlyExtendsObject&quot;)
  @SafeVarargs
  public final CoreMap asCoreMap(Function&lt;Sentence,Object&gt;... functions) {
<span class="nc bnc" id="L1041" title="All 2 branches missed.">    for (Function&lt;Sentence, Object&gt; function : functions) {</span>
<span class="nc" id="L1042">      function.apply(this);</span>
    }
<span class="nc" id="L1044">    return this.document.asAnnotation(true).get(CoreAnnotations.SentencesAnnotation.class).get(this.sentenceIndex());</span>
  }

  /**
   * Returns this sentence as a list of CoreLabels representing the sentence.
   * Note that, importantly, only the fields which have already been called will be populated in
   * the CoreMap!
   *
   * Therefore, this method is generally NOT recommended.
   *
   * @param functions A list of functions to call before populating the CoreMap.
   *                  For example, you can specify mySentence::posTags, and then posTags will
   *                  be populated.
   */
  @SuppressWarnings(&quot;TypeParameterExplicitlyExtendsObject&quot;)
  @SafeVarargs
  public final List&lt;CoreLabel&gt; asCoreLabels(Function&lt;Sentence,Object&gt;... functions) {
<span class="nc bnc" id="L1061" title="All 2 branches missed.">    for (Function&lt;Sentence, Object&gt; function : functions) {</span>
<span class="nc" id="L1062">      function.apply(this);</span>
    }
<span class="nc" id="L1064">    return asCoreMap().get(CoreAnnotations.TokensAnnotation.class);</span>
  }


  //
  // HELPERS FROM DOCUMENT
  //

  /**
   * A helper to get the raw Protobuf builder for a given token.
   * Primarily useful for cache checks.
   * @param i The index of the token to retrieve.
   * @return A Protobuf builder for that token.
   */
  public CoreNLPProtos.Token.Builder rawToken(int i) {
<span class="nc" id="L1079">    return tokensBuilders.get(i);</span>
  }

  /**
   * Get the backing protocol buffer for this sentence.
   * @return The raw backing protocol buffer builder for this sentence.
   */
  public CoreNLPProtos.Sentence.Builder rawSentence() {
<span class="nc" id="L1087">    return this.impl;</span>
  }

  /**
   * Update each token in the sentence with the given information.
   * @param tokens The CoreNLP tokens returned by the {@link edu.stanford.nlp.pipeline.Annotator}.
   * @param setter The function to set a Protobuf object with the given field.
   * @param getter The function to get the given field from the {@link CoreLabel}.
   * @param &lt;E&gt; The type of the given field we are setting in the protocol buffer and reading from the {@link CoreLabel}.
   */
  protected &lt;E&gt; void updateTokens(List&lt;CoreLabel&gt; tokens,
                              Consumer&lt;Pair&lt;CoreNLPProtos.Token.Builder, E&gt;&gt; setter,
                              Function&lt;CoreLabel, E&gt; getter) {
<span class="nc" id="L1100">    synchronized (this.impl) {</span>
<span class="nc bnc" id="L1101" title="All 2 branches missed.">      for (int i = 0; i &lt; tokens.size(); ++i) {</span>
<span class="nc" id="L1102">        E value = getter.apply(tokens.get(i));</span>
<span class="nc bnc" id="L1103" title="All 2 branches missed.">        if (value != null) {</span>
<span class="nc" id="L1104">          setter.accept(Pair.makePair(tokensBuilders.get(i), value));</span>
        }
      }
<span class="nc" id="L1107">    }</span>
<span class="nc" id="L1108">  }</span>

  /**
   * Update the parse tree for this sentence.
   * @param parse The parse tree to update.
   * @param binary The binary parse tree to update.
   */
  protected void updateParse(
      CoreNLPProtos.ParseTree parse,
      CoreNLPProtos.ParseTree binary) {
<span class="nc" id="L1118">    synchronized (this.impl) {</span>
<span class="nc" id="L1119">      this.impl.setParseTree(parse);</span>
<span class="nc bnc" id="L1120" title="All 2 branches missed.">      if (binary != null) {</span>
<span class="nc" id="L1121">        this.impl.setBinarizedParseTree(binary);</span>
      }
<span class="nc" id="L1123">    }</span>
<span class="nc" id="L1124">  }</span>

  /**
   * Update the dependencies of the sentence.
   *
   * @param basic The basic dependencies to update.
   * @param enhanced The enhanced dependencies to update.
   * @param enhancedPlusPlus The enhanced plus plus dependencies to update.
   */
  protected void updateDependencies(CoreNLPProtos.DependencyGraph basic,
                                    CoreNLPProtos.DependencyGraph enhanced,
                                    CoreNLPProtos.DependencyGraph enhancedPlusPlus) {
<span class="nc" id="L1136">    synchronized (this.impl) {</span>
<span class="nc" id="L1137">      this.impl.setBasicDependencies(basic);</span>
<span class="nc" id="L1138">      this.impl.setEnhancedDependencies(enhanced);</span>
<span class="nc" id="L1139">      this.impl.setEnhancedPlusPlusDependencies(enhancedPlusPlus);</span>
<span class="nc" id="L1140">    }</span>
<span class="nc" id="L1141">  }</span>

  /**
   * Update the Open IE relation triples for this sentence.
   *
   * @param triples The stream of relation triples to add to the sentence.
   */
  protected void updateOpenIE(Stream&lt;CoreNLPProtos.RelationTriple&gt; triples) {
<span class="nc" id="L1149">    synchronized (this.impl) {</span>
<span class="nc" id="L1150">      triples.forEach(this.impl::addOpenieTriple);</span>
<span class="nc" id="L1151">    }</span>
<span class="nc" id="L1152">  }</span>

  /**
   * Update the Open IE relation triples for this sentence.
   *
   * @param triples The stream of relation triples to add to the sentence.
   */
  protected void updateKBP(Stream&lt;CoreNLPProtos.RelationTriple&gt; triples) {
<span class="nc" id="L1160">    synchronized (this.impl) {</span>
<span class="nc" id="L1161">      triples.forEach(this.impl::addKbpTriple);</span>
<span class="nc" id="L1162">    }</span>
<span class="nc" id="L1163">  }</span>

  /**
   * Update the Sentiment class for this sentence.
   *
   * @param sentiment The sentiment of the sentence.
   */
  protected void updateSentiment(String sentiment) {
<span class="nc" id="L1171">    synchronized (this.impl) {</span>
<span class="nc" id="L1172">      this.impl.setSentiment(sentiment);</span>
<span class="nc" id="L1173">    }</span>
<span class="nc" id="L1174">  }</span>

  /** {@inheritDoc} */
  @Override
  public boolean equals(Object o) {
<span class="pc bpc" id="L1179" title="1 of 2 branches missed.">    if (this == o) return true;</span>
<span class="pc bpc" id="L1180" title="1 of 2 branches missed.">    if (!(o instanceof Sentence)) return false;</span>
<span class="fc" id="L1181">    Sentence sentence = (Sentence) o;</span>
    // Short circuit for fast equals check
<span class="pc bpc" id="L1183" title="2 of 4 branches missed.">    if (impl.hasText() &amp;&amp; !impl.getText().equals(sentence.impl.getText())) {</span>
<span class="nc" id="L1184">      return false;</span>
    }
<span class="pc bpc" id="L1186" title="1 of 2 branches missed.">    if (this.tokensBuilders.size() != sentence.tokensBuilders.size()) {</span>
<span class="nc" id="L1187">      return false;</span>
    }
    // Check the implementation of the sentence
<span class="pc bpc" id="L1190" title="1 of 2 branches missed.">    if (!impl.build().equals(sentence.impl.build())) {</span>
<span class="nc" id="L1191">      return false;</span>
    }
    // Check each token
<span class="fc bfc" id="L1194" title="All 2 branches covered.">    for (int i = 0, sz = tokensBuilders.size(); i &lt; sz; ++i) {</span>
<span class="pc bpc" id="L1195" title="1 of 2 branches missed.">      if (!tokensBuilders.get(i).build().equals(sentence.tokensBuilders.get(i).build())) {</span>
<span class="nc" id="L1196">        return false;</span>
      }
    }
<span class="fc" id="L1199">    return true;</span>
  }

  /** {@inheritDoc} */
  @Override
  public int hashCode() {
<span class="nc bnc" id="L1205" title="All 2 branches missed.">    if (this.impl.hasText()) {</span>
<span class="nc" id="L1206">      return this.impl.getText().hashCode() * 31 +  this.tokensBuilders.size();</span>
    } else {
<span class="nc" id="L1208">      return impl.build().hashCode();</span>
    }
  }

  /** {@inheritDoc} */
  @Override
  public String toString() {
<span class="nc" id="L1215">    return impl.getText();</span>
  }

  /**
   * @param start - inclusive
   * @param end - exclusive
   * @return - the text for the provided token span.
   */
  public String substring(int start, int end) {
<span class="nc" id="L1224">    StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L1225" title="All 2 branches missed.">    for(CoreLabel word : asCoreLabels().subList(start, end)) {</span>
<span class="nc" id="L1226">      sb.append(word.word());</span>
<span class="nc" id="L1227">      sb.append(word.after());</span>
<span class="nc" id="L1228">    }</span>
<span class="nc" id="L1229">    return sb.toString();</span>
  }


  private static &lt;E&gt; List&lt;E&gt; lazyList(final List&lt;CoreNLPProtos.Token.Builder&gt; tokens, final Function&lt;CoreNLPProtos.Token.Builder,E&gt; fn) {
<span class="fc" id="L1234">    return new AbstractList&lt;E&gt;() {</span>
      @Override
      public E get(int index) {
<span class="fc" id="L1237">        return fn.apply(tokens.get(index));</span>
      }
      @Override
      public int size() {
<span class="nc" id="L1241">        return tokens.size();</span>
      }
    };
  }

  /** Returns the sentence id of the sentence, if one was found */
  public Optional&lt;String&gt; sentenceid() {
<span class="nc" id="L1248">    synchronized (impl) {</span>
<span class="nc bnc" id="L1249" title="All 2 branches missed.">      if (impl.hasSentenceID()) {</span>
<span class="nc" id="L1250">        return Optional.of(impl.getSentenceID());</span>
      } else {
<span class="nc" id="L1252">        return Optional.empty();</span>
      }
<span class="nc" id="L1254">    }</span>
  }

  /**
   * Apply a TokensRegex pattern to the sentence.
   *
   * @param pattern The TokensRegex pattern to match against.
   * @return the matcher.
   */
  public boolean matches(TokenSequencePattern pattern) {
<span class="nc" id="L1264">    return pattern.getMatcher(asCoreLabels()).matches();</span>
  }

  /**
   * Apply a TokensRegex pattern to the sentence.
   *
   * @param pattern The TokensRegex pattern to match against.
   * @return True if the tokensregex pattern matches.
   */
  public boolean matches(String pattern) {
<span class="nc" id="L1274">    return matches(TokenSequencePattern.compile(pattern));</span>
  }

  /**
   * Apply a TokensRegex pattern to the sentence.
   *
   * @param pattern The TokensRegex pattern to match against.
   * @param fn The action to do on each match.
   * @return the list of matches, after run through the function.
   */
  public &lt;T&gt; List&lt;T&gt; find(TokenSequencePattern pattern, Function&lt;TokenSequenceMatcher, T&gt; fn) {
<span class="nc" id="L1285">    TokenSequenceMatcher matcher = pattern.matcher(asCoreLabels());</span>
<span class="nc" id="L1286">    List&lt;T&gt; lst = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1287" title="All 2 branches missed.">    while(matcher.find()) {</span>
<span class="nc" id="L1288">      lst.add(fn.apply(matcher));</span>
    }
<span class="nc" id="L1290">    return lst;</span>
  }

  public &lt;T&gt; List&lt;T&gt;  find(String pattern, Function&lt;TokenSequenceMatcher, T&gt; fn) {
<span class="nc" id="L1294">    return find(TokenSequencePattern.compile(pattern), fn);</span>
  }

  /**
   * Apply a semgrex pattern to the sentence
   * @param pattern The Semgrex pattern to match against.
   * @param fn The action to do on each match.
   * @return the list of matches, after run through the function.
   */
  public &lt;T&gt; List&lt;T&gt; semgrex(SemgrexPattern pattern, Function&lt;SemgrexMatcher, T&gt; fn) {
<span class="nc" id="L1304">    SemgrexMatcher matcher = pattern.matcher(dependencyGraph());</span>
<span class="nc" id="L1305">    List&lt;T&gt; lst = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1306" title="All 2 branches missed.">    while(matcher.findNextMatchingNode()) {</span>
<span class="nc" id="L1307">      lst.add(fn.apply(matcher));</span>
    }
<span class="nc" id="L1309">    return lst;</span>
  }

  /**
   * Apply a semgrex pattern to the sentence
   * @param pattern The Semgrex pattern to match against.
   * @param fn The action to do on each match.
   * @return the list of matches, after run through the function.
   */
  public &lt;T&gt; List&lt;T&gt; semgrex(String pattern, Function&lt;SemgrexMatcher, T&gt; fn) {
<span class="nc" id="L1319">    return semgrex(SemgrexPattern.compile(pattern), fn);</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>