<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CoreAnnotations.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Stanford CoreNLP</a> &gt; <a href="index.source.html" class="el_package">edu.stanford.nlp.ling</a> &gt; <span class="el_source">CoreAnnotations.java</span></div><h1>CoreAnnotations.java</h1><pre class="source lang-java linenums">package edu.stanford.nlp.ling;

import edu.stanford.nlp.ie.util.RelationTriple;
import edu.stanford.nlp.util.*;

import java.util.Calendar;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.SortedSet;

/**
 * &lt;p&gt;
 * Set of common annotations for {@link CoreMap}s. The classes
 * defined here are typesafe keys for getting and setting annotation
 * values. These classes need not be instantiated outside of this
 * class. e.g {@link TextAnnotation}.class serves as the key and a
 * {@code String} serves as the value containing the
 * corresponding word.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * New types of {@link CoreAnnotation} can be defined anywhere that is
 * convenient in the source tree - they are just classes. This file exists to
 * hold widely used &quot;core&quot; annotations and others inherited from the
 * {@link Label} family. In general, most keys should be placed in this file as
 * they may often be reused throughout the code. This architecture allows for
 * flexibility, but in many ways it should be considered as equivalent to an
 * enum in which everything should be defined
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * The getType method required by CoreAnnotation must return the same class type
 * as its value type parameter. It feels like one should be able to get away
 * without that method, but because Java erases the generic type signature, that
 * info disappears at runtime. See {@link ValueAnnotation} for an example.
 * &lt;/p&gt;
 *
 * @author dramage
 * @author rafferty
 * @author bethard
 */
public class CoreAnnotations {

<span class="nc" id="L45">  private CoreAnnotations() { } // only static members</span>

  /**
   * The CoreMap key identifying the annotation's text.
   *
   * Note that this key is intended to be used with many different kinds of
   * annotations - documents, sentences and tokens all have their own text.
   */
<span class="fc" id="L53">  public static class TextAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="fc" id="L56">      return String.class;</span>
    }
  }


  /**
   * The CoreMap key for getting the lemma (morphological stem) of a token.
   *
   * This key is typically set on token annotations.
   *
   * TODO: merge with StemAnnotation?
   */
<span class="nc" id="L68">  public static class LemmaAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L71">      return String.class;</span>
    }
  }

  /**
   * The CoreMap key for getting the Penn part of speech of a token.
   *
   * This key is typically set on token annotations.
   */
<span class="nc" id="L80">  public static class PartOfSpeechAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L83">      return String.class;</span>
    }
  }

  /**
   * The CoreMap key for getting the token-level named entity tag (e.g., DATE,
   * PERSON, etc.)
   *
   * This key is typically set on token annotations.
   */
<span class="nc" id="L93">  public static class NamedEntityTagAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L96">      return String.class;</span>
    }
  }

  /**
   * The CoreMap key for getting the token-level named entity tag (e.g., DATE,
   * PERSON, etc.) from a previous NER tagger. NERFeatureFactory is sensitive to
   * this tag and will turn the annotations from the previous NER tagger into
   * new features. This is currently used to implement one level of stacking --
   * we may later change it to take a list as needed.
   *
   * This key is typically set on token annotations.
   */
<span class="nc" id="L109">  public static class StackedNamedEntityTagAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L112">      return String.class;</span>
    }
  }

  /**
   * The CoreMap key for getting the token-level true case annotation (e.g.,
   * INIT_UPPER)
   *
   * This key is typically set on token annotations.
   */
<span class="nc" id="L122">  public static class TrueCaseAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L125">      return String.class;</span>
    }
  }

  /**
   * The CoreMap key identifying the annotation's true-cased text.
   *
   * Note that this key is intended to be used with many different kinds of
   * annotations - documents, sentences and tokens all have their own text.
   */
<span class="nc" id="L135">  public static class TrueCaseTextAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L138">      return String.class;</span>
    }
  }

  /**
   * The CoreMap key for getting the tokens contained by an annotation.
   *
   * This key should be set for any annotation that contains tokens. It can be
   * done without much memory overhead using List.subList.
   */
<span class="nc" id="L148">  public static class TokensAnnotation implements CoreAnnotation&lt;List&lt;CoreLabel&gt;&gt; {</span>
    @Override
    public Class&lt;List&lt;CoreLabel&gt;&gt; getType() {
<span class="nc" id="L151">      return ErasureUtils.uncheckedCast(List.class);</span>
    }
  }

  /**
   * The CoreMap key for getting the tokens (can be words, phrases or anything that are of type CoreMap) contained by an annotation.
   *
   * This key should be set for any annotation that contains tokens (words, phrases etc). It can be
   * done without much memory overhead using List.subList.
   */
<span class="nc" id="L161">  public static class GenericTokensAnnotation implements CoreAnnotation&lt;List&lt;CoreMap&gt;&gt; {</span>
    @Override
    public Class&lt;List&lt;CoreMap&gt;&gt; getType() {
<span class="nc" id="L164">      return ErasureUtils.uncheckedCast(List.class);</span>
    }
  }

  /**
   * The CoreMap key for getting the sentences contained in an annotation.
   * The sentences are represented as a {@code List&lt;CoreMap&gt;}.
   * Each sentence might typically have annotations such as {@code TextAnnotation},
   * {@code TokensAnnotation}, {@code SentenceIndexAnnotation}, and {@code BasicDependenciesAnnotation}.
   *
   * This key is typically set only on document annotations.
   */
<span class="nc" id="L176">  public static class SentencesAnnotation implements CoreAnnotation&lt;List&lt;CoreMap&gt;&gt; {</span>
    @Override
    public Class&lt;List&lt;CoreMap&gt;&gt; getType() {
<span class="nc" id="L179">      return ErasureUtils.uncheckedCast(List.class);</span>
    }
  }

  /**
   * The CoreMap key for getting the quotations contained by an annotation.
   *
   * This key is typically set only on document annotations.
   */
<span class="nc" id="L188">  public static class QuotationsAnnotation implements CoreAnnotation&lt;List&lt;CoreMap&gt;&gt; {</span>
    @Override
    public Class&lt;List&lt;CoreMap&gt;&gt; getType() {
<span class="nc" id="L191">      return ErasureUtils.uncheckedCast(List.class);</span>
    }
  }

  /**
   * The CoreMap key for getting the quotations contained by an annotation.
   *
   * This key is typically set only on document annotations.
   */
<span class="nc" id="L200">  public static class UnclosedQuotationsAnnotation implements CoreAnnotation&lt;List&lt;CoreMap&gt;&gt; {</span>
    @Override
    public Class&lt;List&lt;CoreMap&gt;&gt; getType() {
<span class="nc" id="L203">      return ErasureUtils.uncheckedCast(List.class);</span>
    }
  }

  /**
   * Unique identifier within a document for a given quotation.
   */
<span class="nc" id="L210">  public static class QuotationIndexAnnotation implements CoreAnnotation&lt;Integer&gt; {</span>
    @Override
    public Class&lt;Integer&gt; getType() {
<span class="nc" id="L213">      return Integer.class;</span>
    }
  }

  /**
   * The index of the sentence that this annotation begins in.
   */
<span class="nc" id="L220">  public static class SentenceBeginAnnotation implements CoreAnnotation&lt;Integer&gt; {</span>
    @Override
    public Class&lt;Integer&gt; getType() {
<span class="nc" id="L223">      return Integer.class;</span>
    }
  }

  /**
   * The index of the sentence that this annotation begins in.
   */
<span class="nc" id="L230">  public static class SentenceEndAnnotation implements CoreAnnotation&lt;Integer&gt; {</span>
    @Override
    public Class&lt;Integer&gt; getType() {
<span class="nc" id="L233">      return Integer.class;</span>
    }
  }


  /**
   * The CoreMap key for getting the paragraphs contained by an annotation.
   *
   * This key is typically set only on document annotations.
   */
<span class="nc" id="L243">  public static class ParagraphsAnnotation implements CoreAnnotation&lt;List&lt;CoreMap&gt;&gt; {</span>
    @Override
    public Class&lt;List&lt;CoreMap&gt;&gt; getType() {
<span class="nc" id="L246">      return ErasureUtils.uncheckedCast(List.class);</span>
    }
  }

  /**
   * The CoreMap key identifying the first token included in an annotation. The
   * token with index 0 is the first token in the document.
   *
   * This key should be set for any annotation that contains tokens.
   */
<span class="nc" id="L256">  public static class TokenBeginAnnotation implements CoreAnnotation&lt;Integer&gt; {</span>
    @Override
    public Class&lt;Integer&gt; getType() {
<span class="nc" id="L259">      return Integer.class;</span>
    }
  }

  /**
   * The CoreMap key identifying the last token after the end of an annotation.
   * The token with index 0 is the first token in the document.
   *
   * This key should be set for any annotation that contains tokens.
   */
<span class="nc" id="L269">  public static class TokenEndAnnotation implements CoreAnnotation&lt;Integer&gt; {</span>
    @Override
    public Class&lt;Integer&gt; getType() {
<span class="nc" id="L272">      return Integer.class;</span>
    }
  }

  /**
   * The CoreMap key identifying the date and time associated with an
   * annotation.
   *
   * This key is typically set on document annotations.
   */
<span class="nc" id="L282">  public static class CalendarAnnotation implements CoreAnnotation&lt;Calendar&gt; {</span>
    @Override
    public Class&lt;Calendar&gt; getType() {
<span class="nc" id="L285">      return Calendar.class;</span>
    }
  }

  /*
   * These are the keys hashed on by IndexedWord
   */

  /**
   * This refers to the unique identifier for a &quot;document&quot;, where document may
   * vary based on your application.
   */
<span class="nc" id="L297">  public static class DocIDAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L300">      return String.class;</span>
    }
  }

  /**
   * This indexes a token number inside a sentence.  Standardly, tokens are
   * indexed within a sentence starting at 1 (not 0: we follow common parlance
   * whereby we speak of the first word of a sentence).
   * This is generally an individual word or feature index - it is local, and
   * may not be uniquely identifying without other identifiers such as sentence
   * and doc. However, if these are the same, the index annotation should be a
   * unique identifier for differentiating objects.
   */
<span class="nc" id="L313">  public static class IndexAnnotation implements CoreAnnotation&lt;Integer&gt; {</span>
    @Override
    public Class&lt;Integer&gt; getType() {
<span class="nc" id="L316">      return Integer.class;</span>
    }
  }

  /**
   * This indexes the beginning of a span of words, e.g., a constituent in a
   * tree. See {@link edu.stanford.nlp.trees.Tree#indexSpans(int)}.
   * This annotation counts tokens.
   * It standardly indexes from 1 (like IndexAnnotation).  The reasons for
   * this are: (i) Talking about the first word of a sentence is kind of
   * natural, and (ii) We use index 0 to refer to an imaginary root in
   * dependency output.
   */
<span class="nc" id="L329">  public static class BeginIndexAnnotation implements CoreAnnotation&lt;Integer&gt; {</span>
    @Override
    public Class&lt;Integer&gt; getType() {
<span class="nc" id="L332">      return Integer.class;</span>
    }
  }

  /**
   * This indexes the end of a span of words, e.g., a constituent in a
   * tree.  See {@link edu.stanford.nlp.trees.Tree#indexSpans(int)}. This annotation
   * counts tokens.  It standardly indexes from 1 (like IndexAnnotation).
   * The end index is not a fencepost: its value is equal to the
   * IndexAnnotation of the last word in the span.
   */
<span class="nc" id="L343">  public static class EndIndexAnnotation implements CoreAnnotation&lt;Integer&gt; {</span>
    @Override
    public Class&lt;Integer&gt; getType() {
<span class="nc" id="L346">      return Integer.class;</span>
    }
  }

  /**
   * This indicates that starting at this token, the sentence should not be ended until
   * we see a ForcedSentenceEndAnnotation.  Used to force the ssplit annotator
   * (eg the WordToSentenceProcessor) to keep tokens in the same sentence
   * until ForcedSentenceEndAnnotation is seen.
   */
<span class="nc" id="L356">  public static class ForcedSentenceUntilEndAnnotation</span>
          implements CoreAnnotation&lt;Boolean&gt; {
    @Override
    public Class&lt;Boolean&gt; getType() {
<span class="nc" id="L360">      return Boolean.class;</span>
    }
  }

  /**
   * This indicates the sentence should end at this token.  Used to
   * force the ssplit annotator (eg the WordToSentenceProcessor) to
   * start a new sentence at the next token.
   */
<span class="nc" id="L369">  public static class ForcedSentenceEndAnnotation</span>
  implements CoreAnnotation&lt;Boolean&gt; {
    @Override
    public Class&lt;Boolean&gt; getType() {
<span class="nc" id="L373">      return Boolean.class;</span>
    }
  }

  /**
   * Unique identifier within a document for a given sentence.
   */
<span class="nc" id="L380">  public static class SentenceIndexAnnotation implements CoreAnnotation&lt;Integer&gt; {</span>
    @Override
    public Class&lt;Integer&gt; getType() {
<span class="nc" id="L383">      return Integer.class;</span>
    }
  }

  /**
   * Line number for a sentence in a document delimited by newlines
   * instead of punctuation.  May skip numbers if there are blank
   * lines not represented as sentences.  Indexed from 1 rather than 0.
   */
<span class="nc" id="L392">  public static class LineNumberAnnotation implements CoreAnnotation&lt;Integer&gt; {</span>
    @Override
    public Class&lt;Integer&gt; getType() {
<span class="nc" id="L395">      return Integer.class;</span>
    }
  }

  /**
   * Contains the &quot;value&quot; - an ill-defined string used widely in MapLabel.
   */
<span class="nc" id="L402">  public static class ValueAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L405">      return String.class;</span>
    }
  }

<span class="nc" id="L409">  public static class CategoryAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L412">      return String.class;</span>
    }
  }

  /**
   * The exact original surface form of a token.  This is created in the
   * invertible PTBTokenizer. The tokenizer may normalize the token form to
   * match what appears in the PTB, but this key will hold the original characters.
   */
<span class="nc" id="L421">  public static class OriginalTextAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L424">      return String.class;</span>
    }
  }

  /**
   * Annotation for the whitespace characters appearing before this word. This
   * can be filled in by the tokenizer so that the original text string can be
   * reconstructed.
   */
<span class="nc" id="L433">  public static class BeforeAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L436">      return String.class;</span>
    }
  }

  /**
   * Annotation for the whitespace characters appear after this word. This can
   * be filled in by the tokenizer so that the original text string can be
   * reconstructed.
   */
<span class="nc" id="L445">  public static class AfterAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L448">      return String.class;</span>
    }
  }

  /**
   * CoNLL dep parsing - coarser POS tags.
   */
<span class="nc" id="L455">  public static class CoarseTagAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L458">      return String.class;</span>
    }
  }

  /**
   * CoNLL dep parsing - the dependency type
   */
<span class="nc" id="L465">  public static class CoNLLDepAnnotation implements CoreAnnotation&lt;CoreMap&gt; {</span>
    @Override
    public Class&lt;CoreMap&gt; getType() {
<span class="nc" id="L468">      return CoreMap.class;</span>
    }
  }

  /**
   * CoNLL SRL/dep parsing - whether the word is a predicate
   */
<span class="nc" id="L475">  public static class CoNLLPredicateAnnotation implements CoreAnnotation&lt;Boolean&gt; {</span>
    @Override
    public Class&lt;Boolean&gt; getType() {
<span class="nc" id="L478">      return Boolean.class;</span>
    }
  }

  /**
   * CoNLL SRL/dep parsing - map which, for the current word, specifies its
   * specific role for each predicate
   */
<span class="nc" id="L486">  public static class CoNLLSRLAnnotation implements CoreAnnotation&lt;Map&lt;Integer,String&gt;&gt; {</span>
    @Override
    public Class&lt;Map&lt;Integer,String&gt;&gt; getType() {
<span class="nc" id="L489">      return ErasureUtils.uncheckedCast(Map.class);</span>
    }
  }

  /**
   * CoNLL dep parsing - the dependency type
   */
<span class="nc" id="L496">  public static class CoNLLDepTypeAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L499">      return String.class;</span>
    }
  }

  /**
   * CoNLL-U dep parsing - span of multiword tokens
   */
<span class="nc" id="L506">  public static class CoNLLUTokenSpanAnnotation implements CoreAnnotation&lt;IntPair&gt; {</span>
    @Override
    public Class&lt;IntPair&gt; getType() {
<span class="nc" id="L509">      return ErasureUtils.uncheckedCast(Pair.class);</span>
    }
  }

  /**
   * CoNLL-U dep parsing - List of secondary dependencies
   */
<span class="nc" id="L516">  public static class CoNLLUSecondaryDepsAnnotation implements CoreAnnotation&lt;HashMap&lt;Integer,String&gt;&gt; {</span>
    @Override
    public Class&lt;HashMap&lt;Integer,String&gt;&gt; getType() {
<span class="nc" id="L519">      return ErasureUtils.uncheckedCast(Pair.class);</span>
    }
  }

  /**
   * CoNLL-U dep parsing - List of morphological features
   */
<span class="nc" id="L526">  public static class CoNLLUFeats implements CoreAnnotation&lt;HashMap&lt;String,String&gt;&gt; {</span>
    @Override
    public Class&lt;HashMap&lt;String,String&gt;&gt; getType() {
<span class="nc" id="L529">      return ErasureUtils.uncheckedCast(HashMap.class);</span>
    }
  }

  /**
   * CoNLL-U dep parsing - Any other annotation
   */
<span class="nc" id="L536">  public static class CoNLLUMisc implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L539">      return String.class;</span>
    }
  }

  /**
   * CoNLL dep parsing - the index of the word which is the parent of this word
   * in the dependency tree
   */
<span class="nc" id="L547">  public static class CoNLLDepParentIndexAnnotation implements CoreAnnotation&lt;Integer&gt; {</span>
    @Override
    public Class&lt;Integer&gt; getType() {
<span class="nc" id="L550">      return Integer.class;</span>
    }
  }

  /**
   * Inverse document frequency of the word this label represents
   */
<span class="nc" id="L557">  public static class IDFAnnotation implements CoreAnnotation&lt;Double&gt; {</span>
    @Override
    public Class&lt;Double&gt; getType() {
<span class="nc" id="L560">      return Double.class;</span>
    }
  }

  /**
   * The standard key for a propbank label which is of type Argument
   */
<span class="nc" id="L567">  public static class ArgumentAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L570">      return String.class;</span>
    }
  }

  /**
   * Another key used for propbank - to signify core arg nodes or predicate
   * nodes
   */
<span class="nc" id="L578">  public static class MarkingAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L581">      return String.class;</span>
    }
  }

  /**
   * The standard key for Semantic Head Word which is a String
   */
<span class="nc" id="L588">  public static class SemanticHeadWordAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L591">      return String.class;</span>
    }
  }

  /**
   * The standard key for Semantic Head Word POS which is a String
   */
<span class="nc" id="L598">  public static class SemanticHeadTagAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L601">      return String.class;</span>
    }
  }

  /**
   * Probank key for the Verb sense given in the Propbank Annotation, should
   * only be in the verbnode
   */
<span class="nc" id="L609">  public static class VerbSenseAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L612">      return String.class;</span>
    }
  }

  /**
   * The standard key for storing category with functional tags.
   */
<span class="nc" id="L619">  public static class CategoryFunctionalTagAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L622">      return String.class;</span>
    }
  }

  /**
   * This is an NER ID annotation (in case the all caps parsing didn't work out
   * for you...)
   */
<span class="nc" id="L630">  public static class NERIDAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L633">      return String.class;</span>
    }
  }

  /**
   * The key for the normalized value of numeric named entities.
   */
<span class="nc" id="L640">  public static class NormalizedNamedEntityTagAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L643">      return String.class;</span>
    }
  }

<span class="nc" id="L647">  public enum SRL_ID {</span>
<span class="nc" id="L648">    ARG, NO, ALL_NO, REL</span>
  }

  /**
   * The key for semantic role labels (Note: please add to this description if
   * you use this key)
   */
<span class="nc" id="L655">  public static class SRLIDAnnotation implements CoreAnnotation&lt;SRL_ID&gt; {</span>
    @Override
    public Class&lt;SRL_ID&gt; getType() {
<span class="nc" id="L658">      return SRL_ID.class;</span>
    }
  }

  /**
   * The standard key for the &quot;shape&quot; of a word: a String representing the type
   * of characters in a word, such as &quot;Xx&quot; for a capitalized word. See
   * {@link edu.stanford.nlp.process.WordShapeClassifier} for functions for
   * making shape strings.
   */
<span class="nc" id="L668">  public static class ShapeAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L671">      return String.class;</span>
    }
  }

  /**
   * The Standard key for storing the left terminal number relative to the root
   * of the tree of the leftmost terminal dominated by the current node
   */
<span class="nc" id="L679">  public static class LeftTermAnnotation implements CoreAnnotation&lt;Integer&gt; {</span>
    @Override
    public Class&lt;Integer&gt; getType() {
<span class="nc" id="L682">      return Integer.class;</span>
    }
  }

  /**
   * The standard key for the parent which is a String
   */
<span class="nc" id="L689">  public static class ParentAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L692">      return String.class;</span>
    }
  }

<span class="nc" id="L696">  public static class INAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L699">      return String.class;</span>
    }
  }

  /**
   * The standard key for span which is an IntPair
   */
<span class="nc" id="L706">  public static class SpanAnnotation implements CoreAnnotation&lt;IntPair&gt; {</span>
    @Override
    public Class&lt;IntPair&gt; getType() {
<span class="nc" id="L709">      return IntPair.class;</span>
    }
  }

  /**
   * The standard key for the answer which is a String
   */
<span class="fc" id="L716">  public static class AnswerAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="fc" id="L719">      return String.class;</span>
    }
  }

  /**
   * The standard key for gold answer which is a String
   */
<span class="nc" id="L726">  public static class GoldAnswerAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L729">      return String.class;</span>
    }
  }

  /**
   * The standard key for the features which is a Collection
   */
<span class="nc" id="L736">  public static class FeaturesAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L739">      return String.class;</span>
    }
  }

  /**
   * The standard key for the semantic interpretation
   */
<span class="nc" id="L746">  public static class InterpretationAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L749">      return String.class;</span>
    }
  }

  /**
   * The standard key for the semantic role label of a phrase.
   */
<span class="nc" id="L756">  public static class RoleAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L759">      return String.class;</span>
    }
  }

  /**
   * The standard key for the gazetteer information
   */
<span class="nc" id="L766">  public static class GazetteerAnnotation implements CoreAnnotation&lt;List&lt;String&gt;&gt; {</span>
    @Override
    public Class&lt;List&lt;String&gt;&gt; getType() {
<span class="nc" id="L769">      return ErasureUtils.uncheckedCast(List.class);</span>
    }
  }

  /**
   * Morphological stem of the word this label represents
   */
<span class="nc" id="L776">  public static class StemAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L779">      return String.class;</span>
    }
  }

<span class="nc" id="L783">  public static class PolarityAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L786">      return String.class;</span>
    }
  }

<span class="nc" id="L790">  public static class MorphoNumAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L793">      return String.class;</span>
    }
  }

<span class="nc" id="L797">  public static class MorphoPersAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L800">      return String.class;</span>
    }
  }

<span class="nc" id="L804">  public static class MorphoGenAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L807">      return String.class;</span>
    }
  }

<span class="nc" id="L811">  public static class MorphoCaseAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L814">      return String.class;</span>
    }
  }

  /**
   * For Chinese: character level information, segmentation. Used for representing
   * a single character as a token.
   */
<span class="nc" id="L822">  public static class ChineseCharAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L825">      return String.class;</span>
    }
  }

  /** For Chinese: the segmentation info existing in the original text. */
<span class="nc" id="L830">  public static class ChineseOrigSegAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L833">      return String.class;</span>
    }
  }

  /** For Chinese: the segmentation information from the segmenter.
   *  Either a &quot;1&quot; for a new word starting at this position or a &quot;0&quot;.
   */
<span class="nc" id="L840">  public static class ChineseSegAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L843">      return String.class;</span>
    }
  }

  /**
   * Not sure exactly what this is, but it is different from
   * ChineseSegAnnotation and seems to indicate if the text is segmented
   */
<span class="nc" id="L851">  public static class ChineseIsSegmentedAnnotation implements CoreAnnotation&lt;Boolean&gt; {</span>
    @Override
    public Class&lt;Boolean&gt; getType() {
<span class="nc" id="L854">      return Boolean.class;</span>
    }
  }

  /**
   * for Arabic: character level information, segmentation
   */
<span class="nc" id="L861">  public static class ArabicCharAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    public Class&lt;String&gt; getType() {
<span class="nc" id="L863">      return String.class;</span>
    }
  }

  /** For Arabic: the segmentation information from the segmenter. */
<span class="nc" id="L868">  public static class ArabicSegAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    public Class&lt;String&gt; getType() {
<span class="nc" id="L870">      return String.class;</span>
    }
  }

  /**
   * The CoreMap key identifying the offset of the first character of an
   * annotation. The character with index 0 is the first character in the
   * document.
   *
   * This key should be set for any annotation that represents a span of text.
   */
<span class="nc" id="L881">  public static class CharacterOffsetBeginAnnotation implements CoreAnnotation&lt;Integer&gt; {</span>
    @Override
    public Class&lt;Integer&gt; getType() {
<span class="nc" id="L884">      return Integer.class;</span>
    }
  }

  /**
   * The CoreMap key identifying the offset of the last character after the end
   * of an annotation. The character with index 0 is the first character in the
   * document.
   *
   * This key should be set for any annotation that represents a span of text.
   */
<span class="nc" id="L895">  public static class CharacterOffsetEndAnnotation implements CoreAnnotation&lt;Integer&gt; {</span>
    @Override
    public Class&lt;Integer&gt; getType() {
<span class="nc" id="L898">      return Integer.class;</span>
    }
  }

  /**
   * Key for relative value of a word - used in RTE
   */
<span class="nc" id="L905">  public static class CostMagnificationAnnotation implements CoreAnnotation&lt;Double&gt; {</span>
    @Override
    public Class&lt;Double&gt; getType() {
<span class="nc" id="L908">      return Double.class;</span>
    }
  }

<span class="nc" id="L912">  public static class WordSenseAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L915">      return String.class;</span>
    }
  }

<span class="nc" id="L919">  public static class SRLInstancesAnnotation implements CoreAnnotation&lt;List&lt;List&lt;Pair&lt;String, Pair&gt;&gt;&gt;&gt; {</span>
    @Override
    public Class&lt;List&lt;List&lt;Pair&lt;String, Pair&gt;&gt;&gt;&gt; getType() {
<span class="nc" id="L922">      return ErasureUtils.uncheckedCast(List.class);</span>
    }
  }

  /**
   * Used by RTE to track number of text sentences, to determine when hyp
   * sentences begin.
   */
<span class="nc" id="L930">  public static class NumTxtSentencesAnnotation implements CoreAnnotation&lt;Integer&gt; {</span>
    @Override
    public Class&lt;Integer&gt; getType() {
<span class="nc" id="L933">      return Integer.class;</span>
    }
  }

  /**
   * Used in Trees
   */
<span class="nc" id="L940">  public static class TagLabelAnnotation implements CoreAnnotation&lt;Label&gt; {</span>
    @Override
    public Class&lt;Label&gt; getType() {
<span class="nc" id="L943">      return Label.class;</span>
    }
  }

  /**
   * Used in CRFClassifier stuff PositionAnnotation should possibly be an int -
   * it's present as either an int or string depending on context CharAnnotation
   * may be &quot;CharacterAnnotation&quot; - not sure
   */
<span class="nc" id="L952">  public static class DomainAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L955">      return String.class;</span>
    }
  }

<span class="nc" id="L959">  public static class PositionAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L962">      return String.class;</span>
    }
  }

<span class="nc" id="L966">  public static class CharAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L969">      return String.class;</span>
    }
  }

  /** Note: this is not a catchall &quot;unknown&quot; annotation but seems to have a
   *  specific meaning for sequence classifiers
   */
<span class="nc" id="L976">  public static class UnknownAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L979">      return String.class;</span>
    }
  }

<span class="nc" id="L983">  public static class IDAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L986">      return String.class;</span>
    }
  }

  /** Possibly this should be grouped with gazetteer annotation - original key
   *  was &quot;gaz&quot;.
   */
<span class="nc" id="L993">  public static class GazAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L996">      return String.class;</span>
    }
  }

<span class="nc" id="L1000">  public static class PossibleAnswersAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1003">      return String.class;</span>
    }
  }

<span class="nc" id="L1007">  public static class DistSimAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1010">      return String.class;</span>
    }
  }

<span class="nc" id="L1014">  public static class AbbrAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1017">      return String.class;</span>
    }
  }

<span class="nc" id="L1021">  public static class ChunkAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1024">      return String.class;</span>
    }
  }

<span class="nc" id="L1028">  public static class GovernorAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1031">      return String.class;</span>
    }
  }

<span class="nc" id="L1035">  public static class AbgeneAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1038">      return String.class;</span>
    }
  }

<span class="nc" id="L1042">  public static class GeniaAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1045">      return String.class;</span>
    }
  }

<span class="nc" id="L1049">  public static class AbstrAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1052">      return String.class;</span>
    }
  }

<span class="nc" id="L1056">  public static class FreqAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1059">      return String.class;</span>
    }
  }

<span class="nc" id="L1063">  public static class DictAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1066">      return String.class;</span>
    }
  }

<span class="nc" id="L1070">  public static class WebAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1073">      return String.class;</span>
    }
  }

<span class="nc" id="L1077">  public static class FemaleGazAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1080">      return String.class;</span>
    }
  }

<span class="nc" id="L1084">  public static class MaleGazAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1087">      return String.class;</span>
    }
  }

<span class="nc" id="L1091">  public static class LastGazAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1094">      return String.class;</span>
    }
  }

  /**
   * it really seems like this should have a different name or else be a boolean
   */
<span class="nc" id="L1101">  public static class IsURLAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1104">      return String.class;</span>
    }
  }

<span class="nc" id="L1108">  public static class LinkAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1111">      return String.class;</span>
    }
  }

<span class="nc" id="L1115">  public static class MentionsAnnotation implements CoreAnnotation&lt;List&lt;CoreMap&gt;&gt; {</span>
    @Override
    public Class&lt;List&lt;CoreMap&gt;&gt; getType() {
<span class="nc" id="L1118">      return ErasureUtils.uncheckedCast(List.class);</span>
    }
  }

<span class="nc" id="L1122">  public static class EntityTypeAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1125">      return String.class;</span>
    }
  }

  /**
   * it really seems like this should have a different name or else be a boolean
   */
<span class="nc" id="L1132">  public static class IsDateRangeAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1135">      return String.class;</span>
    }
  }

<span class="nc" id="L1139">  public static class PredictedAnswerAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1142">      return String.class;</span>
    }
  }

  /** Seems like this could be consolidated with something else... */
<span class="nc" id="L1147">  public static class OriginalCharAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1150">      return String.class;</span>
    }
  }

<span class="nc" id="L1154">  public static class UTypeAnnotation implements CoreAnnotation&lt;Integer&gt; {</span>
    @Override
    public Class&lt;Integer&gt; getType() {
<span class="nc" id="L1157">      return Integer.class;</span>
    }
  }

<span class="nc" id="L1161">  public static class EntityRuleAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1164">      return String.class;</span>
    }
  }

  /**
   * Section of a document
   */
<span class="nc" id="L1171">  public static class SectionAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1174">      return String.class;</span>
    }
  }

  /**
   * Date for a section of a document
   */
<span class="nc" id="L1181">  public static class SectionDateAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1184">      return String.class;</span>
    }
  }

  /**
   * Id for a section of a document
   */
<span class="nc" id="L1191">  public static class SectionIDAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1194">      return String.class;</span>
    }
  }

  /**
   * Indicates that the token starts a new section and the attributes
   *   that should go into that section
   */
<span class="nc" id="L1202">  public static class SectionStartAnnotation implements CoreAnnotation&lt;CoreMap&gt; {</span>
    @Override
    public Class&lt;CoreMap&gt; getType() {
<span class="nc" id="L1205">      return CoreMap.class;</span>
    }
  }

  /**
   * Indicates that the token end a section and the label of the section
   */
<span class="nc" id="L1212">  public static class SectionEndAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1215">      return String.class;</span>
    }
  }

<span class="nc" id="L1219">  public static class WordPositionAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1222">      return String.class;</span>
    }
  }

<span class="nc" id="L1226">  public static class ParaPositionAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1229">      return String.class;</span>
    }
  }

<span class="nc" id="L1233">  public static class SentencePositionAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1236">      return String.class;</span>
    }
  }

  // Why do both this and sentenceposannotation exist? I don't know, but one
  // class
  // uses both so here they remain for now...
<span class="nc" id="L1243">  public static class SentenceIDAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1246">      return String.class;</span>
    }
  }

<span class="nc" id="L1250">  public static class EntityClassAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1253">      return String.class;</span>
    }
  }

<span class="nc" id="L1257">  public static class AnswerObjectAnnotation implements CoreAnnotation&lt;Object&gt; {</span>
    @Override
    public Class&lt;Object&gt; getType() {
<span class="nc" id="L1260">      return Object.class;</span>
    }
  }

  /**
   * Used in Task3 Pascal system
   */
<span class="nc" id="L1267">  public static class BestCliquesAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1270">      return String.class;</span>
    }
  }

<span class="nc" id="L1274">  public static class BestFullAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1277">      return String.class;</span>
    }
  }

<span class="nc" id="L1281">  public static class LastTaggedAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1284">      return String.class;</span>
    }
  }

  /**
   * Used in wsd.supwsd package
   */
<span class="nc" id="L1291">  public static class LabelAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1294">      return String.class;</span>
    }
  }

<span class="nc" id="L1298">  public static class NeighborsAnnotation implements CoreAnnotation&lt;List&lt;Pair&lt;WordLemmaTag, String&gt;&gt;&gt; {</span>
    @Override
    public Class&lt;List&lt;Pair&lt;WordLemmaTag, String&gt;&gt;&gt; getType() {
<span class="nc" id="L1301">      return ErasureUtils.uncheckedCast(List.class);</span>
    }
  }

<span class="nc" id="L1305">  public static class ContextsAnnotation implements CoreAnnotation&lt;List&lt;Pair&lt;String, String&gt;&gt;&gt; {</span>
    @Override
    public Class&lt;List&lt;Pair&lt;String, String&gt;&gt;&gt; getType() {
<span class="nc" id="L1308">      return ErasureUtils.uncheckedCast(List.class);</span>
    }
  }

<span class="nc" id="L1312">  public static class DependentsAnnotation implements</span>
  CoreAnnotation&lt;List&lt;Pair&lt;Triple&lt;String, String, String&gt;, String&gt;&gt;&gt; {
    @Override
    public Class&lt;List&lt;Pair&lt;Triple&lt;String, String, String&gt;, String&gt;&gt;&gt; getType() {
<span class="nc" id="L1316">      return ErasureUtils.uncheckedCast(List.class);</span>
    }
  }

<span class="nc" id="L1320">  public static class WordFormAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1323">      return String.class;</span>
    }
  }

<span class="nc" id="L1327">  public static class TrueTagAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1330">      return String.class;</span>
    }
  }

<span class="nc" id="L1334">  public static class SubcategorizationAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1337">      return String.class;</span>
    }
  }

<span class="nc" id="L1341">  public static class BagOfWordsAnnotation implements CoreAnnotation&lt;List&lt;Pair&lt;String, String&gt;&gt;&gt; {</span>
    @Override
    public Class&lt;List&lt;Pair&lt;String, String&gt;&gt;&gt; getType() {
<span class="nc" id="L1344">      return ErasureUtils.uncheckedCast(List.class);</span>
    }
  }

  /**
   * Used in srl.unsup
   */
<span class="nc" id="L1351">  public static class HeightAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1354">      return String.class;</span>
    }
  }

<span class="nc" id="L1358">  public static class LengthAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1361">      return String.class;</span>
    }
  }

  /**
   * Used in Gale2007ChineseSegmenter
   */
<span class="nc" id="L1368">  public static class LBeginAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1371">      return String.class;</span>
    }
  }

<span class="nc" id="L1375">  public static class LMiddleAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1378">      return String.class;</span>
    }
  }

<span class="nc" id="L1382">  public static class LEndAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1385">      return String.class;</span>
    }
  }

<span class="nc" id="L1389">  public static class D2_LBeginAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1392">      return String.class;</span>
    }
  }

<span class="nc" id="L1396">  public static class D2_LMiddleAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1399">      return String.class;</span>
    }
  }

<span class="nc" id="L1403">  public static class D2_LEndAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1406">      return String.class;</span>
    }
  }

<span class="nc" id="L1410">  public static class UBlockAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1413">      return String.class;</span>
    }
  }

  /** Used in Chinese segmenters for whether there was space before a character. */
<span class="nc" id="L1418">  public static class SpaceBeforeAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1421">      return String.class;</span>
    }
  }

  /*
   * Used in parser.discrim
   */

  /**
   * The base version of the parser state, like NP or VBZ or ...
   */
<span class="nc" id="L1432">  public static class StateAnnotation implements CoreAnnotation&lt;CoreLabel&gt; {</span>
    @Override
    public Class&lt;CoreLabel&gt; getType() {
<span class="nc" id="L1435">      return CoreLabel.class;</span>
    }
  }

  /**
   * used in binarized trees to say the name of the most recent child
   */
<span class="nc" id="L1442">  public static class PrevChildAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1445">      return String.class;</span>
    }
  }

  /**
   * used in binarized trees to specify the first child in the rule for which
   * this node is the parent
   */
<span class="nc" id="L1453">  public static class FirstChildAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1456">      return String.class;</span>
    }
  }

  /**
   * whether the node is the parent in a unary rule
   */
<span class="nc" id="L1463">  public static class UnaryAnnotation implements CoreAnnotation&lt;Boolean&gt; {</span>
    @Override
    public Class&lt;Boolean&gt; getType() {
<span class="nc" id="L1466">      return Boolean.class;</span>
    }
  }

  /**
   * annotation stolen from the lex parser
   */
<span class="nc" id="L1473">  public static class DoAnnotation implements CoreAnnotation&lt;Boolean&gt; {</span>
    @Override
    public Class&lt;Boolean&gt; getType() {
<span class="nc" id="L1476">      return Boolean.class;</span>
    }
  }

  /**
   * annotation stolen from the lex parser
   */
<span class="nc" id="L1483">  public static class HaveAnnotation implements CoreAnnotation&lt;Boolean&gt; {</span>
    @Override
    public Class&lt;Boolean&gt; getType() {
<span class="nc" id="L1486">      return Boolean.class;</span>
    }
  }

  /**
   * annotation stolen from the lex parser
   */
<span class="nc" id="L1493">  public static class BeAnnotation implements CoreAnnotation&lt;Boolean&gt; {</span>
    @Override
    public Class&lt;Boolean&gt; getType() {
<span class="nc" id="L1496">      return Boolean.class;</span>
    }
  }

  /**
   * annotation stolen from the lex parser
   */
<span class="nc" id="L1503">  public static class NotAnnotation implements CoreAnnotation&lt;Boolean&gt; {</span>
    @Override
    public Class&lt;Boolean&gt; getType() {
<span class="nc" id="L1506">      return Boolean.class;</span>
    }
  }

  /**
   * annotation stolen from the lex parser
   */
<span class="nc" id="L1513">  public static class PercentAnnotation implements CoreAnnotation&lt;Boolean&gt; {</span>
    @Override
    public Class&lt;Boolean&gt; getType() {
<span class="nc" id="L1516">      return Boolean.class;</span>
    }
  }

  /**
   * specifies the base state of the parent of this node in the parse tree
   */
<span class="nc" id="L1523">  public static class GrandparentAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1526">      return String.class;</span>
    }
  }

  /**
   * The key for storing a Head word as a string rather than a pointer (as in
   * TreeCoreAnnotations.HeadWordAnnotation)
   */
<span class="nc" id="L1534">  public static class HeadWordStringAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1537">      return String.class;</span>
    }
  }

  /**
   * Used in nlp.coref
   */
<span class="nc" id="L1544">  public static class MonthAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1547">      return String.class;</span>
    }
  }

<span class="nc" id="L1551">  public static class DayAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1554">      return String.class;</span>
    }
  }

<span class="nc" id="L1558">  public static class YearAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1561">      return String.class;</span>
    }
  }

  /**
   * Used in propbank.srl
   */
<span class="nc" id="L1568">  public static class PriorAnnotation implements CoreAnnotation&lt;Map&lt;String, Double&gt;&gt; {</span>
    @Override
    public Class&lt;Map&lt;String, Double&gt;&gt; getType() {
<span class="nc" id="L1571">      return ErasureUtils.uncheckedCast(Map.class);</span>
    }
  }

<span class="nc" id="L1575">  public static class SemanticWordAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1578">      return String.class;</span>
    }
  }

<span class="nc" id="L1582">  public static class SemanticTagAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1585">      return String.class;</span>
    }
  }

<span class="nc" id="L1589">  public static class CovertIDAnnotation implements CoreAnnotation&lt;List&lt;IntPair&gt;&gt; {</span>
    @Override
    public Class&lt;List&lt;IntPair&gt;&gt; getType() {
<span class="nc" id="L1592">      return ErasureUtils.uncheckedCast(List.class);</span>
    }
  }

<span class="nc" id="L1596">  public static class ArgDescendentAnnotation implements CoreAnnotation&lt;Pair&lt;String, Double&gt;&gt; {</span>

    @Override
    public Class&lt;Pair&lt;String, Double&gt;&gt; getType() {
<span class="nc" id="L1600">      return ErasureUtils.uncheckedCast(Pair.class);</span>
    }
  }

  /**
   * Used in SimpleXMLAnnotator. The value is an XML element name String for the
   * innermost element in which this token was contained.
   */
<span class="nc" id="L1608">  public static class XmlElementAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1611">      return String.class;</span>
    }
  }

  /**
   * Used in CleanXMLAnnotator.  The value is a list of XML element names indicating
   * the XML tag the token was nested inside.
   */
<span class="nc" id="L1619">  public static class XmlContextAnnotation implements CoreAnnotation&lt;List&lt;String&gt;&gt; {</span>

    @Override
    public Class&lt;List&lt;String&gt;&gt; getType() {
<span class="nc" id="L1623">      return ErasureUtils.uncheckedCast(List.class);</span>
    }
  }

  /**
   *
   * Used for Topic Assignments from LDA or its equivalent models. The value is
   * the topic ID assigned to the current token.
   *
   */
<span class="nc" id="L1633">  public static class TopicAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1636">      return String.class;</span>
    }
  }

  // gets the synonymn of a word in the Wordnet (use a bit differently in sonalg's code)
<span class="nc" id="L1641">  public static class WordnetSynAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1644">      return String.class;</span>
    }
  }

  //to get words of the phrase
<span class="nc" id="L1649">  public static class PhraseWordsTagAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1652">      return String.class;</span>
    }
  }

  //to get pos tag of the phrase i.e. root of the phrase tree in the parse tree
<span class="nc" id="L1657">  public static class PhraseWordsAnnotation implements CoreAnnotation&lt;List&lt;String&gt;&gt; {</span>
    @Override
    public Class&lt;List&lt;String&gt;&gt; getType() {
<span class="nc" id="L1660">      return ErasureUtils.uncheckedCast(List.class);</span>
    }
  }

  //to get prototype feature, see Haghighi Exemplar driven learning
<span class="nc" id="L1665">  public static class ProtoAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1668">      return String.class;</span>
    }
  }

  //which common words list does this word belong to
<span class="nc" id="L1673">  public static class CommonWordsAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1676">      return String.class;</span>
    }
  }

  // Document date
  // Needed by SUTime
<span class="nc" id="L1682">  public static class DocDateAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1685">      return String.class;</span>
    }
  }

  /**
   * Document type
   * What kind of document is it: story, multi-part article, listing, email, etc
   */
<span class="nc" id="L1693">  public static class DocTypeAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1696">      return String.class;</span>
    }
  }

  /**
   * Document source type
   * What kind of place did the document come from: newswire, discussion forum, web...
   */
<span class="nc" id="L1704">  public static class DocSourceTypeAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1707">      return String.class;</span>
    }
  }

  /**
   * Document title
   * What is the document title
   */
<span class="nc" id="L1715">  public static class DocTitleAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1718">      return String.class;</span>
    }
  }

  /**
   * Reference location for the document
   */
<span class="nc" id="L1725">  public static class LocationAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1728">      return String.class;</span>
    }
  }

  /**
   * Author for the document
   * (really should be a set of authors, but just have single string for simplicity)
   */
<span class="nc" id="L1736">  public static class AuthorAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1739">      return String.class;</span>
    }
  }

  // Numeric annotations

  // Per token annotation indicating whether the token represents a NUMBER or ORDINAL
  // (twenty first =&gt; NUMBER ORDINAL)
<span class="nc" id="L1747">  public static class NumericTypeAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1750">      return String.class;</span>
    }
  }

  // Per token annotation indicating the numeric value of the token
  // (twenty first =&gt; 20 1)
<span class="nc" id="L1756">  public static class NumericValueAnnotation implements CoreAnnotation&lt;Number&gt; {</span>
    @Override
    public Class&lt;Number&gt; getType() {
<span class="nc" id="L1759">      return Number.class;</span>
    }
  }

  // Per token annotation indicating the numeric object associated with an annotation
<span class="nc" id="L1764">  public static class NumericObjectAnnotation implements CoreAnnotation&lt;Object&gt; {</span>
    @Override
    public Class&lt;Object&gt; getType() {
<span class="nc" id="L1767">      return Object.class;</span>
    }
  }

  // Annotation indicating whether the numeric phrase the token is part of
  // represents a NUMBER or ORDINAL (twenty first =&gt; ORDINAL ORDINAL)
<span class="nc" id="L1773">  public static class NumericCompositeValueAnnotation implements CoreAnnotation&lt;Number&gt; {</span>
    @Override
    public Class&lt;Number&gt; getType() {
<span class="nc" id="L1776">      return Number.class;</span>
    }
  }

  // Annotation indicating the numeric value of the phrase the token is part of
  // (twenty first =&gt; 21 21 )
<span class="nc" id="L1782">  public static class NumericCompositeTypeAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1785">      return String.class;</span>
    }
  }

  /** Annotation indicating the numeric object associated with an annotation. */
<span class="nc" id="L1790">  public static class NumericCompositeObjectAnnotation implements CoreAnnotation&lt;Object&gt; {</span>
    @Override
    public Class&lt;Object&gt; getType() {
<span class="nc" id="L1793">      return Object.class;</span>
    }
  }

<span class="nc" id="L1797">  public static class NumerizedTokensAnnotation implements CoreAnnotation&lt;List&lt;CoreMap&gt;&gt; {</span>
    @Override
    public Class&lt;List&lt;CoreMap&gt;&gt; getType() {
<span class="nc" id="L1800">      return ErasureUtils.uncheckedCast(List.class);</span>
    }
  }

  /**
   * used in dcoref.
   * to indicate that the it should use the discourse information annotated in the document
   */
<span class="nc" id="L1808">  public static class UseMarkedDiscourseAnnotation implements CoreAnnotation&lt;Boolean&gt; {</span>
    @Override
    public Class&lt;Boolean&gt; getType() {
<span class="nc" id="L1811">      return Boolean.class;</span>
    }
  }

  /**
   * used in dcoref.
   * to store discourse information. (marking {@code &lt;TURN&gt;} or quotation)
   */
<span class="nc" id="L1819">  public static class UtteranceAnnotation implements CoreAnnotation&lt;Integer&gt; {</span>
    @Override
    public Class&lt;Integer&gt; getType() {
<span class="nc" id="L1822">      return Integer.class;</span>
    }
  }

  /**
   * used in dcoref.
   * to store speaker information.
   */
<span class="nc" id="L1830">  public static class SpeakerAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1833">      return String.class;</span>
    }
  }

  /**
   * used in dcoref.
   * to store paragraph information.
   */
<span class="nc" id="L1841">  public static class ParagraphAnnotation implements CoreAnnotation&lt;Integer&gt; {</span>
    @Override
    public Class&lt;Integer&gt; getType() {
<span class="nc" id="L1844">      return Integer.class;</span>
    }
  }

  /**
   * used in ParagraphAnnotator.
   * to store paragraph information.
   */
<span class="nc" id="L1852">  public static class ParagraphIndexAnnotation implements CoreAnnotation&lt;Integer&gt; {</span>
    @Override
    public Class&lt;Integer&gt; getType() {
<span class="nc" id="L1855">      return Integer.class;</span>
    }
  }

  /**
   * used in dcoref.
   * to store premarked entity mentions.
   */
<span class="nc" id="L1863">  public static class MentionTokenAnnotation implements CoreAnnotation&lt;MultiTokenTag&gt; {</span>
    @Override
    public Class&lt;MultiTokenTag&gt; getType() {
<span class="nc" id="L1866">      return MultiTokenTag.class;</span>
    }
  }

  /**
   * used in incremental DAG parser
   */
<span class="nc" id="L1873">  public static class LeftChildrenNodeAnnotation implements CoreAnnotation&lt;SortedSet&lt;Pair&lt;CoreLabel, String&gt;&gt;&gt; {</span>
    @Override
    public Class&lt;SortedSet&lt;Pair&lt;CoreLabel, String&gt;&gt;&gt; getType() {
<span class="nc" id="L1876">      return ErasureUtils.uncheckedCast(SortedSet.class);</span>
    }
  }

  /**
   * Stores an exception associated with processing this document
   */
<span class="nc" id="L1883">  public static class ExceptionAnnotation implements CoreAnnotation&lt;Throwable&gt; {</span>
    @Override
    public Class&lt;Throwable&gt; getType() {
<span class="nc" id="L1886">      return ErasureUtils.uncheckedCast(Throwable.class);</span>
    }
  }


  /**
   * The CoreMap key identifying the annotation's antecedent.
   *
   * The intent of this annotation is to go with words that have been
   * linked via coref to some other entity.  For example, if &quot;dog&quot; is
   * corefed to &quot;cirrus&quot; in the sentence &quot;Cirrus, a small dog, ate an
   * entire pumpkin pie&quot;, then &quot;dog&quot; would have the
   * AntecedentAnnotation &quot;cirrus&quot;.
   *
   * This annotation is currently used ONLY in the KBP slot filling project.
   * In that project, &quot;cirrus&quot; from the example above would also have an
   * AntecedentAnnotation of &quot;cirrus&quot;.
   * Generally, you want to use the usual coref graph annotations
   */
<span class="nc" id="L1905">  public static class AntecedentAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
    public Class&lt;String&gt; getType() {
<span class="nc" id="L1908">      return String.class;</span>
    }
  }

<span class="nc" id="L1912">  public static class LabelWeightAnnotation implements CoreAnnotation&lt;Double&gt;{</span>
   @Override
   public Class&lt;Double&gt; getType(){
<span class="nc" id="L1915">     return Double.class;</span>
   }
  }

<span class="nc" id="L1919">  public static class ColumnDataClassifierAnnotation implements CoreAnnotation&lt;String&gt; {</span>
    @Override
<span class="nc" id="L1921">    public Class&lt;String&gt; getType() { return String.class; }</span>
  }

<span class="nc" id="L1924">  public static class LabelIDAnnotation implements CoreAnnotation&lt;Integer&gt;{</span>
    @Override
<span class="nc" id="L1926">    public Class&lt;Integer&gt; getType() { return Integer.class; }</span>
  }

  /**
   * An annotation for a sentence tagged with its KBP relation.
   * Attaches to a sentence.
   *
   * @see edu.stanford.nlp.pipeline.KBPAnnotator
   */
<span class="nc" id="L1935">  public static class KBPTriplesAnnotation implements CoreAnnotation&lt;List&lt;RelationTriple&gt;&gt;{</span>
    @Override
<span class="nc" id="L1937">    public Class&lt;List&lt;RelationTriple&gt;&gt; getType() { return ErasureUtils.uncheckedCast(List.class); }</span>
  }

  /**
   * An annotation for the Wikipedia page (i.e., canonical name) associated with
   * this token.
   * This is the recommended annotation to use for entity linking that links to Wikipedia.
   * Attaches to a token, as well as to a mention (see (@link MentionsAnnotation}).
   *
   * @see edu.stanford.nlp.pipeline.WikidictAnnotator
   */
<span class="nc" id="L1948">  public static class WikipediaEntityAnnotation implements CoreAnnotation&lt;String&gt;{</span>
    @Override
<span class="nc" id="L1950">    public Class&lt;String&gt; getType() { return ErasureUtils.uncheckedCast(String.class); }</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>